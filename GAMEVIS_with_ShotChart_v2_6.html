<!DOCTYPE html>
<!-- APP_VERSION: 2.6.0 -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIBA Game Visualizer - Enhanced</title>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
/* ROOT VARIABLES & BASE STYLES */
:root {
    --bg-base: #0a0b0f;
    --bg-primary: #12141a;
    --bg-card: rgba(22, 25, 35, 0.85);
    --bg-elevated: rgba(35, 40, 55, 0.9);
    --bg-glass: rgba(255, 255, 255, 0.03);
    
    --accent-cyan: #00d4ff;
    --accent-cyan-glow: rgba(0, 212, 255, 0.4);
    --accent-magenta: #ff00aa;
    --accent-magenta-glow: rgba(255, 0, 170, 0.3);
    --accent-gold: #ffd000;
    --accent-emerald: #00ff88;
    --accent-coral: #ff6b6b;
    --accent-purple: #a855f7;
    --accent-orange: #f97316;
    
    --team-home: #00d4ff;
    --team-home-bg: rgba(0, 212, 255, 0.15);
    --team-away: #ff00aa;
    --team-away-bg: rgba(255, 0, 170, 0.15);
    
    --positive: #00ff88;
    --positive-bg: rgba(0, 255, 136, 0.12);
    --negative: #ff6b6b;
    --negative-bg: rgba(255, 107, 107, 0.12);
    --warning: #ffa500;
    --warning-bg: rgba(255, 165, 0, 0.12);
    
    --text-bright: #ffffff;
    --text-primary: #e8ecf4;
    --text-secondary: #8892a8;
    --text-muted: #5a6478;
    
    --border-subtle: rgba(255, 255, 255, 0.06);
    --border-accent: rgba(0, 212, 255, 0.3);
    
    --space-xs: 4px;
    --space-sm: 8px;
    --space-md: 16px;
    --space-lg: 24px;
    --space-xl: 32px;
    --space-2xl: 48px;
    
    --radius-sm: 8px;
    --radius-md: 12px;
    --radius-lg: 20px;
}

/* Light Theme Mode - Complete Override */
body.light-theme {
    --bg-base: #f5f5f7 !important;
    --bg-primary: #ffffff !important;
    --bg-card: rgba(255, 255, 255, 0.95) !important;
    --bg-elevated: rgba(245, 245, 250, 0.95) !important;
    --bg-glass: rgba(0, 0, 0, 0.02) !important;

    --text-bright: #1a1a2e !important;
    --text-primary: #1a1a2e !important;
    --text-secondary: #4a4a5a !important;
    --text-muted: #7a7a8a !important;

    --border-subtle: rgba(0, 0, 0, 0.1) !important;
    --border-accent: rgba(0, 100, 200, 0.3) !important;

    background: #f5f5f7 !important;
}

body.light-theme::before {
    background:
        radial-gradient(ellipse 80% 50% at 20% 0%, rgba(0, 150, 255, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse 60% 40% at 80% 100%, rgba(200, 0, 150, 0.06) 0%, transparent 50%) !important;
}

/* Container and main sections */
body.light-theme .container {
    background: transparent;
}

body.light-theme .glass-card,
body.light-theme .upload-section {
    background: rgba(255, 255, 255, 0.92) !important;
    border: 1px solid rgba(0, 0, 0, 0.08) !important;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06) !important;
}

body.light-theme .stat-card,
body.light-theme .card,
body.light-theme .player-card,
body.light-theme .lineup-card {
    background: rgba(255, 255, 255, 0.95) !important;
    border-color: rgba(0, 0, 0, 0.08) !important;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.05) !important;
}

/* Headers */
body.light-theme .main-header,
body.light-theme .browser-header,
body.light-theme .game-header {
    background: rgba(255, 255, 255, 0.96) !important;
    border-color: rgba(0, 0, 0, 0.08) !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04) !important;
}

body.light-theme .card-header,
body.light-theme .section-header {
    border-color: rgba(0, 0, 0, 0.06) !important;
}

/* Modal and overlays */
body.light-theme .modal-content,
body.light-theme .modal-overlay > div {
    background: rgba(255, 255, 255, 0.98) !important;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15) !important;
}

body.light-theme #_gvAuthOverlay {
    background: #f5f5f7 !important;
}

body.light-theme #_gvAuthBox {
    background: rgba(255, 255, 255, 0.98) !important;
    box-shadow: 0 25px 80px rgba(0, 0, 0, 0.12) !important;
}

body.light-theme #_gvPwd {
    background: rgba(0, 0, 0, 0.03) !important;
    border-color: rgba(0, 0, 0, 0.15) !important;
    color: #1a1a2e !important;
}

body.light-theme ._gvLogo,
body.light-theme #_gvSubmit {
    color: #ffffff !important;
}

/* Inputs, selects, textareas */
body.light-theme input,
body.light-theme select,
body.light-theme textarea {
    background: rgba(255, 255, 255, 0.95) !important;
    border-color: rgba(0, 0, 0, 0.15) !important;
    color: #1a1a2e !important;
}

body.light-theme input::placeholder,
body.light-theme textarea::placeholder {
    color: #8a8a9a !important;
}

/* Tabs */
body.light-theme .tab-btn,
body.light-theme .quarter-tab {
    color: #4a4a5a;
}

body.light-theme .tab-btn:not(.active),
body.light-theme .quarter-tab:not(.active) {
    background: rgba(0, 0, 0, 0.03);
}

body.light-theme .tab-btn.active,
body.light-theme .quarter-tab.active {
    background: var(--accent-cyan);
    color: #ffffff !important;
}

body.light-theme .tab-container {
    background: rgba(255, 255, 255, 0.8);
    border-color: rgba(0, 0, 0, 0.06);
}

/* Buttons */
body.light-theme .btn,
body.light-theme button {
    border-color: rgba(0, 0, 0, 0.12);
}

body.light-theme .btn-primary,
body.light-theme .primary-btn {
    color: #ffffff !important;
}

/* Rows and lists */
body.light-theme .play-row,
body.light-theme .player-row,
body.light-theme .lineup-row,
body.light-theme .browser-game-card {
    border-color: rgba(0, 0, 0, 0.06) !important;
    background: rgba(255, 255, 255, 0.6);
}

body.light-theme .play-row:hover,
body.light-theme .player-row:hover,
body.light-theme .lineup-row:hover,
body.light-theme .browser-game-card:hover {
    background: rgba(0, 0, 0, 0.04) !important;
}

/* Charts and visualizations */
body.light-theme .court-container,
body.light-theme .shot-chart-container,
body.light-theme .shot-court-container,
body.light-theme .game-flow-container {
    background: rgba(255, 255, 255, 0.7) !important;
    border-color: rgba(0, 0, 0, 0.06);
}

body.light-theme .win-prob-container,
body.light-theme .battle-card,
body.light-theme .epa-section {
    background: rgba(0, 0, 0, 0.03) !important;
}

/* Dropdowns and popups */
body.light-theme .dropdown,
body.light-theme .tooltip,
body.light-theme .popup,
body.light-theme .context-menu {
    background: rgba(255, 255, 255, 0.98) !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15) !important;
    border-color: rgba(0, 0, 0, 0.08);
}

/* Loading states */
body.light-theme .loading-overlay,
body.light-theme .loading-progress-container {
    background: rgba(245, 245, 247, 0.95) !important;
}

body.light-theme .skeleton {
    background: linear-gradient(90deg, rgba(0,0,0,0.06) 25%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.06) 75%) !important;
}

/* Team input sections */
body.light-theme .team-input-section {
    background: rgba(255, 255, 255, 0.9) !important;
}

/* URL fetch and folder upload sections */
body.light-theme .url-fetch-section,
body.light-theme .folder-upload-section,
body.light-theme .win-prob-calculator-section {
    border-color: rgba(0, 0, 0, 0.08) !important;
}

/* Scoreboard */
body.light-theme .scoreboard,
body.light-theme .stats-table {
    background: rgba(255, 255, 255, 0.95) !important;
    border-color: rgba(0, 0, 0, 0.08) !important;
}

/* Table styles */
body.light-theme table,
body.light-theme th,
body.light-theme td {
    border-color: rgba(0, 0, 0, 0.08) !important;
}

body.light-theme th {
    background: rgba(0, 0, 0, 0.03) !important;
}

body.light-theme tr:hover {
    background: rgba(0, 0, 0, 0.02) !important;
}

/* ─── Light Theme: Smart Visibility Improvements ─── */

/* Buttons with shadows for better visibility */
body.light-theme .btn,
body.light-theme button:not(.tab-btn):not(.quarter-tab) {
    box-shadow: 0 2px 4px rgba(0,0,0,0.15), 0 1px 2px rgba(0,0,0,0.1) !important;
    border: 1px solid rgba(0,0,0,0.1) !important;
}
body.light-theme .btn:hover,
body.light-theme button:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.2), 0 2px 4px rgba(0,0,0,0.12) !important;
}
body.light-theme .btn-primary,
body.light-theme .primary-btn,
body.light-theme .fetch-btn,
body.light-theme .load-btn {
    background: linear-gradient(135deg, #1d4ed8, #2563eb) !important;
    color: #ffffff !important;
}
body.light-theme .btn-secondary {
    background: #374151 !important;
    color: #ffffff !important;
}
body.light-theme .btn-success {
    background: #047857 !important;
    color: #ffffff !important;
}
body.light-theme .btn-danger {
    background: #b91c1c !important;
    color: #ffffff !important;
}

/* Team color indicators - make more visible */
body.light-theme .team-home,
body.light-theme [class*="home-team"] {
    color: var(--accent-cyan) !important;
    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
body.light-theme .team-away,
body.light-theme [class*="away-team"] {
    color: var(--accent-magenta) !important;
    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

/* Score and stat values - ensure readability */
body.light-theme .score,
body.light-theme .stat-value,
body.light-theme .big-stat {
    color: #1a1a2e !important;
    font-weight: 700;
}

/* Performance/percentile cells with better contrast */
body.light-theme .perf-excellent,
body.light-theme .pct-excellent,
body.light-theme [class*="percentile-80"] {
    background: rgba(22, 163, 74, 0.85) !important;
    color: #ffffff !important;
}
body.light-theme .perf-good,
body.light-theme .pct-good,
body.light-theme [class*="percentile-60"] {
    background: rgba(132, 204, 22, 0.9) !important;
    color: #1a1a2e !important;
}
body.light-theme .perf-average,
body.light-theme .pct-avg,
body.light-theme [class*="percentile-neutral"] {
    background: rgba(234, 179, 8, 0.9) !important;
    color: #1a1a2e !important;
}
body.light-theme .perf-below,
body.light-theme .pct-below,
body.light-theme [class*="percentile-40"] {
    background: rgba(249, 115, 22, 0.9) !important;
    color: #ffffff !important;
}
body.light-theme .perf-poor,
body.light-theme .pct-poor,
body.light-theme [class*="percentile-20"] {
    background: rgba(220, 38, 38, 0.85) !important;
    color: #ffffff !important;
}

/* Badges and tags */
body.light-theme [class*="badge"],
body.light-theme [class*="tag"],
body.light-theme [class*="pill"],
body.light-theme [class*="chip"] {
    box-shadow: 0 1px 3px rgba(0,0,0,0.12) !important;
    border: 1px solid rgba(0,0,0,0.08) !important;
}

/* Play-by-play event types */
body.light-theme .play-made,
body.light-theme .event-made,
body.light-theme [class*="made"] {
    background: rgba(22, 163, 74, 0.2) !important;
    border-left: 3px solid #16a34a !important;
}
body.light-theme .play-missed,
body.light-theme .event-missed,
body.light-theme [class*="missed"] {
    background: rgba(220, 38, 38, 0.15) !important;
    border-left: 3px solid #dc2626 !important;
}
body.light-theme .play-turnover,
body.light-theme .event-turnover {
    background: rgba(234, 179, 8, 0.2) !important;
    border-left: 3px solid #ca8a04 !important;
}
body.light-theme .play-foul,
body.light-theme .event-foul {
    background: rgba(249, 115, 22, 0.2) !important;
    border-left: 3px solid #ea580c !important;
}

/* Quarter/period tabs */
body.light-theme .quarter-tab:not(.active) {
    background: rgba(0, 0, 0, 0.05) !important;
    color: #4a4a5a !important;
    border: 1px solid rgba(0,0,0,0.1) !important;
}
body.light-theme .quarter-tab.active {
    box-shadow: 0 2px 6px rgba(0,0,0,0.15) !important;
}

/* Shot chart elements */
body.light-theme .shot-made {
    fill: #16a34a !important;
    stroke: #15803d !important;
}
body.light-theme .shot-missed {
    fill: #dc2626 !important;
    stroke: #b91c1c !important;
}

/* Win probability bar */
body.light-theme .win-prob-bar {
    background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta)) !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
}

/* Game flow chart background */
body.light-theme .game-flow-container {
    background: rgba(255, 255, 255, 0.9) !important;
    border: 1px solid rgba(0,0,0,0.1) !important;
}

/* Player cards in lineups */
body.light-theme .player-avatar,
body.light-theme .player-img {
    background: linear-gradient(135deg, #e0e0e4, #c8c8cc) !important;
    border: 2px solid #b0b0b8 !important;
    color: var(--accent-cyan) !important;
}

/* Positive/negative values */
body.light-theme .positive,
body.light-theme [style*="color: #22c55e"],
body.light-theme [style*="color: rgb(34, 197, 94)"],
body.light-theme [style*="color:#22c55e"] {
    color: #16a34a !important;
    font-weight: 600;
}
body.light-theme .negative,
body.light-theme [style*="color: #ef4444"],
body.light-theme [style*="color: rgb(239, 68, 68)"],
body.light-theme [style*="color:#ef4444"] {
    color: #dc2626 !important;
    font-weight: 600;
}

/* Links */
body.light-theme a {
    color: var(--accent-cyan) !important;
}
body.light-theme a:hover {
    color: #0e7490 !important;
    text-decoration: underline;
}

/* Scrollbar for light theme */
body.light-theme ::-webkit-scrollbar-track {
    background: #f0f0f2 !important;
}
body.light-theme ::-webkit-scrollbar-thumb {
    background: #c0c0c8 !important;
    border-radius: 4px;
}
body.light-theme ::-webkit-scrollbar-thumb:hover {
    background: #a0a0a8 !important;
}

/* Selection highlight */
body.light-theme ::selection {
    background: rgba(var(--theme-primary-rgb, 59, 130, 246), 0.3) !important;
    color: #1a1a2e !important;
}

/* Tooltip improvements */
body.light-theme .tooltip-content,
body.light-theme [class*="tooltip"] {
    background: rgba(255, 255, 255, 0.98) !important;
    color: #1a1a2e !important;
    border: 1px solid rgba(0,0,0,0.12) !important;
    box-shadow: 0 4px 16px rgba(0,0,0,0.15) !important;
}

/* Legend items */
body.light-theme .legend-item,
body.light-theme [class*="legend"] {
    color: #1a1a2e !important;
}

/* Section titles and headers */
body.light-theme .section-title,
body.light-theme .card-title,
body.light-theme h1, body.light-theme h2, body.light-theme h3, body.light-theme h4 {
    color: #1a1a2e !important;
}

/* Muted/secondary text */
body.light-theme .text-muted,
body.light-theme .text-secondary,
body.light-theme small {
    color: #6a6a7a !important;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

/* ═══════════════════════════════════════════════════════════════════════════
   PASSWORD PROTECTION SYSTEM v3.1 - STYLES
   ═══════════════════════════════════════════════════════════════════════════ */
#_gvAuthOverlay{position:fixed;inset:0;background:var(--bg-base);z-index:999999;display:flex;align-items:center;justify-content:center}
#_gvAuthOverlay::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse 80% 50% at 20% 0%,rgba(0,212,255,0.08) 0%,transparent 50%),radial-gradient(ellipse 60% 40% at 80% 100%,rgba(255,0,170,0.06) 0%,transparent 50%);pointer-events:none}
#_gvAuthBox{background:var(--bg-card);backdrop-filter:blur(20px);border:1px solid var(--border-subtle);border-radius:24px;padding:48px;width:420px;text-align:center;position:relative;z-index:10;box-shadow:0 25px 80px rgba(0,0,0,0.5)}
#_gvAuthBox::before{content:'';position:absolute;top:-1px;left:-1px;right:-1px;height:3px;background:linear-gradient(90deg,var(--accent-cyan),var(--accent-magenta));border-radius:24px 24px 0 0}
._gvLogo{width:80px;height:80px;margin:0 auto 24px;background:linear-gradient(135deg,var(--accent-cyan),var(--accent-magenta));border-radius:20px;display:flex;align-items:center;justify-content:center;font-size:32px;font-weight:700;color:var(--bg-base)}
._gvTitle{font-family:'Space Grotesk',sans-serif;font-size:24px;font-weight:600;margin-bottom:8px;color:var(--text-primary)}
._gvSub{color:var(--text-secondary);font-size:14px;margin-bottom:32px}
#_gvPwd{width:100%;padding:16px 20px;background:rgba(255,255,255,0.05);border:1px solid var(--border-subtle);border-radius:12px;color:var(--text-primary);font-size:16px;font-family:inherit;outline:none;transition:all 0.3s ease;margin-bottom:16px}
#_gvPwd:focus{border-color:var(--accent-cyan);box-shadow:0 0 0 3px rgba(0,212,255,0.15)}
#_gvPwd::placeholder{color:var(--text-secondary)}
#_gvSubmit{width:100%;padding:16px;background:linear-gradient(135deg,var(--accent-cyan),#0099cc);border:none;border-radius:12px;color:var(--bg-base);font-size:16px;font-weight:600;font-family:'Space Grotesk',sans-serif;cursor:pointer;transition:all 0.3s ease}
#_gvSubmit:hover{transform:translateY(-2px);box-shadow:0 8px 25px rgba(0,212,255,0.3)}
#_gvSubmit:disabled{opacity:0.5;cursor:not-allowed;transform:none}
._gvErr{color:#ff6b6b;font-size:13px;margin-top:16px;min-height:20px}
._gvLock{color:var(--text-secondary);font-size:12px;margin-top:24px;padding-top:24px;border-top:1px solid var(--border-subtle)}
@keyframes _gvShake{0%,100%{transform:translateX(0)}25%{transform:translateX(-10px)}75%{transform:translateX(10px)}}
._gvShake{animation:_gvShake 0.4s ease-in-out}
.gv-protected-hidden{display:none!important}

/* ═══════════════════════════════════════════════════════════════════════════
   PLAYER/TEAM PHOTO STYLES
   ═══════════════════════════════════════════════════════════════════════════ */
.player-photo {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    background: var(--bg-elevated);
    border: 2px solid var(--accent-cyan);
    flex-shrink: 0;
}
.player-photo-placeholder {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--team-home-bg), var(--team-away-bg));
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: bold;
    color: var(--accent-cyan);
    flex-shrink: 0;
    border: 2px solid var(--border-subtle);
}
.player-photo-loading {
    animation: pulse 1.5s ease-in-out infinite;
}
@keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
.team-logo {
    width: 32px;
    height: 32px;
    border-radius: var(--radius-sm);
    object-fit: contain;
    background: var(--bg-glass);
}
.team-logo-sm {
    width: 20px;
    height: 20px;
    border-radius: 4px;
}
.player-row-photo {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}
/* ═══════════════════════════════════════════════════════════════════════════ */

html {
    scroll-behavior: smooth;
}

body {
    font-family: 'DM Sans', sans-serif;
    background: var(--bg-base);
    color: var(--text-primary);
    min-height: 100vh;
    line-height: 1.5;
    overflow-x: hidden;
}

body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: 
        radial-gradient(ellipse 80% 50% at 20% 0%, rgba(0, 212, 255, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse 60% 40% at 80% 100%, rgba(255, 0, 170, 0.06) 0%, transparent 50%);
    pointer-events: none;
    z-index: 0;
}

/* ========================================================================
   MULTI-VIEW NAVIGATION SYSTEM
   ======================================================================== */

.app-view {
    position: fixed;
    inset: 0;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.25s ease, visibility 0.25s ease;
    z-index: 10;
    overflow-y: auto;
    background: var(--bg-base);
}

.app-view.active {
    opacity: 1;
    visibility: visible;
}

.app-view:not(.active) {
    pointer-events: none;
}

/* View: Upload/Splash */
#view-upload {
    z-index: 10;
}

/* View: Game Browser */
#view-browser {
    z-index: 11;
    background: var(--bg-base);
}

#view-browser::before {
    content: '';
    position: fixed;
    inset: 0;
    background: 
        radial-gradient(ellipse 80% 50% at 20% 0%, rgba(168, 85, 247, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse 60% 40% at 80% 100%, rgba(0, 212, 255, 0.06) 0%, transparent 50%);
    pointer-events: none;
    z-index: 0;
}

/* View: Game Visualizer */
#view-game {
    z-index: 12;
}

/* Back Navigation Button */
.nav-back-btn {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 20px;
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    color: var(--text-secondary);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.nav-back-btn:hover {
    background: var(--bg-card);
    border-color: var(--accent-cyan);
    color: var(--accent-cyan);
}

.nav-back-btn .back-icon {
    font-size: 16px;
}

/* Game Browser Full Page Styles */
.browser-view-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 80px var(--space-xl) var(--space-xl);
    position: relative;
    z-index: 1;
}

.browser-header {
    text-align: center;
    margin-bottom: var(--space-2xl);
}

.browser-header h1 {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 2.5rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: var(--space-sm);
}

.browser-header .subtitle {
    color: var(--text-secondary);
    font-size: 1rem;
}

.browser-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: var(--space-lg);
    margin-bottom: var(--space-xl);
    padding: var(--space-md) var(--space-lg);
    background: var(--bg-elevated);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-subtle);
}

.browser-count {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-size: 14px;
    color: var(--text-secondary);
}

.browser-count .count-num {
    background: linear-gradient(135deg, var(--accent-purple), var(--accent-magenta));
    color: white;
    padding: 4px 12px;
    border-radius: 20px;
    font-weight: 700;
    font-size: 13px;
}

.browser-filter-select {
    padding: 10px 16px;
    background: var(--bg-base);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    font-size: 13px;
    min-width: 220px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.browser-filter-select:hover {
    border-color: var(--accent-cyan);
}

.browser-filter-select:focus {
    outline: none;
    border-color: var(--accent-cyan);
    box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
}

/* Full Page Game List */
.browser-game-list {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
    contain: content; /* Optimize paint */
}

.browser-game-card {
    background: var(--bg-card);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    overflow: hidden;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
    contain: layout style; /* Optimize reflows */
}

.browser-game-card:hover {
    border-color: var(--accent-cyan);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
}

.browser-game-main {
    display: grid;
    grid-template-columns: 1fr auto 1fr auto auto;
    align-items: center;
    gap: var(--space-lg);
    padding: var(--space-lg) var(--space-xl);
    cursor: pointer;
}

.browser-team {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.browser-team.home {
    text-align: left;
}

.browser-team.away {
    text-align: right;
}

.browser-team-name {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-bright);
}

.browser-team.home .browser-team-name {
    color: var(--team-home);
}

.browser-team.away .browser-team-name {
    color: var(--team-away);
}

.browser-score-block {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    padding: 0 var(--space-lg);
}

.browser-score {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 2rem;
    font-weight: 700;
}

.browser-score.home {
    color: var(--team-home);
}

.browser-score.away {
    color: var(--team-away);
}

.browser-score-divider {
    width: 2px;
    height: 40px;
    background: linear-gradient(to bottom, var(--team-home), var(--team-away));
    border-radius: 2px;
}

.browser-date {
    font-size: 13px;
    color: var(--text-muted);
    font-family: 'Space Mono', monospace;
    min-width: 80px;
    text-align: center;
}

.browser-load-btn {
    padding: 12px 24px;
    background: linear-gradient(135deg, var(--accent-cyan), rgba(0, 212, 255, 0.7));
    border: none;
    border-radius: var(--radius-sm);
    color: var(--bg-base);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 13px;
    font-weight: 700;
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
    white-space: nowrap;
    min-width: 100px;
}

.browser-load-btn:hover:not(:disabled) {
    transform: scale(1.02);
    box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
}

.browser-load-btn:disabled {
    opacity: 0.7;
    cursor: wait;
}

/* Expandable details */
.browser-game-details {
    display: none;
    padding: 0 var(--space-xl) var(--space-lg);
    background: var(--bg-elevated);
    border-top: 1px solid var(--border-subtle);
}

.browser-game-card.expanded .browser-game-details {
    display: block;
}

.browser-game-card.expanded .browser-caret {
    transform: rotate(90deg);
}

.browser-caret {
    color: var(--text-muted);
    transition: transform 0.3s ease;
    font-size: 12px;
}

.browser-four-factors {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--space-lg);
    padding: var(--space-md) 0;
}

.browser-factor-item {
    text-align: center;
    padding: var(--space-md);
    background: var(--bg-glass);
    border-radius: var(--radius-sm);
}

.browser-factor-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-muted);
    margin-bottom: var(--space-xs);
}

.browser-factor-values {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: var(--space-sm);
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 600;
}

.browser-factor-values .home {
    color: var(--team-home);
}

.browser-factor-values .away {
    color: var(--team-away);
}

.container {
    max-width: 1900px;
    margin: 0 auto;
    padding: var(--space-xl);
    position: relative;
    z-index: 1;
}

.glass-card {
    background: var(--bg-card);
    backdrop-filter: blur(20px);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-lg);
    position: relative;
    overflow: hidden;
}

/* TABS */
.tab-container {
    display: flex;
    gap: var(--space-sm);
    margin-bottom: var(--space-lg);
    padding: var(--space-sm);
    background: rgba(15, 23, 42, 0.95);
    border-radius: var(--radius-md);
    width: fit-content;
    position: sticky;
    top: var(--space-md);
    z-index: 100;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    border: 1px solid var(--border-subtle);
}

.tab-btn {
    padding: 12px 24px;
    background: transparent;
    border: none;
    color: var(--text-secondary);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    border-radius: var(--radius-sm);
    transition: all 0.3s ease;
}

.tab-btn:hover {
    background: var(--bg-glass);
    color: var(--text-primary);
}

.tab-btn.active {
    background: linear-gradient(135deg, var(--accent-cyan), rgba(0, 212, 255, 0.7));
    color: var(--bg-base);
}

.tab-content-wrapper {
    position: relative;
    overflow: hidden;
}

.tab-content {
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.4s ease, transform 0.4s ease;
    visibility: hidden;
    pointer-events: none;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
}

.tab-content.active {
    opacity: 1;
    transform: translateY(0);
    position: relative;
    visibility: visible;
    pointer-events: auto;
}

/* HEADER */
.game-header {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: var(--space-2xl);
    padding: var(--space-xl) var(--space-2xl);
    margin-bottom: var(--space-xl);
    align-items: center;
}

.team-block {
    display: flex;
    align-items: center;
    gap: var(--space-lg);
}

.team-block.away {
    flex-direction: row-reverse;
    text-align: right;
}

.team-logo {
    width: 80px;
    height: 80px;
    border-radius: var(--radius-md);
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Space Grotesk', sans-serif;
    font-size: 24px;
    font-weight: 700;
}

.team-logo.home {
    background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(0, 212, 255, 0.05));
    border: 1px solid rgba(0, 212, 255, 0.3);
    color: var(--team-home);
    box-shadow: 0 0 30px rgba(0, 212, 255, 0.2);
}

.team-logo.away {
    background: linear-gradient(135deg, rgba(255, 0, 170, 0.2), rgba(255, 0, 170, 0.05));
    border: 1px solid rgba(255, 0, 170, 0.3);
    color: var(--team-away);
    box-shadow: 0 0 30px rgba(255, 0, 170, 0.2);
}

.team-content h2 {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 28px;
    font-weight: 700;
    color: var(--text-bright);
    margin-bottom: var(--space-sm);
}

.result-tag {
    display: inline-flex;
    align-items: center;
    gap: var(--space-xs);
    padding: 6px 14px;
    border-radius: 100px;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.result-tag.win {
    background: var(--positive-bg);
    color: var(--positive);
    border: 1px solid rgba(0, 255, 136, 0.3);
}

.result-tag.loss {
    background: var(--negative-bg);
    color: var(--negative);
    border: 1px solid rgba(255, 107, 107, 0.3);
}

.result-tag::before {
    content: '';
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: currentColor;
}

.score-center { text-align: center; }

.score-display {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-md);
    margin-bottom: var(--space-md);
}

.score-value {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 72px;
    font-weight: 700;
    line-height: 1;
}

.score-value.home {
    color: var(--team-home);
    text-shadow: 0 0 40px var(--accent-cyan-glow);
}

.score-value.away {
    color: var(--team-away);
    text-shadow: 0 0 40px var(--accent-magenta-glow);
}

.score-divider {
    width: 3px;
    height: 48px;
    background: linear-gradient(180deg, var(--team-home), var(--team-away));
    border-radius: 2px;
    opacity: 0.6;
}

.match-meta {
    font-size: 13px;
    color: var(--text-muted);
    margin-bottom: var(--space-md);
}

.pace-indicator {
    display: inline-flex;
    align-items: center;
    gap: var(--space-sm);
    padding: 8px 18px;
    background: var(--bg-elevated);
    border-radius: 100px;
    font-size: 13px;
    color: var(--text-secondary);
    border: 1px solid var(--border-subtle);
}

.pace-indicator .value {
    font-family: 'Space Mono', monospace;
    color: var(--accent-gold);
    font-weight: 600;
}

/* STATS GRID */
.stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-lg);
    margin-bottom: var(--space-xl);
}

.stat-card {
    padding: var(--space-lg);
}

.stat-card.full-width {
    grid-column: span 2;
}

.card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: var(--space-lg);
    padding-bottom: var(--space-md);
    border-bottom: 1px solid var(--border-subtle);
}

.card-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-secondary);
}

.team-legend {
    display: flex;
    gap: var(--space-lg);
}

.legend-item {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-size: 12px;
    font-weight: 500;
}

.legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
}

.legend-dot.home {
    background: var(--team-home);
    box-shadow: 0 0 10px var(--accent-cyan-glow);
}

.legend-dot.away {
    background: var(--team-away);
    box-shadow: 0 0 10px var(--accent-magenta-glow);
}

.factors-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: var(--space-md);
}

.factor-block {
    text-align: center;
    padding: var(--space-md);
    background: var(--bg-glass);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-subtle);
    transition: all 0.3s ease;
}

.factor-block:hover {
    border-color: var(--border-accent);
    transform: translateY(-2px);
}

.factor-values {
    display: flex;
    justify-content: center;
    gap: var(--space-lg);
    margin-bottom: var(--space-sm);
}

.factor-val {
    font-family: 'Space Mono', monospace;
    font-size: 22px;
    font-weight: 700;
}

.factor-val.home { color: var(--team-home); }
.factor-val.away { color: var(--team-away); }
.factor-val.home.winner { text-shadow: 0 0 20px var(--accent-cyan-glow); }
.factor-val.away.winner { text-shadow: 0 0 20px var(--accent-magenta-glow); }

.factor-label {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-muted);
}

/* Four Factors Bars on Top */
.factor-bar-top {
    display: flex;
    gap: var(--space-md);
    margin-bottom: var(--space-sm);
}

.factor-bar-bg {
    flex: 1;
    height: 6px;
    background: var(--bg-elevated);
    border-radius: 3px;
    overflow: hidden;
}

.factor-bar-fill {
    height: 100%;
    border-radius: 3px;
    transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.factor-bar-fill.home {
    background: linear-gradient(90deg, var(--team-home), rgba(0, 212, 255, 0.5));
}

.factor-bar-fill.away {
    background: linear-gradient(90deg, var(--team-away), rgba(255, 0, 170, 0.5));
}

/* Battle Metrics */
.battle-metrics {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-lg);
    margin-bottom: var(--space-xl);
    padding-bottom: var(--space-lg);
    border-bottom: 1px solid var(--border-subtle);
}

@media (max-width: 700px) {
    .battle-metrics {
        grid-template-columns: 1fr;
    }
}

.battle-card {
    background: var(--bg-glass);
    border-radius: var(--radius-md);
    padding: var(--space-lg);
    border: 1px solid var(--border-subtle);
    position: relative;
    overflow: hidden;
}

.battle-card.home-advantage {
    border-color: rgba(0, 212, 255, 0.3);
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.1);
}

.battle-card.away-advantage {
    border-color: rgba(255, 0, 128, 0.3);
    box-shadow: 0 0 20px rgba(255, 0, 128, 0.1);
}

.battle-icon {
    font-size: 24px;
    margin-bottom: var(--space-sm);
}

.battle-content {
    margin-bottom: var(--space-md);
}

.battle-label {
    font-size: 14px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-primary);
    margin-bottom: var(--space-xs);
}

.battle-value {
    font-family: 'Space Mono', monospace;
    font-size: 32px;
    font-weight: 700;
    line-height: 1;
    margin-bottom: var(--space-xs);
}

.battle-value.positive {
    color: var(--team-home);
    text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
}

.battle-value.negative {
    color: var(--team-away);
    text-shadow: 0 0 20px rgba(255, 0, 128, 0.5);
}

.battle-unit {
    font-size: 14px;
    font-weight: 500;
    opacity: 0.7;
}

.battle-detail {
    font-size: 10px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.battle-bar-container {
    height: 8px;
    background: linear-gradient(90deg, var(--team-home) 0%, var(--bg-elevated) 50%, var(--team-away) 100%);
    border-radius: 4px;
    margin-bottom: var(--space-sm);
    position: relative;
    overflow: hidden;
}

.battle-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: var(--team-home);
    border-radius: 4px 0 0 4px;
    transition: width 0.6s ease;
}

.battle-bar::after {
    content: '';
    position: absolute;
    right: 0;
    top: 0;
    width: 3px;
    height: 100%;
    background: white;
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
}

.battle-teams {
    display: flex;
    justify-content: space-between;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.battle-teams .home {
    color: var(--team-home);
}

.battle-teams .away {
    color: var(--team-away);
}

.metrics-list {
    display: flex;
    flex-direction: column;
    gap: var(--space-lg);
}

.metric-row {
    display: grid;
    grid-template-columns: 80px 1fr 80px;
    gap: var(--space-md);
    align-items: center;
}

.metric-value {
    font-family: 'Space Mono', monospace;
    font-size: 18px;
    font-weight: 700;
}

.metric-value.home { color: var(--team-home); text-align: right; }
.metric-value.away { color: var(--team-away); text-align: left; }

.metric-center {
    display: flex;
    flex-direction: column;
    gap: var(--space-xs);
}

.metric-label {
    text-align: center;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-muted);
}

.metric-bars {
    display: flex;
    height: 8px;
    border-radius: 4px;
    overflow: hidden;
    background: var(--bg-elevated);
}

.metric-bar {
    height: 100%;
    transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.metric-bar.home {
    background: linear-gradient(90deg, transparent, var(--team-home));
}

.metric-bar.away {
    background: linear-gradient(90deg, var(--team-away), transparent);
}

/* Metrics separator */
.metrics-separator {
    display: flex;
    align-items: center;
    gap: 12px;
    margin: 8px 0 4px 0;
    padding: 0 60px;
}

.metrics-separator .separator-line {
    flex: 1;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--border-accent), transparent);
}

.metrics-separator .separator-label {
    font-size: 9px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-muted);
    white-space: nowrap;
}

/* Game Browser Styles */
.game-browser-item {
    border-bottom: 1px solid var(--border-subtle);
    transition: background 0.2s ease;
}

.game-browser-item:last-child {
    border-bottom: none;
}

.game-browser-item:hover {
    background: var(--bg-glass);
}

.game-browser-main {
    display: flex;
    align-items: center;
    padding: 16px;
    cursor: pointer;
    gap: 16px;
}

.game-browser-caret {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: var(--text-muted);
    transition: transform 0.2s ease;
    flex-shrink: 0;
}

.game-browser-item.expanded .game-browser-caret {
    transform: rotate(90deg);
}

.game-browser-teams {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
}

.game-browser-team {
    flex: 1;
    text-align: center;
}

.game-browser-team.home {
    text-align: right;
}

.game-browser-team.away {
    text-align: left;
}

.game-browser-team-name {
    font-size: 14px;
    font-weight: 700;
    color: var(--text-bright);
    margin-bottom: 4px;
}

.game-browser-team.home .game-browser-team-name {
    color: var(--team-home);
}

.game-browser-team.away .game-browser-team-name {
    color: var(--team-away);
}

.game-browser-score {
    display: flex;
    align-items: center;
    gap: 8px;
    font-family: 'Space Mono', monospace;
    font-size: 20px;
    font-weight: 800;
    flex-shrink: 0;
}

.game-browser-score .home-score {
    color: var(--team-home);
    min-width: 36px;
    text-align: right;
}

.game-browser-score .away-score {
    color: var(--team-away);
    min-width: 36px;
    text-align: left;
}

.game-browser-score .score-divider {
    color: var(--text-muted);
    font-size: 14px;
}

.game-browser-date {
    font-size: 11px;
    color: var(--text-muted);
    text-align: right;
    flex-shrink: 0;
    min-width: 80px;
}

.game-browser-load {
    padding: 6px 12px;
    background: var(--accent-cyan);
    color: var(--bg-base);
    border: none;
    border-radius: var(--radius-sm);
    font-size: 11px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
}

.game-browser-load:hover {
    background: var(--team-home);
    transform: scale(1.05);
}

.game-browser-details {
    display: none;
    padding: 0 16px 16px 56px;
    background: var(--bg-base);
}

.game-browser-item.expanded .game-browser-details {
    display: block;
}

.game-browser-four-factors {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
}

.four-factor-item {
    background: var(--bg-glass);
    border-radius: var(--radius-sm);
    padding: 12px;
    text-align: center;
}

.four-factor-label {
    font-size: 10px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
}

.four-factor-values {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
}

.four-factor-value {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 700;
}

.four-factor-value.home {
    color: var(--team-home);
}

.four-factor-value.away {
    color: var(--team-away);
}

.four-factor-vs {
    color: var(--text-muted);
    font-size: 10px;
}

.four-factor-winner {
    font-size: 10px;
    margin-top: 4px;
}

.four-factor-winner.home {
    color: var(--team-home);
}

.four-factor-winner.away {
    color: var(--team-away);
}

/* PLAYER TABLE - EXPANDED */
.team-section {
    margin-bottom: var(--space-xl);
}

.team-section-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--space-lg) var(--space-xl);
    border-bottom: 1px solid var(--border-subtle);
}

.team-section-header h3 {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 20px;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: var(--space-md);
}

.team-indicator {
    width: 4px;
    height: 24px;
    border-radius: 2px;
}

.team-indicator.home {
    background: var(--team-home);
    box-shadow: 0 0 15px var(--accent-cyan-glow);
}

.team-indicator.away {
    background: var(--team-away);
    box-shadow: 0 0 15px var(--accent-magenta-glow);
}

.points-badge {
    padding: 8px 20px;
    border-radius: 100px;
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 700;
}

.points-badge.win {
    background: var(--positive-bg);
    color: var(--positive);
    border: 1px solid rgba(0, 255, 136, 0.3);
}

.points-badge.loss {
    background: var(--negative-bg);
    color: var(--negative);
    border: 1px solid rgba(255, 107, 107, 0.3);
}

/* WIN PROBABILITY CARD */
.win-probability-card {
    margin-bottom: var(--space-xl);
}

.win-prob-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-lg);
}

.win-prob-title {
    font-size: 18px;
    font-weight: 700;
    color: var(--text-bright);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}

.win-prob-subtitle {
    font-size: 11px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.blowout-tag {
    background: linear-gradient(135deg, var(--accent-gold), var(--accent-orange));
    color: var(--bg-base);
    padding: 4px 12px;
    border-radius: 100px;
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 1px;
    margin-left: 12px;
    animation: pulse-glow 2s ease-in-out infinite;
}

@keyframes pulse-glow {
    0%, 100% { box-shadow: 0 0 10px rgba(255, 208, 0, 0.4); }
    50% { box-shadow: 0 0 25px rgba(255, 208, 0, 0.8); }
}

.confidence-badge {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
}

.confidence-label {
    color: var(--text-muted);
}

.confidence-value {
    font-weight: 700;
    font-family: 'Space Grotesk', sans-serif;
}

.win-prob-container {
    display: flex;
    align-items: center;
    gap: var(--space-lg);
}

.win-prob-team {
    flex: 0 0 auto;
    text-align: center;
    min-width: 140px;
}

.win-prob-team-name {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
    margin-bottom: var(--space-xs);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.win-prob-value {
    font-family: 'Space Mono', monospace;
    font-size: 36px;
    font-weight: 700;
}

.win-prob-value.home {
    color: var(--team-home);
    text-shadow: 0 0 20px var(--accent-cyan-glow);
}

.win-prob-value.away {
    color: var(--team-away);
    text-shadow: 0 0 20px var(--accent-magenta-glow);
}

.win-prob-value.dominant {
    animation: winner-pulse 1.5s ease-in-out infinite;
}

@keyframes winner-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
}

.win-prob-ppp {
    margin-top: 8px;
    font-size: 12px;
}

.ppp-label {
    color: var(--text-muted);
    margin-right: 4px;
}

.ppp-value {
    font-family: 'Space Mono', monospace;
    font-weight: 600;
}

.ppp-value.home { color: var(--team-home); }
.ppp-value.away { color: var(--team-away); }

.win-prob-bar-container {
    flex: 1;
    position: relative;
    height: 50px;
    background: var(--bg-elevated);
    border-radius: var(--radius-md);
    overflow: hidden;
    border: 1px solid var(--border-subtle);
}

.win-prob-bar {
    position: absolute;
    top: 0;
    height: 100%;
    transition: width 0.5s ease;
}

.win-prob-bar.home {
    left: 0;
    background: linear-gradient(90deg, var(--team-home), rgba(0, 212, 255, 0.4));
    border-radius: var(--radius-md) 0 0 var(--radius-md);
}

.win-prob-bar.away {
    right: 0;
    background: linear-gradient(270deg, var(--team-away), rgba(255, 0, 128, 0.4));
    border-radius: 0 var(--radius-md) var(--radius-md) 0;
}

.win-prob-margin {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--bg-card);
    padding: 8px 16px;
    border-radius: var(--radius-sm);
    text-align: center;
    border: 1px solid var(--border-subtle);
    z-index: 5;
}

.win-prob-margin .margin-label {
    display: block;
    font-size: 9px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.win-prob-margin .margin-value {
    font-family: 'Space Mono', monospace;
    font-size: 16px;
    font-weight: 700;
}

.win-prob-margin .margin-value.home { color: var(--team-home); }
.win-prob-margin .margin-value.away { color: var(--team-away); }

.win-prob-factors {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--space-md);
    margin-top: var(--space-lg);
    padding-top: var(--space-lg);
    border-top: 1px solid var(--border-subtle);
}

.win-prob-factor {
    text-align: center;
    padding: var(--space-md);
    background: var(--bg-elevated);
    border-radius: var(--radius-sm);
}

.win-prob-factor-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
}

.win-prob-factor-label {
    font-size: 10px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.win-prob-factor-winner {
    font-size: 10px;
}

.win-prob-factor.home-advantage .win-prob-factor-winner {
    color: var(--team-home);
}

.win-prob-factor.away-advantage .win-prob-factor-winner {
    color: var(--team-away);
}

.win-prob-factor-values {
    display: flex;
    justify-content: center;
    gap: var(--space-md);
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 600;
}

.win-prob-factor-value.home {
    color: var(--team-home);
}

.win-prob-factor-value.away {
    color: var(--team-away);
}

.win-prob-factor-value.winner {
    text-shadow: 0 0 10px currentColor;
}

.win-prob-factor-diff {
    font-size: 11px;
    margin-top: var(--space-xs);
    font-family: 'Space Mono', monospace;
}

.win-prob-factor-diff.positive {
    color: var(--positive);
}

.win-prob-factor-diff.negative {
    color: var(--negative);
}

.impact-bar-container {
    height: 4px;
    background: var(--bg-base);
    border-radius: 2px;
    margin: 6px 0 4px;
    overflow: hidden;
}

.impact-bar {
    height: 100%;
    border-radius: 2px;
    transition: width 0.5s ease;
}

.impact-bar.home {
    background: linear-gradient(90deg, var(--team-home), rgba(0, 212, 255, 0.5));
}

.impact-bar.away {
    background: linear-gradient(90deg, var(--team-away), rgba(255, 0, 170, 0.5));
}

.win-prob-factor-weight {
    font-size: 9px;
    color: var(--text-muted);
    margin-top: 2px;
}

.simulation-details {
    display: flex;
    justify-content: center;
    gap: var(--space-xl);
    margin-top: var(--space-lg);
    padding-top: var(--space-lg);
    border-top: 1px solid var(--border-subtle);
}

.sim-stat {
    text-align: center;
}

.sim-label {
    display: block;
    font-size: 10px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
}

.sim-value {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-secondary);
}

/* Responsive */
@media (max-width: 900px) {
    .win-prob-factors {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .win-prob-container {
        flex-direction: column;
    }
    
    .win-prob-bar-container {
        width: 100%;
        order: -1;
    }
}

.player-table-wrapper {
    overflow-x: auto;
    position: relative;
}

.player-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    table-layout: auto;
}

/* When table fits in viewport, expand to fill width */
.player-table.auto-fit {
    width: 100%;
    min-width: 0;
}

.player-table th {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.8px;
    padding: var(--space-md) var(--space-md);
    text-align: center;
    background: var(--bg-elevated);
    border-bottom: 1px solid var(--border-subtle);
    border-right: 1px solid rgba(255, 255, 255, 0.04);
    position: sticky;
    top: 0;
    z-index: 10;
}

.player-table th:last-child {
    border-right: none;
}

.player-table th:first-child,
.player-table th.sticky-header:first-child {
    text-align: left;
    padding-left: var(--space-xl);
    position: sticky;
    left: 0;
    z-index: 20;
    background: var(--bg-elevated);
    min-width: 140px;
    box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
    border-right: 2px solid rgba(255, 255, 255, 0.08);
}

/* Sticky cell for player names */
.player-table td.sticky-cell {
    position: sticky;
    left: 0;
    z-index: 5;
    background: var(--bg-card);
    min-width: 140px;
    box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
    border-right: 2px solid rgba(255, 255, 255, 0.08);
}

.player-table tbody tr:hover td.sticky-cell {
    background: rgba(0, 20, 30, 0.95);
}

.player-table .col-group {
    background: rgba(0, 0, 0, 0.3);
    color: var(--accent-cyan);
    font-size: 12px;
    letter-spacing: 1px;
    border-left: 2px solid var(--border-subtle);
    border-right: 2px solid var(--border-subtle);
    padding: var(--space-md) var(--space-lg);
}

.player-table .col-group.shot-dist {
    color: var(--accent-gold);
}

.player-table .col-group.off-impact {
    color: var(--accent-emerald);
}

.player-table .col-group.def-impact {
    color: var(--accent-coral);
}

.player-table td {
    padding: var(--space-md) 10px;
    text-align: center;
    font-size: 14px;
    border-bottom: 1px solid var(--border-subtle);
    border-right: 1px solid rgba(255, 255, 255, 0.04);
    vertical-align: middle;
}

.player-table td:last-child {
    border-right: none;
}

/* Thicker borders between column groups */
.player-table th[data-group="scoring"]:last-of-type,
.player-table td[data-group="scoring"]:last-of-type {
    border-right: 2px solid rgba(0, 212, 255, 0.3);
}

.player-table th[data-group="usage"]:last-of-type,
.player-table td[data-group="usage"]:last-of-type {
    border-right: 2px solid rgba(255, 107, 107, 0.3);
}

.player-table th[data-group="shotdist"]:last-of-type,
.player-table td[data-group="shotdist"]:last-of-type {
    border-right: 2px solid rgba(255, 208, 0, 0.3);
}

.player-table th[data-group="offcourt"]:last-of-type,
.player-table td[data-group="offcourt"]:last-of-type {
    border-right: 2px solid rgba(0, 255, 136, 0.3);
}

.player-table th[data-group="defcourt"]:last-of-type,
.player-table td[data-group="defcourt"]:last-of-type {
    border-right: 2px solid rgba(255, 107, 107, 0.3);
}

/* Subtle background colors for each column group */
.player-table th[data-group="scoring"],
.player-table td[data-group="scoring"] {
    background-color: rgba(0, 212, 255, 0.04);
}

.player-table th[data-group="usage"],
.player-table td[data-group="usage"] {
    background-color: rgba(168, 85, 247, 0.04);
}

.player-table th[data-group="shotdist"],
.player-table td[data-group="shotdist"] {
    background-color: rgba(255, 208, 0, 0.04);
}

.player-table th[data-group="offcourt"],
.player-table td[data-group="offcourt"] {
    background-color: rgba(0, 255, 136, 0.04);
}

.player-table th[data-group="defcourt"],
.player-table td[data-group="defcourt"] {
    background-color: rgba(255, 107, 107, 0.04);
}

.player-table th[data-group="individual"],
.player-table td[data-group="individual"] {
    background-color: rgba(255, 0, 170, 0.04);
}

/* Slightly stronger background on group headers */
.player-table .col-group-header[data-group="scoring"] {
    background-color: rgba(0, 212, 255, 0.12) !important;
}

.player-table .col-group-header[data-group="usage"] {
    background-color: rgba(168, 85, 247, 0.12) !important;
}

.player-table .col-group-header[data-group="shotdist"] {
    background-color: rgba(255, 208, 0, 0.12) !important;
}

.player-table .col-group-header[data-group="offcourt"] {
    background-color: rgba(0, 255, 136, 0.12) !important;
}

.player-table .col-group-header[data-group="defcourt"] {
    background-color: rgba(255, 107, 107, 0.12) !important;
}

.player-table .col-group-header[data-group="individual"] {
    background-color: rgba(255, 0, 170, 0.12) !important;
}

/* Row hover should override the group background */
.player-table tbody tr:hover td[data-group] {
    background-color: rgba(0, 212, 255, 0.08);
}

.player-table td:first-child,
.player-table td.sticky-cell {
    text-align: left;
    padding-left: var(--space-xl);
}

.player-table tbody tr {
    transition: all 0.2s ease;
}

.player-table tbody tr:hover {
    background: rgba(0, 212, 255, 0.04);
}

.player-name {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-bright);
    white-space: nowrap;
}

.points-total {
    font-family: 'Space Mono', monospace;
    font-size: 16px;
    font-weight: 700;
    padding: 6px 14px;
    background: var(--bg-elevated);
    border-radius: var(--radius-sm);
    color: var(--text-bright);
}

.mins-cell {
    position: relative;
    min-width: 55px;
}

.mins-value {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    position: relative;
    z-index: 1;
}

.mins-value.tpc-value {
    font-weight: 700;
    color: var(--text-bright);
}

.mins-bar {
    position: absolute;
    bottom: 6px;
    left: 6px;
    right: 6px;
    height: 4px;
    background: var(--bg-elevated);
    border-radius: 2px;
    overflow: hidden;
}

.mins-bar-fill {
    height: 100%;
    border-radius: 2px;
}

.metric-cell {
    position: relative;
    min-width: 58px;
}

.metric-bg {
    position: absolute;
    inset: 5px;
    background: var(--bg-elevated);
    border-radius: var(--radius-sm);
    overflow: hidden;
}

.metric-fill {
    height: 100%;
    opacity: 0.6;
}

.metric-fill.cyan { background: linear-gradient(90deg, var(--team-home), transparent); }
.metric-fill.magenta { background: linear-gradient(90deg, var(--team-away), transparent); }
.metric-fill.defense { background: linear-gradient(90deg, var(--accent-coral), transparent); }
.metric-fill.positive { background: linear-gradient(90deg, var(--positive), transparent); }
.metric-fill.neutral { background: linear-gradient(90deg, var(--text-muted), transparent); }

.metric-text {
    position: relative;
    z-index: 1;
    font-family: 'Space Mono', monospace;
    font-weight: 600;
    font-size: 13px;
}

.metric-text.positive {
    color: var(--positive);
}

.metric-text.negative {
    color: var(--negative);
}

.net-pill {
    display: inline-block;
    padding: 6px 12px;
    border-radius: 100px;
    font-family: 'Space Mono', monospace;
    font-weight: 700;
    font-size: 12px;
}

.net-pill.positive {
    background: var(--positive-bg);
    color: var(--positive);
    border: 1px solid rgba(0, 255, 136, 0.2);
}

.net-pill.negative {
    background: var(--negative-bg);
    color: var(--negative);
    border: 1px solid rgba(255, 107, 107, 0.2);
}

/* Diff Pills for +/- on-court stats */
.diff-pill {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 6px;
    font-family: 'Space Mono', monospace;
    font-weight: 600;
    font-size: 12px;
    background: var(--bg-elevated);
    color: var(--text-secondary);
}

.diff-pill.positive {
    background: var(--positive-bg);
    color: var(--positive);
}

.diff-pill.negative {
    background: var(--negative-bg);
    color: var(--negative);
}

/* Shot Distribution Cells */
.shot-cell {
    min-width: 70px;
    padding: 6px !important;
}

/* Separators between shot zones (after RIM%, after MID%) */
.shot-cell.zone-end,
td.shot-pct-cell.zone-end,
td.zone-end,
th.zone-end {
    border-right: 2px solid rgba(255, 255, 255, 0.15) !important;
}

.shot-pct-cell {
    min-width: 55px;
}

.shot-wrapper {
    display: flex;
    flex-direction: column;
    gap: 3px;
    align-items: center;
}

.shot-att {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    color: var(--text-muted);
}

.shot-pct {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 700;
}

.shot-pct.rim { color: var(--accent-coral); }
.shot-pct.mid { color: var(--accent-purple); }
.shot-pct.three { color: var(--accent-emerald); }

.shot-bar {
    width: 100%;
    height: 4px;
    background: var(--bg-elevated);
    border-radius: 2px;
    overflow: hidden;
}

.shot-bar-fill {
    height: 100%;
    border-radius: 2px;
}

.shot-bar-fill.rim { background: linear-gradient(90deg, var(--accent-coral), transparent); }
.shot-bar-fill.mid { background: linear-gradient(90deg, var(--accent-purple), transparent); }
.shot-bar-fill.three { background: linear-gradient(90deg, var(--accent-emerald), transparent); }

/* Column separators - visible dividers between logical groups */
.player-table th.col-separator,
.player-table td.col-separator,
.player-table td[data-group].col-separator,
th.col-separator,
td.col-separator {
    border-right: 2px solid rgba(255, 255, 255, 0.35) !important;
}

/* COLLAPSIBLE COLUMN GROUPS */
.col-group-header {
    cursor: pointer;
    user-select: none;
    transition: all 0.2s ease;
    position: relative;
}

.col-group-header:hover {
    background: rgba(255, 255, 255, 0.05) !important;
}

.col-group-header::after {
    content: '▼';
    font-size: 8px;
    margin-left: 6px;
    display: inline-block;
    transition: transform 0.3s ease;
    opacity: 0.6;
}

.col-group-header.collapsed::after {
    transform: rotate(-90deg);
}

.col-group-header.collapsed {
    /* Completely hide collapsed headers to prevent alignment issues */
    display: none;
}

/* Hidden columns when group is collapsed */
.player-table th.col-hidden,
.player-table td.col-hidden {
    display: none;
}

/* Collapsed groups indicator row */
.collapsed-groups-bar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    padding: 8px 12px;
    background: var(--bg-elevated);
    border-radius: var(--radius-sm);
    margin-bottom: 8px;
    align-items: center;
}

.collapsed-groups-bar .label {
    font-size: 10px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.collapsed-group-chip {
    padding: 4px 10px;
    background: var(--bg-glass);
    border: 1px solid var(--border-accent);
    border-radius: 12px;
    font-size: 10px;
    font-weight: 600;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 4px;
}

.collapsed-group-chip:hover {
    transform: scale(1.05);
}

/* Color-coded chips for each group */
.collapsed-group-chip[data-group="scoring"] {
    background: rgba(0, 212, 255, 0.15);
    border-color: rgba(0, 212, 255, 0.4);
    color: rgb(0, 212, 255);
}
.collapsed-group-chip[data-group="scoring"]:hover {
    background: rgba(0, 212, 255, 0.3);
}

.collapsed-group-chip[data-group="usage"] {
    background: rgba(168, 85, 247, 0.15);
    border-color: rgba(168, 85, 247, 0.4);
    color: rgb(168, 85, 247);
}
.collapsed-group-chip[data-group="usage"]:hover {
    background: rgba(168, 85, 247, 0.3);
}

.collapsed-group-chip[data-group="shotdist"] {
    background: rgba(255, 208, 0, 0.15);
    border-color: rgba(255, 208, 0, 0.4);
    color: rgb(255, 208, 0);
}
.collapsed-group-chip[data-group="shotdist"]:hover {
    background: rgba(255, 208, 0, 0.3);
}

.collapsed-group-chip[data-group="offcourt"] {
    background: rgba(0, 255, 136, 0.15);
    border-color: rgba(0, 255, 136, 0.4);
    color: rgb(0, 255, 136);
}
.collapsed-group-chip[data-group="offcourt"]:hover {
    background: rgba(0, 255, 136, 0.3);
}

.collapsed-group-chip[data-group="defcourt"] {
    background: rgba(255, 107, 107, 0.15);
    border-color: rgba(255, 107, 107, 0.4);
    color: rgb(255, 107, 107);
}
.collapsed-group-chip[data-group="defcourt"]:hover {
    background: rgba(255, 107, 107, 0.3);
}

.collapsed-group-chip[data-group="individual"] {
    background: rgba(255, 0, 170, 0.15);
    border-color: rgba(255, 0, 170, 0.4);
    color: rgb(255, 0, 170);
}
.collapsed-group-chip[data-group="individual"]:hover {
    background: rgba(255, 0, 170, 0.3);
}

.collapsed-group-chip::before {
    content: '+';
    font-weight: 700;
}

.expand-all-btn {
    padding: 4px 12px;
    background: var(--accent-purple);
    border: none;
    border-radius: 12px;
    font-size: 10px;
    font-weight: 700;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-left: auto;
}

.expand-all-btn:hover {
    background: var(--accent-magenta);
    transform: scale(1.05);
}

/* SORTABLE COLUMNS */
.sortable-header {
    cursor: pointer;
    user-select: none;
    transition: all 0.2s ease;
    position: relative;
}

.sortable-header:hover {
    background: rgba(255, 255, 255, 0.08) !important;
    color: var(--text-bright);
}

.sortable-header::before {
    content: '';
    position: absolute;
    right: 4px;
    top: 50%;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    opacity: 0.3;
}

.sortable-header.sort-asc::before {
    border-bottom: 5px solid var(--accent-cyan);
    opacity: 1;
}

.sortable-header.sort-desc::before {
    border-top: 5px solid var(--accent-cyan);
    opacity: 1;
}

/* HALF STATS TAB STYLES */
.half-stats-container {
    display: flex;
    flex-direction: column;
    gap: var(--space-xl);
}

.half-selector {
    display: flex;
    gap: var(--space-sm);
    margin-bottom: var(--space-lg);
    padding: var(--space-sm);
    background: var(--bg-elevated);
    border-radius: var(--radius-md);
    width: fit-content;
}

.half-btn {
    padding: 10px 20px;
    background: transparent;
    border: none;
    color: var(--text-secondary);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    border-radius: var(--radius-sm);
    transition: all 0.3s ease;
}

.half-btn:hover {
    background: var(--bg-glass);
    color: var(--text-primary);
}

.half-btn.active {
    background: linear-gradient(135deg, var(--accent-cyan), rgba(0, 212, 255, 0.7));
    color: var(--bg-base);
}

.half-btn.ot {
    background: linear-gradient(135deg, var(--accent-gold), rgba(255, 208, 0, 0.7));
}

.half-content {
    display: none;
}

.half-content.active {
    display: block;
}

/* HALF COMPARISON STYLES */
.comparison-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-xl);
}

@media (max-width: 1200px) {
    .comparison-container {
        grid-template-columns: 1fr;
    }
}

.comparison-card {
    padding: var(--space-xl);
    height: 100%;
}

.comparison-panel .comparison-card {
    height: auto;
    min-height: 400px;
}

.comparison-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: var(--space-lg);
    padding-bottom: var(--space-md);
    border-bottom: 1px solid var(--border-subtle);
}

.comparison-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 16px;
    font-weight: 700;
    color: var(--text-bright);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}

.half-label {
    padding: 4px 12px;
    border-radius: 100px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.half-label.first {
    background: rgba(0, 212, 255, 0.15);
    color: var(--accent-cyan);
    border: 1px solid rgba(0, 212, 255, 0.3);
}

.half-label.second {
    background: rgba(255, 0, 170, 0.15);
    color: var(--accent-magenta);
    border: 1px solid rgba(255, 0, 170, 0.3);
}

.half-label.ot {
    background: rgba(255, 208, 0, 0.15);
    color: var(--accent-gold);
    border: 1px solid rgba(255, 208, 0, 0.3);
}

.half-label.total {
    background: rgba(16, 185, 129, 0.15);
    color: var(--accent-emerald);
    border: 1px solid rgba(16, 185, 129, 0.3);
    cursor: pointer;
    transition: all 0.2s ease;
}

.half-label.total:hover {
    background: rgba(16, 185, 129, 0.25);
}

.half-label.total.active {
    background: rgba(16, 185, 129, 0.3);
    box-shadow: 0 0 8px rgba(16, 185, 129, 0.3);
}

.half-value.total { color: var(--accent-emerald); }

.comparison-bar.total {
    background: linear-gradient(90deg, var(--accent-emerald), rgba(16, 185, 129, 0.6));
}

.comparison-bar-container.with-total {
    padding: 4px 0;
    gap: 3px;
}

.comparison-bar-row {
    display: flex;
    width: 100%;
    height: 16px;
    position: relative;
}

.comparison-bar-row.halves-row {
    height: 14px;
}

.comparison-bar-row.total-row {
    height: 10px;
}

.comparison-bar-container.with-total .comparison-bar {
    height: 100%;
}

.comparison-bar-container.with-total .halves-row {
    height: 12px;
}

.comparison-bar-container.with-total .total-row {
    height: 10px;
}

.comparison-bar-container.with-total .comparison-bar-value {
    font-size: 9px;
}

.comparison-metric {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    padding: var(--space-md) 0;
    border-bottom: 1px solid var(--border-subtle);
}

.comparison-metric:last-child {
    border-bottom: none;
}

/* Collapsible section headers */
.comparison-section-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--space-sm) var(--space-md);
    margin: var(--space-md) 0 var(--space-xs) 0;
    background: var(--bg-elevated);
    border-radius: var(--radius-sm);
    cursor: pointer;
    user-select: none;
    transition: all 0.2s ease;
}

.comparison-section-header:hover {
    background: var(--bg-glass);
}

.comparison-section-header:first-of-type {
    margin-top: 0;
}

.comparison-section-title {
    font-size: 11px;
    font-weight: 700;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.comparison-section-header::after {
    content: '▼';
    font-size: 8px;
    color: var(--text-muted);
    transition: transform 0.3s ease;
}

.comparison-section-header.collapsed::after {
    transform: rotate(-90deg);
}

.comparison-section-header.collapsed {
    opacity: 0.7;
    margin-bottom: var(--space-xs);
}

.comparison-section-content {
    overflow: hidden;
    transition: max-height 0.3s ease;
}

.comparison-section-content.collapsed {
    max-height: 0 !important;
    padding: 0;
}

.metric-name {
    flex: 0 0 120px;
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.metric-values {
    flex: 1;
    display: flex;
    align-items: center;
    gap: var(--space-md);
}

.half-value {
    flex: 0 0 60px;
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 600;
    text-align: center;
}

.half-value.first { color: var(--accent-cyan); }
.half-value.second { color: var(--accent-magenta); }

.change-indicator {
    flex: 0 0 80px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    font-weight: 700;
    padding: 4px 8px;
    border-radius: 6px;
}

.change-indicator.positive {
    background: var(--positive-bg);
    color: var(--positive);
}

.change-indicator.negative {
    background: var(--negative-bg);
    color: var(--negative);
}

.change-indicator.neutral {
    background: var(--bg-elevated);
    color: var(--text-muted);
}

.comparison-bar-container {
    flex: 1;
    min-height: 24px;
    background: var(--bg-elevated);
    border-radius: var(--radius-sm);
    overflow: hidden;
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.comparison-bar {
    height: 100%;
    transition: width 0.6s ease;
    position: relative;
}

.comparison-bar.first {
    background: linear-gradient(90deg, var(--accent-cyan), rgba(0, 212, 255, 0.5));
}

.comparison-bar.second {
    background: linear-gradient(90deg, rgba(255, 0, 170, 0.5), var(--accent-magenta));
}

.comparison-bar-value {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    font-weight: 600;
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

.comparison-bar.first .comparison-bar-value { left: 8px; }
.comparison-bar.second .comparison-bar-value { right: 8px; }
.comparison-bar.total .comparison-bar-value { left: 8px; }

/* Comparison Chart Styles */
.four-factors-comparison {
    margin-top: var(--space-xl);
}

/* ========================================================================
   THREE-PANEL COMPARISON LAYOUT
   ======================================================================== */

.half-comparison-wrapper {
    width: 100%;
}

.comparison-toggle-container {
    display: flex;
    justify-content: center;
    margin-bottom: var(--space-lg);
}

.comparison-toggle-btn {
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    padding: 10px 24px;
    color: var(--text-primary);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.comparison-toggle-btn:hover {
    background: var(--bg-glass);
    border-color: var(--accent-cyan);
}

.comparison-toggle-btn.active {
    background: rgba(0, 212, 255, 0.15);
    border-color: var(--accent-cyan);
    color: var(--accent-cyan);
}

.comparison-panels {
    display: flex;
    gap: var(--space-md);
    transition: all 0.4s ease;
}

.comparison-panel {
    transition: all 0.4s ease;
    overflow: hidden;
    position: relative;
    border-radius: var(--radius-lg);
}

.comparison-panel .panel-content {
    transition: opacity 0.3s ease, width 0.4s ease;
}

.comparison-panel.home-panel,
.comparison-panel.away-panel {
    flex: 1;
    min-width: 0;
}

.comparison-panel.home-panel.expanded,
.comparison-panel.away-panel.expanded {
    min-width: 300px;
}

.comparison-panel.total-panel {
    flex: 0;
    width: 0;
    min-width: 0;
    opacity: 0;
    overflow: hidden;
}

/* Collapsed state for half panels */
.comparison-panel.home-panel.collapsed,
.comparison-panel.away-panel.collapsed {
    flex: 0;
    width: 50px;
    min-width: 50px;
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-subtle);
}

.comparison-panel.collapsed .panel-content {
    opacity: 0;
    pointer-events: none;
    width: 0;
    overflow: hidden;
}

/* Expanded state for total panel */
.comparison-panel.total-panel.expanded {
    flex: 2;
    opacity: 1;
}

/* Collapse carets */
.panel-collapse-caret {
    position: absolute;
    top: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    cursor: pointer;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 10;
    background: transparent;
}

.home-panel .panel-collapse-caret {
    right: 0;
}

.away-panel .panel-collapse-caret {
    left: 0;
}

.comparison-panel.collapsed .panel-collapse-caret {
    opacity: 1;
    pointer-events: auto;
}

.caret-icon {
    font-size: 32px;
    color: var(--text-muted);
    transition: all 0.2s ease;
    line-height: 1;
}

.caret-label {
    font-size: 10px;
    font-weight: 700;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    writing-mode: vertical-rl;
    text-orientation: mixed;
    margin-top: 8px;
}

.home-panel .caret-label {
    color: var(--team-home);
}

.away-panel .caret-label {
    color: var(--team-away);
}

.panel-collapse-caret:hover .caret-icon {
    color: var(--text-bright);
    transform: scale(1.2);
}

/* ========================================================================
   TOTAL COMPARISON (TUG OF WAR) STYLES
   ======================================================================== */

.total-comparison-card {
    padding: var(--space-lg);
    height: 100%;
}

.total-comparison-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding-bottom: var(--space-md);
    margin-bottom: var(--space-md);
    border-bottom: 1px solid var(--border-subtle);
}

.team-side {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    flex: 1;
}

.team-side.home {
    justify-content: flex-start;
}

.team-side.away {
    justify-content: flex-end;
}

.team-side .team-name {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 14px;
    font-weight: 700;
    color: var(--text-bright);
}

.total-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 16px;
    font-weight: 700;
    color: var(--accent-emerald);
    text-transform: uppercase;
    letter-spacing: 2px;
    padding: 0 var(--space-lg);
}

.total-comparison-body {
    /* No height restriction - expand fully */
}

/* Tug of war section headers */
.tow-section-header {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: var(--space-sm) var(--space-md);
    margin: var(--space-md) 0 var(--space-xs) 0;
    background: var(--bg-elevated);
    border-radius: var(--radius-sm);
    cursor: pointer;
    user-select: none;
    transition: all 0.2s ease;
}

.tow-section-header:hover {
    background: var(--bg-glass);
}

.tow-section-header:first-child {
    margin-top: 0;
}

.tow-section-title {
    font-size: 11px;
    font-weight: 700;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.tow-section-header::after {
    content: '▼';
    font-size: 8px;
    color: var(--text-muted);
    margin-left: 8px;
    transition: transform 0.3s ease;
}

.tow-section-header.collapsed::after {
    transform: rotate(-90deg);
}

.tow-section-content {
    overflow: hidden;
    transition: max-height 0.3s ease;
}

.tow-section-content.collapsed {
    max-height: 0 !important;
}

/* Tug of war metric rows */
.tow-metric-row {
    display: grid;
    grid-template-columns: 70px 1fr 70px;
    align-items: center;
    gap: var(--space-md);
    padding: var(--space-sm) 0;
}

.tow-metric-label {
    font-size: 10px;
    font-weight: 700;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    text-align: center;
    padding-bottom: var(--space-sm);
    margin-bottom: var(--space-xs);
    border-bottom: 1px solid var(--border-subtle);
}

.tow-value {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 600;
    text-align: center;
}

.tow-value.home {
    color: var(--team-home);
    text-align: right;
}

.tow-value.away {
    color: var(--team-away);
    text-align: left;
}

.tow-value.better {
    font-weight: 800;
    text-shadow: 0 0 8px currentColor;
}

.tow-label {
    font-size: 10px;
    font-weight: 700;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    text-align: center;
    white-space: nowrap;
    padding: 0 var(--space-xs);
}

.tow-bar-container {
    height: 12px;
    background: var(--bg-elevated);
    border-radius: 6px;
    overflow: hidden;
    display: flex;
}

.tow-bar {
    height: 100%;
    transition: width 0.6s ease;
}

.tow-bar.home {
    background: linear-gradient(90deg, rgba(0, 212, 255, 0.3), var(--accent-cyan));
    border-radius: 6px 0 0 6px;
}

.tow-bar.away {
    background: linear-gradient(90deg, var(--accent-magenta), rgba(255, 0, 170, 0.3));
    border-radius: 0 6px 6px 0;
}

.four-factors-comparison .factors-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: var(--space-lg);
}

@media (max-width: 900px) {
    .four-factors-comparison .factors-grid {
        grid-template-columns: repeat(3, 1fr);
    }
}

@media (max-width: 600px) {
    .four-factors-comparison .factors-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}

.factor-card {
    background: var(--bg-elevated);
    border-radius: var(--radius-md);
    padding: var(--space-lg);
    text-align: center;
    position: relative;
    overflow: hidden;
}

.factor-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
}

.factor-card.efg::before { background: var(--accent-emerald); }
.factor-card.tov::before { background: var(--accent-coral); }
.factor-card.oreb::before { background: var(--accent-purple); }
.factor-card.ft::before { background: var(--accent-gold); }
.factor-card.ast::before { background: var(--accent-cyan); }

.factor-name {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: var(--space-md);
}

.factor-comparison {
    display: flex;
    justify-content: center;
    gap: var(--space-lg);
    margin-bottom: var(--space-md);
}

.factor-half {
    text-align: center;
}

.factor-half-label {
    font-size: 9px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
}

.factor-half-label.first { color: var(--accent-cyan); }
.factor-half-label.second { color: var(--accent-magenta); }

.factor-half-value {
    font-family: 'Space Mono', monospace;
    font-size: 20px;
    font-weight: 700;
    color: var(--text-bright);
}

.factor-change {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 100px;
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    font-weight: 700;
}

.factor-change.positive {
    background: var(--positive-bg);
    color: var(--positive);
}

.factor-change.negative {
    background: var(--negative-bg);
    color: var(--negative);
}

.factor-change.neutral {
    background: var(--bg-glass);
    color: var(--text-muted);
}

/* Column Group Toggle Button */
.collapse-all-btn {
    padding: 6px 12px;
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-sm);
    color: var(--text-secondary);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 11px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-left: auto;
}

.collapse-all-btn:hover {
    background: var(--bg-glass);
    color: var(--text-primary);
    border-color: var(--accent-cyan);
}

.table-controls {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    margin-bottom: var(--space-md);
    padding: 0 var(--space-xl);
}

.sort-indicator {
    font-size: 10px;
    color: var(--text-muted);
}

/* Performance bars */
.perf-cell {
    padding: 6px !important;
    min-width: 70px;
}

.perf-wrapper {
    display: flex;
    align-items: center;
    gap: 6px;
}

.perf-bar {
    flex: 1;
    height: 10px;
    background: var(--bg-elevated);
    border-radius: 5px;
    overflow: hidden;
}

.perf-fill {
    height: 100%;
    border-radius: 5px;
}

.perf-fill.shooting { background: linear-gradient(90deg, #3b82f6, #60a5fa); }
.perf-fill.handling { background: linear-gradient(90deg, #8b5cf6, #a78bfa); }
.perf-fill.rebounding { background: linear-gradient(90deg, #14b8a6, #2dd4bf); }
.perf-fill.playmaking { background: linear-gradient(90deg, #f59e0b, #fbbf24); }
.perf-fill.defense { background: linear-gradient(90deg, #ef4444, #f87171); }
.perf-fill.warning { background: linear-gradient(90deg, #ef4444, #f87171); }

.perf-val {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    font-weight: 600;
    min-width: 26px;
    text-align: right;
    color: var(--text-secondary);
}

/* LINEUP SECTION */
.lineup-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
    gap: var(--space-lg);
}

.lineup-card {
    padding: var(--space-lg);
}

.lineup-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: var(--space-md);
    padding-bottom: var(--space-md);
    border-bottom: 1px solid var(--border-subtle);
}

.lineup-players {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--text-secondary);
    margin-bottom: var(--space-sm);
    line-height: 1.4;
    word-wrap: break-word;
}

.lineup-time {
    font-size: 12px;
    color: var(--text-muted);
}

.lineup-time span {
    font-family: 'Space Mono', monospace;
    color: var(--accent-gold);
}

.lineup-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-md);
}

.lineup-stat-group {
    padding: var(--space-md);
    background: var(--bg-glass);
    border-radius: var(--radius-sm);
}

.lineup-stat-group h5 {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-muted);
    margin-bottom: var(--space-sm);
}

.lineup-stat-group.offense h5 { color: var(--accent-cyan); }
.lineup-stat-group.defense h5 { color: var(--accent-magenta); }

.lineup-factor {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    border-bottom: 1px solid var(--border-subtle);
}

.lineup-factor:last-child {
    border-bottom: none;
}

.lineup-factor-label {
    font-size: 11px;
    color: var(--text-secondary);
}

.lineup-factor-value {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    font-weight: 600;
}

.lineup-factor-value.good { color: var(--positive); }
.lineup-factor-value.bad { color: var(--negative); }
.lineup-factor-value.neutral { color: var(--text-primary); }

.lineup-net {
    text-align: center;
    padding: var(--space-md);
    margin-top: var(--space-md);
    background: var(--bg-elevated);
    border-radius: var(--radius-sm);
}

.lineup-net-value {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 28px;
    font-weight: 700;
}

.lineup-net-value.positive { color: var(--positive); }
.lineup-net-value.negative { color: var(--negative); }

.lineup-net-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-muted);
}

/* ========================================================================
   SEASON COMPARE TAB STYLES
   ======================================================================== */

.season-team-results {
    background: var(--bg-card);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    padding: var(--space-lg);
}

.season-team-results table {
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-sm);
    overflow: hidden;
}

.season-team-results th,
.season-team-results td {
    border: 1px solid var(--border-subtle);
    padding: 8px 10px;
}

.season-team-results th {
    background: var(--bg-elevated);
    color: var(--text-secondary);
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.season-team-results td {
    font-size: 12px;
    font-family: 'Space Mono', monospace;
}

.season-team-results tbody tr:hover {
    background: rgba(0, 212, 255, 0.05);
}

/* EPA Multi-bar chart styling */
.epa-multi-bars {
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    padding: var(--space-md);
}

.epa-player-chart {
    display: grid;
    grid-template-columns: 100px 1fr 70px;
    gap: 12px;
    align-items: center;
    padding: 12px 16px;
    background: var(--bg-card);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-sm);
    transition: all 0.2s ease;
}

.epa-player-chart:hover {
    border-color: var(--border-accent);
    background: var(--bg-elevated);
}

.epa-player-chart:last-child {
    margin-bottom: 0;
}

/* EPA bar styling */
.epa-bar {
    height: 14px;
    border-radius: 3px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease;
}

.epa-bar:hover {
    transform: scaleY(1.2);
}

/* Insight cards */
.insight-card {
    border: 1px solid var(--border-subtle);
}

/* Season summary header */
.season-summary {
    border: 1px solid var(--border-accent);
}

/* Lineup Filter */
.lineup-filter-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-lg);
    padding: var(--space-md);
    background: var(--bg-elevated);
    border-radius: var(--radius-md);
}

.lineup-filter-buttons {
    display: flex;
    gap: var(--space-sm);
}

.lineup-filter-btn {
    padding: 10px 20px;
    background: var(--bg-glass);
    border: 1px solid var(--border-subtle);
    color: var(--text-secondary);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    border-radius: var(--radius-sm);
    transition: all 0.3s ease;
}

.lineup-filter-btn:hover {
    background: var(--bg-card);
    color: var(--text-primary);
}

.lineup-filter-btn.active {
    background: linear-gradient(135deg, var(--accent-cyan), rgba(0, 212, 255, 0.7));
    color: var(--bg-base);
    border-color: var(--accent-cyan);
}

.lineup-filter-btn.home-btn.active {
    background: linear-gradient(135deg, var(--team-home), rgba(0, 212, 255, 0.7));
    border-color: var(--team-home);
}

.lineup-filter-btn.away-btn.active {
    background: linear-gradient(135deg, var(--team-away), rgba(255, 0, 170, 0.7));
    border-color: var(--team-away);
}

.lineup-count {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    color: var(--text-muted);
}

/* Team Shot Distribution */
.team-shots-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-xl);
}

@media (max-width: 900px) {
    .team-shots-grid {
        grid-template-columns: 1fr;
    }
}

.shot-court-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space-md);
}

.shot-court-title {
    font-size: 14px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.shot-court-title.home { color: var(--team-home); }
.shot-court-title.away { color: var(--team-away); }

.shot-court-svg {
    width: 100%;
    max-width: 320px;
    height: auto;
}

.court-zone {
    stroke: rgba(255, 255, 255, 0.3);
    stroke-width: 2;
    cursor: pointer;
    transition: all 0.3s ease;
}

.court-zone:hover {
    filter: brightness(1.2);
    stroke: rgba(255, 255, 255, 0.6);
}

.court-line {
    fill: none;
    stroke: rgba(255, 255, 255, 0.4);
    stroke-width: 2;
}

.court-baseline {
    fill: none;
    stroke: rgba(255, 255, 255, 0.5);
    stroke-width: 3;
}

.zone-label {
    font-family: 'Space Mono', monospace;
    font-weight: 700;
    fill: white;
    text-anchor: middle;
    pointer-events: none;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

.zone-label-pct {
    font-size: 20px;
}

.zone-label-detail {
    font-size: 10px;
    fill: rgba(255, 255, 255, 0.8);
}

.zone-label-dist {
    font-size: 9px;
    fill: rgba(255, 255, 255, 0.6);
}

.shot-court-legend {
    display: flex;
    justify-content: center;
    gap: var(--space-lg);
    margin-top: var(--space-sm);
}

.legend-zone {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    font-size: 11px;
    color: var(--text-secondary);
}

.legend-zone-color {
    width: 12px;
    height: 12px;
    border-radius: 3px;
}

.legend-zone-color.rim { background: var(--accent-coral); }
.legend-zone-color.mid { background: var(--accent-purple); }
.legend-zone-color.three { background: var(--accent-emerald); }

/* Shot Visualization Container */
.shot-viz-container {
    display: flex;
    flex-direction: column;
    gap: var(--space-xl);
}

/* Shot Distribution Bar Chart */
.shot-dist-chart {
    background: var(--bg-glass);
    border-radius: var(--radius-md);
    padding: var(--space-lg);
    border: 1px solid var(--border-subtle);
}

.shot-dist-title {
    font-size: 14px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-primary);
}

/* Game Flow Charts */
.game-flow-container {
    display: grid;
    gap: var(--space-xl);
}

.flow-chart-card {
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    border: 1px solid var(--border-subtle);
}

.flow-chart-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-lg);
}

.flow-chart-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 16px;
    font-weight: 700;
    color: var(--text-bright);
    display: flex;
    align-items: center;
    gap: 8px;
}

.flow-chart-legend {
    display: flex;
    gap: var(--space-lg);
    font-size: 12px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
}

.legend-line {
    width: 24px;
    height: 3px;
    border-radius: 2px;
}

.legend-line.home { background: var(--team-home); }
.legend-line.away { background: var(--team-away); }
.legend-line.zero { background: rgba(255, 255, 255, 0.3); }

.flow-chart-svg {
    width: 100%;
    height: 280px;
    background: var(--bg-glass);
    border-radius: var(--radius-md);
    overflow: visible;
}

.flow-axis-line {
    stroke: rgba(255, 255, 255, 0.15);
    stroke-width: 1;
}

.flow-axis-label {
    fill: var(--text-muted);
    font-size: 10px;
    font-family: 'Space Mono', monospace;
}

.flow-period-line {
    stroke: rgba(255, 255, 255, 0.25);
    stroke-width: 1;
    stroke-dasharray: 4 4;
}

.flow-period-label {
    fill: var(--text-secondary);
    font-size: 12px;
    font-weight: 600;
    font-family: 'Space Grotesk', sans-serif;
}

.flow-zero-line {
    stroke: rgba(255, 255, 255, 0.4);
    stroke-width: 1;
}

.flow-line {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
}

.flow-line.home {
    stroke: var(--team-home);
    filter: drop-shadow(0 0 6px var(--accent-cyan-glow));
}

.flow-line.away {
    stroke: var(--team-away);
    filter: drop-shadow(0 0 6px var(--accent-magenta-glow));
}

.flow-area {
    opacity: 0.15;
}

.flow-area.home { fill: var(--team-home); }
.flow-area.away { fill: var(--team-away); }
.flow-area.positive { fill: var(--team-home); }
.flow-area.negative { fill: var(--team-away); }

.flow-tooltip {
    position: absolute;
    background: var(--bg-elevated);
    border: 1px solid var(--border-accent);
    border-radius: var(--radius-sm);
    padding: 8px 12px;
    font-size: 12px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 100;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
}

.flow-tooltip.visible {
    opacity: 1;
}

.flow-stats-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--space-md);
    margin-top: var(--space-lg);
    padding-top: var(--space-lg);
    border-top: 1px solid var(--border-subtle);
}

.flow-stat-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--space-sm) var(--space-md);
    background: var(--bg-glass);
    border-radius: var(--radius-sm);
}

.flow-stat-label {
    font-size: 11px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.flow-stat-value {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 700;
}

.flow-stat-value.home { color: var(--team-home); }
.flow-stat-value.away { color: var(--team-away); }
.flow-stat-value.positive { color: var(--positive); }
.flow-stat-value.negative { color: var(--negative); }

/* Player Runs & Team Momentum Styles */
.runs-momentum-container {
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    border: 1px solid var(--border-subtle);
    margin-bottom: var(--space-lg);
}

.runs-momentum-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-lg);
}

.runs-momentum-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 16px;
    font-weight: 700;
    color: var(--text-bright);
    display: flex;
    align-items: center;
    gap: 8px;
}

.runs-chart-wrapper {
    position: relative;
    width: 100%;
}

/* Unified track for up/down visualization */
.runs-track-unified {
    position: relative;
    height: 200px;
    margin-left: 90px;
    background: var(--bg-glass);
    border-radius: var(--radius-sm);
    overflow: visible;
}

.runs-track-center-line {
    position: absolute;
    left: 0;
    right: 0;
    top: 50%;
    height: 2px;
    background: rgba(255, 255, 255, 0.2);
}

.runs-track-label-left {
    position: absolute;
    left: -90px;
    width: 85px;
    font-size: 10px;
    font-weight: 700;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    text-align: right;
    padding-right: 8px;
}

.runs-track-label-left.top {
    top: 30px;
    color: var(--team-home);
}

.runs-track-label-left.bottom {
    bottom: 30px;
    color: var(--team-away);
}

/* Run markers - positioned from center */
.run-marker {
    position: absolute;
    border-radius: 6px;
    padding: 6px 8px;
    font-size: 10px;
    font-weight: 600;
    font-family: 'Space Grotesk', sans-serif;
    white-space: nowrap;
    cursor: pointer;
    transition: all 0.2s ease;
    z-index: 5;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px;
    min-width: 55px;
    /* max-width removed - now controlled by duration */
    transform: translateX(-50%);
}

.run-marker:hover {
    z-index: 10;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
    filter: brightness(1.1);
}

/* Home team - protrudes UP from center line */
.run-marker.home {
    background: linear-gradient(180deg, rgba(0, 212, 255, 0.95), rgba(0, 180, 220, 0.85));
    color: var(--bg-base);
    border: 1px solid var(--team-home);
    bottom: 50%;
    transform: translateX(-50%);
}

.run-marker.home:hover {
    transform: translateX(-50%) scale(1.05);
}

/* Away team - protrudes DOWN from center line */
.run-marker.away {
    background: linear-gradient(0deg, rgba(255, 0, 170, 0.95), rgba(220, 0, 150, 0.85));
    color: white;
    border: 1px solid var(--team-away);
    top: 50%;
    transform: translateX(-50%);
}

.run-marker.away:hover {
    transform: translateX(-50%) scale(1.05);
}

.run-marker-player {
    font-weight: 800;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.run-marker-stats {
    font-size: 10px;
    opacity: 0.9;
}

.run-marker-duration {
    font-size: 9px;
    opacity: 0.8;
    font-family: 'Space Mono', monospace;
}

/* Team Momentum markers - width based on duration */
.momentum-marker {
    position: absolute;
    border-radius: 8px;
    padding: 8px 10px;
    font-size: 10px;
    font-weight: 600;
    font-family: 'Space Grotesk', sans-serif;
    cursor: pointer;
    transition: all 0.2s ease;
    z-index: 5;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
    gap: 3px;
    width: auto;
    min-width: 65px;
    /* max-width removed - now controlled by duration */
    align-items: center;
    justify-content: center;
    transform: translateX(-50%);
}

.momentum-marker:hover {
    z-index: 10;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    filter: brightness(1.1);
}

/* Home team momentum - protrudes UP */
.momentum-marker.home {
    background: linear-gradient(180deg, rgba(0, 212, 255, 0.25), rgba(0, 212, 255, 0.1));
    border: 2px solid var(--team-home);
    color: var(--team-home);
    bottom: 50%;
    transform: translateX(-50%);
}

.momentum-marker.home:hover {
    transform: translateX(-50%) scale(1.05);
}

/* Away team momentum - protrudes DOWN */
.momentum-marker.away {
    background: linear-gradient(0deg, rgba(255, 0, 170, 0.25), rgba(255, 0, 170, 0.1));
    border: 2px solid var(--team-away);
    color: var(--team-away);
    top: 50%;
    transform: translateX(-50%);
}

.momentum-marker.away:hover {
    transform: translateX(-50%) scale(1.05);
}

.momentum-score {
    font-size: 14px;
    font-weight: 800;
    font-family: 'Space Mono', monospace;
    text-align: center;
}

.momentum-time {
    font-size: 10px;
    opacity: 0.8;
    text-align: center;
}

.momentum-lineup {
    font-size: 8px;
    color: var(--text-secondary);
    text-align: center;
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.momentum-top-scorer {
    font-size: 10px;
    font-weight: 600;
    text-align: center;
    padding-top: 3px;
    border-top: 1px solid rgba(255,255,255,0.15);
}

/* Tooltip for full lineup display */
.momentum-marker[data-lineup] {
    position: absolute;
}

.momentum-marker[data-lineup]::after {
    content: attr(data-lineup);
    position: absolute;
    left: 50%;
    background: var(--bg-elevated);
    color: var(--text-primary);
    padding: 8px 12px;
    border-radius: var(--radius-sm);
    font-size: 11px;
    white-space: pre-line;
    width: max-content;
    max-width: 280px;
    text-align: center;
    opacity: 0;
    visibility: hidden;
    transition: all 0.2s ease;
    z-index: 100;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    border: 1px solid var(--border-accent);
    pointer-events: none;
    transform: translateX(-50%);
}

.momentum-marker.home[data-lineup]::after {
    bottom: calc(100% + 8px);
}

.momentum-marker.away[data-lineup]::after {
    top: calc(100% + 8px);
}

.momentum-marker[data-lineup]:hover::after {
    opacity: 1;
    visibility: visible;
}

.runs-timeline-axis {
    position: relative;
    margin-left: 90px;
    height: 24px;
    display: flex;
    align-items: center;
    border-top: 1px solid var(--border-subtle);
    margin-top: 4px;
}

.timeline-label {
    position: absolute;
    font-size: 10px;
    color: var(--text-muted);
    font-family: 'Space Mono', monospace;
    transform: translateX(-50%);
    top: 6px;
}

.runs-legend {
    display: flex;
    gap: var(--space-lg);
    margin-top: var(--space-md);
    padding-top: var(--space-md);
    border-top: 1px solid var(--border-subtle);
    font-size: 11px;
    color: var(--text-secondary);
}

.runs-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
}

.runs-legend-marker {
    width: 12px;
    height: 12px;
    border-radius: 4px;
}

.runs-legend-marker.home {
    background: var(--team-home);
}

.runs-legend-marker.away {
    background: var(--team-away);
}

.no-runs-message {
    text-align: center;
    padding: var(--space-lg);
    color: var(--text-muted);
    font-size: 13px;
}

/* BPM Table Styles */
.bpm-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-xl);
}

@media (max-width: 1200px) {
    .bpm-container {
        grid-template-columns: 1fr;
    }
}

.bpm-team-card {
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    border: 1px solid var(--border-subtle);
}

.bpm-team-header {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    margin-bottom: var(--space-lg);
    padding-bottom: var(--space-md);
    border-bottom: 2px solid var(--border-subtle);
}

.bpm-team-header.home {
    border-bottom-color: var(--team-home);
}

.bpm-team-header.away {
    border-bottom-color: var(--team-away);
}

.bpm-team-name {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 18px;
    font-weight: 700;
}

.bpm-team-name.home {
    color: var(--team-home);
}

.bpm-team-name.away {
    color: var(--team-away);
}

.bpm-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
}

.bpm-table th {
    text-align: left;
    padding: 10px 8px;
    font-weight: 700;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-size: 10px;
    border-bottom: 1px solid var(--border-subtle);
}

.bpm-table th.sortable {
    cursor: pointer;
    transition: color 0.2s ease;
}

.bpm-table th.sortable:hover {
    color: var(--accent-cyan);
}

.bpm-table th.numeric {
    text-align: center;
}

.bpm-table td {
    padding: 10px 8px;
    border-bottom: 1px solid var(--border-subtle);
    color: var(--text-primary);
}

.bpm-table td.player-name {
    font-weight: 600;
}

.bpm-table td.numeric {
    text-align: center;
    font-family: 'Space Mono', monospace;
    font-size: 13px;
}

.bpm-table td.positive {
    color: var(--positive);
}

.bpm-table td.negative {
    color: var(--negative);
}

.bpm-table td.neutral {
    color: var(--text-secondary);
}

.bpm-table tr:hover {
    background: var(--bg-glass);
}

.bpm-value {
    font-weight: 700;
}

.bpm-methodology {
    margin-top: var(--space-lg);
    padding: var(--space-md);
    background: var(--bg-glass);
    border-radius: var(--radius-sm);
    font-size: 11px;
    color: var(--text-muted);
}

.bpm-methodology h4 {
    font-size: 12px;
    color: var(--text-secondary);
    margin-bottom: var(--space-sm);
}
    margin-bottom: var(--space-lg);
    text-align: center;
}

.shot-dist-bars {
    display: flex;
    flex-direction: column;
    gap: var(--space-lg);
}

.shot-dist-row {
    display: grid;
    grid-template-columns: 50px 50px 1fr 50px;
    gap: var(--space-sm);
    align-items: center;
}

.shot-dist-label {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    font-weight: 700;
    text-align: right;
}

/* Tug-of-war bar container */
.shot-dist-bar-group {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 0;
    height: 32px;
    background: var(--bg-elevated);
    border-radius: 6px;
    overflow: hidden;
    position: relative;
}

/* Center divider line */
.shot-dist-bar-group::before {
    content: '';
    position: absolute;
    left: 50%;
    top: 0;
    bottom: 0;
    width: 2px;
    background: rgba(255, 255, 255, 0.3);
    transform: translateX(-50%);
    z-index: 3;
}

.shot-dist-bar-wrapper {
    display: flex;
    align-items: center;
    height: 100%;
    flex: 1;
}

.shot-dist-bar-wrapper.home-wrapper {
    justify-content: flex-end;
}

.shot-dist-bar-wrapper.away-wrapper {
    justify-content: flex-start;
}

.shot-dist-bar {
    height: 100%;
    min-width: 2px;
    transition: width 0.6s ease;
}

.shot-dist-bar.home {
    background: linear-gradient(270deg, var(--team-home), rgba(0, 212, 255, 0.4));
    border-radius: 6px 0 0 6px;
}

.shot-dist-bar.away {
    background: linear-gradient(90deg, var(--team-away), rgba(255, 0, 128, 0.4));
    border-radius: 0 6px 6px 0;
}

.shot-dist-value {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    font-weight: 600;
    min-width: 45px;
    padding: 0 8px;
}

.shot-dist-value.home {
    color: var(--team-home);
    text-align: right;
}

.shot-dist-value.away {
    color: var(--team-away);
    text-align: left;
}

.shot-dist-legend {
    display: flex;
    justify-content: center;
    gap: var(--space-xl);
    margin-top: var(--space-lg);
    padding-top: var(--space-md);
    border-top: 1px solid var(--border-subtle);
}

.shot-dist-legend-item {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
}

/* Connections Tab */
.connections-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-xl);
}

.connections-section {
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    border: 1px solid var(--border-subtle);
}

.connections-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-lg);
    padding-bottom: var(--space-md);
    border-bottom: 1px solid var(--border-subtle);
}

.connections-header h3 {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 18px;
    font-weight: 700;
}

.connections-count {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    color: var(--text-muted);
}

.connections-grid {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
}

.connection-card {
    padding: var(--space-md);
    background: var(--bg-glass);
    border-radius: var(--radius-md);
}

.connection-header {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    margin-bottom: var(--space-sm);
}

.connection-players {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-family: 'Space Mono', monospace;
    font-size: 13px;
}

.connection-passer {
    color: var(--text-primary);
    font-weight: 600;
}

.connection-arrow {
    color: var(--text-muted);
}

.connection-scorer {
    color: var(--accent-gold);
    font-weight: 600;
}

.connection-stats {
    display: flex;
    align-items: center;
    gap: var(--space-lg);
    margin-bottom: var(--space-sm);
}

.connection-main {
    text-align: center;
    min-width: 60px;
}

.connection-count {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 32px;
    font-weight: 700;
    color: var(--text-bright);
    line-height: 1;
}

.connection-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-muted);
}

.connection-details {
    display: flex;
    gap: var(--space-md);
    flex: 1;
}

.connection-detail {
    text-align: center;
    padding: var(--space-xs) var(--space-sm);
    background: var(--bg-elevated);
    border-radius: var(--radius-sm);
    min-width: 50px;
}

.detail-value {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 700;
    color: var(--text-primary);
    display: block;
}

.detail-value.three {
    color: var(--accent-emerald);
}

.detail-value.two {
    color: var(--accent-coral);
}

.detail-label {
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
}

.connection-bar-container {
    height: 4px;
    background: var(--bg-elevated);
    border-radius: 2px;
    overflow: hidden;
}

.connection-bar {
    height: 100%;
    border-radius: 2px;
    transition: width 0.6s ease;
}

.connection-bar.home {
    background: linear-gradient(90deg, var(--team-home), rgba(0, 212, 255, 0.5));
}

.connection-bar.away {
    background: linear-gradient(90deg, var(--team-away), rgba(255, 0, 170, 0.5));
}

.no-data {
    text-align: center;
    color: var(--text-muted);
    padding: var(--space-xl);
}

@media (max-width: 1200px) {
    .connections-container {
        grid-template-columns: 1fr;
    }
}

/* UPLOAD SECTION */
.upload-section {
    padding: var(--space-2xl);
    text-align: center;
    margin-bottom: var(--space-xl);
    border: 2px dashed rgba(0, 212, 255, 0.3);
}

.upload-section h2 {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 32px;
    font-weight: 700;
    margin-bottom: var(--space-md);
    background: linear-gradient(135deg, var(--team-home), var(--team-away));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.upload-buttons {
    display: flex;
    gap: var(--space-md);
    justify-content: center;
    flex-wrap: wrap;
}

.upload-btn {
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    color: var(--text-primary);
    padding: 14px 24px;
    border-radius: var(--radius-md);
    cursor: pointer;
    font-family: 'DM Sans', sans-serif;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
}

.upload-btn:hover {
    background: rgba(0, 212, 255, 0.1);
    border-color: var(--team-home);
    transform: translateY(-2px);
}

.upload-btn.primary {
    background: linear-gradient(135deg, var(--team-home), rgba(0, 212, 255, 0.7));
    border-color: transparent;
    color: var(--bg-base);
    font-weight: 600;
}

.upload-btn.primary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.upload-status {
    margin-top: var(--space-lg);
    font-size: 13px;
    color: var(--text-secondary);
}

.upload-status.success { color: var(--positive); }
.upload-status.error { color: var(--negative); }

/* URL Fetcher Section (Tauri only) */
.url-fetch-section {
    background: linear-gradient(135deg, rgba(0, 255, 136, 0.05), rgba(0, 212, 255, 0.05));
    border-radius: var(--radius-md);
    padding: var(--space-lg);
    margin: var(--space-lg) 0;
}

.url-fetch-section input[type="text"] {
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.url-fetch-section input[type="text"]:hover {
    border-color: rgba(0, 212, 255, 0.5);
}

#fetch-urls-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 255, 136, 0.3);
}

#fetch-urls-btn:disabled {
    opacity: 0.7;
    cursor: wait;
    transform: none;
}

.demo-divider {
    margin-top: var(--space-xl);
    padding-top: var(--space-xl);
    border-top: 1px solid var(--border-subtle);
}

.demo-btn {
    background: linear-gradient(135deg, var(--team-away), rgba(255, 0, 170, 0.7));
    border: none;
    color: white;
    padding: 14px 28px;
    border-radius: var(--radius-md);
    cursor: pointer;
    font-family: 'DM Sans', sans-serif;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
}

.demo-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 0 40px var(--accent-magenta-glow);
}

/* LIVE MODE */
.live-section {
    margin-top: var(--space-xl);
    padding-top: var(--space-xl);
    border-top: 1px solid var(--border-subtle);
}

.live-section h3 {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 18px;
    margin-bottom: var(--space-md);
    color: var(--accent-emerald);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
}

.live-modes {
    display: flex;
    gap: var(--space-md);
    justify-content: center;
    margin-bottom: var(--space-lg);
}

.live-mode-btn {
    padding: 10px 20px;
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    color: var(--text-secondary);
    border-radius: var(--radius-md);
    cursor: pointer;
    font-family: 'DM Sans', sans-serif;
    font-size: 13px;
    transition: all 0.3s ease;
}

.live-mode-btn:hover {
    border-color: var(--accent-emerald);
    color: var(--text-primary);
}

.live-mode-btn.active {
    background: rgba(0, 255, 136, 0.15);
    border-color: var(--accent-emerald);
    color: var(--accent-emerald);
}

.url-input-group {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
    max-width: 700px;
    margin: 0 auto var(--space-lg);
}

.url-input {
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    color: var(--text-primary);
    padding: 12px 16px;
    border-radius: var(--radius-md);
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    width: 100%;
    transition: all 0.3s ease;
}

.url-input:focus {
    outline: none;
    border-color: var(--accent-emerald);
    box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
}

.live-controls {
    display: flex;
    gap: var(--space-md);
    justify-content: center;
    flex-wrap: wrap;
}

.live-btn {
    background: linear-gradient(135deg, var(--accent-emerald), rgba(0, 255, 136, 0.7));
    border: none;
    color: var(--bg-base);
    padding: 14px 28px;
    border-radius: var(--radius-md);
    cursor: pointer;
    font-family: 'DM Sans', sans-serif;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}

.live-btn:hover:not(:disabled) {
    transform: translateY(-3px);
    box-shadow: 0 0 40px rgba(0, 255, 136, 0.4);
}

.live-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.live-btn.stop {
    background: linear-gradient(135deg, var(--negative), rgba(255, 107, 107, 0.7));
}

.live-status-panel {
    background: var(--bg-elevated);
    border-radius: var(--radius-md);
    padding: var(--space-md) var(--space-lg);
    margin-top: var(--space-lg);
    max-width: 700px;
    margin-left: auto;
    margin-right: auto;
    display: none;
}

.live-status-panel.active {
    display: block;
}

.status-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.status-indicator {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-weight: 600;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    animation: pulse 1.5s ease-in-out infinite;
}

.status-dot.connected { background: var(--positive); }
.status-dot.connecting { background: var(--warning); }
.status-dot.error { background: var(--negative); animation: none; }

@keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.5; transform: scale(0.8); }
}

.status-times {
    font-size: 12px;
    color: var(--text-muted);
}

.server-hint {
    margin-top: var(--space-md);
    padding: var(--space-md);
    background: rgba(255, 208, 0, 0.1);
    border: 1px solid rgba(255, 208, 0, 0.3);
    border-radius: var(--radius-sm);
    font-size: 12px;
    color: var(--accent-gold);
}

.server-hint code {
    background: var(--bg-base);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'Space Mono', monospace;
}

/* LOADING */
.loading {
    text-align: center;
    padding: var(--space-2xl);
    color: var(--text-secondary);
}

.loading-spinner {
    width: 48px;
    height: 48px;
    border: 3px solid var(--bg-elevated);
    border-top-color: var(--team-home);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto var(--space-lg);
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* ========================================================================
   SCHEDULE BROWSER STYLES
   ======================================================================== */

.schedule-section {
    margin-top: var(--space-xl);
    padding-top: var(--space-xl);
    border-top: 1px solid var(--border-subtle);
}

.schedule-section h3 {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 18px;
    margin-bottom: var(--space-md);
    color: var(--accent-purple);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
}

.schedule-config {
    max-width: 700px;
    margin: 0 auto var(--space-lg);
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
}

.schedule-url-display {
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    padding: var(--space-md);
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--text-secondary);
    word-break: break-all;
}

.schedule-btn {
    background: linear-gradient(135deg, var(--accent-purple), rgba(168, 85, 247, 0.7));
    border: none;
    color: white;
    padding: 14px 28px;
    border-radius: var(--radius-md);
    cursor: pointer;
    font-family: 'DM Sans', sans-serif;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
}

.schedule-btn:hover:not(:disabled) {
    transform: translateY(-3px);
    box-shadow: 0 0 40px rgba(168, 85, 247, 0.4);
}

.schedule-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Loading Overlay */
.schedule-loading-overlay {
    position: fixed;
    inset: 0;
    background: rgba(10, 11, 15, 0.95);
    z-index: 999998;
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}

.schedule-loading-overlay.active {
    display: flex;
}

.schedule-loading-box {
    background: var(--bg-card);
    backdrop-filter: blur(20px);
    border: 1px solid var(--border-subtle);
    border-radius: 24px;
    padding: 48px;
    width: 500px;
    max-width: 90%;
    text-align: center;
    position: relative;
}

.schedule-loading-box::before {
    content: '';
    position: absolute;
    top: -1px;
    left: -1px;
    right: -1px;
    height: 3px;
    background: linear-gradient(90deg, var(--accent-purple), var(--accent-cyan));
    border-radius: 24px 24px 0 0;
}

.loading-icon {
    width: 80px;
    height: 80px;
    margin: 0 auto 24px;
    background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
    border-radius: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    animation: pulse-glow 2s ease-in-out infinite;
}

@keyframes pulse-glow {
    0%, 100% { box-shadow: 0 0 20px rgba(168, 85, 247, 0.4); }
    50% { box-shadow: 0 0 40px rgba(168, 85, 247, 0.8); }
}

.loading-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text-primary);
}

.loading-subtitle {
    color: var(--text-secondary);
    font-size: 14px;
    margin-bottom: 24px;
}

.loading-progress-container {
    background: var(--bg-elevated);
    border-radius: 10px;
    height: 20px;
    overflow: hidden;
    margin-bottom: 12px;
    border: 1px solid var(--border-subtle);
}

.loading-progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--accent-purple), var(--accent-cyan));
    border-radius: 10px;
    transition: width 0.3s ease;
    position: relative;
    overflow: hidden;
}

.loading-progress-bar::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.loading-progress-text {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    color: var(--text-primary);
    margin-bottom: 8px;
}

.loading-current-game {
    font-size: 12px;
    color: var(--text-muted);
    min-height: 20px;
}

.loading-cancel-btn {
    margin-top: 24px;
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    color: var(--text-secondary);
    padding: 10px 24px;
    border-radius: var(--radius-md);
    cursor: pointer;
    font-family: 'DM Sans', sans-serif;
    font-size: 13px;
    transition: all 0.2s ease;
}

.loading-cancel-btn:hover {
    background: var(--negative-bg);
    border-color: var(--negative);
    color: var(--negative);
}

/* Game List */
.game-list-container {
    display: none;
    margin-top: var(--space-xl);
    max-width: 900px;
    margin-left: auto;
    margin-right: auto;
}

.game-list-container.active {
    display: block;
}

.game-list-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: var(--space-lg);
}

.game-list-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 20px;
    font-weight: 700;
    color: var(--text-bright);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}

.game-list-count {
    background: var(--accent-purple);
    color: white;
    padding: 4px 12px;
    border-radius: 100px;
    font-size: 12px;
    font-weight: 600;
}

.game-list-close {
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    color: var(--text-secondary);
    padding: 8px 16px;
    border-radius: var(--radius-md);
    cursor: pointer;
    font-family: 'DM Sans', sans-serif;
    font-size: 13px;
    transition: all 0.2s ease;
}

.game-list-close:hover {
    background: var(--negative-bg);
    border-color: var(--negative);
    color: var(--negative);
}

.game-list-filters {
    display: flex;
    gap: var(--space-md);
    margin-bottom: var(--space-lg);
    flex-wrap: wrap;
}

.game-filter-input {
    flex: 1;
    min-width: 200px;
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    color: var(--text-primary);
    padding: 10px 16px;
    border-radius: var(--radius-md);
    font-family: 'DM Sans', sans-serif;
    font-size: 14px;
    transition: all 0.3s ease;
}

.game-filter-input:focus {
    outline: none;
    border-color: var(--accent-purple);
    box-shadow: 0 0 15px rgba(168, 85, 247, 0.2);
}

.game-list {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
    max-height: 500px;
    overflow-y: auto;
    padding-right: var(--space-sm);
}

.game-list::-webkit-scrollbar {
    width: 6px;
}

.game-list::-webkit-scrollbar-track {
    background: var(--bg-elevated);
    border-radius: 3px;
}

.game-list::-webkit-scrollbar-thumb {
    background: var(--accent-purple);
    border-radius: 3px;
}

.game-item {
    display: grid;
    grid-template-columns: 80px 1fr auto 100px;
    gap: var(--space-md);
    align-items: center;
    padding: var(--space-md) var(--space-lg);
    background: var(--bg-elevated);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    cursor: pointer;
    transition: all 0.3s ease;
}

.game-item:hover {
    background: rgba(168, 85, 247, 0.1);
    border-color: var(--accent-purple);
    transform: translateX(4px);
}

.game-item-date {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    color: var(--text-muted);
    text-align: center;
}

.game-item-date .day {
    font-size: 18px;
    font-weight: 700;
    color: var(--text-primary);
    display: block;
}

.game-item-teams {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.game-item-team {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-size: 14px;
    font-weight: 500;
}

.game-item-team.home {
    color: var(--team-home);
}

.game-item-team.away {
    color: var(--team-away);
}

.game-item-score {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
}

.game-item-score-value {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 20px;
    font-weight: 700;
}

.game-item-score-value.home {
    color: var(--team-home);
}

.game-item-score-value.away {
    color: var(--team-away);
}

.game-item-score-divider {
    font-size: 10px;
    color: var(--text-muted);
}

.game-item-action {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    color: var(--accent-purple);
    font-size: 13px;
    font-weight: 600;
}

.game-item-action::after {
    content: '→';
    transition: transform 0.2s ease;
}

.game-item:hover .game-item-action::after {
    transform: translateX(4px);
}

.game-item.loading {
    opacity: 0.6;
    pointer-events: none;
}

.game-item.loading .game-item-action::after {
    content: '';
    width: 16px;
    height: 16px;
    border: 2px solid var(--accent-purple);
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

.no-games-message {
    text-align: center;
    padding: var(--space-2xl);
    color: var(--text-muted);
}

/* FOOTER */
.footer-note {
    text-align: center;
    padding: var(--space-xl);
    color: var(--text-muted);
    font-size: 11px;
}

input[type="file"] {
    display: none;
}

/* Live floating bar */
.live-floating-bar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg-card);
    backdrop-filter: blur(20px);
    border: 1px solid var(--positive);
    border-radius: 100px;
    padding: 10px 24px;
    display: none;
    align-items: center;
    gap: var(--space-lg);
    z-index: 1000;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
}

.live-floating-bar.active {
    display: flex;
}

.floating-status {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-size: 13px;
    font-weight: 500;
    color: var(--positive);
}

.floating-countdown {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    color: var(--text-secondary);
}

.floating-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 6px;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.floating-btn:hover {
    background: var(--bg-elevated);
    color: var(--text-bright);
}

/* Debug panel */
.debug-panel {
    background: var(--bg-elevated);
    border: 1px solid var(--accent-gold);
    border-radius: var(--radius-md);
    padding: var(--space-md);
    margin-top: var(--space-lg);
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    max-height: 200px;
    overflow-y: auto;
    display: none;
}

.debug-panel.active {
    display: block;
}

.debug-panel pre {
    white-space: pre-wrap;
    color: var(--text-secondary);
}

/* ========================================================================
   MARGIN TAB STYLES
   ======================================================================== */

.margin-tab-container {
    padding: var(--space-lg);
}

.margin-controls {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-lg);
    margin-bottom: var(--space-xl);
    padding: var(--space-lg);
    background: var(--bg-elevated);
    border-radius: var(--radius-md);
    align-items: center;
}

.margin-team-selector {
    display: flex;
    gap: var(--space-md);
}

.margin-team-btn {
    padding: 12px 24px;
    background: var(--bg-glass);
    border: 2px solid var(--border-subtle);
    color: var(--text-secondary);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    border-radius: var(--radius-md);
    transition: all 0.3s ease;
}

.margin-team-btn:hover {
    border-color: var(--text-muted);
    color: var(--text-primary);
}

.margin-team-btn.active.home {
    background: var(--team-home-bg);
    border-color: var(--team-home);
    color: var(--team-home);
    box-shadow: 0 0 20px var(--accent-cyan-glow);
}

.margin-team-btn.active.away {
    background: var(--team-away-bg);
    border-color: var(--team-away);
    color: var(--team-away);
    box-shadow: 0 0 20px var(--accent-magenta-glow);
}

.margin-input-group {
    display: flex;
    align-items: center;
    gap: var(--space-md);
}

.margin-input-group label {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 13px;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.margin-input {
    width: 80px;
    padding: 10px 14px;
    background: var(--bg-base);
    border: 2px solid var(--border-subtle);
    border-radius: var(--radius-sm);
    color: var(--text-bright);
    font-family: 'Space Mono', monospace;
    font-size: 18px;
    font-weight: 700;
    text-align: center;
    transition: all 0.3s ease;
}

.margin-input:focus {
    outline: none;
    border-color: var(--accent-gold);
    box-shadow: 0 0 15px rgba(255, 208, 0, 0.3);
}

.margin-calculate-btn {
    padding: 12px 28px;
    background: linear-gradient(135deg, var(--accent-gold), rgba(255, 208, 0, 0.7));
    border: none;
    color: var(--bg-base);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    border-radius: var(--radius-md);
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.margin-calculate-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 0 30px rgba(255, 208, 0, 0.4);
}

.margin-stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-xl);
}

@media (max-width: 1200px) {
    .margin-stats-grid {
        grid-template-columns: 1fr;
    }
}

.margin-team-card {
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-subtle);
    overflow: hidden;
}

.margin-team-card.home {
    border-color: rgba(0, 212, 255, 0.3);
}

.margin-team-card.away {
    border-color: rgba(255, 0, 170, 0.3);
}

.margin-team-header {
    padding: var(--space-md) var(--space-lg);
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.margin-team-header.home {
    background: linear-gradient(90deg, var(--team-home-bg), transparent);
    border-bottom: 2px solid rgba(0, 212, 255, 0.3);
}

.margin-team-header.away {
    background: linear-gradient(90deg, var(--team-away-bg), transparent);
    border-bottom: 2px solid rgba(255, 0, 170, 0.3);
}

.margin-team-name {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 16px;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}

.margin-team-name.home { color: var(--team-home); }
.margin-team-name.away { color: var(--team-away); }

.margin-stats-table {
    width: 100%;
    border-collapse: collapse;
}

.margin-stats-table th {
    padding: var(--space-sm) var(--space-md);
    text-align: center;
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
    background: var(--bg-elevated);
    border-bottom: 1px solid var(--border-subtle);
}

.margin-stats-table th:first-child {
    text-align: left;
    padding-left: var(--space-lg);
}

.margin-stats-table td {
    padding: var(--space-sm) var(--space-md);
    text-align: center;
    font-size: 13px;
    border-bottom: 1px solid var(--border-subtle);
    transition: all 0.2s ease;
}

.margin-stats-table td:first-child {
    text-align: left;
    padding-left: var(--space-lg);
    font-weight: 500;
    color: var(--text-secondary);
}

.margin-stats-table tr:hover {
    background: var(--bg-glass);
}

.margin-stat-value {
    font-family: 'Space Mono', monospace;
    font-weight: 600;
    color: var(--text-bright);
}

.margin-stat-checkbox {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: var(--accent-cyan);
}

.margin-adjustment {
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    gap: 0px;
    padding: 4px 8px;
    border-radius: var(--radius-sm);
    font-family: 'Space Mono', monospace;
    font-size: 13px;
    font-weight: 700;
    min-width: 95px;
    justify-content: center;
}

.margin-adjustment.positive {
    background: var(--positive-bg);
    color: var(--positive);
    border: 1px solid rgba(0, 255, 136, 0.3);
}

.margin-adjustment.negative {
    background: var(--negative-bg);
    color: var(--negative);
    border: 1px solid rgba(255, 107, 107, 0.3);
}

.margin-adjustment.neutral {
    background: var(--bg-elevated);
    color: var(--text-muted);
    border: 1px solid var(--border-subtle);
}

.margin-adjustment-icon {
    font-size: 14px;
    font-weight: 900;
}

.margin-main-value {
    display: flex;
    align-items: center;
    gap: 2px;
    font-size: 13px;
}

.margin-translation {
    display: block;
    font-size: 9px;
    font-weight: 600;
    opacity: 0.9;
    margin-top: 1px;
    white-space: nowrap;
    letter-spacing: -0.3px;
}

.margin-adjustment.positive .margin-translation {
    color: var(--positive);
}

.margin-adjustment.negative .margin-translation {
    color: var(--negative);
}

.margin-adjustment.worsening {
    background: var(--negative-bg);
    border: 1px solid rgba(255, 107, 107, 0.4);
    position: relative;
}

.margin-adjustment.worsening .margin-main-value {
    color: var(--negative);
}

.margin-worsen-label {
    display: block;
    font-size: 8px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--negative);
    opacity: 0.9;
    margin-top: 1px;
}

.margin-result-panel {
    margin-top: var(--space-xl);
    padding: var(--space-lg);
    background: var(--bg-elevated);
    border-radius: var(--radius-lg);
    border: 2px solid var(--accent-gold);
    box-shadow: 0 0 30px rgba(255, 208, 0, 0.15);
}

.margin-result-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: var(--space-lg);
    padding-bottom: var(--space-md);
    border-bottom: 1px solid var(--border-subtle);
}

.margin-result-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 16px;
    font-weight: 700;
    color: var(--accent-gold);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}

.margin-result-score {
    font-family: 'Space Mono', monospace;
    font-size: 24px;
    font-weight: 700;
}

.margin-result-score .home { color: var(--team-home); }
.margin-result-score .away { color: var(--team-away); }
.margin-result-score .divider { color: var(--text-muted); margin: 0 8px; }

.margin-methodology {
    margin-top: var(--space-lg);
    padding: var(--space-md);
    background: var(--bg-glass);
    border-radius: var(--radius-sm);
    border-left: 3px solid var(--accent-purple);
}

.margin-methodology-title {
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--accent-purple);
    margin-bottom: var(--space-sm);
}

.margin-methodology-text {
    font-size: 12px;
    color: var(--text-secondary);
    line-height: 1.6;
}

.margin-methodology-formula {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--text-muted);
    margin-top: var(--space-sm);
    padding: var(--space-sm);
    background: var(--bg-base);
    border-radius: var(--radius-sm);
}

.margin-category-header {
    padding: var(--space-xs) var(--space-lg);
    background: var(--bg-glass);
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-muted);
    border-bottom: 1px solid var(--border-subtle);
}

.margin-epa-indicator {
    font-size: 10px;
    color: var(--text-muted);
    margin-left: 4px;
}

/* Responsive */
@media (max-width: 1400px) {
    .stats-grid { grid-template-columns: 1fr; }
    .stat-card.full-width { grid-column: span 1; }
    .factors-grid { grid-template-columns: repeat(3, 1fr); }
}

@media (max-width: 1000px) {
    .game-header {
        grid-template-columns: 1fr;
        text-align: center;
    }
    .team-block, .team-block.away {
        flex-direction: column;
        text-align: center;
    }
}

/* ========================================================================
   SHOT CHART TAB STYLES
   ======================================================================== */

.shot-chart-container {
    padding: var(--space-lg);
    min-height: 100vh;
}

.shot-chart-controls {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-lg);
    margin-bottom: var(--space-xl);
    padding: var(--space-lg);
    background: var(--bg-elevated);
    border-radius: var(--radius-md);
    align-items: center;
}

.shot-chart-control-group {
    display: flex;
    flex-direction: column;
    gap: var(--space-xs);
}

.shot-chart-control-group label {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.shot-chart-select {
    padding: 10px 16px;
    background: var(--bg-base);
    border: 2px solid var(--border-subtle);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 14px;
    min-width: 200px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.shot-chart-select:hover {
    border-color: var(--accent-cyan);
}

.shot-chart-select:focus {
    outline: none;
    border-color: var(--accent-cyan);
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
}

.shot-chart-legend {
    display: flex;
    gap: var(--space-lg);
    margin-left: auto;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-size: 13px;
    color: var(--text-secondary);
}

.legend-dot {
    width: 16px;
    height: 16px;
    border-radius: 50%;
}

.legend-dot.made {
    background: var(--positive);
    box-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
}

.legend-dot.missed {
    background: var(--negative);
    box-shadow: 0 0 8px rgba(255, 107, 107, 0.5);
}

.shot-chart-court-container {
    position: relative;
    width: 100%;
    max-width: 1800px;
    margin: 0 auto var(--space-xl);
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-subtle);
    overflow: visible;
}

.shot-chart-court {
    position: relative;
    width: 100%;
    padding-bottom: 53%;
    background: linear-gradient(180deg, rgba(30, 30, 40, 1) 0%, rgba(20, 20, 30, 1) 100%);
}

.shot-chart-court svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

.court-line {
    stroke: rgba(255, 255, 255, 0.3);
    stroke-width: 2;
    fill: none;
}

.court-paint {
    fill: rgba(255, 255, 255, 0.03);
}

.court-three-zone {
    fill: rgba(0, 212, 255, 0.02);
}

.shot-marker {
    cursor: pointer;
    transition: r 0.15s ease, filter 0.15s ease;
    pointer-events: all;
}

.shot-marker:hover {
    r: 14;
}

.shot-marker.made {
    fill: var(--positive);
    filter: drop-shadow(0 0 6px rgba(0, 255, 136, 0.6));
}

.shot-marker.missed {
    fill: var(--negative);
    filter: drop-shadow(0 0 6px rgba(255, 107, 107, 0.6));
}

.shot-marker.made:hover {
    filter: drop-shadow(0 0 12px rgba(0, 255, 136, 0.9));
}

.shot-marker.missed:hover {
    filter: drop-shadow(0 0 12px rgba(255, 107, 107, 0.9));
}

.shot-tooltip {
    position: fixed;
    background: var(--bg-elevated);
    border: 1px solid var(--border-accent);
    border-radius: var(--radius-sm);
    padding: var(--space-sm) var(--space-md);
    font-size: 12px;
    color: var(--text-primary);
    pointer-events: none;
    z-index: 10000;
    white-space: nowrap;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    opacity: 0;
    transition: opacity 0.15s ease;
    transform: translate(-50%, -100%);
}

.shot-tooltip.active {
    opacity: 1;
}

.shot-chart-url-prompt {
    text-align: center;
    padding: var(--space-2xl);
    background: var(--bg-elevated);
    border-radius: var(--radius-lg);
    border: 2px dashed var(--border-accent);
    margin: var(--space-xl) 0;
}

.shot-chart-url-prompt h3 {
    color: var(--text-bright);
    margin-bottom: var(--space-md);
    font-family: 'Space Grotesk', sans-serif;
}

.shot-chart-url-prompt p {
    color: var(--text-secondary);
    margin-bottom: var(--space-lg);
}

.shot-chart-url-prompt input {
    width: 100%;
    max-width: 600px;
    padding: 14px 18px;
    background: var(--bg-base);
    border: 2px solid var(--border-subtle);
    border-radius: var(--radius-md);
    color: var(--text-primary);
    font-family: 'Space Mono', monospace;
    font-size: 13px;
    margin-bottom: var(--space-md);
    transition: all 0.3s ease;
}

.shot-chart-url-prompt input:focus {
    outline: none;
    border-color: var(--accent-gold);
    box-shadow: 0 0 20px rgba(255, 208, 0, 0.2);
}

.shot-chart-url-prompt button {
    padding: 14px 32px;
    background: linear-gradient(135deg, var(--accent-gold), rgba(255, 208, 0, 0.7));
    border: none;
    border-radius: var(--radius-md);
    color: var(--bg-base);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
}

.shot-chart-url-prompt button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(255, 208, 0, 0.3);
}

.shot-chart-loading {
    text-align: center;
    padding: var(--space-xl);
    color: var(--text-secondary);
}

.shot-chart-loading .spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--border-subtle);
    border-top-color: var(--accent-gold);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto var(--space-md);
}

.zone-overlay {
    fill: transparent;
    stroke: none;
    cursor: pointer;
    transition: all 0.3s ease;
}

.zone-overlay:hover {
    fill: rgba(255, 255, 255, 0.1);
}

.zone-label {
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 700;
    fill: var(--text-bright);
    text-anchor: middle;
    dominant-baseline: middle;
    pointer-events: none;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
}

.zone-label-pct {
    font-size: 20px;
}

.zone-label-detail {
    font-size: 10px;
    fill: var(--text-secondary);
}

/* Zone percentage colors */
.zone-cold { fill: rgba(255, 107, 107, 0.25); }
.zone-below-avg { fill: rgba(255, 165, 0, 0.2); }
.zone-avg { fill: rgba(255, 255, 255, 0.1); }
.zone-above-avg { fill: rgba(0, 212, 255, 0.2); }
.zone-hot { fill: rgba(0, 255, 136, 0.25); }

/* Shot zone stats grid */
.shot-zone-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--space-lg);
    margin-bottom: var(--space-xl);
}

.zone-stat-card {
    background: var(--bg-card);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-subtle);
    padding: var(--space-lg);
    transition: all 0.3s ease;
}

.zone-stat-card:hover {
    border-color: var(--accent-cyan);
    transform: translateY(-2px);
}

.zone-stat-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-md);
}

.zone-stat-name {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.zone-stat-pct {
    font-family: 'Space Mono', monospace;
    font-size: 24px;
    font-weight: 700;
}

.zone-stat-pct.hot { color: var(--positive); }
.zone-stat-pct.warm { color: var(--accent-cyan); }
.zone-stat-pct.neutral { color: var(--text-secondary); }
.zone-stat-pct.cool { color: var(--warning); }
.zone-stat-pct.cold { color: var(--negative); }

.zone-stat-detail {
    font-size: 12px;
    color: var(--text-muted);
    margin-bottom: var(--space-sm);
}

.zone-stat-bar-container {
    height: 8px;
    background: var(--bg-elevated);
    border-radius: 4px;
    overflow: hidden;
}

.zone-stat-bar {
    height: 100%;
    border-radius: 4px;
    transition: width 0.5s ease;
}

.zone-stat-bar.hot { background: linear-gradient(90deg, var(--positive), rgba(0, 255, 136, 0.5)); }
.zone-stat-bar.warm { background: linear-gradient(90deg, var(--accent-cyan), rgba(0, 212, 255, 0.5)); }
.zone-stat-bar.neutral { background: linear-gradient(90deg, var(--text-secondary), rgba(136, 146, 168, 0.5)); }
.zone-stat-bar.cool { background: linear-gradient(90deg, var(--warning), rgba(255, 165, 0, 0.5)); }
.zone-stat-bar.cold { background: linear-gradient(90deg, var(--negative), rgba(255, 107, 107, 0.5)); }

/* Shot chart bar chart */
.shot-chart-bar-container {
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-subtle);
    padding: var(--space-xl);
    margin-top: var(--space-xl);
}

.shot-chart-bar-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 18px;
    font-weight: 700;
    color: var(--text-bright);
    margin-bottom: var(--space-lg);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}

.shot-chart-bars {
    display: flex;
    justify-content: space-around;
    align-items: flex-end;
    height: 300px;
    padding: var(--space-lg) 0;
    border-bottom: 2px solid var(--border-subtle);
}

.shot-bar-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space-sm);
    flex: 1;
    max-width: 120px;
}

.shot-bar {
    width: 60px;
    min-height: 4px;
    border-radius: 4px 4px 0 0;
    transition: height 0.5s ease;
    position: relative;
}

.shot-bar::after {
    content: attr(data-pct);
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Space Mono', monospace;
    font-size: 14px;
    font-weight: 700;
    color: var(--text-bright);
}

.shot-bar-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    text-align: center;
    margin-top: var(--space-sm);
}

.shot-bar-count {
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    color: var(--text-muted);
}

/* Period filter buttons */
.shot-chart-period-filter {
    display: flex;
    gap: var(--space-sm);
    flex-wrap: wrap;
}

.period-filter-btn {
    padding: 8px 16px;
    background: var(--bg-glass);
    border: 1px solid var(--border-subtle);
    color: var(--text-secondary);
    font-family: 'Space Grotesk', sans-serif;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    border-radius: var(--radius-sm);
    transition: all 0.3s ease;
}

.period-filter-btn:hover {
    border-color: var(--accent-cyan);
    color: var(--text-primary);
}

.period-filter-btn.active {
    background: linear-gradient(135deg, var(--accent-cyan), rgba(0, 212, 255, 0.7));
    border-color: transparent;
    color: var(--bg-base);
}

/* Summary stats row */
.shot-chart-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: var(--space-md);
    margin-bottom: var(--space-xl);
    padding: var(--space-lg);
    background: var(--bg-elevated);
    border-radius: var(--radius-md);
}

.summary-stat {
    text-align: center;
}

.summary-stat-value {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 28px;
    font-weight: 700;
    color: var(--text-bright);
}

.summary-stat-label {
    font-size: 11px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.summary-stat-value.positive { color: var(--positive); }
.summary-stat-value.negative { color: var(--negative); }
.summary-stat-value.neutral { color: var(--accent-cyan); }

/* ═══════════════════════════════════════════════════════════════════════════
   COMPREHENSIVE MOBILE SUPPORT - Full Range Responsive Design
   Supports: iOS, Android, tablets, and all touch devices
   ═══════════════════════════════════════════════════════════════════════════ */

/* Mobile Detection CSS Custom Properties */
:root {
    --is-mobile: 0;
    --is-touch: 0;
    --safe-area-top: env(safe-area-inset-top, 0px);
    --safe-area-bottom: env(safe-area-inset-bottom, 0px);
    --safe-area-left: env(safe-area-inset-left, 0px);
    --safe-area-right: env(safe-area-inset-right, 0px);
}

/* Touch-friendly tap targets */
@media (pointer: coarse) {
    :root { --is-touch: 1; }
    button, select, input, .interactive { min-height: 44px; min-width: 44px; }
    select, input { font-size: 16px !important; }
}

/* ═══════════════════════════════════════════════════════════════════════════
   TABLET BREAKPOINT (768px - 1024px)
   ═══════════════════════════════════════════════════════════════════════════ */
@media (max-width: 1024px) {
    .container { padding: var(--space-md); }
    .game-header { flex-direction: column; gap: var(--space-md); }
    .team-info { flex-direction: row; justify-content: space-between; width: 100%; }
    .quarter-nav { flex-wrap: wrap; }
}

/* ═══════════════════════════════════════════════════════════════════════════
   MOBILE BREAKPOINT (max-width: 768px)
   ═══════════════════════════════════════════════════════════════════════════ */
@media (max-width: 768px) {
    :root { --is-mobile: 1; }

    body {
        padding-top: var(--safe-area-top);
        padding-bottom: calc(var(--space-md) + var(--safe-area-bottom));
        padding-left: var(--safe-area-left);
        padding-right: var(--safe-area-right);
    }

    .container {
        padding: var(--space-sm);
    }

    /* Game Header - Stack vertically */
    .game-header {
        flex-direction: column;
        gap: var(--space-md);
        padding: var(--space-md);
    }

    .team-info {
        flex-direction: column;
        text-align: center;
    }

    .team-score {
        font-size: 48px;
    }

    .team-name {
        font-size: 14px;
    }

    .game-meta {
        font-size: 11px;
    }

    /* Quarter Navigation - Horizontal scroll */
    .quarter-nav {
        display: flex;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        padding: var(--space-sm);
        gap: var(--space-xs);
        scroll-snap-type: x mandatory;
    }

    .quarter-nav button {
        flex-shrink: 0;
        scroll-snap-align: start;
        padding: 10px 16px;
        font-size: 12px;
    }

    /* View Tabs - Horizontal scroll */
    .view-tabs {
        display: flex;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        gap: var(--space-xs);
        padding-bottom: var(--space-sm);
    }

    .view-tab {
        flex-shrink: 0;
        white-space: nowrap;
        padding: 10px 14px;
        font-size: 12px;
    }

    /* Stat Cards - 2 column grid */
    .stat-grid, .stats-grid {
        grid-template-columns: repeat(2, 1fr) !important;
        gap: var(--space-sm);
    }

    .stat-card {
        padding: var(--space-sm);
    }

    .stat-value {
        font-size: 24px;
    }

    .stat-label {
        font-size: 10px;
    }

    /* Player Cards - Stack */
    .player-cards-grid {
        grid-template-columns: 1fr !important;
        gap: var(--space-sm);
    }

    .player-card {
        padding: var(--space-md);
    }

    .player-name {
        font-size: 14px;
    }

    /* Tables - Horizontal scroll */
    .table-container {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }

    table {
        min-width: 600px;
        font-size: 11px;
    }

    th, td {
        padding: var(--space-sm) var(--space-xs);
    }

    /* Shot Chart - Scale down */
    .shot-chart-container {
        max-width: 100%;
        overflow: hidden;
    }

    .shot-chart svg {
        max-width: 100%;
        height: auto;
    }

    /* Play-by-Play - Compact */
    .play-item {
        padding: var(--space-sm);
        font-size: 12px;
    }

    .play-time {
        font-size: 10px;
    }

    /* Modals - Full screen */
    .modal-content {
        width: 100% !important;
        height: 100% !important;
        max-height: 100vh !important;
        border-radius: 0 !important;
        padding: var(--space-md);
        padding-top: calc(var(--space-md) + var(--safe-area-top));
    }

    .modal-close {
        position: fixed;
        top: calc(var(--space-md) + var(--safe-area-top));
        right: var(--space-md);
        width: 44px;
        height: 44px;
        z-index: 1001;
    }

    /* Password Box - Mobile */
    #_gvAuthBox {
        width: calc(100% - 32px) !important;
        max-width: 360px !important;
        padding: 24px !important;
    }

    ._gvLogo {
        width: 64px !important;
        height: 64px !important;
    }

    ._gvTitle {
        font-size: 20px !important;
    }

    #_gvPwd {
        font-size: 16px !important;
        padding: 14px !important;
    }

    /* Comparison View */
    .comparison-grid {
        grid-template-columns: 1fr !important;
    }

    /* Four Factors */
    .four-factors-grid {
        grid-template-columns: repeat(2, 1fr) !important;
    }

    /* Legend */
    .legend {
        flex-wrap: wrap;
        gap: var(--space-xs);
    }

    .legend-item {
        font-size: 10px;
        padding: var(--space-xs) var(--space-sm);
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
   SMALL MOBILE BREAKPOINT (max-width: 480px)
   ═══════════════════════════════════════════════════════════════════════════ */
@media (max-width: 480px) {
    .container {
        padding: var(--space-xs);
    }

    .team-score {
        font-size: 36px;
    }

    .stat-grid, .stats-grid {
        grid-template-columns: 1fr 1fr !important;
    }

    .stat-value {
        font-size: 20px;
    }

    table {
        font-size: 10px;
    }

    th, td {
        padding: 4px 2px;
    }

    .quarter-nav button {
        padding: 8px 12px;
        font-size: 11px;
    }

    .view-tab {
        padding: 8px 10px;
        font-size: 11px;
    }

    .player-card {
        padding: var(--space-sm);
    }

    .four-factors-grid {
        grid-template-columns: 1fr 1fr !important;
        gap: var(--space-xs);
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
   LANDSCAPE MOBILE
   ═══════════════════════════════════════════════════════════════════════════ */
@media (orientation: landscape) and (max-height: 500px) {
    .game-header {
        flex-direction: row;
        padding: var(--space-sm) var(--space-md);
    }

    .team-score {
        font-size: 32px;
    }

    .stat-grid, .stats-grid {
        grid-template-columns: repeat(4, 1fr) !important;
    }

    .modal-content {
        padding: var(--space-sm);
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
   TOUCH-SPECIFIC ENHANCEMENTS
   ═══════════════════════════════════════════════════════════════════════════ */
@media (hover: none) and (pointer: coarse) {
    /* Remove hover effects */
    button:hover, .interactive:hover {
        transform: none !important;
        box-shadow: none !important;
    }

    /* Add active states */
    button:active, .interactive:active {
        opacity: 0.7;
        transform: scale(0.98);
    }

    /* Better scrolling */
    .table-container,
    .quarter-nav,
    .view-tabs,
    .modal-content {
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
   iOS-SPECIFIC FIXES
   ═══════════════════════════════════════════════════════════════════════════ */
@supports (-webkit-touch-callout: none) {
    input, select, textarea {
        font-size: 16px !important;
    }

    .modal-content {
        padding-bottom: calc(var(--space-md) + env(safe-area-inset-bottom));
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
   MOBILE UTILITY CLASSES
   ═══════════════════════════════════════════════════════════════════════════ */
@media (max-width: 768px) {
    .desktop-only { display: none !important; }
    .mobile-scroll-hint::after {
        content: '← Swipe →';
        display: block;
        text-align: center;
        font-size: 10px;
        color: var(--text-muted);
        padding: var(--space-xs);
    }
}

@media (min-width: 769px) {
    .mobile-only { display: none !important; }
}

/* ═══════════════════════════════════════════════════════════════════════════ */

    </style>
</head>
<body>
    <!-- ═══════════════════════════════════════════════════════════════════════════
         PASSWORD PROTECTION SYSTEM v3.1
         CENTRAL PASSWORD CONTROL - Change password in _GV_CONFIG below
         ═══════════════════════════════════════════════════════════════════════════ -->
    <div id="_gvAuthOverlay">
        <div id="_gvAuthBox">
            <div class="_gvLogo">GV</div>
            <div class="_gvTitle">FIBA Game Visualizer</div>
            <div class="_gvSub">Authentication Required</div>
            <input type="password" id="_gvPwd" placeholder="Enter access password" autocomplete="off" spellcheck="false">
            <div id="_gvRememberRow" style="display:none;margin:12px 0;text-align:left;">
                <label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:13px;color:#8892a8;">
                    <input type="checkbox" id="_gvRememberPwd" style="width:16px;height:16px;cursor:pointer;">
                    <span>Remember password on this device</span>
                </label>
            </div>
            <button id="_gvSubmit">Unlock Application</button>
            <div id="_gvErrMsg" class="_gvErr"></div>
            <div class="_gvLock">🔒 Protected Content</div>
        </div>
    </div>
    
    <script>
    // ═══════════════════════════════════════════════════════════════════════════
    // MOBILE DETECTION & DEVICE UTILITIES
    // Comprehensive detection for iOS, Android, tablets, and touch devices
    // ═══════════════════════════════════════════════════════════════════════════
    const MobileDetect = (function() {
        'use strict';

        const ua = navigator.userAgent || navigator.vendor || window.opera || '';
        const platform = navigator.platform || '';

        const isIOS = /iPad|iPhone|iPod/.test(ua) || (platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        const isAndroid = /Android/.test(ua);
        const isMobileUA = /Mobile|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
        const isSmallScreen = window.innerWidth <= 768;
        const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const hasCoarsePointer = window.matchMedia('(pointer: coarse)').matches;

        const isMobile = isIOS || isAndroid || (isMobileUA && isSmallScreen);
        const isTablet = ((isIOS || isAndroid) && !isMobileUA) || (hasTouch && window.innerWidth >= 768 && window.innerWidth <= 1024);
        const isTouchDevice = hasTouch || hasCoarsePointer;

        function updateCSSProperties() {
            document.documentElement.style.setProperty('--is-mobile', isMobile ? '1' : '0');
            document.documentElement.style.setProperty('--is-touch', isTouchDevice ? '1' : '0');
        }

        function updateBodyClasses() {
            const body = document.body;
            if (!body) return;
            body.classList.toggle('is-mobile', isMobile);
            body.classList.toggle('is-tablet', isTablet);
            body.classList.toggle('is-touch', isTouchDevice);
            body.classList.toggle('is-ios', isIOS);
            body.classList.toggle('is-android', isAndroid);
        }

        function handleResize() {
            updateCSSProperties();
            updateBodyClasses();
        }

        function init() {
            updateCSSProperties();
            if (document.body) updateBodyClasses();
            else document.addEventListener('DOMContentLoaded', updateBodyClasses);
            window.addEventListener('resize', handleResize);
            window.addEventListener('orientationchange', () => setTimeout(handleResize, 100));
        }

        init();

        return {
            get isMobile() { return isMobile; },
            get isTablet() { return isTablet; },
            get isTouchDevice() { return isTouchDevice; },
            get isIOS() { return isIOS; },
            get isAndroid() { return isAndroid; },
            refresh: handleResize
        };
    })();

    window.MobileDetect = MobileDetect;

    // ═══════════════════════════════════════════════════════════════════════════
    // COPY PROTECTION SYSTEM v4.0 - COMPREHENSIVE ANTI-TAMPERING
    // Multi-layer protection with distributed integrity checks
    // ═══════════════════════════════════════════════════════════════════════════

    const _0x7f = "WktUGhE4XRkSEXQcVjBkNB0aXhwLR2QhCU9gNw4wATYPOHQ3UydkNR0vSSELHkkhDxpnNlc3WSJTL142CjxeIR0ndzcLMGc1Vz9ZNlcVdzcRFWshHk9wNRA7dzcfM3Q3DhpZIlcjATVUN2c3DzxkIlMzZzYONGchHjdJNVc/ZzcQTkobDyBrLRIaZCEUDmQZVSRkISlPYBoROF40V0NkIldDARoNPGsiHSBdIVYedBwXEl40VzhrGQlPSjRRO3sbVyR7GQ==";

    // Decoy variables (confuse code analysis)
    const _0x8a = "aHR0cHM6Ly9mYWtlLmNvbS9hdXRo";
    const _0x9b = [104,116,116,112,115,58,47,47,100,101,99,111,121];
    const _0x6c = "==QZslmcvN2Y";
    const _0xfa = {u:"https://",d:"decoy.com",p:"/fake"};

    const _GV_CONFIG = {
        _e: _0x7f,
        _k: "gv3x",
        sessionMinutes: 60,
        maxAttempts: 5,
        lockoutMinutes: 15,
        cacheMinutes: 5
    };

    // ═══════════════════════════════════════════════════════════════════════════
    // PARENT APP BRIDGE - Communication with Tauri launcher for password save/auto-fill
    // ═══════════════════════════════════════════════════════════════════════════
    const _ParentBridge = (function() {
        'use strict';

        const PARENT_ORIGIN = '*'; // Accept from any parent (Tauri app)
        const APP_ID = 'gamevis'; // Unique identifier for this app

        let isInIframe = false;
        let parentReady = false;
        let pendingPassword = null;

        // Check if running inside an iframe
        function detectIframe() {
            try {
                isInIframe = window.self !== window.top;
            } catch (e) {
                isInIframe = true; // Cross-origin restriction means we're in iframe
            }
            return isInIframe;
        }

        // Send message to parent app
        function sendToParent(type, data = {}) {
            if (!isInIframe) return;
            try {
                window.parent.postMessage({
                    source: 'slb-remote-app',
                    type: type,
                    appId: APP_ID,
                    ...data
                }, PARENT_ORIGIN);
            } catch (e) {
                console.log('[ParentBridge] Failed to send message:', e);
            }
        }

        // Handle messages from parent
        function handleParentMessage(event) {
            const data = event.data;
            if (!data || typeof data !== 'object' || data.source !== 'slb-parent-app') {
                return;
            }

            console.log('[ParentBridge] Received:', data.type);

            switch (data.type) {
                case 'SAVED_PASSWORD':
                    parentReady = true;
                    if (data.password) {
                        pendingPassword = data.password;
                        // Auto-fill the password field if overlay is visible
                        const pwdInput = document.getElementById('_gvPwd');
                        const overlay = document.getElementById('_gvAuthOverlay');
                        if (pwdInput && overlay && overlay.style.display !== 'none') {
                            pwdInput.value = data.password;
                            // Show remember checkbox as checked since we have a saved password
                            const rememberRow = document.getElementById('_gvRememberRow');
                            const rememberCb = document.getElementById('_gvRememberPwd');
                            if (rememberRow) rememberRow.style.display = 'block';
                            if (rememberCb) rememberCb.checked = true;

                            // Auto-submit after a short delay to allow UI to update
                            setTimeout(() => {
                                const submitBtn = document.getElementById('_gvSubmit');
                                if (submitBtn && !submitBtn.disabled) {
                                    submitBtn.click();
                                }
                            }, 300);
                        }
                    }
                    break;

                case 'NO_SAVED_PASSWORD':
                    parentReady = true;
                    // Show the remember checkbox option
                    const rememberRow = document.getElementById('_gvRememberRow');
                    if (rememberRow) rememberRow.style.display = 'block';
                    break;

                case 'PASSWORD_SAVED':
                    console.log('[ParentBridge] Password saved successfully');
                    break;

                case 'PASSWORD_CLEARED':
                    console.log('[ParentBridge] Password cleared');
                    break;

                case 'THEME_UPDATE':
                    console.log('[ParentBridge] Theme update received:', data.theme);
                    applyParentTheme(data.theme);
                    break;
            }
        }

        // Apply theme from parent Tauri app
        function applyParentTheme(theme) {
            if (!theme) return;

            const root = document.documentElement;
            const primaryColor = theme.primaryColor;
            const accentColor = theme.accentColor;
            const isLight = theme.backgroundMode === 'light';

            // Apply background mode (dark/light)
            if (isLight) {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }

            // Update CSS custom properties - GAMEVIS uses a robust variable system
            if (primaryColor) {
                root.style.setProperty('--accent-cyan', primaryColor);
                root.style.setProperty('--team-home', primaryColor);
                root.style.setProperty('--border-accent', hexToRgba(primaryColor, 0.3));
                root.style.setProperty('--accent-cyan-glow', hexToRgba(primaryColor, 0.4));
                root.style.setProperty('--team-home-bg', hexToRgba(primaryColor, 0.15));
            }
            if (accentColor) {
                root.style.setProperty('--accent-magenta', accentColor);
                root.style.setProperty('--accent-purple', accentColor);
                root.style.setProperty('--team-away', accentColor);
                root.style.setProperty('--accent-magenta-glow', hexToRgba(accentColor, 0.3));
                root.style.setProperty('--team-away-bg', hexToRgba(accentColor, 0.15));
            }

            // Apply comprehensive color scheme based on primary color - higher opacity for visibility
            if (primaryColor && !isLight) {
                // Dark mode - stronger primary color tints to backgrounds
                root.style.setProperty('--bg-base', blendColors('#0a0b0f', primaryColor, 0.15));
                root.style.setProperty('--bg-primary', blendColors('#12141a', primaryColor, 0.18));
                root.style.setProperty('--bg-card', hexToRgba(blendColors('#161923', primaryColor, 0.22), 0.9));
                root.style.setProperty('--bg-elevated', hexToRgba(blendColors('#232837', primaryColor, 0.25), 0.92));
                root.style.setProperty('--border-subtle', hexToRgba(primaryColor, 0.28));
            }

            // Update body background and all dynamic styles
            updateBackgroundGradient(theme);
        }

        // Blend two hex colors together
        function blendColors(baseHex, tintHex, amount) {
            const base = hexToRgbObj(baseHex);
            const tint = hexToRgbObj(tintHex);
            if (!base || !tint) return baseHex;

            const r = Math.round(base.r + (tint.r - base.r) * amount);
            const g = Math.round(base.g + (tint.g - base.g) * amount);
            const b = Math.round(base.b + (tint.b - base.b) * amount);

            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // Convert hex to RGB object
        function hexToRgbObj(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Convert hex to rgba
        function hexToRgba(hex, alpha) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (result) {
                const r = parseInt(result[1], 16);
                const g = parseInt(result[2], 16);
                const b = parseInt(result[3], 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            return `rgba(0, 212, 255, ${alpha})`; // fallback cyan
        }

        // Update background gradients and comprehensive theme styles
        function updateBackgroundGradient(theme) {
            const style = document.createElement('style');
            style.id = 'theme-override';

            // Remove old theme override if exists
            const old = document.getElementById('theme-override');
            if (old) old.remove();

            if (theme.primaryColor && theme.accentColor) {
                const isLight = theme.backgroundMode === 'light';
                const primaryColor = theme.primaryColor;
                const accentColor = theme.accentColor;

                // Gradient opacities - higher for more visible effect
                const primaryOpacity = isLight ? 0.10 : 0.18;
                const accentOpacity = isLight ? 0.08 : 0.14;
                const buttonTextColor = isLight ? '#ffffff' : '#0a0b0f';

                // Generate blended colors - apply primary color tinting to BOTH light and dark modes
                let bgBase, bgPrimary, bgCard, bgElevated, borderSubtle;

                if (isLight) {
                    // Light mode with primary color tints
                    bgBase = blendColors('#f5f5f7', primaryColor, 0.06);
                    bgPrimary = blendColors('#ffffff', primaryColor, 0.04);
                    bgCard = `rgba(255, 255, 255, 0.95)`;
                    bgElevated = `rgba(${hexToRgb(blendColors('#f0f0f4', primaryColor, 0.08))}, 0.95)`;
                    borderSubtle = `rgba(${hexToRgb(blendColors('#d0d0d8', primaryColor, 0.20))}, 0.5)`;
                } else {
                    // Dark mode with primary color tints - higher opacity for visibility
                    bgBase = blendColors('#0a0b0f', primaryColor, 0.15);
                    bgPrimary = blendColors('#12141a', primaryColor, 0.18);
                    bgCard = hexToRgba(blendColors('#161923', primaryColor, 0.22), 0.9);
                    bgElevated = hexToRgba(blendColors('#232837', primaryColor, 0.25), 0.92);
                    borderSubtle = hexToRgba(primaryColor, 0.28);
                }

                // Helper to convert hex to RGB string for rgba
                function hexToRgb(hex) {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '255, 255, 255';
                }

                style.textContent = `
                    /* Body and background */
                    body {
                        background: ${bgBase} !important;
                    }
                    body::before {
                        background:
                            radial-gradient(ellipse 80% 50% at 20% 0%, ${hexToRgba(primaryColor, primaryOpacity)} 0%, transparent 50%),
                            radial-gradient(ellipse 60% 40% at 80% 100%, ${hexToRgba(accentColor, accentOpacity)} 0%, transparent 50%) !important;
                    }

                    /* Glass cards and containers */
                    .glass-card, .upload-section {
                        background: ${bgCard} !important;
                        border-color: ${borderSubtle} !important;
                    }

                    /* Stat cards and regular cards */
                    .stat-card, .card, .player-card, .lineup-card {
                        background: ${bgCard} !important;
                        border-color: ${borderSubtle} !important;
                    }

                    /* Headers */
                    .main-header, .browser-header, .game-header {
                        background: ${bgPrimary} !important;
                        border-color: ${borderSubtle} !important;
                    }

                    .card-header {
                        border-color: ${borderSubtle} !important;
                    }

                    /* Game browser cards */
                    .browser-game-card {
                        background: ${bgCard} !important;
                        border-color: ${borderSubtle} !important;
                    }
                    .browser-game-card:hover {
                        border-color: ${primaryColor} !important;
                        box-shadow: 0 4px 20px ${hexToRgba(primaryColor, 0.2)} !important;
                    }

                    /* Tab containers */
                    .tab-container {
                        background: ${hexToRgba(bgPrimary, 0.5)} !important;
                        border-color: ${borderSubtle} !important;
                    }

                    /* Inputs */
                    input, select, textarea {
                        background: ${isLight ? `rgba(${hexToRgb(blendColors('#ffffff', primaryColor, 0.03))}, 0.95)` : hexToRgba(blendColors('#0a0b0f', primaryColor, 0.18), 0.85)} !important;
                        border-color: ${borderSubtle} !important;
                    }
                    input:focus, select:focus, textarea:focus {
                        border-color: ${primaryColor} !important;
                        box-shadow: 0 0 0 3px ${hexToRgba(primaryColor, isLight ? 0.20 : 0.35)} !important;
                    }

                    /* Buttons with primary color */
                    .tab-btn.active, .quarter-tab.active {
                        background: ${primaryColor} !important;
                        color: ${buttonTextColor} !important;
                    }

                    /* Rows */
                    .play-row, .player-row, .lineup-row {
                        border-color: ${borderSubtle} !important;
                    }
                    .play-row:hover, .player-row:hover, .lineup-row:hover {
                        background: ${hexToRgba(primaryColor, 0.18)} !important;
                    }

                    /* Charts and visualizations */
                    .court-container, .shot-chart-container, .shot-court-container, .game-flow-container {
                        background: ${hexToRgba(bgPrimary, 0.6)} !important;
                        border-color: ${borderSubtle} !important;
                    }

                    /* Win probability and battle cards */
                    .win-prob-container, .battle-card, .epa-section {
                        background: ${hexToRgba(primaryColor, 0.12)} !important;
                    }

                    /* Dropdowns and popups */
                    .dropdown, .tooltip, .popup, .context-menu {
                        background: ${bgElevated} !important;
                        border-color: ${borderSubtle} !important;
                    }

                    /* Loading states */
                    .loading-overlay, .loading-progress-container {
                        background: ${hexToRgba(bgBase, 0.97)} !important;
                    }

                    /* Team input sections */
                    .team-input-section {
                        background: ${bgElevated} !important;
                    }

                    /* URL fetch sections */
                    .url-fetch-section, .folder-upload-section, .win-prob-calculator-section {
                        border-color: ${borderSubtle} !important;
                    }

                    /* Tables */
                    table, th, td {
                        border-color: ${borderSubtle} !important;
                    }
                    th {
                        background: ${hexToRgba(primaryColor, 0.18)} !important;
                    }
                    tr:hover {
                        background: ${hexToRgba(primaryColor, 0.12)} !important;
                    }

                    /* Auth overlay */
                    #_gvAuthOverlay {
                        background: ${bgBase} !important;
                    }
                    #_gvAuthOverlay::before {
                        background:
                            radial-gradient(ellipse 80% 50% at 20% 0%, ${hexToRgba(primaryColor, primaryOpacity)} 0%, transparent 50%),
                            radial-gradient(ellipse 60% 40% at 80% 100%, ${hexToRgba(accentColor, accentOpacity)} 0%, transparent 50%) !important;
                    }
                    #_gvAuthBox {
                        background: ${bgCard} !important;
                    }
                    #_gvAuthBox::before {
                        background: linear-gradient(90deg, ${primaryColor}, ${accentColor}) !important;
                    }
                    ._gvLogo {
                        background: linear-gradient(135deg, ${primaryColor}, ${accentColor}) !important;
                        color: ${buttonTextColor} !important;
                    }
                    #_gvSubmit {
                        background: linear-gradient(135deg, ${primaryColor}, ${adjustBrightness(primaryColor, -20)}) !important;
                        color: ${buttonTextColor} !important;
                    }
                    #_gvPwd {
                        background: ${isLight ? `rgba(${hexToRgb(blendColors('#ffffff', primaryColor, 0.02))}, 0.95)` : hexToRgba(blendColors('#0a0b0f', primaryColor, 0.20), 0.85)} !important;
                        color: ${isLight ? '#1a1a2e' : '#e2e8f0'} !important;
                    }
                    #_gvPwd:focus {
                        border-color: ${primaryColor} !important;
                        box-shadow: 0 0 0 3px ${hexToRgba(primaryColor, isLight ? 0.20 : 0.35)} !important;
                    }

                    /* Selection color */
                    ::selection {
                        background: ${hexToRgba(primaryColor, 0.3)} !important;
                    }

                    /* Scrollbar styling */
                    ::-webkit-scrollbar-thumb {
                        background: ${hexToRgba(primaryColor, 0.3)} !important;
                    }
                    ::-webkit-scrollbar-thumb:hover {
                        background: ${hexToRgba(primaryColor, 0.5)} !important;
                    }

                    ${isLight ? `
                    /* ─── Light Mode Visibility Enhancements ─── */

                    /* Buttons with shadows */
                    body.light-theme .btn,
                    body.light-theme button:not(.tab-btn):not(.quarter-tab) {
                        box-shadow: 0 2px 4px rgba(0,0,0,0.15), 0 1px 2px rgba(0,0,0,0.1) !important;
                        border: 1px solid rgba(0,0,0,0.1) !important;
                    }
                    body.light-theme .btn-primary,
                    body.light-theme .primary-btn,
                    body.light-theme .fetch-btn {
                        background: ${adjustBrightness(primaryColor, -15)} !important;
                        color: #ffffff !important;
                    }

                    /* Text colors for light mode */
                    body.light-theme,
                    body.light-theme .container,
                    body.light-theme td,
                    body.light-theme .stat-value,
                    body.light-theme .score {
                        color: #1a1a2e !important;
                    }
                    body.light-theme th {
                        color: #1a1a2e !important;
                        background: ${blendColors('#e8e8ec', primaryColor, 0.12)} !important;
                    }
                    body.light-theme .text-muted,
                    body.light-theme small {
                        color: #6a6a7a !important;
                    }

                    /* Performance cells - stronger colors for visibility */
                    body.light-theme .perf-excellent,
                    body.light-theme [class*="percentile-80"] {
                        background: rgba(22, 163, 74, 0.85) !important;
                        color: #ffffff !important;
                    }
                    body.light-theme .perf-good,
                    body.light-theme [class*="percentile-60"] {
                        background: rgba(132, 204, 22, 0.9) !important;
                        color: #1a1a2e !important;
                    }
                    body.light-theme .perf-average,
                    body.light-theme [class*="percentile-neutral"] {
                        background: rgba(234, 179, 8, 0.9) !important;
                        color: #1a1a2e !important;
                    }
                    body.light-theme .perf-below,
                    body.light-theme [class*="percentile-40"] {
                        background: rgba(249, 115, 22, 0.9) !important;
                        color: #ffffff !important;
                    }
                    body.light-theme .perf-poor,
                    body.light-theme [class*="percentile-20"] {
                        background: rgba(220, 38, 38, 0.85) !important;
                        color: #ffffff !important;
                    }

                    /* Badges and tags */
                    body.light-theme [class*="badge"],
                    body.light-theme [class*="tag"],
                    body.light-theme [class*="pill"] {
                        box-shadow: 0 1px 3px rgba(0,0,0,0.12) !important;
                    }

                    /* Positive/negative values */
                    body.light-theme .positive { color: #16a34a !important; font-weight: 600; }
                    body.light-theme .negative { color: #dc2626 !important; font-weight: 600; }

                    /* Links */
                    body.light-theme a { color: ${adjustBrightness(primaryColor, -15)} !important; }

                    /* Scrollbar for light */
                    body.light-theme ::-webkit-scrollbar-track { background: #f0f0f2 !important; }
                    body.light-theme ::-webkit-scrollbar-thumb { background: #c0c0c8 !important; }
                    body.light-theme ::-webkit-scrollbar-thumb:hover { background: #a0a0a8 !important; }
                    ` : ''}
                `;
                document.head.appendChild(style);
            }
        }

        // Adjust color brightness
        function adjustBrightness(hex, percent) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (!result) return hex;

            let r = parseInt(result[1], 16);
            let g = parseInt(result[2], 16);
            let b = parseInt(result[3], 16);

            r = Math.max(0, Math.min(255, r + (r * percent / 100)));
            g = Math.max(0, Math.min(255, g + (g * percent / 100)));
            b = Math.max(0, Math.min(255, b + (b * percent / 100)));

            return `#${Math.round(r).toString(16).padStart(2, '0')}${Math.round(g).toString(16).padStart(2, '0')}${Math.round(b).toString(16).padStart(2, '0')}`;
        }

        // Request saved password from parent
        function requestSavedPassword() {
            sendToParent('REQUEST_SAVED_PASSWORD');
        }

        // Save password to parent app
        function savePassword(password) {
            sendToParent('SAVE_PASSWORD', { password: password });
        }

        // Clear saved password
        function clearPassword() {
            sendToParent('CLEAR_SAVED_PASSWORD');
        }

        // Notify parent of successful authentication
        function notifyAuthSuccess() {
            sendToParent('AUTH_SUCCESS');
        }

        // Initialize the bridge
        function init() {
            if (!detectIframe()) {
                console.log('[ParentBridge] Not in iframe, bridge disabled');
                return;
            }

            console.log('[ParentBridge] Running in iframe, initializing bridge');

            // Listen for messages from parent
            window.addEventListener('message', handleParentMessage);

            // Request saved password after a short delay to ensure parent is ready
            setTimeout(requestSavedPassword, 100);
        }

        // Auto-init when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // Public API
        return {
            isInIframe: () => isInIframe,
            savePassword: savePassword,
            clearPassword: clearPassword,
            notifyAuthSuccess: notifyAuthSuccess,
            getPendingPassword: () => pendingPassword
        };
    })();

    // ═══════════════════════════════════════════════════════════════════════════
    // IMAGE BRIDGE - Request player/team images from Tauri parent app
    // ═══════════════════════════════════════════════════════════════════════════
    const ImageBridge = (function() {
        'use strict';

        const pendingRequests = new Map();
        let requestIdCounter = 0;
        let isInIframe = false;
        const imageCache = new Map();

        function detectIframe() {
            try {
                isInIframe = window.self !== window.top;
                return isInIframe;
            } catch (e) {
                isInIframe = true;
                return true;
            }
        }

        function generateRequestId() {
            return `img_${Date.now()}_${++requestIdCounter}`;
        }

        function getCacheKey(type, name, team) {
            return `${type}:${name.toLowerCase()}:${team.toLowerCase()}`;
        }

        function sendToParent(type, data) {
            if (!isInIframe) return;
            try {
                window.parent.postMessage({
                    source: 'slb-remote-app',
                    type: type,
                    ...data
                }, '*');
            } catch (e) {
                console.log('[ImageBridge] Failed to send message:', e);
            }
        }

        function handleImageResponse(data) {
            const { requestId, imageData, error } = data;

            if (pendingRequests.has(requestId)) {
                const { resolve, reject, cacheKey } = pendingRequests.get(requestId);
                pendingRequests.delete(requestId);

                if (error) {
                    reject(new Error(error));
                } else {
                    if (imageData) {
                        imageCache.set(cacheKey, imageData);
                    }
                    resolve(imageData);
                }
            }
        }

        function handleBatchResponse(data) {
            const { requestId, results, error } = data;

            if (pendingRequests.has(requestId)) {
                const { resolve, reject } = pendingRequests.get(requestId);
                pendingRequests.delete(requestId);

                if (error) {
                    reject(new Error(error));
                } else {
                    for (const [key, imageData] of Object.entries(results)) {
                        if (imageData) {
                            imageCache.set(key, imageData);
                        }
                    }
                    resolve(results);
                }
            }
        }

        window.addEventListener('message', function(event) {
            const data = event.data;
            if (!data || typeof data !== 'object' || data.source !== 'slb-parent-app') {
                return;
            }

            switch (data.type) {
                case 'PLAYER_IMAGE_RESPONSE':
                case 'TEAM_IMAGE_RESPONSE':
                    handleImageResponse(data);
                    break;
                case 'IMAGES_BATCH_RESPONSE':
                    handleBatchResponse(data);
                    break;
            }
        });

        function requestPlayerImage(playerName, teamName, leagueName = null) {
            return new Promise((resolve, reject) => {
                if (!isInIframe) {
                    resolve(null);
                    return;
                }

                const cacheKey = getCacheKey('player', playerName, teamName);
                if (imageCache.has(cacheKey)) {
                    resolve(imageCache.get(cacheKey));
                    return;
                }

                const requestId = generateRequestId();
                pendingRequests.set(requestId, { resolve, reject, cacheKey });

                setTimeout(() => {
                    if (pendingRequests.has(requestId)) {
                        pendingRequests.delete(requestId);
                        resolve(null);
                    }
                }, 30000);

                sendToParent('REQUEST_PLAYER_IMAGE', {
                    requestId,
                    playerName,
                    teamName,
                    leagueName
                });
            });
        }

        function requestTeamImage(teamName, leagueName = null) {
            return new Promise((resolve, reject) => {
                if (!isInIframe) {
                    resolve(null);
                    return;
                }

                const cacheKey = getCacheKey('team', teamName, '');
                if (imageCache.has(cacheKey)) {
                    resolve(imageCache.get(cacheKey));
                    return;
                }

                const requestId = generateRequestId();
                pendingRequests.set(requestId, { resolve, reject, cacheKey });

                setTimeout(() => {
                    if (pendingRequests.has(requestId)) {
                        pendingRequests.delete(requestId);
                        resolve(null);
                    }
                }, 30000);

                sendToParent('REQUEST_TEAM_IMAGE', {
                    requestId,
                    teamName,
                    leagueName
                });
            });
        }

        function requestImagesBatch(requests) {
            return new Promise((resolve, reject) => {
                if (!isInIframe) {
                    resolve({});
                    return;
                }

                const cachedResults = {};
                const uncachedRequests = [];

                for (const req of requests) {
                    const cacheKey = req.imageType === 'team'
                        ? getCacheKey('team', req.teamName, '')
                        : getCacheKey('player', req.playerName || '', req.teamName);

                    if (imageCache.has(cacheKey)) {
                        cachedResults[cacheKey] = imageCache.get(cacheKey);
                    } else {
                        uncachedRequests.push(req);
                    }
                }

                if (uncachedRequests.length === 0) {
                    resolve(cachedResults);
                    return;
                }

                const requestId = generateRequestId();
                pendingRequests.set(requestId, { resolve, reject, requests: uncachedRequests });

                setTimeout(() => {
                    if (pendingRequests.has(requestId)) {
                        pendingRequests.delete(requestId);
                        resolve(cachedResults);
                    }
                }, 60000);

                sendToParent('REQUEST_IMAGES_BATCH', {
                    requestId,
                    requests: uncachedRequests
                });
            });
        }

        function getCachedImage(type, name, team = '') {
            const cacheKey = getCacheKey(type, name, team);
            return imageCache.get(cacheKey) || null;
        }

        detectIframe();

        return {
            isInIframe: () => isInIframe,
            requestPlayerImage,
            requestTeamImage,
            requestImagesBatch,
            getCachedImage
        };
    })();

    window.ImageBridge = ImageBridge;

    // ═══════════════════════════════════════════════════════════════════════════
    // CORE INTEGRITY SYSTEM - Essential constants distributed
    // Removing or modifying this section will cause all calculations to fail
    // ═══════════════════════════════════════════════════════════════════════════
    const _ΞCore = (function(){
        'use strict';
        const _μ = {
            α: 0.4,                          // FTA coefficient
            β: 1,                            // Subtraction identity
            γ: 0,                            // Addition identity
            δ: 100,                          // Rating base multiplier
            ε: 2.718281828459045,            // Natural log base
            ζ: 3.141592653589793,            // Pi
            η: function(){ return this.α; },
            θ: null,                         // License validation state
            ι: Date.now(),                   // Init timestamp
            κ: [],                           // Integrity chain
            λ: 0.618033988749895,            // Golden ratio - 1
            μ: 1.4142135623730951,           // sqrt(2)
            ν: 'UNVALIDATED',                // License state
            ξ: new Map(),                    // Function registry
            ο: 0,                            // Integrity counter
            π: function(x,y,z,w){
                if(this.ν !== 'VALIDATED' && this.ν !== 'GRACE') return NaN;
                return x - y * this.β + z + this.α * w;
            },
            ρ: function(n,d){
                if(this.ν !== 'VALIDATED' && this.ν !== 'GRACE') return NaN;
                return d > 0 ? (n / d) * this.δ : 0;
            },
            σ: null,
            τ: function(){ return this.κ.length; },
            υ: function(f,n){ this.ξ.set(n,f); this.κ.push(n); },
            φ: function(n){ return this.ξ.has(n); },
            χ: function(){
                const r = [];
                this.κ.forEach(k => { if(!this.ξ.has(k)) r.push(k); });
                return r;
            },
            ψ: function(){ return this.ι; },
            ω: function(s){ this.ν = s; this.σ = btoa(Date.now().toString(36)); }
        };
        _μ.υ(_μ.π, '_ΞCore.π');
        _μ.υ(_μ.ρ, '_ΞCore.ρ');
        return _μ;
    })();

    window._Ξ_LICENSE_VALID = false;

    (function(_0x4f2a,_0x3b7c){const _0x2d9e=function(_0x5c1a){while(--_0x5c1a){_0x4f2a['push'](_0x4f2a['shift']());}};_0x2d9e(++_0x3b7c);}([],0x1f3));
    (function(){
        'use strict';
        const _ζ={_n:'gv_'+Math.random().toString(36).substr(2,9),_t:Date.now(),_m:!1,_c:0,_p:null,_f:!1};
        
        // Multi-layer URL decoder
        const _Λ=(e,k)=>{
            try{
                // Layer 1: Base64 decode
                let s=atob(e);
                // Layer 2: XOR with key
                let r='';for(let i=0;i<s.length;i++){r+=String.fromCharCode(s.charCodeAt(i)^k.charCodeAt(i%k.length));}
                // Layer 3: Reverse
                r=r.split('').reverse().join('');
                // Layer 4: Base64 decode again
                return atob(r);
            }catch(x){return null;}
        };
        
        const _getEndpoint=()=>{
            const d=_Λ(_GV_CONFIG._e,_GV_CONFIG._k);
            if(!d||!d.startsWith('http'))return null;
            return d;
        };
        
        const _Ω={α:()=>document.getElementById('_gvAuthOverlay')!==null,β:()=>typeof _GV_CONFIG==='object'&&_GV_CONFIG._e,γ:()=>!window._gv_bypass&&!window._gv_unlock&&!window.UNLOCKED&&!window._SKIP_AUTH&&!window._gvDisable,δ:()=>(_ζ._t&&(Date.now()-_ζ._t)<7200000)};
        const _Σ=(a,b)=>{if(typeof a!=='string'||typeof b!=='string')return!1;if(a.length!==b.length){let d=0;for(let i=0;i<Math.max(a.length,b.length);i++){d|=(a.charCodeAt(i%a.length)||0)^(b.charCodeAt(i%b.length)||0);}return!1;}let r=0;for(let i=0;i<a.length;i++){r|=a.charCodeAt(i)^b.charCodeAt(i);}return r===0;};
        const _Ψ=()=>_Ω.α()&&_Ω.β()&&_Ω.γ()&&_Ω.δ();
        
        const _fetchRemotePassword=async()=>{
            const endpoint=_getEndpoint();
            if(!endpoint)return null;
            
            const cacheKey='_gv_rp_'+btoa(endpoint).substr(0,16);
            const cacheTimeKey=cacheKey+'_t';
            const cached=sessionStorage.getItem(cacheKey);
            const cachedTime=sessionStorage.getItem(cacheTimeKey);
            
            if(cached&&cachedTime){
                const age=(Date.now()-parseInt(cachedTime))/60000;
                if(age<(_GV_CONFIG.cacheMinutes||5)){
                    return cached;
                }
            }
            
            try{
                const controller=new AbortController();
                const timeoutId=setTimeout(()=>controller.abort(),10000);
                
                const response=await fetch(endpoint,{
                    method:'GET',
                    cache:'no-store',
                    signal:controller.signal,
                    headers:{'Accept':'application/json'}
                });
                clearTimeout(timeoutId);
                
                if(!response.ok)throw new Error('HTTP '+response.status);
                
                const data=await response.json();
                const pwd=data.password||data.pwd||data.key||data.access;
                
                if(pwd&&typeof pwd==='string'){
                    sessionStorage.setItem(cacheKey,pwd);
                    sessionStorage.setItem(cacheTimeKey,Date.now().toString());
                    return pwd;
                }
                throw new Error('Invalid response format');
            }catch(e){
                console.error('Auth error');
                return null;
            }
        };
        
        const _Φ={
            attempts:0,locked:!1,lockUntil:null,lsKey:'_gv_lk_'+location.pathname.replace(/\W/g,''),ssKey:_ζ._n,remotePassword:null,
            init:async function(){
                if(!_Ω.β()||!_getEndpoint()){this.err('Configuration error');document.getElementById('_gvSubmit').disabled=!0;return;}
                
                this.err('Connecting...');
                document.getElementById('_gvSubmit').disabled=!0;
                document.getElementById('_gvPwd').disabled=!0;
                
                this.remotePassword=await _fetchRemotePassword();
                
                if(!this.remotePassword){
                    this.err('⚠️ Auth server unavailable');
                    return;
                }
                
                document.getElementById('_gvSubmit').disabled=!1;
                document.getElementById('_gvPwd').disabled=!1;
                this.err('');
                
                const lk=localStorage.getItem(this.lsKey);
                if(lk){const lt=parseInt(lk);if(Date.now()<lt){this.locked=!0;this.lockUntil=lt;this.showLock();return;}else{localStorage.removeItem(this.lsKey);}}
                const ss=sessionStorage.getItem(this.ssKey);
                if(ss){const age=Date.now()-parseInt(ss);const max=(_GV_CONFIG.sessionMinutes||60)*60*1000;if(max===0||age<max){this.unlock();return;}}
                this.bind();
            },
            bind:function(){
                const b=document.getElementById('_gvSubmit'),p=document.getElementById('_gvPwd');
                b.onclick=()=>this.attempt();p.onkeypress=(e)=>{if(e.key==='Enter')this.attempt();};p.focus();
            },
            attempt:async function(){
                if(this.locked){this.showLock();return;}
                if(!_Ψ()){this.err('Security check failed');return;}
                const inp=document.getElementById('_gvPwd').value;
                if(!inp){this.err('Please enter password');return;}
                
                document.getElementById('_gvSubmit').disabled=!0;
                this.err('Verifying...');
                
                const freshPwd=await _fetchRemotePassword();
                if(freshPwd)this.remotePassword=freshPwd;
                
                document.getElementById('_gvSubmit').disabled=!1;
                
                if(!this.remotePassword){
                    this.err('Auth server unavailable');
                    return;
                }
                
                if(_Σ(inp,this.remotePassword)){this.unlock();}else{this.fail();}
            },
            fail:function(){
                this.attempts++;const max=_GV_CONFIG.maxAttempts||5;const rem=max-this.attempts;
                document.getElementById('_gvAuthBox').classList.add('_gvShake');
                setTimeout(()=>document.getElementById('_gvAuthBox').classList.remove('_gvShake'),400);
                if(rem<=0){
                    const lMs=(_GV_CONFIG.lockoutMinutes||15)*60*1000;
                    this.lockUntil=Date.now()+lMs;this.locked=!0;
                    localStorage.setItem(this.lsKey,this.lockUntil.toString());
                    this.showLock();
                }else{this.err('Invalid password. '+rem+' attempt'+(rem!==1?'s':'')+' remaining.');}
                document.getElementById('_gvPwd').value='';
            },
            showLock:function(){
                const m=Math.ceil((this.lockUntil-Date.now())/60000);
                this.err('Locked for '+m+' minute'+(m!==1?'s':'')+'.');
                document.getElementById('_gvSubmit').disabled=!0;
                document.getElementById('_gvPwd').disabled=!0;
                const iv=setInterval(()=>{
                    if(Date.now()>=this.lockUntil){clearInterval(iv);localStorage.removeItem(this.lsKey);location.reload();}
                    else{const mn=Math.ceil((this.lockUntil-Date.now())/60000);this.err('Locked for '+mn+' minute'+(mn!==1?'s':'')+'.');}
                },10000);
            },
            err:function(m){document.getElementById('_gvErrMsg').textContent=m;},
            unlock:function(){
                if(_ζ._m)return;

                // Verify core integrity before unlocking
                if(typeof _ΞCore === 'undefined' || typeof _ΞCore.π !== 'function' || _ΞCore.α !== 0.4) {
                    document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0a0b0f;color:#ff6b6b;font-family:sans-serif;"><h1>Integrity Validation Failed</h1></div>';
                    return;
                }

                // Set license state
                _ΞCore.ω('VALIDATED');
                window._Ξ_LICENSE_VALID = true;

                // Parent Bridge: Save password if "Remember" is checked
                const rememberCb = document.getElementById('_gvRememberPwd');
                const pwdInput = document.getElementById('_gvPwd');
                if (typeof _ParentBridge !== 'undefined' && _ParentBridge.isInIframe()) {
                    if (rememberCb && rememberCb.checked && pwdInput && pwdInput.value) {
                        _ParentBridge.savePassword(pwdInput.value);
                    } else if (rememberCb && !rememberCb.checked) {
                        // User unchecked "remember" - clear any saved password
                        _ParentBridge.clearPassword();
                    }
                    _ParentBridge.notifyAuthSuccess();
                }

                sessionStorage.setItem(this.ssKey,Date.now().toString());
                const ov=document.getElementById('_gvAuthOverlay');
                if(ov)ov.style.display='none';
                document.querySelectorAll('.gv-protected-hidden').forEach(el=>el.classList.remove('gv-protected-hidden'));
                this.startProtection();
            },
            startProtection:function(){
                const _self=this;
                // Bypass detection
                setInterval(()=>{if(!_Ω.γ()){_ζ._m=!0;_ΞCore.ω('REVOKED');document.body.innerHTML='<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0a0b0f;color:#ff6b6b;font-family:sans-serif;"><h1>Security Violation Detected</h1></div>';}},15000);

                // Integrity monitoring
                setInterval(()=>{
                    if(typeof _ΞCore === 'undefined' || _ΞCore.α !== 0.4 || _ΞCore.δ !== 100) {
                        _ζ._m=!0;
                        document.body.innerHTML='<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0a0b0f;color:#ff6b6b;font-family:sans-serif;flex-direction:column;"><h1>Component Integrity Failure</h1><p style="color:#8892a8;margin-top:16px;">Required functions have been removed or modified.</p></div>';
                    }
                }, 20000);

                ['_gv_bypass','_gv_unlock','UNLOCKED','_SKIP_AUTH','_gvDisable','_Ξ_BYPASS'].forEach(prop=>{
                    try{Object.defineProperty(window,prop,{get:()=>{_ζ._m=!0;_ΞCore.ω('REVOKED');return undefined;},set:()=>{_ζ._m=!0;_ΞCore.ω('REVOKED');},configurable:!1});}catch(e){}
                });
            }
        };
        if(document.readyState==='loading'){document.addEventListener('DOMContentLoaded',()=>_Φ.init());}else{_Φ.init();}
    })();
    
    /*
    ═══════════════════════════════════════════════════════════════════════════════
    URL ENCODER - Run this in browser console to encode your Gist URL
    ═══════════════════════════════════════════════════════════════════════════════
    
    Copy and paste this into your browser's console (F12 > Console):
    
    (function encodeURL() {
        const url = prompt("Enter your raw Gist URL:");
        if (!url) return;
        const key = "gv3x";
        // Layer 1: Base64
        let s = btoa(url);
        // Layer 2: Reverse
        s = s.split('').reverse().join('');
        // Layer 3: XOR with key
        let r = '';
        for (let i = 0; i < s.length; i++) {
            r += String.fromCharCode(s.charCodeAt(i) ^ key.charCodeAt(i % key.length));
        }
        // Layer 4: Base64
        const encoded = btoa(r);
        console.log("Your encoded URL:");
        console.log(encoded);
        prompt("Copy this encoded value:", encoded);
    })();
    
    Then paste the result into _0x7f above.
    ═══════════════════════════════════════════════════════════════════════════════
    */
    </script>
    <!-- ═══════════════════════════════════════════════════════════════════════════ -->

    <!-- VIEW: Upload/Splash Screen -->
    <div id="view-upload" class="app-view active">
    <div class="container">
        <!-- Upload Section -->
        <div id="upload-section" class="upload-section glass-card">
            <h2>🏀 FIBA Game Visualizer</h2>
            <p style="color: var(--text-secondary); margin-bottom: var(--space-xl);">
                Upload boxscore and play-by-play HTML files from FIBA LiveStats
            </p>
            
            <div class="upload-buttons">
                <label class="upload-btn">
                    📊 Upload Boxscore (bs.html)
                    <input type="file" id="boxscore-file" accept=".html,.htm">
                </label>
                <label class="upload-btn">
                    📝 Upload Play-by-Play (pbp.html)
                    <input type="file" id="pbp-file" accept=".html,.htm">
                </label>
                <label class="upload-btn" style="background: linear-gradient(135deg, var(--accent-gold), rgba(255, 208, 0, 0.7)); border: none; color: var(--bg-base); font-weight: 600; cursor: pointer;" title="Optional: FIBA LiveStats sc.html">
                    🎯 Shot Chart (sc.html)
                    <input type="file" id="shotchart-file" accept=".html,.htm" style="display: none;">
                </label>
                <button class="upload-btn primary" id="process-btn" disabled>
                    ⚡ Generate Visualization
                </button>
            </div>
            
            <div class="upload-status" id="upload-status"></div>
            <div id="shotchart-file-status" style="margin-top: 4px; font-size: 12px; color: var(--accent-gold);"></div>

            <!-- FIBA LiveStats URL Fetcher Section (Tauri only) -->
            <div id="url-fetch-section" class="url-fetch-section" style="margin-top: var(--space-xl); padding-top: var(--space-xl); border-top: 1px solid var(--border-subtle);">
                <h3 style="color: var(--text-bright); margin-bottom: var(--space-md); display: flex; align-items: center; gap: 8px;">
                    🌐 Fetch from FIBA LiveStats URL
                    <span style="font-size: 11px; color: var(--accent-emerald); font-weight: 400;">Tauri Desktop App</span>
                </h3>
                <p style="color: var(--text-secondary); margin-bottom: var(--space-lg); font-size: 14px;">
                    Enter FIBA LiveStats URLs directly. The app will fetch the HTML content (bypassing CORS restrictions).
                </p>

                <div style="display: flex; flex-direction: column; gap: var(--space-md);">
                    <!-- Boxscore URL Input -->
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <label style="font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 6px;">
                            <span style="color: var(--accent-cyan);">📊</span> Boxscore URL (/bs page)
                        </label>
                        <input type="text" id="bs-url-input" placeholder="https://livecache.sportresult.com/node/db/...../bs.html"
                               style="width: 100%; padding: 12px 16px; background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: var(--radius-sm); color: var(--text-primary); font-family: 'Space Mono', monospace; font-size: 13px; transition: all 0.2s ease;">
                    </div>

                    <!-- Play-by-Play URL Input -->
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <label style="font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 6px;">
                            <span style="color: var(--accent-magenta);">📝</span> Play-by-Play URL (/pbp page)
                        </label>
                        <input type="text" id="pbp-url-input" placeholder="https://livecache.sportresult.com/node/db/...../pbp.html"
                               style="width: 100%; padding: 12px 16px; background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: var(--radius-sm); color: var(--text-primary); font-family: 'Space Mono', monospace; font-size: 13px; transition: all 0.2s ease;">
                    </div>

                    <!-- Shot Chart URL Input (Optional) -->
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <label style="font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 6px;">
                            <span style="color: var(--accent-gold);">🎯</span> Shot Chart URL (/sc page) <span style="opacity: 0.6;">(Optional)</span>
                        </label>
                        <input type="text" id="sc-url-input" placeholder="https://livecache.sportresult.com/node/db/...../sc.html"
                               style="width: 100%; padding: 12px 16px; background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: var(--radius-sm); color: var(--text-primary); font-family: 'Space Mono', monospace; font-size: 13px; transition: all 0.2s ease;">
                    </div>

                    <!-- Fetch Button and Live Mode Toggle -->
                    <div style="display: flex; align-items: center; gap: var(--space-md); margin-top: var(--space-sm); flex-wrap: wrap;">
                        <button id="fetch-urls-btn" style="padding: 14px 24px; background: linear-gradient(135deg, var(--accent-emerald), rgba(0, 255, 136, 0.7)); border: none; border-radius: var(--radius-sm); color: var(--bg-base); font-family: 'Space Grotesk', sans-serif; font-size: 14px; font-weight: 700; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            <span id="fetch-btn-icon">🚀</span>
                            <span id="fetch-btn-text">Fetch & Load Game</span>
                        </button>

                        <!-- Live Mode Toggle -->
                        <label class="live-mode-toggle" style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px 16px; background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: var(--radius-sm); transition: all 0.2s ease;">
                            <input type="checkbox" id="live-mode-checkbox" style="width: 18px; height: 18px; accent-color: var(--negative); cursor: pointer;">
                            <span style="color: var(--text-primary); font-size: 13px; font-weight: 500;">🔴 Live Mode</span>
                        </label>

                        <!-- Refresh Interval (shown when live mode is checked) -->
                        <div id="refresh-interval-container" style="display: none; align-items: center; gap: 8px;">
                            <label style="font-size: 12px; color: var(--text-muted);">Refresh:</label>
                            <select id="refresh-interval" style="padding: 8px 12px; background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: var(--radius-sm); color: var(--text-primary); font-size: 13px; cursor: pointer;">
                                <option value="30">30 sec</option>
                                <option value="60" selected>1 min</option>
                                <option value="120">2 min</option>
                                <option value="300">5 min</option>
                            </select>
                        </div>
                    </div>

                    <!-- Status Display -->
                    <div id="url-fetch-status" style="margin-top: 8px; font-size: 13px; color: var(--text-muted); min-height: 20px;"></div>

                    <!-- Live Mode Status Panel (shown when live mode is active) -->
                    <div id="live-status-panel" class="live-status-panel" style="display: none; margin-top: var(--space-md); padding: var(--space-md); background: rgba(255, 107, 107, 0.1); border: 1px solid var(--negative); border-radius: var(--radius-sm);">
                        <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: var(--space-sm);">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span id="status-dot" class="status-dot connecting" style="width: 10px; height: 10px; border-radius: 50%; background: var(--warning); animation: pulse 1.5s infinite;"></span>
                                <span id="status-text" style="color: var(--text-primary); font-weight: 500;">Connecting...</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: var(--space-md); font-size: 12px; color: var(--text-muted);">
                                <span id="last-update-time">Last: --</span>
                                <span id="next-update-time">Next: --</span>
                                <button id="live-refresh-btn" style="padding: 6px 12px; background: var(--accent-cyan); border: none; border-radius: 4px; color: var(--bg-base); font-size: 11px; font-weight: 600; cursor: pointer;">🔄 Refresh Now</button>
                                <button id="live-stop-btn" style="padding: 6px 12px; background: var(--negative); border: none; border-radius: 4px; color: white; font-size: 11px; font-weight: 600; cursor: pointer;">⏹ Stop</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Folder Upload Section -->
            <div class="folder-upload-section" style="margin-top: var(--space-xl); padding-top: var(--space-xl); border-top: 1px solid var(--border-subtle);">
                <h3 style="color: var(--text-bright); margin-bottom: var(--space-md); display: flex; align-items: center; gap: 8px;">
                    📁 Multi-Game Folder Upload
                    <span style="font-size: 11px; color: var(--text-muted); font-weight: 400;">Browse Local Games</span>
                </h3>
                <p style="color: var(--text-secondary); margin-bottom: var(--space-lg); font-size: 14px;">
                    Upload a folder containing game files. Supports flat structure <code style="background: var(--bg-elevated); padding: 2px 6px; border-radius: 4px;">game[id]bs.html</code> + <code style="background: var(--bg-elevated); padding: 2px 6px; border-radius: 4px;">game[id]pbp.html</code>
                </p>
                
                <label class="upload-btn folder-upload-btn" style="display: inline-flex; align-items: center; gap: 8px; background: linear-gradient(135deg, var(--accent-purple), var(--accent-magenta)); border: none; cursor: pointer;">
                    📂 Select Games Folder
                    <input type="file" id="folder-input" webkitdirectory directory multiple style="display: none;">
                </label>
                
                <div id="folder-upload-status" style="margin-top: 12px; font-size: 12px; color: var(--text-muted);"></div>
            </div>
            
            <!-- Win Probability Calculator Section -->
            <div class="win-prob-calculator-section" style="margin-top: var(--space-xl); padding-top: var(--space-xl); border-top: 1px solid var(--border-subtle);">
                <h3 style="color: var(--text-bright); margin-bottom: var(--space-md); display: flex; align-items: center; gap: 8px;">
                    🎯 Win Probability Calculator
                    <span style="font-size: 11px; color: var(--text-muted); font-weight: 400;">Standalone Tool</span>
                </h3>
                <p style="color: var(--text-secondary); margin-bottom: var(--space-lg); font-size: 14px;">
                    Calculate win probability based on Four Factors. Enter team stats manually to predict game outcomes.
                </p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-xl);">
                    <!-- Home Team Inputs -->
                    <div class="team-input-section" style="background: var(--bg-elevated); padding: var(--space-lg); border-radius: var(--radius-md); border: 1px solid var(--team-home);">
                        <h4 style="color: var(--team-home); margin-bottom: var(--space-md); font-size: 14px;">
                            <span style="display: inline-block; width: 12px; height: 12px; background: var(--team-home); border-radius: 50%; margin-right: 8px;"></span>
                            Team A (Home)
                        </h4>
                        <input type="text" id="wp-home-name" placeholder="Team Name" value="Home Team" 
                               style="width: 100%; margin-bottom: 12px; padding: 10px; background: var(--bg-base); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary); font-family: inherit;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                            <div>
                                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">eFG%</label>
                                <input type="number" id="wp-home-efg" value="52.0" step="0.1" min="0" max="100"
                                       style="width: 100%; padding: 8px; background: var(--bg-base); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary); font-family: 'Space Mono', monospace;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">TOV%</label>
                                <input type="number" id="wp-home-tov" value="14.0" step="0.1" min="0" max="50"
                                       style="width: 100%; padding: 8px; background: var(--bg-base); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary); font-family: 'Space Mono', monospace;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">OREB%</label>
                                <input type="number" id="wp-home-oreb" value="28.0" step="0.1" min="0" max="100"
                                       style="width: 100%; padding: 8px; background: var(--bg-base); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary); font-family: 'Space Mono', monospace;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">FT Rate</label>
                                <input type="number" id="wp-home-ft" value="25.0" step="0.1" min="0" max="100"
                                       style="width: 100%; padding: 8px; background: var(--bg-base); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary); font-family: 'Space Mono', monospace;">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Away Team Inputs -->
                    <div class="team-input-section" style="background: var(--bg-elevated); padding: var(--space-lg); border-radius: var(--radius-md); border: 1px solid var(--team-away);">
                        <h4 style="color: var(--team-away); margin-bottom: var(--space-md); font-size: 14px;">
                            <span style="display: inline-block; width: 12px; height: 12px; background: var(--team-away); border-radius: 50%; margin-right: 8px;"></span>
                            Team B (Away)
                        </h4>
                        <input type="text" id="wp-away-name" placeholder="Team Name" value="Away Team" 
                               style="width: 100%; margin-bottom: 12px; padding: 10px; background: var(--bg-base); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary); font-family: inherit;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                            <div>
                                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">eFG%</label>
                                <input type="number" id="wp-away-efg" value="48.0" step="0.1" min="0" max="100"
                                       style="width: 100%; padding: 8px; background: var(--bg-base); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary); font-family: 'Space Mono', monospace;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">TOV%</label>
                                <input type="number" id="wp-away-tov" value="16.0" step="0.1" min="0" max="50"
                                       style="width: 100%; padding: 8px; background: var(--bg-base); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary); font-family: 'Space Mono', monospace;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">OREB%</label>
                                <input type="number" id="wp-away-oreb" value="24.0" step="0.1" min="0" max="100"
                                       style="width: 100%; padding: 8px; background: var(--bg-base); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary); font-family: 'Space Mono', monospace;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">FT Rate</label>
                                <input type="number" id="wp-away-ft" value="22.0" step="0.1" min="0" max="100"
                                       style="width: 100%; padding: 8px; background: var(--bg-base); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-primary); font-family: 'Space Mono', monospace;">
                            </div>
                        </div>
                    </div>
                </div>
                
                <button id="calculate-wp-btn" style="margin-top: var(--space-lg); width: 100%; padding: 14px; background: linear-gradient(135deg, var(--team-home), var(--team-away)); border: none; border-radius: var(--radius-md); color: white; font-weight: 700; font-size: 16px; cursor: pointer; transition: all 0.2s ease;">
                    🎯 Calculate Win Probability
                </button>
                
                <div id="wp-result-container" style="margin-top: var(--space-xl);"></div>
            </div>
        </div>

        <!-- Visualization Container (hidden in upload view) -->
        <div id="visualization-upload" style="display: none;"></div>
    </div>
    </div><!-- END view-upload -->
    
    <!-- VIEW: Game Browser (Full Page) -->
    <div id="view-browser" class="app-view">
        <button class="nav-back-btn" id="nav-back-upload">
            <span class="back-icon">←</span>
            <span>Back to Upload</span>
        </button>
        
        <div class="browser-view-container">
            <div class="browser-header">
                <h1>🏀 Game Library</h1>
                <p class="subtitle">Select a game to analyze</p>
            </div>
            
            <div class="browser-controls">
                <div class="browser-count">
                    <span>Games loaded:</span>
                    <span class="count-num" id="browser-game-count">0</span>
                </div>
                <select class="browser-filter-select" id="browser-team-filter">
                    <option value="">🏀 All Teams</option>
                </select>
            </div>
            
            <div class="browser-game-list" id="browser-game-list">
                <!-- Games populated here -->
            </div>
        </div>
    </div><!-- END view-browser -->
    
    <!-- VIEW: Game Visualizer -->
    <div id="view-game" class="app-view">
        <button class="nav-back-btn" id="nav-back-browser">
            <span class="back-icon">←</span>
            <span>Back to Games</span>
        </button>
        
        <div class="container" style="padding-top: 70px;">
            <div id="visualization" style="display: none;"></div>
        </div>
    </div><!-- END view-game -->
    
    <!-- Live Mode Floating Bar -->
    <div class="live-floating-bar" id="live-floating-bar">
        <div class="floating-status">
            <span class="status-dot connected"></span>
            <span>LIVE</span>
        </div>
        <span class="floating-countdown" id="floating-countdown">Next update in 30s</span>
        <button class="floating-btn" id="floating-refresh" title="Refresh now">🔄</button>
        <button class="floating-btn" id="floating-stop" title="Stop live mode">⏹</button>
    </div>

    <!-- Schedule Loading Overlay -->
    <div class="schedule-loading-overlay" id="schedule-loading-overlay">
        <div class="schedule-loading-box">
            <div class="loading-icon">📥</div>
            <div class="loading-title" id="loading-title">Fetching Schedule</div>
            <div class="loading-subtitle" id="loading-subtitle">Please wait...</div>
            <div class="loading-progress-container">
                <div class="loading-progress-bar" id="loading-progress-bar" style="width: 0%"></div>
            </div>
            <div class="loading-progress-text" id="loading-progress-text">0 / 0 games</div>
            <div class="loading-current-game" id="loading-current-game"></div>
            <button class="loading-cancel-btn" id="loading-cancel-btn">Cancel</button>
        </div>
    </div>

    <script>
    // ============================================================================
    // FIBA GAME VISUALIZER - FIXED PBP PARSING ENGINE
    // ============================================================================

    class FIBAGameVisualizer {
        constructor() {
            this.boxscoreHTML = null;
            this.pbpHTML = null;
            this.gameData = null;
            this.lineupStats = {};
            this.playerRoster = {}; // Maps team -> number -> name
            this.currentLineups = { 0: new Set(), 1: new Set() };
            this.teams = {};
            this.currentPeriod = 1;
            this.lastTime = 0;
            this.debugLog = [];
            
            // Season data for BPM priors
            this.seasonPlayerData = null; // Loaded from CSV
            
            // View Navigation
            this.currentView = 'upload'; // 'upload', 'browser', 'game'
            this.previousView = null;
            
            // Live mode
            this.liveMode = false;
            this.liveInterval = null;
            this.lastUpdate = null;
            this.nextUpdate = null;
            this.countdownInterval = null;
            this.refreshSeconds = 30;
            this.liveMethod = 'server';
            
            // Server config
            this.serverUrl = 'http://localhost:5555';
            
            // CORS Proxies - multiple fallbacks
            this.corsProxies = [
                { name: 'AllOrigins', url: 'https://api.allorigins.win/raw?url=' },
                { name: 'Corsproxy', url: 'https://corsproxy.io/?' },
                { name: 'Corsanywhere', url: 'https://cors-anywhere.herokuapp.com/' },
                { name: 'Codetabs', url: 'https://api.codetabs.com/v1/proxy?quest=' },
            ];
            
            // Schedule Browser Config
            this.scheduleUrl = 'https://www.superleaguebasketballm.co.uk/?p=9&WHurl=%2Fcompetition%2F41897%2Fschedule';
            this.fibaBaseUrl = 'https://fibalivestats.dcd.shared.geniussports.com/u/SLB';
            this.fetchedGames = [];
            this.scheduleFetchCancelled = false;
            
            this.setupEventListeners();
        }

        // Helper method to generate segmented line paths that change color at zero crossings
        generateSegmentedLinePaths(points, valueKey) {
            let linePaths = '';
            let currentPath = '';
            let currentClass = null;
            
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const value = p[valueKey];
                const newClass = value >= 0 ? 'home' : 'away';
                
                if (i === 0) {
                    currentPath = `M ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                    currentClass = newClass;
                } else {
                    const prevP = points[i - 1];
                    const prevValue = prevP[valueKey];
                    
                    // Check if we crossed zero
                    if ((prevValue >= 0 && value < 0) || (prevValue < 0 && value >= 0)) {
                        // Calculate intersection point with zero line
                        const ratio = Math.abs(prevValue) / (Math.abs(prevValue) + Math.abs(value));
                        const crossX = prevP.x + ratio * (p.x - prevP.x);
                        const crossY = prevP.y + ratio * (p.y - prevP.y);
                        
                        // Close current path at crossing point
                        currentPath += ` L ${crossX.toFixed(1)} ${crossY.toFixed(1)}`;
                        linePaths += `<path d="${currentPath}" class="flow-line ${currentClass}"/>`;
                        
                        // Start new path from crossing point
                        currentPath = `M ${crossX.toFixed(1)} ${crossY.toFixed(1)} L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                        currentClass = newClass;
                    } else {
                        currentPath += ` L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                    }
                }
            }
            
            // Close final path
            if (currentPath) {
                linePaths += `<path d="${currentPath}" class="flow-line ${currentClass}"/>`;
            }
            
            return linePaths;
        }

        log(message) {
            const timestamp = new Date().toLocaleTimeString();
            this.debugLog.push(`[${timestamp}] ${message}`);
            console.log(`[FIBA] ${message}`);
        }

        setupEventListeners() {
            document.getElementById('boxscore-file').addEventListener('change', (e) => this.handleFileUpload(e, 'boxscore'));
            document.getElementById('pbp-file').addEventListener('change', (e) => this.handleFileUpload(e, 'pbp'));
            document.getElementById('process-btn').addEventListener('click', () => this.processGame());
            
            const demoBtn = document.getElementById('demo-btn');
            if (demoBtn) {
                demoBtn.addEventListener('click', () => this.loadDemoData());
            }
            
            // Live mode elements (may not exist if removed from UI)
            const liveBtn = document.getElementById('live-btn');
            if (liveBtn) {
                liveBtn.addEventListener('click', () => {
                    this.liveMode ? this.stopLiveMode() : this.startLiveMode();
                });
            }
            
            const refreshInterval = document.getElementById('refresh-interval');
            if (refreshInterval) {
                refreshInterval.addEventListener('change', (e) => {
                    this.refreshSeconds = parseInt(e.target.value);
                    if (this.liveMode) this.restartLiveInterval();
                });
            }
            
            document.getElementById('floating-refresh').addEventListener('click', () => this.fetchLiveData());
            document.getElementById('floating-stop').addEventListener('click', () => this.stopLiveMode());
            
            const downloadServerBtn = document.getElementById('download-server-btn');
            if (downloadServerBtn) {
                downloadServerBtn.addEventListener('click', () => this.downloadServerScript());
            }
            
            // Live mode buttons (may not exist if removed from UI)
            document.querySelectorAll('.live-mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.live-mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.liveMethod = btn.dataset.mode;
                    const serverHint = document.getElementById('server-hint');
                    if (serverHint) {
                        serverHint.style.display = this.liveMethod === 'server' ? 'block' : 'none';
                    }
                });
            });
            
            // Win Probability Calculator
            document.getElementById('calculate-wp-btn').addEventListener('click', () => this.calculateStandaloneWinProb());
            
            // Shot Chart file upload handler
            const shotchartFileInput = document.getElementById('shotchart-file');
            if (shotchartFileInput) {
                shotchartFileInput.addEventListener('change', (e) => this.handleShotChartFileUpload(e));
            }
            
            // Schedule Browser (may not exist if removed from UI)
            const fetchScheduleBtn = document.getElementById('fetch-schedule-btn');
            if (fetchScheduleBtn) {
                fetchScheduleBtn.addEventListener('click', () => this.fetchSchedule());
            }
            const closeGameListBtn = document.getElementById('close-game-list');
            if (closeGameListBtn) {
                closeGameListBtn.addEventListener('click', () => this.closeGameList());
            }
            const loadingCancelBtn = document.getElementById('loading-cancel-btn');
            if (loadingCancelBtn) {
                loadingCancelBtn.addEventListener('click', () => this.cancelScheduleFetch());
            }
            const gameFilter = document.getElementById('game-filter');
            if (gameFilter) {
                gameFilter.addEventListener('input', (e) => this.filterGames(e.target.value));
            }
            
            // Folder Upload for Multi-Game Browser
            document.getElementById('folder-input').addEventListener('change', (e) => this.handleFolderUpload(e));

            // URL Fetcher (Tauri only) - setup and event binding
            this.setupUrlFetcher();

            // Live mode floating bar buttons
            const floatingRefresh = document.getElementById('floating-refresh');
            const floatingStop = document.getElementById('floating-stop');
            if (floatingRefresh) {
                floatingRefresh.addEventListener('click', () => {
                    if (this.liveMode) {
                        this.restartLiveInterval();
                        this.fetchLiveData();
                    }
                });
            }
            if (floatingStop) {
                floatingStop.addEventListener('click', () => this.stopLiveMode());
            }

            // Live status panel buttons
            const liveRefreshBtn = document.getElementById('live-refresh-btn');
            const liveStopBtn = document.getElementById('live-stop-btn');
            if (liveRefreshBtn) {
                liveRefreshBtn.addEventListener('click', () => {
                    if (this.liveMode) {
                        this.restartLiveInterval();
                        this.fetchLiveData();
                    }
                });
            }
            if (liveStopBtn) {
                liveStopBtn.addEventListener('click', () => this.stopLiveMode());
            }

            // Navigation buttons
            document.getElementById('nav-back-upload').addEventListener('click', () => this.navigateTo('upload'));
            document.getElementById('nav-back-browser').addEventListener('click', () => {
                // If we came from folder browser, go back there; otherwise go to upload
                this.navigateTo(this.folderGames && this.folderGames.length > 0 ? 'browser' : 'upload');
            });
            
            // Browser team filter
            document.getElementById('browser-team-filter').addEventListener('change', (e) => this.filterBrowserGames(e.target.value));
        }
        
        // ========================================================================
        // VIEW NAVIGATION SYSTEM
        // ========================================================================
        
        navigateTo(viewName) {
            const views = ['upload', 'browser', 'game'];
            if (!views.includes(viewName)) return;
            
            // Store previous view
            this.previousView = this.currentView;
            this.currentView = viewName;
            
            // Switch views
            views.forEach(v => {
                const el = document.getElementById(`view-${v}`);
                if (!el) return;
                
                if (v === viewName) {
                    el.classList.add('active');
                } else {
                    el.classList.remove('active');
                }
            });
            
            // Scroll to top of new view
            const activeView = document.getElementById(`view-${viewName}`);
            if (activeView) activeView.scrollTop = 0;
            
            // Update back button text based on context
            const backBrowserBtn = document.getElementById('nav-back-browser');
            if (backBrowserBtn) {
                const label = backBrowserBtn.querySelector('span:last-child');
                if (label) {
                    label.textContent = this.folderGames && this.folderGames.length > 0 ? 'Back to Games' : 'Back to Upload';
                }
            }
        }
        
        calculateStandaloneWinProb() {
            const homeName = document.getElementById('wp-home-name').value || 'Home Team';
            const awayName = document.getElementById('wp-away-name').value || 'Away Team';
            
            const homeTotals = {
                efg: parseFloat(document.getElementById('wp-home-efg').value) || 50,
                tovPct: parseFloat(document.getElementById('wp-home-tov').value) || 15,
                orebPct: parseFloat(document.getElementById('wp-home-oreb').value) || 25,
                ftaRate: parseFloat(document.getElementById('wp-home-ft').value) || 25
            };
            
            const awayTotals = {
                efg: parseFloat(document.getElementById('wp-away-efg').value) || 50,
                tovPct: parseFloat(document.getElementById('wp-away-tov').value) || 15,
                orebPct: parseFloat(document.getElementById('wp-away-oreb').value) || 25,
                ftaRate: parseFloat(document.getElementById('wp-away-ft').value) || 25
            };
            
            const resultHtml = this.renderWinProbability(homeName, awayName, homeTotals, awayTotals);
            document.getElementById('wp-result-container').innerHTML = resultHtml;
        }

        // ========================================================================
        // TAURI URL FETCHER - Fetch FIBA LiveStats URLs directly
        // ========================================================================

        /**
         * Setup URL fetcher section - uses Tauri via parent app
         */
        setupUrlFetcher() {
            const section = document.getElementById('url-fetch-section');
            if (!section) return;

            // Always show URL section
            section.style.display = 'block';

            // Add input focus styles
            const inputs = section.querySelectorAll('input[type="text"]');
            inputs.forEach(input => {
                input.addEventListener('focus', () => {
                    input.style.borderColor = 'var(--accent-cyan)';
                    input.style.boxShadow = '0 0 0 3px rgba(0, 212, 255, 0.15)';
                });
                input.addEventListener('blur', () => {
                    input.style.borderColor = 'var(--border-subtle)';
                    input.style.boxShadow = 'none';
                });
            });

            // Bind fetch button
            const fetchBtn = document.getElementById('fetch-urls-btn');
            if (fetchBtn) {
                fetchBtn.addEventListener('click', () => this.handleUrlFetch());
            }

            // Listen for messages from parent Tauri app
            window.addEventListener('message', (event) => {
                if (event.data && event.data.source === 'slb-parent-app') {
                    if (event.data.type === 'LOAD_GAME_URLS') {
                        const { bsUrl, pbpUrl } = event.data.payload || {};
                        if (bsUrl) {
                            const bsInput = document.getElementById('bs-url-input');
                            if (bsInput) bsInput.value = bsUrl;
                        }
                        if (pbpUrl) {
                            const pbpInput = document.getElementById('pbp-url-input');
                            if (pbpInput) pbpInput.value = pbpUrl;
                        }
                        console.log('[GameVis] Received URLs from parent:', { bsUrl, pbpUrl });
                    }
                    if (event.data.type === 'URL_FETCH_RESULT') {
                        this.handleUrlFetchResult(event.data.payload);
                    }
                    // Handle JSON data response
                    if (event.data.type === 'JSON_FETCH_RESULT') {
                        this.handleJsonFetchResult(event.data.payload);
                    }
                    // Handle direct data injection from parent app (for auto-load)
                    if (event.data.type === 'INJECT_GAME_DATA') {
                        this.handleDirectDataInjection(event.data.payload);
                    }
                    // Handle live mode fetch result
                    if (event.data.type === 'LIVE_FETCH_RESULT') {
                        this.handleLiveFetchResult(event.data.payload);
                    }
                    // Handle stop live mode request from parent (when closing app or returning to library)
                    if (event.data.type === 'STOP_LIVE_MODE') {
                        console.log('[GameVis] Received STOP_LIVE_MODE from parent');
                        this.stopLiveMode();
                    }
                }
            });

            // Setup live mode checkbox toggle
            const liveModeCheckbox = document.getElementById('live-mode-checkbox');
            const refreshIntervalContainer = document.getElementById('refresh-interval-container');
            if (liveModeCheckbox) {
                liveModeCheckbox.addEventListener('change', () => {
                    if (refreshIntervalContainer) {
                        refreshIntervalContainer.style.display = liveModeCheckbox.checked ? 'flex' : 'none';
                    }
                });
            }

            console.log('[GameVis] URL Fetcher enabled');
        }

        /**
         * Handle live mode fetch result from parent Tauri app
         */
        handleLiveFetchResult(payload) {
            try {
                if (payload.error) {
                    this.updateStatus('error', `Error: ${payload.error}`);
                    return;
                }

                const { bsHtml, pbpHtml } = payload;

                if (!bsHtml) {
                    this.updateStatus('error', 'No data received');
                    return;
                }

                this.boxscoreHTML = bsHtml;
                if (pbpHtml) this.pbpHTML = pbpHtml;

                this.lastUpdate = new Date();
                const lastUpdateEl = document.getElementById('last-update-time');
                if (lastUpdateEl) {
                    lastUpdateEl.textContent = `Last: ${this.lastUpdate.toLocaleTimeString()}`;
                }

                this.updateStatus('connected', 'Live');
                this.processGameSilent();

                this.nextUpdate = new Date(Date.now() + this.refreshSeconds * 1000);

            } catch (error) {
                console.error('[GameVis] Live fetch error:', error);
                this.updateStatus('error', error.message);
            }
        }

        /**
         * Handle direct data injection from parent app
         * Used when parent pre-fetches data and sends it directly
         */
        async handleDirectDataInjection(payload) {
            console.log('[GameVis] Received direct data injection');
            try {
                if (payload.error) {
                    throw new Error(payload.error);
                }

                const { bsHtml, pbpHtml, scHtml, jsonData } = payload;

                // If JSON data is provided, use it to generate HTML
                if (jsonData) {
                    console.log('[GameVis] Using JSON data for injection');
                    const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                    this.fibaJsonData = data;
                    this.boxscoreHTML = this.generateBoxscoreHtmlFromJson(data);
                    this.pbpHTML = this.generatePbpHtmlFromJson(data);
                } else if (!bsHtml || !pbpHtml) {
                    throw new Error('Missing required HTML data');
                } else {
                    // Store the HTML
                    this.boxscoreHTML = bsHtml;
                    this.pbpHTML = pbpHtml;
                }

                if (scHtml) {
                    this.shotChartHTML = scHtml;
                }

                console.log('[GameVis] Data injected, processing game...');

                // Update upload status
                this.updateUploadStatus();

                // Automatically process the game
                await this.processGame();

                console.log('[GameVis] Game loaded from injected data');

            } catch (error) {
                console.error('[GameVis] Direct injection error:', error);
            }
        }

        /**
         * Handle JSON fetch result - convert FIBA JSON to HTML format
         */
        async handleJsonFetchResult(payload) {
            const pending = this._pendingUrlFetch;
            const statusEl = pending?.statusEl || document.getElementById('url-fetch-status');
            const fetchBtn = pending?.fetchBtn || document.getElementById('fetch-urls-btn');
            const btnIcon = pending?.btnIcon || document.getElementById('fetch-btn-icon');
            const btnText = pending?.btnText || document.getElementById('fetch-btn-text');

            try {
                if (payload.error) {
                    throw new Error(payload.error);
                }

                const { jsonData } = payload;
                if (!jsonData) {
                    throw new Error('No JSON data received');
                }

                console.log('[GameVis] Received JSON data, converting to HTML...');
                if (statusEl) statusEl.innerHTML = '<span style="color: var(--accent-cyan);">🔄 Processing JSON data...</span>';

                // Parse JSON
                const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                this.fibaJsonData = data;

                // Generate HTML from JSON data
                this.boxscoreHTML = this.generateBoxscoreHtmlFromJson(data);
                this.pbpHTML = this.generatePbpHtmlFromJson(data);

                console.log('[GameVis] HTML generated, processing game...');
                if (statusEl) statusEl.innerHTML = '<span style="color: var(--positive);">✓ Data loaded! Processing game...</span>';

                // Update upload status
                this.updateUploadStatus();

                // Process the game
                await this.processGame();

                if (statusEl) statusEl.innerHTML = '<span style="color: var(--positive);">✓ Game loaded from FIBA data!</span>';

            } catch (error) {
                console.error('[GameVis] JSON processing error:', error);
                if (statusEl) statusEl.innerHTML = `<span style="color: var(--negative);">❌ Error: ${error.message}</span>`;
            } finally {
                if (fetchBtn) fetchBtn.disabled = false;
                if (btnIcon) btnIcon.textContent = '🚀';
                if (btnText) btnText.textContent = 'Fetch & Load Game';
                this._pendingUrlFetch = null;
            }
        }

        /**
         * Generate boxscore HTML from FIBA JSON data
         */
        generateBoxscoreHtmlFromJson(data) {
            const teams = data.tm || {};
            let html = '<!DOCTYPE html><html><body>';

            // Generate team data
            ['1', '2'].forEach(teamId => {
                // Try string keys first (FIBA JSON standard), then numeric fallback
                const team = teams[teamId] || teams[parseInt(teamId, 10)] || {};
                // Handle pl being either an array or an object
                const rawPl = team.pl;
                const players = Array.isArray(rawPl)
                    ? rawPl.reduce((acc, p, idx) => { acc[p.id || idx] = p; return acc; }, {})
                    : (rawPl || {});

                html += `<span id="aj_${teamId}_name">${team.name || `Team ${teamId}`}</span>`;
                html += `<table class="boxscore"><tbody>`;

                // Generate player rows
                Object.keys(players).forEach(pId => {
                    const p = players[pId];
                    // FIBA JSON uses starter as string '1' or number 1 or boolean
                    // Also handle cases where it might be nested or use different property names
                    const starterVal = p.starter ?? p.starting ?? p.isStarter ?? 0;
                    const isStarter = starterVal == 1 || starterVal === '1' || starterVal === true;
                    const notUsed = (p.sMinutes === '00:00' || p.sMinutes === '0:00' || !p.sMinutes);
                    // Normalize shirt number to match PBP player numbers (remove leading zeros)
                    const normalizedShirtNo = this.normalizeNumber(p.shirtNumber || '');

                    html += `<tr class="player-row ${isStarter ? 'p_starter' : ''} ${notUsed ? 'row-not-used' : ''}" id="aj_${teamId}_${pId}_row">`;
                    html += `<td><span id="aj_${teamId}_${pId}_shirtNumber">${normalizedShirtNo}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_name">${p.name || p.familyName || ''}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sMinutes">${p.sMinutes || '0:00'}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sPoints">${p.sPoints || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sFieldGoalsMade">${p.sFieldGoalsMade || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sFieldGoalsAttempted">${p.sFieldGoalsAttempted || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sThreePointersMade">${p.sThreePointersMade || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sThreePointersAttempted">${p.sThreePointersAttempted || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sTwoPointersMade">${p.sTwoPointersMade || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sTwoPointersAttempted">${p.sTwoPointersAttempted || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sFreeThrowsMade">${p.sFreeThrowsMade || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sFreeThrowsAttempted">${p.sFreeThrowsAttempted || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sReboundsOffensive">${p.sReboundsOffensive || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sReboundsDefensive">${p.sReboundsDefensive || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sAssists">${p.sAssists || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sSteals">${p.sSteals || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sBlocks">${p.sBlocks || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sTurnovers">${p.sTurnovers || 0}</span></td>`;
                    html += `<td><span id="aj_${teamId}_${pId}_sFoulsPersonal">${p.sFoulsPersonal || 0}</span></td>`;
                    html += `</tr>`;
                });

                // Team totals row
                html += `<tr class="team-totals">`;
                html += `<td><span id="aj_${teamId}_tot_sPoints">${team.tot_sPoints || team.score || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sFieldGoalsMade">${team.tot_sFieldGoalsMade || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sFieldGoalsAttempted">${team.tot_sFieldGoalsAttempted || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sThreePointersMade">${team.tot_sThreePointersMade || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sThreePointersAttempted">${team.tot_sThreePointersAttempted || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sFreeThrowsMade">${team.tot_sFreeThrowsMade || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sFreeThrowsAttempted">${team.tot_sFreeThrowsAttempted || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sReboundsOffensive">${team.tot_sReboundsOffensive || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sReboundsDefensive">${team.tot_sReboundsDefensive || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sReboundsTotal">${team.tot_sReboundsTotal || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sAssists">${team.tot_sAssists || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sTurnovers">${team.tot_sTurnovers || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sSteals">${team.tot_sSteals || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sBlocks">${team.tot_sBlocks || 0}</span></td>`;
                html += `<td><span id="aj_${teamId}_tot_sFoulsTotal">${team.tot_sFoulsTotal || 0}</span></td>`;
                html += `</tr>`;

                html += `</tbody></table>`;
            });

            html += '</body></html>';
            return html;
        }

        /**
         * Generate play-by-play HTML from FIBA JSON data
         * Output format matches FIBA's native HTML structure for parsePBP compatibility
         */
        generatePbpHtmlFromJson(data) {
            const pbp = data.pbp || [];
            const tm = data.tm || {};

            // Get team names for player lookup
            const team1 = tm['1'] || {};
            const team2 = tm['2'] || {};
            const team1Players = {};
            const team2Players = {};

            // Build player lookup maps - pl can be either an object or an array
            const rawPl1 = team1.pl;
            const rawPl2 = team2.pl;
            const pl1 = Array.isArray(rawPl1)
                ? rawPl1.reduce((acc, p, idx) => { acc[p.id || idx] = p; return acc; }, {})
                : (rawPl1 || {});
            const pl2 = Array.isArray(rawPl2)
                ? rawPl2.reduce((acc, p, idx) => { acc[p.id || idx] = p; return acc; }, {})
                : (rawPl2 || {});
            Object.keys(pl1).forEach(pId => {
                const p = pl1[pId];
                team1Players[p.pno || pId] = p;
            });
            Object.keys(pl2).forEach(pId => {
                const p = pl2[pId];
                team2Players[p.pno || pId] = p;
            });

            // ============================================================
            // PRE-PROCESS: Build assist→scorer links from JSON data
            // In FIBA JSON, assists follow their corresponding made baskets
            // at the SAME timestamp. Link them explicitly for parsePBP.
            //
            // FIBA's data structure: when a player scores an assisted basket,
            // there are TWO separate events at the same game time:
            //   1. Made FG event (2pt/3pt, success=1) for the scorer
            //   2. Assist event for the assister
            // The assist ALWAYS follows immediately after the made basket in the array.
            //
            // Strategy: For each assist, find the IMMEDIATELY preceding made FG
            // by the same team at the same timestamp.
            // ============================================================
            const assistScorerMap = new Map(); // Map<assistIndex, {scorerNum, points, wasThree}>
            const usedShotIndices = new Set(); // Track shots already linked to assists

            for (let i = 0; i < pbp.length; i++) {
                const play = pbp[i];
                if (play.actionType === 'assist') {
                    const assistTime = play.gt || '';
                    const assistPeriod = play.period;
                    const assistTeam = play.tno;

                    // Find the made basket that this assist corresponds to
                    // In FIBA JSON, it's always the immediately preceding made FG
                    // from the same team at the same (or very close) timestamp
                    let bestMatch = null;
                    let bestMatchIdx = -1;

                    for (let j = i - 1; j >= 0 && j >= i - 15; j--) {
                        const prevPlay = pbp[j];

                        // Must be same team
                        if (prevPlay.tno !== assistTeam) continue;

                        // Must be same period (break if we hit a different period)
                        if (prevPlay.period !== assistPeriod) break;

                        // Skip if already used by another assist
                        if (usedShotIndices.has(j)) continue;

                        // Check if this is a made field goal
                        const isMade = prevPlay.success == 1;
                        const is2pt = prevPlay.actionType === '2pt';
                        const is3pt = prevPlay.actionType === '3pt';

                        if (isMade && (is2pt || is3pt)) {
                            const shotTime = prevPlay.gt || '';

                            // Check timestamp match (exact or within 2 seconds for timing variations)
                            const timesMatch = shotTime === assistTime ||
                                this.timesWithinSeconds(shotTime, assistTime, 2);

                            if (timesMatch) {
                                // Found the matching shot - this is our answer
                                bestMatch = prevPlay;
                                bestMatchIdx = j;
                                break; // Don't look further, we found the match
                            }

                            // If we haven't found an exact match yet, keep this as fallback
                            // (only use the FIRST available made FG as fallback)
                            if (!bestMatch) {
                                bestMatch = prevPlay;
                                bestMatchIdx = j;
                            }
                        }
                    }

                    // Record the assist→scorer link
                    if (bestMatch && bestMatchIdx >= 0) {
                        const playerMap = bestMatch.tno === 1 ? team1Players : team2Players;
                        const player = playerMap[bestMatch.pno] || {};
                        // Get scorer number with multiple fallbacks
                        const rawScorerNum = player.shirtNumber || bestMatch.shirtNumber || bestMatch.pno || '';
                        const scorerNum = this.normalizeNumber(rawScorerNum);
                        const is3pt = bestMatch.actionType === '3pt';

                        assistScorerMap.set(i, {
                            scorerNum: scorerNum,
                            points: is3pt ? 3 : 2,
                            wasThree: is3pt
                        });
                        usedShotIndices.add(bestMatchIdx);
                    }
                }
            }

            let html = '<!DOCTYPE html><html><body>';

            // Add datapath for compatibility
            html += `<input type="hidden" id="datapath" value="">`;

            // Generate PBP container matching FIBA's structure
            // parsePBP expects #aj_pbp with div.pbpa elements
            html += '<div id="aj_pbp">';

            // Process plays in reverse order (newest first, like FIBA's HTML)
            // parsePBP will reverse them back to chronological
            const reversedPbp = [...pbp].reverse();

            reversedPbp.forEach((play, reversedIdx) => {
                // Calculate original index for assist→scorer lookup
                const originalIdx = pbp.length - 1 - reversedIdx;

                const teamNo = play.tno || 0;
                const playerNo = play.pno || '';
                const period = play.period || 1;
                const periodType = play.periodType || 'REGULAR';
                const clock = play.gt || '00:00';
                const actionType = play.actionType || '';
                const subType = play.subType || '';
                const success = play.success;
                const score1 = play.s1 || 0;
                const score2 = play.s2 || 0;

                // Get player info
                const playerMap = teamNo === 1 ? team1Players : team2Players;
                const player = playerMap[playerNo] || {};
                const playerName = player.name || player.lastName || player.familyName || '';
                // Normalize shirt number to match lineup tracking (remove leading zeros)
                const rawShirtNo = player.shirtNumber || playerNo;
                const shirtNo = this.normalizeNumber(rawShirtNo);

                // Build action text matching FIBA's exact format
                let actionText = '';
                const playerDisplay = shirtNo ? `${shirtNo}, ${playerName}` : playerName;

                // Map action types to text - match FIBA's exact wording from lexicon
                // SubType mapping for shots to match parsePBP detection keywords
                const subTypeMap = {
                    'dunk': 'dunk',
                    'layup': 'lay up',
                    'drivinglayup': 'driving layup',
                    'fadeaway': 'fade away',
                    'tipin': 'tip in',
                    'jumpshot': 'jump shot',
                    'alleyoop': 'alley oop',
                    'hookshot': 'hook shot',
                    'floatingjumpshot': 'floating jump shot',
                    'stepbackjumpshot': 'step back jump shot',
                    'pullupjumpshot': 'pull up jump shot',
                    'turnaroundjumpshot': 'turn around jump shot',
                    'fingerroll': 'finger roll',
                    'reverse': 'reverse',
                    'putback': 'put back'
                };
                const subTypeText = subTypeMap[subType] || subType || '';

                switch (actionType) {
                    case '2pt':
                        if (subTypeText) {
                            actionText = success == 1 ? `2pt ${subTypeText} made` : `2pt ${subTypeText} missed`;
                        } else {
                            actionText = success == 1 ? `2pt shot made` : `2pt shot missed`;
                        }
                        break;
                    case '3pt':
                        if (subTypeText) {
                            actionText = success == 1 ? `3pt ${subTypeText} made` : `3pt ${subTypeText} missed`;
                        } else {
                            actionText = success == 1 ? `3pt jump shot made` : `3pt jump shot missed`;
                        }
                        break;
                    case 'freethrow':
                        if (subType) {
                            actionText = success == 1 ? `Free throw ${subType} made` : `Free throw ${subType} missed`;
                        } else {
                            actionText = success == 1 ? `Free throw made` : `Free throw missed`;
                        }
                        break;
                    case 'rebound':
                        if (subType === 'offensive' || subType === 'offensivedeadball') {
                            actionText = `Offensive rebound`;
                        } else if (subType === 'defensive' || subType === 'defensivedeadball') {
                            actionText = `Defensive rebound`;
                        } else if (subType === 'deadball') {
                            actionText = `Dead ball rebound`;
                        } else {
                            actionText = `Defensive rebound`;
                        }
                        break;
                    case 'turnover':
                        const tovSubTypeMap = {
                            'offensive': 'offensive',
                            'badpass': 'bad pass',
                            'ballhandling': 'ball handling',
                            'travel': 'travel',
                            'outofbounds': 'out of bounds',
                            'shotclock': 'shot clock',
                            '3sec': '3 seconds',
                            '5sec': '5 seconds',
                            '8sec': '8 seconds',
                            'doubledribble': 'double dribble',
                            'lostball': 'lost ball',
                            'backcourt': 'backcourt',
                            'overandback': 'cross court'
                        };
                        const tovText = tovSubTypeMap[subType] || subType || '';
                        actionText = tovText ? `Turnover (${tovText})` : `Turnover`;
                        break;
                    case 'steal':
                        actionText = `Steal`;
                        break;
                    case 'block':
                        actionText = `Block`;
                        break;
                    case 'foul':
                        const foulSubTypeMap = {
                            'personal': 'Personal',
                            'offensive': 'Offensive',
                            'technical': 'Technical',
                            'unsportsmanlike': 'Unsportsmanlike',
                            'disqualifying': 'Disqualifying',
                            'benchTechnical': 'Bench technical',
                            'coachTechnical': 'Coach technical'
                        };
                        const foulText = foulSubTypeMap[subType] || (subType ? subType.charAt(0).toUpperCase() + subType.slice(1) : 'Personal');
                        actionText = `${foulText} foul`;
                        break;
                    case 'assist':
                        actionText = `Assist`;
                        break;
                    case 'substitution':
                        actionText = subType === 'in' ? `Substitution in` : `Substitution out`;
                        break;
                    case 'timeout':
                        const timeoutMap = {
                            'full': 'full',
                            'short': 'short',
                            'officials': 'official',
                            'commercial': 'commercial'
                        };
                        const timeoutText = timeoutMap[subType] || '';
                        actionText = timeoutText ? `Timeout - ${timeoutText}` : `Timeout`;
                        break;
                    case 'jumpball':
                        const jumpballMap = {
                            'won': 'won',
                            'lost': 'lost',
                            'startperiod': 'start period',
                            'heldball': 'held ball'
                        };
                        const jumpText = jumpballMap[subType] || '';
                        actionText = jumpText ? `Jump ball - ${jumpText}` : `Jump ball`;
                        break;
                    case 'period':
                        actionText = subType === 'start' ? `Period start` : `Period end`;
                        break;
                    case 'game':
                        actionText = subType === 'start' ? `Game start` : `Game end`;
                        break;
                    default:
                        actionText = play.actionText || actionType || 'Unknown';
                }

                // Determine team class (pbpt1 for team 1, pbpt2 for team 2)
                const teamClass = teamNo === 1 ? 'pbpt1' : (teamNo === 2 ? 'pbpt2' : 'pbpt0');

                // Format period display - use P for regular, OT for overtime (matches parsePeriodString expectations)
                let periodDisplay = '';
                let periodKey = '';
                if (periodType === 'OVERTIME') {
                    periodDisplay = `OT${period}`;
                    periodKey = `per_ot${period} per_ot`;
                } else {
                    // Regular period - use P1, P2, P3, P4 format that parsePeriodString expects
                    periodDisplay = `P${period}`;
                    periodKey = `per_${period} per_reg`;
                }

                // Build scoring block if this is a scoring action
                let scoringBlock = '';
                let scoringClass = '';
                if (play.scoring && success == 1) {
                    scoringBlock = `<span class="pbpsc">${score1}-${score2}</span>`;
                    scoringClass = 'scaction';
                }

                // Build the action div matching FIBA's exact HTML structure
                // For assists, add data attributes with scorer information for parsePBP
                let assistDataAttrs = '';
                if (actionType === 'assist') {
                    const scorerInfo = assistScorerMap.get(originalIdx);
                    if (scorerInfo) {
                        assistDataAttrs = ` data-scorer-num="${scorerInfo.scorerNum}" data-scorer-points="${scorerInfo.points}" data-scorer-three="${scorerInfo.wasThree}"`;
                    }
                }
                html += `<div id="${clock}" class="pbpa ${teamClass} pbpty${actionType} ${periodKey} ${subType} ${actionType}"${assistDataAttrs}>`;

                if (teamNo === 0) {
                    // Game/Period events (no team)
                    html += `<div class="description">${actionText}</div>`;
                    html += `<span class="pbpsc">${score1}-${score2}</span>`;
                } else {
                    // Team-specific action with nested pbp-team structure
                    html += `<div class="pbp-team pbp-team${teamNo} ${scoringClass}">`;
                    html += `<div class="pbp-time"><span class="pbp-period">${periodDisplay}</span> ${clock}${scoringBlock}</div>`;
                    html += `<div class="pbp-action"><strong>${playerDisplay}</strong>, ${actionText}</div>`;
                    html += `<span class="teamcolorbox team${teamNo}color"></span>`;
                    html += `</div>`;
                }

                html += `</div>`;
            });

            html += '</div>'; // Close #aj_pbp
            html += '</body></html>';
            return html;
        }

        /**
         * Handle URL fetch button click - sends request to parent Tauri app
         */
        async handleUrlFetch() {
            const bsUrlInput = document.getElementById('bs-url-input');
            const pbpUrlInput = document.getElementById('pbp-url-input');
            const scUrlInput = document.getElementById('sc-url-input');
            const statusEl = document.getElementById('url-fetch-status');
            const fetchBtn = document.getElementById('fetch-urls-btn');
            const btnIcon = document.getElementById('fetch-btn-icon');
            const btnText = document.getElementById('fetch-btn-text');

            const bsUrl = bsUrlInput?.value.trim();
            const pbpUrl = pbpUrlInput?.value.trim();
            const scUrl = scUrlInput?.value.trim();

            // Check if live mode is enabled
            const liveModeCheckbox = document.getElementById('live-mode-checkbox');
            const isLiveMode = liveModeCheckbox?.checked || false;

            // Validation
            if (!bsUrl || !pbpUrl) {
                statusEl.innerHTML = '<span style="color: var(--negative);">❌ Please enter both Boxscore and Play-by-Play URLs</span>';
                return;
            }

            // Validate URL format
            const urlPattern = /^https?:\/\/.+/i;
            if (!urlPattern.test(bsUrl)) {
                statusEl.innerHTML = '<span style="color: var(--negative);">❌ Invalid Boxscore URL format</span>';
                return;
            }
            if (!urlPattern.test(pbpUrl)) {
                statusEl.innerHTML = '<span style="color: var(--negative);">❌ Invalid Play-by-Play URL format</span>';
                return;
            }
            if (scUrl && !urlPattern.test(scUrl)) {
                statusEl.innerHTML = '<span style="color: var(--negative);">❌ Invalid Shot Chart URL format</span>';
                return;
            }

            // If live mode is enabled, start live mode instead of one-time fetch
            if (isLiveMode) {
                this.startLiveMode();
                return;
            }

            // Update UI to loading state
            fetchBtn.disabled = true;
            btnIcon.textContent = '⏳';
            btnText.textContent = 'Fetching...';
            statusEl.innerHTML = '<span style="color: var(--accent-cyan);">📡 Requesting data via Tauri...</span>';

            // Store pending request info
            this._pendingUrlFetch = { bsUrl, pbpUrl, scUrl, statusEl, fetchBtn, btnIcon, btnText };

            // Send request to parent Tauri app
            window.parent.postMessage({
                source: 'gamevis-app',
                type: 'FETCH_URLS_REQUEST',
                payload: { bsUrl, pbpUrl, scUrl }
            }, '*');
        }

        /**
         * Handle URL fetch result from parent Tauri app
         */
        async handleUrlFetchResult(payload) {
            const pending = this._pendingUrlFetch;
            if (!pending) return;

            const { statusEl, fetchBtn, btnIcon, btnText, bsUrl } = pending;

            try {
                if (payload.error) {
                    throw new Error(payload.error);
                }

                let { bsHtml, pbpHtml, scHtml, jsonData } = payload;

                // Check if JSON data was provided directly
                if (jsonData) {
                    console.log('[GameVis] Using JSON data directly');
                    this.fibaJsonData = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                    this.boxscoreHTML = this.generateBoxscoreHtmlFromJson(this.fibaJsonData);
                    this.pbpHTML = this.generatePbpHtmlFromJson(this.fibaJsonData);

                    statusEl.innerHTML = '<span style="color: var(--positive);">✓ Data loaded! Processing game...</span>';
                    this.updateUploadStatus();
                    await this.processGame();
                    statusEl.innerHTML = '<span style="color: var(--positive);">✓ Game loaded successfully!</span>';

                    // Reset button
                    fetchBtn.disabled = false;
                    btnIcon.textContent = '🚀';
                    btnText.textContent = 'Fetch & Load Game';
                    this._pendingUrlFetch = null;
                    return;
                } else if (!bsHtml || !pbpHtml) {
                    throw new Error('Failed to fetch required data');
                } else {
                    // Try to extract JSON data URL from HTML and fetch it
                    const dataPathMatch = bsHtml.match(/id\s*=\s*["']datapath["']\s*value\s*=\s*["']([^"']+)["']/i);
                    if (dataPathMatch) {
                        const dataPath = dataPathMatch[1];
                        // Construct JSON URL from the base URL
                        const urlObj = new URL(bsUrl || 'https://fibalivestats.dcd.shared.geniussports.com');
                        const jsonUrl = urlObj.origin + dataPath + 'data.json';

                        statusEl.innerHTML = '<span style="color: var(--accent-cyan);">📡 Fetching JSON data...</span>';
                        console.log('[GameVis] Found datapath, fetching JSON from:', jsonUrl);

                        // Request the JSON data via Tauri
                        this._pendingJsonUrl = jsonUrl;
                        window.parent.postMessage({
                            source: 'gamevis-app',
                            type: 'FETCH_JSON_REQUEST',
                            payload: { jsonUrl }
                        }, '*');
                        return; // Wait for JSON response
                    }
                }

                // Store the fetched HTML
                this.boxscoreHTML = bsHtml;
                this.pbpHTML = pbpHtml;
                if (scHtml) {
                    this.shotChartHTML = scHtml;
                }

                statusEl.innerHTML = '<span style="color: var(--positive);">✓ HTML fetched successfully! Processing game...</span>';

                // Update upload status
                this.updateUploadStatus();

                // Automatically process the game
                await this.processGame();

                statusEl.innerHTML = '<span style="color: var(--positive);">✓ Game loaded from URL!</span>';

            } catch (error) {
                console.error('[GameVis] URL fetch error:', error);
                statusEl.innerHTML = `<span style="color: var(--negative);">❌ Error: ${error.message || error}</span>`;
            } finally {
                // Reset button state
                fetchBtn.disabled = false;
                btnIcon.textContent = '🚀';
                btnText.textContent = 'Fetch & Load Game';
                this._pendingUrlFetch = null;
            }
        }

        // ========================================================================
        // SCHEDULE BROWSER METHODS
        // ========================================================================
        
        async fetchSchedule() {
            const fetchBtn = document.getElementById('fetch-schedule-btn');
            const scheduleUrlInput = document.getElementById('schedule-url-input');
            
            if (!fetchBtn || !scheduleUrlInput) return;
            
            const scheduleUrl = scheduleUrlInput.value.trim();
            
            if (!scheduleUrl) {
                alert('Please enter a schedule URL');
                return;
            }
            
            fetchBtn.disabled = true;
            fetchBtn.innerHTML = '⏳ Fetching...';
            this.scheduleFetchCancelled = false;
            
            this.showLoadingOverlay('Fetching Schedule', 'Connecting to schedule page...');
            
            try {
                // Fetch the schedule page
                const scheduleHtml = await this.fetchWithProxy(scheduleUrl);
                
                if (!scheduleHtml) {
                    throw new Error('Failed to fetch schedule page. Please run the local Python server for reliable fetching.');
                }
                
                console.log('Schedule HTML length:', scheduleHtml.length);
                
                // Parse the schedule to extract game IDs
                const games = this.parseSchedulePage(scheduleHtml);
                
                console.log('Games found:', games.length);
                
                if (games.length === 0) {
                    // Show what we got for debugging
                    console.log('Schedule HTML preview:', scheduleHtml.substring(0, 2000));
                    throw new Error('No games found in schedule. The page structure may have changed or the URL may be incorrect.');
                }
                
                this.updateLoadingProgress(0, games.length, 'Downloading game data...');
                
                // Fetch box score data for each game
                const fetchedGames = [];
                for (let i = 0; i < games.length; i++) {
                    if (this.scheduleFetchCancelled) {
                        break;
                    }
                    
                    const game = games[i];
                    this.updateLoadingProgress(i, games.length, `Fetching: ${game.homeTeam || 'Game ' + (i + 1)} vs ${game.awayTeam || '...'}`);
                    
                    try {
                        // Fetch box score to get team names and scores
                        const bsUrl = `${this.fibaBaseUrl}/${game.gameId}/bs.html`;
                        const bsHtml = await this.fetchWithProxy(bsUrl);
                        
                        if (bsHtml) {
                            const gameInfo = this.parseBoxscoreForGameInfo(bsHtml, game);
                            if (gameInfo) {
                                gameInfo.bsHtml = bsHtml;
                                fetchedGames.push(gameInfo);
                            }
                        }
                    } catch (e) {
                        console.warn(`Failed to fetch game ${game.gameId}:`, e);
                    }
                    
                    // Small delay to be nice to the server
                    await this.delay(300);
                }
                
                this.fetchedGames = fetchedGames;
                this.hideLoadingOverlay();
                this.displayGameList(fetchedGames);
                
            } catch (error) {
                console.error('Schedule fetch error:', error);
                this.hideLoadingOverlay();
                alert('Error fetching schedule: ' + error.message);
            } finally {
                fetchBtn.disabled = false;
                fetchBtn.innerHTML = '📥 Fetch All Games from Schedule';
            }
        }
        
        async fetchWithProxy(url) {
            // First try the server method if available
            try {
                const response = await fetch(`${this.serverUrl}/fetch-url`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.html) {
                        console.log('Fetched via local server');
                        return data.html;
                    }
                }
            } catch (e) {
                console.log('Local server not available, trying proxies...');
            }
            
            // Try AllOrigins with JSON endpoint (more reliable)
            try {
                const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(url)}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.contents && data.contents.length > 500) {
                        console.log('Fetched via AllOrigins JSON');
                        return data.contents;
                    }
                }
            } catch (e) {
                console.log('AllOrigins JSON failed:', e.message);
            }
            
            // Try other CORS proxies
            for (const proxy of this.corsProxies) {
                try {
                    console.log(`Trying ${proxy.name}...`);
                    const response = await fetch(proxy.url + encodeURIComponent(url));
                    if (response.ok) {
                        const html = await response.text();
                        if (html && html.length > 500) {
                            console.log(`Fetched via ${proxy.name}`);
                            return html;
                        }
                    }
                } catch (e) {
                    console.log(`${proxy.name} failed:`, e.message);
                    continue;
                }
            }
            
            return null;
        }
        
        parseSchedulePage(html) {
            const games = [];
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Method 1: Find all links that contain match/GAMEID/boxscore pattern
            // SLB URL format: ...WHurl=%2Fcompetition%2F41897%2Fmatch%2F2702542%2Fboxscore...
            const allLinks = doc.querySelectorAll('a[href]');
            
            allLinks.forEach(link => {
                const href = link.getAttribute('href') || '';
                // Decode URL-encoded characters
                const decodedHref = decodeURIComponent(href);
                
                // Look for match/GAMEID pattern
                const matchPatterns = [
                    /match\/(\d+)\/boxscore/i,
                    /match\/(\d+)/i,
                    /game\/(\d+)/i,
                    /matchId=(\d+)/i,
                    /gameId=(\d+)/i
                ];
                
                for (const pattern of matchPatterns) {
                    const match = decodedHref.match(pattern);
                    if (match) {
                        const gameId = match[1];
                        // Check if we already have this game
                        if (!games.find(g => g.gameId === gameId)) {
                            // Try to extract info from surrounding elements
                            let dateStr = '';
                            let homeTeam = '';
                            let awayTeam = '';
                            let homeScore = '';
                            let awayScore = '';
                            
                            // Look for parent row/container
                            const row = link.closest('tr') || link.closest('.match-row') || 
                                        link.closest('[class*="match"]') || link.closest('[class*="game"]') ||
                                        link.parentElement?.parentElement;
                            
                            if (row) {
                                // Extract text content and look for team names/scores
                                const text = row.textContent;
                                
                                // Try to find score pattern like "85 - 72" or "85:72"
                                const scoreMatch = text.match(/(\d{2,3})\s*[-:]\s*(\d{2,3})/);
                                if (scoreMatch) {
                                    homeScore = scoreMatch[1];
                                    awayScore = scoreMatch[2];
                                }
                            }
                            
                            games.push({
                                gameId,
                                dateStr,
                                homeTeam,
                                awayTeam,
                                homeScore,
                                awayScore,
                                originalLink: href
                            });
                        }
                        break;
                    }
                }
            });
            
            // Method 2: Regex fallback on raw HTML
            if (games.length === 0) {
                console.log('DOM parsing found no games, trying regex...');
                
                // Decode the entire HTML first
                const decodedHtml = html.replace(/%2F/gi, '/').replace(/%3F/gi, '?').replace(/%3D/gi, '=');
                
                const patterns = [
                    /match\/(\d{6,8})\/boxscore/gi,
                    /match\/(\d{6,8})/gi,
                    /['"\/](\d{7})['"\/?]/g  // 7-digit numbers that could be game IDs
                ];
                
                const foundIds = new Set();
                
                for (const regex of patterns) {
                    let match;
                    while ((match = regex.exec(decodedHtml)) !== null) {
                        const gameId = match[1];
                        if (!foundIds.has(gameId) && gameId.length >= 6) {
                            foundIds.add(gameId);
                            games.push({
                                gameId,
                                dateStr: '',
                                homeTeam: '',
                                awayTeam: '',
                                homeScore: '',
                                awayScore: ''
                            });
                        }
                    }
                }
            }
            
            console.log(`parseSchedulePage found ${games.length} games`);
            return games;
        }
        
        parseBoxscoreForGameInfo(bsHtml, baseGame) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(bsHtml, 'text/html');
            
            let homeTeam = '';
            let awayTeam = '';
            let homeScore = 0;
            let awayScore = 0;
            let gameDate = baseGame.dateStr || '';
            
            // Try to extract team names from the box score
            // Look for team headers
            const teamHeaders = doc.querySelectorAll('.team-name, .teamname, [class*="team-header"], h2, h3');
            const teamNames = [];
            
            teamHeaders.forEach(el => {
                const text = el.textContent.trim();
                if (text && text.length > 1 && text.length < 50 && !text.match(/^\d+$/)) {
                    teamNames.push(text);
                }
            });
            
            // Also look in stat tables
            const tables = doc.querySelectorAll('table');
            tables.forEach(table => {
                const caption = table.querySelector('caption, thead th');
                if (caption) {
                    const text = caption.textContent.trim();
                    if (text && !text.match(/^\d+$/) && text.length < 50) {
                        teamNames.push(text);
                    }
                }
            });
            
            // Look for score in the header area
            const scoreElements = doc.querySelectorAll('.score, [class*="score"], .final-score');
            scoreElements.forEach(el => {
                const text = el.textContent.trim();
                const scoreMatch = text.match(/(\d+)\s*[-:vs]\s*(\d+)/);
                if (scoreMatch) {
                    homeScore = parseInt(scoreMatch[1]);
                    awayScore = parseInt(scoreMatch[2]);
                }
            });
            
            // Alternative: look for team totals in stat tables
            if (homeScore === 0 || awayScore === 0) {
                const rows = doc.querySelectorAll('tr');
                rows.forEach(row => {
                    const text = row.textContent.toLowerCase();
                    if (text.includes('total') || text.includes('team')) {
                        const cells = row.querySelectorAll('td, th');
                        cells.forEach(cell => {
                            const val = parseInt(cell.textContent.trim());
                            if (val >= 30 && val <= 200) {
                                if (homeScore === 0) homeScore = val;
                                else if (awayScore === 0) awayScore = val;
                            }
                        });
                    }
                });
            }
            
            // Extract date if not already present
            if (!gameDate) {
                const dateElements = doc.querySelectorAll('.date, [class*="date"], time');
                dateElements.forEach(el => {
                    const text = el.textContent.trim();
                    if (text.match(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/) || 
                        text.match(/\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}/) ||
                        text.match(/\w+ \d{1,2},? \d{4}/)) {
                        gameDate = text;
                    }
                });
            }
            
            // Use team names if found
            if (teamNames.length >= 2) {
                homeTeam = teamNames[0];
                awayTeam = teamNames[1];
            } else if (teamNames.length === 1) {
                homeTeam = teamNames[0];
            }
            
            // Fallback to base game info
            if (!homeTeam) homeTeam = baseGame.homeTeam || `Team A`;
            if (!awayTeam) awayTeam = baseGame.awayTeam || `Team B`;
            
            return {
                gameId: baseGame.gameId,
                homeTeam,
                awayTeam,
                homeScore,
                awayScore,
                gameDate,
                bsUrl: `${this.fibaBaseUrl}/${baseGame.gameId}/bs.html`,
                pbpUrl: `${this.fibaBaseUrl}/${baseGame.gameId}/pbp.html`
            };
        }
        
        showLoadingOverlay(title, subtitle) {
            const overlay = document.getElementById('schedule-loading-overlay');
            document.getElementById('loading-title').textContent = title;
            document.getElementById('loading-subtitle').textContent = subtitle;
            document.getElementById('loading-progress-bar').style.width = '0%';
            document.getElementById('loading-progress-text').textContent = 'Starting...';
            document.getElementById('loading-current-game').textContent = '';
            overlay.classList.add('active');
        }
        
        hideLoadingOverlay() {
            document.getElementById('schedule-loading-overlay').classList.remove('active');
        }
        
        updateLoadingProgress(current, total, message) {
            const percent = total > 0 ? Math.round((current / total) * 100) : 0;
            document.getElementById('loading-progress-bar').style.width = `${percent}%`;
            document.getElementById('loading-progress-text').textContent = `${current} / ${total} games`;
            document.getElementById('loading-current-game').textContent = message;
        }
        
        cancelScheduleFetch() {
            this.scheduleFetchCancelled = true;
            this.hideLoadingOverlay();
        }
        
        displayGameList(games) {
            if (games.length === 0) {
                alert('No games were successfully fetched.');
                return;
            }
            
            const container = document.getElementById('game-list-container');
            const listEl = document.getElementById('game-list');
            const countEl = document.getElementById('game-count');
            
            countEl.textContent = games.length;
            
            // Sort games by date (newest first) if dates are available
            const sortedGames = [...games].sort((a, b) => {
                if (a.gameDate && b.gameDate) {
                    return new Date(b.gameDate) - new Date(a.gameDate);
                }
                return parseInt(b.gameId) - parseInt(a.gameId);
            });
            
            listEl.innerHTML = sortedGames.map(game => this.renderGameItem(game)).join('');
            
            // Add click handlers
            listEl.querySelectorAll('.game-item').forEach(item => {
                item.addEventListener('click', () => this.selectGame(item.dataset.gameId));
            });
            
            container.classList.add('active');
        }
        
        renderGameItem(game) {
            const dateDisplay = this.formatGameDate(game.gameDate);
            
            return `
                <div class="game-item" data-game-id="${game.gameId}">
                    <div class="game-item-date">
                        <span class="day">${dateDisplay.day}</span>
                        ${dateDisplay.month}
                    </div>
                    <div class="game-item-teams">
                        <div class="game-item-team home">🏠 ${game.homeTeam}</div>
                        <div class="game-item-team away">✈️ ${game.awayTeam}</div>
                    </div>
                    <div class="game-item-score">
                        <div class="game-item-score-value home">${game.homeScore || '-'}</div>
                        <div class="game-item-score-divider">vs</div>
                        <div class="game-item-score-value away">${game.awayScore || '-'}</div>
                    </div>
                    <div class="game-item-action">View</div>
                </div>
            `;
        }
        
        formatGameDate(dateStr) {
            if (!dateStr) {
                return { day: '?', month: '' };
            }
            
            try {
                const date = new Date(dateStr);
                if (!isNaN(date.getTime())) {
                    return {
                        day: date.getDate(),
                        month: date.toLocaleDateString('en-US', { month: 'short' })
                    };
                }
            } catch (e) {}
            
            // Try to parse common formats
            const parts = dateStr.split(/[\/\-\s]/);
            if (parts.length >= 2) {
                return {
                    day: parts[0].replace(/\D/g, '') || '?',
                    month: parts[1].substring(0, 3)
                };
            }
            
            return { day: '?', month: dateStr.substring(0, 6) };
        }
        
        filterGames(query) {
            const listEl = document.getElementById('game-list');
            const items = listEl.querySelectorAll('.game-item');
            const lowerQuery = query.toLowerCase();
            
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(lowerQuery) ? '' : 'none';
            });
        }
        
        closeGameList() {
            document.getElementById('game-list-container').classList.remove('active');
        }
        
        async selectGame(gameId) {
            const game = this.fetchedGames.find(g => g.gameId === gameId);
            if (!game) {
                alert('Game data not found');
                return;
            }
            
            const gameItem = document.querySelector(`.game-item[data-game-id="${gameId}"]`);
            gameItem?.classList.add('loading');
            
            try {
                // Use cached box score HTML if available
                this.boxscoreHTML = game.bsHtml;
                
                // Fetch play-by-play
                const pbpHtml = await this.fetchWithProxy(game.pbpUrl);
                if (pbpHtml) {
                    this.pbpHTML = pbpHtml;
                }
                
                // Process the game
                this.closeGameList();
                this.processGame();
                
            } catch (error) {
                console.error('Error loading game:', error);
                alert('Error loading game: ' + error.message);
            } finally {
                gameItem?.classList.remove('loading');
            }
        }
        
        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        handleFileUpload(event, type) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                if (type === 'boxscore') this.boxscoreHTML = e.target.result;
                else this.pbpHTML = e.target.result;
                this.updateUploadStatus();
            };
            reader.readAsText(file);
        }

        updateUploadStatus() {
            const status = document.getElementById('upload-status');
            const processBtn = document.getElementById('process-btn');
            const bsLoaded = this.boxscoreHTML !== null;
            const pbpLoaded = this.pbpHTML !== null;
            
            if (bsLoaded && pbpLoaded) {
                status.textContent = '✓ Both files loaded - Ready to process!';
                status.className = 'upload-status success';
                processBtn.disabled = false;
            } else if (bsLoaded) {
                status.textContent = '✓ Boxscore loaded. Waiting for Play-by-Play...';
                status.className = 'upload-status';
                processBtn.disabled = true;
            } else if (pbpLoaded) {
                status.textContent = '✓ Play-by-Play loaded. Waiting for Boxscore...';
                status.className = 'upload-status';
                processBtn.disabled = true;
            }
        }
        
        // ========================================================================
        // FOLDER UPLOAD - MULTI-GAME BROWSER
        // ========================================================================
        
        async handleFolderUpload(event) {
            const files = Array.from(event.target.files);
            const statusEl = document.getElementById('folder-upload-status');
            
            if (files.length === 0) {
                statusEl.textContent = 'No files selected';
                return;
            }
            
            statusEl.innerHTML = '<span style="color: var(--accent-cyan);">⏳ Scanning folder...</span>';
            
            // Group files by game ID
            const gameFiles = {};
            
            for (const file of files) {
                const path = file.webkitRelativePath || file.name;
                const filename = file.name;
                
                // Match flat file structure: game[id]bs.html and game[id]pbp.html
                // e.g., game2702542bs.html, game2702542pbp.html
                const flatBsMatch = filename.match(/^game(\d+)bs\.html$/i);
                const flatPbpMatch = filename.match(/^game(\d+)pbp\.html$/i);
                
                // Also support folder structure: folder/game[id]bs/file.html
                const folderBsMatch = path.match(/game(\d+)bs[\/\\]/i);
                const folderPbpMatch = path.match(/game(\d+)pbp[\/\\]/i);
                
                // Also try matching numeric-only patterns
                const altBsMatch = !flatBsMatch && !folderBsMatch && filename.match(/^(\d+)bs\.html$/i);
                const altPbpMatch = !flatPbpMatch && !folderPbpMatch && filename.match(/^(\d+)pbp\.html$/i);
                
                const effectiveBsMatch = flatBsMatch || folderBsMatch || altBsMatch;
                const effectivePbpMatch = flatPbpMatch || folderPbpMatch || altPbpMatch;
                
                if (effectiveBsMatch && file.name.endsWith('.html')) {
                    const gameId = effectiveBsMatch[1];
                    if (!gameFiles[gameId]) gameFiles[gameId] = {};
                    gameFiles[gameId].boxscore = file;
                }
                
                if (effectivePbpMatch && file.name.endsWith('.html')) {
                    const gameId = effectivePbpMatch[1];
                    if (!gameFiles[gameId]) gameFiles[gameId] = {};
                    gameFiles[gameId].pbp = file;
                }
            }
            
            const gameIds = Object.keys(gameFiles);
            
            if (gameIds.length === 0) {
                // Show some sample paths to help debug
                const samplePaths = Array.from(files).slice(0, 5).map(f => f.name);
                console.log('Sample files scanned:', samplePaths);
                statusEl.innerHTML = `<span style="color: var(--negative);">❌ No games found in ${files.length} files. Expected files like: game[id]bs.html and game[id]pbp.html</span>`;
                return;
            }
            
            statusEl.innerHTML = `<span style="color: var(--positive);">✓ Found ${gameIds.length} games. Loading boxscore data...</span>`;
            
            // Parse each game to extract details with progress updates
            this.folderGames = [];
            const total = gameIds.length;
            let processed = 0;
            let successCount = 0;
            
            // Create progress bar
            const progressContainer = document.createElement('div');
            progressContainer.innerHTML = `
                <div style="margin-top: 10px;">
                    <div style="background: var(--bg-elevated); border-radius: 4px; height: 8px; overflow: hidden;">
                        <div id="folder-progress-bar" style="background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta)); height: 100%; width: 0%; transition: width 0.2s ease;"></div>
                    </div>
                    <div id="folder-progress-text" style="font-size: 12px; color: var(--text-muted); margin-top: 4px;">0 / ${total} games loaded</div>
                </div>
            `;
            statusEl.parentNode.insertBefore(progressContainer, statusEl.nextSibling);
            
            const progressBar = document.getElementById('folder-progress-bar');
            const progressText = document.getElementById('folder-progress-text');
            
            // Process in batches to avoid blocking UI
            const batchSize = 5;
            for (let i = 0; i < gameIds.length; i += batchSize) {
                const batch = gameIds.slice(i, i + batchSize);
                
                await Promise.all(batch.map(async (gameId) => {
                    const gameData = gameFiles[gameId];
                    if (!gameData.boxscore) return;
                    
                    try {
                        const bsContent = await this.readFileAsText(gameData.boxscore);
                        const parsed = this.parseGameSummary(bsContent, gameId);
                        
                        if (parsed) {
                            parsed.boxscoreFile = gameData.boxscore;
                            parsed.pbpFile = gameData.pbp || null;
                            this.folderGames.push(parsed);
                            successCount++;
                        }
                    } catch (err) {
                        console.error(`Error parsing game ${gameId}:`, err);
                    }
                }));
                
                processed += batch.length;
                const pct = Math.round((processed / total) * 100);
                progressBar.style.width = pct + '%';
                progressText.textContent = `${processed} / ${total} games loaded (${successCount} successful)`;
                
                // Yield to browser for UI updates
                await new Promise(r => setTimeout(r, 0));
            }
            
            // Parse date strings to proper Date objects for sorting
            const parseGameDate = (dateStr) => {
                if (!dateStr) return null;
                // Handle DD/MM/YY or DD/MM/YYYY format
                const parts = dateStr.split('/');
                if (parts.length === 3) {
                    let [day, month, year] = parts.map(p => parseInt(p));
                    // Handle 2-digit year
                    if (year < 100) year += 2000;
                    return new Date(year, month - 1, day);
                }
                return null;
            };
            
            // Sort by date (chronological - oldest first)
            this.folderGames.sort((a, b) => {
                const dateA = parseGameDate(a.date);
                const dateB = parseGameDate(b.date);
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;
                return dateA - dateB; // Oldest first
            });
            
            // Remove progress bar and show final status
            progressContainer.remove();
            statusEl.innerHTML = `<span style="color: var(--positive);">✓ Loaded ${this.folderGames.length} games</span>`;
            
            // Display games
            this.renderGameBrowser();
        }
        
        readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(e);
                reader.readAsText(file);
            });
        }
        
        parseGameSummary(html, gameId) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            let homeTeam = '', awayTeam = '', homeScore = 0, awayScore = 0;
            const teamStats = [];
            
            // Method 1: Use FIBA LiveStats IDs (same as parseBoxscore)
            const team1NameEl = doc.querySelector('#aj_1_name');
            const team2NameEl = doc.querySelector('#aj_2_name');
            
            if (team1NameEl) homeTeam = team1NameEl.textContent.trim();
            if (team2NameEl) awayTeam = team2NameEl.textContent.trim();
            
            // Method 2: Fallback to table captions if IDs not found
            if (!homeTeam || !awayTeam) {
                const captions = doc.querySelectorAll('table caption');
                const captionTexts = [];
                captions.forEach(cap => {
                    const text = cap.textContent.trim();
                    if (text && text.length > 2 && text.length < 60) {
                        captionTexts.push(text);
                    }
                });
                if (captionTexts.length >= 2) {
                    if (!homeTeam) homeTeam = captionTexts[0];
                    if (!awayTeam) awayTeam = captionTexts[1];
                }
            }
            
            // Extract team totals - try FIBA LiveStats IDs first
            for (let teamId = 1; teamId <= 2; teamId++) {
                const prefix = `aj_${teamId}_tot_`;
                
                const getValueById = (suffix) => {
                    const span = doc.querySelector(`span[id="${prefix}${suffix}"]`);
                    return span ? parseInt(span.textContent.trim()) || 0 : 0;
                };
                
                let pts = getValueById('sPoints');
                let fgm = getValueById('sFieldGoalsMade');
                let fga = getValueById('sFieldGoalsAttempted');
                let fg3m = getValueById('sThreePointersMade');
                let fta = getValueById('sFreeThrowsAttempted');
                let tov = getValueById('sTurnovers');
                let oreb = getValueById('sReboundsOffensive');
                let dreb = getValueById('sReboundsDefensive');
                
                // If FIBA IDs didn't work, try parsing from table structure
                if (pts === 0 && fga === 0) {
                    const tables = doc.querySelectorAll('table.boxscore, table');
                    const table = tables[teamId - 1];
                    
                    if (table) {
                        // Try team-totals row first
                        let totalRow = table.querySelector('tr.team-totals');
                        if (!totalRow) totalRow = table.querySelector('tr.total');
                        if (!totalRow) totalRow = table.querySelector('tfoot tr');
                        
                        if (totalRow) {
                            // Get headers
                            const thead = table.querySelector('thead');
                            const headers = [];
                            if (thead) {
                                thead.querySelectorAll('th').forEach(th => {
                                    headers.push(th.textContent.trim().toUpperCase());
                                });
                            }
                            
                            const cells = totalRow.querySelectorAll('td');
                            
                            const getValueByHeader = (names) => {
                                for (const name of names) {
                                    const idx = headers.findIndex(h => h === name || h.includes(name));
                                    if (idx >= 0 && cells[idx]) {
                                        const val = parseInt(cells[idx].textContent.trim());
                                        if (!isNaN(val)) return val;
                                    }
                                }
                                return 0;
                            };
                            
                            pts = getValueByHeader(['PTS', 'POINTS']);
                            fgm = getValueByHeader(['FGM', '2PM']);
                            fga = getValueByHeader(['FGA', '2PA']);
                            fg3m = getValueByHeader(['3PM', '3FGM', '3P']);
                            fta = getValueByHeader(['FTA']);
                            tov = getValueByHeader(['TO', 'TOV']);
                            oreb = getValueByHeader(['OR', 'OREB']);
                            dreb = getValueByHeader(['DR', 'DREB']);
                        }
                    }
                }
                
                teamStats.push({ pts, fgm, fga, fg3m, fta, tov, oreb, dreb });
            }
            
            // Assign scores
            if (teamStats.length >= 1) homeScore = teamStats[0].pts;
            if (teamStats.length >= 2) awayScore = teamStats[1].pts;
            
            // Calculate four factors
            const calcFourFactors = (team, opponent) => {
                let efg = 50, tovPct = 15, orebPct = 25, ftRate = 25;
                
                if (team && team.fga > 0) {
                    efg = ((team.fgm + 0.5 * team.fg3m) / team.fga) * 100;
                    ftRate = (team.fta / team.fga) * 100;
                    
                    const poss = team.fga + 0.44 * team.fta + team.tov;
                    if (poss > 0) {
                        tovPct = (team.tov / poss) * 100;
                    }
                }
                
                // OREB% = OREB / (OREB + Opponent DREB)
                if (team && opponent) {
                    const orebOpportunities = team.oreb + opponent.dreb;
                    if (orebOpportunities > 0) {
                        orebPct = (team.oreb / orebOpportunities) * 100;
                    }
                }
                
                return { efg, tovPct, orebPct, ftRate };
            };
            
            const fourFactors = {
                home: calcFourFactors(teamStats[0], teamStats[1]),
                away: calcFourFactors(teamStats[1], teamStats[0])
            };
            
            // Extract date from matchDetail div containing "Game Details"
            let gameDate = '';
            let competition = '';
            const matchDetails = doc.querySelectorAll('.matchDetail');
            
            for (const detail of matchDetails) {
                const heading = detail.querySelector('h6');
                if (!heading) continue;
                
                const headingText = heading.textContent.trim();
                
                if (headingText.includes('Game Details')) {
                    const text = detail.textContent;
                    const dateMatch = text.match(/(\d{1,2}\/\d{1,2}\/\d{2,4})/);
                    if (dateMatch) {
                        gameDate = dateMatch[1];
                    }
                }
                
                if (headingText.includes('Competition')) {
                    const p = detail.querySelector('p');
                    if (p) {
                        competition = p.textContent.trim();
                    }
                }
            }
            
            // Fallback: search all matchDetail divs for any date pattern
            if (!gameDate) {
                for (const detail of matchDetails) {
                    const text = detail.textContent;
                    const dateMatch = text.match(/(\d{1,2}\/\d{1,2}\/\d{2,4})/);
                    if (dateMatch) {
                        gameDate = dateMatch[1];
                        break;
                    }
                }
            }
            
            return {
                gameId,
                homeTeam: homeTeam || `Game ${gameId} - Home`,
                awayTeam: awayTeam || `Game ${gameId} - Away`,
                homeScore,
                awayScore,
                date: gameDate,
                competition,
                fourFactors
            };
        }
        
        renderGameBrowser() {
            // Use the new full-page browser view
            const list = document.getElementById('browser-game-list');
            const count = document.getElementById('browser-game-count');
            const filterDropdown = document.getElementById('browser-team-filter');
            
            if (!this.folderGames || this.folderGames.length === 0) {
                return;
            }
            
            count.textContent = this.folderGames.length;
            
            // Populate team dropdown
            const allTeams = new Set();
            this.folderGames.forEach(game => {
                if (game.homeTeam) allTeams.add(game.homeTeam);
                if (game.awayTeam) allTeams.add(game.awayTeam);
            });
            
            const sortedTeams = Array.from(allTeams).sort((a, b) => a.localeCompare(b));
            filterDropdown.innerHTML = `
                <option value="">🏀 All Teams (${this.folderGames.length} games)</option>
                ${sortedTeams.map(team => `<option value="${team}">${team}</option>`).join('')}
            `;
            
            // Use document fragment for better performance
            const fragment = document.createDocumentFragment();
            const tempContainer = document.createElement('div');
            
            // Build HTML string (faster than individual DOM operations)
            const htmlParts = [];
            
            this.folderGames.forEach((game, idx) => {
                const ff = game.fourFactors || { home: { efg: 50, tovPct: 15, orebPct: 25, ftRate: 25 }, away: { efg: 50, tovPct: 15, orebPct: 25, ftRate: 25 } };
                const homeWon = game.homeScore > game.awayScore;
                const hasScores = game.homeScore !== undefined && game.homeScore !== null;
                
                // Format scores - show actual value even if 0, but show — if undefined
                const homeScoreDisplay = (game.homeScore !== undefined && game.homeScore !== null) ? game.homeScore : '—';
                const awayScoreDisplay = (game.awayScore !== undefined && game.awayScore !== null) ? game.awayScore : '—';
                
                htmlParts.push(`
                    <div class="browser-game-card" data-game-idx="${idx}" data-home="${game.homeTeam}" data-away="${game.awayTeam}">
                        <div class="browser-game-main">
                            <div class="browser-team home">
                                <div class="browser-team-name">${game.homeTeam}</div>
                                ${hasScores && homeWon ? '<span style="font-size: 10px; color: var(--positive); margin-top: 2px;">● WIN</span>' : ''}
                            </div>
                            <div class="browser-score-block">
                                <span class="browser-score home">${homeScoreDisplay}</span>
                                <div class="browser-score-divider"></div>
                                <span class="browser-score away">${awayScoreDisplay}</span>
                            </div>
                            <div class="browser-team away">
                                <div class="browser-team-name">${game.awayTeam}</div>
                                ${hasScores && !homeWon && game.awayScore > game.homeScore ? '<span style="font-size: 10px; color: var(--positive); margin-top: 2px;">WIN ●</span>' : ''}
                            </div>
                            <div class="browser-date">${game.date || '—'}${game.competition ? ` · ${game.competition}` : ''}</div>
                            <button class="browser-load-btn" data-game-idx="${idx}">Load Game</button>
                        </div>
                        <div class="browser-game-details">
                            <div class="browser-four-factors">
                                <div class="browser-factor-item">
                                    <div class="browser-factor-label">eFG%</div>
                                    <div class="browser-factor-values">
                                        <span class="home">${ff.home.efg.toFixed(1)}</span>
                                        <span style="color: var(--text-muted);">vs</span>
                                        <span class="away">${ff.away.efg.toFixed(1)}</span>
                                    </div>
                                </div>
                                <div class="browser-factor-item">
                                    <div class="browser-factor-label">TOV%</div>
                                    <div class="browser-factor-values">
                                        <span class="home">${ff.home.tovPct.toFixed(1)}</span>
                                        <span style="color: var(--text-muted);">vs</span>
                                        <span class="away">${ff.away.tovPct.toFixed(1)}</span>
                                    </div>
                                </div>
                                <div class="browser-factor-item">
                                    <div class="browser-factor-label">OREB%</div>
                                    <div class="browser-factor-values">
                                        <span class="home">${ff.home.orebPct.toFixed(1)}</span>
                                        <span style="color: var(--text-muted);">vs</span>
                                        <span class="away">${ff.away.orebPct.toFixed(1)}</span>
                                    </div>
                                </div>
                                <div class="browser-factor-item">
                                    <div class="browser-factor-label">FT Rate</div>
                                    <div class="browser-factor-values">
                                        <span class="home">${ff.home.ftRate.toFixed(1)}</span>
                                        <span style="color: var(--text-muted);">vs</span>
                                        <span class="away">${ff.away.ftRate.toFixed(1)}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `);
            });
            
            list.innerHTML = htmlParts.join('');
            
            // Use event delegation for better performance (single listener instead of many)
            list.onclick = (e) => {
                const loadBtn = e.target.closest('.browser-load-btn');
                if (loadBtn) {
                    e.stopPropagation();
                    const idx = parseInt(loadBtn.dataset.gameIdx);
                    this.loadGameFromFolder(idx);
                    return;
                }
                
                const main = e.target.closest('.browser-game-main');
                if (main && !e.target.closest('.browser-load-btn')) {
                    const card = main.closest('.browser-game-card');
                    if (card) card.classList.toggle('expanded');
                }
            };
            
            // Navigate to browser view
            this.navigateTo('browser');
        }
        
        filterBrowserGames(selectedTeam) {
            if (!this.folderGames) return;
            
            const cards = document.querySelectorAll('.browser-game-card');
            let visibleCount = 0;
            
            cards.forEach(card => {
                const homeTeam = card.dataset.home;
                const awayTeam = card.dataset.away;
                
                const matchesHome = homeTeam === selectedTeam;
                const matchesAway = awayTeam === selectedTeam;
                const showAll = selectedTeam === '';
                
                const visible = showAll || matchesHome || matchesAway;
                card.style.display = visible ? '' : 'none';
                if (visible) visibleCount++;
            });
            
            // Update count
            const countEl = document.getElementById('browser-game-count');
            if (countEl) {
                countEl.textContent = visibleCount;
            }
        }
        
        async loadGameFromFolder(idx) {
            const game = this.folderGames[idx];
            if (!game || !game.boxscoreFile) {
                alert('Game data not available. Please try reloading the folder.');
                return;
            }
            
            // Show loading state on button
            const btn = document.querySelector(`.browser-load-btn[data-game-idx="${idx}"]`);
            if (btn) {
                btn.textContent = 'Loading...';
                btn.disabled = true;
            }
            
            try {
                // Read boxscore file
                this.boxscoreHTML = await this.readFileAsText(game.boxscoreFile);
                
                // Read PBP file if available
                this.pbpHTML = game.pbpFile ? await this.readFileAsText(game.pbpFile) : null;
                
                // Navigate to game view and process
                this.navigateTo('game');
                this.processGame();
                
            } catch (err) {
                console.error('Error loading game:', err);
                alert('Error loading game: ' + err.message);
                
                if (btn) {
                    btn.textContent = 'Load Game';
                    btn.disabled = false;
                }
            }
        }

        // ========================================================================
        // SERVER SCRIPT DOWNLOAD
        // ========================================================================
        
        downloadServerScript() {
            const serverCode = `#!/usr/bin/env python3
"""
FIBA LiveStats Proxy Server
============================
Run this server locally to enable reliable live game data fetching.

Usage:
    python fiba_live_server.py

Requirements:
    pip install flask requests flask-cors
"""

from flask import Flask, jsonify, request
from flask_cors import CORS
import requests
import threading
import time
from datetime import datetime

app = Flask(__name__)
CORS(app)

game_cache = {
    'boxscore_html': None,
    'pbp_html': None,
    'last_update': None,
    'bs_url': None,
    'pbp_url': None,
    'auto_refresh': False,
    'refresh_interval': 30,
    'error': None
}

HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
}

def fetch_url(url, timeout=15):
    try:
        response = requests.get(url, headers=HEADERS, timeout=timeout)
        response.raise_for_status()
        return response.text, None
    except requests.exceptions.RequestException as e:
        return None, str(e)

def auto_refresh_worker():
    global game_cache
    while True:
        if game_cache['auto_refresh'] and game_cache['bs_url']:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] Auto-refreshing...")
            bs_html, bs_error = fetch_url(game_cache['bs_url'])
            if bs_html:
                game_cache['boxscore_html'] = bs_html
                game_cache['error'] = None
            if game_cache['pbp_url']:
                pbp_html, _ = fetch_url(game_cache['pbp_url'])
                if pbp_html:
                    game_cache['pbp_html'] = pbp_html
            game_cache['last_update'] = datetime.now().isoformat()
        time.sleep(game_cache['refresh_interval'])

@app.route('/')
def index():
    return jsonify({
        'status': 'running',
        'service': 'FIBA LiveStats Proxy Server',
        'cache_status': {
            'has_boxscore': game_cache['boxscore_html'] is not None,
            'has_pbp': game_cache['pbp_html'] is not None,
            'last_update': game_cache['last_update']
        }
    })

@app.route('/fetch', methods=['POST'])
def fetch_game():
    global game_cache
    data = request.json or {}
    bs_url = data.get('bs_url', '').strip()
    pbp_url = data.get('pbp_url', '').strip()
    
    if not bs_url:
        return jsonify({'success': False, 'error': 'Boxscore URL required'}), 400
    
    if not pbp_url and 'bs.html' in bs_url:
        pbp_url = bs_url.replace('bs.html', 'pbp.html')
    
    print(f"Fetching: {bs_url}")
    bs_html, bs_error = fetch_url(bs_url)
    if not bs_html:
        return jsonify({'success': False, 'error': f'Failed: {bs_error}'}), 500
    
    game_cache['boxscore_html'] = bs_html
    game_cache['bs_url'] = bs_url
    
    pbp_html = None
    if pbp_url:
        pbp_html, _ = fetch_url(pbp_url)
        if pbp_html:
            game_cache['pbp_html'] = pbp_html
            game_cache['pbp_url'] = pbp_url
    
    game_cache['last_update'] = datetime.now().isoformat()
    
    return jsonify({
        'success': True,
        'boxscore_html': bs_html,
        'pbp_html': pbp_html,
        'last_update': game_cache['last_update']
    })

@app.route('/status', methods=['GET'])
def status():
    return jsonify({
        'server': 'running',
        'auto_refresh': game_cache['auto_refresh'],
        'last_update': game_cache['last_update'],
        'has_boxscore': game_cache['boxscore_html'] is not None,
        'has_pbp': game_cache['pbp_html'] is not None
    })

@app.route('/fetch-url', methods=['POST'])
def fetch_single_url():
    """Fetch any URL - useful for schedule pages and individual games"""
    data = request.json or {}
    url = data.get('url', '').strip()
    
    if not url:
        return jsonify({'success': False, 'error': 'URL required'}), 400
    
    print(f"Fetching URL: {url}")
    html, error = fetch_url(url)
    
    if html:
        return jsonify({
            'success': True,
            'html': html
        })
    else:
        return jsonify({'success': False, 'error': error or 'Failed to fetch'}), 500

if __name__ == '__main__':
    print("=" * 50)
    print("FIBA LiveStats Proxy Server")
    print("Running on http://localhost:5555")
    print("=" * 50)
    
    refresh_thread = threading.Thread(target=auto_refresh_worker, daemon=True)
    refresh_thread.start()
    
    app.run(host='0.0.0.0', port=5555, debug=False, threaded=True)
`;
            const blob = new Blob([serverCode], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fiba_live_server.py';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ========================================================================
        // LIVE MODE
        // ========================================================================

        async startLiveMode() {
            const bsUrlInput = document.getElementById('bs-url-input');
            const pbpUrlInput = document.getElementById('pbp-url-input');
            const statusEl = document.getElementById('url-fetch-status');
            const fetchBtn = document.getElementById('fetch-urls-btn');
            const btnIcon = document.getElementById('fetch-btn-icon');
            const btnText = document.getElementById('fetch-btn-text');

            if (!bsUrlInput) return;

            const bsUrl = bsUrlInput.value.trim();
            let pbpUrl = pbpUrlInput ? pbpUrlInput.value.trim() : '';

            if (!bsUrl) {
                if (statusEl) statusEl.innerHTML = '<span style="color: var(--negative);">❌ Please enter the Boxscore URL</span>';
                return;
            }

            if (!pbpUrl && bsUrl.includes('bs.html')) {
                pbpUrl = bsUrl.replace('bs.html', 'pbp.html');
            }

            this.liveBsUrl = bsUrl;
            this.livePbpUrl = pbpUrl;
            this.liveMode = true;

            const refreshIntervalEl = document.getElementById('refresh-interval');
            this.refreshSeconds = refreshIntervalEl ? parseInt(refreshIntervalEl.value) : 60;

            // Update UI for live mode
            if (fetchBtn) {
                fetchBtn.disabled = true;
                fetchBtn.style.background = 'linear-gradient(135deg, var(--negative), rgba(255, 107, 107, 0.7))';
            }
            if (btnIcon) btnIcon.textContent = '🔴';
            if (btnText) btnText.textContent = 'Live Mode Active';
            if (bsUrlInput) bsUrlInput.disabled = true;
            if (pbpUrlInput) pbpUrlInput.disabled = true;

            // Disable live mode checkbox
            const liveModeCheckbox = document.getElementById('live-mode-checkbox');
            if (liveModeCheckbox) liveModeCheckbox.disabled = true;

            // Show live status panel
            const liveStatusPanel = document.getElementById('live-status-panel');
            if (liveStatusPanel) liveStatusPanel.style.display = 'block';

            this.updateStatus('connecting', 'Connecting...');
            await this.fetchLiveData();
            this.startLiveInterval();
        }

        stopLiveMode() {
            this.liveMode = false;
            if (this.liveInterval) clearInterval(this.liveInterval);
            if (this.countdownInterval) clearInterval(this.countdownInterval);

            const bsUrlInput = document.getElementById('bs-url-input');
            const pbpUrlInput = document.getElementById('pbp-url-input');
            const fetchBtn = document.getElementById('fetch-urls-btn');
            const btnIcon = document.getElementById('fetch-btn-icon');
            const btnText = document.getElementById('fetch-btn-text');

            // Reset UI
            if (fetchBtn) {
                fetchBtn.disabled = false;
                fetchBtn.style.background = 'linear-gradient(135deg, var(--accent-emerald), rgba(0, 255, 136, 0.7))';
            }
            if (btnIcon) btnIcon.textContent = '🚀';
            if (btnText) btnText.textContent = 'Fetch & Load Game';
            if (bsUrlInput) bsUrlInput.disabled = false;
            if (pbpUrlInput) pbpUrlInput.disabled = false;

            // Re-enable live mode checkbox
            const liveModeCheckbox = document.getElementById('live-mode-checkbox');
            if (liveModeCheckbox) {
                liveModeCheckbox.disabled = false;
                liveModeCheckbox.checked = false;
            }

            // Hide refresh interval
            const refreshIntervalContainer = document.getElementById('refresh-interval-container');
            if (refreshIntervalContainer) refreshIntervalContainer.style.display = 'none';

            // Hide live status panel
            const liveStatusPanel = document.getElementById('live-status-panel');
            if (liveStatusPanel) liveStatusPanel.style.display = 'none';

            // Hide floating bar
            const floatingBar = document.getElementById('live-floating-bar');
            if (floatingBar) floatingBar.classList.remove('active');

            this.updateStatus('error', 'Stopped');
        }

        startLiveInterval() {
            if (this.liveInterval) clearInterval(this.liveInterval);
            this.nextUpdate = new Date(Date.now() + this.refreshSeconds * 1000);
            this.startCountdown();
            this.liveInterval = setInterval(() => this.fetchLiveData(), this.refreshSeconds * 1000);
        }

        restartLiveInterval() {
            this.startLiveInterval();
        }

        startCountdown() {
            if (this.countdownInterval) clearInterval(this.countdownInterval);
            const update = () => {
                if (!this.nextUpdate) return;
                const remaining = Math.max(0, Math.ceil((this.nextUpdate - Date.now()) / 1000));
                document.getElementById('next-update-time').textContent = `Next: ${remaining}s`;
                document.getElementById('floating-countdown').textContent = `Next update in ${remaining}s`;
            };
            update();
            this.countdownInterval = setInterval(update, 1000);
        }

        async fetchLiveData() {
            this.updateStatus('connecting', 'Fetching...');

            try {
                // Check if we're in an iframe (Tauri app)
                const isInIframe = window.self !== window.top;

                if (isInIframe) {
                    // Request data from parent Tauri app (uses Cloudflare Worker)
                    console.log('[GameVis Live] Requesting live data from parent app...');
                    window.parent.postMessage({
                        source: 'gamevis-app',
                        type: 'LIVE_FETCH_REQUEST',
                        payload: {
                            bsUrl: this.liveBsUrl,
                            pbpUrl: this.livePbpUrl
                        }
                    }, '*');
                    // Result will come via LIVE_FETCH_RESULT message
                    return;
                }

                // Fallback for standalone mode (not in Tauri)
                let bsHtml, pbpHtml;

                if (this.liveMethod === 'server') {
                    const response = await fetch(`${this.serverUrl}/fetch`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            bs_url: this.liveBsUrl,
                            pbp_url: this.livePbpUrl
                        })
                    });

                    if (!response.ok) throw new Error('Server request failed');
                    const data = await response.json();

                    if (!data.success) throw new Error(data.error || 'Server error');

                    bsHtml = data.boxscore_html;
                    pbpHtml = data.pbp_html;
                } else {
                    for (const proxy of this.corsProxies) {
                        try {
                            const bsResp = await fetch(proxy.url + encodeURIComponent(this.liveBsUrl));
                            if (bsResp.ok) {
                                bsHtml = await bsResp.text();
                                if (bsHtml && bsHtml.length > 500) {
                                    if (this.livePbpUrl) {
                                        const pbpResp = await fetch(proxy.url + encodeURIComponent(this.livePbpUrl));
                                        if (pbpResp.ok) pbpHtml = await pbpResp.text();
                                    }
                                    break;
                                }
                            }
                        } catch (e) { continue; }
                    }

                    if (!bsHtml) throw new Error('All proxies failed');
                }

                this.boxscoreHTML = bsHtml;
                if (pbpHtml) this.pbpHTML = pbpHtml;

                this.lastUpdate = new Date();
                document.getElementById('last-update-time').textContent =
                    `Last: ${this.lastUpdate.toLocaleTimeString()}`;

                this.updateStatus('connected', 'Live');
                this.processGameSilent();

                this.nextUpdate = new Date(Date.now() + this.refreshSeconds * 1000);

            } catch (error) {
                console.error('Fetch error:', error);
                this.updateStatus('error', `Error: ${error.message}`);
            }
        }

        updateStatus(type, message) {
            const dot = document.getElementById('status-dot');
            const text = document.getElementById('status-text');
            dot.className = 'status-dot ' + type;
            text.textContent = message;
            
            if (type === 'connected') {
                document.getElementById('live-floating-bar').classList.add('active');
            }
        }

        processGameSilent() {
            try {
                this.resetParserState();
                const teamsData = this.parseBoxscore(this.boxscoreHTML);
                let onCourtStats = null;
                if (this.pbpHTML) {
                    onCourtStats = this.parsePBP(this.pbpHTML, teamsData);
                }
                const result = this.calculateAdvancedMetrics(teamsData, onCourtStats);
                document.getElementById('upload-section').style.display = 'none';
                this.renderVisualization(result.teamsData, result.pace);
            } catch (error) {
                console.error('Processing error:', error);
                this.updateStatus('error', `Parse error: ${error.message}`);
            }
        }

        resetParserState() {
            this.lineupStats = {};
            this.playerRoster = {};
            this.currentLineups = { 0: new Set(), 1: new Set() };
            this.teams = {};
            this.currentPeriod = 1;
            this.lastTime = 0;
            this.resetAssistCombinations();
            
            // Game flow tracking for PPP Development chart
            this.gameFlowData = [];
            this.runningStats = {
                home: { points: 0, fga: 0, fgm: 0, fg3m: 0, fg3a: 0, fta: 0, ftm: 0, tov: 0, oreb: 0 },
                away: { points: 0, fga: 0, fgm: 0, fg3m: 0, fg3a: 0, fta: 0, ftm: 0, tov: 0, oreb: 0 }
            };
            
            // Player Runs & Team Momentum tracking
            this.playerRuns = [];          // Array of { player, team, teamIdx, points, startElapsed, endElapsed, startScore, endScore }
            this.teamMomentumRuns = [];    // Array of { team, teamIdx, points, lineup, lineupNames, startElapsed, endElapsed, scoreDiff, topScorer, topScorerPoints }
            this.currentScoringRun = {
                lastScoringTeam: null,
                consecutivePoints: 0,
                scoringPlayers: {},        // { playerNum: points }
                startElapsed: 0,
                startHomeScore: 0,
                startAwayScore: 0,
                currentLineup: null
            };
            
            // Period-based stats tracking
            this.periodStats = {
                // Structure: periodStats[teamName][period] = { player stats... }
            };
            this.teamPeriodTotals = {
                // Structure: teamPeriodTotals[teamName][period] = { totals... }
            };
            this.maxPeriod = 4; // Will update if OT detected
        }

        // ========================================================================
        // BOXSCORE PARSING - FIXED
        // ========================================================================

        parseBoxscore(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const teamsData = {};
            
            // Extract team names
            const teamNames = [];
            for (let i = 1; i <= 2; i++) {
                const nameSpan = doc.querySelector(`#aj_${i}_name`);
                if (nameSpan) teamNames.push(nameSpan.textContent.trim());
            }
            
            this.log(`Found teams: ${teamNames.join(' vs ')}`);
            
            const tables = doc.querySelectorAll('table.boxscore');
            tables.forEach((table, tableIdx) => {
                if (tableIdx >= 2) return;
                const teamName = teamNames[tableIdx] || `Team ${tableIdx + 1}`;
                const players = [];
                const teamTotals = {};
                const roster = {};
                const starters = [];
                
                // Parse each player row
                table.querySelectorAll('tr.player-row').forEach(row => {
                    if (row.classList.contains('row-not-used')) return;
                    const player = this.parsePlayerRow(row, tableIdx + 1);
                    if (player) {
                        players.push(player);
                        // Build roster: number -> name
                        roster[player.number] = player.name;
                        if (player.isStarter) {
                            starters.push(player.number);
                        }
                    }
                });
                
                // Parse team totals
                const totalsRow = table.querySelector('tr.team-totals');
                if (totalsRow) this.parseTeamTotals(totalsRow, tableIdx + 1, teamTotals);
                
                teamsData[teamName] = { players, teamTotals };
                this.playerRoster[teamName] = roster;
                this.teams[tableIdx] = { name: teamName, roster, starters };
                
                // Initialize current lineups with starters (using jersey numbers)
                this.currentLineups[tableIdx] = new Set(starters.map(n => this.normalizeNumber(n)));
                
                this.log(`Team ${tableIdx}: ${teamName}, ${players.length} players, Starters: ${starters.join(',')}`);
            });
            
            return teamsData;
        }

        normalizeNumber(num) {
            // Remove leading zeros and convert to string
            if (num === null || num === undefined) return null;
            const str = String(num).trim();
            if (/^\d+$/.test(str)) {
                return String(parseInt(str, 10));
            }
            return str;
        }

        /**
         * Check if two game clock times are within a given number of seconds
         * Format: "MM:SS" or "M:SS"
         */
        timesWithinSeconds(time1, time2, maxDiff) {
            if (!time1 || !time2) return false;
            const parseTime = (t) => {
                const parts = t.split(':');
                if (parts.length !== 2) return null;
                const mins = parseInt(parts[0], 10);
                const secs = parseInt(parts[1], 10);
                if (isNaN(mins) || isNaN(secs)) return null;
                return mins * 60 + secs;
            };
            const t1 = parseTime(time1);
            const t2 = parseTime(time2);
            if (t1 === null || t2 === null) return false;
            return Math.abs(t1 - t2) <= maxDiff;
        }

        parsePlayerRow(row, teamId) {
            const rowId = row.getAttribute('id') || '';
            const match = rowId.match(/aj_(\d+)_(\d+)_row/);
            if (!match) return null;
            
            const playerId = match[2];
            const prefix = `aj_${teamId}_${playerId}_`;
            const player = {};
            
            // Get jersey number
            const numSpan = row.querySelector('span[id$="shirtNumber"]');
            if (numSpan) {
                player.number = this.normalizeNumber(numSpan.textContent.trim());
            }
            
            // Get player name
            const nameSpan = row.querySelector(`span[id="${prefix}name"]`) || row.querySelector('span[id$="_name"]');
            if (nameSpan) player.name = nameSpan.textContent.trim();
            
            player.isStarter = row.classList.contains('p_starter');
            
            // Parse minutes
            const minsSpan = row.querySelector(`span[id="${prefix}sMinutes"]`);
            if (minsSpan) {
                const minText = minsSpan.textContent.trim();
                if (minText.includes(':')) {
                    const parts = minText.split(':');
                    player.minutes = parseInt(parts[0]) + parseInt(parts[1]) / 60;
                } else {
                    player.minutes = parseFloat(minText) || 0;
                }
            } else {
                player.minutes = 0;
            }
            
            // Parse stats
            const statMap = {
                'sPoints': 'points', 'sFieldGoalsMade': 'fgm', 'sFieldGoalsAttempted': 'fga',
                'sThreePointersMade': 'fg3m', 'sThreePointersAttempted': 'fg3a',
                'sTwoPointersMade': 'fg2m', 'sTwoPointersAttempted': 'fg2a',
                'sFreeThrowsMade': 'ftm', 'sFreeThrowsAttempted': 'fta',
                'sReboundsOffensive': 'oreb', 'sReboundsDefensive': 'dreb',
                'sAssists': 'ast', 'sSteals': 'stl', 'sBlocks': 'blk',
                'sTurnovers': 'tov', 'sFoulsPersonal': 'pf'
            };
            
            for (const [spanSuffix, statKey] of Object.entries(statMap)) {
                const span = row.querySelector(`span[id="${prefix}${spanSuffix}"]`);
                player[statKey] = span ? parseInt(span.textContent.trim()) || 0 : 0;
            }
            
            // Calculate 2pt if not directly available
            if (!player.fg2m) player.fg2m = player.fgm - player.fg3m;
            if (!player.fg2a) player.fg2a = player.fga - player.fg3a;
            
            // Initialize shot distribution
            player.rimAtt = 0;
            player.rimMade = 0;
            player.midAtt = 0;
            player.midMade = 0;
            
            return player;
        }

        parseTeamTotals(row, teamId, totals) {
            const prefix = `aj_${teamId}_tot_`;
            const statMap = {
                'sPoints': 'points', 'sFieldGoalsMade': 'fgm', 'sFieldGoalsAttempted': 'fga',
                'sThreePointersMade': 'fg3m', 'sThreePointersAttempted': 'fg3a',
                'sFreeThrowsMade': 'ftm', 'sFreeThrowsAttempted': 'fta',
                'sReboundsOffensive': 'oreb', 'sReboundsDefensive': 'dreb',
                'sReboundsTotal': 'treb', 'sAssists': 'ast', 'sTurnovers': 'tov',
                'sSteals': 'stl', 'sBlocks': 'blk', 'sFoulsTotal': 'pf'
            };
            
            for (const [spanSuffix, statKey] of Object.entries(statMap)) {
                const span = row.querySelector(`span[id="${prefix}${spanSuffix}"]`);
                totals[statKey] = span ? parseInt(span.textContent.trim()) || 0 : 0;
            }
        }

        // ========================================================================
        // PLAY-BY-PLAY PARSING - COMPLETELY REWRITTEN
        // ========================================================================

        getDefaultLineupStats() {
            return {
                points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0, ftm: 0, fta: 0,
                oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, pf: 0,
                seconds: 0, pointsAllowed: 0,
                defFgm: 0, defFga: 0, defFg3m: 0, defFg3a: 0,
                defFtm: 0, defFta: 0, defOrebAllowed: 0, defTovForced: 0
            };
        }
        
        // Finalize current scoring run and check for significant runs
        finalizeCurrentRun(currentElapsed, currentTeamName, currentTeamIdx, currentLineupKey) {
            const run = this.currentScoringRun;
            if (!run.lastScoringTeam === null || run.consecutivePoints < 6) return;
            
            const duration = run.endElapsed - run.startElapsed;
            const durationStr = this.formatDuration(duration);
            
            // Check for player runs (6+ points by single player)
            for (const [playerNum, playerPoints] of Object.entries(run.scoringPlayers)) {
                if (playerPoints >= 6) {
                    // Get player name from roster
                    const playerName = this.getPlayerNameFromNum(run.teamName, playerNum);
                    this.playerRuns.push({
                        player: playerNum,
                        playerName: playerName,
                        team: run.teamName,
                        teamIdx: run.lastScoringTeam,
                        points: playerPoints,
                        startElapsed: run.startElapsed,
                        endElapsed: run.endElapsed,
                        duration: durationStr,
                        startScore: `${run.startHomeScore}-${run.startAwayScore}`,
                        endScore: `${run.endHomeScore}-${run.endAwayScore}`
                    });
                }
            }
            
            // Check for team momentum runs (6+ points with same lineup)
            if (run.consecutivePoints >= 6) {
                // Get lineup player names
                const lineupNames = this.getLineupNames(run.currentLineup);
                
                // Find top scorer in this run
                let topScorer = null;
                let topPoints = 0;
                for (const [playerNum, playerPoints] of Object.entries(run.scoringPlayers)) {
                    if (playerPoints > topPoints) {
                        topPoints = playerPoints;
                        topScorer = this.getPlayerNameFromNum(run.teamName, playerNum);
                    }
                }
                
                const scoreDiff = run.lastScoringTeam === 0 
                    ? `${run.consecutivePoints}-0`
                    : `0-${run.consecutivePoints}`;
                
                this.teamMomentumRuns.push({
                    team: run.teamName,
                    teamIdx: run.lastScoringTeam,
                    points: run.consecutivePoints,
                    lineup: run.currentLineup,
                    lineupNames: lineupNames,
                    startElapsed: run.startElapsed,
                    endElapsed: run.endElapsed,
                    duration: durationStr,
                    scoreDiff: scoreDiff,
                    topScorer: topScorer,
                    topScorerPoints: topPoints
                });
            }
        }
        
        formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}'${secs.toString().padStart(2, '0')}"`;
        }
        
        getPlayerNameFromNum(teamName, playerNum) {
            const normalizedNum = this.normalizeNumber(playerNum);
            let fullName = null;
            
            // Try to find player in teams roster data (from boxscore parsing)
            if (this.teams) {
                for (const team of Object.values(this.teams)) {
                    if (team.name === teamName && team.roster) {
                        const name = team.roster[normalizedNum];
                        if (name) {
                            fullName = name;
                            break;
                        }
                    }
                }
            }
            
            // Try to find player in boxscore data
            if (!fullName && this.boxscoreData) {
                for (const team of Object.values(this.boxscoreData)) {
                    if (team.name === teamName && team.players) {
                        for (const player of team.players) {
                            if (this.normalizeNumber(player.number) === normalizedNum) {
                                fullName = player.name;
                                break;
                            }
                        }
                    }
                    if (fullName) break;
                }
            }
            
            // Try playerRoster
            if (!fullName && this.playerRoster && this.playerRoster[`${teamName}|${normalizedNum}`]) {
                fullName = this.playerRoster[`${teamName}|${normalizedNum}`];
            }
            
            if (!fullName) return `#${playerNum}`;
            
            // Extract display name with suffix handling
            return this.extractDisplayName(fullName);
        }
        
        extractDisplayName(fullName) {
            // Suffixes to check for (case-insensitive)
            const suffixes = ['Jr.', 'Jr', 'III', 'II', 'IV', 'V', 'VI', 'VII', 'VIII', 'Sr.', 'Sr'];
            
            const parts = fullName.trim().split(/\s+/);
            if (parts.length === 0) return fullName.toUpperCase();
            if (parts.length === 1) return parts[0].toUpperCase();
            
            const lastPart = parts[parts.length - 1];
            
            // Check if last part is a suffix
            const isSuffix = suffixes.some(s => 
                lastPart.toLowerCase() === s.toLowerCase() || 
                lastPart.toLowerCase().replace('.', '') === s.toLowerCase().replace('.', '')
            );
            
            if (isSuffix && parts.length >= 2) {
                // Return the part before the suffix + the suffix
                // e.g., "Ron Polite III" -> "POLITE III"
                const nameBeforeSuffix = parts[parts.length - 2];
                return `${nameBeforeSuffix.toUpperCase()} ${lastPart.toUpperCase()}`;
            }
            
            // No suffix, just return last name
            return lastPart.toUpperCase();
        }
        
        getLineupNames(lineupKey, fullNames = false) {
            if (!lineupKey) return '';
            const parts = lineupKey.split('|');
            if (parts.length < 2) return '';
            
            const teamName = parts[0];
            const playerNums = parts[1].split(',');
            const names = [];
            
            for (const num of playerNums) {
                if (fullNames) {
                    // Get full name for tooltip display
                    const fullName = this.getFullPlayerName(teamName, num);
                    names.push(fullName);
                } else {
                    // Get display name (last name + suffix)
                    const name = this.getPlayerNameFromNum(teamName, num);
                    names.push(name);
                }
            }
            
            return names.join(', ');
        }
        
        getFullPlayerName(teamName, playerNum) {
            const normalizedNum = this.normalizeNumber(playerNum);
            
            // Try teams roster
            if (this.teams) {
                for (const team of Object.values(this.teams)) {
                    if (team.name === teamName && team.roster) {
                        const name = team.roster[normalizedNum];
                        if (name) return name;
                    }
                }
            }
            
            // Try boxscore data
            if (this.boxscoreData) {
                for (const team of Object.values(this.boxscoreData)) {
                    if (team.name === teamName && team.players) {
                        for (const player of team.players) {
                            if (this.normalizeNumber(player.number) === normalizedNum) {
                                return player.name;
                            }
                        }
                    }
                }
            }
            
            // Try playerRoster
            if (this.playerRoster && this.playerRoster[`${teamName}|${normalizedNum}`]) {
                return this.playerRoster[`${teamName}|${normalizedNum}`];
            }
            
            return `#${playerNum}`;
        }

        // Initialize assist combinations tracking
        resetAssistCombinations() {
            this.assistCombinations = {}; // Key: "team|assister|scorer", Value: { count, points, threes, twos }
            this.lastScorer = null; // Track last scorer for assist pairing
            this.lastScorerTeam = null;
            this.lastScorerPoints = 0;
            this.lastScorerWasThree = false;
        }

        getLineupKey(teamIdx) {
            if (!(teamIdx in this.teams)) return `Team${teamIdx}|unknown`;
            const lineup = Array.from(this.currentLineups[teamIdx])
                .map(n => this.normalizeNumber(n))
                .filter(n => n !== null)
                .sort((a, b) => parseInt(a) - parseInt(b));
            const teamName = this.teams[teamIdx].name;
            return `${teamName}|${lineup.join(',')}`;
        }

        parsePeriodString(periodText) {
            if (!periodText) return this.currentPeriod;
            periodText = periodText.trim().toUpperCase();

            // Regular period: P1, P2, P3, P4 (FIBA format)
            if (periodText.startsWith('P') && /\d/.test(periodText[1])) {
                return parseInt(periodText.substring(1));
            }

            // Quarter format: Q1, Q2, Q3, Q4 (backward compatibility)
            if (periodText.startsWith('Q') && /\d/.test(periodText[1])) {
                return parseInt(periodText.substring(1));
            }

            // Overtime: OT, OT1, OT2
            if (periodText.includes('OT')) {
                const match = periodText.match(/OT\s*(\d+)/);
                if (match) return 4 + parseInt(match[1]);
                return 5; // Just "OT" = first overtime
            }

            return this.currentPeriod;
        }

        calculateElapsedTime(timeStr, period) {
            try {
                const parts = timeStr.split(':');
                if (parts.length !== 2) return this.lastTime;
                
                const minutes = parseInt(parts[0]);
                const seconds = parseInt(parts[1]);
                const remaining = minutes * 60 + seconds;
                
                if (period <= 4) {
                    // Regular periods: 10 minutes each
                    const periodDuration = 600;
                    const periodElapsed = periodDuration - remaining;
                    return (period - 1) * periodDuration + periodElapsed;
                } else {
                    // Overtime: 5 minutes each
                    const otPeriod = period - 4;
                    const periodDuration = 300;
                    const periodElapsed = periodDuration - remaining;
                    return 2400 + (otPeriod - 1) * periodDuration + periodElapsed;
                }
            } catch (e) {
                return this.lastTime;
            }
        }

        updateLineupTimes(currentElapsed) {
            if (this.lastTime !== null) {
                const delta = currentElapsed - this.lastTime;
                if (delta > 0) {
                    for (const teamIdx of [0, 1]) {
                        const lineupKey = this.getLineupKey(teamIdx);
                        if (!this.lineupStats[lineupKey]) {
                            this.lineupStats[lineupKey] = this.getDefaultLineupStats();
                        }
                        this.lineupStats[lineupKey].seconds += delta;
                    }
                }
            }
            this.lastTime = currentElapsed;
        }

        parsePBP(html, teamsData) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            const teamNames = Object.keys(teamsData);
            if (teamNames.length < 2) return null;
            
            const homeTeam = teamNames[0];
            const awayTeam = teamNames[1];
            
            // Initialize period-based stats tracking
            this.periodStats = {};
            this.teamPeriodTotals = {};
            this.playerPeriodOnCourtStats = {}; // Track on-court stats by period
            this.playerPeriodMinutes = {}; // Track minutes played per period
            this.playerOnCourtSince = {}; // Track when each player entered the court (elapsed seconds)
            
            for (const teamName of teamNames) {
                this.periodStats[teamName] = {};
                this.teamPeriodTotals[teamName] = {};
                this.playerPeriodOnCourtStats[teamName] = {};
                this.playerPeriodMinutes[teamName] = {};
                this.playerOnCourtSince[teamName] = {};
                
                for (let p = 1; p <= 6; p++) { // Support up to 2 OT periods
                    this.periodStats[teamName][p] = {};
                    this.teamPeriodTotals[teamName][p] = {
                        points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                        ftm: 0, fta: 0, oreb: 0, dreb: 0, ast: 0,
                        stl: 0, blk: 0, tov: 0, pf: 0,
                        // Shot zone tracking
                        rimAtt: 0, rimMade: 0,
                        midAtt: 0, midMade: 0,
                        // Assisted points tracking
                        assistedFgm: 0, assistedPoints: 0
                    };
                    this.playerPeriodOnCourtStats[teamName][p] = {};
                    this.playerPeriodMinutes[teamName][p] = {};
                }
            }
            
            // Initialize on-court stats for all players
            const playerOnCourtStats = {};
            const playerShotStats = {};
            
            for (const teamName of teamNames) {
                for (const player of teamsData[teamName].players) {
                    const key = `${teamName}|${player.number}`;
                    playerOnCourtStats[key] = {
                        teamPoints: 0, oppPoints: 0,
                        teamFGA: 0, teamFGM: 0, team3PA: 0, team3PM: 0,
                        teamFTA: 0, teamFTM: 0, teamOreb: 0, teamDreb: 0, teamTov: 0,
                        oppFGA: 0, oppFGM: 0, opp3PA: 0, opp3PM: 0,
                        oppFTA: 0, oppFTM: 0, oppOreb: 0, oppDreb: 0, oppTov: 0,
                        seconds: 0
                    };
                    playerShotStats[key] = {
                        rimAtt: 0, rimMade: 0,
                        midAtt: 0, midMade: 0,
                        threeAtt: 0, threeMade: 0
                    };
                }
            }
            
            // Initialize lineup stats for starting lineups
            for (const teamIdx of [0, 1]) {
                const lineupKey = this.getLineupKey(teamIdx);
                this.lineupStats[lineupKey] = this.getDefaultLineupStats();
            }
            
            const pbpContainer = doc.querySelector('#aj_pbp');
            if (!pbpContainer) {
                this.log('ERROR: PBP container not found');
                return playerOnCourtStats;
            }
            
            // Process actions in chronological order (reverse the DOM order)
            const actions = Array.from(pbpContainer.querySelectorAll('div.pbpa')).reverse();
            this.log(`Processing ${actions.length} PBP actions`);
            
            let processedCount = 0;
            let previousPeriod = 0;
            
            // Helper to initialize starters on court at period start
            const initializeStartersForPeriod = (period, elapsed) => {
                for (const teamIdx of [0, 1]) {
                    const teamName = teamIdx === 0 ? homeTeam : awayTeam;
                    for (const playerNum of this.currentLineups[teamIdx]) {
                        // Mark player as on court since period start
                        if (!this.playerOnCourtSince[teamName][playerNum]) {
                            this.playerOnCourtSince[teamName][playerNum] = {};
                        }
                        this.playerOnCourtSince[teamName][playerNum][period] = elapsed;
                    }
                }
            };
            
            // Helper to finalize minutes for all on-court players at period end
            const finalizeMinutesForPeriod = (period, periodEndElapsed) => {
                for (const teamIdx of [0, 1]) {
                    const teamName = teamIdx === 0 ? homeTeam : awayTeam;
                    for (const playerNum of this.currentLineups[teamIdx]) {
                        const entryTime = this.playerOnCourtSince[teamName]?.[playerNum]?.[period];
                        if (entryTime !== undefined) {
                            const secondsPlayed = periodEndElapsed - entryTime;
                            if (!this.playerPeriodMinutes[teamName][period][playerNum]) {
                                this.playerPeriodMinutes[teamName][period][playerNum] = 0;
                            }
                            this.playerPeriodMinutes[teamName][period][playerNum] += secondsPlayed;
                            // Clear the entry time
                            delete this.playerOnCourtSince[teamName][playerNum][period];
                        }
                    }
                }
            };
            
            for (const action of actions) {
                // Determine which team
                let teamIdx = null;
                const classes = action.className || '';
                if (classes.includes('pbp-team1') || classes.includes('pbpt1')) teamIdx = 0;
                else if (classes.includes('pbp-team2') || classes.includes('pbpt2')) teamIdx = 1;
                
                // Parse period
                const periodSpan = action.querySelector('.pbp-period') || action.querySelector('span.pbp-period');
                if (periodSpan) {
                    const newPeriod = this.parsePeriodString(periodSpan.textContent);
                    
                    // Detect period change
                    if (newPeriod !== previousPeriod) {
                        // Finalize minutes for previous period (if not first)
                        if (previousPeriod > 0) {
                            // Calculate period end time
                            const periodEndElapsed = previousPeriod <= 4 
                                ? previousPeriod * 600 
                                : 2400 + (previousPeriod - 4) * 300;
                            finalizeMinutesForPeriod(previousPeriod, periodEndElapsed);
                        }
                        
                        this.currentPeriod = newPeriod;
                        previousPeriod = newPeriod;
                        
                        // Initialize starters for new period
                        const periodStartElapsed = newPeriod <= 4 
                            ? (newPeriod - 1) * 600 
                            : 2400 + (newPeriod - 5) * 300;
                        initializeStartersForPeriod(newPeriod, periodStartElapsed);
                    }
                }
                
                // Parse time
                const timeDiv = action.querySelector('.pbp-time') || action.querySelector('div.pbp-time');
                let elapsed = this.lastTime;
                if (timeDiv) {
                    const timeText = timeDiv.textContent.trim();
                    const timeMatch = timeText.match(/(\d{1,2}):(\d{2})/);
                    if (timeMatch) {
                        const timeStr = `${timeMatch[1]}:${timeMatch[2]}`;
                        elapsed = this.calculateElapsedTime(timeStr, this.currentPeriod);
                        this.updateLineupTimes(elapsed);
                    }
                }
                
                // Get action description
                const actionDiv = action.querySelector('.pbp-action') || action.querySelector('div.pbp-action');
                if (!actionDiv) continue;
                
                const actionText = actionDiv.textContent.toLowerCase();
                
                // Extract player number from action
                let playerNum = null;
                const strongTag = actionDiv.querySelector('strong');
                if (strongTag) {
                    const text = strongTag.textContent.trim();
                    if (text.includes(',')) {
                        playerNum = this.normalizeNumber(text.split(',')[0].trim());
                    } else if (/^\d+$/.test(text.trim())) {
                        playerNum = this.normalizeNumber(text.trim());
                    }
                }
                
                // ============================================================
                // HANDLE SUBSTITUTIONS
                // ============================================================
                if (actionText.includes('substitution')) {
                    this.log(`SUB DETECTED: teamIdx=${teamIdx}, playerNum=${playerNum}, actionText="${actionText.substring(0, 50)}"`);
                    if (teamIdx !== null && playerNum) {
                        const teamName = teamIdx === 0 ? homeTeam : awayTeam;
                        const isSubIn = actionText.includes('substitution in');
                        const isSubOut = actionText.includes('substitution out');
                        this.log(`SUB PROCESSING: team=${teamName}, player=#${playerNum}, isSubIn=${isSubIn}, isSubOut=${isSubOut}`);

                        if (isSubOut) {
                            // Calculate minutes played for this period
                            const entryTime = this.playerOnCourtSince[teamName]?.[playerNum]?.[this.currentPeriod];
                            if (entryTime !== undefined) {
                                const secondsPlayed = elapsed - entryTime;
                                if (!this.playerPeriodMinutes[teamName][this.currentPeriod][playerNum]) {
                                    this.playerPeriodMinutes[teamName][this.currentPeriod][playerNum] = 0;
                                }
                                this.playerPeriodMinutes[teamName][this.currentPeriod][playerNum] += secondsPlayed;
                                // Clear the entry time
                                delete this.playerOnCourtSince[teamName][playerNum][this.currentPeriod];
                            }

                            // Remove player from lineup - try normalized form
                            const wasInLineup = this.currentLineups[teamIdx].has(playerNum);
                            this.currentLineups[teamIdx].delete(playerNum);

                            // Also remove any variant with leading zeros that might have been added incorrectly
                            for (const num of this.currentLineups[teamIdx]) {
                                if (this.normalizeNumber(num) === playerNum) {
                                    this.currentLineups[teamIdx].delete(num);
                                }
                            }

                            if (!wasInLineup) {
                                this.log(`WARNING: Sub out for #${playerNum} (${teamName}) but player not found in lineup. Current lineup: [${Array.from(this.currentLineups[teamIdx]).join(', ')}]`);
                            }
                        } else if (isSubIn) {
                            // Mark entry time for this period
                            if (!this.playerOnCourtSince[teamName][playerNum]) {
                                this.playerOnCourtSince[teamName][playerNum] = {};
                            }
                            this.playerOnCourtSince[teamName][playerNum][this.currentPeriod] = elapsed;

                            // Add player with normalized number
                            this.currentLineups[teamIdx].add(playerNum);
                        }

                        // Validate lineup size (should be 5 players)
                        if (this.currentLineups[teamIdx].size > 5) {
                            this.log(`WARNING: ${teamName} has ${this.currentLineups[teamIdx].size} players on court after sub: [${Array.from(this.currentLineups[teamIdx]).join(', ')}]`);
                        }

                        // Initialize new lineup stats
                        const newLineupKey = this.getLineupKey(teamIdx);
                        if (!this.lineupStats[newLineupKey]) {
                            this.lineupStats[newLineupKey] = this.getDefaultLineupStats();
                        }
                    }
                    continue;
                }
                
                // Skip non-stat events
                if (actionText.includes('timeout') || 
                    actionText.includes('jump ball') || 
                    actionText.includes('instant replay')) {
                    continue;
                }
                
                if (teamIdx === null) continue;
                
                const lineupKey = this.getLineupKey(teamIdx);
                const oppTeamIdx = 1 - teamIdx;
                const oppLineupKey = this.getLineupKey(oppTeamIdx);
                
                // Ensure lineup stats exist
                if (!this.lineupStats[lineupKey]) {
                    this.lineupStats[lineupKey] = this.getDefaultLineupStats();
                }
                if (!this.lineupStats[oppLineupKey]) {
                    this.lineupStats[oppLineupKey] = this.getDefaultLineupStats();
                }
                
                const scoringTeam = teamIdx === 0 ? homeTeam : awayTeam;
                const defendingTeam = teamIdx === 0 ? awayTeam : homeTeam;
                
                // ============================================================
                // SHOT DETECTION
                // ============================================================
                let points = 0;
                let isFGA = false, isFGM = false;
                let is3PA = false, is3PM = false;
                let isFTA = false, isFTM = false;
                
                const isMade = actionText.includes('made');
                const isMissed = actionText.includes('missed');
                
                // Shot type classification
                let isRimShot = false;
                let isMidRange = false;
                let isThree = false;
                
                // Check for 3-pointers
                if (actionText.includes('3pt')) {
                    isFGA = true;
                    is3PA = true;
                    isThree = true;
                    if (isMade) { points = 3; isFGM = true; is3PM = true; }
                }
                // Check for rim shots (layups, dunks, etc.)
                else if (actionText.includes('2pt') && 
                    (actionText.includes('lay up') || actionText.includes('layup') || 
                     actionText.includes('dunk') || actionText.includes('tip in') || 
                     actionText.includes('tipin') || actionText.includes('alley') ||
                     actionText.includes('driving') || actionText.includes('finger roll') ||
                     actionText.includes('hook') || actionText.includes('put back') ||
                     actionText.includes('reverse'))) {
                    isFGA = true;
                    isRimShot = true;
                    if (isMade) { points = 2; isFGM = true; }
                }
                // Mid-range shots
                else if (actionText.includes('2pt') || 
                         (actionText.includes('jump shot') && !actionText.includes('3pt')) ||
                         actionText.includes('jumper') || actionText.includes('fadeaway') ||
                         actionText.includes('pull up') || actionText.includes('step back') ||
                         actionText.includes('turn around')) {
                    isFGA = true;
                    if (actionText.includes('floater') || actionText.includes('runner')) {
                        isRimShot = true;
                    } else {
                        isMidRange = true;
                    }
                    if (isMade) { points = 2; isFGM = true; }
                }
                // Free throws
                else if (actionText.includes('free throw')) {
                    isFTA = true;
                    if (isMade) { points = 1; isFTM = true; }
                }
                
                // Update lineup stats for field goals
                if (isFGA) {
                    this.lineupStats[lineupKey].fga++;
                    this.lineupStats[oppLineupKey].defFga++;
                    if (isFGM) {
                        this.lineupStats[lineupKey].fgm++;
                        this.lineupStats[oppLineupKey].defFgm++;
                    }
                    if (is3PA) {
                        this.lineupStats[lineupKey].fg3a++;
                        this.lineupStats[oppLineupKey].defFg3a++;
                        if (is3PM) {
                            this.lineupStats[lineupKey].fg3m++;
                            this.lineupStats[oppLineupKey].defFg3m++;
                        }
                    }
                }
                
                // Update lineup stats for free throws
                if (isFTA) {
                    this.lineupStats[lineupKey].fta++;
                    this.lineupStats[oppLineupKey].defFta++;
                    if (isFTM) {
                        this.lineupStats[lineupKey].ftm++;
                        this.lineupStats[oppLineupKey].defFtm++;
                    }
                }
                
                // Update points
                if (points > 0) {
                    this.lineupStats[lineupKey].points += points;
                    this.lineupStats[oppLineupKey].pointsAllowed += points;
                    
                    // Track last scorer for assist pairing (only for field goals, not FTs)
                    if (isFGM && playerNum) {
                        this.lastScorer = playerNum;
                        this.lastScorerTeam = scoringTeam;
                        this.lastScorerPoints = points;
                        this.lastScorerWasThree = is3PM;
                    }
                }
                
                // ============================================================
                // GAME FLOW DATA TRACKING (for PPP Development chart)
                // ============================================================
                const teamKey = teamIdx === 0 ? 'home' : 'away';
                
                // Update running stats for FGA
                if (isFGA) {
                    this.runningStats[teamKey].fga++;
                    if (isFGM) {
                        this.runningStats[teamKey].fgm++;
                    }
                    if (is3PA) {
                        this.runningStats[teamKey].fg3a++;
                        if (is3PM) {
                            this.runningStats[teamKey].fg3m++;
                        }
                    }
                }
                
                // Update running stats for FTA
                if (isFTA) {
                    this.runningStats[teamKey].fta++;
                    if (isFTM) {
                        this.runningStats[teamKey].ftm++;
                    }
                }
                
                // Update running stats for points
                if (points > 0) {
                    this.runningStats[teamKey].points += points;
                }
                
                // ============================================================
                // PLAYER RUNS & TEAM MOMENTUM TRACKING
                // ============================================================
                if (points > 0 && playerNum) {
                    const currentHomeScore = this.runningStats.home.points;
                    const currentAwayScore = this.runningStats.away.points;
                    
                    // Check if same team is scoring consecutively
                    if (this.currentScoringRun.lastScoringTeam === teamIdx) {
                        // Same team continues scoring
                        this.currentScoringRun.consecutivePoints += points;
                        
                        // Track player contributions in this run
                        if (!this.currentScoringRun.scoringPlayers[playerNum]) {
                            this.currentScoringRun.scoringPlayers[playerNum] = 0;
                        }
                        this.currentScoringRun.scoringPlayers[playerNum] += points;
                    } else {
                        // Team changed - finalize previous run if significant
                        this.finalizeCurrentRun(elapsed, scoringTeam, teamIdx, lineupKey);
                        
                        // Start new run
                        this.currentScoringRun = {
                            lastScoringTeam: teamIdx,
                            consecutivePoints: points,
                            scoringPlayers: { [playerNum]: points },
                            startElapsed: elapsed,
                            startHomeScore: currentHomeScore - (teamIdx === 0 ? points : 0),
                            startAwayScore: currentAwayScore - (teamIdx === 1 ? points : 0),
                            currentLineup: lineupKey,
                            teamName: scoringTeam
                        };
                    }
                    
                    // Update end time for the run
                    this.currentScoringRun.endElapsed = elapsed;
                    this.currentScoringRun.endHomeScore = currentHomeScore;
                    this.currentScoringRun.endAwayScore = currentAwayScore;
                }
                
                // Track turnovers for running stats (handled below in turnover section)
                // Track offensive rebounds (handled below in rebound section)
                
                // Record game flow data point after scoring events or possession-ending events
                if (points > 0 || isFGA || actionText.includes('turnover')) {
                    const homePoss = 0.96 * (this.runningStats.home.fga + this.runningStats.home.tov + 
                        0.44 * this.runningStats.home.fta - this.runningStats.home.oreb);
                    const awayPoss = 0.96 * (this.runningStats.away.fga + this.runningStats.away.tov + 
                        0.44 * this.runningStats.away.fta - this.runningStats.away.oreb);
                    
                    const homePPP = homePoss > 0 ? this.runningStats.home.points / homePoss : 0;
                    const awayPPP = awayPoss > 0 ? this.runningStats.away.points / awayPoss : 0;
                    
                    // Calculate EPA from TO margin and OREB margin
                    // TO margin: fewer home TOs = home advantage (awayTov - homeTov)
                    // OREB margin: more home OREBs = home advantage (homeOreb - awayOreb)
                    const toMargin = this.runningStats.away.tov - this.runningStats.home.tov;
                    const orebMargin = this.runningStats.home.oreb - this.runningStats.away.oreb;
                    const epa = (toMargin + orebMargin) * 1.05;
                    
                    // Calculate Scoring Battle from eFG% and FT Rate margins
                    // eFG% = (FGM + 0.5 * FG3M) / FGA
                    const homeEfg = this.runningStats.home.fga > 0 ? 
                        ((this.runningStats.home.fgm + 0.5 * this.runningStats.home.fg3m) / this.runningStats.home.fga * 100) : 0;
                    const awayEfg = this.runningStats.away.fga > 0 ? 
                        ((this.runningStats.away.fgm + 0.5 * this.runningStats.away.fg3m) / this.runningStats.away.fga * 100) : 0;
                    const efgMargin = homeEfg - awayEfg;
                    
                    // FT Rate = FTM / FGA (as percentage)
                    const homeFtRate = this.runningStats.home.fga > 0 ? 
                        (this.runningStats.home.ftm / this.runningStats.home.fga * 100) : 0;
                    const awayFtRate = this.runningStats.away.fga > 0 ? 
                        (this.runningStats.away.ftm / this.runningStats.away.fga * 100) : 0;
                    const ftRateMargin = homeFtRate - awayFtRate;
                    
                    // Scoring Battle = (eFG% margin × 1.77) + (FT Rate margin × 0.25)
                    // Scale by pace estimate (use current possessions as proxy)
                    const avgPoss = (homePoss + awayPoss) / 2;
                    const gamePace = avgPoss > 0 ? (avgPoss / (elapsed / 2400)) : 75; // Estimate pace
                    const scoringBattle = ((efgMargin * 1.77) + (ftRateMargin * 0.25)) * (gamePace / 100);
                    
                    this.gameFlowData.push({
                        elapsed: elapsed,
                        period: this.currentPeriod,
                        homePoints: this.runningStats.home.points,
                        awayPoints: this.runningStats.away.points,
                        margin: this.runningStats.home.points - this.runningStats.away.points,
                        homePoss: homePoss,
                        awayPoss: awayPoss,
                        possMargin: homePoss - awayPoss,
                        homePPP: homePPP,
                        awayPPP: awayPPP,
                        // EPA tracking
                        homeTov: this.runningStats.home.tov,
                        awayTov: this.runningStats.away.tov,
                        homeOreb: this.runningStats.home.oreb,
                        awayOreb: this.runningStats.away.oreb,
                        toMargin: toMargin,
                        orebMargin: orebMargin,
                        epa: epa,
                        // Scoring Battle tracking
                        homeEfg: homeEfg,
                        awayEfg: awayEfg,
                        efgMargin: efgMargin,
                        homeFtRate: homeFtRate,
                        awayFtRate: awayFtRate,
                        ftRateMargin: ftRateMargin,
                        scoringBattle: scoringBattle
                    });
                }
                
                // Update player shot stats
                if (playerNum && isFGA) {
                    const playerKey = `${scoringTeam}|${playerNum}`;
                    if (playerShotStats[playerKey]) {
                        if (isRimShot) {
                            playerShotStats[playerKey].rimAtt++;
                            if (isFGM) playerShotStats[playerKey].rimMade++;
                        } else if (isMidRange) {
                            playerShotStats[playerKey].midAtt++;
                            if (isFGM) playerShotStats[playerKey].midMade++;
                        } else if (isThree) {
                            playerShotStats[playerKey].threeAtt++;
                            if (is3PM) playerShotStats[playerKey].threeMade++;
                        }
                    }
                }
                
                // ============================================================
                // PERIOD-BASED STAT TRACKING
                // ============================================================
                
                // Track max period for OT detection
                if (this.currentPeriod > this.maxPeriod) {
                    this.maxPeriod = this.currentPeriod;
                }
                
                // Ensure period stats exist for this player
                if (playerNum && this.periodStats[scoringTeam]) {
                    if (!this.periodStats[scoringTeam][this.currentPeriod][playerNum]) {
                        this.periodStats[scoringTeam][this.currentPeriod][playerNum] = {
                            minutes: 0, points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                            ftm: 0, fta: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, pf: 0,
                            rimAtt: 0, rimMade: 0, midAtt: 0, midMade: 0
                        };
                    }
                    
                    const pStats = this.periodStats[scoringTeam][this.currentPeriod][playerNum];
                    const tStats = this.teamPeriodTotals[scoringTeam][this.currentPeriod];
                    
                    // Update period stats based on action
                    if (isFGA) {
                        pStats.fga++;
                        tStats.fga++;
                        if (isFGM) {
                            pStats.fgm++;
                            tStats.fgm++;
                        }
                        if (is3PA) {
                            pStats.fg3a++;
                            tStats.fg3a++;
                            if (is3PM) {
                                pStats.fg3m++;
                                tStats.fg3m++;
                            }
                        }
                        if (isRimShot) {
                            pStats.rimAtt++;
                            tStats.rimAtt++;
                            if (isFGM) {
                                pStats.rimMade++;
                                tStats.rimMade++;
                            }
                        } else if (isMidRange) {
                            pStats.midAtt++;
                            tStats.midAtt++;
                            if (isFGM) {
                                pStats.midMade++;
                                tStats.midMade++;
                            }
                        }
                    }
                    
                    if (isFTA) {
                        pStats.fta++;
                        tStats.fta++;
                        if (isFTM) {
                            pStats.ftm++;
                            tStats.ftm++;
                        }
                    }
                    
                    if (points > 0) {
                        pStats.points += points;
                        tStats.points += points;
                    }
                }
                
                // ============================================================
                // OTHER STATS
                // ============================================================
                
                // Rebounds
                if (actionText.includes('offensive rebound')) {
                    this.lineupStats[lineupKey].oreb++;
                    this.lineupStats[oppLineupKey].defOrebAllowed++;
                    
                    // Track offensive rebound for game flow
                    const orebTeamKey = teamIdx === 0 ? 'home' : 'away';
                    this.runningStats[orebTeamKey].oreb++;
                    
                    // Period tracking
                    if (playerNum && this.periodStats[scoringTeam] && this.periodStats[scoringTeam][this.currentPeriod][playerNum]) {
                        this.periodStats[scoringTeam][this.currentPeriod][playerNum].oreb++;
                        this.teamPeriodTotals[scoringTeam][this.currentPeriod].oreb++;
                    }
                } else if (actionText.includes('defensive rebound')) {
                    this.lineupStats[lineupKey].dreb++;
                    // Period tracking
                    if (playerNum && this.periodStats[scoringTeam] && this.periodStats[scoringTeam][this.currentPeriod][playerNum]) {
                        this.periodStats[scoringTeam][this.currentPeriod][playerNum].dreb++;
                        this.teamPeriodTotals[scoringTeam][this.currentPeriod].dreb++;
                    }
                }
                
                // Assists - use data attributes (from JSON) or fall back to lastScorer tracking
                if (actionText.includes('assist') && !actionText.includes('assisted')) {
                    this.lineupStats[lineupKey].ast++;

                    // Period tracking
                    if (playerNum && this.periodStats[scoringTeam] && this.periodStats[scoringTeam][this.currentPeriod][playerNum]) {
                        this.periodStats[scoringTeam][this.currentPeriod][playerNum].ast++;
                        this.teamPeriodTotals[scoringTeam][this.currentPeriod].ast++;
                    }

                    // Get scorer info - priority: data attributes (JSON), then lastScorer (HTML)
                    // Data attributes are set by generatePbpHtmlFromJson for JSON-sourced data
                    let scorerNum = null;
                    let scorerPoints = 0;
                    let wasThree = false;

                    const dataScorer = action.getAttribute('data-scorer-num');
                    const dataPoints = action.getAttribute('data-scorer-points');
                    const dataThree = action.getAttribute('data-scorer-three');

                    if (dataScorer) {
                        // Use data attributes (most reliable - directly from JSON)
                        scorerNum = this.normalizeNumber(dataScorer);
                        scorerPoints = parseInt(dataPoints) || 0;
                        wasThree = dataThree === 'true';
                    } else if (this.lastScorer && this.lastScorerTeam === scoringTeam) {
                        // Fall back to lastScorer tracking (for native HTML files)
                        scorerNum = this.lastScorer;
                        scorerPoints = this.lastScorerPoints || 0;
                        wasThree = this.lastScorerWasThree || false;
                    }

                    // Track assisted FGMs and points for team period totals
                    if (scorerNum && this.teamPeriodTotals[scoringTeam]) {
                        this.teamPeriodTotals[scoringTeam][this.currentPeriod].assistedFgm++;
                        this.teamPeriodTotals[scoringTeam][this.currentPeriod].assistedPoints += scorerPoints;
                    }

                    // Track assist combination
                    if (playerNum && scorerNum) {
                        const comboKey = `${scoringTeam}|${playerNum}|${scorerNum}`;
                        if (!this.assistCombinations[comboKey]) {
                            this.assistCombinations[comboKey] = {
                                count: 0,
                                points: 0,
                                threes: 0,
                                twos: 0,
                                team: scoringTeam,
                                assister: playerNum,
                                scorer: scorerNum
                            };
                        }
                        this.assistCombinations[comboKey].count++;
                        this.assistCombinations[comboKey].points += scorerPoints;
                        if (wasThree) {
                            this.assistCombinations[comboKey].threes++;
                        } else {
                            this.assistCombinations[comboKey].twos++;
                        }
                    }

                    // Clear last scorer after assist is recorded
                    this.lastScorer = null;
                    this.lastScorerTeam = null;
                }
                
                // Steals
                if (actionText.includes('steal')) {
                    this.lineupStats[lineupKey].stl++;
                    // Period tracking
                    if (playerNum && this.periodStats[scoringTeam] && this.periodStats[scoringTeam][this.currentPeriod][playerNum]) {
                        this.periodStats[scoringTeam][this.currentPeriod][playerNum].stl++;
                        this.teamPeriodTotals[scoringTeam][this.currentPeriod].stl++;
                    }
                }
                
                // Blocks
                if (/\bblock\b/.test(actionText)) {
                    this.lineupStats[lineupKey].blk++;
                    // Period tracking
                    if (playerNum && this.periodStats[scoringTeam] && this.periodStats[scoringTeam][this.currentPeriod][playerNum]) {
                        this.periodStats[scoringTeam][this.currentPeriod][playerNum].blk++;
                        this.teamPeriodTotals[scoringTeam][this.currentPeriod].blk++;
                    }
                }
                
                // Turnovers
                if (actionText.includes('turnover')) {
                    this.lineupStats[lineupKey].tov++;
                    this.lineupStats[oppLineupKey].defTovForced++;
                    
                    // Track turnover for game flow
                    const tovTeamKey = teamIdx === 0 ? 'home' : 'away';
                    this.runningStats[tovTeamKey].tov++;
                    
                    // Period tracking
                    if (playerNum && this.periodStats[scoringTeam] && this.periodStats[scoringTeam][this.currentPeriod][playerNum]) {
                        this.periodStats[scoringTeam][this.currentPeriod][playerNum].tov++;
                        this.teamPeriodTotals[scoringTeam][this.currentPeriod].tov++;
                    }
                }
                
                // Fouls
                if (actionText.includes('foul') && 
                    !actionText.includes('foul drawn') && 
                    !actionText.includes('fouled by') &&
                    !actionText.includes('foul on') &&
                    !actionText.includes('free throw')) {
                    this.lineupStats[lineupKey].pf++;
                }
                
                // Update on-court stats for players
                const scoringLineup = this.currentLineups[teamIdx];
                const defendingLineup = this.currentLineups[oppTeamIdx];
                const currentPd = this.currentPeriod;
                
                for (const num of scoringLineup) {
                    const key = `${scoringTeam}|${num}`;
                    if (playerOnCourtStats[key]) {
                        const stats = playerOnCourtStats[key];
                        stats.teamPoints += points;
                        if (isFGA) stats.teamFGA++;
                        if (isFGM) stats.teamFGM++;
                        if (is3PA) stats.team3PA++;
                        if (is3PM) stats.team3PM++;
                        if (isFTA) stats.teamFTA++;
                        if (isFTM) stats.teamFTM++;
                        if (actionText.includes('offensive rebound')) stats.teamOreb++;
                        if (actionText.includes('defensive rebound')) stats.teamDreb++;
                        if (actionText.includes('turnover')) stats.teamTov++;
                    }
                    
                    // Period-based on-court stats
                    if (this.playerPeriodOnCourtStats[scoringTeam] && this.playerPeriodOnCourtStats[scoringTeam][currentPd]) {
                        if (!this.playerPeriodOnCourtStats[scoringTeam][currentPd][num]) {
                            this.playerPeriodOnCourtStats[scoringTeam][currentPd][num] = {
                                teamPoints: 0, oppPoints: 0,
                                teamFGA: 0, teamFGM: 0, team3PA: 0, team3PM: 0,
                                teamFTA: 0, teamFTM: 0, teamOreb: 0, teamDreb: 0, teamTov: 0,
                                oppFGA: 0, oppFGM: 0, opp3PA: 0, opp3PM: 0,
                                oppFTA: 0, oppFTM: 0, oppOreb: 0, oppDreb: 0, oppTov: 0,
                                seconds: 0
                            };
                        }
                        const pStats = this.playerPeriodOnCourtStats[scoringTeam][currentPd][num];
                        pStats.teamPoints += points;
                        if (isFGA) pStats.teamFGA++;
                        if (isFGM) pStats.teamFGM++;
                        if (is3PA) pStats.team3PA++;
                        if (is3PM) pStats.team3PM++;
                        if (isFTA) pStats.teamFTA++;
                        if (isFTM) pStats.teamFTM++;
                        if (actionText.includes('offensive rebound')) pStats.teamOreb++;
                        if (actionText.includes('defensive rebound')) pStats.teamDreb++;
                        if (actionText.includes('turnover')) pStats.teamTov++;
                    }
                }
                
                for (const num of defendingLineup) {
                    const key = `${defendingTeam}|${num}`;
                    if (playerOnCourtStats[key]) {
                        const stats = playerOnCourtStats[key];
                        stats.oppPoints += points;
                        if (isFGA) stats.oppFGA++;
                        if (isFGM) stats.oppFGM++;
                        if (is3PA) stats.opp3PA++;
                        if (is3PM) stats.opp3PM++;
                        if (isFTA) stats.oppFTA++;
                        if (isFTM) stats.oppFTM++;
                        if (actionText.includes('offensive rebound')) stats.oppOreb++;
                        if (actionText.includes('defensive rebound')) stats.oppDreb++;
                        if (actionText.includes('turnover')) stats.oppTov++;
                    }
                    
                    // Period-based on-court stats for defending players
                    if (this.playerPeriodOnCourtStats[defendingTeam] && this.playerPeriodOnCourtStats[defendingTeam][currentPd]) {
                        if (!this.playerPeriodOnCourtStats[defendingTeam][currentPd][num]) {
                            this.playerPeriodOnCourtStats[defendingTeam][currentPd][num] = {
                                teamPoints: 0, oppPoints: 0,
                                teamFGA: 0, teamFGM: 0, team3PA: 0, team3PM: 0,
                                teamFTA: 0, teamFTM: 0, teamOreb: 0, teamDreb: 0, teamTov: 0,
                                oppFGA: 0, oppFGM: 0, opp3PA: 0, opp3PM: 0,
                                oppFTA: 0, oppFTM: 0, oppOreb: 0, oppDreb: 0, oppTov: 0,
                                seconds: 0
                            };
                        }
                        const pStats = this.playerPeriodOnCourtStats[defendingTeam][currentPd][num];
                        pStats.oppPoints += points;
                        if (isFGA) pStats.oppFGA++;
                        if (isFGM) pStats.oppFGM++;
                        if (is3PA) pStats.opp3PA++;
                        if (is3PM) pStats.opp3PM++;
                        if (isFTA) pStats.oppFTA++;
                        if (isFTM) pStats.oppFTM++;
                        if (actionText.includes('offensive rebound')) pStats.oppOreb++;
                        if (actionText.includes('defensive rebound')) pStats.oppDreb++;
                        if (actionText.includes('turnover')) pStats.oppTov++;
                    }
                }
                
                processedCount++;
            }
            
            // Finalize minutes for the last period (game end)
            if (previousPeriod > 0) {
                const periodEndElapsed = previousPeriod <= 4 
                    ? previousPeriod * 600 
                    : 2400 + (previousPeriod - 4) * 300;
                finalizeMinutesForPeriod(previousPeriod, periodEndElapsed);
            }
            
            // Finalize any remaining scoring run
            if (this.currentScoringRun && this.currentScoringRun.consecutivePoints >= 6) {
                this.finalizeCurrentRun(this.currentScoringRun.endElapsed || 0, null, null, null);
            }
            
            this.log(`Processed ${processedCount} stat events`);
            this.log(`Player Runs detected: ${this.playerRuns.length}`);
            this.log(`Team Momentum Runs detected: ${this.teamMomentumRuns.length}`);
            this.log(`Generated ${Object.keys(this.lineupStats).length} lineup combinations`);
            
            // Merge shot stats into player data
            for (const teamName of teamNames) {
                for (const player of teamsData[teamName].players) {
                    const key = `${teamName}|${player.number}`;
                    if (playerShotStats[key]) {
                        player.rimAtt = playerShotStats[key].rimAtt;
                        player.rimMade = playerShotStats[key].rimMade;
                        player.midAtt = playerShotStats[key].midAtt;
                        player.midMade = playerShotStats[key].midMade;
                    }
                }
            }
            
            return playerOnCourtStats;
        }

        // ========================================================================
        // ADVANCED METRICS
        // ========================================================================

        calculateAdvancedMetrics(teamsData, onCourtStats) {
            const teamNames = Object.keys(teamsData);
            if (teamNames.length < 2) return { teamsData, pace: 0 };
            
            for (const teamName of teamNames) {
                const team = teamsData[teamName];
                const totals = team.teamTotals;
                const oppTeam = teamNames.find(t => t !== teamName);
                const oppTotals = teamsData[oppTeam].teamTotals;
                
                // Aggregate rim stats from players
                totals.rimAtt = team.players.reduce((sum, p) => sum + (p.rimAtt || 0), 0);
                totals.rimMade = team.players.reduce((sum, p) => sum + (p.rimMade || 0), 0);
                
                totals.possessions = 0.96 * (totals.fga + totals.tov + 0.44 * totals.fta - totals.oreb);
                totals.efg = totals.fga > 0 ? ((totals.fgm + 0.5 * totals.fg3m) / totals.fga * 100) : 0;
                const tsa = totals.fga + 0.44 * totals.fta;
                totals.ts = tsa > 0 ? (totals.points / (2 * tsa) * 100) : 0;
                const orebOpps = totals.oreb + oppTotals.dreb;
                totals.orebPct = orebOpps > 0 ? (totals.oreb / orebOpps * 100) : 0;
                const tovDenom = totals.fga + 0.44 * totals.fta + totals.tov;
                totals.tovPct = tovDenom > 0 ? (totals.tov / tovDenom * 100) : 0;
                totals.ftaRate = totals.fga > 0 ? (totals.fta / totals.fga * 100) : 0;
                totals.astToRatio = totals.tov > 0 ? (totals.ast / totals.tov) : totals.ast;
                const totalRebs = totals.oreb + totals.dreb + oppTotals.oreb + oppTotals.dreb;
                totals.rebPct = totalRebs > 0 ? ((totals.oreb + totals.dreb) / totalRebs * 100) : 0;
                totals.ortg = totals.possessions > 0 ? (totals.points / totals.possessions * 100) : 0;
            }
            
            const homeTotal = teamsData[teamNames[0]].teamTotals;
            const awayTotal = teamsData[teamNames[1]].teamTotals;
            const gamePoss = (homeTotal.possessions + awayTotal.possessions) / 2;
            const totalMins = (homeTotal.minutes || 200) / 5;
            const pace = totalMins > 0 ? (gamePoss / totalMins * 40) : 0;
            
            // Player metrics
            for (const teamName of teamNames) {
                const team = teamsData[teamName];
                const oppTeamName = teamNames.find(t => t !== teamName);
                const oppTotals = teamsData[oppTeamName].teamTotals;
                
                for (const player of team.players) {
                    if (player.minutes <= 0) continue;
                    
                    // Get team and opponent totals for calculations
                    const teamTotals = team.teamTotals;
                    const teamMins = teamTotals.minutes || 200; // Total team minutes (5 players * game minutes)
                    const gameMinutes = teamMins / 5; // Single player equivalent (e.g., 40 for regulation)
                    const pMin = Math.max(player.minutes, 0.1); // Player minutes with minimum
                    
                    // Opponent possession estimate for STL%, BLK%
                    const oppPoss = Math.max(1, oppTotals.fga + 0.44 * oppTotals.fta - oppTotals.oreb + oppTotals.tov);
                    const opp2pa = Math.max(1, oppTotals.fga - oppTotals.fg3a);
                    
                    // ========================================
                    // BASKETBALL REFERENCE INDIVIDUAL STATS
                    // https://www.basketball-reference.com/about/glossary.html
                    // ========================================
                    
                    // eFG% (Effective Field Goal Percentage)
                    // Formula: (FGM + 0.5 * 3PM) / FGA
                    player.efg = player.fga > 0 ? ((player.fgm + 0.5 * player.fg3m) / player.fga * 100) : 0;
                    
                    // TS% (True Shooting Percentage)
                    // Formula: PTS / (2 * TSA) where TSA = FGA + 0.44 * FTA
                    const playerTSA = player.fga + 0.44 * player.fta;
                    player.ts = playerTSA > 0 ? (player.points / (2 * playerTSA) * 100) : 0;
                    
                    // USG% (Usage Rate)
                    // Formula: 100 * ((FGA + 0.44 * FTA + TOV) * (Tm MP / 5)) / (MP * (Tm FGA + 0.44 * Tm FTA + Tm TOV))
                    const playerPoss = player.fga + 0.44 * player.fta + player.tov;
                    const teamPoss = teamTotals.fga + 0.44 * teamTotals.fta + teamTotals.tov;
                    player.usg = (pMin > 0 && teamPoss > 0) ?
                        (100 * (playerPoss * gameMinutes) / (pMin * teamPoss)) : 0;
                    
                    // AST% (Assist Percentage)
                    // Formula: 100 * AST / (((MP / (Tm MP / 5)) * Tm FGM) - FGM)
                    // Estimates % of teammate FG assisted while player on floor
                    const estTeamFgmWhileOnFloor = (pMin / gameMinutes) * teamTotals.fgm;
                    const teammatesFgm = estTeamFgmWhileOnFloor - player.fgm;
                    player.astPct = teammatesFgm > 0 ? (100 * player.ast / teammatesFgm) : 0;
                    
                    // TOV% (Turnover Percentage)
                    // Formula: 100 * TOV / (FGA + 0.44 * FTA + TOV)
                    const playerTovDenom = player.fga + 0.44 * player.fta + player.tov;
                    player.tovPct = playerTovDenom > 0 ? (100 * player.tov / playerTovDenom) : 0;
                    
                    // FTr (Free Throw Rate)
                    // Formula: FTA / FGA
                    player.ftRate = player.fga > 0 ? (player.fta / player.fga * 100) : 0;
                    
                    // STL% (Steal Percentage)
                    // Formula: 100 * (STL * (Tm MP / 5)) / (MP * Opp Poss)
                    player.stlPct = (pMin > 0 && oppPoss > 0) ?
                        (100 * (player.stl * gameMinutes) / (pMin * oppPoss)) : 0;
                    
                    // BLK% (Block Percentage)
                    // Formula: 100 * (BLK * (Tm MP / 5)) / (MP * (Opp FGA - Opp 3PA))
                    player.blkPct = (pMin > 0 && opp2pa > 0) ?
                        (100 * (player.blk * gameMinutes) / (pMin * opp2pa)) : 0;
                    
                    // ORB% (Offensive Rebound Percentage)
                    // Formula: 100 * (ORB * (Tm MP / 5)) / (MP * (Tm ORB + Opp DRB))
                    const orebOpportunities = teamTotals.oreb + oppTotals.dreb;
                    player.orebPct = (pMin > 0 && orebOpportunities > 0) ?
                        (100 * (player.oreb * gameMinutes) / (pMin * orebOpportunities)) : 0;
                    
                    // DRB% (Defensive Rebound Percentage)
                    // Formula: 100 * (DRB * (Tm MP / 5)) / (MP * (Tm DRB + Opp ORB))
                    const drebOpportunities = teamTotals.dreb + oppTotals.oreb;
                    player.drebPct = (pMin > 0 && drebOpportunities > 0) ?
                        (100 * (player.dreb * gameMinutes) / (pMin * drebOpportunities)) : 0;
                    
                    // TRB% (Total Rebound Percentage)
                    // Formula: 100 * (TRB * (Tm MP / 5)) / (MP * (Tm TRB + Opp TRB))
                    const totalRebOpps = teamTotals.oreb + teamTotals.dreb + oppTotals.oreb + oppTotals.dreb;
                    player.rebPct = (pMin > 0 && totalRebOpps > 0) ?
                        (100 * ((player.oreb + player.dreb) * gameMinutes) / (pMin * totalRebOpps)) : 0;
                    
                    // AST/USG Ratio - playmaking efficiency
                    player.astUsgRatio = player.usg > 0 ? (player.astPct / player.usg) : 0;
                    
                    // PPP (Points Per Possession used)
                    // Formula: PTS / (FGA + 0.44*FTA + TOV)
                    const playerPossUsed = player.fga + 0.44 * player.fta + player.tov;
                    player.ppp = playerPossUsed > 0 ? (player.points / playerPossUsed) : 0;
                    
                    // Store opponent team averages for +/- comparison
                    player.oppTeamEfg = oppTotals.efg || 50;
                    player.oppTeamOrebPct = oppTotals.orebPct || 25;
                    player.oppTeamTovPct = oppTotals.tovPct || 15;
                    player.teamDRtg = oppTotals.ortg || 100; // Team's DRtg = opponent's ORtg
                    
                    // On-court metrics - Offensive
                    const key = `${teamName}|${player.number}`;
                    if (onCourtStats && onCourtStats[key]) {
                        const ocs = onCourtStats[key];
                        const ocTeamPoss = 0.96 * (ocs.teamFGA + ocs.teamTov + 0.44 * ocs.teamFTA - ocs.teamOreb);
                        const ocOppPoss = 0.96 * (ocs.oppFGA + ocs.oppTov + 0.44 * ocs.oppFTA - ocs.oppOreb);
                        
                        // Offensive on-court metrics
                        player.onCourtORtg = ocTeamPoss > 0 ? (ocs.teamPoints / ocTeamPoss * 100) : 0;
                        player.onCourtDRtg = ocOppPoss > 0 ? (ocs.oppPoints / ocOppPoss * 100) : 0;
                        player.netRating = player.onCourtORtg - player.onCourtDRtg;
                        player.onCourtEfg = ocs.teamFGA > 0 ? ((ocs.teamFGM + 0.5 * ocs.team3PM) / ocs.teamFGA * 100) : 0;
                        player.onCourtFTARate = ocs.teamFGA > 0 ? (ocs.teamFTA / ocs.teamFGA * 100) : 0;
                        const ocOrebOpps = ocs.teamOreb + ocs.oppDreb;
                        player.onCourtOrebPct = ocOrebOpps > 0 ? (ocs.teamOreb / ocOrebOpps * 100) : 0;
                        const ocTovDenom = ocs.teamFGA + 0.44 * ocs.teamFTA + ocs.teamTov;
                        player.onCourtTovPct = ocTovDenom > 0 ? (ocs.teamTov / ocTovDenom * 100) : 0;
                        
                        // Defensive on-court metrics (opponent stats while player is on court)
                        player.defOnCourtEfg = ocs.oppFGA > 0 ? ((ocs.oppFGM + 0.5 * ocs.opp3PM) / ocs.oppFGA * 100) : 0;
                        player.defOnCourtFTARate = ocs.oppFGA > 0 ? (ocs.oppFTA / ocs.oppFGA * 100) : 0;
                        const defOrebOpps = ocs.oppOreb + ocs.teamDreb;
                        player.defOnCourtOrebPct = defOrebOpps > 0 ? (ocs.oppOreb / defOrebOpps * 100) : 0;
                        const defTovDenom = ocs.oppFGA + 0.44 * ocs.oppFTA + ocs.oppTov;
                        player.defOnCourtTovPct = defTovDenom > 0 ? (ocs.oppTov / defTovDenom * 100) : 0;
                    } else {
                        player.onCourtORtg = team.teamTotals.ortg;
                        player.onCourtDRtg = oppTotals.ortg;
                        player.netRating = player.onCourtORtg - player.onCourtDRtg;
                        player.onCourtEfg = team.teamTotals.efg;
                        player.onCourtFTARate = team.teamTotals.ftaRate;
                        player.onCourtOrebPct = team.teamTotals.orebPct;
                        player.onCourtTovPct = team.teamTotals.tovPct;
                        
                        // Defensive defaults (opponent averages)
                        player.defOnCourtEfg = oppTotals.efg;
                        player.defOnCourtFTARate = oppTotals.ftaRate;
                        player.defOnCourtOrebPct = oppTotals.orebPct;
                        player.defOnCourtTovPct = oppTotals.tovPct;
                    }
                    
                    // Calculate points assisted on from assistCombinations
                    player.pointsAssisted = 0;
                    for (const [key, combo] of Object.entries(this.assistCombinations)) {
                        const [team, assisterNum] = key.split('|');
                        if (team === teamName && assisterNum === player.number) {
                            player.pointsAssisted += combo.points;
                        }
                    }
                    
                    // Total Point Contribution = Points Scored + Points Assisted On
                    player.totalPointContribution = player.points + player.pointsAssisted;
                }
            }
            
            return { teamsData, pace };
        }

        // ========================================================================
        // MAIN PROCESSING
        // ========================================================================

        processGame() {
            if (!this.boxscoreHTML) {
                alert('Please upload a boxscore file');
                return;
            }
            
            // If we're still on upload view, navigate to game view
            if (this.currentView === 'upload') {
                this.navigateTo('game');
            }
            
            // Show loading in the game view
            const vizContainer = document.getElementById('visualization');
            vizContainer.style.display = 'block';
            vizContainer.innerHTML = `
                <div class="loading" style="min-height: 400px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <div class="loading-spinner"></div>
                    <p style="margin-top: 20px;">Processing game data...</p>
                </div>
            `;
            
            setTimeout(() => {
                try {
                    this.resetParserState();
                    const teamsData = this.parseBoxscore(this.boxscoreHTML);
                    let onCourtStats = null;
                    if (this.pbpHTML) {
                        onCourtStats = this.parsePBP(this.pbpHTML, teamsData);
                    }
                    const result = this.calculateAdvancedMetrics(teamsData, onCourtStats);
                    this.renderVisualization(result.teamsData, result.pace);
                } catch (error) {
                    console.error('Error:', error);
                    vizContainer.innerHTML = `
                        <div class="glass-card" style="padding: var(--space-xl); text-align: center;">
                            <h2>❌ Error</h2>
                            <p style="color: var(--negative); margin: 20px 0;">${error.message}</p>
                            <button class="upload-btn primary" onclick="visualizer.navigateTo('${this.folderGames && this.folderGames.length > 0 ? 'browser' : 'upload'}')">Go Back</button>
                        </div>
                    `;
                }
            }, 100);
        }

        // ========================================================================
        // DEMO DATA
        // ========================================================================

        loadDemoData() {
            const teamsData = {
                'Sheffield Sharks': {
                    players: [
                        { number: '1', name: 'D. Williams', isStarter: true, minutes: 35, points: 20, fgm: 8, fga: 11, fg3m: 4, fg3a: 5, fg2m: 4, fg2a: 6, ftm: 0, fta: 0, oreb: 0, dreb: 2, ast: 2, stl: 1, blk: 2, tov: 2, pf: 1, rimAtt: 4, rimMade: 3, midAtt: 2, midMade: 1 },
                        { number: '3', name: 'R. Chatman III', isStarter: true, minutes: 35, points: 35, fgm: 12, fga: 19, fg3m: 6, fg3a: 7, fg2m: 6, fg2a: 12, ftm: 5, fta: 9, oreb: 0, dreb: 7, ast: 6, stl: 0, blk: 0, tov: 3, pf: 3, rimAtt: 8, rimMade: 5, midAtt: 4, midMade: 1 },
                        { number: '4', name: 'W. Lee', isStarter: true, minutes: 28, points: 10, fgm: 4, fga: 8, fg3m: 0, fg3a: 1, fg2m: 4, fg2a: 7, ftm: 2, fta: 4, oreb: 2, dreb: 5, ast: 1, stl: 0, blk: 1, tov: 1, pf: 2, rimAtt: 6, rimMade: 4, midAtt: 1, midMade: 0 },
                        { number: '7', name: 'J. Jones', isStarter: true, minutes: 22, points: 5, fgm: 2, fga: 6, fg3m: 1, fg3a: 4, fg2m: 1, fg2a: 2, ftm: 0, fta: 0, oreb: 0, dreb: 1, ast: 3, stl: 1, blk: 0, tov: 1, pf: 3, rimAtt: 1, rimMade: 0, midAtt: 1, midMade: 1 },
                        { number: '11', name: 'R. Glasgow Jr', isStarter: true, minutes: 19, points: 6, fgm: 2, fga: 5, fg3m: 2, fg3a: 4, fg2m: 0, fg2a: 1, ftm: 0, fta: 0, oreb: 0, dreb: 1, ast: 2, stl: 0, blk: 0, tov: 1, pf: 2, rimAtt: 0, rimMade: 0, midAtt: 1, midMade: 0 },
                        { number: '15', name: 'M. Sherrod', isStarter: false, minutes: 15, points: 4, fgm: 2, fga: 5, fg3m: 0, fg3a: 0, fg2m: 2, fg2a: 5, ftm: 0, fta: 0, oreb: 2, dreb: 1, ast: 0, stl: 0, blk: 1, tov: 0, pf: 2, rimAtt: 4, rimMade: 2, midAtt: 1, midMade: 0 },
                        { number: '22', name: 'L. Sherrod', isStarter: false, minutes: 20, points: 10, fgm: 4, fga: 7, fg3m: 2, fg3a: 3, fg2m: 2, fg2a: 4, ftm: 0, fta: 0, oreb: 0, dreb: 2, ast: 4, stl: 2, blk: 0, tov: 1, pf: 1, rimAtt: 3, rimMade: 2, midAtt: 1, midMade: 0 },
                        { number: '33', name: 'K. Brown', isStarter: false, minutes: 14, points: 8, fgm: 3, fga: 6, fg3m: 2, fg3a: 4, fg2m: 1, fg2a: 2, ftm: 0, fta: 0, oreb: 0, dreb: 3, ast: 1, stl: 0, blk: 0, tov: 0, pf: 1, rimAtt: 1, rimMade: 0, midAtt: 1, midMade: 1 }
                    ],
                    teamTotals: { points: 98, fgm: 37, fga: 67, fg3m: 17, fg3a: 28, ftm: 7, fta: 13, oreb: 4, dreb: 22, treb: 26, ast: 19, stl: 4, blk: 4, tov: 9, pf: 15, minutes: 188 }
                },
                'Manchester Basketball': {
                    players: [
                        { number: '0', name: 'K. Davis', isStarter: true, minutes: 32, points: 18, fgm: 7, fga: 15, fg3m: 2, fg3a: 6, fg2m: 5, fg2a: 9, ftm: 2, fta: 3, oreb: 1, dreb: 4, ast: 8, stl: 2, blk: 0, tov: 4, pf: 2, rimAtt: 6, rimMade: 4, midAtt: 3, midMade: 1 },
                        { number: '5', name: 'T. Smith', isStarter: true, minutes: 30, points: 14, fgm: 5, fga: 12, fg3m: 2, fg3a: 5, fg2m: 3, fg2a: 7, ftm: 2, fta: 2, oreb: 0, dreb: 3, ast: 2, stl: 1, blk: 0, tov: 2, pf: 3, rimAtt: 4, rimMade: 2, midAtt: 3, midMade: 1 },
                        { number: '12', name: 'J. Thompson', isStarter: true, minutes: 26, points: 12, fgm: 5, fga: 9, fg3m: 0, fg3a: 2, fg2m: 5, fg2a: 7, ftm: 2, fta: 4, oreb: 3, dreb: 5, ast: 1, stl: 0, blk: 2, tov: 1, pf: 4, rimAtt: 6, rimMade: 5, midAtt: 1, midMade: 0 },
                        { number: '21', name: 'M. Johnson', isStarter: true, minutes: 28, points: 11, fgm: 4, fga: 10, fg3m: 3, fg3a: 7, fg2m: 1, fg2a: 3, ftm: 0, fta: 0, oreb: 0, dreb: 2, ast: 3, stl: 1, blk: 0, tov: 2, pf: 2, rimAtt: 1, rimMade: 0, midAtt: 2, midMade: 1 },
                        { number: '34', name: 'C. Williams', isStarter: true, minutes: 24, points: 8, fgm: 3, fga: 7, fg3m: 0, fg3a: 0, fg2m: 3, fg2a: 7, ftm: 2, fta: 4, oreb: 2, dreb: 6, ast: 0, stl: 0, blk: 3, tov: 1, pf: 3, rimAtt: 6, rimMade: 3, midAtt: 1, midMade: 0 },
                        { number: '8', name: 'R. Brown', isStarter: false, minutes: 18, points: 9, fgm: 3, fga: 8, fg3m: 1, fg3a: 4, fg2m: 2, fg2a: 4, ftm: 2, fta: 2, oreb: 0, dreb: 2, ast: 4, stl: 1, blk: 0, tov: 1, pf: 1, rimAtt: 2, rimMade: 1, midAtt: 2, midMade: 1 },
                        { number: '14', name: 'A. Taylor', isStarter: false, minutes: 16, points: 6, fgm: 2, fga: 6, fg3m: 2, fg3a: 4, fg2m: 0, fg2a: 2, ftm: 0, fta: 0, oreb: 0, dreb: 1, ast: 2, stl: 0, blk: 0, tov: 1, pf: 2, rimAtt: 0, rimMade: 0, midAtt: 2, midMade: 0 },
                        { number: '25', name: 'J. Anderson', isStarter: false, minutes: 14, points: 4, fgm: 2, fga: 5, fg3m: 0, fg3a: 1, fg2m: 2, fg2a: 4, ftm: 0, fta: 2, oreb: 1, dreb: 2, ast: 0, stl: 0, blk: 1, tov: 0, pf: 2, rimAtt: 3, rimMade: 2, midAtt: 1, midMade: 0 }
                    ],
                    teamTotals: { points: 82, fgm: 31, fga: 72, fg3m: 10, fg3a: 29, ftm: 10, fta: 17, oreb: 7, dreb: 25, treb: 32, ast: 20, stl: 5, blk: 6, tov: 12, pf: 19, minutes: 188 }
                }
            };
            
            // Generate demo lineup stats with realistic data
            this.lineupStats = {
                'Sheffield Sharks|1,3,4,7,11': { 
                    points: 45, fgm: 16, fga: 28, fg3m: 8, fg3a: 12, ftm: 5, fta: 8, 
                    oreb: 2, dreb: 10, ast: 8, stl: 2, blk: 2, tov: 4, pf: 5,
                    seconds: 720, pointsAllowed: 35, 
                    defFgm: 12, defFga: 30, defFg3m: 4, defFg3a: 14, 
                    defFta: 8, defFtm: 7, defOrebAllowed: 3, defTovForced: 5 
                },
                'Sheffield Sharks|3,4,15,22,33': { 
                    points: 28, fgm: 11, fga: 20, fg3m: 5, fg3a: 8, ftm: 1, fta: 2, 
                    oreb: 3, dreb: 6, ast: 5, stl: 2, blk: 1, tov: 3, pf: 4,
                    seconds: 480, pointsAllowed: 24, 
                    defFgm: 9, defFga: 22, defFg3m: 3, defFg3a: 10, 
                    defFta: 4, defFtm: 3, defOrebAllowed: 2, defTovForced: 4 
                },
                'Sheffield Sharks|1,3,15,22,33': { 
                    points: 25, fgm: 10, fga: 19, fg3m: 4, fg3a: 8, ftm: 1, fta: 3, 
                    oreb: 2, dreb: 6, ast: 6, stl: 0, blk: 1, tov: 2, pf: 6,
                    seconds: 400, pointsAllowed: 23, 
                    defFgm: 8, defFga: 20, defFg3m: 3, defFg3a: 9, 
                    defFta: 5, defFtm: 4, defOrebAllowed: 4, defTovForced: 3 
                },
                'Manchester Basketball|0,5,12,21,34': { 
                    points: 42, fgm: 15, fga: 35, fg3m: 5, fg3a: 15, ftm: 7, fta: 10, 
                    oreb: 4, dreb: 12, ast: 10, stl: 3, blk: 3, tov: 6, pf: 8,
                    seconds: 720, pointsAllowed: 52, 
                    defFgm: 20, defFga: 38, defFg3m: 10, defFg3a: 16, 
                    defFta: 4, defFtm: 2, defOrebAllowed: 2, defTovForced: 4 
                },
                'Manchester Basketball|0,8,12,14,25': { 
                    points: 22, fgm: 8, fga: 20, fg3m: 3, fg3a: 8, ftm: 3, fta: 5, 
                    oreb: 2, dreb: 8, ast: 6, stl: 1, blk: 2, tov: 4, pf: 5,
                    seconds: 480, pointsAllowed: 26, 
                    defFgm: 10, defFga: 18, defFg3m: 4, defFg3a: 8, 
                    defFta: 3, defFtm: 2, defOrebAllowed: 1, defTovForced: 3 
                },
                'Manchester Basketball|5,8,12,21,25': { 
                    points: 18, fgm: 8, fga: 17, fg3m: 2, fg3a: 6, ftm: 0, fta: 2, 
                    oreb: 1, dreb: 5, ast: 4, stl: 1, blk: 1, tov: 2, pf: 6,
                    seconds: 400, pointsAllowed: 20, 
                    defFgm: 7, defFga: 16, defFg3m: 3, defFg3a: 6, 
                    defFta: 4, defFtm: 3, defOrebAllowed: 2, defTovForced: 2 
                }
            };
            
            // Generate demo game flow data for the charts
            this.gameFlowData = [];
            const generateDemoFlow = () => {
                let homePoints = 0, awayPoints = 0;
                let homeFga = 0, awayFga = 0;
                let homeFta = 0, awayFta = 0;
                let homeTov = 0, awayTov = 0;
                let homeOreb = 0, awayOreb = 0;
                
                // Simulate game events
                const events = [
                    // Q1 - Away starts with turnovers
                    { elapsed: 30, home: 2 }, { elapsed: 45, awayTov: true }, { elapsed: 60, away: 3 }, { elapsed: 90, home: 2 },
                    { elapsed: 120, home: 3 }, { elapsed: 150, away: 2 }, { elapsed: 165, homeTov: true }, { elapsed: 180, home: 2 },
                    { elapsed: 210, away: 3 }, { elapsed: 240, home: 3 }, { elapsed: 255, awayTov: true }, { elapsed: 270, away: 2 },
                    { elapsed: 300, home: 2 }, { elapsed: 330, away: 2 }, { elapsed: 360, home: 3 },
                    { elapsed: 420, home: 2 }, { elapsed: 450, homeOreb: true }, { elapsed: 480, away: 3 }, { elapsed: 540, home: 2 },
                    { elapsed: 580, away: 2 },
                    // Q2 - Home team controls possessions
                    { elapsed: 630, home: 3 }, { elapsed: 660, awayTov: true }, { elapsed: 680, away: 2 }, { elapsed: 720, home: 2 },
                    { elapsed: 780, away: 3 }, { elapsed: 810, awayTov: true }, { elapsed: 840, home: 3 }, { elapsed: 900, away: 2 },
                    { elapsed: 960, home: 2 }, { elapsed: 990, homeOreb: true }, { elapsed: 1020, home: 3 }, { elapsed: 1080, away: 2 },
                    { elapsed: 1140, home: 2 }, { elapsed: 1160, awayTov: true }, { elapsed: 1180, away: 3 },
                    // Q3 - Back and forth
                    { elapsed: 1230, home: 3 }, { elapsed: 1260, homeTov: true }, { elapsed: 1290, away: 2 }, { elapsed: 1350, home: 2 },
                    { elapsed: 1410, home: 3 }, { elapsed: 1440, awayOreb: true }, { elapsed: 1470, away: 2 }, { elapsed: 1530, home: 2 },
                    { elapsed: 1590, away: 3 }, { elapsed: 1620, homeTov: true }, { elapsed: 1650, home: 3 }, { elapsed: 1710, home: 2 },
                    { elapsed: 1770, away: 2 },
                    // Q4 - Away fights back but still down in possessions
                    { elapsed: 1830, away: 3 }, { elapsed: 1860, homeOreb: true }, { elapsed: 1890, home: 2 }, { elapsed: 1950, away: 2 },
                    { elapsed: 2010, home: 2 }, { elapsed: 2040, awayTov: true }, { elapsed: 2070, away: 3 }, { elapsed: 2130, away: 2 },
                    { elapsed: 2190, home: 3 }, { elapsed: 2250, away: 2 }, { elapsed: 2310, home: 2 },
                    { elapsed: 2370, away: 2 }, { elapsed: 2400, home: 2 }
                ];
                
                events.forEach(e => {
                    if (e.home) {
                        homePoints += e.home;
                        homeFga += 1;
                        if (e.home === 1) homeFta += 1;
                    }
                    if (e.away) {
                        awayPoints += e.away;
                        awayFga += 1;
                        if (e.away === 1) awayFta += 1;
                    }
                    if (e.homeTov) homeTov++;
                    if (e.awayTov) awayTov++;
                    if (e.homeOreb) homeOreb++;
                    if (e.awayOreb) awayOreb++;
                    
                    const period = e.elapsed <= 600 ? 1 : e.elapsed <= 1200 ? 2 : e.elapsed <= 1800 ? 3 : 4;
                    const homePoss = 0.96 * (homeFga + homeTov + 0.44 * homeFta - homeOreb);
                    const awayPoss = 0.96 * (awayFga + awayTov + 0.44 * awayFta - awayOreb);
                    
                    // Calculate EPA from TO margin and OREB margin
                    const toMargin = awayTov - homeTov;
                    const orebMargin = homeOreb - awayOreb;
                    const epa = (toMargin + orebMargin) * 1.05;
                    
                    // Calculate demo Scoring Battle (simplified for demo)
                    // Assume ~50% FG%, home slightly better
                    const homeFgm = Math.round(homeFga * 0.48);
                    const awayFgm = Math.round(awayFga * 0.45);
                    const homeFg3m = Math.round(homeFga * 0.15);
                    const awayFg3m = Math.round(awayFga * 0.12);
                    const homeFtm = Math.round(homeFta * 0.78);
                    const awayFtm = Math.round(awayFta * 0.75);
                    
                    const homeEfg = homeFga > 0 ? ((homeFgm + 0.5 * homeFg3m) / homeFga * 100) : 50;
                    const awayEfg = awayFga > 0 ? ((awayFgm + 0.5 * awayFg3m) / awayFga * 100) : 50;
                    const efgMargin = homeEfg - awayEfg;
                    
                    const homeFtRate = homeFga > 0 ? (homeFtm / homeFga * 100) : 0;
                    const awayFtRate = awayFga > 0 ? (awayFtm / awayFga * 100) : 0;
                    const ftRateMargin = homeFtRate - awayFtRate;
                    
                    const avgPoss = (homePoss + awayPoss) / 2;
                    const gamePace = avgPoss > 0 ? (avgPoss / (e.elapsed / 2400)) : 75;
                    const scoringBattle = ((efgMargin * 1.77) + (ftRateMargin * 0.25)) * (gamePace / 100);
                    
                    this.gameFlowData.push({
                        elapsed: e.elapsed,
                        period: period,
                        homePoints: homePoints,
                        awayPoints: awayPoints,
                        margin: homePoints - awayPoints,
                        homePoss: Math.max(0.1, homePoss),
                        awayPoss: Math.max(0.1, awayPoss),
                        possMargin: homePoss - awayPoss,
                        homePPP: homePoss > 0 ? homePoints / homePoss : 0,
                        awayPPP: awayPoss > 0 ? awayPoints / awayPoss : 0,
                        // EPA tracking
                        homeTov: homeTov,
                        awayTov: awayTov,
                        homeOreb: homeOreb,
                        awayOreb: awayOreb,
                        toMargin: toMargin,
                        orebMargin: orebMargin,
                        epa: epa,
                        // Scoring Battle tracking
                        homeEfg: homeEfg,
                        awayEfg: awayEfg,
                        efgMargin: efgMargin,
                        homeFtRate: homeFtRate,
                        awayFtRate: awayFtRate,
                        ftRateMargin: ftRateMargin,
                        scoringBattle: scoringBattle
                    });
                });
            };
            generateDemoFlow();
            
            // Generate demo player runs and team momentum runs
            this.playerRuns = [
                {
                    player: '3', playerName: 'CHATMAN III', team: 'Sheffield Sharks', teamIdx: 0,
                    points: 8, startElapsed: 120, endElapsed: 240, duration: "2'00\"",
                    startScore: '4-3', endScore: '12-5'
                },
                {
                    player: '0', playerName: 'DAVIS', team: 'Manchester Basketball', teamIdx: 1,
                    points: 6, startElapsed: 780, endElapsed: 900, duration: "2'00\"",
                    startScore: '24-18', endScore: '24-26'
                },
                {
                    player: '3', playerName: 'CHATMAN III', team: 'Sheffield Sharks', teamIdx: 0,
                    points: 9, startElapsed: 1650, endElapsed: 1770, duration: "2'00\"",
                    startScore: '48-42', endScore: '57-44'
                },
                {
                    player: '12', playerName: 'THOMPSON', team: 'Manchester Basketball', teamIdx: 1,
                    points: 6, startElapsed: 2070, endElapsed: 2130, duration: "1'00\"",
                    startScore: '62-58', endScore: '62-64'
                },
                {
                    player: '22', playerName: 'L. SHERROD', team: 'Sheffield Sharks', teamIdx: 0,
                    points: 7, startElapsed: 1080, endElapsed: 1200, duration: "2'00\"",
                    startScore: '32-28', endScore: '39-28'
                }
            ];
            
            this.teamMomentumRuns = [
                {
                    team: 'Sheffield Sharks', teamIdx: 0, points: 12, 
                    lineup: 'Sheffield Sharks|1,3,4,7,11',
                    lineupNames: 'WILLIAMS, CHATMAN III, LEE, JONES, GLASGOW JR',
                    startElapsed: 90, endElapsed: 300, duration: "3'30\"",
                    scoreDiff: '12-0', topScorer: 'CHATMAN III', topScorerPoints: 8
                },
                {
                    team: 'Manchester Basketball', teamIdx: 1, points: 8,
                    lineup: 'Manchester Basketball|0,5,12,21,34',
                    lineupNames: 'DAVIS, SMITH, THOMPSON, JOHNSON, WILLIAMS',
                    startElapsed: 720, endElapsed: 900, duration: "3'00\"",
                    scoreDiff: '0-8', topScorer: 'DAVIS', topScorerPoints: 5
                },
                {
                    team: 'Sheffield Sharks', teamIdx: 0, points: 7,
                    lineup: 'Sheffield Sharks|1,3,4,7,11',
                    lineupNames: 'WILLIAMS, CHATMAN III, LEE, JONES, GLASGOW JR',
                    startElapsed: 1200, endElapsed: 1380, duration: "3'00\"",
                    scoreDiff: '7-0', topScorer: 'WILLIAMS', topScorerPoints: 4
                },
                {
                    team: 'Manchester Basketball', teamIdx: 1, points: 11,
                    lineup: 'Manchester Basketball|0,5,12,21,34',
                    lineupNames: 'DAVIS, SMITH, THOMPSON, JOHNSON, WILLIAMS',
                    startElapsed: 1830, endElapsed: 2070, duration: "4'00\"",
                    scoreDiff: '0-11', topScorer: 'DAVIS', topScorerPoints: 6
                },
                {
                    team: 'Sheffield Sharks', teamIdx: 0, points: 9,
                    lineup: 'Sheffield Sharks|3,4,15,22,33',
                    lineupNames: 'CHATMAN III, LEE, M. SHERROD, L. SHERROD, BROWN',
                    startElapsed: 2190, endElapsed: 2400, duration: "3'30\"",
                    scoreDiff: '9-0', topScorer: 'CHATMAN III', topScorerPoints: 5
                }
            ];
            
            // Navigate to game view for demo
            this.navigateTo('game');
            
            const result = this.calculateAdvancedMetrics(teamsData, null);
            this.renderVisualization(result.teamsData, result.pace);
        }

        // ========================================================================
        // RENDERING
        // ========================================================================

        renderVisualization(teamsData, pace) {
            const teamNames = Object.keys(teamsData);
            if (teamNames.length < 2) return;
            
            // Store teamsData for shot chart tab re-rendering
            this.lastTeamsData = teamsData;
            
            const homeTeam = teamNames[0];
            const awayTeam = teamNames[1];
            const homeTotals = teamsData[homeTeam].teamTotals;
            const awayTotals = teamsData[awayTeam].teamTotals;
            const isHomeWin = homeTotals.points > awayTotals.points;
            
            const allPlayers = [
                ...teamsData[homeTeam].players.filter(p => p.minutes >= 5),
                ...teamsData[awayTeam].players.filter(p => p.minutes >= 5)
            ];
            const globalRanges = this.calculateGlobalRanges(allPlayers);
            
            // Calculate game averages (both teams combined)
            const gameAvg = {
                ortg: ((homeTotals.ortg || 100) + (awayTotals.ortg || 100)) / 2,
                drtg: ((homeTotals.ortg || 100) + (awayTotals.ortg || 100)) / 2, // DRtg avg = ORtg avg
                efg: ((homeTotals.efg || 50) + (awayTotals.efg || 50)) / 2,
                orebPct: ((homeTotals.orebPct || 25) + (awayTotals.orebPct || 25)) / 2,
                tovPct: ((homeTotals.tovPct || 15) + (awayTotals.tovPct || 15)) / 2
            };
            
            const container = document.getElementById('visualization');
            container.style.display = 'block';
            
            container.innerHTML = `
                ${this.renderGameHeader(homeTeam, awayTeam, homeTotals, awayTotals, isHomeWin, pace)}
                
                <div class="tab-container">
                    <button class="tab-btn active" data-tab="winprob">🎯 Win Probability</button>
                    <button class="tab-btn" data-tab="gameflow">📈 Game Flow</button>
                    <button class="tab-btn" data-tab="bpm">📊 BPM</button>
                    <button class="tab-btn" data-tab="players">📊 Player Stats</button>
                    <button class="tab-btn" data-tab="halfstats">⏱️ Half Stats</button>
                    <button class="tab-btn" data-tab="comparison">📈 Half Comparison + Total</button>
                    <button class="tab-btn" data-tab="connections">🔗 Connections</button>
                    <button class="tab-btn" data-tab="lineups">👥 Lineups</button>
                    <button class="tab-btn" data-tab="seasoncompare">📂 Season Compare</button>
                    <button class="tab-btn" data-tab="margin">📐 Margin</button>
                    <button class="tab-btn" data-tab="shotchart">🎯 Shot Chart</button>
                </div>
                
                <div class="tab-content-wrapper">
                    <div class="tab-content active" id="tab-winprob">
                        ${this.renderWinProbability(homeTeam, awayTeam, homeTotals, awayTotals)}
                    </div>
                    
                    <div class="tab-content" id="tab-gameflow">
                        ${this.renderGameFlowTab(homeTeam, awayTeam, homeTotals, awayTotals)}
                    </div>
                    
                    <div class="tab-content" id="tab-bpm">
                        ${this.renderBPMTab(teamsData, homeTeam, awayTeam, homeTotals, awayTotals, pace)}
                    </div>
                    
                    <div class="tab-content" id="tab-players">
                        <div class="stats-grid">
                            ${this.renderTeamFourFactors(homeTeam, awayTeam, homeTotals, awayTotals)}
                            ${this.renderKeyMetrics(homeTotals, awayTotals, homeTeam, awayTeam, pace)}
                        </div>
                        
                        ${this.renderPlayerTable(homeTeam, teamsData[homeTeam], isHomeWin, homeTotals, true, globalRanges, gameAvg)}
                        ${this.renderPlayerTable(awayTeam, teamsData[awayTeam], !isHomeWin, awayTotals, false, globalRanges, gameAvg)}
                        
                        ${this.renderTeamShotDistribution(homeTeam, awayTeam, teamsData)}
                    </div>
                    
                    <div class="tab-content" id="tab-halfstats">
                        ${this.renderHalfStatsTab(teamsData, globalRanges, gameAvg)}
                    </div>
                    
                    <div class="tab-content" id="tab-comparison">
                        ${this.renderHalfComparisonTab(teamsData)}
                    </div>
                    
                    <div class="tab-content" id="tab-connections">
                        ${this.renderConnectionsTab(teamsData)}
                    </div>
                    
                    <div class="tab-content" id="tab-lineups">
                        ${this.renderLineupsTab(teamsData)}
                    </div>
                    
                    <div class="tab-content" id="tab-seasoncompare">
                        ${this.renderSeasonCompareTab(teamsData)}
                    </div>
                    
                    <div class="tab-content" id="tab-margin">
                        ${this.renderMarginTab(teamsData, homeTotals, awayTotals, pace)}
                    </div>
                    
                    <div class="tab-content" id="tab-shotchart">
                        ${this.renderShotChartTab(teamsData, homeTeam, awayTeam)}
                    </div>
                </div>
                
                <div class="footer-note">
                    Players with ≥5 mins shown • Shot zones from PBP • A/U = AST%÷USG% • Generated by FIBA Game Visualizer
                </div>
            `;
            
            // Tab switching
            container.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    container.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    container.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById(`tab-${btn.dataset.tab}`).classList.add('active');
                    
                    // Smooth scroll to tab container when switching tabs
                    const tabContainer = container.querySelector('.tab-container');
                    if (tabContainer) {
                        tabContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                    
                    // Initialize comparison section heights when switching to comparison tab
                    if (btn.dataset.tab === 'comparison') {
                        setTimeout(() => {
                            container.querySelectorAll('.comparison-section-content').forEach(content => {
                                if (!content.classList.contains('collapsed')) {
                                    content.style.maxHeight = content.scrollHeight + 'px';
                                }
                            });
                            container.querySelectorAll('.tow-section-content').forEach(content => {
                                if (!content.classList.contains('collapsed')) {
                                    content.style.maxHeight = content.scrollHeight + 'px';
                                }
                            });
                        }, 10);
                    }
                });
            });
            
            // Initialize comparison section heights
            setTimeout(() => {
                container.querySelectorAll('.comparison-section-content').forEach(content => {
                    content.style.maxHeight = content.scrollHeight + 'px';
                });
                container.querySelectorAll('.tow-section-content').forEach(content => {
                    content.style.maxHeight = content.scrollHeight + 'px';
                });
            }, 100);
            
            // Sortable column headers
            container.querySelectorAll('.sortable-header').forEach(header => {
                header.addEventListener('click', () => {
                    const tableId = header.dataset.table;
                    const sortKey = header.dataset.sort;
                    
                    // Toggle direction if same header clicked
                    let direction = 'desc';
                    if (header.classList.contains('sort-desc')) {
                        direction = 'asc';
                    }
                    
                    this.sortTable(tableId, sortKey, direction);
                });
            });
            
            // Initialize all column groups as expanded by default
            setTimeout(() => {
                container.querySelectorAll('.team-section').forEach(section => {
                    const tableId = section.dataset.tableId;
                    if (tableId) {
                        this.expandAllGroups(tableId);
                    }
                });
            }, 50);
            
            // Lineup team filter
            container.querySelectorAll('.lineup-filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    container.querySelectorAll('.lineup-filter-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const team = btn.dataset.team;
                    const allGrid = document.getElementById('lineups-all');
                    const homeGrid = document.getElementById('lineups-home');
                    const awayGrid = document.getElementById('lineups-away');
                    const countAll = container.querySelector('.lineup-count-all');
                    const countHome = container.querySelector('.lineup-count-home');
                    const countAway = container.querySelector('.lineup-count-away');
                    
                    if (allGrid) allGrid.style.display = team === 'all' ? 'grid' : 'none';
                    if (homeGrid) homeGrid.style.display = team === 'home' ? 'grid' : 'none';
                    if (awayGrid) awayGrid.style.display = team === 'away' ? 'grid' : 'none';
                    
                    if (countAll) countAll.style.display = team === 'all' ? 'inline' : 'none';
                    if (countHome) countHome.style.display = team === 'home' ? 'inline' : 'none';
                    if (countAway) countAway.style.display = team === 'away' ? 'inline' : 'none';
                });
            });

            // Lineup view toggle (Cards/Table)
            container.querySelectorAll('.lineup-view-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    container.querySelectorAll('.lineup-view-btn').forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'transparent';
                        b.style.color = 'var(--text-muted)';
                    });
                    btn.classList.add('active');
                    btn.style.background = 'var(--bg-elevated)';
                    btn.style.color = 'var(--text-primary)';

                    const view = btn.dataset.view;
                    const cardsView = container.querySelector('.lineup-cards-view');
                    const tableView = container.querySelector('.lineup-table-view');

                    if (cardsView) cardsView.style.display = view === 'cards' ? 'block' : 'none';
                    if (tableView) tableView.style.display = view === 'table' ? 'block' : 'none';

                    // Sync table view with current team filter
                    if (view === 'table') {
                        const activeFilterBtn = container.querySelector('.lineup-filter-btn.active');
                        const team = activeFilterBtn ? activeFilterBtn.dataset.team : 'all';
                        const tableAll = document.getElementById('lineup-table-all');
                        const tableHome = document.getElementById('lineup-table-home');
                        const tableAway = document.getElementById('lineup-table-away');
                        if (tableAll) tableAll.style.display = team === 'all' ? 'block' : 'none';
                        if (tableHome) tableHome.style.display = team === 'home' ? 'block' : 'none';
                        if (tableAway) tableAway.style.display = team === 'away' ? 'block' : 'none';
                    }
                });
            });

            // Update lineup filter to also toggle table views
            container.querySelectorAll('.lineup-filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const team = btn.dataset.team;
                    // Also update table views
                    const tableAll = document.getElementById('lineup-table-all');
                    const tableHome = document.getElementById('lineup-table-home');
                    const tableAway = document.getElementById('lineup-table-away');
                    if (tableAll) tableAll.style.display = team === 'all' ? 'block' : 'none';
                    if (tableHome) tableHome.style.display = team === 'home' ? 'block' : 'none';
                    if (tableAway) tableAway.style.display = team === 'away' ? 'block' : 'none';
                });
            });

            // Connections view toggle (Cards/Table)
            container.querySelectorAll('.connections-view-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    container.querySelectorAll('.connections-view-btn').forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'transparent';
                        b.style.color = 'var(--text-muted)';
                    });
                    btn.classList.add('active');
                    btn.style.background = 'var(--bg-elevated)';
                    btn.style.color = 'var(--text-primary)';

                    const view = btn.dataset.view;
                    const cardsView = container.querySelector('.connections-cards-view');
                    const tableView = container.querySelector('.connections-table-view');

                    if (cardsView) cardsView.style.display = view === 'cards' ? 'block' : 'none';
                    if (tableView) tableView.style.display = view === 'table' ? 'block' : 'none';
                });
            });

            // Season CSV file upload handler
            const seasonCsvInput = document.getElementById('season-csv-file');
            if (seasonCsvInput) {
                seasonCsvInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const csvText = event.target.result;
                            const seasonData = this.parseSeasonCSV(csvText);
                            
                            if (seasonData.length === 0) {
                                alert('No valid data found in CSV');
                                return;
                            }
                            
                            // Store for later use
                            this.seasonData = seasonData;
                            
                            // Get debug info
                            const csvTeams = [...new Set(seasonData.map(p => p.Team))];
                            const gameTeams = [homeTeam, awayTeam];
                            const gamePlayers = {
                                home: teamsData[homeTeam]?.players?.map(p => p.name) || [],
                                away: teamsData[awayTeam]?.players?.map(p => p.name) || []
                            };
                            
                            // Calculate comparison
                            const results = this.calculateSeasonComparison(teamsData, seasonData);
                            
                            // Add debug info to results
                            results.debugInfo = { csvTeams, gameTeams, gamePlayers };
                            
                            // Render results
                            const resultsHtml = this.renderSeasonCompareResults(results, homeTeam, awayTeam);
                            
                            document.getElementById('season-upload-section').style.display = 'none';
                            document.getElementById('season-compare-results').innerHTML = resultsHtml;
                            document.getElementById('season-compare-results').style.display = 'block';
                            
                        } catch (err) {
                            console.error('Error parsing season CSV:', err);
                            alert('Error parsing CSV file. Please check the format.');
                        }
                    };
                    reader.readAsText(file);
                });
            }
        }

        calculateGlobalRanges(allPlayers) {
            const statKeys = [
                'minutes', 'usg', 'totalPointContribution',
                'onCourtORtg', 'onCourtDRtg', 'onCourtEfg', 'onCourtFTARate', 'onCourtOrebPct', 'onCourtTovPct',
                'defOnCourtEfg', 'defOnCourtFTARate', 'defOnCourtOrebPct', 'defOnCourtTovPct',
                'ts', 'astPct', 'rebPct', 'astUsgRatio', 'tovPct', 'ppp',
                'stlPct', 'blkPct', 'ftRate', 'orebPct', 'drebPct'
            ];
            const ranges = {};
            for (const key of statKeys) {
                const values = allPlayers.map(p => p[key] || 0).filter(v => !isNaN(v));
                ranges[key] = values.length > 0 ? { min: Math.min(...values), max: Math.max(...values) } : { min: 0, max: 100 };
            }
            return ranges;
        }

        renderGameHeader(homeTeam, awayTeam, homeTotals, awayTotals, isHomeWin, pace) {
            return `
                <div class="game-header glass-card">
                    <div class="team-block">
                        <div class="team-logo home">${homeTeam.substring(0, 3).toUpperCase()}</div>
                        <div class="team-content">
                            <h2>${homeTeam}</h2>
                            <span class="result-tag ${isHomeWin ? 'win' : 'loss'}">${isHomeWin ? 'Victory' : 'Defeat'}</span>
                        </div>
                    </div>
                    <div class="score-center">
                        <div class="score-display">
                            <span class="score-value home">${homeTotals.points}</span>
                            <div class="score-divider"></div>
                            <span class="score-value away">${awayTotals.points}</span>
                        </div>
                        <div class="match-meta">${this.liveMode ? '🔴 LIVE' : 'Final'}</div>
                        <div class="pace-indicator">
                            ⚡ Pace: <span class="value">${pace.toFixed(1)}</span> / 40min
                        </div>
                    </div>
                    <div class="team-block away">
                        <div class="team-logo away">${awayTeam.substring(0, 3).toUpperCase()}</div>
                        <div class="team-content">
                            <h2>${awayTeam}</h2>
                            <span class="result-tag ${!isHomeWin ? 'win' : 'loss'}">${!isHomeWin ? 'Victory' : 'Defeat'}</span>
                        </div>
                    </div>
                </div>
            `;
        }

        renderTeamFourFactors(homeTeam, awayTeam, homeTotals, awayTotals, subtitle = '') {
            const factors = [
                { label: 'ORtg', home: homeTotals.ortg || 0, away: awayTotals.ortg || 0, higherBetter: true, max: 130 },
                { label: 'eFG%', home: homeTotals.efg || 0, away: awayTotals.efg || 0, higherBetter: true, max: 70 },
                { label: 'FTA Rate', home: homeTotals.ftaRate || 0, away: awayTotals.ftaRate || 0, higherBetter: true, max: 50 },
                { label: 'OREB%', home: homeTotals.orebPct || 0, away: awayTotals.orebPct || 0, higherBetter: true, max: 50 },
                { label: 'TOV%', home: homeTotals.tovPct || 0, away: awayTotals.tovPct || 0, higherBetter: false, max: 30 }
            ];
            
            const titleSuffix = subtitle ? ` - ${subtitle}` : '';
            
            return `
                <div class="stat-card glass-card full-width">
                    <div class="card-header">
                        <span class="card-title">Offensive Rating & Four Factors${titleSuffix}</span>
                        <div class="team-legend">
                            <div class="legend-item"><span class="legend-dot home"></span><span style="color: var(--team-home); font-weight: 600;">${homeTeam}</span></div>
                            <div class="legend-item"><span class="legend-dot away"></span><span style="color: var(--team-away); font-weight: 600;">${awayTeam}</span></div>
                        </div>
                    </div>
                    <div class="factors-grid">
                        ${factors.map(f => {
                            const homeWins = f.higherBetter ? f.home > f.away : f.home < f.away;
                            const awayWins = !homeWins;
                            const homeBarWidth = Math.min((f.home / f.max) * 100, 100);
                            const awayBarWidth = Math.min((f.away / f.max) * 100, 100);
                            return `
                                <div class="factor-block">
                                    <div class="factor-bar-top">
                                        <div class="factor-bar-bg">
                                            <div class="factor-bar-fill home" style="width: ${homeBarWidth}%;"></div>
                                        </div>
                                        <div class="factor-bar-bg">
                                            <div class="factor-bar-fill away" style="width: ${awayBarWidth}%;"></div>
                                        </div>
                                    </div>
                                    <div class="factor-values">
                                        <span class="factor-val home ${homeWins ? 'winner' : ''}">${f.home.toFixed(1)}</span>
                                        <span class="factor-val away ${awayWins ? 'winner' : ''}">${f.away.toFixed(1)}</span>
                                    </div>
                                    <div class="factor-label">${f.label}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        renderKeyMetrics(homeTotals, awayTotals, homeTeam, awayTeam, pace) {
            const homeAstPct = homeTotals.fgm > 0 ? (homeTotals.ast / homeTotals.fgm * 100) : 0;
            const awayAstPct = awayTotals.fgm > 0 ? (awayTotals.ast / awayTotals.fgm * 100) : 0;
            
            // Calculate FT%
            const homeFtPct = homeTotals.fta > 0 ? (homeTotals.ftm / homeTotals.fta * 100) : 75;
            const awayFtPct = awayTotals.fta > 0 ? (awayTotals.ftm / awayTotals.fta * 100) : 75;
            
            // ========================================================================
            // EXPECTED POINTS ADDED (EPA) - TO + OREB Battle
            // ========================================================================
            // Simple, intuitive formula:
            // EPA = (TO Margin + OREB Margin) × 1.05 PPP
            //
            // - TO Margin = Opponent TOs - Your TOs (each opponent TO = extra opportunity)
            // - OREB Margin = Your OREBs - Opponent OREBs (each OREB = extra shot)
            // - 1.05 PPP = typical points per possession
            //
            // Positive = home team advantage
            
            const toMargin = (awayTotals.tov || 0) - (homeTotals.tov || 0);
            const orebMargin = (homeTotals.oreb || 0) - (awayTotals.oreb || 0);
            const epaFromBattle = (toMargin + orebMargin) * 1.05;
            
            const gamePace = pace || 70; // FIBA average ~70 possessions per 40 min
            
            // ========================================================================
            // SCORING BATTLE - Research-based formula  
            // ========================================================================
            // Based on 2023 paper "Dean Oliver's Four Factors Revisited" (arXiv:2305.13032):
            //
            // Points per 100 possessions =
            //   [eFG% margin × 1.77] + [FT Rate margin × 0.25]
            //
            // - eFG% coefficient: 1.77 points per 1% margin (most impactful factor)
            // - FT Rate (FTM/FGA): 0.25 points per 1% margin
            // - Scale by (pace/100) to convert to actual game points
            //
            // Note: FT Rate = FTM/FGA (incorporates both getting to line AND converting)
            
            const efgMargin = (homeTotals.efg || 50) - (awayTotals.efg || 50);
            
            // FT Rate = FTM / FGA (as percentage)
            const homeFTMRate = homeTotals.fga > 0 ? (homeTotals.ftm / homeTotals.fga * 100) : 0;
            const awayFTMRate = awayTotals.fga > 0 ? (awayTotals.ftm / awayTotals.fga * 100) : 0;
            const ftRateMargin = homeFTMRate - awayFTMRate;
            
            const pointsPer100 = (efgMargin * 1.77) + (ftRateMargin * 0.25);
            const scoringDifferential = pointsPer100 * (gamePace / 100);
            
            // Calculate team RIM% and 3PT% from totals
            const homeRimPct = homeTotals.rimAtt > 0 ? (homeTotals.rimMade / homeTotals.rimAtt * 100) : 0;
            const awayRimPct = awayTotals.rimAtt > 0 ? (awayTotals.rimMade / awayTotals.rimAtt * 100) : 0;
            const home3ptPct = homeTotals.fg3a > 0 ? (homeTotals.fg3m / homeTotals.fg3a * 100) : 0;
            const away3ptPct = awayTotals.fg3a > 0 ? (awayTotals.fg3m / awayTotals.fg3a * 100) : 0;
            
            // Calculate shot attempt ratios (as percentages)
            const homeRimRate = homeTotals.fga > 0 ? (homeTotals.rimAtt / homeTotals.fga * 100) : 0;
            const awayRimRate = awayTotals.fga > 0 ? (awayTotals.rimAtt / awayTotals.fga * 100) : 0;
            const home3ptRate = homeTotals.fga > 0 ? (homeTotals.fg3a / homeTotals.fga * 100) : 0;
            const away3ptRate = awayTotals.fga > 0 ? (awayTotals.fg3a / awayTotals.fga * 100) : 0;
            
            const metrics = [
                { label: 'True Shooting %', home: homeTotals.ts, away: awayTotals.ts, max: 100 },
                { label: 'AST / TO Ratio', home: homeTotals.astToRatio, away: awayTotals.astToRatio, max: 4 },
                { label: 'Team AST %', home: homeAstPct, away: awayAstPct, max: 100 },
                { label: 'Free Throw %', home: homeFtPct, away: awayFtPct, max: 100, separator: true },
                { label: 'RIM%', home: homeRimPct, away: awayRimPct, max: 100 },
                { label: 'RIMA/FGA', home: homeRimRate, away: awayRimRate, max: 100 },
                { label: '3PT%', home: home3ptPct, away: away3ptPct, max: 100 },
                { label: '3PTA/FGA', home: home3ptRate, away: away3ptRate, max: 100 }
            ];
            
            // Format battle metrics for display
            const formatPoss = (diff) => {
                const sign = diff >= 0 ? '+' : '';
                return `${sign}${diff.toFixed(1)}`;
            };
            
            const epaClass = epaFromBattle > 0 ? 'home-advantage' : (epaFromBattle < 0 ? 'away-advantage' : '');
            const scoringClass = scoringDifferential > 0 ? 'home-advantage' : (scoringDifferential < 0 ? 'away-advantage' : '');
            
            // Calculate bar widths (scale: ±10 EPA or ±10 points = full bar)
            const epaBarWidth = Math.min(100, Math.max(0, 50 + (epaFromBattle / 10) * 50));
            const scoringBarWidth = Math.min(100, Math.max(0, 50 + (scoringDifferential / 10) * 50));
            
            return `
                <div class="stat-card glass-card full-width">
                    <div class="card-header">
                        <span class="card-title">Additional Metrics</span>
                    </div>
                    
                    <!-- Battle Metrics -->
                    <div class="battle-metrics">
                        <div class="battle-card ${epaClass}">
                            <div class="battle-icon">⚔️</div>
                            <div class="battle-content">
                                <div class="battle-label">EPA (TO + OREB Battle)</div>
                                <div class="battle-value ${epaFromBattle >= 0 ? 'positive' : 'negative'}">${formatPoss(epaFromBattle)} <span class="battle-unit">pts</span></div>
                                <div class="battle-detail">
                                    TO Margin: ${toMargin >= 0 ? '+' : ''}${toMargin} | OREB Margin: ${orebMargin >= 0 ? '+' : ''}${orebMargin}
                                </div>
                            </div>
                            <div class="battle-bar-container">
                                <div class="battle-bar home" style="width: ${epaBarWidth}%;"></div>
                            </div>
                            <div class="battle-teams">
                                <span class="home">${homeTeam}</span>
                                <span class="away">${awayTeam}</span>
                            </div>
                        </div>
                        
                        <div class="battle-card ${scoringClass}">
                            <div class="battle-icon">🎯</div>
                            <div class="battle-content">
                                <div class="battle-label">Scoring Battle</div>
                                <div class="battle-value ${scoringDifferential >= 0 ? 'positive' : 'negative'}">${formatPoss(scoringDifferential)} <span class="battle-unit">pts</span></div>
                                <div class="battle-detail">
                                    eFG%: ${formatPoss(efgMargin * 1.77 * gamePace / 100)} | FT Rate: ${formatPoss(ftRateMargin * 0.25 * gamePace / 100)}
                                </div>
                            </div>
                            <div class="battle-bar-container">
                                <div class="battle-bar home" style="width: ${scoringBarWidth}%;"></div>
                            </div>
                            <div class="battle-teams">
                                <span class="home">${homeTeam}</span>
                                <span class="away">${awayTeam}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="metrics-list">
                        ${metrics.map(m => `
                            <div class="metric-row">
                                <div class="metric-value home">${typeof m.home === 'number' ? m.home.toFixed(1) : m.home}${m.max === 100 ? '%' : ''}</div>
                                <div class="metric-center">
                                    <div class="metric-bars">
                                        <div style="width: 50%; display: flex; justify-content: flex-end;">
                                            <div class="metric-bar home" style="width: ${(m.home / m.max) * 50}%;"></div>
                                        </div>
                                        <div style="width: 50%; display: flex; justify-content: flex-start;">
                                            <div class="metric-bar away" style="width: ${(m.away / m.max) * 50}%;"></div>
                                        </div>
                                    </div>
                                    <div class="metric-label">${m.label}</div>
                                </div>
                                <div class="metric-value away">${typeof m.away === 'number' ? m.away.toFixed(1) : m.away}${m.max === 100 ? '%' : ''}</div>
                            </div>
                            ${m.separator ? `
                            <div class="metrics-separator">
                                <div class="separator-line"></div>
                                <span class="separator-label">Shot Zones</span>
                                <div class="separator-line"></div>
                            </div>
                            ` : ''}
                        `).join('')}
                    </div>
                </div>
            `;
        }

        renderTeamShotDistribution(homeTeam, awayTeam, teamsData) {
            // Calculate team totals for shot distribution
            const calcTeamShots = (team) => {
                const players = teamsData[team].players;
                let rimAtt = 0, rimMade = 0, midAtt = 0, midMade = 0, threeAtt = 0, threeMade = 0;
                
                for (const p of players) {
                    rimAtt += p.rimAtt || 0;
                    rimMade += p.rimMade || 0;
                    midAtt += p.midAtt || 0;
                    midMade += p.midMade || 0;
                    threeAtt += p.fg3a || 0;
                    threeMade += p.fg3m || 0;
                }
                
                const totalAtt = rimAtt + midAtt + threeAtt;
                return {
                    rim: { att: rimAtt, made: rimMade, pct: rimAtt > 0 ? (rimMade / rimAtt * 100) : 0, dist: totalAtt > 0 ? (rimAtt / totalAtt * 100) : 0 },
                    mid: { att: midAtt, made: midMade, pct: midAtt > 0 ? (midMade / midAtt * 100) : 0, dist: totalAtt > 0 ? (midAtt / totalAtt * 100) : 0 },
                    three: { att: threeAtt, made: threeMade, pct: threeAtt > 0 ? (threeMade / threeAtt * 100) : 0, dist: totalAtt > 0 ? (threeAtt / totalAtt * 100) : 0 },
                    total: totalAtt
                };
            };
            
            const homeShots = calcTeamShots(homeTeam);
            const awayShots = calcTeamShots(awayTeam);
            
            // Helper to generate court SVG for a team
            const renderCourt = (shots, teamClass, teamName) => {
                // Color intensity based on FG%
                const getZoneColor = (pct, baseColor) => {
                    const intensity = Math.min(1, pct / 70); // 70% = max intensity
                    return `opacity: ${0.4 + intensity * 0.5}`;
                };
                
                return `
                    <div class="shot-court-container">
                        <div class="shot-court-title ${teamClass}">${teamName}</div>
                        <svg class="shot-court-svg" viewBox="0 0 300 280" xmlns="http://www.w3.org/2000/svg">
                            <!-- Court background -->
                            <rect x="0" y="0" width="300" height="280" fill="#1a1a2e" rx="8"/>
                            
                            <!-- 3-Point Zone (outer arc) -->
                            <path class="court-zone" 
                                d="M 30 280 L 30 100 Q 30 20, 150 20 Q 270 20, 270 100 L 270 280 Z"
                                fill="#00ff88" style="${getZoneColor(shots.three.pct, 'emerald')}"
                            />
                            
                            <!-- Mid-Range Zone -->
                            <path class="court-zone"
                                d="M 60 280 L 60 120 Q 60 60, 150 60 Q 240 60, 240 120 L 240 280 Z"
                                fill="#a855f7" style="${getZoneColor(shots.mid.pct, 'purple')}"
                            />
                            
                            <!-- Paint/Rim Zone -->
                            <rect class="court-zone" x="100" y="180" width="100" height="100" rx="4"
                                fill="#ff6b6b" style="${getZoneColor(shots.rim.pct, 'coral')}"
                            />
                            
                            <!-- Rim circle -->
                            <circle cx="150" cy="230" r="15" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="3"/>
                            <rect x="135" y="240" width="30" height="5" fill="rgba(255,255,255,0.4)"/>
                            
                            <!-- 3-Point Line -->
                            <path class="court-line"
                                d="M 40 280 L 40 105 Q 40 30, 150 30 Q 260 30, 260 105 L 260 280"
                            />
                            
                            <!-- Mid-Range Arc -->
                            <path class="court-line"
                                d="M 70 280 L 70 125 Q 70 70, 150 70 Q 230 70, 230 125 L 230 280"
                            />
                            
                            <!-- Free throw line -->
                            <line class="court-line" x1="100" y1="180" x2="200" y2="180"/>
                            
                            <!-- Free throw circle -->
                            <circle cx="150" cy="180" r="30" class="court-line"/>
                            
                            <!-- Baseline -->
                            <line class="court-baseline" x1="10" y1="278" x2="290" y2="278"/>
                            
                            <!-- 3-Point Zone Labels -->
                            <text x="150" y="52" class="zone-label zone-label-pct">${shots.three.pct.toFixed(0)}%</text>
                            <text x="150" y="67" class="zone-label zone-label-detail">${shots.three.made}/${shots.three.att}</text>
                            
                            <!-- Mid-Range Zone Labels -->
                            <text x="150" y="130" class="zone-label zone-label-pct">${shots.mid.pct.toFixed(0)}%</text>
                            <text x="150" y="145" class="zone-label zone-label-detail">${shots.mid.made}/${shots.mid.att}</text>
                            
                            <!-- Rim Zone Labels -->
                            <text x="150" y="210" class="zone-label zone-label-pct">${shots.rim.pct.toFixed(0)}%</text>
                            <text x="150" y="225" class="zone-label zone-label-detail">${shots.rim.made}/${shots.rim.att}</text>
                        </svg>
                    </div>
                `;
            };
            
            // Shot Distribution Bar Chart
            const maxDist = Math.max(
                homeShots.rim.dist, homeShots.mid.dist, homeShots.three.dist,
                awayShots.rim.dist, awayShots.mid.dist, awayShots.three.dist, 50
            );
            
            const renderDistributionChart = () => {
                const zones = [
                    { label: 'Rim', key: 'rim', color: '#ff6b6b' },
                    { label: 'Mid', key: 'mid', color: '#a855f7' },
                    { label: '3PT', key: 'three', color: '#00ff88' }
                ];
                
                return `
                    <div class="shot-dist-chart">
                        <div class="shot-dist-title">Shot Distribution</div>
                        <div class="shot-dist-bars">
                            ${zones.map(zone => `
                                <div class="shot-dist-row">
                                    <div class="shot-dist-label" style="color: ${zone.color}">${zone.label}</div>
                                    <span class="shot-dist-value home">${homeShots[zone.key].dist.toFixed(0)}%</span>
                                    <div class="shot-dist-bar-group">
                                        <div class="shot-dist-bar-wrapper home-wrapper">
                                            <div class="shot-dist-bar home" style="width: ${(homeShots[zone.key].dist / maxDist) * 50}%;"></div>
                                        </div>
                                        <div class="shot-dist-bar-wrapper away-wrapper">
                                            <div class="shot-dist-bar away" style="width: ${(awayShots[zone.key].dist / maxDist) * 50}%;"></div>
                                        </div>
                                    </div>
                                    <span class="shot-dist-value away">${awayShots[zone.key].dist.toFixed(0)}%</span>
                                </div>
                            `).join('')}
                        </div>
                        <div class="shot-dist-legend">
                            <span class="shot-dist-legend-item"><span class="legend-dot home"></span>${homeTeam}</span>
                            <span class="shot-dist-legend-item"><span class="legend-dot away"></span>${awayTeam}</span>
                        </div>
                    </div>
                `;
            };
            
            return `
                <div class="stat-card glass-card full-width" style="margin-top: var(--space-xl);">
                    <div class="card-header">
                        <span class="card-title">Team Shot Distribution</span>
                    </div>
                    <div class="shot-viz-container">
                        <div class="team-shots-grid">
                            ${renderCourt(homeShots, 'home', homeTeam)}
                            ${renderCourt(awayShots, 'away', awayTeam)}
                        </div>
                        ${renderDistributionChart()}
                    </div>
                    <div class="shot-court-legend">
                        <div class="legend-zone"><span class="legend-zone-color rim"></span>Rim</div>
                        <div class="legend-zone"><span class="legend-zone-color mid"></span>Mid-Range</div>
                        <div class="legend-zone"><span class="legend-zone-color three"></span>3-Point</div>
                    </div>
                </div>
            `;
        }


        // ========================================================================
        // WIN PROBABILITY ENGINE - MONTE CARLO SIMULATION
        // ========================================================================
        // 10,000 possession-based simulations using Four Factors + EPA metrics
        
        calculateWinProbability(homeTotals, awayTotals) {
            const NUM_SIMULATIONS = 10000;
            const POSSESSIONS_PER_GAME = 75; // Typical FIBA game
            
            // ========================================================================
            // EXTRACT FOUR FACTORS (convert to decimals)
            // ========================================================================
            
            const home = {
                efg: (homeTotals.efg || 50) / 100,
                tov: (homeTotals.tovPct || 15) / 100,
                oreb: (homeTotals.orebPct || 25) / 100,
                ftRate: (homeTotals.ftaRate || 25) / 100,
                ftPct: (homeTotals.ftm && homeTotals.fta) ? homeTotals.ftm / homeTotals.fta : 0.75
            };
            
            const away = {
                efg: (awayTotals.efg || 50) / 100,
                tov: (awayTotals.tovPct || 15) / 100,
                oreb: (awayTotals.orebPct || 25) / 100,
                ftRate: (awayTotals.ftaRate || 25) / 100,
                ftPct: (awayTotals.ftm && awayTotals.fta) ? awayTotals.ftm / awayTotals.fta : 0.75
            };
            
            // ========================================================================
            // CALCULATE BASE PPP (Points Per Possession)
            // ========================================================================
            
            const calculateBasePPP = (team) => {
                // Non-turnover rate
                const nonTovRate = 1 - team.tov;
                
                // Miss rate
                const missRate = 1 - team.efg;
                
                // OREB cycling multiplier (geometric series)
                const orebMissProduct = team.oreb * missRate;
                const orebMultiplier = orebMissProduct < 0.95 ? 1 / (1 - orebMissProduct) : 3;
                
                // Shots per possession
                const shotsPerPoss = nonTovRate * orebMultiplier;
                
                // Points from FG (eFG already accounts for 3pt value)
                const fgPoints = shotsPerPoss * team.efg * 2;
                
                // Points from FT
                const ftPoints = shotsPerPoss * team.ftRate * team.ftPct * 0.9;
                
                return fgPoints + ftPoints;
            };
            
            const homePPP = calculateBasePPP(home);
            const awayPPP = calculateBasePPP(away);
            
            // ========================================================================
            // VARIANCE PARAMETERS FOR SIMULATION
            // ========================================================================
            
            // Standard deviation for each factor (based on typical game-to-game variance)
            const variance = {
                efg: 0.06,      // eFG% varies by ~6 percentage points game-to-game
                tov: 0.04,      // TOV% varies by ~4 percentage points
                oreb: 0.08,     // OREB% varies by ~8 percentage points
                ftRate: 0.10,   // FT Rate varies significantly
                ftPct: 0.08     // FT% varies by ~8 percentage points
            };
            
            // ========================================================================
            // EPA (EXPECTED POSSESSION ADVANTAGE) METRICS
            // ========================================================================
            // EPA = Net effect of TO Battle + OREB Battle (using raw counts, not rates)
            // Aligned with calculateBattleMetrics() formula
            
            // TO Battle: Each turnover costs ~1.1 points
            // Using raw TO counts from totals
            const homeTovCount = homeTotals.tov || 0;
            const awayTovCount = awayTotals.tov || 0;
            const tovImpactHome = (awayTovCount - homeTovCount) * 1.1;
            
            // OREB Battle: Each OREB worth ~1.1 points
            // Using raw OREB counts from totals
            const homeOrebCount = homeTotals.oreb || 0;
            const awayOrebCount = awayTotals.oreb || 0;
            const orebImpactHome = (homeOrebCount - awayOrebCount) * 1.1;
            
            // EPA Battle = TO + OREB combined
            const epaHome = tovImpactHome + orebImpactHome;
            
            // Scoring Battle: eFG% differential using same formula as margin tab
            // efgImpact = (homeEfg - awayEfg) * 1.77 * (POSS / 100)
            const efgDiffPct = (homeTotals.efg || 50) - (awayTotals.efg || 50);
            const efgImpactHome = efgDiffPct * 1.77 * (POSSESSIONS_PER_GAME / 100);
            
            // FT Rate Impact: ftRateImpact = (homeFtRate - awayFtRate) * 0.25 * (POSS / 100)
            const ftRateDiffPct = (homeTotals.ftaRate || 25) - (awayTotals.ftaRate || 25);
            const ftRateImpactHome = ftRateDiffPct * 0.25 * (POSSESSIONS_PER_GAME / 100);
            
            // Scoring Battle = eFG% + FT Rate
            const scoringBattleHome = efgImpactHome + ftRateImpactHome;
            
            // ========================================================================
            // MONTE CARLO SIMULATION - 10,000 GAMES
            // ========================================================================
            
            // Box-Muller transform for normal distribution
            const randomNormal = (mean, std) => {
                const u1 = Math.random();
                const u2 = Math.random();
                const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                return mean + z * std;
            };
            
            // Clamp function to keep percentages in valid range
            const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
            
            // Simulate a single possession
            const simulatePossession = (team) => {
                // Check for turnover
                if (Math.random() < team.tov) {
                    return 0; // Turnover, no points
                }
                
                // Shot attempt
                let points = 0;
                let shotTaken = true;
                
                while (shotTaken) {
                    // Determine if shot is made (using eFG%)
                    if (Math.random() < team.efg) {
                        // Made shot - determine if 2 or 3 pointer
                        // eFG% = (FGM + 0.5*3PM) / FGA, so we can estimate 3pt rate
                        points += Math.random() < 0.3 ? 3 : 2; // ~30% of makes are 3s
                        shotTaken = false;
                    } else {
                        // Missed shot - check for OREB
                        if (Math.random() < team.oreb) {
                            // Got offensive rebound, get another shot
                            shotTaken = true;
                        } else {
                            shotTaken = false;
                        }
                    }
                }
                
                // Free throws (happens independently, modeled as rate per shot)
                if (Math.random() < team.ftRate * 0.5) {
                    const ftAttempts = Math.random() < 0.2 ? 3 : 2; // Some and-1s or 3pt fouls
                    for (let i = 0; i < ftAttempts; i++) {
                        if (Math.random() < team.ftPct) {
                            points += 1;
                        }
                    }
                }
                
                return points;
            };
            
            // Simulate one full game
            const simulateGame = () => {
                // Add random variance to team stats for this game
                const gameHome = {
                    efg: clamp(randomNormal(home.efg, variance.efg), 0.25, 0.75),
                    tov: clamp(randomNormal(home.tov, variance.tov), 0.05, 0.35),
                    oreb: clamp(randomNormal(home.oreb, variance.oreb), 0.10, 0.50),
                    ftRate: clamp(randomNormal(home.ftRate, variance.ftRate), 0.10, 0.60),
                    ftPct: clamp(randomNormal(home.ftPct, variance.ftPct), 0.50, 0.95)
                };
                
                const gameAway = {
                    efg: clamp(randomNormal(away.efg, variance.efg), 0.25, 0.75),
                    tov: clamp(randomNormal(away.tov, variance.tov), 0.05, 0.35),
                    oreb: clamp(randomNormal(away.oreb, variance.oreb), 0.10, 0.50),
                    ftRate: clamp(randomNormal(away.ftRate, variance.ftRate), 0.10, 0.60),
                    ftPct: clamp(randomNormal(away.ftPct, variance.ftPct), 0.50, 0.95)
                };
                
                let homeScore = 0;
                let awayScore = 0;
                
                // Simulate each possession
                for (let poss = 0; poss < POSSESSIONS_PER_GAME; poss++) {
                    homeScore += simulatePossession(gameHome);
                    awayScore += simulatePossession(gameAway);
                }
                
                return { homeScore, awayScore, margin: homeScore - awayScore };
            };
            
            // Run simulations
            let homeWins = 0;
            let ties = 0;
            const margins = [];
            const homeScores = [];
            const awayScores = [];
            
            for (let sim = 0; sim < NUM_SIMULATIONS; sim++) {
                const result = simulateGame();
                margins.push(result.margin);
                homeScores.push(result.homeScore);
                awayScores.push(result.awayScore);
                
                if (result.margin > 0) homeWins++;
                else if (result.margin === 0) ties++;
            }
            
            // ========================================================================
            // CALCULATE RESULTS FROM SIMULATIONS
            // ========================================================================
            
            // Expected margin - use EPA-based calculation which is more accurate
            // EPA (TO + OREB) + Scoring Battle (eFG + FT Rate) = total expected differential
            const epaBasedMargin = epaHome + scoringBattleHome;
            const expectedMargin = epaBasedMargin;
            
            // Monte Carlo margin for reference (tends to overestimate differentials)
            const mcMargin = margins.reduce((a, b) => a + b, 0) / NUM_SIMULATIONS;
            
            // Standard deviation of margins from simulation (captures game-to-game variance)
            const variance_margins = margins.reduce((acc, m) => acc + Math.pow(m - mcMargin, 2), 0) / NUM_SIMULATIONS;
            const stdDev = Math.sqrt(variance_margins);
            
            // Win probability using normal approximation with EPA margin and MC variance
            // P(home wins) = P(margin > 0) = Phi(margin / stdDev)
            const normalCDF = (x) => {
                // Approximation of standard normal CDF
                const t = 1 / (1 + 0.2316419 * Math.abs(x));
                const d = 0.3989423 * Math.exp(-x * x / 2);
                const p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
                return x > 0 ? 1 - p : p;
            };
            
            const zScore = stdDev > 0 ? expectedMargin / stdDev : (expectedMargin > 0 ? 3 : -3);
            const homeWinProb = normalCDF(zScore) * 100;
            const awayWinProb = 100 - homeWinProb;
            
            // Mean scores
            const avgHomeScore = homeScores.reduce((a, b) => a + b, 0) / NUM_SIMULATIONS;
            const avgAwayScore = awayScores.reduce((a, b) => a + b, 0) / NUM_SIMULATIONS;
            
            // ========================================================================
            // ADVANTAGE COUNTING
            // ========================================================================
            
            const homeAdvantages = {
                efg: home.efg > away.efg,
                tov: home.tov < away.tov,
                oreb: home.oreb > away.oreb,
                ft: home.ftRate > away.ftRate
            };
            
            const advantageCount = Object.values(homeAdvantages).filter(v => v).length;
            
            // ========================================================================
            // CALCULATE DIFFERENTIALS FOR DISPLAY
            // ========================================================================
            
            const efgDiff = (home.efg - away.efg) * 100;
            const tovDiff = (away.tov - home.tov) * 100;  // Inverted: lower TOV is better
            const orebDiff = (home.oreb - away.oreb) * 100;
            const ftDiff = (home.ftRate - away.ftRate) * 100;
            
            // Calculate impact scores
            const totalImpact = Math.abs(efgDiff) * 0.4 + Math.abs(tovDiff) * 0.25 + 
                                Math.abs(orebDiff) * 0.2 + Math.abs(ftDiff) * 0.15;
            
            const efgImpact = totalImpact > 0 ? (Math.abs(efgDiff) * 0.4 / totalImpact) * 100 : 25;
            const tovImpact = totalImpact > 0 ? (Math.abs(tovDiff) * 0.25 / totalImpact) * 100 : 25;
            const orebImpact = totalImpact > 0 ? (Math.abs(orebDiff) * 0.2 / totalImpact) * 100 : 25;
            const ftImpact = totalImpact > 0 ? (Math.abs(ftDiff) * 0.15 / totalImpact) * 100 : 25;
            
            // ========================================================================
            // RETURN COMPLETE RESULT OBJECT
            // ========================================================================
            
            return {
                homeWinProb,
                awayWinProb,
                homePPP,
                awayPPP,
                expectedMargin,
                avgHomeScore,
                avgAwayScore,
                factors: {
                    efg: { 
                        home: homeTotals.efg || 0, 
                        away: awayTotals.efg || 0, 
                        diff: efgDiff, 
                        impact: efgImpact, 
                        weight: 40 
                    },
                    tov: { 
                        home: homeTotals.tovPct || 0, 
                        away: awayTotals.tovPct || 0, 
                        diff: -tovDiff,
                        impact: tovImpact, 
                        weight: 25 
                    },
                    oreb: { 
                        home: homeTotals.orebPct || 0, 
                        away: awayTotals.orebPct || 0, 
                        diff: orebDiff, 
                        impact: orebImpact, 
                        weight: 20 
                    },
                    ft: { 
                        home: homeTotals.ftaRate || 0, 
                        away: awayTotals.ftaRate || 0, 
                        diff: ftDiff, 
                        impact: ftImpact, 
                        weight: 15 
                    }
                },
                epa: {
                    toBattle: tovImpactHome,
                    orebBattle: orebImpactHome,
                    total: epaHome,
                    scoringBattle: scoringBattleHome,
                    efgImpact: efgImpactHome,
                    ftRateImpact: ftRateImpactHome
                },
                simulation: {
                    numSims: NUM_SIMULATIONS,
                    possessions: POSSESSIONS_PER_GAME,
                    stdDev: stdDev,
                    zScore: zScore,
                    advantageCount: advantageCount
                }
            };
        }

        renderWinProbability(homeTeam, awayTeam, homeTotals, awayTotals) {
            const wp = this.calculateWinProbability(homeTotals, awayTotals);
            
            const factorLabels = {
                efg: { name: 'eFG%', higherBetter: true },
                tov: { name: 'TOV%', higherBetter: false },
                oreb: { name: 'OREB%', higherBetter: true },
                ft: { name: 'FT Rate', higherBetter: true }
            };
            
            // Determine confidence level based on win probability differential
            const probDiff = Math.abs(wp.homeWinProb - 50);
            let confidenceLevel, confidenceColor;
            if (probDiff > 40) { 
                confidenceLevel = 'Very High'; 
                confidenceColor = 'var(--positive)'; 
            } else if (probDiff > 25) { 
                confidenceLevel = 'High'; 
                confidenceColor = 'var(--accent-emerald)'; 
            } else if (probDiff > 12) { 
                confidenceLevel = 'Moderate'; 
                confidenceColor = 'var(--accent-gold)'; 
            } else { 
                confidenceLevel = 'Low (Close)'; 
                confidenceColor = 'var(--accent-coral)'; 
            }
            
            // Determine game outcome tags
            const dominantProb = Math.max(wp.homeWinProb, wp.awayWinProb);
            const isBlowout = dominantProb > 85;
            const isLandslide = dominantProb > 95;
            
            return `
                <div class="stat-card glass-card full-width win-probability-card">
                    <div class="win-prob-header">
                        <div>
                            <div class="win-prob-title">
                                🎯 Win Probability (Four Factors Analysis)
                                ${isLandslide ? '<span class="blowout-tag">LANDSLIDE</span>' : 
                                  isBlowout ? '<span class="blowout-tag">DOMINANT</span>' : ''}
                            </div>
                            <div class="win-prob-subtitle">Four Factors analysis • EPA-based expected margin</div>
                        </div>
                        <div class="confidence-badge" style="color: ${confidenceColor}">
                            <span class="confidence-label">Confidence:</span>
                            <span class="confidence-value">${confidenceLevel}</span>
                        </div>
                    </div>
                    
                    <div class="win-prob-container">
                        <div class="win-prob-team">
                            <div class="win-prob-team-name">${homeTeam}</div>
                            <div class="win-prob-value home ${wp.homeWinProb > 50 ? 'dominant' : ''}">${wp.homeWinProb.toFixed(1)}%</div>
                            <div class="win-prob-ppp">
                                <span class="ppp-label">PPP:</span>
                                <span class="ppp-value home">${wp.homePPP.toFixed(3)}</span>
                            </div>
                        </div>
                        
                        <div class="win-prob-bar-container">
                            <div class="win-prob-bar home" style="width: ${wp.homeWinProb}%;"></div>
                            <div class="win-prob-bar away" style="width: ${wp.awayWinProb}%;"></div>
                            <div class="win-prob-margin">
                                <span class="margin-label">Expected Margin</span>
                                <span class="margin-value ${wp.expectedMargin >= 0 ? 'home' : 'away'}">
                                    ${wp.expectedMargin >= 0 ? '+' : ''}${wp.expectedMargin.toFixed(1)} pts
                                </span>
                            </div>
                        </div>
                        
                        <div class="win-prob-team">
                            <div class="win-prob-team-name">${awayTeam}</div>
                            <div class="win-prob-value away ${wp.awayWinProb > 50 ? 'dominant' : ''}">${wp.awayWinProb.toFixed(1)}%</div>
                            <div class="win-prob-ppp">
                                <span class="ppp-label">PPP:</span>
                                <span class="ppp-value away">${wp.awayPPP.toFixed(3)}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="win-prob-factors">
                        ${Object.entries(wp.factors).map(([key, factor]) => {
                            const label = factorLabels[key];
                            const homeWins = label.higherBetter ? factor.home > factor.away : factor.home < factor.away;
                            const displayDiff = key === 'tov' ? -factor.diff : factor.diff;
                            const diffClass = displayDiff > 0 ? 'positive' : displayDiff < 0 ? 'negative' : '';
                            
                            return `
                                <div class="win-prob-factor ${homeWins ? 'home-advantage' : 'away-advantage'}">
                                    <div class="win-prob-factor-header">
                                        <span class="win-prob-factor-label">${label.name}</span>
                                        <span class="win-prob-factor-winner">${homeWins ? '◀' : '▶'}</span>
                                    </div>
                                    <div class="win-prob-factor-values">
                                        <span class="win-prob-factor-value home ${homeWins ? 'winner' : ''}">${factor.home.toFixed(1)}</span>
                                        <span style="color: var(--text-muted);">vs</span>
                                        <span class="win-prob-factor-value away ${!homeWins ? 'winner' : ''}">${factor.away.toFixed(1)}</span>
                                    </div>
                                    <div class="win-prob-factor-diff ${diffClass}">${displayDiff > 0 ? '+' : ''}${displayDiff.toFixed(1)}</div>
                                    <div class="impact-bar-container">
                                        <div class="impact-bar ${homeWins ? 'home' : 'away'}" style="width: ${factor.impact}%;"></div>
                                    </div>
                                    <div class="win-prob-factor-weight">${factor.weight}% base weight</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    
                    <!-- EPA Metrics Section -->
                    <div class="epa-section" style="margin-top: 20px; padding: 16px; background: var(--bg-glass); border-radius: var(--radius-md);">
                        <div class="epa-header" style="font-size: 13px; font-weight: 700; color: var(--text-bright); margin-bottom: 12px;">
                            ⚡ EPA (Expected Possession Advantage) Breakdown
                        </div>
                        <div class="epa-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                            <div class="epa-item" style="text-align: center;">
                                <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 4px;">TO Battle</div>
                                <div style="font-size: 18px; font-weight: 700; color: ${wp.epa.toBattle >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                    ${wp.epa.toBattle >= 0 ? '+' : ''}${wp.epa.toBattle.toFixed(1)}
                                </div>
                                <div style="font-size: 9px; color: var(--text-muted);">extra possessions</div>
                            </div>
                            <div class="epa-item" style="text-align: center;">
                                <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 4px;">OREB Battle</div>
                                <div style="font-size: 18px; font-weight: 700; color: ${wp.epa.orebBattle >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                    ${wp.epa.orebBattle >= 0 ? '+' : ''}${wp.epa.orebBattle.toFixed(1)}
                                </div>
                                <div style="font-size: 9px; color: var(--text-muted);">second chance pts</div>
                            </div>
                            <div class="epa-item" style="text-align: center;">
                                <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 4px;">Scoring Battle</div>
                                <div style="font-size: 18px; font-weight: 700; color: ${wp.epa.scoringBattle >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                    ${wp.epa.scoringBattle >= 0 ? '+' : ''}${wp.epa.scoringBattle.toFixed(1)}
                                </div>
                                <div style="font-size: 9px; color: var(--text-muted);">eFG% impact pts</div>
                            </div>
                        </div>
                        <div style="text-align: center; margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-subtle);">
                            <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 4px;">Total EPA</div>
                            <div style="font-size: 22px; font-weight: 800; color: ${wp.epa.total >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                ${wp.epa.total >= 0 ? '+' : ''}${wp.epa.total.toFixed(1)} pts
                            </div>
                        </div>
                    </div>
                    
                    <div class="simulation-details">
                        <div class="sim-stat">
                            <span class="sim-label">Simulations</span>
                            <span class="sim-value">${wp.simulation.numSims.toLocaleString()}</span>
                        </div>
                        <div class="sim-stat">
                            <span class="sim-label">Possessions/Game</span>
                            <span class="sim-value">${wp.simulation.possessions}</span>
                        </div>
                        <div class="sim-stat">
                            <span class="sim-label">Margin Std Dev</span>
                            <span class="sim-value">±${wp.simulation.stdDev.toFixed(1)} pts</span>
                        </div>
                        <div class="sim-stat">
                            <span class="sim-label">Z-Score</span>
                            <span class="sim-value">${wp.simulation.zScore.toFixed(2)}</span>
                        </div>
                        <div class="sim-stat">
                            <span class="sim-label">Factor Advantages</span>
                            <span class="sim-value">${wp.simulation.advantageCount}/4</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // ========================================================================
        // GAME FLOW TAB - Score Margin & PPP Development Charts
        // ========================================================================
        
        renderGameFlowTab(homeTeam, awayTeam, homeTotals, awayTotals) {
            // Check if we have game flow data
            if (!this.gameFlowData || this.gameFlowData.length < 2) {
                return `
                    <div class="stat-card glass-card full-width" style="text-align: center; padding: 60px;">
                        <h3 style="color: var(--text-muted);">📈 Game Flow Data Not Available</h3>
                        <p style="color: var(--text-muted); margin-top: 16px;">Play-by-play data is required to generate game flow charts.</p>
                        <p style="color: var(--text-muted); margin-top: 8px;">Upload both boxscore and PBP files to see this analysis.</p>
                    </div>
                `;
            }
            
            // Calculate final stats
            const finalData = this.gameFlowData[this.gameFlowData.length - 1];
            const maxMargin = Math.max(...this.gameFlowData.map(d => Math.abs(d.margin)));
            const maxPPP = Math.max(...this.gameFlowData.map(d => Math.max(d.homePPP, d.awayPPP)));
            const minPPP = Math.min(...this.gameFlowData.filter(d => d.homePPP > 0 || d.awayPPP > 0).map(d => Math.min(d.homePPP || 99, d.awayPPP || 99)));
            
            // Calculate lead changes and biggest runs
            let leadChanges = 0;
            let currentLeader = null;
            let biggestHomeRun = 0;
            let biggestAwayRun = 0;
            let currentHomeRun = 0;
            let currentAwayRun = 0;
            let lastMargin = 0;
            
            for (const data of this.gameFlowData) {
                const newLeader = data.margin > 0 ? 'home' : (data.margin < 0 ? 'away' : null);
                if (newLeader && currentLeader && newLeader !== currentLeader) {
                    leadChanges++;
                }
                if (newLeader) currentLeader = newLeader;
                
                // Track runs
                const marginChange = data.margin - lastMargin;
                if (marginChange > 0) {
                    currentHomeRun += marginChange;
                    currentAwayRun = 0;
                    biggestHomeRun = Math.max(biggestHomeRun, currentHomeRun);
                } else if (marginChange < 0) {
                    currentAwayRun += Math.abs(marginChange);
                    currentHomeRun = 0;
                    biggestAwayRun = Math.max(biggestAwayRun, currentAwayRun);
                }
                lastMargin = data.margin;
            }
            
            return `
                <div class="game-flow-container">
                    ${this.renderRunsMomentumChart(homeTeam, awayTeam)}
                    ${this.renderScoreMarginChart(homeTeam, awayTeam, maxMargin)}
                    ${this.renderPossessionMarginChart(homeTeam, awayTeam)}
                    ${this.renderScoringBattleChart(homeTeam, awayTeam)}
                    ${this.renderPPPDevelopmentChart(homeTeam, awayTeam, maxPPP, minPPP)}
                    
                    <div class="flow-stats-summary">
                        <div class="flow-stat-item">
                            <span class="flow-stat-label">Final Score</span>
                            <span class="flow-stat-value ${homeTotals.points > awayTotals.points ? 'home' : 'away'}">${homeTotals.points} - ${awayTotals.points}</span>
                        </div>
                        <div class="flow-stat-item">
                            <span class="flow-stat-label">Lead Changes</span>
                            <span class="flow-stat-value">${leadChanges}</span>
                        </div>
                        <div class="flow-stat-item">
                            <span class="flow-stat-label">Biggest ${homeTeam.split(' ')[0]} Run</span>
                            <span class="flow-stat-value home">${biggestHomeRun}-0</span>
                        </div>
                        <div class="flow-stat-item">
                            <span class="flow-stat-label">Biggest ${awayTeam.split(' ')[0]} Run</span>
                            <span class="flow-stat-value away">0-${biggestAwayRun}</span>
                        </div>
                        <div class="flow-stat-item">
                            <span class="flow-stat-label">Final EPA</span>
                            <span class="flow-stat-value ${(finalData.epa || 0) >= 0 ? 'home' : 'away'}">${(finalData.epa || 0) >= 0 ? '+' : ''}${(finalData.epa || 0).toFixed(1)} pts</span>
                        </div>
                        <div class="flow-stat-item">
                            <span class="flow-stat-label">${homeTeam.split(' ')[0]} PPP</span>
                            <span class="flow-stat-value home">${(finalData.homePPP || 0).toFixed(3)}</span>
                        </div>
                        <div class="flow-stat-item">
                            <span class="flow-stat-label">${awayTeam.split(' ')[0]} PPP</span>
                            <span class="flow-stat-value away">${(finalData.awayPPP || 0).toFixed(3)}</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        renderRunsMomentumChart(homeTeam, awayTeam) {
            const data = this.gameFlowData;
            if (!data || data.length < 2) return '';
            
            const hasPlayerRuns = this.playerRuns && this.playerRuns.length > 0;
            const hasTeamRuns = this.teamMomentumRuns && this.teamMomentumRuns.length > 0;
            
            // Calculate max elapsed time for positioning
            const maxElapsed = Math.max(...data.map(d => d.elapsed));
            const maxPeriod = Math.max(...data.map(d => d.period));
            
            // Generate timeline labels
            const timelineLabels = [];
            for (let p = 1; p <= maxPeriod; p++) {
                let periodEnd;
                if (p <= 4) {
                    periodEnd = p * 600;
                } else {
                    periodEnd = 2400 + (p - 4) * 300;
                }
                const percent = Math.min((periodEnd / maxElapsed) * 100, 100);
                const label = p <= 4 ? `Q${p}` : `OT${p-4}`;
                timelineLabels.push({ percent, label });
            }
            
            // Render timeline axis
            const renderTimeline = () => {
                return timelineLabels.map(t => `
                    <span class="timeline-label" style="left: ${t.percent}%;">${t.label}</span>
                `).join('');
            };
            
            // Render player run markers - UP for home, DOWN for away
            const renderPlayerRuns = () => {
                if (!hasPlayerRuns) return '<div class="no-runs-message">No individual player runs (6+ pts) detected</div>';
                
                return this.playerRuns.map((run, idx) => {
                    const centerPercent = ((run.startElapsed + run.endElapsed) / 2 / maxElapsed) * 100;
                    const teamClass = run.teamIdx === 0 ? 'home' : 'away';
                    
                    // Calculate height based on points (more points = taller bar)
                    const minHeight = 50;
                    const maxHeight = 90;
                    const heightPx = Math.min(maxHeight, minHeight + (run.points - 6) * 8);
                    
                    // Calculate width based on duration (seconds)
                    // Parse duration string like "2:30" or "1:15"
                    const durationParts = run.duration.split(':');
                    const durationSeconds = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1] || 0);
                    
                    // Width: min 55px, max 140px, scaled by duration
                    // Base: 55px for runs under 30 seconds, up to 140px for runs over 3 minutes
                    const minWidth = 55;
                    const maxWidth = 140;
                    const widthPx = Math.min(maxWidth, Math.max(minWidth, minWidth + (durationSeconds / 180) * (maxWidth - minWidth)));
                    
                    return `
                        <div class="run-marker ${teamClass}" 
                             style="left: ${centerPercent}%; height: ${heightPx}px; width: ${widthPx}px;"
                             title="${run.playerName}: ${run.points} pts in ${run.duration}\n${run.startScore} → ${run.endScore}">
                            <span class="run-marker-player">${run.playerName}</span>
                            <span class="run-marker-stats">${run.points} pts</span>
                            <span class="run-marker-duration">⏱ ${run.duration}</span>
                        </div>
                    `;
                }).join('');
            };
            
            // Render team momentum markers - UP for home, DOWN for away
            const renderTeamMomentum = () => {
                if (!hasTeamRuns) return '<div class="no-runs-message">No team momentum runs (6+ pts) detected</div>';
                
                return this.teamMomentumRuns.map((run, idx) => {
                    const centerPercent = ((run.startElapsed + run.endElapsed) / 2 / maxElapsed) * 100;
                    const teamClass = run.teamIdx === 0 ? 'home' : 'away';
                    
                    // Calculate height based on points
                    const minHeight = 55;
                    const maxHeight = 90;
                    const heightPx = Math.min(maxHeight, minHeight + (run.points - 6) * 6);
                    
                    // Calculate width based on duration (seconds)
                    const durationParts = run.duration.split(':');
                    const durationSeconds = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1] || 0);
                    
                    // Width: min 65px, max 150px, scaled by duration
                    const minWidth = 65;
                    const maxWidth = 150;
                    const widthPx = Math.min(maxWidth, Math.max(minWidth, minWidth + (durationSeconds / 180) * (maxWidth - minWidth)));
                    
                    // Get full lineup names for hover tooltip
                    const fullLineupNames = this.getLineupNames(run.lineup, true);
                    
                    return `
                        <div class="momentum-marker ${teamClass}" 
                             style="left: ${centerPercent}%; height: ${heightPx}px; width: ${widthPx}px;"
                             title="${run.team}: ${run.scoreDiff} in ${run.duration}"
                             data-lineup="Lineup:\n${fullLineupNames}\n\nTop: ${run.topScorer} (${run.topScorerPoints} pts)">
                            <span class="momentum-score">${run.scoreDiff}</span>
                            <span class="momentum-time">${run.duration}</span>
                            <span class="momentum-top-scorer">${run.topScorer} ${run.topScorerPoints}pts</span>
                        </div>
                    `;
                }).join('');
            };
            
            // Count runs by team
            const homePlayerRuns = this.playerRuns?.filter(r => r.teamIdx === 0).length || 0;
            const awayPlayerRuns = this.playerRuns?.filter(r => r.teamIdx === 1).length || 0;
            const homeTeamRuns = this.teamMomentumRuns?.filter(r => r.teamIdx === 0).length || 0;
            const awayTeamRuns = this.teamMomentumRuns?.filter(r => r.teamIdx === 1).length || 0;
            
            return `
                <!-- Player Runs Chart -->
                <div class="runs-momentum-container">
                    <div class="runs-momentum-header">
                        <span class="runs-momentum-title">🔥 Player Scoring Runs (6+ consecutive pts)</span>
                        <div class="flow-chart-legend">
                            <div class="legend-item">
                                <span class="legend-line home"></span>
                                <span style="color: var(--team-home);">${homeTeam} (${homePlayerRuns})</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-line away"></span>
                                <span style="color: var(--team-away);">${awayTeam} (${awayPlayerRuns})</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="runs-chart-wrapper">
                        <div class="runs-track-unified">
                            <span class="runs-track-label-left top">${homeTeam.split(' ')[0]}</span>
                            <span class="runs-track-label-left bottom">${awayTeam.split(' ')[0]}</span>
                            <div class="runs-track-center-line"></div>
                            ${renderPlayerRuns()}
                        </div>
                        
                        <div class="runs-timeline-axis">
                            ${renderTimeline()}
                        </div>
                    </div>
                </div>
                
                <!-- Team Momentum Runs Chart -->
                <div class="runs-momentum-container">
                    <div class="runs-momentum-header">
                        <span class="runs-momentum-title">⚡ Team Momentum Runs (6+ consecutive pts by lineup)</span>
                        <div class="flow-chart-legend">
                            <div class="legend-item">
                                <span class="legend-line home"></span>
                                <span style="color: var(--team-home);">${homeTeam} (${homeTeamRuns})</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-line away"></span>
                                <span style="color: var(--team-away);">${awayTeam} (${awayTeamRuns})</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="runs-chart-wrapper">
                        <div class="runs-track-unified">
                            <span class="runs-track-label-left top">${homeTeam.split(' ')[0]}</span>
                            <span class="runs-track-label-left bottom">${awayTeam.split(' ')[0]}</span>
                            <div class="runs-track-center-line"></div>
                            ${renderTeamMomentum()}
                        </div>
                        
                        <div class="runs-timeline-axis">
                            ${renderTimeline()}
                        </div>
                    </div>
                </div>
            `;
        }
        
        renderScoreMarginChart(homeTeam, awayTeam, maxMargin) {
            const data = this.gameFlowData;
            if (!data || data.length < 2) return '';
            
            // Chart dimensions
            const width = 800;
            const height = 240;
            const padding = { top: 20, right: 60, bottom: 40, left: 50 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Calculate max elapsed time (handle OT)
            const maxElapsed = Math.max(...data.map(d => d.elapsed));
            const maxPeriod = Math.max(...data.map(d => d.period));
            
            // Scale Y axis symmetrically around 0
            const yMax = Math.max(30, Math.ceil(maxMargin / 5) * 5 + 5);
            
            // Generate path for the margin line
            const points = data.map(d => {
                const x = padding.left + (d.elapsed / maxElapsed) * chartWidth;
                const y = padding.top + chartHeight / 2 - (d.margin / yMax) * (chartHeight / 2);
                return { x, y, margin: d.margin, elapsed: d.elapsed };
            });
            
            // Create path string
            const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`).join(' ');
            
            // Create fill area (fill to zero line)
            const zeroY = padding.top + chartHeight / 2;
            let fillPath = '';
            let currentFill = '';
            
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const newFill = p.margin >= 0 ? 'positive' : 'negative';
                
                if (newFill !== currentFill || i === 0) {
                    if (currentFill) {
                        fillPath += ` L ${points[i-1].x.toFixed(1)} ${zeroY} Z" class="flow-area ${currentFill}"/>`;
                    }
                    fillPath += `<path d="M ${p.x.toFixed(1)} ${zeroY} L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                    currentFill = newFill;
                } else {
                    fillPath += ` L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                }
            }
            if (currentFill) {
                fillPath += ` L ${points[points.length-1].x.toFixed(1)} ${zeroY} Z" class="flow-area ${currentFill}"/>`;
            }
            
            // Period lines
            let periodLines = '';
            for (let p = 1; p <= maxPeriod; p++) {
                let periodEnd;
                if (p <= 4) {
                    periodEnd = p * 600;
                } else {
                    periodEnd = 2400 + (p - 4) * 300;
                }
                if (periodEnd < maxElapsed) {
                    const x = padding.left + (periodEnd / maxElapsed) * chartWidth;
                    periodLines += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" class="flow-period-line"/>`;
                    const label = p <= 4 ? `P${p}` : `OT${p-4}`;
                    periodLines += `<text x="${x}" y="${height - 8}" class="flow-period-label" text-anchor="middle">${label}</text>`;
                }
            }
            
            // Y-axis labels
            const yLabels = [];
            for (let v = -yMax; v <= yMax; v += 10) {
                const y = padding.top + chartHeight / 2 - (v / yMax) * (chartHeight / 2);
                yLabels.push(`<text x="${padding.left - 8}" y="${y + 4}" class="flow-axis-label" text-anchor="end">${v > 0 ? '+' : ''}${v}</text>`);
                yLabels.push(`<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" class="flow-axis-line"/>`);
            }
            
            return `
                <div class="flow-chart-card">
                    <div class="flow-chart-header">
                        <span class="flow-chart-title">📊 Scoring Development (Score Margin)</span>
                        <div class="flow-chart-legend">
                            <div class="legend-item">
                                <span class="legend-line home"></span>
                                <span style="color: var(--team-home);">${homeTeam} Lead</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-line away"></span>
                                <span style="color: var(--team-away);">${awayTeam} Lead</span>
                            </div>
                        </div>
                    </div>
                    <svg class="flow-chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                        <!-- Y-axis lines and labels -->
                        ${yLabels.join('\n')}
                        
                        <!-- Zero line -->
                        <line x1="${padding.left}" y1="${zeroY}" x2="${width - padding.right}" y2="${zeroY}" class="flow-zero-line"/>
                        
                        <!-- Period dividers -->
                        ${periodLines}
                        
                        <!-- Fill areas -->
                        ${fillPath}
                        
                        <!-- Main margin line (segmented by positive/negative) -->
                        ${this.generateSegmentedLinePaths(points, 'margin')}
                        
                        <!-- Y-axis title -->
                        <text x="12" y="${height / 2}" class="flow-axis-label" text-anchor="middle" transform="rotate(-90, 12, ${height / 2})">Score Margin</text>
                    </svg>
                </div>
            `;
        }
        
        renderPossessionMarginChart(homeTeam, awayTeam) {
            const data = this.gameFlowData;
            if (!data || data.length < 2) return '';
            
            // Chart dimensions
            const width = 800;
            const height = 240;
            const padding = { top: 20, right: 60, bottom: 40, left: 50 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Calculate max elapsed time (handle OT)
            const maxElapsed = Math.max(...data.map(d => d.elapsed));
            const maxPeriod = Math.max(...data.map(d => d.period));
            
            // Calculate max EPA for Y-axis scaling
            const maxEPA = Math.max(...data.map(d => Math.abs(d.epa || 0)));
            
            // Scale Y axis symmetrically around 0
            const yMax = Math.max(5, Math.ceil(maxEPA) + 2);
            
            // Generate path for the EPA line
            const points = data.map(d => {
                const x = padding.left + (d.elapsed / maxElapsed) * chartWidth;
                const epa = d.epa || 0;
                const y = padding.top + chartHeight / 2 - (epa / yMax) * (chartHeight / 2);
                return { x, y, epa: epa, elapsed: d.elapsed, toMargin: d.toMargin || 0, orebMargin: d.orebMargin || 0 };
            });
            
            // Create path string
            const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`).join(' ');
            
            // Create fill area (fill to zero line)
            const zeroY = padding.top + chartHeight / 2;
            let fillPath = '';
            let currentFill = '';
            
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const newFill = p.epa >= 0 ? 'positive' : 'negative';
                
                if (newFill !== currentFill || i === 0) {
                    if (currentFill) {
                        fillPath += ` L ${points[i-1].x.toFixed(1)} ${zeroY} Z" class="flow-area ${currentFill}"/>`;
                    }
                    fillPath += `<path d="M ${p.x.toFixed(1)} ${zeroY} L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                    currentFill = newFill;
                } else {
                    fillPath += ` L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                }
            }
            if (currentFill) {
                fillPath += ` L ${points[points.length-1].x.toFixed(1)} ${zeroY} Z" class="flow-area ${currentFill}"/>`;
            }
            
            // Period lines
            let periodLines = '';
            for (let p = 1; p <= maxPeriod; p++) {
                let periodEnd;
                if (p <= 4) {
                    periodEnd = p * 600;
                } else {
                    periodEnd = 2400 + (p - 4) * 300;
                }
                if (periodEnd < maxElapsed) {
                    const x = padding.left + (periodEnd / maxElapsed) * chartWidth;
                    periodLines += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" class="flow-period-line"/>`;
                    const label = p <= 4 ? `P${p}` : `OT${p-4}`;
                    periodLines += `<text x="${x}" y="${height - 8}" class="flow-period-label" text-anchor="middle">${label}</text>`;
                }
            }
            
            // Y-axis labels (show as expected points)
            const yLabels = [];
            const step = yMax > 15 ? 5 : (yMax > 8 ? 4 : 2);
            for (let v = -yMax; v <= yMax; v += step) {
                const y = padding.top + chartHeight / 2 - (v / yMax) * (chartHeight / 2);
                yLabels.push(`<text x="${padding.left - 8}" y="${y + 4}" class="flow-axis-label" text-anchor="end">${v > 0 ? '+' : ''}${v.toFixed(0)}</text>`);
                yLabels.push(`<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" class="flow-axis-line"/>`);
            }
            
            const finalEPA = points[points.length - 1].epa;
            const finalToMargin = points[points.length - 1].toMargin;
            const finalOrebMargin = points[points.length - 1].orebMargin;
            
            return `
                <div class="flow-chart-card">
                    <div class="flow-chart-header">
                        <span class="flow-chart-title">⚔️ Expected Points Added (EPA)</span>
                        <div class="flow-chart-legend">
                            <div class="legend-item">
                                <span class="legend-line home"></span>
                                <span style="color: var(--team-home);">${homeTeam} Advantage</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-line away"></span>
                                <span style="color: var(--team-away);">${awayTeam} Advantage</span>
                            </div>
                        </div>
                    </div>
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; padding: 0 16px;">
                        EPA = (TO Margin + OREB Margin) × 1.05 PPP | 
                        <span style="color: ${finalToMargin >= 0 ? 'var(--team-home)' : 'var(--team-away)'}">TO: ${finalToMargin >= 0 ? '+' : ''}${finalToMargin}</span> | 
                        <span style="color: ${finalOrebMargin >= 0 ? 'var(--team-home)' : 'var(--team-away)'}">OREB: ${finalOrebMargin >= 0 ? '+' : ''}${finalOrebMargin}</span>
                    </div>
                    <svg class="flow-chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                        <!-- Y-axis lines and labels -->
                        ${yLabels.join('\n')}
                        
                        <!-- Zero line -->
                        <line x1="${padding.left}" y1="${zeroY}" x2="${width - padding.right}" y2="${zeroY}" class="flow-zero-line"/>
                        
                        <!-- Period dividers -->
                        ${periodLines}
                        
                        <!-- Fill areas -->
                        ${fillPath}
                        
                        <!-- Main EPA line (segmented by positive/negative) -->
                        ${this.generateSegmentedLinePaths(points, 'epa')}
                        
                        <!-- Y-axis title -->
                        <text x="12" y="${height / 2}" class="flow-axis-label" text-anchor="middle" transform="rotate(-90, 12, ${height / 2})">EPA (pts)</text>
                        
                        <!-- End value label -->
                        <text x="${points[points.length-1].x + 8}" y="${points[points.length-1].y + 4}" 
                              fill="${finalEPA >= 0 ? 'var(--team-home)' : 'var(--team-away)'}" 
                              font-size="11" font-weight="600">${finalEPA >= 0 ? '+' : ''}${finalEPA.toFixed(1)}</text>
                    </svg>
                </div>
            `;
        }
        
        renderScoringBattleChart(homeTeam, awayTeam) {
            const rawData = this.gameFlowData;
            if (!rawData || rawData.length < 2) return '';
            
            // Buffer the chart until both teams have scored to avoid early disparity
            const firstBothScoredIndex = rawData.findIndex(d => d.homePoints > 0 && d.awayPoints > 0);
            const data = firstBothScoredIndex >= 0 ? rawData.slice(firstBothScoredIndex) : rawData;
            if (data.length < 2) return '';
            
            // Chart dimensions
            const width = 800;
            const height = 240;
            const padding = { top: 20, right: 60, bottom: 40, left: 50 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Calculate max elapsed time (handle OT) - use full game time for consistent x-axis
            const maxElapsed = Math.max(...rawData.map(d => d.elapsed));
            const maxPeriod = Math.max(...rawData.map(d => d.period));
            
            // Calculate max Scoring Battle for Y-axis scaling (from buffered data)
            const maxSB = Math.max(...data.map(d => Math.abs(d.scoringBattle || 0)));
            
            // Scale Y axis symmetrically around 0
            const yMax = Math.max(5, Math.ceil(maxSB) + 2);
            
            // Generate path for the Scoring Battle line
            const points = data.map(d => {
                const x = padding.left + (d.elapsed / maxElapsed) * chartWidth;
                const sb = d.scoringBattle || 0;
                const y = padding.top + chartHeight / 2 - (sb / yMax) * (chartHeight / 2);
                return { x, y, scoringBattle: sb, elapsed: d.elapsed, efgMargin: d.efgMargin || 0, ftRateMargin: d.ftRateMargin || 0 };
            });
            
            // Create path string
            const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`).join(' ');
            
            // Create fill area (fill to zero line)
            const zeroY = padding.top + chartHeight / 2;
            let fillPath = '';
            let currentFill = '';
            
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const newFill = p.scoringBattle >= 0 ? 'positive' : 'negative';
                
                if (newFill !== currentFill || i === 0) {
                    if (currentFill) {
                        fillPath += ` L ${points[i-1].x.toFixed(1)} ${zeroY} Z" class="flow-area ${currentFill}"/>`;
                    }
                    fillPath += `<path d="M ${p.x.toFixed(1)} ${zeroY} L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                    currentFill = newFill;
                } else {
                    fillPath += ` L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                }
            }
            if (currentFill) {
                fillPath += ` L ${points[points.length-1].x.toFixed(1)} ${zeroY} Z" class="flow-area ${currentFill}"/>`;
            }
            
            // Period lines
            let periodLines = '';
            for (let p = 1; p <= maxPeriod; p++) {
                let periodEnd;
                if (p <= 4) {
                    periodEnd = p * 600;
                } else {
                    periodEnd = 2400 + (p - 4) * 300;
                }
                if (periodEnd < maxElapsed) {
                    const x = padding.left + (periodEnd / maxElapsed) * chartWidth;
                    periodLines += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" class="flow-period-line"/>`;
                    const label = p <= 4 ? `P${p}` : `OT${p-4}`;
                    periodLines += `<text x="${x}" y="${height - 8}" class="flow-period-label" text-anchor="middle">${label}</text>`;
                }
            }
            
            // Y-axis labels (show as expected points)
            const yLabels = [];
            const step = yMax > 15 ? 5 : (yMax > 8 ? 4 : 2);
            for (let v = -yMax; v <= yMax; v += step) {
                const y = padding.top + chartHeight / 2 - (v / yMax) * (chartHeight / 2);
                yLabels.push(`<text x="${padding.left - 8}" y="${y + 4}" class="flow-axis-label" text-anchor="end">${v > 0 ? '+' : ''}${v.toFixed(0)}</text>`);
                yLabels.push(`<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" class="flow-axis-line"/>`);
            }
            
            const finalSB = points[points.length - 1].scoringBattle;
            const finalEfgMargin = points[points.length - 1].efgMargin;
            const finalFtRateMargin = points[points.length - 1].ftRateMargin;
            
            return `
                <div class="flow-chart-card">
                    <div class="flow-chart-header">
                        <span class="flow-chart-title">🎯 Scoring Battle (eFG% + FT Rate)</span>
                        <div class="flow-chart-legend">
                            <div class="legend-item">
                                <span class="legend-line home"></span>
                                <span style="color: var(--team-home);">${homeTeam} Advantage</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-line away"></span>
                                <span style="color: var(--team-away);">${awayTeam} Advantage</span>
                            </div>
                        </div>
                    </div>
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; padding: 0 16px;">
                        SB = (eFG% Margin × 1.77 + FT Rate Margin × 0.25) × Pace/100 | 
                        <span style="color: ${finalEfgMargin >= 0 ? 'var(--team-home)' : 'var(--team-away)'}">eFG%: ${finalEfgMargin >= 0 ? '+' : ''}${finalEfgMargin.toFixed(1)}</span> | 
                        <span style="color: ${finalFtRateMargin >= 0 ? 'var(--team-home)' : 'var(--team-away)'}">FT Rate: ${finalFtRateMargin >= 0 ? '+' : ''}${finalFtRateMargin.toFixed(1)}</span>
                    </div>
                    <svg class="flow-chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                        <!-- Y-axis lines and labels -->
                        ${yLabels.join('\n')}
                        
                        <!-- Zero line -->
                        <line x1="${padding.left}" y1="${zeroY}" x2="${width - padding.right}" y2="${zeroY}" class="flow-zero-line"/>
                        
                        <!-- Period dividers -->
                        ${periodLines}
                        
                        <!-- Fill areas -->
                        ${fillPath}
                        
                        <!-- Main Scoring Battle line (segmented by positive/negative) -->
                        ${this.generateSegmentedLinePaths(points, 'scoringBattle')}
                        
                        <!-- Y-axis title -->
                        <text x="12" y="${height / 2}" class="flow-axis-label" text-anchor="middle" transform="rotate(-90, 12, ${height / 2})">SB (pts)</text>
                        
                        <!-- End value label -->
                        <text x="${points[points.length-1].x + 8}" y="${points[points.length-1].y + 4}" 
                              fill="${finalSB >= 0 ? 'var(--team-home)' : 'var(--team-away)'}" 
                              font-size="11" font-weight="600">${finalSB >= 0 ? '+' : ''}${finalSB.toFixed(1)}</text>
                    </svg>
                </div>
            `;
        }
        
        renderPPPDevelopmentChart(homeTeam, awayTeam, maxPPP, minPPP) {
            const data = this.gameFlowData.filter(d => d.homePPP > 0 || d.awayPPP > 0);
            if (!data || data.length < 2) return '';
            
            // Chart dimensions
            const width = 800;
            const height = 240;
            const padding = { top: 20, right: 60, bottom: 40, left: 50 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Calculate max elapsed time
            const maxElapsed = Math.max(...data.map(d => d.elapsed));
            const maxPeriod = Math.max(...data.map(d => d.period));
            
            // Scale Y axis for PPP (typically 0.8 to 1.4)
            const yMin = Math.max(0, Math.floor((minPPP - 0.1) * 10) / 10);
            const yMax = Math.min(2.0, Math.ceil((maxPPP + 0.1) * 10) / 10);
            const yRange = yMax - yMin;
            
            // Generate paths for home and away PPP lines
            const homePoints = data.filter(d => d.homePPP > 0).map(d => {
                const x = padding.left + (d.elapsed / maxElapsed) * chartWidth;
                const y = padding.top + chartHeight - ((d.homePPP - yMin) / yRange) * chartHeight;
                return { x, y, ppp: d.homePPP };
            });
            
            const awayPoints = data.filter(d => d.awayPPP > 0).map(d => {
                const x = padding.left + (d.elapsed / maxElapsed) * chartWidth;
                const y = padding.top + chartHeight - ((d.awayPPP - yMin) / yRange) * chartHeight;
                return { x, y, ppp: d.awayPPP };
            });
            
            // Create path strings
            const homePathD = homePoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`).join(' ');
            const awayPathD = awayPoints.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`).join(' ');
            
            // Period lines
            let periodLines = '';
            for (let p = 1; p <= maxPeriod; p++) {
                let periodEnd;
                if (p <= 4) {
                    periodEnd = p * 600;
                } else {
                    periodEnd = 2400 + (p - 4) * 300;
                }
                if (periodEnd < maxElapsed) {
                    const x = padding.left + (periodEnd / maxElapsed) * chartWidth;
                    periodLines += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" class="flow-period-line"/>`;
                    const label = p <= 4 ? `P${p}` : `OT${p-4}`;
                    periodLines += `<text x="${x}" y="${height - 8}" class="flow-period-label" text-anchor="middle">${label}</text>`;
                }
            }
            
            // Y-axis labels (PPP values)
            const yLabels = [];
            const step = yRange > 0.6 ? 0.2 : 0.1;
            for (let v = yMin; v <= yMax; v += step) {
                const y = padding.top + chartHeight - ((v - yMin) / yRange) * chartHeight;
                yLabels.push(`<text x="${padding.left - 8}" y="${y + 4}" class="flow-axis-label" text-anchor="end">${v.toFixed(2)}</text>`);
                yLabels.push(`<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" class="flow-axis-line"/>`);
            }
            
            // 1.0 PPP reference line (league average)
            const avgY = padding.top + chartHeight - ((1.0 - yMin) / yRange) * chartHeight;
            
            return `
                <div class="flow-chart-card">
                    <div class="flow-chart-header">
                        <span class="flow-chart-title">📈 Points Per Possession Development</span>
                        <div class="flow-chart-legend">
                            <div class="legend-item">
                                <span class="legend-line home"></span>
                                <span style="color: var(--team-home);">${homeTeam}</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-line away"></span>
                                <span style="color: var(--team-away);">${awayTeam}</span>
                            </div>
                        </div>
                    </div>
                    <svg class="flow-chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                        <!-- Y-axis lines and labels -->
                        ${yLabels.join('\n')}
                        
                        <!-- 1.0 PPP reference line -->
                        ${avgY >= padding.top && avgY <= height - padding.bottom ? 
                            `<line x1="${padding.left}" y1="${avgY}" x2="${width - padding.right}" y2="${avgY}" 
                                   stroke="rgba(255, 255, 255, 0.4)" stroke-width="1" stroke-dasharray="6 3"/>
                             <text x="${width - padding.right + 5}" y="${avgY + 4}" class="flow-axis-label" text-anchor="start">1.00</text>` : ''}
                        
                        <!-- Period dividers -->
                        ${periodLines}
                        
                        <!-- PPP lines -->
                        <path d="${homePathD}" class="flow-line home"/>
                        <path d="${awayPathD}" class="flow-line away"/>
                        
                        <!-- Y-axis title -->
                        <text x="12" y="${height / 2}" class="flow-axis-label" text-anchor="middle" transform="rotate(-90, 12, ${height / 2})">PPP</text>
                        
                        <!-- End markers -->
                        ${homePoints.length > 0 ? `<circle cx="${homePoints[homePoints.length-1].x}" cy="${homePoints[homePoints.length-1].y}" r="4" fill="var(--team-home)"/>` : ''}
                        ${awayPoints.length > 0 ? `<circle cx="${awayPoints[awayPoints.length-1].x}" cy="${awayPoints[awayPoints.length-1].y}" r="4" fill="var(--team-away)"/>` : ''}
                        
                        <!-- End value labels -->
                        ${homePoints.length > 0 ? `<text x="${homePoints[homePoints.length-1].x + 8}" y="${homePoints[homePoints.length-1].y + 4}" fill="var(--team-home)" font-size="11" font-weight="600">${homePoints[homePoints.length-1].ppp.toFixed(3)}</text>` : ''}
                        ${awayPoints.length > 0 ? `<text x="${awayPoints[awayPoints.length-1].x + 8}" y="${awayPoints[awayPoints.length-1].y + 4}" fill="var(--team-away)" font-size="11" font-weight="600">${awayPoints[awayPoints.length-1].ppp.toFixed(3)}</text>` : ''}
                    </svg>
                </div>
            `;
        }

        renderPlayerTable(teamName, teamData, isWin, teamTotals, isHomeTeam, globalRanges, gameAvg, tableId = '') {
            const players = teamData.players.filter(p => p.minutes >= 5).sort((a, b) => b.minutes - a.minutes);
            const teamClass = isHomeTeam ? 'home' : 'away';
            const teamColor = isHomeTeam ? 'var(--team-home)' : 'var(--team-away)';
            const fillClass = isHomeTeam ? 'cyan' : 'magenta';
            const uniqueId = tableId || `table-${teamName.replace(/\s+/g, '-')}-${Date.now()}`;
            
            // Group display names
            const groupNames = {
                scoring: 'Scoring',
                usage: 'Usage', 
                shotdist: 'Shot Dist',
                offcourt: 'Off On-Court',
                defcourt: 'Def On-Court',
                individual: 'Individual'
            };
            
            return `
                <div class="team-section glass-card" data-table-id="${uniqueId}">
                    <div class="team-section-header">
                        <h3><span class="team-indicator ${teamClass}"></span>${teamName}</h3>
                        <span class="points-badge ${isWin ? 'win' : 'loss'}">${teamTotals.points} PTS • ${isWin ? 'WIN' : 'LOSS'}</span>
                    </div>
                    <div class="collapsed-groups-bar" id="collapsed-bar-${uniqueId}">
                        <span class="label">Show:</span>
                        ${Object.entries(groupNames).map(([key, name]) => `
                            <span class="collapsed-group-chip" data-group="${key}" data-table="${uniqueId}" 
                                  onclick="window.fibaVisualizer.toggleColumnGroup('${uniqueId}', '${key}')">${name}</span>
                        `).join('')}
                        <button class="expand-all-btn" onclick="window.fibaVisualizer.expandAllGroups('${uniqueId}')">Expand All</button>
                    </div>
                    <div class="table-controls" style="display: none;">
                        <span class="sort-indicator">Click column headers to sort</span>
                        <button class="collapse-all-btn" data-table="${uniqueId}" onclick="window.fibaVisualizer.toggleAllGroups('${uniqueId}')">Toggle All Groups</button>
                    </div>
                    <div class="player-table-wrapper">
                        <table class="player-table sticky-col" id="${uniqueId}">
                            <thead>
                                <tr>
                                    <th class="sticky-header"></th>
                                    <th colspan="6" class="col-group col-group-header" data-group="scoring" onclick="window.fibaVisualizer.toggleColumnGroup('${uniqueId}', 'scoring')">Scoring</th>
                                    <th colspan="3" class="col-group col-group-header" data-group="usage" onclick="window.fibaVisualizer.toggleColumnGroup('${uniqueId}', 'usage')">Usage</th>
                                    <th colspan="6" class="col-group col-group-header shot-dist" data-group="shotdist" onclick="window.fibaVisualizer.toggleColumnGroup('${uniqueId}', 'shotdist')">Shot Distribution</th>
                                    <th colspan="4" class="col-group col-group-header off-impact" data-group="offcourt" onclick="window.fibaVisualizer.toggleColumnGroup('${uniqueId}', 'offcourt')">Offensive On-Court</th>
                                    <th colspan="5" class="col-group col-group-header def-impact" data-group="defcourt" onclick="window.fibaVisualizer.toggleColumnGroup('${uniqueId}', 'defcourt')">Defensive On-Court</th>
                                    <th colspan="7" class="col-group col-group-header" data-group="individual" onclick="window.fibaVisualizer.toggleColumnGroup('${uniqueId}', 'individual')">Individual</th>
                                </tr>
                                <tr>
                                    <th class="sticky-header sortable-header" data-sort="name" data-table="${uniqueId}" style="text-align: left;">Player</th>
                                    <th class="sortable-header" data-sort="fgm" data-table="${uniqueId}" data-group="scoring">Made</th>
                                    <th class="sortable-header" data-sort="ast" data-table="${uniqueId}" data-group="scoring">AST</th>
                                    <th class="sortable-header col-separator" data-sort="points" data-table="${uniqueId}" data-group="scoring">PTS</th>
                                    <th class="sortable-header" data-sort="pointsAssisted" data-table="${uniqueId}" data-group="scoring">+AST</th>
                                    <th class="sortable-header" data-sort="totalPointContribution" data-table="${uniqueId}" data-group="scoring">TPC</th>
                                    <th class="sortable-header col-separator" data-sort="ppp" data-table="${uniqueId}" data-group="scoring">PPP</th>
                                    <th class="sortable-header" data-sort="usg" data-table="${uniqueId}" data-group="usage">USG</th>
                                    <th class="sortable-header" data-sort="astUsgRatio" data-table="${uniqueId}" data-group="usage">A/U</th>
                                    <th class="sortable-header col-separator" data-sort="minutes" data-table="${uniqueId}" data-group="usage">MIN</th>
                                    <th class="sortable-header" data-sort="rimAtt" data-table="${uniqueId}" data-group="shotdist">RIM</th>
                                    <th class="sortable-header zone-end" data-sort="rimPct" data-table="${uniqueId}" data-group="shotdist">RIM%</th>
                                    <th class="sortable-header" data-sort="midAtt" data-table="${uniqueId}" data-group="shotdist">MID</th>
                                    <th class="sortable-header zone-end" data-sort="midPct" data-table="${uniqueId}" data-group="shotdist">MID%</th>
                                    <th class="sortable-header" data-sort="fg3a" data-table="${uniqueId}" data-group="shotdist">3PT</th>
                                    <th class="sortable-header col-separator" data-sort="threePct" data-table="${uniqueId}" data-group="shotdist">3PT%</th>
                                    <th class="sortable-header" data-sort="onCourtORtg" data-table="${uniqueId}" data-group="offcourt">ORtg</th>
                                    <th class="sortable-header" data-sort="onCourtEfg" data-table="${uniqueId}" data-group="offcourt">eFG</th>
                                    <th class="sortable-header" data-sort="onCourtOrebPct" data-table="${uniqueId}" data-group="offcourt">ORB%</th>
                                    <th class="sortable-header col-separator" data-sort="onCourtTovPct" data-table="${uniqueId}" data-group="offcourt">TOV%</th>
                                    <th class="sortable-header" data-sort="onCourtDRtg" data-table="${uniqueId}" data-group="defcourt">DRtg</th>
                                    <th class="sortable-header" data-sort="defOnCourtEfg" data-table="${uniqueId}" data-group="defcourt">Opp eFG</th>
                                    <th class="sortable-header" data-sort="defOnCourtOrebPct" data-table="${uniqueId}" data-group="defcourt">Opp ORB</th>
                                    <th class="sortable-header" data-sort="defOnCourtTovPct" data-table="${uniqueId}" data-group="defcourt">TOV Frc</th>
                                    <th class="sortable-header col-separator" data-sort="netRating" data-table="${uniqueId}" data-group="defcourt">Net</th>
                                    <th class="sortable-header col-separator" data-sort="ts" data-table="${uniqueId}" data-group="individual">TS%</th>
                                    <th class="sortable-header" data-sort="astPct" data-table="${uniqueId}" data-group="individual">AST%</th>
                                    <th class="sortable-header col-separator" data-sort="tovPct" data-table="${uniqueId}" data-group="individual">TO%</th>
                                    <th class="sortable-header" data-sort="stlPct" data-table="${uniqueId}" data-group="individual">STL%</th>
                                    <th class="sortable-header col-separator" data-sort="blkPct" data-table="${uniqueId}" data-group="individual">BLK%</th>
                                    <th class="sortable-header col-separator" data-sort="ftRate" data-table="${uniqueId}" data-group="individual">FT Rate</th>
                                    <th class="sortable-header" data-sort="orebPct" data-table="${uniqueId}" data-group="individual">ORB%</th>
                                    <th class="sortable-header" data-sort="drebPct" data-table="${uniqueId}" data-group="individual">DRB%</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${players.map(p => this.renderPlayerRow(p, globalRanges, teamTotals, teamClass, teamColor, fillClass, gameAvg)).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        getBarWidth(value, min, max) {
            if (max === min) return 50;
            return Math.max(0, Math.min(100, ((value - min) / (max - min)) * 100));
        }

        renderPlayerRow(player, ranges, teamTotals, teamClass, teamColor, fillClass, gameAvg) {
            const netRatingClass = player.netRating >= 0 ? 'positive' : 'negative';
            
            const rimPct = player.rimAtt > 0 ? (player.rimMade / player.rimAtt * 100) : 0;
            const midPct = player.midAtt > 0 ? (player.midMade / player.midAtt * 100) : 0;
            const threePct = player.fg3a > 0 ? (player.fg3m / player.fg3a * 100) : 0;
            
            let midAtt = player.midAtt || 0;
            let midMade = player.midMade || 0;
            if (midAtt === 0 && player.fg2a > 0) {
                midAtt = Math.max(0, player.fg2a - (player.rimAtt || 0));
                midMade = Math.max(0, player.fg2m - (player.rimMade || 0));
            }
            const calculatedMidPct = midAtt > 0 ? (midMade / midAtt * 100) : 0;
            
            // Calculate +/- relative to GAME AVERAGES (both teams combined)
            // Offensive on-court vs game average
            const offORtgDiff = player.onCourtORtg - (gameAvg?.ortg || 100);
            const offEfgDiff = player.onCourtEfg - (gameAvg?.efg || 50);
            const offOrebDiff = player.onCourtOrebPct - (gameAvg?.orebPct || 25);
            const offTovDiff = player.onCourtTovPct - (gameAvg?.tovPct || 15);
            
            // Defensive on-court vs game average
            const defDRtgDiff = player.onCourtDRtg - (gameAvg?.drtg || 100);
            const defEfgDiff = (player.defOnCourtEfg || 0) - (gameAvg?.efg || 50);
            const defOrebDiff = (player.defOnCourtOrebPct || 0) - (gameAvg?.orebPct || 25);
            const defTovDiff = (player.defOnCourtTovPct || 0) - (gameAvg?.tovPct || 15);
            
            // Helper to format +/- with color class and bar width
            const formatDiff = (diff, inverted = false) => {
                const isGood = inverted ? diff < 0 : diff > 0;
                const colorClass = isGood ? 'positive' : (Math.abs(diff) < 0.5 ? '' : 'negative');
                const sign = diff >= 0 ? '+' : '';
                // Scale diff to bar width: 0 = 50%, ±15 = 0-100%
                const effectiveDiff = inverted ? -diff : diff;
                const barWidth = Math.max(0, Math.min(100, 50 + (effectiveDiff / 15) * 50));
                return { text: `${sign}${diff.toFixed(0)}`, class: colorClass, barWidth };
            };
            
            // Offensive on-court (higher is better except TOV%)
            const offORtg = formatDiff(offORtgDiff);
            const offEfg = formatDiff(offEfgDiff);
            const offOreb = formatDiff(offOrebDiff);
            const offTov = formatDiff(offTovDiff, true); // Lower TOV% is better
            
            // Defensive on-court (lower is better except TOV forced)
            const defDRtg = formatDiff(defDRtgDiff, true); // Lower DRtg is better
            const defEfg = formatDiff(defEfgDiff, true); // Lower opp eFG is better
            const defOreb = formatDiff(defOrebDiff, true); // Lower opp OREB% is better
            const defTov = formatDiff(defTovDiff); // Higher TOV forced is better
            
            // Total point contribution
            const tpc = player.totalPointContribution || player.points;
            const pointsAssisted = player.pointsAssisted || 0;
            
            // Use pre-calculated stats from aggregatePlayerStatsForPeriods, with fallback calculations
            // FT Rate = FTA / FGA * 100
            const ftRate = player.ftRate || (player.fga > 0 ? (player.fta / player.fga * 100) : 0);
            
            // STL% - use pre-calculated or fallback to per-40 rate
            const stlPct = player.stlPct || (player.minutes > 0 ? (player.stl || 0) / player.minutes * 40 : 0);
            
            // BLK% - use pre-calculated or fallback to per-40 rate
            const blkPct = player.blkPct || (player.minutes > 0 ? (player.blk || 0) / player.minutes * 40 : 0);
            
            // OREB% - use pre-calculated value first
            const orebPct = player.orebPct || 0;
            
            // DREB% - use pre-calculated value first
            const drebPct = player.drebPct || 0;
            
            return `
                <tr data-player='${JSON.stringify({name: player.name, fgm: player.fgm, ast: player.ast, points: player.points, pointsAssisted, totalPointContribution: tpc, ppp: player.ppp || 0, usg: player.usg, astUsgRatio: player.astUsgRatio, minutes: player.minutes, rimAtt: player.rimAtt || 0, rimPct, midAtt, midPct: calculatedMidPct, fg3a: player.fg3a, threePct, onCourtORtg: player.onCourtORtg, onCourtEfg: player.onCourtEfg, onCourtOrebPct: player.onCourtOrebPct, onCourtTovPct: player.onCourtTovPct, onCourtDRtg: player.onCourtDRtg, defOnCourtEfg: player.defOnCourtEfg || 0, defOnCourtOrebPct: player.defOnCourtOrebPct || 0, defOnCourtTovPct: player.defOnCourtTovPct || 0, netRating: player.netRating, ts: player.ts, astPct: player.astPct, tovPct: player.tovPct || 0, stlPct, blkPct, ftRate, orebPct, drebPct})}'>
                    <td class="sticky-cell"><span class="player-name">${player.name}</span></td>
                    <td data-group="scoring">${player.fgm}</td>
                    <td data-group="scoring" style="color: var(--text-muted);">${player.ast}</td>
                    <td data-group="scoring" class="col-separator"><span class="points-total">${player.points}</span></td>
                    <td data-group="scoring" style="color: var(--accent-purple);">${pointsAssisted > 0 ? '+' + pointsAssisted : '0'}</td>
                    <td data-group="scoring" class="mins-cell">
                        <span class="mins-value tpc-value">${tpc}</span>
                        <div class="mins-bar"><div class="mins-bar-fill tpc" style="width: ${this.getBarWidth(tpc, ranges.totalPointContribution?.min || 0, ranges.totalPointContribution?.max || 50)}%; background: linear-gradient(90deg, var(--accent-emerald), var(--accent-purple));"></div></div>
                    </td>
                    <td data-group="scoring" class="perf-cell col-separator"><div class="perf-wrapper"><div class="perf-bar"><div class="perf-fill shooting" style="width: ${this.getBarWidth(player.ppp || 0, ranges.ppp.min, ranges.ppp.max)}%;"></div></div><span class="perf-val">${(player.ppp || 0).toFixed(2)}</span></div></td>
                    <td data-group="usage" class="mins-cell">
                        <span class="mins-value">${player.usg.toFixed(0)}</span>
                        <div class="mins-bar"><div class="mins-bar-fill" style="width: ${this.getBarWidth(player.usg, ranges.usg.min, ranges.usg.max)}%; background: var(--accent-coral);"></div></div>
                    </td>
                    <td data-group="usage" class="perf-cell"><div class="perf-wrapper"><div class="perf-bar"><div class="perf-fill playmaking" style="width: ${this.getBarWidth(player.astUsgRatio, ranges.astUsgRatio.min, ranges.astUsgRatio.max)}%;"></div></div><span class="perf-val">${player.astUsgRatio.toFixed(1)}</span></div></td>
                    <td data-group="usage" class="mins-cell col-separator">
                        <span class="mins-value">${player.minutes.toFixed(0)}</span>
                        <div class="mins-bar"><div class="mins-bar-fill" style="width: ${this.getBarWidth(player.minutes, ranges.minutes.min, ranges.minutes.max)}%; background: ${teamColor};"></div></div>
                    </td>
                    
                    <td data-group="shotdist" class="shot-cell">
                        <div class="shot-wrapper">
                            <span class="shot-att">${player.rimAtt || 0}</span>
                            <div class="shot-bar"><div class="shot-bar-fill rim" style="width: ${Math.min(100, (player.rimAtt || 0) / 10 * 100)}%;"></div></div>
                        </div>
                    </td>
                    <td data-group="shotdist" class="shot-pct-cell zone-end"><span class="shot-pct rim">${rimPct.toFixed(0)}%</span></td>
                    <td data-group="shotdist" class="shot-cell">
                        <div class="shot-wrapper">
                            <span class="shot-att">${midAtt}</span>
                            <div class="shot-bar"><div class="shot-bar-fill mid" style="width: ${Math.min(100, midAtt / 10 * 100)}%;"></div></div>
                        </div>
                    </td>
                    <td data-group="shotdist" class="shot-pct-cell zone-end"><span class="shot-pct mid">${calculatedMidPct.toFixed(0)}%</span></td>
                    <td data-group="shotdist" class="shot-cell">
                        <div class="shot-wrapper">
                            <span class="shot-att">${player.fg3a}</span>
                            <div class="shot-bar"><div class="shot-bar-fill three" style="width: ${Math.min(100, player.fg3a / 10 * 100)}%;"></div></div>
                        </div>
                    </td>
                    <td data-group="shotdist" class="col-separator"><span class="shot-pct three">${threePct.toFixed(0)}%</span></td>
                    
                    <!-- Offensive On-Court (+/- vs team avg) -->
                    <td data-group="offcourt"><div class="metric-cell"><div class="metric-bg"><div class="metric-fill ${offORtg.class === 'positive' ? 'positive' : (offORtg.class === 'negative' ? 'defense' : 'neutral')}" style="width: ${offORtg.barWidth}%;"></div></div><span class="metric-text ${offORtg.class}">${offORtg.text}</span></div></td>
                    <td data-group="offcourt"><div class="metric-cell"><div class="metric-bg"><div class="metric-fill ${offEfg.class === 'positive' ? 'positive' : (offEfg.class === 'negative' ? 'defense' : 'neutral')}" style="width: ${offEfg.barWidth}%;"></div></div><span class="metric-text ${offEfg.class}">${offEfg.text}</span></div></td>
                    <td data-group="offcourt"><div class="metric-cell"><div class="metric-bg"><div class="metric-fill ${offOreb.class === 'positive' ? 'positive' : (offOreb.class === 'negative' ? 'defense' : 'neutral')}" style="width: ${offOreb.barWidth}%;"></div></div><span class="metric-text ${offOreb.class}">${offOreb.text}</span></div></td>
                    <td data-group="offcourt" class="col-separator"><div class="metric-cell"><div class="metric-bg"><div class="metric-fill ${offTov.class === 'positive' ? 'positive' : (offTov.class === 'negative' ? 'defense' : 'neutral')}" style="width: ${offTov.barWidth}%;"></div></div><span class="metric-text ${offTov.class}">${offTov.text}</span></div></td>
                    
                    <!-- Defensive On-Court (+/- vs opp avg) -->
                    <td data-group="defcourt"><div class="metric-cell"><div class="metric-bg"><div class="metric-fill ${defDRtg.class === 'positive' ? 'positive' : (defDRtg.class === 'negative' ? 'defense' : 'neutral')}" style="width: ${defDRtg.barWidth}%;"></div></div><span class="metric-text ${defDRtg.class}">${defDRtg.text}</span></div></td>
                    <td data-group="defcourt"><div class="metric-cell"><div class="metric-bg"><div class="metric-fill ${defEfg.class === 'positive' ? 'positive' : (defEfg.class === 'negative' ? 'defense' : 'neutral')}" style="width: ${defEfg.barWidth}%;"></div></div><span class="metric-text ${defEfg.class}">${defEfg.text}</span></div></td>
                    <td data-group="defcourt"><div class="metric-cell"><div class="metric-bg"><div class="metric-fill ${defOreb.class === 'positive' ? 'positive' : (defOreb.class === 'negative' ? 'defense' : 'neutral')}" style="width: ${defOreb.barWidth}%;"></div></div><span class="metric-text ${defOreb.class}">${defOreb.text}</span></div></td>
                    <td data-group="defcourt"><div class="metric-cell"><div class="metric-bg"><div class="metric-fill ${defTov.class === 'positive' ? 'positive' : (defTov.class === 'negative' ? 'defense' : 'neutral')}" style="width: ${defTov.barWidth}%;"></div></div><span class="metric-text ${defTov.class}">${defTov.text}</span></div></td>
                    <td data-group="defcourt" class="col-separator"><span class="net-pill ${netRatingClass}">${player.netRating >= 0 ? '+' : ''}${player.netRating.toFixed(0)}</span></td>
                    
                    <!-- Individual -->
                    <td data-group="individual" class="perf-cell col-separator"><div class="perf-wrapper"><div class="perf-bar"><div class="perf-fill shooting" style="width: ${this.getBarWidth(player.ts, ranges.ts.min, ranges.ts.max)}%;"></div></div><span class="perf-val">${player.ts.toFixed(0)}</span></div></td>
                    <td data-group="individual" class="perf-cell"><div class="perf-wrapper"><div class="perf-bar"><div class="perf-fill handling" style="width: ${this.getBarWidth(player.astPct, ranges.astPct.min, ranges.astPct.max)}%;"></div></div><span class="perf-val">${player.astPct.toFixed(0)}</span></div></td>
                    <td data-group="individual" class="perf-cell col-separator"><div class="perf-wrapper"><div class="perf-bar"><div class="perf-fill rebounding" style="width: ${100 - this.getBarWidth(player.tovPct || 0, ranges.tovPct.min, ranges.tovPct.max)}%;"></div></div><span class="perf-val">${(player.tovPct || 0).toFixed(0)}</span></div></td>
                    <td data-group="individual" class="perf-cell"><div class="perf-wrapper"><div class="perf-bar"><div class="perf-fill defense" style="width: ${this.getBarWidth(stlPct, ranges.stlPct?.min || 0, ranges.stlPct?.max || 5)}%;"></div></div><span class="perf-val">${stlPct.toFixed(1)}</span></div></td>
                    <td data-group="individual" class="perf-cell col-separator"><div class="perf-wrapper"><div class="perf-bar"><div class="perf-fill defense" style="width: ${this.getBarWidth(blkPct, ranges.blkPct?.min || 0, ranges.blkPct?.max || 5)}%;"></div></div><span class="perf-val">${blkPct.toFixed(1)}</span></div></td>
                    <td data-group="individual" class="perf-cell col-separator"><div class="perf-wrapper"><div class="perf-bar"><div class="perf-fill shooting" style="width: ${this.getBarWidth(ftRate, ranges.ftRate?.min || 0, ranges.ftRate?.max || 50)}%;"></div></div><span class="perf-val">${ftRate.toFixed(0)}</span></div></td>
                    <td data-group="individual" class="perf-cell"><div class="perf-wrapper"><div class="perf-bar"><div class="perf-fill rebounding" style="width: ${this.getBarWidth(orebPct, ranges.orebPct?.min || 0, ranges.orebPct?.max || 30)}%;"></div></div><span class="perf-val">${orebPct.toFixed(1)}</span></div></td>
                    <td data-group="individual" class="perf-cell"><div class="perf-wrapper"><div class="perf-bar"><div class="perf-fill rebounding" style="width: ${this.getBarWidth(drebPct, ranges.drebPct?.min || 0, ranges.drebPct?.max || 40)}%;"></div></div><span class="perf-val">${drebPct.toFixed(1)}</span></div></td>
                </tr>
            `;
        }

        // ========================================================================
        // LINEUPS TAB - FIXED TO USE JERSEY NUMBERS
        // ========================================================================

        // ========================================================================
        // CONNECTIONS TAB - ASSIST COMBINATIONS
        // ========================================================================

        renderConnectionsTab(teamsData) {
            const teamNames = Object.keys(teamsData);
            const homeTeam = teamNames[0];
            const awayTeam = teamNames[1];

            const combinations = Object.entries(this.assistCombinations)
                .map(([key, stats]) => {
                    const [team, assisterNum, scorerNum] = key.split('|');
                    const roster = this.playerRoster[team] || {};
                    const assisterName = roster[assisterNum] || `#${assisterNum}`;
                    const scorerName = roster[scorerNum] || `#${scorerNum}`;
                    return {
                        team,
                        assisterNum,
                        scorerNum,
                        assisterName,
                        scorerName,
                        ...stats
                    };
                })
                .sort((a, b) => b.count - a.count);

            if (combinations.length === 0) {
                return `
                    <div class="stat-card glass-card full-width" style="text-align: center; padding: 60px;">
                        <h3 style="color: var(--text-muted);">No connection data available</h3>
                        <p style="color: var(--text-muted); margin-top: 16px;">Upload play-by-play data to see assist combinations</p>
                    </div>
                `;
            }

            const homeCombos = combinations.filter(c => c.team === homeTeam);
            const awayCombos = combinations.filter(c => c.team === awayTeam);
            const maxCount = Math.max(...combinations.map(c => c.count));

            const renderComboCard = (combo, isHome) => {
                const teamClass = isHome ? 'home' : 'away';
                const barWidth = (combo.count / maxCount) * 100;
                const ppp = combo.count > 0 ? (combo.points / combo.count).toFixed(2) : '0.00';

                return `
                    <div class="connection-card glass-card">
                        <div class="connection-header">
                            <span class="team-indicator ${teamClass}"></span>
                            <div class="connection-players">
                                <span class="connection-passer">${combo.assisterName}</span>
                                <span class="connection-arrow">→</span>
                                <span class="connection-scorer">${combo.scorerName}</span>
                            </div>
                        </div>
                        <div class="connection-stats">
                            <div class="connection-main">
                                <div class="connection-count">${combo.count}</div>
                                <div class="connection-label">assists</div>
                            </div>
                            <div class="connection-details">
                                <div class="connection-detail">
                                    <span class="detail-value">${combo.points}</span>
                                    <span class="detail-label">PTS</span>
                                </div>
                                <div class="connection-detail">
                                    <span class="detail-value">${ppp}</span>
                                    <span class="detail-label">PPP</span>
                                </div>
                                <div class="connection-detail">
                                    <span class="detail-value three">${combo.threes}</span>
                                    <span class="detail-label">3PT</span>
                                </div>
                                <div class="connection-detail">
                                    <span class="detail-value two">${combo.twos}</span>
                                    <span class="detail-label">2PT</span>
                                </div>
                            </div>
                        </div>
                        <div class="connection-bar-container">
                            <div class="connection-bar ${teamClass}" style="width: ${barWidth}%;"></div>
                        </div>
                    </div>
                `;
            };

            // Render connections table
            const renderConnectionsTable = (combos, tableId) => {
                return `
                    <div class="connections-table-container" style="overflow-x: auto; margin-top: 16px;">
                        <table class="connections-stats-table" id="${tableId}" style="width: 100%; border-collapse: collapse; font-size: 12px;">
                            <thead>
                                <tr style="background: rgba(16, 185, 129, 0.15);">
                                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid rgba(16, 185, 129, 0.4); min-width: 40px;"></th>
                                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid rgba(16, 185, 129, 0.4);">Passer</th>
                                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid rgba(16, 185, 129, 0.4);">Scorer</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid rgba(16, 185, 129, 0.4);">AST</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid rgba(16, 185, 129, 0.4);">PTS</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid rgba(16, 185, 129, 0.4);">PPP</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid rgba(16, 185, 129, 0.4);">3PT</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid rgba(16, 185, 129, 0.4);">2PT</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${combos.map((c, i) => {
                                    const teamColor = c.team === homeTeam ? 'var(--accent-cyan)' : 'var(--accent-magenta)';
                                    const ppp = c.count > 0 ? (c.points / c.count).toFixed(2) : '0.00';
                                    return `
                                        <tr style="background: ${i % 2 === 0 ? 'rgba(0,0,0,0.1)' : 'transparent'}; border-bottom: 1px solid rgba(255,255,255,0.05);">
                                            <td style="padding: 8px;">
                                                <span style="width: 10px; height: 10px; border-radius: 50%; background: ${teamColor}; display: inline-block;"></span>
                                            </td>
                                            <td style="padding: 8px; color: #3b82f6; font-weight: 500;">${c.assisterName}</td>
                                            <td style="padding: 8px; color: #10b981; font-weight: 500;">${c.scorerName}</td>
                                            <td style="padding: 8px; text-align: center; font-weight: 700; color: #4ade80;">${c.count}</td>
                                            <td style="padding: 8px; text-align: center; font-weight: 700; color: #fbbf24;">${c.points}</td>
                                            <td style="padding: 8px; text-align: center; font-family: 'Space Mono', monospace;">${ppp}</td>
                                            <td style="padding: 8px; text-align: center; color: var(--accent-emerald);">${c.threes}</td>
                                            <td style="padding: 8px; text-align: center; color: var(--accent-coral);">${c.twos}</td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            };

            return `
                <div class="connections-view-toggle" style="display: flex; justify-content: flex-end; gap: 8px; margin-bottom: 16px;">
                    <button class="connections-view-btn active" data-view="cards" style="padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border-subtle); background: var(--bg-elevated); color: var(--text-primary); cursor: pointer; font-size: 11px;">📊 Cards</button>
                    <button class="connections-view-btn" data-view="table" style="padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border-subtle); background: transparent; color: var(--text-muted); cursor: pointer; font-size: 11px;">📋 Table</button>
                </div>

                <!-- Card View -->
                <div class="connections-cards-view">
                    <div class="connections-container">
                        <div class="connections-section">
                            <div class="connections-header">
                                <h3><span class="team-indicator home"></span>${homeTeam}</h3>
                                <span class="connections-count">${homeCombos.length} combinations</span>
                            </div>
                            <div class="connections-grid">
                                ${homeCombos.slice(0, 10).map(c => renderComboCard(c, true)).join('')}
                            </div>
                            ${homeCombos.length === 0 ? '<p class="no-data">No assist combinations recorded</p>' : ''}
                        </div>

                        <div class="connections-section">
                            <div class="connections-header">
                                <h3><span class="team-indicator away"></span>${awayTeam}</h3>
                                <span class="connections-count">${awayCombos.length} combinations</span>
                            </div>
                            <div class="connections-grid">
                                ${awayCombos.slice(0, 10).map(c => renderComboCard(c, false)).join('')}
                            </div>
                            ${awayCombos.length === 0 ? '<p class="no-data">No assist combinations recorded</p>' : ''}
                        </div>
                    </div>
                </div>

                <!-- Table View -->
                <div class="connections-table-view" style="display: none;">
                    <div class="stat-card glass-card full-width">
                        <div class="card-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <h3 style="margin: 0; display: flex; align-items: center; gap: 8px;">
                                <span class="team-indicator home"></span>${homeTeam} Connections
                            </h3>
                            <span style="color: var(--text-muted); font-size: 12px;">${homeCombos.length} combinations</span>
                        </div>
                        ${renderConnectionsTable(homeCombos, 'connections-table-home')}
                    </div>

                    <div class="stat-card glass-card full-width" style="margin-top: 24px;">
                        <div class="card-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <h3 style="margin: 0; display: flex; align-items: center; gap: 8px;">
                                <span class="team-indicator away"></span>${awayTeam} Connections
                            </h3>
                            <span style="color: var(--text-muted); font-size: 12px;">${awayCombos.length} combinations</span>
                        </div>
                        ${renderConnectionsTable(awayCombos, 'connections-table-away')}
                    </div>
                </div>
            `;
        }

        // ========================================================================
        // COLLAPSIBLE COLUMN GROUPS & SORTABLE COLUMNS
        // ========================================================================

        toggleColumnGroup(tableId, groupName) {
            const table = document.getElementById(tableId);
            if (!table) return;
            
            const groupHeader = table.querySelector(`th.col-group-header[data-group="${groupName}"]`);
            if (!groupHeader) return;
            
            const isCollapsed = groupHeader.classList.toggle('collapsed');
            
            // Get the colspan to determine how many cells to hide
            const headerRow = groupHeader.parentElement;
            const groupHeaders = Array.from(headerRow.querySelectorAll('th.col-group-header'));
            const groupIndex = groupHeaders.indexOf(groupHeader);
            
            // Find all cells belonging to this group (excluding the group header itself)
            const allHeaders = table.querySelectorAll(`th[data-group="${groupName}"]:not(.col-group-header)`);
            const allCells = table.querySelectorAll(`td[data-group="${groupName}"]`);
            
            allHeaders.forEach(h => h.classList.toggle('col-hidden', isCollapsed));
            allCells.forEach(c => c.classList.toggle('col-hidden', isCollapsed));
            
            // Update colspan for the group header
            if (isCollapsed) {
                groupHeader.setAttribute('data-original-colspan', groupHeader.getAttribute('colspan'));
                groupHeader.setAttribute('colspan', '1');
            } else {
                const originalColspan = groupHeader.getAttribute('data-original-colspan');
                if (originalColspan) {
                    groupHeader.setAttribute('colspan', originalColspan);
                }
            }
            
            // Update the collapsed groups bar
            this.updateCollapsedGroupsBar(tableId);
            
            // Auto-fit table to viewport after column toggle
            this.autoFitTable(tableId);
        }
        
        autoFitTable(tableId) {
            const table = document.getElementById(tableId);
            if (!table) return;
            
            const wrapper = table.closest('.player-table-wrapper');
            if (!wrapper) return;
            
            // Count visible columns to determine if table should auto-fit
            const visibleHeaders = table.querySelectorAll('thead tr:last-child th:not(.col-hidden)');
            const visibleCount = visibleHeaders.length;
            
            // If few columns visible (e.g., <= 10), scale to fit viewport
            // Otherwise, allow horizontal scroll
            if (visibleCount <= 12) {
                table.classList.add('auto-fit');
                table.style.minWidth = '100%';
            } else {
                table.classList.remove('auto-fit');
                // Set appropriate min-width based on visible columns
                const minWidth = Math.max(800, visibleCount * 90);
                table.style.minWidth = `${minWidth}px`;
            }
        }
        
        updateCollapsedGroupsBar(tableId) {
            const table = document.getElementById(tableId);
            const bar = document.getElementById(`collapsed-bar-${tableId}`);
            if (!table || !bar) return;
            
            const groups = ['scoring', 'usage', 'shotdist', 'offcourt', 'defcourt', 'individual'];
            let anyCollapsed = false;
            let anyExpanded = false;
            
            groups.forEach(group => {
                const header = table.querySelector(`th.col-group-header[data-group="${group}"]`);
                const chip = bar.querySelector(`.collapsed-group-chip[data-group="${group}"]`);
                if (!header || !chip) return;
                
                const isCollapsed = header.classList.contains('collapsed');
                chip.style.display = isCollapsed ? 'flex' : 'none';
                
                if (isCollapsed) anyCollapsed = true;
                else anyExpanded = true;
            });
            
            // Show/hide the bar based on whether any groups are collapsed
            bar.style.display = anyCollapsed ? 'flex' : 'none';
        }
        
        expandAllGroups(tableId) {
            const table = document.getElementById(tableId);
            if (!table) return;
            
            const groups = ['scoring', 'usage', 'shotdist', 'offcourt', 'defcourt', 'individual'];
            groups.forEach(group => {
                const header = table.querySelector(`th.col-group-header[data-group="${group}"]`);
                if (header && header.classList.contains('collapsed')) {
                    this.toggleColumnGroup(tableId, group);
                }
            });
            
            // Recalculate table fit after expanding all
            this.autoFitTable(tableId);
        }
        
        collapseAllGroups(tableId) {
            const table = document.getElementById(tableId);
            if (!table) return;
            
            const groups = ['scoring', 'usage', 'shotdist', 'offcourt', 'defcourt', 'individual'];
            groups.forEach(group => {
                const header = table.querySelector(`th.col-group-header[data-group="${group}"]`);
                if (header && !header.classList.contains('collapsed')) {
                    this.toggleColumnGroup(tableId, group);
                }
            });
            
            // Recalculate table fit after collapsing all
            this.autoFitTable(tableId);
        }

        toggleAllGroups(tableId) {
            const table = document.getElementById(tableId);
            if (!table) return;
            
            const groupHeaders = table.querySelectorAll('.col-group-header');
            const anyExpanded = Array.from(groupHeaders).some(h => !h.classList.contains('collapsed'));
            
            const groups = ['scoring', 'usage', 'shotdist', 'offcourt', 'defcourt', 'individual'];
            groups.forEach(group => {
                const header = table.querySelector(`th.col-group-header[data-group="${group}"]`);
                if (header) {
                    const isCurrentlyCollapsed = header.classList.contains('collapsed');
                    if (anyExpanded && !isCurrentlyCollapsed) {
                        this.toggleColumnGroup(tableId, group);
                    } else if (!anyExpanded && isCurrentlyCollapsed) {
                        this.toggleColumnGroup(tableId, group);
                    }
                }
            });
        }

        toggleComparisonSection(cardId, sectionKey) {
            const card = document.getElementById(cardId);
            if (!card) return;
            
            const header = card.querySelector(`.comparison-section-header[data-section="${sectionKey}"]`);
            const content = card.querySelector(`.comparison-section-content[data-section="${sectionKey}"]`);
            
            if (!header || !content) return;
            
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
            
            // Set max-height for animation
            if (!isCollapsed) {
                content.style.maxHeight = content.scrollHeight + 'px';
            } else {
                content.style.maxHeight = '0';
            }
        }

        toggleTotalView() {
            const wrapper = document.getElementById('half-comparison-wrapper');
            const btn = document.getElementById('total-toggle-btn');
            const homePanel = document.getElementById('home-panel');
            const awayPanel = document.getElementById('away-panel');
            const totalPanel = document.getElementById('total-panel');
            
            if (!wrapper || !btn || !homePanel || !awayPanel || !totalPanel) return;
            
            const isShowingTotal = btn.classList.toggle('active');
            
            if (isShowingTotal) {
                // Show total view: collapse halves, expand total
                btn.querySelector('.toggle-text').textContent = 'Show Half Comparison';
                homePanel.classList.remove('expanded');
                homePanel.classList.add('collapsed');
                awayPanel.classList.remove('expanded');
                awayPanel.classList.add('collapsed');
                totalPanel.classList.remove('collapsed');
                totalPanel.classList.add('expanded');
                
                // Initialize total section heights
                setTimeout(() => {
                    totalPanel.querySelectorAll('.tow-section-content').forEach(content => {
                        content.style.maxHeight = content.scrollHeight + 'px';
                    });
                }, 50);
            } else {
                // Show half view: expand halves, collapse total
                btn.querySelector('.toggle-text').textContent = 'Show Total Comparison';
                homePanel.classList.remove('collapsed');
                homePanel.classList.add('expanded');
                awayPanel.classList.remove('collapsed');
                awayPanel.classList.add('expanded');
                totalPanel.classList.remove('expanded');
                totalPanel.classList.add('collapsed');
                
                // Reinitialize half section heights
                setTimeout(() => {
                    document.querySelectorAll('.comparison-section-content').forEach(content => {
                        if (!content.classList.contains('collapsed')) {
                            content.style.maxHeight = content.scrollHeight + 'px';
                        }
                    });
                }, 50);
            }
        }

        expandHalfPanel(side) {
            const btn = document.getElementById('total-toggle-btn');
            const homePanel = document.getElementById('home-panel');
            const awayPanel = document.getElementById('away-panel');
            const totalPanel = document.getElementById('total-panel');
            
            if (!btn || !homePanel || !awayPanel || !totalPanel) return;
            
            // Expand the clicked side, collapse total
            btn.classList.remove('active');
            btn.querySelector('.toggle-text').textContent = 'Show Total Comparison';
            
            homePanel.classList.remove('collapsed');
            homePanel.classList.add('expanded');
            awayPanel.classList.remove('collapsed');
            awayPanel.classList.add('expanded');
            totalPanel.classList.remove('expanded');
            totalPanel.classList.add('collapsed');
            
            // Reinitialize section heights
            setTimeout(() => {
                document.querySelectorAll('.comparison-section-content').forEach(content => {
                    if (!content.classList.contains('collapsed')) {
                        content.style.maxHeight = content.scrollHeight + 'px';
                    }
                });
            }, 50);
        }

        toggleTotalSection(sectionKey) {
            const card = document.getElementById('total-comparison-card');
            if (!card) return;
            
            const header = card.querySelector(`.tow-section-header[data-section="${sectionKey}"]`);
            const content = card.querySelector(`.tow-section-content[data-section="${sectionKey}"]`);
            
            if (!header || !content) return;
            
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
            
            if (!isCollapsed) {
                content.style.maxHeight = content.scrollHeight + 'px';
            } else {
                content.style.maxHeight = '0';
            }
        }

        sortTable(tableId, sortKey, direction = 'desc') {
            const table = document.getElementById(tableId);
            if (!table) return;
            
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Update header classes
            table.querySelectorAll('.sortable-header').forEach(h => {
                h.classList.remove('sort-asc', 'sort-desc');
            });
            
            const header = table.querySelector(`th[data-sort="${sortKey}"]`);
            if (header) {
                header.classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');
            }
            
            rows.sort((a, b) => {
                let aData, bData;
                try {
                    aData = JSON.parse(a.getAttribute('data-player'));
                    bData = JSON.parse(b.getAttribute('data-player'));
                } catch (e) {
                    return 0;
                }
                
                let aVal = aData[sortKey];
                let bVal = bData[sortKey];
                
                // Handle string comparison for names
                if (sortKey === 'name') {
                    return direction === 'asc' 
                        ? aVal.localeCompare(bVal) 
                        : bVal.localeCompare(aVal);
                }
                
                // Numeric comparison
                aVal = parseFloat(aVal) || 0;
                bVal = parseFloat(bVal) || 0;
                
                return direction === 'asc' ? aVal - bVal : bVal - aVal;
            });
            
            rows.forEach(row => tbody.appendChild(row));
        }

        // ========================================================================
        // HALF STATS TAB
        // ========================================================================

        renderHalfStatsTab(teamsData, globalRanges, gameAvg) {
            const teamNames = Object.keys(teamsData);
            if (teamNames.length < 2) {
                return '<div class="stat-card glass-card">No team data available</div>';
            }
            
            const homeTeam = teamNames[0];
            const awayTeam = teamNames[1];
            const homeTotals = teamsData[homeTeam].teamTotals;
            const awayTotals = teamsData[awayTeam].teamTotals;
            
            // Check if we have period data
            const hasFirstHalf = this.periodStats[homeTeam] && (this.periodStats[homeTeam][1] || this.periodStats[homeTeam][2]);
            const hasSecondHalf = this.periodStats[homeTeam] && (this.periodStats[homeTeam][3] || this.periodStats[homeTeam][4]);
            const hasOT = this.maxPeriod > 4;
            
            // Generate period selector buttons
            const periods = [
                { id: 'first', label: '1st Half', show: true },
                { id: 'second', label: '2nd Half', show: true }
            ];
            
            // Add OT periods if detected
            for (let i = 5; i <= this.maxPeriod; i++) {
                periods.push({ id: `ot${i-4}`, label: `OT${i-4}`, show: true, isOT: true });
            }
            
            if (!hasFirstHalf && !hasSecondHalf) {
                return `
                    <div class="stat-card glass-card full-width" style="text-align: center; padding: 60px;">
                        <h3 style="color: var(--text-muted);">📊 Half Stats Not Available</h3>
                        <p style="color: var(--text-muted); margin-top: 16px;">Play-by-play data is required to split stats by half.</p>
                        <p style="color: var(--text-muted); margin-top: 8px;">Upload both boxscore and PBP files to see this analysis.</p>
                    </div>
                `;
            }
            
            return `
                <div class="half-stats-container">
                    <div class="half-selector">
                        ${periods.map((p, idx) => `
                            <button class="half-btn ${idx === 0 ? 'active' : ''} ${p.isOT ? 'ot' : ''}" 
                                    data-half="${p.id}" 
                                    onclick="window.fibaVisualizer.switchHalf('${p.id}')">
                                ${p.label}
                            </button>
                        `).join('')}
                    </div>
                    
                    ${periods.map((p, idx) => `
                        <div class="half-content ${idx === 0 ? 'active' : ''}" id="half-${p.id}">
                            ${this.renderHalfContent(p.id, teamsData, globalRanges, gameAvg)}
                        </div>
                    `).join('')}
                </div>
            `;
        }

        switchHalf(halfId) {
            document.querySelectorAll('.half-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.half === halfId);
            });
            document.querySelectorAll('.half-content').forEach(content => {
                content.classList.toggle('active', content.id === `half-${halfId}`);
            });
        }

        renderHalfContent(halfId, teamsData, globalRanges, gameAvg) {
            const teamNames = Object.keys(teamsData);
            const homeTeam = teamNames[0];
            const awayTeam = teamNames[1];
            
            // Determine which periods to aggregate
            let periodsToAggregate = [];
            if (halfId === 'first') {
                periodsToAggregate = [1, 2];
            } else if (halfId === 'second') {
                periodsToAggregate = [3, 4];
            } else if (halfId.startsWith('ot')) {
                const otNum = parseInt(halfId.replace('ot', ''));
                periodsToAggregate = [4 + otNum];
            }
            
            // Aggregate player stats for these periods (pass opponent team for advanced stats)
            const homeHalfPlayers = this.aggregatePlayerStatsForPeriods(homeTeam, teamsData[homeTeam], periodsToAggregate, awayTeam);
            const awayHalfPlayers = this.aggregatePlayerStatsForPeriods(awayTeam, teamsData[awayTeam], periodsToAggregate, homeTeam);
            
            // Aggregate team totals for these periods (pass opponent team for OREB% calculation)
            const homeHalfTotals = this.aggregateTeamTotalsForPeriods(homeTeam, periodsToAggregate, awayTeam);
            const awayHalfTotals = this.aggregateTeamTotalsForPeriods(awayTeam, periodsToAggregate, homeTeam);
            
            const isHomeWin = homeHalfTotals.points > awayHalfTotals.points;
            
            // Calculate half-specific ranges - filter players with at least 2 minutes
            const allHalfPlayers = [...homeHalfPlayers, ...awayHalfPlayers].filter(p => p.minutes >= 2);
            const halfRanges = this.calculateGlobalRanges(allHalfPlayers.length > 0 ? allHalfPlayers : teamsData[homeTeam].players);
            
            // Calculate half-specific game averages
            const halfGameAvg = {
                ortg: ((homeHalfTotals.ortg || 100) + (awayHalfTotals.ortg || 100)) / 2,
                drtg: ((homeHalfTotals.drtg || 100) + (awayHalfTotals.drtg || 100)) / 2,
                efg: ((homeHalfTotals.efg || 50) + (awayHalfTotals.efg || 50)) / 2,
                orebPct: ((homeHalfTotals.orebPct || 25) + (awayHalfTotals.orebPct || 25)) / 2,
                tovPct: ((homeHalfTotals.tovPct || 15) + (awayHalfTotals.tovPct || 15)) / 2
            };
            
            const halfLabel = halfId === 'first' ? '1st Half' : halfId === 'second' ? '2nd Half' : halfId.toUpperCase();
            
            return `
                <div class="stats-grid">
                    ${this.renderTeamFourFactors(homeTeam, awayTeam, homeHalfTotals, awayHalfTotals, halfLabel)}
                </div>
                
                ${this.renderHalfPlayerTable(homeTeam, { players: homeHalfPlayers, teamTotals: homeHalfTotals }, isHomeWin, homeHalfTotals, true, halfRanges, halfGameAvg, `half-${halfId}-home`)}
                ${this.renderHalfPlayerTable(awayTeam, { players: awayHalfPlayers, teamTotals: awayHalfTotals }, !isHomeWin, awayHalfTotals, false, halfRanges, halfGameAvg, `half-${halfId}-away`)}
            `;
        }

        renderHalfPlayerTable(teamName, teamData, isWin, teamTotals, isHomeTeam, globalRanges, gameAvg, tableId) {
            // Filter players with at least 2 minutes played in this half
            const players = teamData.players.filter(p => p.minutes >= 2).sort((a, b) => b.minutes - a.minutes);
            
            const teamClass = isHomeTeam ? 'home' : 'away';
            const teamColor = isHomeTeam ? 'var(--team-home)' : 'var(--team-away)';
            const fillClass = isHomeTeam ? 'cyan' : 'magenta';
            
            if (players.length === 0) {
                return `
                    <div class="team-section glass-card">
                        <div class="team-section-header">
                            <h3><span class="team-indicator ${teamClass}"></span>${teamName}</h3>
                            <span class="points-badge" style="opacity: 0.5;">${teamTotals.points || 0} PTS</span>
                        </div>
                        <div style="padding: 40px; text-align: center; color: var(--text-muted);">
                            No play-by-play data available for this period
                        </div>
                    </div>
                `;
            }
            
            // Create a modified teamData with only the filtered players
            const filteredTeamData = {
                ...teamData,
                players: players
            };
            
            return this.renderPlayerTable(teamName, filteredTeamData, isWin, teamTotals, isHomeTeam, globalRanges, gameAvg, tableId);
        }

        aggregatePlayerStatsForPeriods(teamName, teamData, periods, oppTeamName = null) {
            // If we don't have period data, return empty
            if (!this.periodStats[teamName]) {
                // Fallback: return the original players with estimated half stats
                return teamData.players.map(p => ({
                    ...p,
                    minutes: p.minutes / 2, // Rough estimate
                    points: Math.round(p.points / 2),
                    fgm: Math.round(p.fgm / 2),
                    fga: Math.round(p.fga / 2),
                    fg3m: Math.round(p.fg3m / 2),
                    fg3a: Math.round(p.fg3a / 2),
                    ftm: Math.round(p.ftm / 2),
                    fta: Math.round(p.fta / 2),
                    oreb: Math.round(p.oreb / 2),
                    dreb: Math.round(p.dreb / 2),
                    ast: Math.round(p.ast / 2),
                    stl: Math.round(p.stl / 2),
                    blk: Math.round(p.blk / 2),
                    tov: Math.round(p.tov / 2),
                    pf: Math.round(p.pf / 2),
                    rimAtt: Math.round((p.rimAtt || 0) / 2),
                    rimMade: Math.round((p.rimMade || 0) / 2),
                    midAtt: Math.round((p.midAtt || 0) / 2),
                    midMade: Math.round((p.midMade || 0) / 2),
                }));
            }
            
            const playerMap = {};
            
            // Initialize from team roster
            teamData.players.forEach(p => {
                playerMap[p.number] = {
                    ...p,
                    number: p.number,
                    name: p.name,
                    isStarter: p.isStarter,
                    minutes: 0, points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                    fg2m: 0, fg2a: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0,
                    ast: 0, stl: 0, blk: 0, tov: 0, pf: 0,
                    rimAtt: 0, rimMade: 0, midAtt: 0, midMade: 0
                };
            });
            
            // Calculate team totals for these periods for USG% calculation
            let teamFga = 0, teamFta = 0, teamTov = 0, teamOreb = 0, teamDreb = 0, teamFgm = 0, teamAst = 0;
            let teamStl = 0, teamBlk = 0, teamFg3a = 0, teamFg3m = 0;
            let totalTeamSeconds = 0; // Track total team seconds for proper USG calc
            
            // Calculate opponent team totals for STL%, BLK%, OREB%, DREB% calculations
            let oppFga = 0, oppFta = 0, oppTov = 0, oppOreb = 0, oppDreb = 0, oppFg3a = 0;
            if (oppTeamName && this.teamPeriodTotals[oppTeamName]) {
                periods.forEach(period => {
                    const oppPt = this.teamPeriodTotals[oppTeamName][period];
                    if (oppPt) {
                        oppFga += oppPt.fga || 0;
                        oppFta += oppPt.fta || 0;
                        oppTov += oppPt.tov || 0;
                        oppOreb += oppPt.oreb || 0;
                        oppDreb += oppPt.dreb || 0;
                        oppFg3a += oppPt.fg3a || 0;
                    }
                });
            }
            
            // Aggregate minutes from period-based tracking first
            periods.forEach(period => {
                const periodMinutes = this.playerPeriodMinutes?.[teamName]?.[period];
                if (periodMinutes) {
                    Object.entries(periodMinutes).forEach(([playerNum, seconds]) => {
                        if (playerMap[playerNum]) {
                            playerMap[playerNum].minutes += seconds / 60; // Convert seconds to minutes
                        } else {
                            // Player might not be in roster, create entry
                            const roster = this.playerRoster[teamName] || {};
                            playerMap[playerNum] = {
                                number: playerNum,
                                name: roster[playerNum] || `#${playerNum}`,
                                isStarter: false,
                                minutes: seconds / 60, points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                                fg2m: 0, fg2a: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0,
                                ast: 0, stl: 0, blk: 0, tov: 0, pf: 0,
                                rimAtt: 0, rimMade: 0, midAtt: 0, midMade: 0
                            };
                        }
                        totalTeamSeconds += seconds;
                    });
                }
            });
            
            // Aggregate stats from periods
            periods.forEach(period => {
                const periodData = this.periodStats[teamName]?.[period];
                if (!periodData) return;
                
                Object.entries(periodData).forEach(([playerNum, stats]) => {
                    if (!playerMap[playerNum]) {
                        // Player might not be in roster, create entry
                        const roster = this.playerRoster[teamName] || {};
                        playerMap[playerNum] = {
                            number: playerNum,
                            name: roster[playerNum] || `#${playerNum}`,
                            isStarter: false,
                            minutes: 0, points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                            fg2m: 0, fg2a: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0,
                            ast: 0, stl: 0, blk: 0, tov: 0, pf: 0,
                            rimAtt: 0, rimMade: 0, midAtt: 0, midMade: 0
                        };
                    }
                    
                    const p = playerMap[playerNum];
                    // Don't add minutes here - already tracked from substitutions
                    p.points += stats.points || 0;
                    p.fgm += stats.fgm || 0;
                    p.fga += stats.fga || 0;
                    p.fg3m += stats.fg3m || 0;
                    p.fg3a += stats.fg3a || 0;
                    p.ftm += stats.ftm || 0;
                    p.fta += stats.fta || 0;
                    p.oreb += stats.oreb || 0;
                    p.dreb += stats.dreb || 0;
                    p.ast += stats.ast || 0;
                    p.stl += stats.stl || 0;
                    p.blk += stats.blk || 0;
                    p.tov += stats.tov || 0;
                    p.pf += stats.pf || 0;
                    p.rimAtt += stats.rimAtt || 0;
                    p.rimMade += stats.rimMade || 0;
                    p.midAtt += stats.midAtt || 0;
                    p.midMade += stats.midMade || 0;
                    
                    // Accumulate team totals
                    teamFga += stats.fga || 0;
                    teamFta += stats.fta || 0;
                    teamTov += stats.tov || 0;
                    teamOreb += stats.oreb || 0;
                    teamDreb += stats.dreb || 0;
                    teamFgm += stats.fgm || 0;
                    teamAst += stats.ast || 0;
                    teamStl += stats.stl || 0;
                    teamBlk += stats.blk || 0;
                    teamFg3a += stats.fg3a || 0;
                    teamFg3m += stats.fg3m || 0;
                });
            });
            
            // Calculate total team minutes from tracked data (for USG% calculation)
            const totalTeamMinutes = totalTeamSeconds / 60;
            
            // Fallback: Estimate minutes from actions if no minute tracking data available
            const halfMinutes = periods.length <= 2 ? 100 : 25; // Regular half or OT (5 players * 20min or 5min)
            const hasTrackedMinutes = totalTeamSeconds > 0;
            
            if (!hasTrackedMinutes) {
                // Use actions as a proxy for playing time when PBP minute tracking failed
                const totalActions = Object.values(playerMap).reduce((sum, p) => 
                    sum + p.fga + p.fta * 0.44 + p.oreb + p.dreb + p.ast + p.stl + p.blk + p.tov, 0
                );
                
                Object.values(playerMap).forEach(p => {
                    const playerActions = p.fga + p.fta * 0.44 + p.oreb + p.dreb + p.ast + p.stl + p.blk + p.tov;
                    p.minutes = totalActions > 0 ? (playerActions / totalActions) * halfMinutes : 0;
                });
            }
            
            // Aggregate on-court stats from period-based tracking
            const playerOnCourtAgg = {};
            periods.forEach(period => {
                const periodOnCourt = this.playerPeriodOnCourtStats?.[teamName]?.[period];
                if (!periodOnCourt) return;
                
                Object.entries(periodOnCourt).forEach(([playerNum, ocs]) => {
                    if (!playerOnCourtAgg[playerNum]) {
                        playerOnCourtAgg[playerNum] = {
                            teamPoints: 0, oppPoints: 0,
                            teamFGA: 0, teamFGM: 0, team3PA: 0, team3PM: 0,
                            teamFTA: 0, teamFTM: 0, teamOreb: 0, teamDreb: 0, teamTov: 0,
                            oppFGA: 0, oppFGM: 0, opp3PA: 0, opp3PM: 0,
                            oppFTA: 0, oppFTM: 0, oppOreb: 0, oppDreb: 0, oppTov: 0
                        };
                    }
                    const agg = playerOnCourtAgg[playerNum];
                    agg.teamPoints += ocs.teamPoints || 0;
                    agg.oppPoints += ocs.oppPoints || 0;
                    agg.teamFGA += ocs.teamFGA || 0;
                    agg.teamFGM += ocs.teamFGM || 0;
                    agg.team3PA += ocs.team3PA || 0;
                    agg.team3PM += ocs.team3PM || 0;
                    agg.teamFTA += ocs.teamFTA || 0;
                    agg.teamFTM += ocs.teamFTM || 0;
                    agg.teamOreb += ocs.teamOreb || 0;
                    agg.teamDreb += ocs.teamDreb || 0;
                    agg.teamTov += ocs.teamTov || 0;
                    agg.oppFGA += ocs.oppFGA || 0;
                    agg.oppFGM += ocs.oppFGM || 0;
                    agg.opp3PA += ocs.opp3PA || 0;
                    agg.opp3PM += ocs.opp3PM || 0;
                    agg.oppFTA += ocs.oppFTA || 0;
                    agg.oppFTM += ocs.oppFTM || 0;
                    agg.oppOreb += ocs.oppOreb || 0;
                    agg.oppDreb += ocs.oppDreb || 0;
                    agg.oppTov += ocs.oppTov || 0;
                });
            });
            
            // Calculate derived stats for each player
            // Calculate opponent possessions for rate stats
            const oppPossessions = Math.max(1, oppFga + 0.44 * oppFta - oppOreb + oppTov);
            const opp2pa = Math.max(1, oppFga - oppFg3a); // Opponent 2-point attempts for BLK%
            
            // Team minutes for rate stat adjustments
            // In basketball, team minutes = 5 * game minutes (5 players on court)
            // totalTeamMinutes is already calculated from player minutes
            const teamMinutes = totalTeamMinutes > 0 ? totalTeamMinutes : 200; // Default to 40 min game * 5 players
            const gameMinutes = teamMinutes / 5; // Single player equivalent (e.g., 40 for regulation)
            
            return Object.values(playerMap).map(p => {
                p.fg2m = p.fgm - p.fg3m;
                p.fg2a = p.fga - p.fg3a;
                
                // Player minutes with minimum to avoid division by zero
                const pMin = Math.max(p.minutes, 0.1);
                
                // Minutes adjustment factor for rate stats
                // This adjusts stats to estimate what they'd be over the full game
                const minAdj = gameMinutes / pMin;
                
                // ========================================
                // BASKETBALL REFERENCE INDIVIDUAL STATS
                // https://www.basketball-reference.com/about/glossary.html
                // ========================================
                
                // eFG% (Effective Field Goal Percentage)
                // Formula: (FGM + 0.5 * 3PM) / FGA
                // No minutes adjustment needed - it's a pure efficiency metric
                p.efg = p.fga > 0 ? ((p.fgm + 0.5 * p.fg3m) / p.fga * 100) : 0;
                
                // TS% (True Shooting Percentage)
                // Formula: PTS / (2 * TSA) where TSA = FGA + 0.44 * FTA
                // No minutes adjustment needed - it's a pure efficiency metric
                const tsa = p.fga + 0.44 * p.fta;
                p.ts = tsa > 0 ? (p.points / (2 * tsa) * 100) : 0;
                
                // USG% (Usage Rate)
                // Formula: 100 * ((FGA + 0.44 * FTA + TOV) * (Tm MP / 5)) / (MP * (Tm FGA + 0.44 * Tm FTA + Tm TOV))
                // Estimates % of team plays used by player while on floor
                const playerPoss = p.fga + 0.44 * p.fta + p.tov;
                const teamPoss = teamFga + 0.44 * teamFta + teamTov;
                p.usg = (pMin > 0 && teamPoss > 0) ? 
                    (100 * (playerPoss * gameMinutes) / (pMin * teamPoss)) : 0;
                
                // AST% (Assist Percentage)  
                // Formula: 100 * AST / (((MP / (Tm MP / 5)) * Tm FGM) - FGM)
                // Estimates % of teammate FG assisted while player on floor
                const estTeamFgmWhileOnFloor = (pMin / gameMinutes) * teamFgm;
                const teammatesFgm = estTeamFgmWhileOnFloor - p.fgm;
                p.astPct = teammatesFgm > 0 ? (100 * p.ast / teammatesFgm) : 0;
                
                // TOV% (Turnover Percentage)
                // Formula: 100 * TOV / (FGA + 0.44 * FTA + TOV)
                // No minutes adjustment - measures turnovers per play used
                const tovDenom = p.fga + 0.44 * p.fta + p.tov;
                p.tovPct = tovDenom > 0 ? (100 * p.tov / tovDenom) : 0;
                
                // FTr (Free Throw Rate)
                // Formula: FTA / FGA
                // No minutes adjustment needed
                p.ftRate = p.fga > 0 ? (p.fta / p.fga * 100) : 0;
                
                // STL% (Steal Percentage)
                // Formula: 100 * (STL * (Tm MP / 5)) / (MP * Opp Poss)
                // Estimates % of opponent possessions ending in steal by player
                p.stlPct = (pMin > 0 && oppPossessions > 0) ?
                    (100 * (p.stl * gameMinutes) / (pMin * oppPossessions)) : 0;
                
                // BLK% (Block Percentage)
                // Formula: 100 * (BLK * (Tm MP / 5)) / (MP * (Opp FGA - Opp 3PA))
                // Estimates % of opponent 2PA blocked by player
                p.blkPct = (pMin > 0 && opp2pa > 0) ?
                    (100 * (p.blk * gameMinutes) / (pMin * opp2pa)) : 0;
                
                // ORB% (Offensive Rebound Percentage)
                // Formula: 100 * (ORB * (Tm MP / 5)) / (MP * (Tm ORB + Opp DRB))
                // Estimates % of available offensive rebounds grabbed by player
                const orebOpportunities = teamOreb + oppDreb;
                p.orebPct = (pMin > 0 && orebOpportunities > 0) ?
                    (100 * (p.oreb * gameMinutes) / (pMin * orebOpportunities)) : 0;
                
                // DRB% (Defensive Rebound Percentage)
                // Formula: 100 * (DRB * (Tm MP / 5)) / (MP * (Tm DRB + Opp ORB))
                // Estimates % of available defensive rebounds grabbed by player
                const drebOpportunities = teamDreb + oppOreb;
                p.drebPct = (pMin > 0 && drebOpportunities > 0) ?
                    (100 * (p.dreb * gameMinutes) / (pMin * drebOpportunities)) : 0;
                
                // TRB% (Total Rebound Percentage)
                // Formula: 100 * (TRB * (Tm MP / 5)) / (MP * (Tm TRB + Opp TRB))
                const totalRebOpportunities = teamOreb + teamDreb + oppOreb + oppDreb;
                p.rebPct = (pMin > 0 && totalRebOpportunities > 0) ?
                    (100 * ((p.oreb + p.dreb) * gameMinutes) / (pMin * totalRebOpportunities)) : 0;
                
                // AST/USG Ratio - playmaking efficiency (custom metric)
                p.astUsgRatio = p.usg > 0 ? (p.astPct / p.usg) : 0;
                
                // PPP (Points Per Possession used)
                // Simplified as Points / (FGA + 0.44*FTA + TOV)
                const playerPossUsed = p.fga + 0.44 * p.fta + p.tov;
                p.ppp = playerPossUsed > 0 ? (p.points / playerPossUsed) : 0;
                
                // On-court metrics - calculated from period-aggregated on-court data
                const ocs = playerOnCourtAgg[p.number];
                if (ocs && (ocs.teamFGA > 0 || ocs.oppFGA > 0)) {
                    // Dean Oliver possession formula for on-court stats
                    const ocTeamPoss = ocs.teamFGA + 0.44 * ocs.teamFTA - ocs.teamOreb + ocs.teamTov;
                    const ocOppPoss = ocs.oppFGA + 0.44 * ocs.oppFTA - ocs.oppOreb + ocs.oppTov;
                    
                    // Offensive on-court metrics
                    p.onCourtORtg = ocTeamPoss > 0 ? (ocs.teamPoints / ocTeamPoss * 100) : 0;
                    p.onCourtDRtg = ocOppPoss > 0 ? (ocs.oppPoints / ocOppPoss * 100) : 0;
                    p.netRating = p.onCourtORtg - p.onCourtDRtg;
                    p.onCourtEfg = ocs.teamFGA > 0 ? ((ocs.teamFGM + 0.5 * ocs.team3PM) / ocs.teamFGA * 100) : 0;
                    const ocOrebOpps = ocs.teamOreb + ocs.oppDreb;
                    p.onCourtOrebPct = ocOrebOpps > 0 ? (ocs.teamOreb / ocOrebOpps * 100) : 0;
                    const ocTovDenom = ocs.teamFGA + 0.44 * ocs.teamFTA + ocs.teamTov;
                    p.onCourtTovPct = ocTovDenom > 0 ? (ocs.teamTov / ocTovDenom * 100) : 0;
                    
                    // Defensive on-court metrics
                    p.defOnCourtEfg = ocs.oppFGA > 0 ? ((ocs.oppFGM + 0.5 * ocs.opp3PM) / ocs.oppFGA * 100) : 0;
                    const defOrebOpps = ocs.oppOreb + ocs.teamDreb;
                    p.defOnCourtOrebPct = defOrebOpps > 0 ? (ocs.oppOreb / defOrebOpps * 100) : 0;
                    const defTovDenom = ocs.oppFGA + 0.44 * ocs.oppFTA + ocs.oppTov;
                    p.defOnCourtTovPct = defTovDenom > 0 ? (ocs.oppTov / defTovDenom * 100) : 0;
                } else {
                    // Fallback to player-specific estimates
                    p.onCourtORtg = 0;
                    p.onCourtDRtg = 0;
                    p.netRating = 0;
                    p.onCourtEfg = p.fga > 0 ? ((p.fgm + 0.5 * p.fg3m) / p.fga * 100) : 0;
                    p.onCourtOrebPct = 0;
                    p.onCourtTovPct = p.tovPct;
                    p.defOnCourtEfg = 0;
                    p.defOnCourtOrebPct = 0;
                    p.defOnCourtTovPct = 0;
                }
                
                p.pointsAssisted = 0;
                p.totalPointContribution = p.points + (p.ast * 2); // Simple estimate
                
                return p;
            });
        }

        aggregateTeamTotalsForPeriods(teamName, periods, oppTeamName = null) {
            const totals = {
                points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                ftm: 0, fta: 0, oreb: 0, dreb: 0, treb: 0,
                ast: 0, stl: 0, blk: 0, tov: 0, pf: 0,
                // Shot zones
                rimAtt: 0, rimMade: 0,
                midAtt: 0, midMade: 0,
                // Assisted points
                assistedFgm: 0, assistedPoints: 0,
                // Opponent stats for OREB% calculation
                oppDreb: 0, oppOreb: 0, oppFga: 0, oppFgm: 0, oppTov: 0, oppFta: 0, oppPoints: 0,
                oppFg3a: 0, oppFg3m: 0
            };
            
            if (!this.teamPeriodTotals[teamName]) {
                return totals;
            }
            
            periods.forEach(period => {
                const pt = this.teamPeriodTotals[teamName][period];
                if (!pt) return;
                
                totals.points += pt.points || 0;
                totals.fgm += pt.fgm || 0;
                totals.fga += pt.fga || 0;
                totals.fg3m += pt.fg3m || 0;
                totals.fg3a += pt.fg3a || 0;
                totals.ftm += pt.ftm || 0;
                totals.fta += pt.fta || 0;
                totals.oreb += pt.oreb || 0;
                totals.dreb += pt.dreb || 0;
                totals.ast += pt.ast || 0;
                totals.stl += pt.stl || 0;
                totals.blk += pt.blk || 0;
                totals.tov += pt.tov || 0;
                totals.pf += pt.pf || 0;
                // Shot zones
                totals.rimAtt += pt.rimAtt || 0;
                totals.rimMade += pt.rimMade || 0;
                totals.midAtt += pt.midAtt || 0;
                totals.midMade += pt.midMade || 0;
                // Assisted points
                totals.assistedFgm += pt.assistedFgm || 0;
                totals.assistedPoints += pt.assistedPoints || 0;
                
                // Get opponent stats for this period if available
                if (oppTeamName && this.teamPeriodTotals[oppTeamName] && this.teamPeriodTotals[oppTeamName][period]) {
                    const oppPt = this.teamPeriodTotals[oppTeamName][period];
                    totals.oppDreb += oppPt.dreb || 0;
                    totals.oppOreb += oppPt.oreb || 0;
                    totals.oppFga += oppPt.fga || 0;
                    totals.oppFgm += oppPt.fgm || 0;
                    totals.oppTov += oppPt.tov || 0;
                    totals.oppFta += oppPt.fta || 0;
                    totals.oppPoints += oppPt.points || 0;
                    totals.oppFg3a += oppPt.fg3a || 0;
                    totals.oppFg3m += oppPt.fg3m || 0;
                }
            });
            
            totals.treb = totals.oreb + totals.dreb;
            
            // ========================================================================
            // DEAN OLIVER'S POSSESSION FORMULA
            // ========================================================================
            // Possessions = FGA + 0.44 * FTA - OREB + TOV
            // This is the simplified version commonly used in basketball analytics
            // The 0.44 coefficient accounts for and-1s, technical FTs, and 3-shot fouls
            
            const possessions = totals.fga + 0.44 * totals.fta - totals.oreb + totals.tov;
            totals.possessions = Math.max(possessions, 1); // Avoid division by zero
            
            // Offensive Rating = (Points / Possessions) * 100
            totals.ortg = possessions > 0 ? (totals.points / possessions * 100) : 0;
            
            // Calculate opponent possessions for DRtg
            const oppPossessions = totals.oppFga + 0.44 * totals.oppFta - totals.oppOreb + totals.oppTov;
            totals.oppPossessions = Math.max(oppPossessions, 1);
            
            // Defensive Rating = (Opponent Points / Opponent Possessions) * 100
            totals.drtg = oppPossessions > 0 ? (totals.oppPoints / oppPossessions * 100) : 0;
            
            // ========================================================================
            // FOUR FACTORS CALCULATIONS
            // ========================================================================
            
            // Effective Field Goal % = (FGM + 0.5 * 3PM) / FGA
            totals.efg = totals.fga > 0 ? ((totals.fgm + 0.5 * totals.fg3m) / totals.fga * 100) : 0;
            
            // Turnover % = TOV / (FGA + 0.44 * FTA + TOV)
            const tovDenom = totals.fga + 0.44 * totals.fta + totals.tov;
            totals.tovPct = tovDenom > 0 ? (totals.tov / tovDenom * 100) : 0;
            
            // Offensive Rebound % = OREB / (OREB + Opponent DREB)
            // This measures how many of available offensive rebounds the team got
            const orebOpportunities = totals.oreb + totals.oppDreb;
            totals.orebPct = orebOpportunities > 0 ? (totals.oreb / orebOpportunities * 100) : 25;
            
            // Free Throw Rate = FTA / FGA (measures ability to get to the line)
            totals.ftaRate = totals.fga > 0 ? (totals.fta / totals.fga * 100) : 0;
            
            // True Shooting % = Points / (2 * TSA) where TSA = FGA + 0.44 * FTA
            const tsa = totals.fga + 0.44 * totals.fta;
            totals.ts = tsa > 0 ? (totals.points / (2 * tsa) * 100) : 0;
            
            // Assist to Turnover Ratio
            totals.astToRatio = totals.tov > 0 ? (totals.ast / totals.tov) : totals.ast;
            
            // Rebound % (team's share of total rebounds)
            const totalRebs = totals.treb + totals.oppOreb + totals.oppDreb;
            totals.rebPct = totalRebs > 0 ? (totals.treb / totalRebs * 100) : 50;
            
            // ========================================================================
            // ADDITIONAL ADVANCED METRICS
            // ========================================================================
            
            // Points Per Possession
            totals.ppp = possessions > 0 ? (totals.points / possessions) : 0;
            
            // True Shot Attempts (TSA) = FGA + 0.44 * FTA
            totals.tsa = tsa;
            
            // TSA per 100 possessions
            totals.tsaPer100 = possessions > 0 ? (tsa / possessions * 100) : 0;
            
            // Rim attempts per 100 possessions
            totals.rimPer100 = possessions > 0 ? (totals.rimAtt / possessions * 100) : 0;
            totals.rimPct = totals.rimAtt > 0 ? (totals.rimMade / totals.rimAtt * 100) : 0;
            
            // Mid-range attempts per 100 possessions
            totals.midPer100 = possessions > 0 ? (totals.midAtt / possessions * 100) : 0;
            totals.midPct = totals.midAtt > 0 ? (totals.midMade / totals.midAtt * 100) : 0;
            
            // 3PA per 100 possessions
            totals.threePer100 = possessions > 0 ? (totals.fg3a / possessions * 100) : 0;
            totals.threePct = totals.fg3a > 0 ? (totals.fg3m / totals.fg3a * 100) : 0;
            
            // FT%
            totals.ftPct = totals.fta > 0 ? (totals.ftm / totals.fta * 100) : 0;
            
            // AST% = AST / FGM (percentage of FGMs that were assisted)
            totals.astPct = totals.fgm > 0 ? (totals.ast / totals.fgm * 100) : 0;
            
            // A/U = AST% / USG% (approximated)
            // USG% approximation = (FGA + 0.44 * FTA + TOV) / team possessions
            const usgApprox = possessions > 0 ? (tovDenom / possessions * 100) : 25;
            totals.astToUsg = usgApprox > 0 ? (totals.astPct / usgApprox) : 0;
            
            // Steal % = STL / opponent possessions * 100
            totals.stlPct = oppPossessions > 0 ? (totals.stl / oppPossessions * 100) : 0;
            
            // Block % = BLK / (opponent 2PA) * 100
            // Note: Using opponent FGA - 3PA as 2PA approximation
            const opp2pa = totals.oppFga - totals.oppFg3a;
            totals.blkPct = opp2pa > 0 ? (totals.blk / opp2pa * 100) : 0;
            
            // % of Points from Assists
            // FG points (not FT) that came from assists
            const fgPoints = totals.points - totals.ftm;
            totals.assistedPtsPct = fgPoints > 0 ? (totals.assistedPoints / fgPoints * 100) : 0;
            
            return totals;
        }

        // ========================================================================
        // HALF COMPARISON TAB
        // ========================================================================

        renderHalfComparisonTab(teamsData) {
            const teamNames = Object.keys(teamsData);
            if (teamNames.length < 2) {
                return '<div class="stat-card glass-card">No team data available</div>';
            }
            
            const homeTeam = teamNames[0];
            const awayTeam = teamNames[1];
            
            // Check if we have period data
            const hasData = this.teamPeriodTotals[homeTeam] && 
                           (this.teamPeriodTotals[homeTeam][1] || this.teamPeriodTotals[homeTeam][2]);
            
            if (!hasData) {
                return `
                    <div class="stat-card glass-card full-width" style="text-align: center; padding: 60px;">
                        <h3 style="color: var(--text-muted);">📈 Half Comparison + Total Not Available</h3>
                        <p style="color: var(--text-muted); margin-top: 16px;">Play-by-play data is required to compare halves.</p>
                        <p style="color: var(--text-muted); margin-top: 8px;">Upload both boxscore and PBP files to see this analysis.</p>
                    </div>
                `;
            }
            
            // Get aggregated stats for each half (pass opponent team for OREB% calculation)
            const homeFirst = this.aggregateTeamTotalsForPeriods(homeTeam, [1, 2], awayTeam);
            const homeSecond = this.aggregateTeamTotalsForPeriods(homeTeam, [3, 4], awayTeam);
            const awayFirst = this.aggregateTeamTotalsForPeriods(awayTeam, [1, 2], homeTeam);
            const awaySecond = this.aggregateTeamTotalsForPeriods(awayTeam, [3, 4], homeTeam);
            
            // Get total game stats (all periods)
            const homeTotal = this.aggregateTeamTotalsForPeriods(homeTeam, [1, 2, 3, 4], awayTeam);
            const awayTotal = this.aggregateTeamTotalsForPeriods(awayTeam, [1, 2, 3, 4], homeTeam);
            
            return `
                <div class="half-comparison-wrapper" id="half-comparison-wrapper">
                    <!-- Toggle Button -->
                    <div class="comparison-toggle-container">
                        <button class="comparison-toggle-btn" id="total-toggle-btn" onclick="window.fibaVisualizer.toggleTotalView()">
                            <span class="toggle-text">Show Total Comparison</span>
                        </button>
                    </div>
                    
                    <!-- Three Panel Layout -->
                    <div class="comparison-panels" id="comparison-panels">
                        <!-- Home Half Panel -->
                        <div class="comparison-panel home-panel expanded" id="home-panel">
                            <div class="panel-collapse-caret" onclick="window.fibaVisualizer.expandHalfPanel('home')">
                                <span class="caret-icon">›</span>
                                <span class="caret-label">${homeTeam.substring(0, 3).toUpperCase()}</span>
                            </div>
                            <div class="panel-content">
                                ${this.renderTeamHalfComparison(homeTeam, homeFirst, homeSecond, true)}
                            </div>
                        </div>
                        
                        <!-- Total Comparison Panel (Center) -->
                        <div class="comparison-panel total-panel collapsed" id="total-panel">
                            <div class="panel-content">
                                ${this.renderTotalComparison(homeTeam, awayTeam, homeTotal, awayTotal)}
                            </div>
                        </div>
                        
                        <!-- Away Half Panel -->
                        <div class="comparison-panel away-panel expanded" id="away-panel">
                            <div class="panel-collapse-caret" onclick="window.fibaVisualizer.expandHalfPanel('away')">
                                <span class="caret-icon">‹</span>
                                <span class="caret-label">${awayTeam.substring(0, 3).toUpperCase()}</span>
                            </div>
                            <div class="panel-content">
                                ${this.renderTeamHalfComparison(awayTeam, awayFirst, awaySecond, false)}
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="four-factors-comparison">
                    ${this.renderFourFactorsComparison(homeTeam, awayTeam, homeFirst, homeSecond, awayFirst, awaySecond)}
                </div>
            `;
        }
        
        renderTotalComparison(homeTeam, awayTeam, homeTotal, awayTotal) {
            const sections = {
                scoring: {
                    title: 'Scoring',
                    metrics: [
                        { key: 'points', label: 'POINTS', format: v => v.toFixed(0) },
                        { key: 'ppp', label: 'PPP', format: v => v.toFixed(3) },
                        { key: 'ortg', label: 'ORTG', format: v => v.toFixed(1) }
                    ]
                },
                efficiency: {
                    title: 'Efficiency',
                    metrics: [
                        { key: 'efg', label: 'eFG%', format: v => v.toFixed(1) },
                        { key: 'ts', label: 'TS%', format: v => v.toFixed(1) },
                        { key: 'tsaPer100', label: 'TSA/100', format: v => v.toFixed(1) }
                    ]
                },
                shots: {
                    title: 'Shot Distribution',
                    metrics: [
                        { key: 'rimPer100', label: 'RIMA/100', format: v => v.toFixed(1) },
                        { key: 'rimPct', label: 'RIM%', format: v => v.toFixed(1) },
                        { key: 'midPer100', label: 'MIDA/100', format: v => v.toFixed(1) },
                        { key: 'midPct', label: 'MID%', format: v => v.toFixed(1) },
                        { key: 'threePer100', label: '3PTA/100', format: v => v.toFixed(1) },
                        { key: 'threePct', label: '3PT%', format: v => v.toFixed(1) }
                    ]
                },
                ft: {
                    title: 'Free Throws',
                    metrics: [
                        { key: 'ftaRate', label: 'FT RATE', format: v => v.toFixed(1) },
                        { key: 'ftPct', label: 'FT%', format: v => v.toFixed(1) }
                    ]
                },
                ballcontrol: {
                    title: 'Ball Control & Rebounding',
                    metrics: [
                        { key: 'orebPct', label: 'OREB%', format: v => v.toFixed(1) },
                        { key: 'astPct', label: 'AST%', format: v => v.toFixed(1) },
                        { key: 'astToUsg', label: 'A/U', format: v => v.toFixed(2) },
                        { key: 'tovPct', label: 'TOV%', format: v => v.toFixed(1), inverted: true }
                    ]
                },
                defense: {
                    title: 'Defense',
                    metrics: [
                        { key: 'stlPct', label: 'STL%', format: v => v.toFixed(1) },
                        { key: 'blkPct', label: 'BLK%', format: v => v.toFixed(1) }
                    ]
                },
                playmaking: {
                    title: 'Playmaking',
                    metrics: [
                        { key: 'assistedPtsPct', label: '% PTS OFF AST', format: v => v.toFixed(1) }
                    ]
                }
            };
            
            const renderTugOfWarRow = (metric) => {
                const homeVal = homeTotal[metric.key] || 0;
                const awayVal = awayTotal[metric.key] || 0;
                const total = homeVal + awayVal;
                
                // Calculate percentages for tug-of-war bar
                let homeWidth = 50;
                let awayWidth = 50;
                if (total > 0) {
                    homeWidth = (homeVal / total) * 100;
                    awayWidth = (awayVal / total) * 100;
                }
                
                // Determine which team is "winning" this stat
                const homeBetter = metric.inverted ? homeVal < awayVal : homeVal > awayVal;
                const awayBetter = metric.inverted ? awayVal < homeVal : awayVal > homeVal;
                
                return `
                    <div class="tow-metric-row">
                        <span class="tow-value home ${homeBetter ? 'better' : ''}">${metric.format(homeVal)}</span>
                        <div class="tow-bar-container">
                            <div class="tow-bar home" style="width: ${homeWidth}%;"></div>
                            <div class="tow-bar away" style="width: ${awayWidth}%;"></div>
                        </div>
                        <span class="tow-value away ${awayBetter ? 'better' : ''}">${metric.format(awayVal)}</span>
                    </div>
                    <div class="tow-metric-label">${metric.label}</div>
                `;
            };
            
            const renderSection = (sectionKey, section) => {
                return `
                    <div class="tow-section-header" data-section="${sectionKey}" onclick="window.fibaVisualizer.toggleTotalSection('${sectionKey}')">
                        <span class="tow-section-title">${section.title}</span>
                    </div>
                    <div class="tow-section-content" data-section="${sectionKey}">
                        ${section.metrics.map(m => renderTugOfWarRow(m)).join('')}
                    </div>
                `;
            };
            
            return `
                <div class="total-comparison-card glass-card" id="total-comparison-card">
                    <div class="total-comparison-header">
                        <div class="team-side home">
                            <span class="team-indicator home"></span>
                            <span class="team-name">${homeTeam}</span>
                        </div>
                        <div class="total-title">TOTAL</div>
                        <div class="team-side away">
                            <span class="team-name">${awayTeam}</span>
                            <span class="team-indicator away"></span>
                        </div>
                    </div>
                    <div class="total-comparison-body">
                        ${Object.entries(sections).map(([key, section]) => renderSection(key, section)).join('')}
                    </div>
                </div>
            `;
        }

        renderTeamHalfComparison(teamName, firstHalf, secondHalf, isHome) {
            const teamClass = isHome ? 'home' : 'away';
            const uniqueId = isHome ? 'home-comparison' : 'away-comparison';
            
            const sections = {
                scoring: {
                    title: 'Scoring',
                    metrics: [
                        { key: 'points', label: 'POINTS', format: v => v.toFixed(0) },
                        { key: 'ppp', label: 'PPP', format: v => v.toFixed(3) },
                        { key: 'ortg', label: 'ORTG', format: v => v.toFixed(1) }
                    ]
                },
                efficiency: {
                    title: 'Efficiency',
                    metrics: [
                        { key: 'efg', label: 'eFG%', format: v => v.toFixed(1) },
                        { key: 'ts', label: 'TS%', format: v => v.toFixed(1) },
                        { key: 'tsaPer100', label: 'TSA/100', format: v => v.toFixed(1) }
                    ]
                },
                shots: {
                    title: 'Shot Distribution',
                    metrics: [
                        { key: 'rimPer100', label: 'RIMA/100', format: v => v.toFixed(1) },
                        { key: 'rimPct', label: 'RIM%', format: v => v.toFixed(1) },
                        { key: 'midPer100', label: 'MIDA/100', format: v => v.toFixed(1) },
                        { key: 'midPct', label: 'MID%', format: v => v.toFixed(1) },
                        { key: 'threePer100', label: '3PTA/100', format: v => v.toFixed(1) },
                        { key: 'threePct', label: '3PT%', format: v => v.toFixed(1) }
                    ]
                },
                ft: {
                    title: 'Free Throws',
                    metrics: [
                        { key: 'ftaRate', label: 'FT RATE', format: v => v.toFixed(1) },
                        { key: 'ftPct', label: 'FT%', format: v => v.toFixed(1) }
                    ]
                },
                ballcontrol: {
                    title: 'Ball Control & Rebounding',
                    metrics: [
                        { key: 'orebPct', label: 'OREB%', format: v => v.toFixed(1) },
                        { key: 'astPct', label: 'AST%', format: v => v.toFixed(1) },
                        { key: 'astToUsg', label: 'A/U', format: v => v.toFixed(2) },
                        { key: 'tovPct', label: 'TOV%', format: v => v.toFixed(1), inverted: true }
                    ]
                },
                defense: {
                    title: 'Defense',
                    metrics: [
                        { key: 'stlPct', label: 'STL%', format: v => v.toFixed(1) },
                        { key: 'blkPct', label: 'BLK%', format: v => v.toFixed(1) }
                    ]
                },
                playmaking: {
                    title: 'Playmaking',
                    metrics: [
                        { key: 'assistedPtsPct', label: '% PTS OFF AST', format: v => v.toFixed(1) }
                    ]
                }
            };
            
            const renderMetricRow = (metric) => {
                const firstVal = firstHalf[metric.key] || 0;
                const secondVal = secondHalf[metric.key] || 0;
                const change = secondVal - firstVal;
                const changeClass = metric.inverted 
                    ? (change < 0 ? 'positive' : change > 0 ? 'negative' : 'neutral')
                    : (change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral');
                
                const maxVal = Math.max(firstVal, secondVal, 0.1);
                const firstWidth = (firstVal / maxVal) * 50;
                const secondWidth = (secondVal / maxVal) * 50;
                
                const firstDisplay = metric.format(firstVal);
                const secondDisplay = metric.format(secondVal);
                
                return `
                    <div class="comparison-metric">
                        <span class="metric-name">${metric.label}</span>
                        <div class="metric-values">
                            <span class="half-value first">${firstDisplay}</span>
                            <div class="comparison-bar-container">
                                <div class="comparison-bar-row halves-row">
                                    <div class="comparison-bar first" style="width: ${firstWidth}%;">
                                        ${firstWidth > 15 ? `<span class="comparison-bar-value">${firstDisplay}</span>` : ''}
                                    </div>
                                    <div class="comparison-bar second" style="width: ${secondWidth}%; margin-left: auto;">
                                        ${secondWidth > 15 ? `<span class="comparison-bar-value">${secondDisplay}</span>` : ''}
                                    </div>
                                </div>
                            </div>
                            <span class="half-value second">${secondDisplay}</span>
                            <span class="change-indicator ${changeClass}">
                                ${change >= 0 ? '+' : ''}${metric.format(change)}
                            </span>
                        </div>
                    </div>
                `;
            };
            
            const renderSection = (sectionKey, section) => {
                return `
                    <div class="comparison-section-header" data-section="${sectionKey}" data-card="${uniqueId}" onclick="window.fibaVisualizer.toggleComparisonSection('${uniqueId}', '${sectionKey}')">
                        <span class="comparison-section-title">${section.title}</span>
                    </div>
                    <div class="comparison-section-content" data-section="${sectionKey}" data-card="${uniqueId}">
                        ${section.metrics.map(m => renderMetricRow(m)).join('')}
                    </div>
                `;
            };
            
            return `
                <div class="comparison-card glass-card" id="${uniqueId}">
                    <div class="comparison-header">
                        <span class="comparison-title">
                            <span class="team-indicator ${teamClass}"></span>
                            ${teamName}
                        </span>
                        <div style="display: flex; gap: 8px;">
                            <span class="half-label first">1st Half</span>
                            <span class="half-label second">2nd Half</span>
                        </div>
                    </div>
                    ${Object.entries(sections).map(([key, section]) => renderSection(key, section)).join('')}
                </div>
            `;
        }

        renderFourFactorsComparison(homeTeam, awayTeam, homeFirst, homeSecond, awayFirst, awaySecond) {
            const factors = [
                { key: 'ppp', label: 'PPP', cssClass: 'efg', format: v => v.toFixed(2) },
                { key: 'efg', label: 'eFG%', cssClass: 'efg', format: v => v.toFixed(1) },
                { key: 'ts', label: 'TS%', cssClass: 'efg', format: v => v.toFixed(1) },
                { key: 'tovPct', label: 'TOV%', cssClass: 'tov', format: v => v.toFixed(1), inverted: true },
                { key: 'orebPct', label: 'OREB%', cssClass: 'oreb', format: v => v.toFixed(1) },
                { key: 'ftaRate', label: 'FT Rate', cssClass: 'ft', format: v => v.toFixed(1) },
                { key: 'assistedPtsPct', label: '% AST', cssClass: 'ast', format: v => v.toFixed(1) }
            ];
            
            const renderFactorCard = (factor, teamName, first, second, isHome) => {
                const firstVal = first[factor.key] || 0;
                const secondVal = second[factor.key] || 0;
                const change = secondVal - firstVal;
                const changeClass = factor.inverted 
                    ? (change < 0 ? 'positive' : change > 0 ? 'negative' : 'neutral')
                    : (change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral');
                
                return `
                    <div class="factor-card ${factor.cssClass}">
                        <div class="factor-name">${factor.label}</div>
                        <div class="factor-comparison">
                            <div class="factor-half">
                                <div class="factor-half-label first">1H</div>
                                <div class="factor-half-value">${factor.format(firstVal)}</div>
                            </div>
                            <div class="factor-half">
                                <div class="factor-half-label second">2H</div>
                                <div class="factor-half-value">${factor.format(secondVal)}</div>
                            </div>
                        </div>
                        <span class="factor-change ${changeClass}">
                            ${change >= 0 ? '+' : ''}${factor.format(change)}
                        </span>
                    </div>
                `;
            };
            
            return `
                <div class="stat-card glass-card full-width" style="margin-top: var(--space-xl);">
                    <div class="card-header">
                        <span class="card-title">📊 Four Factors: Half-by-Half Comparison</span>
                    </div>
                    
                    <div style="margin-bottom: var(--space-xl);">
                        <h4 style="color: var(--team-home); margin-bottom: var(--space-md); font-size: 14px; display: flex; align-items: center; gap: 8px;">
                            <span class="team-indicator home"></span>${homeTeam}
                        </h4>
                        <div class="factors-grid">
                            ${factors.map(f => renderFactorCard(f, homeTeam, homeFirst, homeSecond, true)).join('')}
                        </div>
                    </div>
                    
                    <div>
                        <h4 style="color: var(--team-away); margin-bottom: var(--space-md); font-size: 14px; display: flex; align-items: center; gap: 8px;">
                            <span class="team-indicator away"></span>${awayTeam}
                        </h4>
                        <div class="factors-grid">
                            ${factors.map(f => renderFactorCard(f, awayTeam, awayFirst, awaySecond, false)).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        renderLineupsTab(teamsData) {
            const teamNames = Object.keys(teamsData);
            const homeTeam = teamNames[0];
            const awayTeam = teamNames[1];

            const lineups = Object.entries(this.lineupStats)
                .filter(([key, stats]) => stats.seconds >= 60)
                .sort((a, b) => b[1].seconds - a[1].seconds);

            if (lineups.length === 0) {
                return `
                    <div class="stat-card glass-card full-width" style="text-align: center; padding: 60px;">
                        <h3 style="color: var(--text-muted);">No lineup data available</h3>
                        <p style="color: var(--text-muted); margin-top: 16px;">Upload play-by-play data to see lineup analysis</p>
                    </div>
                `;
            }

            const homeLineups = lineups.filter(([key]) => key.startsWith(homeTeam));
            const awayLineups = lineups.filter(([key]) => key.startsWith(awayTeam));

            // Build table rows data
            const buildLineupRowData = (key, stats) => {
                const [teamName, playersStr] = key.split('|');
                const playerNumbers = playersStr.split(',').filter(n => n);
                const minutes = stats.seconds / 60;
                const roster = this.playerRoster[teamName] || {};
                const teamData = teamsData[teamName];

                const playerNames = playerNumbers.map(num => {
                    if (roster[num]) return roster[num];
                    if (teamData && teamData.players) {
                        const player = teamData.players.find(p => p.number === num);
                        if (player) return player.name;
                    }
                    return `#${num}`;
                });

                // Calculate stats
                const poss = 0.96 * (stats.fga + stats.tov + 0.44 * stats.fta - stats.oreb);
                const offEfg = stats.fga > 0 ? ((stats.fgm + 0.5 * stats.fg3m) / stats.fga * 100) : 0;
                const offTovPct = (stats.fga + 0.44 * stats.fta + stats.tov) > 0 ?
                    (stats.tov / (stats.fga + 0.44 * stats.fta + stats.tov) * 100) : 0;
                const offOrebPct = (stats.oreb + (stats.defOrebAllowed || 0)) > 0 ?
                    (stats.oreb / (stats.oreb + (stats.defOrebAllowed || 0)) * 100) : 0;
                const offRtg = poss > 0 ? (stats.points / poss * 100) : 0;

                const defPoss = 0.96 * ((stats.defFga || 0) + (stats.defTovForced || 0) +
                    0.44 * (stats.defFta || 0) - (stats.defOrebAllowed || 0));
                const defEfg = (stats.defFga || 0) > 0 ?
                    (((stats.defFgm || 0) + 0.5 * (stats.defFg3m || 0)) / (stats.defFga || 0) * 100) : 0;
                const defRtg = defPoss > 0 ? ((stats.pointsAllowed || 0) / defPoss * 100) : 0;

                const netRtg = offRtg - defRtg;
                const plusMinus = (stats.points || 0) - (stats.pointsAllowed || 0);
                const isHome = teamNames[0] === teamName;

                return { teamName, playerNames, minutes, stats, offRtg, defRtg, netRtg, offEfg, offTovPct, offOrebPct, plusMinus, isHome };
            };

            const allRowData = lineups.map(([key, stats]) => buildLineupRowData(key, stats));
            const homeRowData = allRowData.filter(d => d.isHome);
            const awayRowData = allRowData.filter(d => !d.isHome);

            const renderLineupTable = (rows, tableId) => {
                const getValueClass = (val, goodThreshold, badThreshold, lowerBetter = false) => {
                    if (lowerBetter) {
                        if (val <= goodThreshold) return 'good';
                        if (val >= badThreshold) return 'bad';
                    } else {
                        if (val >= goodThreshold) return 'good';
                        if (val <= badThreshold) return 'bad';
                    }
                    return 'neutral';
                };

                return `
                    <div class="lineup-table-container" style="overflow-x: auto; margin-top: 16px;">
                        <table class="lineup-stats-table" id="${tableId}" style="width: 100%; border-collapse: collapse; font-size: 11px;">
                            <thead>
                                <tr style="background: rgba(255,255,255,0.05);">
                                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--border-subtle); min-width: 40px;"></th>
                                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--border-subtle); min-width: 200px;">Lineup</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--border-subtle);">MIN</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--border-subtle);">PTS</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--accent-cyan); border-left: 2px solid var(--accent-cyan); background: rgba(0,212,255,0.08);">ORtg</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--accent-cyan); background: rgba(0,212,255,0.08);">eFG%</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--accent-cyan); background: rgba(0,212,255,0.08);">TOV%</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--accent-cyan); background: rgba(0,212,255,0.08);">ORB%</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--accent-magenta); border-left: 2px solid var(--accent-magenta); background: rgba(255,0,170,0.08);">DRtg</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--accent-magenta); background: rgba(255,0,170,0.08);">Opp eFG</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--gold); border-left: 2px solid var(--gold); background: rgba(255,208,0,0.08);">Net</th>
                                    <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--gold); background: rgba(255,208,0,0.08);">+/-</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${rows.map((d, i) => {
                                    const teamColor = d.isHome ? 'var(--accent-cyan)' : 'var(--accent-magenta)';
                                    const bgColor = this.getNetRatingBackground(d.netRtg);
                                    return `
                                        <tr style="background: ${bgColor}; border-bottom: 1px solid rgba(255,255,255,0.05);">
                                            <td style="padding: 8px;">
                                                <span style="width: 10px; height: 10px; border-radius: 50%; background: ${teamColor}; display: inline-block;"></span>
                                            </td>
                                            <td style="padding: 8px; text-align: left;">
                                                <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                                                    ${d.playerNames.map(name => `<span style="font-size: 10px; padding: 2px 5px; background: rgba(255,255,255,0.08); border-radius: 4px;">${name.split(' ').pop() || name}</span>`).join('')}
                                                </div>
                                            </td>
                                            <td style="padding: 8px; text-align: center; font-weight: 600;">${d.minutes.toFixed(1)}</td>
                                            <td style="padding: 8px; text-align: center;">${d.stats.points || 0}</td>
                                            <td style="padding: 8px; text-align: center; border-left: 2px solid var(--accent-cyan); background: rgba(0,212,255,0.03);" class="${getValueClass(d.offRtg, 110, 95)}">${d.offRtg.toFixed(0)}</td>
                                            <td style="padding: 8px; text-align: center; background: rgba(0,212,255,0.03);" class="${getValueClass(d.offEfg, 52, 45)}">${d.offEfg.toFixed(0)}%</td>
                                            <td style="padding: 8px; text-align: center; background: rgba(0,212,255,0.03);" class="${getValueClass(d.offTovPct, 12, 18, true)}">${d.offTovPct.toFixed(0)}%</td>
                                            <td style="padding: 8px; text-align: center; background: rgba(0,212,255,0.03);" class="${getValueClass(d.offOrebPct, 30, 20)}">${d.offOrebPct.toFixed(0)}%</td>
                                            <td style="padding: 8px; text-align: center; border-left: 2px solid var(--accent-magenta); background: rgba(255,0,170,0.03);" class="${getValueClass(d.defRtg, 100, 115, true)}">${d.defRtg.toFixed(0)}</td>
                                            <td style="padding: 8px; text-align: center; background: rgba(255,0,170,0.03);">${((d.stats.defFga || 0) > 0 ? (((d.stats.defFgm || 0) + 0.5 * (d.stats.defFg3m || 0)) / (d.stats.defFga || 0) * 100) : 0).toFixed(0)}%</td>
                                            <td style="padding: 8px; text-align: center; font-weight: 700; border-left: 2px solid var(--gold); background: rgba(255,208,0,0.03); color: ${d.netRtg >= 0 ? 'var(--positive)' : 'var(--negative)'};">${d.netRtg >= 0 ? '+' : ''}${d.netRtg.toFixed(0)}</td>
                                            <td style="padding: 8px; text-align: center; font-weight: 700; background: ${d.plusMinus >= 0 ? 'rgba(0,255,136,0.15)' : 'rgba(255,107,107,0.15)'}; border-radius: 4px; color: ${d.plusMinus >= 0 ? 'var(--positive)' : 'var(--negative)'};">${d.plusMinus >= 0 ? '+' : ''}${d.plusMinus}</td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            };

            return `
                <div class="lineup-filter-container">
                    <div class="lineup-filter-buttons">
                        <button class="lineup-filter-btn active" data-team="all">All Teams</button>
                        <button class="lineup-filter-btn home-btn" data-team="home">${homeTeam}</button>
                        <button class="lineup-filter-btn away-btn" data-team="away">${awayTeam}</button>
                    </div>
                    <div class="lineup-view-toggle" style="display: flex; gap: 8px; margin-left: auto;">
                        <button class="lineup-view-btn active" data-view="cards" style="padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border-subtle); background: var(--bg-elevated); color: var(--text-primary); cursor: pointer; font-size: 11px;">📊 Cards</button>
                        <button class="lineup-view-btn" data-view="table" style="padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border-subtle); background: transparent; color: var(--text-muted); cursor: pointer; font-size: 11px;">📋 Table</button>
                    </div>
                    <div class="lineup-count">
                        <span class="lineup-count-all">${lineups.length} lineups</span>
                        <span class="lineup-count-home" style="display:none;">${homeLineups.length} lineups</span>
                        <span class="lineup-count-away" style="display:none;">${awayLineups.length} lineups</span>
                    </div>
                </div>

                <!-- Card Views -->
                <div class="lineup-cards-view">
                    <div class="lineup-grid" id="lineups-all">
                        ${lineups.map(([key, stats]) => this.renderLineupCard(key, stats, teamsData)).join('')}
                    </div>
                    <div class="lineup-grid" id="lineups-home" style="display:none;">
                        ${homeLineups.map(([key, stats]) => this.renderLineupCard(key, stats, teamsData)).join('')}
                    </div>
                    <div class="lineup-grid" id="lineups-away" style="display:none;">
                        ${awayLineups.map(([key, stats]) => this.renderLineupCard(key, stats, teamsData)).join('')}
                    </div>
                </div>

                <!-- Table Views -->
                <div class="lineup-table-view" style="display: none;">
                    <div id="lineup-table-all">
                        ${renderLineupTable(allRowData, 'lineup-table-all-data')}
                    </div>
                    <div id="lineup-table-home" style="display:none;">
                        ${renderLineupTable(homeRowData, 'lineup-table-home-data')}
                    </div>
                    <div id="lineup-table-away" style="display:none;">
                        ${renderLineupTable(awayRowData, 'lineup-table-away-data')}
                    </div>
                </div>
            `;
        }
        
        // Helper to get background color based on net rating
        getNetRatingBackground(netRtg) {
            // Clamp net rating to -30 to +30 range for color calculation
            const clampedRtg = Math.max(-30, Math.min(30, netRtg));
            const intensity = Math.abs(clampedRtg) / 30; // 0 to 1
            
            if (netRtg >= 0) {
                // Green gradient for positive - rgba(0, 255, 136, intensity * 0.15)
                return `rgba(0, 255, 136, ${(intensity * 0.18).toFixed(2)})`;
            } else {
                // Red gradient for negative - rgba(255, 107, 107, intensity * 0.15)
                return `rgba(255, 107, 107, ${(intensity * 0.18).toFixed(2)})`;
            }
        }

        renderLineupCard(key, stats, teamsData) {
            const [teamName, playersStr] = key.split('|');
            const playerNumbers = playersStr.split(',').filter(n => n);
            const minutes = stats.seconds / 60;
            
            // Get player names from roster using jersey numbers
            const teamData = teamsData[teamName];
            const roster = this.playerRoster[teamName] || {};
            
            const playerNames = playerNumbers.map(num => {
                // Try to find player name from roster
                if (roster[num]) {
                    return roster[num]; // Return full name
                }
                // Fallback to player data
                if (teamData && teamData.players) {
                    const player = teamData.players.find(p => p.number === num);
                    if (player) {
                        return player.name; // Return full name
                    }
                }
                return `#${num}`;
            }).join(' • ');
            
            // Calculate four factors for offense
            const poss = 0.96 * (stats.fga + stats.tov + 0.44 * stats.fta - stats.oreb);
            const offEfg = stats.fga > 0 ? ((stats.fgm + 0.5 * stats.fg3m) / stats.fga * 100) : 0;
            const offTovPct = (stats.fga + 0.44 * stats.fta + stats.tov) > 0 ? 
                (stats.tov / (stats.fga + 0.44 * stats.fta + stats.tov) * 100) : 0;
            const offOrebPct = (stats.oreb + (stats.defOrebAllowed || 0)) > 0 ? 
                (stats.oreb / (stats.oreb + (stats.defOrebAllowed || 0)) * 100) : 0;
            const offFtRate = stats.fga > 0 ? (stats.fta / stats.fga * 100) : 0;
            const offRtg = poss > 0 ? (stats.points / poss * 100) : 0;
            
            // Calculate four factors for defense
            const defPoss = 0.96 * ((stats.defFga || 0) + (stats.defTovForced || 0) + 
                0.44 * (stats.defFta || 0) - (stats.defOrebAllowed || 0));
            const defEfg = (stats.defFga || 0) > 0 ? 
                (((stats.defFgm || 0) + 0.5 * (stats.defFg3m || 0)) / (stats.defFga || 0) * 100) : 0;
            const defTovPct = ((stats.defFga || 0) + 0.44 * (stats.defFta || 0) + (stats.defTovForced || 0)) > 0 ? 
                ((stats.defTovForced || 0) / ((stats.defFga || 0) + 0.44 * (stats.defFta || 0) + (stats.defTovForced || 0)) * 100) : 0;
            const defOrebPctAllowed = ((stats.defOrebAllowed || 0) + stats.dreb) > 0 ? 
                ((stats.defOrebAllowed || 0) / ((stats.defOrebAllowed || 0) + stats.dreb) * 100) : 0;
            const defFtRate = (stats.defFga || 0) > 0 ? ((stats.defFta || 0) / (stats.defFga || 0) * 100) : 0;
            const defRtg = defPoss > 0 ? ((stats.pointsAllowed || 0) / defPoss * 100) : 0;
            
            const netRtg = offRtg - defRtg;
            const netClass = netRtg >= 0 ? 'positive' : 'negative';
            
            const teamNames = Object.keys(teamsData);
            const isHomeTeam = teamNames[0] === teamName;
            const teamClass = isHomeTeam ? 'home' : 'away';
            
            const getValueClass = (val, goodThreshold, badThreshold, lowerBetter = false) => {
                if (lowerBetter) {
                    if (val <= goodThreshold) return 'good';
                    if (val >= badThreshold) return 'bad';
                } else {
                    if (val >= goodThreshold) return 'good';
                    if (val <= badThreshold) return 'bad';
                }
                return 'neutral';
            };
            
            return `
                <div class="lineup-card glass-card" style="background: linear-gradient(135deg, ${this.getNetRatingBackground(netRtg)}, var(--bg-elevated));">
                    <div class="lineup-header">
                        <div>
                            <div class="lineup-players">${playerNames}</div>
                            <div class="lineup-time">⏱️ <span>${minutes.toFixed(1)}</span> min</div>
                        </div>
                        <span class="team-indicator ${teamClass}"></span>
                    </div>
                    
                    <div class="lineup-stats">
                        <div class="lineup-stat-group offense">
                            <h5>⚔️ Offense</h5>
                            <div class="lineup-factor">
                                <span class="lineup-factor-label">ORtg</span>
                                <span class="lineup-factor-value ${getValueClass(offRtg, 110, 95)}">${offRtg.toFixed(1)}</span>
                            </div>
                            <div class="lineup-factor">
                                <span class="lineup-factor-label">eFG%</span>
                                <span class="lineup-factor-value ${getValueClass(offEfg, 52, 45)}">${offEfg.toFixed(1)}%</span>
                            </div>
                            <div class="lineup-factor">
                                <span class="lineup-factor-label">TOV%</span>
                                <span class="lineup-factor-value ${getValueClass(offTovPct, 12, 18, true)}">${offTovPct.toFixed(1)}%</span>
                            </div>
                            <div class="lineup-factor">
                                <span class="lineup-factor-label">OREB%</span>
                                <span class="lineup-factor-value ${getValueClass(offOrebPct, 30, 20)}">${offOrebPct.toFixed(1)}%</span>
                            </div>
                            <div class="lineup-factor">
                                <span class="lineup-factor-label">FT Rate</span>
                                <span class="lineup-factor-value ${getValueClass(offFtRate, 30, 15)}">${offFtRate.toFixed(1)}%</span>
                            </div>
                        </div>
                        
                        <div class="lineup-stat-group defense">
                            <h5>🛡️ Defense</h5>
                            <div class="lineup-factor">
                                <span class="lineup-factor-label">DRtg</span>
                                <span class="lineup-factor-value ${getValueClass(defRtg, 100, 115, true)}">${defRtg.toFixed(1)}</span>
                            </div>
                            <div class="lineup-factor">
                                <span class="lineup-factor-label">Opp eFG%</span>
                                <span class="lineup-factor-value ${getValueClass(defEfg, 45, 52, true)}">${defEfg.toFixed(1)}%</span>
                            </div>
                            <div class="lineup-factor">
                                <span class="lineup-factor-label">TOV Forced%</span>
                                <span class="lineup-factor-value ${getValueClass(defTovPct, 18, 12)}">${defTovPct.toFixed(1)}%</span>
                            </div>
                            <div class="lineup-factor">
                                <span class="lineup-factor-label">OREB% Allowed</span>
                                <span class="lineup-factor-value ${getValueClass(defOrebPctAllowed, 20, 30, true)}">${defOrebPctAllowed.toFixed(1)}%</span>
                            </div>
                            <div class="lineup-factor">
                                <span class="lineup-factor-label">Opp FT Rate</span>
                                <span class="lineup-factor-value ${getValueClass(defFtRate, 15, 30, true)}">${defFtRate.toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="lineup-net">
                        <div class="lineup-net-value ${netClass}">${netRtg >= 0 ? '+' : ''}${netRtg.toFixed(1)}</div>
                        <div class="lineup-net-label">Net Rating</div>
                    </div>
                </div>
            `;
        }
        
        // ========================================================================
        // MARGIN TAB - Statistical Margin Analysis with EPA Modeling
        // ========================================================================
        
        renderMarginTab(teamsData, homeTotals, awayTotals, pace) {
            const teamNames = Object.keys(teamsData);
            const homeTeam = teamNames[0];
            const awayTeam = teamNames[1];
            
            // Store data for later use in calculations
            this.marginData = {
                homeTeam, awayTeam, homeTotals, awayTotals, pace,
                selectedWinner: 'home',
                wantedMargin: Math.abs(homeTotals.points - awayTotals.points) + 5,
                // Editable battle values (initialized from actual stats)
                battles: {
                    homeTov: homeTotals.tov || 0,
                    awayTov: awayTotals.tov || 0,
                    homeOreb: homeTotals.oreb || 0,
                    awayOreb: awayTotals.oreb || 0,
                    homeEfg: homeTotals.efg || 50,
                    awayEfg: awayTotals.efg || 50,
                    homeFtRate: homeTotals.ftaRate || 25,
                    awayFtRate: awayTotals.ftaRate || 25
                }
            };
            
            // Define stats to display (excluding points, PPP, ORTG as requested)
            const statCategories = {
                shooting: {
                    title: '🎯 Shooting',
                    stats: [
                        { key: 'fgm', label: 'FGM', epa: 2.0, desc: 'Each FGM ≈ 2 pts' },
                        { key: 'fga', label: 'FGA', epa: -0.5, desc: 'Each FGA without make ≈ -0.5 pts (missed opportunity)' },
                        { key: 'fg3m', label: '3PM', epa: 3.0, desc: 'Each 3PM = 3 pts' },
                        { key: 'fg3a', label: '3PA', epa: -0.45, desc: 'Each missed 3PA ≈ -0.45 pts' },
                        { key: 'ftm', label: 'FTM', epa: 1.0, desc: 'Each FTM = 1 pt' },
                        { key: 'fta', label: 'FTA', epa: 0.75, desc: 'Each FTA ≈ 0.75 pts (avg FT%)' }
                    ]
                },
                efficiency: {
                    title: '📊 Efficiency Metrics',
                    stats: [
                        { key: 'efg', label: 'eFG%', epa: 1.77, desc: '+1.77 pts/100poss per 1% eFG' },
                        { key: 'ts', label: 'TS%', epa: 1.5, desc: '+1.5 pts/100poss per 1% TS' },
                        { key: 'tovPct', label: 'TOV%', epa: -0.96, desc: '-0.96 pts/100poss per 1% TOV%', inverted: true },
                        { key: 'orebPct', label: 'OREB%', epa: 0.24, desc: '+0.24 pts/100poss per 1% OREB%' },
                        { key: 'ftaRate', label: 'FT Rate', epa: 0.25, desc: '+0.25 pts/100poss per 1% FT Rate' }
                    ]
                },
                counting: {
                    title: '📈 Counting Stats',
                    stats: [
                        { key: 'oreb', label: 'OREB', epa: 1.1, desc: 'Each OREB ≈ 1.1 pts (extra possession)' },
                        { key: 'dreb', label: 'DREB', epa: 0.4, desc: 'Each DREB ≈ 0.4 pts (denied possession)' },
                        { key: 'ast', label: 'AST', epa: 0.5, desc: 'Each AST ≈ 0.5 pts (efficiency gain)' },
                        { key: 'tov', label: 'TOV', epa: -1.1, desc: 'Each TOV ≈ -1.1 pts (lost possession)', inverted: true }
                    ]
                },
                defense: {
                    title: '🛡️ Defense',
                    stats: [
                        { key: 'stl', label: 'STL', epa: 1.5, desc: 'Each STL ≈ 1.5 pts (gain + deny)' },
                        { key: 'blk', label: 'BLK', epa: 0.8, desc: 'Each BLK ≈ 0.8 pts (often recovered)' },
                        { key: 'pf', label: 'PF', epa: -0.4, desc: 'Each PF ≈ -0.4 pts (FTs given)', inverted: true }
                    ]
                }
            };
            
            const currentMargin = homeTotals.points - awayTotals.points;
            
            // Calculate initial battle values
            const initBattles = this.calculateBattleMetrics(this.marginData.battles);
            
            return `
                <div class="margin-tab-container">
                    <div class="stat-card glass-card full-width">
                        <div class="card-header">
                            <span class="card-title">📐 Margin Analysis - Expected Points Added (EPA) Model</span>
                        </div>
                        
                        <!-- Battle Simulator Section -->
                        <div class="battle-simulator-section" style="margin-bottom: 24px;">
                            <div class="battle-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                                <div>
                                    <h3 style="color: var(--text-bright); font-size: 16px; margin: 0;">⚔️ Battle Simulator</h3>
                                    <p style="color: var(--text-muted); font-size: 11px; margin: 4px 0 0 0;">Edit stats to see projected impact on game outcome</p>
                                </div>
                                <div class="battle-projected-margin" id="battle-projected-margin" style="text-align: right;">
                                    <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase;">Projected Margin</div>
                                    <div style="font-size: 28px; font-weight: 800; color: ${initBattles.totalMargin >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                        ${initBattles.totalMargin >= 0 ? '+' : ''}${initBattles.totalMargin.toFixed(1)} pts
                                    </div>
                                    <div style="font-size: 11px; color: var(--text-secondary);">
                                        ${initBattles.totalMargin >= 0 ? homeTeam : awayTeam} favored
                                    </div>
                                </div>
                            </div>
                            
                            <div class="battle-cards-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                                <!-- EPA Battle Card (TO + OREB) -->
                                <div class="battle-card epa-battle" style="background: var(--bg-glass); border-radius: var(--radius-md); padding: 16px; border: 1px solid var(--border-subtle);">
                                    <div class="battle-card-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                                        <div>
                                            <span style="font-size: 14px; font-weight: 700; color: var(--accent-emerald);">⚡ EPA Battle</span>
                                            <div style="font-size: 10px; color: var(--text-muted);">Turnover + OREB Impact</div>
                                        </div>
                                        <div id="epa-battle-value" style="font-size: 20px; font-weight: 800; color: ${initBattles.epaBattle >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                            ${initBattles.epaBattle >= 0 ? '+' : ''}${initBattles.epaBattle.toFixed(1)}
                                        </div>
                                    </div>
                                    
                                    <!-- Turnovers -->
                                    <div class="battle-stat-row" style="margin-bottom: 12px;">
                                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 6px;">
                                            Turnovers <span style="color: var(--negative);">(−1.1 pts each)</span>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 12px;">
                                            <div style="flex: 1; text-align: center;">
                                                <div style="font-size: 10px; color: var(--team-home); margin-bottom: 4px;">${homeTeam.split(' ').pop()}</div>
                                                <input type="number" class="battle-input" id="battle-home-tov" 
                                                       value="${homeTotals.tov || 0}" min="0" max="50"
                                                       onchange="window.fibaVisualizer.updateBattleValue('homeTov', this.value)"
                                                       style="width: 60px; text-align: center; padding: 8px; font-size: 16px; font-weight: 700; background: var(--bg-base); border: 2px solid var(--team-home); border-radius: var(--radius-sm); color: var(--team-home);">
                                            </div>
                                            <div style="color: var(--text-muted); font-size: 12px;">vs</div>
                                            <div style="flex: 1; text-align: center;">
                                                <div style="font-size: 10px; color: var(--team-away); margin-bottom: 4px;">${awayTeam.split(' ').pop()}</div>
                                                <input type="number" class="battle-input" id="battle-away-tov" 
                                                       value="${awayTotals.tov || 0}" min="0" max="50"
                                                       onchange="window.fibaVisualizer.updateBattleValue('awayTov', this.value)"
                                                       style="width: 60px; text-align: center; padding: 8px; font-size: 16px; font-weight: 700; background: var(--bg-base); border: 2px solid var(--team-away); border-radius: var(--radius-sm); color: var(--team-away);">
                                            </div>
                                        </div>
                                        <div id="tov-battle-impact" style="text-align: center; margin-top: 6px; font-size: 12px; font-weight: 600; color: ${initBattles.tovImpact >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                            TO Impact: ${initBattles.tovImpact >= 0 ? '+' : ''}${initBattles.tovImpact.toFixed(1)} pts
                                        </div>
                                    </div>
                                    
                                    <!-- Offensive Rebounds -->
                                    <div class="battle-stat-row">
                                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 6px;">
                                            Offensive Rebounds <span style="color: var(--positive);">(+1.1 pts each)</span>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 12px;">
                                            <div style="flex: 1; text-align: center;">
                                                <div style="font-size: 10px; color: var(--team-home); margin-bottom: 4px;">${homeTeam.split(' ').pop()}</div>
                                                <input type="number" class="battle-input" id="battle-home-oreb" 
                                                       value="${homeTotals.oreb || 0}" min="0" max="50"
                                                       onchange="window.fibaVisualizer.updateBattleValue('homeOreb', this.value)"
                                                       style="width: 60px; text-align: center; padding: 8px; font-size: 16px; font-weight: 700; background: var(--bg-base); border: 2px solid var(--team-home); border-radius: var(--radius-sm); color: var(--team-home);">
                                            </div>
                                            <div style="color: var(--text-muted); font-size: 12px;">vs</div>
                                            <div style="flex: 1; text-align: center;">
                                                <div style="font-size: 10px; color: var(--team-away); margin-bottom: 4px;">${awayTeam.split(' ').pop()}</div>
                                                <input type="number" class="battle-input" id="battle-away-oreb" 
                                                       value="${awayTotals.oreb || 0}" min="0" max="50"
                                                       onchange="window.fibaVisualizer.updateBattleValue('awayOreb', this.value)"
                                                       style="width: 60px; text-align: center; padding: 8px; font-size: 16px; font-weight: 700; background: var(--bg-base); border: 2px solid var(--team-away); border-radius: var(--radius-sm); color: var(--team-away);">
                                            </div>
                                        </div>
                                        <div id="oreb-battle-impact" style="text-align: center; margin-top: 6px; font-size: 12px; font-weight: 600; color: ${initBattles.orebImpact >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                            OREB Impact: ${initBattles.orebImpact >= 0 ? '+' : ''}${initBattles.orebImpact.toFixed(1)} pts
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Scoring Battle Card (eFG% + FT Rate) -->
                                <div class="battle-card scoring-battle" style="background: var(--bg-glass); border-radius: var(--radius-md); padding: 16px; border: 1px solid var(--border-subtle);">
                                    <div class="battle-card-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                                        <div>
                                            <span style="font-size: 14px; font-weight: 700; color: var(--accent-gold);">🎯 Scoring Battle</span>
                                            <div style="font-size: 10px; color: var(--text-muted);">eFG% + FT Rate Impact</div>
                                        </div>
                                        <div id="scoring-battle-value" style="font-size: 20px; font-weight: 800; color: ${initBattles.scoringBattle >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                            ${initBattles.scoringBattle >= 0 ? '+' : ''}${initBattles.scoringBattle.toFixed(1)}
                                        </div>
                                    </div>
                                    
                                    <!-- eFG% -->
                                    <div class="battle-stat-row" style="margin-bottom: 12px;">
                                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 6px;">
                                            Effective FG% <span style="color: var(--positive);">(+1.77 pts per 1%)</span>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 12px;">
                                            <div style="flex: 1; text-align: center;">
                                                <div style="font-size: 10px; color: var(--team-home); margin-bottom: 4px;">${homeTeam.split(' ').pop()}</div>
                                                <div style="display: flex; align-items: center; justify-content: center;">
                                                    <input type="number" class="battle-input" id="battle-home-efg" 
                                                           value="${(homeTotals.efg || 50).toFixed(1)}" min="0" max="100" step="0.1"
                                                           onchange="window.fibaVisualizer.updateBattleValue('homeEfg', this.value)"
                                                           style="width: 70px; text-align: center; padding: 8px; font-size: 16px; font-weight: 700; background: var(--bg-base); border: 2px solid var(--team-home); border-radius: var(--radius-sm); color: var(--team-home);">
                                                    <span style="margin-left: 4px; color: var(--text-muted);">%</span>
                                                </div>
                                            </div>
                                            <div style="color: var(--text-muted); font-size: 12px;">vs</div>
                                            <div style="flex: 1; text-align: center;">
                                                <div style="font-size: 10px; color: var(--team-away); margin-bottom: 4px;">${awayTeam.split(' ').pop()}</div>
                                                <div style="display: flex; align-items: center; justify-content: center;">
                                                    <input type="number" class="battle-input" id="battle-away-efg" 
                                                           value="${(awayTotals.efg || 50).toFixed(1)}" min="0" max="100" step="0.1"
                                                           onchange="window.fibaVisualizer.updateBattleValue('awayEfg', this.value)"
                                                           style="width: 70px; text-align: center; padding: 8px; font-size: 16px; font-weight: 700; background: var(--bg-base); border: 2px solid var(--team-away); border-radius: var(--radius-sm); color: var(--team-away);">
                                                    <span style="margin-left: 4px; color: var(--text-muted);">%</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div id="efg-battle-impact" style="text-align: center; margin-top: 6px; font-size: 12px; font-weight: 600; color: ${initBattles.efgImpact >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                            eFG% Impact: ${initBattles.efgImpact >= 0 ? '+' : ''}${initBattles.efgImpact.toFixed(1)} pts
                                        </div>
                                    </div>
                                    
                                    <!-- FT Rate -->
                                    <div class="battle-stat-row">
                                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 6px;">
                                            Free Throw Rate <span style="color: var(--positive);">(+0.25 pts per 1%)</span>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 12px;">
                                            <div style="flex: 1; text-align: center;">
                                                <div style="font-size: 10px; color: var(--team-home); margin-bottom: 4px;">${homeTeam.split(' ').pop()}</div>
                                                <div style="display: flex; align-items: center; justify-content: center;">
                                                    <input type="number" class="battle-input" id="battle-home-ftrate" 
                                                           value="${(homeTotals.ftaRate || 25).toFixed(1)}" min="0" max="100" step="0.1"
                                                           onchange="window.fibaVisualizer.updateBattleValue('homeFtRate', this.value)"
                                                           style="width: 70px; text-align: center; padding: 8px; font-size: 16px; font-weight: 700; background: var(--bg-base); border: 2px solid var(--team-home); border-radius: var(--radius-sm); color: var(--team-home);">
                                                    <span style="margin-left: 4px; color: var(--text-muted);">%</span>
                                                </div>
                                            </div>
                                            <div style="color: var(--text-muted); font-size: 12px;">vs</div>
                                            <div style="flex: 1; text-align: center;">
                                                <div style="font-size: 10px; color: var(--team-away); margin-bottom: 4px;">${awayTeam.split(' ').pop()}</div>
                                                <div style="display: flex; align-items: center; justify-content: center;">
                                                    <input type="number" class="battle-input" id="battle-away-ftrate" 
                                                           value="${(awayTotals.ftaRate || 25).toFixed(1)}" min="0" max="100" step="0.1"
                                                           onchange="window.fibaVisualizer.updateBattleValue('awayFtRate', this.value)"
                                                           style="width: 70px; text-align: center; padding: 8px; font-size: 16px; font-weight: 700; background: var(--bg-base); border: 2px solid var(--team-away); border-radius: var(--radius-sm); color: var(--team-away);">
                                                    <span style="margin-left: 4px; color: var(--text-muted);">%</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div id="ftrate-battle-impact" style="text-align: center; margin-top: 6px; font-size: 12px; font-weight: 600; color: ${initBattles.ftRateImpact >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                            FT Rate Impact: ${initBattles.ftRateImpact >= 0 ? '+' : ''}${initBattles.ftRateImpact.toFixed(1)} pts
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Battle Summary Bar -->
                            <div class="battle-summary-bar" style="margin-top: 16px; padding: 12px 16px; background: var(--bg-elevated); border-radius: var(--radius-sm); display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; gap: 24px;">
                                    <div>
                                        <span style="font-size: 10px; color: var(--text-muted); text-transform: uppercase;">EPA Battle</span>
                                        <div id="summary-epa" style="font-size: 14px; font-weight: 700; color: ${initBattles.epaBattle >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                            ${initBattles.epaBattle >= 0 ? '+' : ''}${initBattles.epaBattle.toFixed(1)} pts
                                        </div>
                                    </div>
                                    <div style="color: var(--text-muted);">+</div>
                                    <div>
                                        <span style="font-size: 10px; color: var(--text-muted); text-transform: uppercase;">Scoring Battle</span>
                                        <div id="summary-scoring" style="font-size: 14px; font-weight: 700; color: ${initBattles.scoringBattle >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                            ${initBattles.scoringBattle >= 0 ? '+' : ''}${initBattles.scoringBattle.toFixed(1)} pts
                                        </div>
                                    </div>
                                    <div style="color: var(--text-muted);">=</div>
                                    <div>
                                        <span style="font-size: 10px; color: var(--text-muted); text-transform: uppercase;">Total Projected</span>
                                        <div id="summary-total" style="font-size: 14px; font-weight: 700; color: ${initBattles.totalMargin >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                                            ${initBattles.totalMargin >= 0 ? '+' : ''}${initBattles.totalMargin.toFixed(1)} pts
                                        </div>
                                    </div>
                                </div>
                                <button onclick="window.fibaVisualizer.resetBattleValues()" style="padding: 8px 16px; background: var(--bg-glass); border: 1px solid var(--border-accent); border-radius: var(--radius-sm); color: var(--text-secondary); font-size: 11px; cursor: pointer; transition: all 0.2s;">
                                    ↺ Reset to Actual
                                </button>
                            </div>
                        </div>
                        
                        <div style="border-top: 1px solid var(--border-subtle); margin: 0 -20px 20px -20px;"></div>
                        
                        <!-- Controls -->
                        <div class="margin-controls">
                            <div class="margin-team-selector">
                                <span style="color: var(--text-secondary); font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin-right: 8px;">Winning Team:</span>
                                <button class="margin-team-btn home active" data-team="home" onclick="window.fibaVisualizer.setMarginWinner('home')">
                                    ${homeTeam}
                                </button>
                                <button class="margin-team-btn away" data-team="away" onclick="window.fibaVisualizer.setMarginWinner('away')">
                                    ${awayTeam}
                                </button>
                            </div>
                            
                            <div class="margin-input-group">
                                <label for="margin-value">Wanted Margin:</label>
                                <input type="number" id="margin-value" class="margin-input" 
                                       value="${Math.abs(currentMargin) + 5}" min="1" max="100"
                                       onchange="window.fibaVisualizer.updateMarginValue(this.value)">
                            </div>
                            
                            <button class="margin-calculate-btn" onclick="window.fibaVisualizer.calculateMarginAdjustments()">
                                ⚡ Calculate Adjustments
                            </button>
                        </div>
                        
                        <div class="margin-result-panel" style="display: none;" id="margin-result-panel">
                            <div class="margin-result-header">
                                <span class="margin-result-title">🎯 Margin Analysis Result</span>
                                <div class="margin-result-score" id="margin-result-score">
                                    <span class="home">${homeTotals.points}</span>
                                    <span class="divider">-</span>
                                    <span class="away">${awayTotals.points}</span>
                                </div>
                            </div>
                            <div id="margin-result-details"></div>
                        </div>
                        
                        <!-- Stats Grid -->
                        <div class="margin-stats-grid">
                            ${this.renderMarginTeamCard(homeTeam, homeTotals, statCategories, 'home')}
                            ${this.renderMarginTeamCard(awayTeam, awayTotals, statCategories, 'away')}
                        </div>
                        
                        <!-- Methodology Explanation -->
                        <div class="margin-methodology">
                            <div class="margin-methodology-title">📚 Methodology: Theoretical Physics-Based EPA Model</div>
                            <div class="margin-methodology-text">
                                This analysis uses a <strong>Expected Points Added (EPA)</strong> model derived from basketball analytics research, 
                                incorporating Dean Oliver's Four Factors coefficients refined by Kubatko et al. (2007) and 
                                the 2023 arXiv paper "Dean Oliver's Four Factors Revisited" (arXiv:2305.13032).
                                <br><br>
                                The optimization distributes required margin adjustments across unchecked stats using a 
                                <strong>Lagrangian minimization</strong> approach that minimizes total statistical deviation 
                                while achieving the target point differential. Each stat's adjustment is weighted by its EPA coefficient 
                                and constrained by practical bounds (e.g., can't have negative makes).
                            </div>
                            <div class="margin-methodology-formula">
                                <strong>Key EPA Coefficients (per 100 possessions):</strong><br>
                                eFG%: +1.77 pts per 1% | TOV%: -0.96 pts per 1% | OREB%: +0.24 pts per 1% | FT Rate: +0.25 pts per 1%<br>
                                <strong>Counting Stats:</strong> OREB ≈ 1.1 pts | STL ≈ 1.5 pts | BLK ≈ 0.8 pts | TOV ≈ -1.1 pts
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Calculate battle metrics from editable values
        calculateBattleMetrics(battles) {
            const POSS = 75; // Standard possessions per game
            
            // TO Battle: Each turnover costs ~1.1 points
            // Home advantage = away TOs - home TOs (more opponent TOs = good)
            const tovImpact = (battles.awayTov - battles.homeTov) * 1.1;
            
            // OREB Battle: Each OREB worth ~1.1 points
            const orebImpact = (battles.homeOreb - battles.awayOreb) * 1.1;
            
            // EPA Battle = TO + OREB combined
            const epaBattle = tovImpact + orebImpact;
            
            // eFG% Impact: +1.77 pts per 1% difference (scaled to 75 poss)
            const efgImpact = (battles.homeEfg - battles.awayEfg) * 1.77 * (POSS / 100);
            
            // FT Rate Impact: +0.25 pts per 1% difference (scaled to 75 poss)
            const ftRateImpact = (battles.homeFtRate - battles.awayFtRate) * 0.25 * (POSS / 100);
            
            // Scoring Battle = eFG% + FT Rate
            const scoringBattle = efgImpact + ftRateImpact;
            
            // Total projected margin
            const totalMargin = epaBattle + scoringBattle;
            
            return {
                tovImpact,
                orebImpact,
                epaBattle,
                efgImpact,
                ftRateImpact,
                scoringBattle,
                totalMargin
            };
        }
        
        // Update a battle value and recalculate
        updateBattleValue(key, value) {
            if (!this.marginData || !this.marginData.battles) return;
            
            this.marginData.battles[key] = parseFloat(value) || 0;
            this.refreshBattleDisplay();
        }
        
        // Reset battle values to actual game stats
        resetBattleValues() {
            if (!this.marginData) return;
            
            const { homeTotals, awayTotals } = this.marginData;
            
            this.marginData.battles = {
                homeTov: homeTotals.tov || 0,
                awayTov: awayTotals.tov || 0,
                homeOreb: homeTotals.oreb || 0,
                awayOreb: awayTotals.oreb || 0,
                homeEfg: homeTotals.efg || 50,
                awayEfg: awayTotals.efg || 50,
                homeFtRate: homeTotals.ftaRate || 25,
                awayFtRate: awayTotals.ftaRate || 25
            };
            
            // Update input values
            document.getElementById('battle-home-tov').value = this.marginData.battles.homeTov;
            document.getElementById('battle-away-tov').value = this.marginData.battles.awayTov;
            document.getElementById('battle-home-oreb').value = this.marginData.battles.homeOreb;
            document.getElementById('battle-away-oreb').value = this.marginData.battles.awayOreb;
            document.getElementById('battle-home-efg').value = this.marginData.battles.homeEfg.toFixed(1);
            document.getElementById('battle-away-efg').value = this.marginData.battles.awayEfg.toFixed(1);
            document.getElementById('battle-home-ftrate').value = this.marginData.battles.homeFtRate.toFixed(1);
            document.getElementById('battle-away-ftrate').value = this.marginData.battles.awayFtRate.toFixed(1);
            
            this.refreshBattleDisplay();
        }
        
        // Refresh the battle display with current values
        refreshBattleDisplay() {
            if (!this.marginData || !this.marginData.battles) return;
            
            const battles = this.calculateBattleMetrics(this.marginData.battles);
            const { homeTeam, awayTeam } = this.marginData;
            
            // Update individual impacts
            const updateImpact = (id, value, label) => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.color = value >= 0 ? 'var(--team-home)' : 'var(--team-away)';
                    el.textContent = `${label}: ${value >= 0 ? '+' : ''}${value.toFixed(1)} pts`;
                }
            };
            
            updateImpact('tov-battle-impact', battles.tovImpact, 'TO Impact');
            updateImpact('oreb-battle-impact', battles.orebImpact, 'OREB Impact');
            updateImpact('efg-battle-impact', battles.efgImpact, 'eFG% Impact');
            updateImpact('ftrate-battle-impact', battles.ftRateImpact, 'FT Rate Impact');
            
            // Update battle card totals
            const updateBattleValue = (id, value) => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.color = value >= 0 ? 'var(--team-home)' : 'var(--team-away)';
                    el.textContent = `${value >= 0 ? '+' : ''}${value.toFixed(1)}`;
                }
            };
            
            updateBattleValue('epa-battle-value', battles.epaBattle);
            updateBattleValue('scoring-battle-value', battles.scoringBattle);
            
            // Update summary bar
            const updateSummary = (id, value, suffix = ' pts') => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.color = value >= 0 ? 'var(--team-home)' : 'var(--team-away)';
                    el.textContent = `${value >= 0 ? '+' : ''}${value.toFixed(1)}${suffix}`;
                }
            };
            
            updateSummary('summary-epa', battles.epaBattle);
            updateSummary('summary-scoring', battles.scoringBattle);
            updateSummary('summary-total', battles.totalMargin);
            
            // Update main projected margin
            const marginEl = document.getElementById('battle-projected-margin');
            if (marginEl) {
                const favored = battles.totalMargin >= 0 ? homeTeam : awayTeam;
                marginEl.innerHTML = `
                    <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase;">Projected Margin</div>
                    <div style="font-size: 28px; font-weight: 800; color: ${battles.totalMargin >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                        ${battles.totalMargin >= 0 ? '+' : ''}${battles.totalMargin.toFixed(1)} pts
                    </div>
                    <div style="font-size: 11px; color: var(--text-secondary);">
                        ${favored} favored
                    </div>
                `;
            }
        }
        
        renderMarginTeamCard(teamName, totals, statCategories, teamClass) {
            const renderStatRow = (stat, categoryKey) => {
                const value = totals[stat.key] || 0;
                const isPercentage = ['efg', 'ts', 'tovPct', 'orebPct', 'ftaRate'].includes(stat.key);
                const displayValue = isPercentage ? value.toFixed(1) + '%' : value;
                
                return `
                    <tr data-stat="${stat.key}" data-team="${teamClass}" data-epa="${stat.epa}" data-inverted="${stat.inverted || false}">
                        <td>
                            <span>${stat.label}</span>
                            <span class="margin-epa-indicator" title="${stat.desc}">(${stat.epa > 0 ? '+' : ''}${stat.epa})</span>
                        </td>
                        <td><span class="margin-stat-value">${displayValue}</span></td>
                        <td>
                            <input type="checkbox" class="margin-stat-checkbox" 
                                   id="margin-check-${teamClass}-${stat.key}" 
                                   checked 
                                   data-stat="${stat.key}" 
                                   data-team="${teamClass}">
                        </td>
                        <td>
                            <span class="margin-adjustment neutral" id="margin-adj-${teamClass}-${stat.key}">—</span>
                        </td>
                    </tr>
                `;
            };
            
            const renderCategory = (key, category) => {
                return `
                    <tr class="margin-category-header">
                        <td colspan="4">${category.title}</td>
                    </tr>
                    ${category.stats.map(stat => renderStatRow(stat, key)).join('')}
                `;
            };
            
            return `
                <div class="margin-team-card ${teamClass}">
                    <div class="margin-team-header ${teamClass}">
                        <span class="margin-team-name ${teamClass}">
                            <span class="team-indicator ${teamClass}"></span>
                            ${teamName}
                        </span>
                        <span style="font-family: 'Space Mono', monospace; font-size: 18px; font-weight: 700; color: var(--team-${teamClass});">
                            ${totals.points} PTS
                        </span>
                    </div>
                    <table class="margin-stats-table">
                        <thead>
                            <tr>
                                <th>Stat</th>
                                <th>Current</th>
                                <th>Lock</th>
                                <th>Adjust</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${Object.entries(statCategories).map(([key, cat]) => renderCategory(key, cat)).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }
        
        setMarginWinner(team) {
            this.marginData.selectedWinner = team;
            document.querySelectorAll('.margin-team-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.team === team) btn.classList.add('active');
            });
        }
        
        updateMarginValue(value) {
            this.marginData.wantedMargin = parseInt(value) || 5;
        }
        
        calculateMarginAdjustments() {
            const { homeTeam, awayTeam, homeTotals, awayTotals, pace, selectedWinner, wantedMargin } = this.marginData;
            
            // Current margin (positive = home winning)
            const currentMargin = homeTotals.points - awayTotals.points;
            
            // Target margin (positive = home winning by target)
            const targetMargin = selectedWinner === 'home' ? wantedMargin : -wantedMargin;
            
            // Needed point swing
            const neededSwing = targetMargin - currentMargin;
            
            // Collect unchecked stats and their EPA weights
            const uncheckedStats = { home: [], away: [] };
            
            document.querySelectorAll('.margin-stat-checkbox').forEach(checkbox => {
                if (!checkbox.checked) {
                    const stat = checkbox.dataset.stat;
                    const team = checkbox.dataset.team;
                    const row = checkbox.closest('tr');
                    const epa = parseFloat(row.dataset.epa) || 1;
                    const inverted = row.dataset.inverted === 'true';
                    const totals = team === 'home' ? homeTotals : awayTotals;
                    const currentValue = totals[stat] || 0;
                    
                    uncheckedStats[team].push({
                        stat, epa, inverted, currentValue,
                        isPercentage: ['efg', 'ts', 'tovPct', 'orebPct', 'ftaRate'].includes(stat)
                    });
                }
            });
            
            // ========================================================================
            // LAGRANGIAN OPTIMIZATION MODEL WITH DIRECTIONAL ADJUSTMENTS
            // ========================================================================
            // The key insight: effectiveEPA represents "how does a +1 unit change 
            // in this stat affect HOME's margin?"
            //
            // - Home stats going UP helps home → positive effectiveEPA
            // - Away stats going UP helps away (hurts home) → negative effectiveEPA
            //
            // The optimization will then naturally produce:
            // - Positive adjustments for winner's stats (improve)
            // - Negative adjustments for loser's stats (worsen)
            
            const paceMultiplier = (pace || 70) / 100;
            let totalEPACapacity = 0;
            
            // Determine which team is winning and losing
            const homeIsWinner = selectedWinner === 'home';
            const awayIsWinner = selectedWinner === 'away';
            
            // Calculate total EPA capacity with proper directions
            uncheckedStats.home.forEach(s => {
                const baseDirection = s.inverted ? -1 : 1;
                // Home stat improvements help home's margin (positive contribution)
                const effectiveEPA = s.epa * paceMultiplier * baseDirection;
                s.effectiveEPA = effectiveEPA;
                s.isWorsening = !homeIsWinner; // Home is worsening if they're NOT the winner
                totalEPACapacity += effectiveEPA * effectiveEPA;
            });
            
            uncheckedStats.away.forEach(s => {
                const baseDirection = s.inverted ? -1 : 1;
                // Away stat improvements HURT home's margin (negative contribution)
                // So we negate: if away eFG% goes up, home margin goes down
                const effectiveEPA = -s.epa * paceMultiplier * baseDirection;
                s.effectiveEPA = effectiveEPA;
                s.isWorsening = !awayIsWinner; // Away is worsening if they're NOT the winner
                totalEPACapacity += effectiveEPA * effectiveEPA;
            });
            
            if (totalEPACapacity === 0) {
                alert('Please uncheck at least one stat to adjust.');
                return;
            }
            
            // Calculate Lagrange multiplier
            const lambda = neededSwing / totalEPACapacity;
            
            // Calculate adjustments
            const adjustments = { home: {}, away: {} };
            
            uncheckedStats.home.forEach(s => {
                let adjustment = lambda * s.effectiveEPA;
                
                // Apply bounds based on whether we're improving or worsening
                let boundedAdj = adjustment;
                if (!s.isPercentage) {
                    if (s.currentValue + adjustment < 0) {
                        boundedAdj = -s.currentValue;
                    }
                }
                
                adjustments.home[s.stat] = {
                    raw: adjustment,
                    bounded: boundedAdj,
                    epa: s.effectiveEPA,
                    isPercentage: s.isPercentage,
                    currentValue: s.currentValue,
                    isWorsening: s.isWorsening
                };
            });
            
            uncheckedStats.away.forEach(s => {
                let adjustment = lambda * s.effectiveEPA;
                
                // Apply bounds
                let boundedAdj = adjustment;
                if (!s.isPercentage) {
                    if (s.currentValue + adjustment < 0) {
                        boundedAdj = -s.currentValue;
                    }
                }
                
                adjustments.away[s.stat] = {
                    raw: adjustment,
                    bounded: boundedAdj,
                    epa: s.effectiveEPA,
                    isPercentage: s.isPercentage,
                    currentValue: s.currentValue,
                    isWorsening: s.isWorsening
                };
            });
            
            // Calculate new points based on adjustments
            // For winner team: improvements add points
            // For loser team: worsenings subtract their points
            let homePointChange = 0;
            let awayPointChange = 0;
            
            Object.values(adjustments.home).forEach(adj => {
                // The bounded adjustment already has the correct sign
                // Positive adj = improvement, negative = worsening
                homePointChange += adj.bounded * Math.abs(adj.epa);
            });
            
            Object.values(adjustments.away).forEach(adj => {
                // Away adjustments affect away team's points
                awayPointChange += adj.bounded * Math.abs(adj.epa);
            });
            
            const newHomePoints = Math.round(homeTotals.points + homePointChange);
            const newAwayPoints = Math.round(awayTotals.points + awayPointChange);
            const achievedMargin = newHomePoints - newAwayPoints;
            
            // Update UI with totals for percentage translations
            this.updateMarginAdjustmentUI(adjustments, homeTotals, awayTotals);
            
            // Show result panel
            const resultPanel = document.getElementById('margin-result-panel');
            resultPanel.style.display = 'block';
            
            const resultScore = document.getElementById('margin-result-score');
            resultScore.innerHTML = `
                <span class="home">${newHomePoints}</span>
                <span class="divider">-</span>
                <span class="away">${newAwayPoints}</span>
            `;
            
            const resultDetails = document.getElementById('margin-result-details');
            const resultWinnerTeam = achievedMargin > 0 ? homeTeam : awayTeam;
            const winnerClass = achievedMargin > 0 ? 'home' : 'away';
            
            resultDetails.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; text-align: center; margin-top: 16px;">
                    <div>
                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">Original Margin</div>
                        <div style="font-size: 20px; font-weight: 700; color: ${currentMargin >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                            ${currentMargin >= 0 ? '+' : ''}${currentMargin}
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">Target Margin</div>
                        <div style="font-size: 20px; font-weight: 700; color: ${targetMargin >= 0 ? 'var(--team-home)' : 'var(--team-away)'};">
                            ${targetMargin >= 0 ? '+' : ''}${targetMargin}
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">Achieved Margin</div>
                        <div style="font-size: 20px; font-weight: 700; color: var(--team-${winnerClass});">
                            ${achievedMargin >= 0 ? '+' : ''}${achievedMargin}
                        </div>
                    </div>
                </div>
                <div style="margin-top: 16px; text-align: center; font-size: 13px; color: var(--text-secondary);">
                    <strong style="color: var(--team-${winnerClass});">${resultWinnerTeam}</strong> wins by 
                    <strong style="color: var(--accent-gold);">${Math.abs(achievedMargin)}</strong> points
                </div>
            `;
        }
        
        updateMarginAdjustmentUI(adjustments, homeTotals, awayTotals) {
            // Reset all adjustment displays
            document.querySelectorAll('.margin-adjustment').forEach(el => {
                el.className = 'margin-adjustment neutral';
                el.innerHTML = '—';
            });
            
            // Helper to calculate practical translation of percentage changes
            const calculateTranslation = (stat, pctChange, totals, oppTotals) => {
                if (Math.abs(pctChange) < 0.1) return null;
                
                switch(stat) {
                    case 'efg':
                        // eFG% = (FGM + 0.5 * 3PM) / FGA * 100
                        // Change in (FGM + 0.5*3PM) = pctChange * FGA / 100
                        const efgNumeratorChange = pctChange * (totals.fga || 1) / 100;
                        // Approximate as FGM change (assuming mostly 2PT)
                        const fgmChange = Math.round(efgNumeratorChange * 10) / 10;
                        return { value: fgmChange, unit: 'FGM', positive: fgmChange > 0 };
                        
                    case 'ts':
                        // TS% = PTS / (2 * TSA) * 100, TSA = FGA + 0.44*FTA
                        const tsa = (totals.fga || 0) + 0.44 * (totals.fta || 0);
                        // PTS change = pctChange * 2 * TSA / 100
                        const ptsChange = pctChange * 2 * tsa / 100;
                        return { value: Math.round(ptsChange * 10) / 10, unit: 'PTS', positive: ptsChange > 0 };
                        
                    case 'tovPct':
                        // TOV% = TOV / (FGA + 0.44*FTA + TOV) * 100
                        const tovDenom = (totals.fga || 0) + 0.44 * (totals.fta || 0) + (totals.tov || 0);
                        // TOV change = pctChange * denom / 100
                        const tovChange = pctChange * tovDenom / 100;
                        return { value: Math.round(tovChange * 10) / 10, unit: 'TOV', positive: tovChange < 0 }; // Inverted - fewer TOV is good
                        
                    case 'orebPct':
                        // OREB% = OREB / (OREB + OPP_DREB) * 100
                        const orebOpps = (totals.oreb || 0) + (oppTotals?.dreb || totals.oppDreb || 20);
                        // OREB change = pctChange * opportunities / 100
                        const orebChange = pctChange * orebOpps / 100;
                        return { value: Math.round(orebChange * 10) / 10, unit: 'OREB', positive: orebChange > 0 };
                        
                    case 'ftaRate':
                        // FT Rate = FTA / FGA * 100
                        // FTA change = pctChange * FGA / 100
                        const ftaChange = pctChange * (totals.fga || 1) / 100;
                        return { value: Math.round(ftaChange * 10) / 10, unit: 'FTA', positive: ftaChange > 0 };
                        
                    default:
                        return null;
                }
            };
            
            // Helper to render adjustment cell
            const renderAdjustment = (stat, adj, totals, oppTotals) => {
                const rounded = adj.isPercentage ? adj.bounded.toFixed(1) : Math.round(adj.bounded);
                
                if (Math.abs(adj.bounded) < 0.1) {
                    return { className: 'margin-adjustment neutral', html: '—' };
                }
                
                // Determine if this is a beneficial change for THIS team
                // For the winner team: positive changes are good (green)
                // For the loser team: negative changes mean they're getting worse (red for them, but we show it as their decrease)
                const isPositiveChange = adj.bounded > 0;
                const isWorsening = adj.isWorsening;
                
                // Color logic:
                // - Winner team improving: green (positive)
                // - Loser team worsening: red (negative) - shows their decline
                let className, icon;
                if (isWorsening) {
                    // This team is being made worse - show in red as decline
                    className = 'margin-adjustment negative worsening';
                    icon = isPositiveChange ? '+' : '−';
                } else {
                    // This team is being improved - show in green
                    className = isPositiveChange ? 'margin-adjustment positive' : 'margin-adjustment negative';
                    icon = isPositiveChange ? '+' : '−';
                }
                
                let html = `<span class="margin-main-value"><span class="margin-adjustment-icon">${icon}</span>${Math.abs(rounded)}${adj.isPercentage ? '%' : ''}</span>`;
                
                // Add translation for percentage stats
                if (adj.isPercentage) {
                    const translation = calculateTranslation(stat, adj.bounded, totals, oppTotals);
                    if (translation) {
                        const sign = translation.value >= 0 ? '+' : '';
                        html += `<span class="margin-translation">≈${sign}${translation.value} ${translation.unit}</span>`;
                    }
                }
                
                // Add worsening indicator
                if (isWorsening) {
                    html += `<span class="margin-worsen-label">📉 worse</span>`;
                }
                
                return { className, html };
            };
            
            // Update home adjustments
            Object.entries(adjustments.home).forEach(([stat, adj]) => {
                const el = document.getElementById(`margin-adj-home-${stat}`);
                if (el) {
                    const result = renderAdjustment(stat, adj, homeTotals, awayTotals);
                    el.className = result.className;
                    el.innerHTML = result.html;
                }
            });
            
            // Update away adjustments
            Object.entries(adjustments.away).forEach(([stat, adj]) => {
                const el = document.getElementById(`margin-adj-away-${stat}`);
                if (el) {
                    const result = renderAdjustment(stat, adj, awayTotals, homeTotals);
                    el.className = result.className;
                    el.innerHTML = result.html;
                }
            });
        }
        
        // ========================================================================
        // BPM (BOX PLUS/MINUS) TAB
        // ========================================================================
        
        renderBPMTab(teamsData, homeTeam, awayTeam, homeTotals, awayTotals, pace) {
            // Calculate BPM for all players
            const bpmResults = this.calculateBPMForAllPlayers(teamsData, homeTeam, awayTeam, homeTotals, awayTotals, pace);
            
            // Render team tables
            const renderTeamBPMTable = (teamName, players, isHome) => {
                const teamClass = isHome ? 'home' : 'away';
                
                // Sort by BPM descending
                const sortedPlayers = [...players].sort((a, b) => b.bpm - a.bpm);
                
                const formatBPM = (value) => {
                    const formatted = value >= 0 ? `+${value.toFixed(1)}` : value.toFixed(1);
                    const cssClass = value > 0 ? 'positive' : (value < 0 ? 'negative' : 'neutral');
                    return `<span class="bpm-value ${cssClass}">${formatted}</span>`;
                };
                
                const formatPos = (value) => {
                    if (!value) return '-';
                    return value.toFixed(1);
                };
                
                return `
                    <div class="bpm-team-card">
                        <div class="bpm-team-header ${teamClass}">
                            <span class="bpm-team-name ${teamClass}">${teamName}</span>
                        </div>
                        
                        <table class="bpm-table">
                            <thead>
                                <tr>
                                    <th style="width: 35px;">#</th>
                                    <th>Player</th>
                                    <th class="numeric">MIN</th>
                                    <th class="numeric" title="Estimated Position (1=PG, 5=C)">POS</th>
                                    <th class="numeric" title="Offensive Role (1=Creator, 5=Finisher)">ROLE</th>
                                    <th class="numeric sortable">OBPM</th>
                                    <th class="numeric sortable">DBPM</th>
                                    <th class="numeric sortable">BPM</th>
                                    <th class="numeric sortable" title="Total Points Added = BPM × (Poss/100)">TPA</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedPlayers.map(p => `
                                    <tr>
                                        <td style="color: var(--text-muted);">${p.number}</td>
                                        <td class="player-name">${p.name}</td>
                                        <td class="numeric">${p.minutes}</td>
                                        <td class="numeric" style="color: var(--text-muted);">${formatPos(p.position)}</td>
                                        <td class="numeric" style="color: var(--text-muted);">${formatPos(p.role)}</td>
                                        <td class="numeric">${formatBPM(p.obpm)}</td>
                                        <td class="numeric">${formatBPM(p.dbpm)}</td>
                                        <td class="numeric">${formatBPM(p.bpm)}</td>
                                        <td class="numeric">${formatBPM(p.tpa)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                        
                        <div style="margin-top: 12px; padding: 10px; background: var(--bg-glass); border-radius: var(--radius-sm);">
                            <div style="display: flex; justify-content: space-between; font-size: 12px;">
                                <span style="color: var(--text-muted);">Team Avg BPM:</span>
                                <span style="font-weight: 700; color: ${bpmResults[teamClass].teamAvgBPM >= 0 ? 'var(--positive)' : 'var(--negative)'};">
                                    ${bpmResults[teamClass].teamAvgBPM >= 0 ? '+' : ''}${bpmResults[teamClass].teamAvgBPM.toFixed(1)}
                                </span>
                            </div>
                            <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 4px;">
                                <span style="color: var(--text-muted);">Team TPA:</span>
                                <span style="font-weight: 700; color: ${bpmResults[teamClass].teamTPA >= 0 ? 'var(--positive)' : 'var(--negative)'};">
                                    ${bpmResults[teamClass].teamTPA >= 0 ? '+' : ''}${bpmResults[teamClass].teamTPA.toFixed(1)}
                                </span>
                            </div>
                        </div>
                    </div>
                `;
            };
            
            return `
                <div class="stat-card glass-card full-width">
                    <div class="card-header">
                        <span class="card-title">📊 Box Plus/Minus (gBPM)</span>
                    </div>
                    
                    <div class="bpm-container">
                        ${renderTeamBPMTable(homeTeam, bpmResults.home.players, true)}
                        ${renderTeamBPMTable(awayTeam, bpmResults.away.players, false)}
                    </div>
                    
                    <div class="bpm-methodology">
                        <h4>📐 Single-Game BPM (gBPM) + TPA</h4>
                        <p><strong>Game Box Plus/Minus</strong> estimates a player's contribution per 100 possessions using box score statistics. 
                        <strong>TPA (Total Points Added)</strong> converts this rate to a counting stat: BPM × (Player Possessions / 100).</p>
                        
                        <div style="margin-top: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                            <div>
                                <strong style="color: var(--accent-cyan);">BPM (Rate Stat)</strong>
                                <p style="font-size: 10px; margin-top: 4px;">
                                    Points above average per 100 possessions. Uses BPM 2.0 coefficients with position/role interpolation.
                                    Team adjustment uses 1.20× multiplier on net rating.
                                </p>
                            </div>
                            <div>
                                <strong style="color: var(--accent-magenta);">TPA (Counting Stat)</strong>
                                <p style="font-size: 10px; margin-top: 4px;">
                                    Total Points Added = BPM × (Poss/100). Converts rate to actual game impact.
                                    More meaningful for single-game comparison across different minutes.
                                </p>
                            </div>
                        </div>
                        
                        <!-- Season Data Upload -->
                        <div style="margin-top: 12px; padding: 10px; background: var(--bg-glass); border-radius: var(--radius-sm); border-left: 3px solid var(--accent-cyan);">
                            <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                                <div>
                                    <strong style="color: var(--accent-cyan); font-size: 11px;">📊 Season Priors</strong>
                                    <p style="font-size: 9px; color: var(--text-secondary); margin-top: 2px;">
                                        Load season CSV for better position/role estimates and team adjustment blending.
                                    </p>
                                </div>
                                <label style="padding: 6px 12px; background: var(--bg-elevated); border: 1px solid var(--border-accent); border-radius: var(--radius-sm); color: var(--accent-cyan); font-size: 11px; cursor: pointer; white-space: nowrap;">
                                    📁 Load Season Data
                                    <input type="file" accept=".csv" style="display: none;" onchange="window.fibaVisualizer.handleSeasonDataUpload(event)">
                                </label>
                                <span id="season-data-status" style="font-size: 10px; color: ${this.seasonPlayerData ? 'var(--positive)' : 'var(--text-muted)'};">
                                    ${this.seasonPlayerData ? `✓ ${this.seasonPlayerData.length} players loaded` : 'No season data loaded'}
                                </span>
                            </div>
                        </div>
                        
                        <p style="margin-top: 10px; font-size: 10px; color: var(--text-muted);">
                            <strong>Note:</strong> Single-game BPM is valid for measuring production (Ben Taylor: "we <em>can</em> say they were incredibly productive").
                            Basketball-Reference calculates single-game BPM for all games since 1985. DBPM has higher variance due to limited defensive box stats.
                        </p>
                    </div>
                </div>
            `;
        }
        
        calculateBPMForAllPlayers(teamsData, homeTeam, awayTeam, homeTotals, awayTotals, pace) {
            const results = {
                home: { players: [], teamAvgBPM: 0, teamTPA: 0, teamGameScore: 0, teamPoss: 0, expectedBPM: 0 },
                away: { players: [], teamAvgBPM: 0, teamTPA: 0, teamGameScore: 0, teamPoss: 0, expectedBPM: 0 },
                gamePoss: 0
            };
            
            // Game Score formula (Hollinger) - simple single-game metric for comparison
            const calcGameScore = (p) => {
                return p.points + 0.4 * p.fgm - 0.7 * p.fga - 0.4 * (p.fta - p.ftm) +
                       0.7 * p.oreb + 0.3 * p.dreb + p.stl + 0.7 * p.ast + 0.7 * p.blk - 0.4 * p.pf - p.tov;
            };
            
            // Season data lookup - returns player's season stats if available
            const getSeasonData = (playerName, teamName) => {
                if (!this.seasonPlayerData) return null;
                
                // Normalize names for matching
                const normalize = (name) => name.toLowerCase().replace(/[^a-z]/g, '');
                const normalizedSearch = normalize(playerName);
                
                // Try exact match first, then fuzzy match
                let match = this.seasonPlayerData.find(p => 
                    normalize(p.Player_Name) === normalizedSearch && 
                    p.Team === teamName
                );
                
                // Try name variations if no exact match
                if (!match) {
                    match = this.seasonPlayerData.find(p => {
                        if (p.Team !== teamName) return false;
                        const variations = (p.Name_Variations || p.Player_Name).split(';').map(v => normalize(v.trim()));
                        return variations.some(v => v === normalizedSearch || normalizedSearch.includes(v) || v.includes(normalizedSearch));
                    });
                }
                
                return match;
            };
            
            // BPM 2.0 Coefficients
            const BPM_COEF = {
                pts_adj: 0.86,
                '3pm': 0.389,
                ast: { pos_1: 0.58, pos_5: 1.034 },
                to: -0.964,
                orb: { pos_1: 0.613, pos_5: 0.181 },
                drb: { pos_1: 0.116, pos_5: 0.181 },
                stl: { pos_1: 1.369, pos_5: 1.008 },
                blk: { pos_1: 1.327, pos_5: 0.703 },
                pf: -0.367,
                fga: { role_1: -0.56, role_5: -0.78 },
                fta: { role_1: -0.2464, role_5: -0.3432 }
            };
            
            const OBPM_COEF = {
                pts_adj: 0.605,
                '3pm': 0.477,
                ast: 0.476,
                pf: -0.439,
                to: { pos_1: -0.579, pos_5: -0.882 },
                orb: { pos_1: 0.606, pos_5: 0.422 },
                drb: { pos_1: -0.112, pos_5: 0.103 },
                stl: { pos_1: 0.177, pos_5: 0.294 },
                blk: { pos_1: 0.725, pos_5: 0.097 },
                fga: { role_1: -0.33, role_5: -0.472 },
                fta: { role_1: -0.1452, role_5: -0.20768 }
            };
            
            // Position constant coefficients
            const POS_CONST = { pos_coef: 0.159, role_coef: 1.44, intercept: -4.99 };
            const POS_CONST_OBPM = { pos_coef: 0.08, role_coef: 0.72, intercept: -2.50 };
            
            // Position regression coefficients from appendix
            const POS_REGRESSION = {
                intercept: 2.130,
                pctTRB: 8.668,
                pctSTL: -2.486,
                pctPF: 0.992,
                pctAST: -3.536,
                pctBLK: 1.667
            };
            
            // Offensive role regression coefficients
            const ROLE_REGRESSION = {
                intercept: 6.00,
                pctAST: -6.642,
                pctThresholdPts: -8.544
            };
            
            // Helper functions
            const interpolate = (coef, value) => {
                if (typeof coef === 'number') return coef;
                const key1 = coef.pos_1 !== undefined ? 'pos_1' : 'role_1';
                const key5 = coef.pos_1 !== undefined ? 'pos_5' : 'role_5';
                const t = (value - 1) / 4;
                return coef[key1] + t * (coef[key5] - coef[key1]);
            };
            
            // Calculate game possessions (average of both teams' estimates)
            const calcPossessions = (totals) => {
                return totals.fga - totals.oreb + totals.tov + 0.44 * totals.fta;
            };
            
            const homePoss = calcPossessions(homeTotals);
            const awayPoss = calcPossessions(awayTotals);
            const gamePoss = (homePoss + awayPoss) / 2;
            
            // Calculate actual game net ratings (per 100 possessions)
            const homeNetRtg = gamePoss > 0 ? ((homeTotals.points - awayTotals.points) / gamePoss) * 100 : 0;
            const awayNetRtg = -homeNetRtg;
            
            // Calculate team per-100 stats for percentage calculations
            const calcTeamPer100 = (totals, teamPoss) => {
                const factor = teamPoss > 0 ? 100 / teamPoss : 0;
                return {
                    trb: (totals.oreb + totals.dreb) * factor,
                    stl: totals.stl * factor,
                    pf: totals.pf * factor,
                    ast: totals.ast * factor,
                    blk: totals.blk * factor,
                    pts: totals.points * factor,
                    fga: totals.fga * factor,
                    fta: totals.fta * factor
                };
            };
            
            // Calculate player's percentage of team stats while on court
            const calcPlayerPct = (playerPer100, teamPer100) => {
                return {
                    pctTRB: teamPer100.trb > 0 ? playerPer100.trb / teamPer100.trb : 0,
                    pctSTL: teamPer100.stl > 0 ? playerPer100.stl / teamPer100.stl : 0,
                    pctPF: teamPer100.pf > 0 ? playerPer100.pf / teamPer100.pf : 0,
                    pctAST: teamPer100.ast > 0 ? playerPer100.ast / teamPer100.ast : 0,
                    pctBLK: teamPer100.blk > 0 ? playerPer100.blk / teamPer100.blk : 0,
                    pctPTS: teamPer100.pts > 0 ? playerPer100.pts / teamPer100.pts : 0
                };
            };
            
            // Position regression with season data as prior (if available)
            const estimatePositionRaw = (pcts, minutes, listedPos = 3.0, seasonPos = null) => {
                const regPos = POS_REGRESSION.intercept +
                    POS_REGRESSION.pctTRB * pcts.pctTRB +
                    POS_REGRESSION.pctSTL * pcts.pctSTL +
                    POS_REGRESSION.pctPF * pcts.pctPF +
                    POS_REGRESSION.pctAST * pcts.pctAST +
                    POS_REGRESSION.pctBLK * pcts.pctBLK;
                
                // Use season position as prior if available, otherwise use heuristic
                const priorPos = seasonPos !== null ? seasonPos : listedPos;
                
                // For single-game: use 10-minute prior (vs 50 for season)
                // This gives more weight to actual game performance
                const priorMinutes = 10;
                const totalMin = minutes + priorMinutes;
                const weightedPos = (minutes * regPos + priorMinutes * priorPos) / totalMin;
                
                return weightedPos;
            };
            
            // Offensive role regression with season data as prior (if available)
            const estimateRoleRaw = (pcts, playerPer100, teamPtsPerTSA, minutes, seasonRole = null) => {
                // Calculate threshold points
                const thresholdEfficiency = teamPtsPerTSA - 0.33;
                const tsa = playerPer100.fga + 0.44 * playerPer100.fta;
                const playerPtsPerTSA = tsa > 0 ? playerPer100.pts / tsa : 0;
                
                let thresholdPts = 0;
                if (playerPtsPerTSA > thresholdEfficiency && tsa > 0) {
                    thresholdPts = playerPer100.pts - (thresholdEfficiency * tsa);
                }
                
                // Percentage of team threshold points (approximation)
                const pctThresholdPts = pcts.pctPTS * 0.5;
                
                const regRole = ROLE_REGRESSION.intercept +
                    ROLE_REGRESSION.pctAST * pcts.pctAST +
                    ROLE_REGRESSION.pctThresholdPts * pctThresholdPts;
                
                // Use season role as prior if available, otherwise default to 3.0
                const priorRole = seasonRole !== null ? seasonRole : 3.0;
                
                // For single-game: use 10-minute prior (vs 50 for season)
                const priorMinutes = 10;
                const totalMin = minutes + priorMinutes;
                const weightedRole = (minutes * regRole + priorMinutes * priorRole) / totalMin;
                
                return weightedRole;
            };
            
            // Normalize team positions/roles to average 3.0 (recursive)
            const normalizeToTeamAvg = (playersData, valueKey, targetAvg = 3.0, maxIterations = 10) => {
                for (let iter = 0; iter < maxIterations; iter++) {
                    let totalMinutes = 0;
                    let weightedSum = 0;
                    
                    for (const p of playersData) {
                        const clampedValue = Math.max(1.0, Math.min(5.0, p[valueKey]));
                        weightedSum += p.minutes * clampedValue;
                        totalMinutes += p.minutes;
                    }
                    
                    if (totalMinutes === 0) break;
                    
                    const currentAvg = weightedSum / totalMinutes;
                    const adjustment = targetAvg - currentAvg;
                    
                    if (Math.abs(adjustment) < 0.01) break;
                    
                    for (const p of playersData) {
                        p[valueKey] += adjustment;
                    }
                }
                
                for (const p of playersData) {
                    p[valueKey] = Math.max(1.0, Math.min(5.0, p[valueKey]));
                }
            };
            
            // Process a team's players
            const processTeam = (teamName, teamTotals, oppTotals, teamNetRtg, isHome) => {
                const players = teamsData[teamName].players.filter(p => p.minutes >= 3);
                const teamPoss = calcPossessions(teamTotals);
                const teamPer100 = calcTeamPer100(teamTotals, teamPoss);
                
                // Calculate team average pts per TSA
                const teamTSA = teamTotals.fga + 0.44 * teamTotals.fta;
                const teamPtsPerTSA = teamTSA > 0 ? teamTotals.points / teamTSA : 1.0;
                
                // Track expected team BPM from season data for team adjustment
                let expectedTeamBPM = 0;
                let totalMinutesForExpected = 0;
                
                // First pass: calculate raw positions and roles for all players
                const playersData = [];
                
                for (const player of players) {
                    const playerPoss = (player.minutes * pace) / 40;
                    if (playerPoss < 0.5) continue;
                    
                    // Look up season data for priors
                    const seasonData = getSeasonData(player.name, teamName);
                    const seasonPos = seasonData ? parseFloat(seasonData.POSITION) : null;
                    const seasonRole = seasonData ? parseFloat(seasonData.ROLE) : null;
                    const seasonBPM = seasonData ? parseFloat(seasonData.BPM) : null;
                    const seasonOBPM = seasonData ? parseFloat(seasonData.OBPM) : null;
                    const seasonDBPM = seasonData ? parseFloat(seasonData.DBPM) : null;
                    
                    // Accumulate expected team BPM weighted by minutes
                    if (seasonBPM !== null && !isNaN(seasonBPM)) {
                        expectedTeamBPM += player.minutes * seasonBPM;
                        totalMinutesForExpected += player.minutes;
                    }
                    
                    const factor = 100 / playerPoss;
                    const playerPer100 = {
                        pts: player.points * factor,
                        '3pm': player.fg3m * factor,
                        ast: player.ast * factor,
                        to: player.tov * factor,
                        orb: player.oreb * factor,
                        drb: player.dreb * factor,
                        trb: (player.oreb + player.dreb) * factor,
                        stl: player.stl * factor,
                        blk: player.blk * factor,
                        pf: player.pf * factor,
                        fga: player.fga * factor,
                        fta: player.fta * factor
                    };
                    
                    const pcts = calcPlayerPct(playerPer100, teamPer100);
                    
                    // Default listed position based on basic heuristics (fallback if no season data)
                    let listedPos = 3.0;
                    if (pcts.pctBLK > 0.3 || pcts.pctTRB > 0.25) listedPos = 4.5;
                    else if (pcts.pctAST > 0.25) listedPos = 1.5;
                    
                    playersData.push({
                        player: player,
                        playerPer100: playerPer100,
                        pcts: pcts,
                        minutes: player.minutes,
                        rawPosition: estimatePositionRaw(pcts, player.minutes, listedPos, seasonPos),
                        rawRole: estimateRoleRaw(pcts, playerPer100, teamPtsPerTSA, player.minutes, seasonRole),
                        seasonBPM: seasonBPM,
                        seasonOBPM: seasonOBPM,
                        seasonDBPM: seasonDBPM,
                        hasSeasonData: seasonData !== null
                    });
                }
                
                // Normalize positions and roles to team average of 3.0
                normalizeToTeamAvg(playersData, 'rawPosition', 3.0);
                normalizeToTeamAvg(playersData, 'rawRole', 3.0);
                
                // Second pass: calculate raw BPM for each player
                const rawBPMData = [];
                let totalMinutes = 0;
                let weightedRawBPM = 0;
                let weightedRawOBPM = 0;
                
                for (const pd of playersData) {
                    const position = pd.rawPosition;
                    const role = pd.rawRole;
                    const per100 = pd.playerPer100;
                    
                    // Calculate adjusted points
                    const tsa = per100.fga + 0.44 * per100.fta;
                    const pts_adj = per100.pts + (1.0 - teamPtsPerTSA) * tsa;
                    
                    // Calculate raw BPM
                    let rawBPM = BPM_COEF.pts_adj * pts_adj +
                        BPM_COEF['3pm'] * per100['3pm'] +
                        interpolate(BPM_COEF.ast, position) * per100.ast +
                        BPM_COEF.to * per100.to +
                        interpolate(BPM_COEF.orb, position) * per100.orb +
                        interpolate(BPM_COEF.drb, position) * per100.drb +
                        interpolate(BPM_COEF.stl, position) * per100.stl +
                        interpolate(BPM_COEF.blk, position) * per100.blk +
                        BPM_COEF.pf * per100.pf +
                        interpolate(BPM_COEF.fga, role) * per100.fga +
                        interpolate(BPM_COEF.fta, role) * per100.fta;
                    
                    // Calculate raw OBPM
                    let rawOBPM = OBPM_COEF.pts_adj * pts_adj +
                        OBPM_COEF['3pm'] * per100['3pm'] +
                        OBPM_COEF.ast * per100.ast +
                        OBPM_COEF.pf * per100.pf +
                        interpolate(OBPM_COEF.to, position) * per100.to +
                        interpolate(OBPM_COEF.orb, position) * per100.orb +
                        interpolate(OBPM_COEF.drb, position) * per100.drb +
                        interpolate(OBPM_COEF.stl, position) * per100.stl +
                        interpolate(OBPM_COEF.blk, position) * per100.blk +
                        interpolate(OBPM_COEF.fga, role) * per100.fga +
                        interpolate(OBPM_COEF.fta, role) * per100.fta;
                    
                    // Add position constants
                    const posConst = POS_CONST.pos_coef * position + POS_CONST.role_coef * role + POS_CONST.intercept;
                    const posConstOBPM = POS_CONST_OBPM.pos_coef * position + POS_CONST_OBPM.role_coef * role + POS_CONST_OBPM.intercept;
                    
                    rawBPM += posConst;
                    rawOBPM += posConstOBPM;
                    
                    rawBPMData.push({
                        ...pd,
                        position: position,
                        role: role,
                        rawBPM: rawBPM,
                        rawOBPM: rawOBPM
                    });
                    
                    const minPct = pd.minutes / 200; // Fraction of team minutes (200 = 5 players * 40 min)
                    totalMinutes += pd.minutes;
                    weightedRawBPM += minPct * rawBPM;
                    weightedRawOBPM += minPct * rawOBPM;
                }
                
                // Calculate team adjustments
                // For single-game: blend actual margin with expected team quality from season BPMs
                // This provides more stable anchoring than pure actual margin
                
                // Calculate expected team quality from season BPMs (minutes-weighted)
                const expectedTeamBPMAvg = totalMinutesForExpected > 0 
                    ? expectedTeamBPM / totalMinutesForExpected 
                    : 0;
                
                // Blend actual net rating with expected BPM (70% actual, 30% season expected)
                // This dampens single-game variance while still reflecting actual performance
                const ACTUAL_WEIGHT = 0.7;
                const EXPECTED_WEIGHT = 0.3;
                const blendedNetRtg = totalMinutesForExpected > 0
                    ? (ACTUAL_WEIGHT * teamNetRtg) + (EXPECTED_WEIGHT * expectedTeamBPMAvg * 5) // *5 to convert per-player to team-level
                    : teamNetRtg; // Fall back to actual if no season data
                
                // Team Adjustment = (Blended Net Rating * 1.20 - Sum of minutes-weighted Raw BPMs) / 5
                const teamAdjBPM = (blendedNetRtg * 1.20 - weightedRawBPM) / 5;
                const teamAdjOBPM = (blendedNetRtg * 0.60 - weightedRawOBPM) / 5; // Offensive portion
                
                // Third pass: apply team adjustment and finalize with TPA and Game Score
                const teamResults = [];
                let finalWeightedBPM = 0;
                let teamTotalTPA = 0;
                let teamTotalGameScore = 0;
                
                for (const pd of rawBPMData) {
                    const finalBPM = pd.rawBPM + teamAdjBPM;
                    const finalOBPM = pd.rawOBPM + teamAdjOBPM;
                    const finalDBPM = finalBPM - finalOBPM;
                    
                    // Calculate player possessions for TPA
                    // Player possessions = (minutes / 40) × team possessions (approximation)
                    const playerPoss = (pd.minutes / 200) * teamPoss * 5; // 200 = team minutes, *5 to get individual poss
                    
                    // TPA (Total Points Added) = BPM × (possessions / 100)
                    // This converts the rate stat (per 100 poss) to a counting stat
                    const tpa = finalBPM * (playerPoss / 100);
                    const otpa = finalOBPM * (playerPoss / 100);
                    const dtpa = finalDBPM * (playerPoss / 100);
                    
                    // Game Score (Hollinger) for comparison
                    const gameScore = calcGameScore(pd.player);
                    
                    teamResults.push({
                        number: pd.player.number,
                        name: pd.player.name,
                        minutes: Math.round(pd.player.minutes),
                        obpm: finalOBPM,
                        dbpm: finalDBPM,
                        bpm: finalBPM,
                        // New single-game metrics
                        tpa: tpa,           // Total Points Added (counting stat)
                        otpa: otpa,         // Offensive TPA
                        dtpa: dtpa,         // Defensive TPA
                        gameScore: gameScore, // Hollinger Game Score
                        playerPoss: playerPoss,
                        position: pd.position,
                        role: pd.role,
                        // Season data indicators
                        hasSeasonData: pd.hasSeasonData,
                        seasonBPM: pd.seasonBPM
                    });
                    
                    finalWeightedBPM += pd.minutes * finalBPM;
                    teamTotalTPA += tpa;
                    teamTotalGameScore += gameScore;
                }
                
                return {
                    players: teamResults,
                    teamAvgBPM: totalMinutes > 0 ? finalWeightedBPM / totalMinutes : 0,
                    teamTPA: teamTotalTPA,
                    teamGameScore: teamTotalGameScore,
                    teamPoss: teamPoss,
                    expectedBPM: expectedTeamBPMAvg // Expected team BPM from season data
                };
            };
            
            // Process both teams
            results.home = processTeam(homeTeam, homeTotals, awayTotals, homeNetRtg, true);
            results.away = processTeam(awayTeam, awayTotals, homeTotals, awayNetRtg, false);
            results.gamePoss = gamePoss;
            
            return results;
        }
        
        // ========================================================================
        // SHOT CHART TAB
        // ========================================================================
        
        renderShotChartTab(teamsData, homeTeam, awayTeam) {
            // Check if we have shot chart data loaded
            const hasData = this.shotChartLoadedData && this.shotChartLoadedData.length > 0;
            
            if (!hasData) {
                // Show file upload prompt
                return `
                    <div class="shot-chart-container">
                        <div class="stat-card glass-card full-width">
                            <div class="card-header">
                                <span class="card-title">🎯 Shot Chart Analysis</span>
                            </div>
                            
                            <div class="shot-chart-url-prompt">
                                <h3>📊 Load Shot Chart Data</h3>
                                <p>Upload the FIBA LiveStats shot chart file (sc.html) to visualize shot locations and zones.</p>
                                <p style="font-size: 12px; color: var(--text-muted); margin-bottom: var(--space-lg);">
                                    You can also upload the file from the main upload screen before processing a game.
                                </p>
                                <label class="upload-btn" style="display: inline-block; padding: 14px 32px; background: linear-gradient(135deg, var(--accent-gold), rgba(255, 208, 0, 0.7)); border: none; border-radius: var(--radius-md); color: var(--bg-base); font-family: 'Space Grotesk', sans-serif; font-size: 14px; font-weight: 700; cursor: pointer; transition: all 0.3s ease;">
                                    🎯 Upload Shot Chart (sc.html)
                                    <input type="file" id="shotchart-tab-file" accept=".html,.htm" style="display: none;" onchange="window.fibaVisualizer.handleShotChartTabFileUpload(event)">
                                </label>
                                <div id="shotchart-tab-status" style="margin-top: 16px; font-size: 13px;"></div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Parse and process the shot data
            const shotData = this.processShotChartData(this.shotChartLoadedData, homeTeam, awayTeam);
            
            // Store shot data for filtering
            this.shotChartData = {
                shots: shotData,
                homeTeam,
                awayTeam,
                selectedTeam: 'home',
                selectedPlayer: 'all',
                selectedPeriod: 'all'
            };
            
            return `
                <div class="shot-chart-container">
                    <div class="stat-card glass-card full-width">
                        <div class="card-header">
                            <span class="card-title">🎯 Shot Chart Analysis</span>
                            <button onclick="window.fibaVisualizer.clearShotChartData()" 
                                    style="padding: 6px 12px; background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-secondary); font-size: 11px; cursor: pointer;">
                                🔄 Load Different Game
                            </button>
                        </div>
                        
                        <!-- Controls -->
                        <div class="shot-chart-controls">
                            <div class="shot-chart-control-group">
                                <label>Team</label>
                                <select class="shot-chart-select" id="shot-chart-team" onchange="window.fibaVisualizer.onTeamChange()">
                                    <option value="home">${homeTeam}</option>
                                    <option value="away">${awayTeam}</option>
                                </select>
                            </div>
                            
                            <div class="shot-chart-control-group">
                                <label>Player</label>
                                <select class="shot-chart-select" id="shot-chart-player" onchange="window.fibaVisualizer.updateShotChart()">
                                    <option value="all">All Players</option>
                                    ${this.getPlayersForTeam(shotData, 'home').map(p => 
                                        `<option value="${p.number}">${p.number} - ${p.name}</option>`
                                    ).join('')}
                                </select>
                            </div>
                            
                            <div class="shot-chart-control-group">
                                <label>Period</label>
                                <div class="shot-chart-period-filter">
                                    <button class="period-filter-btn active" data-period="all" onclick="window.fibaVisualizer.setShotChartPeriod('all', this)">All</button>
                                    <button class="period-filter-btn" data-period="1" onclick="window.fibaVisualizer.setShotChartPeriod('1', this)">Q1</button>
                                    <button class="period-filter-btn" data-period="2" onclick="window.fibaVisualizer.setShotChartPeriod('2', this)">Q2</button>
                                    <button class="period-filter-btn" data-period="3" onclick="window.fibaVisualizer.setShotChartPeriod('3', this)">Q3</button>
                                    <button class="period-filter-btn" data-period="4" onclick="window.fibaVisualizer.setShotChartPeriod('4', this)">Q4</button>
                                </div>
                            </div>
                            
                            <div class="shot-chart-legend">
                                <div class="legend-item">
                                    <span class="legend-dot made"></span>
                                    <span>Made</span>
                                </div>
                                <div class="legend-item">
                                    <span class="legend-dot missed"></span>
                                    <span>Missed</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Summary Stats -->
                        <div class="shot-chart-summary" id="shot-chart-summary">
                            ${this.renderShotChartSummary(shotData, 'home', 'all', 'all')}
                        </div>
                        
                        <!-- Court with shots -->
                        <div class="shot-chart-court-container">
                            <div class="shot-chart-court" id="shot-chart-court">
                                ${this.renderShotChartCourt(shotData, 'home', 'all', 'all')}
                            </div>
                            <div class="shot-tooltip" id="shot-tooltip"></div>
                        </div>
                        
                        <!-- Zone Stats Cards -->
                        <div class="shot-zone-stats" id="shot-zone-stats">
                            ${this.renderZoneStatsCards(shotData, 'home', 'all', 'all')}
                        </div>
                        
                        <!-- Zone Bar Chart -->
                        <div class="shot-chart-bar-container">
                            <div class="shot-chart-bar-title">📊 Zone Breakdown</div>
                            <div class="shot-chart-bars" id="shot-chart-bars">
                                ${this.renderZoneBarChart(shotData, 'home', 'all', 'all')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Handle shot chart file upload from splash screen
        handleShotChartFileUpload(event) {
            const file = event.target.files[0];
            const statusEl = document.getElementById('shotchart-file-status');
            
            if (!file) return;
            
            if (statusEl) statusEl.innerHTML = '<span style="color: var(--accent-gold);">⏳ Processing shot chart file...</span>';
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const html = e.target.result;
                    this.shotChartLoadedData = this.parseShotChartHtml(html);
                    
                    if (!this.shotChartLoadedData || this.shotChartLoadedData.length === 0) {
                        if (statusEl) statusEl.innerHTML = '<span style="color: var(--negative);">✗ No shot data found in file</span>';
                        return;
                    }
                    
                    if (statusEl) statusEl.innerHTML = `<span style="color: var(--positive);">✓ Loaded ${this.shotChartLoadedData.length} shots! Data will appear in Shot Chart tab.</span>`;
                } catch (err) {
                    if (statusEl) statusEl.innerHTML = `<span style="color: var(--negative);">✗ Error: ${err.message}</span>`;
                }
            };
            reader.onerror = () => {
                if (statusEl) statusEl.innerHTML = '<span style="color: var(--negative);">✗ Error reading file</span>';
            };
            reader.readAsText(file);
        }
        
        // Handle shot chart file upload from tab
        handleShotChartTabFileUpload(event) {
            const file = event.target.files[0];
            const statusEl = document.getElementById('shotchart-tab-status');
            
            if (!file) return;
            
            if (statusEl) statusEl.innerHTML = '<span style="color: var(--accent-gold);">⏳ Processing shot chart file...</span>';
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const html = e.target.result;
                    this.shotChartLoadedData = this.parseShotChartHtml(html);
                    
                    if (!this.shotChartLoadedData || this.shotChartLoadedData.length === 0) {
                        if (statusEl) statusEl.innerHTML = '<span style="color: var(--negative);">✗ No shot data found in file</span>';
                        return;
                    }
                    
                    if (statusEl) statusEl.innerHTML = `<span style="color: var(--positive);">✓ Loaded ${this.shotChartLoadedData.length} shots! Refreshing...</span>`;
                    
                    // Re-render the shot chart tab
                    setTimeout(() => {
                        const tabContent = document.getElementById('tab-shotchart');
                        if (tabContent && this.lastTeamsData) {
                            const teamNames = Object.keys(this.lastTeamsData);
                            tabContent.innerHTML = this.renderShotChartTab(this.lastTeamsData, teamNames[0], teamNames[1]);
                        }
                    }, 500);
                } catch (err) {
                    if (statusEl) statusEl.innerHTML = `<span style="color: var(--negative);">✗ Error: ${err.message}</span>`;
                }
            };
            reader.onerror = () => {
                if (statusEl) statusEl.innerHTML = '<span style="color: var(--negative);">✗ Error reading file</span>';
            };
            reader.readAsText(file);
        }
        
        // Parse CSV text into array of objects
        parseCSV(csvText) {
            const lines = csvText.trim().split(/\r?\n/);
            if (lines.length < 2) return [];
            
            // Parse header row
            const headers = lines[0].split(',').map(h => h.trim());
            
            // Parse data rows
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                if (values.length !== headers.length) continue;
                
                const row = {};
                headers.forEach((h, idx) => {
                    row[h] = values[idx].trim();
                });
                data.push(row);
            }
            return data;
        }
        
        // Load season player data from CSV file
        loadSeasonDataFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const csvText = e.target.result;
                        this.seasonPlayerData = this.parseCSV(csvText);
                        console.log(`[Season Data] Loaded ${this.seasonPlayerData.length} player records`);
                        resolve(this.seasonPlayerData);
                    } catch (err) {
                        console.error('[Season Data] Error parsing CSV:', err);
                        reject(err);
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }
        
        // Handle season data file upload from UI
        handleSeasonDataUpload(event) {
            const file = event.target.files[0];
            const statusEl = document.getElementById('season-data-status');
            
            if (!file) return;
            
            if (statusEl) statusEl.innerHTML = '<span style="color: var(--accent-gold);">⏳ Loading season data...</span>';
            
            this.loadSeasonDataFromFile(file)
                .then(data => {
                    if (statusEl) statusEl.innerHTML = `<span style="color: var(--positive);">✓ Loaded ${data.length} players with season BPM data</span>`;
                    
                    // Re-render BPM tab if game is loaded
                    if (this.lastTeamsData) {
                        setTimeout(() => {
                            const tabContent = document.getElementById('tab-bpm');
                            if (tabContent) {
                                const teamNames = Object.keys(this.lastTeamsData);
                                console.log('[Season Data] BPM will use season priors on next game load');
                            }
                        }, 100);
                    }
                })
                .catch(err => {
                    if (statusEl) statusEl.innerHTML = `<span style="color: var(--negative);">✗ Error: ${err.message}</span>`;
                });
        }
        
        // Parse shot chart HTML
        parseShotChartHtml(html) {
            const shots = [];
            
            // Create a temporary div to parse HTML
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Find all shot chart spans
            const shotElements = doc.querySelectorAll('span[class*="sc_img"]');
            
            shotElements.forEach(el => {
                const classes = el.className;
                const style = el.getAttribute('style') || '';
                const title = el.getAttribute('title') || '';
                
                // Parse position
                const bottomMatch = style.match(/bottom:\s*([\d.]+)%/);
                const leftMatch = style.match(/left:\s*([\d.]+)%/);
                
                // Parse made/missed and team
                const made = classes.includes('_made');
                const isHome = classes.includes('white_');
                
                // Parse period
                const periodMatch = classes.match(/sc_per(\d+)/);
                const period = periodMatch ? periodMatch[1] : '1';
                
                // Parse player number
                const playerMatch = classes.match(/sc_pn(\d+)/);
                const playerNum = playerMatch ? playerMatch[1] : '0';
                
                // Parse title for name and shot type
                const titleParts = title.split(',');
                const playerName = titleParts.length > 1 ? titleParts[1].trim() : 'Unknown';
                const shotType = titleParts.length > 2 ? titleParts.slice(2).join(',').trim() : 'shot';
                
                if (bottomMatch && leftMatch) {
                    shots.push({
                        x: parseFloat(leftMatch[1]),
                        y: parseFloat(bottomMatch[1]),
                        made,
                        isHome,
                        period,
                        playerNum,
                        playerName,
                        shotType
                    });
                }
            });
            
            return shots;
        }
        
        // Process shot chart data with zone classification
        processShotChartData(rawShots, homeTeam, awayTeam) {
            return rawShots.map(shot => ({
                ...shot,
                is3pt: shot.shotType.toLowerCase().includes('3pt'),
                zone: this.classifyShotZone(shot.x, shot.y, shot.shotType)
            }));
        }
        
        // Clear shot chart data and show file upload prompt
        clearShotChartData() {
            this.shotChartLoadedData = null;
            
            const tabContent = document.getElementById('tab-shotchart');
            if (tabContent && this.lastTeamsData) {
                const teamNames = Object.keys(this.lastTeamsData);
                tabContent.innerHTML = this.renderShotChartTab(this.lastTeamsData, teamNames[0], teamNames[1]);
            }
        }
        
        // Classify shot into zones based on position
        classifyShotZone(x, y, shotType) {
            // FIBA shot chart uses percentage coordinates (0-100)
            // Court is displayed with basket on left (0-50%) and right (50-100%)
            const isRightSide = x > 50;
            
            // Normalize X to be distance from nearest basket (in %)
            // Left basket is at ~5.85% (110/1880*100), right at ~94.15%
            const basketX = isRightSide ? 94.15 : 5.85;
            const normX = Math.abs(x - basketX);
            
            // Y position: 0 = bottom sideline, 100 = top sideline, 50 = center
            const normY = y;
            
            const is3pt = shotType.toLowerCase().includes('3pt');
            const isLayup = shotType.toLowerCase().includes('lay up') || 
                           shotType.toLowerCase().includes('layup') ||
                           shotType.toLowerCase().includes('dunk') ||
                           shotType.toLowerCase().includes('tipinlayup') ||
                           shotType.toLowerCase().includes('tip in') ||
                           shotType.toLowerCase().includes('driving');
            
            // Layups and dunks are always rim shots
            if (isLayup) {
                return 'rim';
            }
            
            // Rim/Restricted area - very close to basket (within ~8% of basket position)
            if (normX <= 8 && normY >= 40 && normY <= 60) {
                return 'rim';
            }
            
            // 3PT zones - use shot type as primary classifier
            if (is3pt) {
                // Corner 3s - Y is in corner area (< 6% or > 94% from sidelines)
                if (normY <= 6 || normY >= 94) {
                    return isRightSide ? 'corner3_right' : 'corner3_left';
                }
                // Wing 3s - between corner and about 35/65
                if (normY <= 30 || normY >= 70) {
                    return isRightSide ? 'wing3_right' : 'wing3_left';
                }
                // Top of key 3
                return 'top3';
            }
            
            // Paint area - inside the key (x within ~20% of basket, y within paint bounds 34-66%)
            if (normX <= 15 && normY >= 34 && normY <= 66) {
                return 'paint';
            }
            
            // Everything else inside the arc is mid-range
            // Mid-range zones by position
            if (normY <= 20 || normY >= 80) {
                // Baseline mid-range (short corner area)
                return isRightSide ? 'mid_baseline_right' : 'mid_baseline_left';
            } else if (normY <= 40 || normY >= 60) {
                // Elbow/wing mid-range
                return 'mid_elbow';
            } else {
                // Free throw line / high post area
                return 'mid_ft';
            }
        }
        
        // Get players for a team
        getPlayersForTeam(shots, team) {
            const isHome = team === 'home';
            const teamShots = shots.filter(s => s.isHome === isHome);
            const playersMap = new Map();
            
            teamShots.forEach(shot => {
                if (!playersMap.has(shot.playerNum)) {
                    playersMap.set(shot.playerNum, { number: shot.playerNum, name: shot.playerName });
                }
            });
            
            return Array.from(playersMap.values()).sort((a, b) => parseInt(a.number) - parseInt(b.number));
        }
        
        // Handle team change
        onTeamChange() {
            if (!this.shotChartData) return;
            
            const teamSelect = document.getElementById('shot-chart-team');
            const playerSelect = document.getElementById('shot-chart-player');
            const selectedTeam = teamSelect.value;
            
            // Update player dropdown
            const players = this.getPlayersForTeam(this.shotChartData.shots, selectedTeam);
            playerSelect.innerHTML = '<option value="all">All Players</option>' + 
                players.map(p => `<option value="${p.number}">${p.number} - ${p.name}</option>`).join('');
            
            this.shotChartData.selectedTeam = selectedTeam;
            this.shotChartData.selectedPlayer = 'all';
            
            this.updateShotChart();
        }
        
        // Set period filter
        setShotChartPeriod(period, btn) {
            if (!this.shotChartData) return;
            
            // Update button states
            document.querySelectorAll('.period-filter-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            this.shotChartData.selectedPeriod = period;
            this.updateShotChart();
        }
        
        // Main update function
        updateShotChart() {
            if (!this.shotChartData) return;
            
            const teamSelect = document.getElementById('shot-chart-team');
            const playerSelect = document.getElementById('shot-chart-player');
            
            if (!teamSelect || !playerSelect) return;
            
            const selectedTeam = teamSelect.value;
            const selectedPlayer = playerSelect.value;
            const selectedPeriod = this.shotChartData.selectedPeriod || 'all';
            
            // Update all sections
            const summaryEl = document.getElementById('shot-chart-summary');
            const courtEl = document.getElementById('shot-chart-court');
            const zoneStatsEl = document.getElementById('shot-zone-stats');
            const barsEl = document.getElementById('shot-chart-bars');
            
            if (summaryEl) summaryEl.innerHTML = this.renderShotChartSummary(this.shotChartData.shots, selectedTeam, selectedPlayer, selectedPeriod);
            if (courtEl) courtEl.innerHTML = this.renderShotChartCourt(this.shotChartData.shots, selectedTeam, selectedPlayer, selectedPeriod);
            if (zoneStatsEl) zoneStatsEl.innerHTML = this.renderZoneStatsCards(this.shotChartData.shots, selectedTeam, selectedPlayer, selectedPeriod);
            if (barsEl) barsEl.innerHTML = this.renderZoneBarChart(this.shotChartData.shots, selectedTeam, selectedPlayer, selectedPeriod);
        }
        
        // Filter shots based on selection
        filterShots(shots, team, player, period) {
            const isHome = team === 'home';
            return shots.filter(s => {
                if (s.isHome !== isHome) return false;
                if (player !== 'all' && s.playerNum !== player) return false;
                if (period !== 'all' && s.period !== period) return false;
                return true;
            });
        }
        
        // Render summary stats
        renderShotChartSummary(shots, team, player, period) {
            const filtered = this.filterShots(shots, team, player, period);
            const total = filtered.length;
            const made = filtered.filter(s => s.made).length;
            const pct = total > 0 ? (made / total * 100).toFixed(1) : 0;
            
            const threes = filtered.filter(s => s.is3pt);
            const threeMade = threes.filter(s => s.made).length;
            const threePct = threes.length > 0 ? (threeMade / threes.length * 100).toFixed(1) : 0;
            
            const twos = filtered.filter(s => !s.is3pt);
            const twoMade = twos.filter(s => s.made).length;
            const twoPct = twos.length > 0 ? (twoMade / twos.length * 100).toFixed(1) : 0;
            
            const rimShots = filtered.filter(s => s.zone === 'rim');
            const rimMade = rimShots.filter(s => s.made).length;
            const rimPct = rimShots.length > 0 ? (rimMade / rimShots.length * 100).toFixed(1) : 0;
            
            // Calculate eFG%
            const efg = total > 0 ? ((made + 0.5 * threeMade) / total * 100).toFixed(1) : 0;
            
            const getPctClass = (pct, type = 'fg') => {
                const p = parseFloat(pct);
                if (type === '3pt') {
                    if (p >= 40) return 'positive';
                    if (p < 30) return 'negative';
                    return 'neutral';
                } else if (type === 'rim') {
                    if (p >= 60) return 'positive';
                    if (p < 45) return 'negative';
                    return 'neutral';
                } else {
                    if (p >= 50) return 'positive';
                    if (p < 40) return 'negative';
                    return 'neutral';
                }
            };
            
            return `
                <div class="summary-stat">
                    <div class="summary-stat-value ${getPctClass(pct)}">${pct}%</div>
                    <div class="summary-stat-label">FG% (${made}/${total})</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value ${getPctClass(efg)}">${efg}%</div>
                    <div class="summary-stat-label">eFG%</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value ${getPctClass(twoPct)}">${twoPct}%</div>
                    <div class="summary-stat-label">2PT (${twoMade}/${twos.length})</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value ${getPctClass(threePct, '3pt')}">${threePct}%</div>
                    <div class="summary-stat-label">3PT (${threeMade}/${threes.length})</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value ${getPctClass(rimPct, 'rim')}">${rimPct}%</div>
                    <div class="summary-stat-label">RIM (${rimMade}/${rimShots.length})</div>
                </div>
            `;
        }
        
        // Get zone color based on percentage
        getZoneColorClass(pct, type = 'fg') {
            const p = parseFloat(pct);
            if (isNaN(p)) return 'neutral';
            
            if (type === '3pt') {
                if (p >= 45) return 'hot';
                if (p >= 37) return 'warm';
                if (p >= 30) return 'neutral';
                if (p >= 25) return 'cool';
                return 'cold';
            } else if (type === 'rim') {
                if (p >= 70) return 'hot';
                if (p >= 55) return 'warm';
                if (p >= 45) return 'neutral';
                if (p >= 35) return 'cool';
                return 'cold';
            } else { // mid-range
                if (p >= 50) return 'hot';
                if (p >= 42) return 'warm';
                if (p >= 35) return 'neutral';
                if (p >= 28) return 'cool';
                return 'cold';
            }
        }
        
        // Get color for zone overlay
        getZoneColor(colorClass) {
            const colors = {
                'hot': 'rgba(0, 255, 136, 0.35)',
                'warm': 'rgba(0, 212, 255, 0.3)',
                'neutral': 'rgba(255, 255, 255, 0.15)',
                'cool': 'rgba(255, 165, 0, 0.3)',
                'cold': 'rgba(255, 107, 107, 0.35)'
            };
            return colors[colorClass] || colors.neutral;
        }
        
        // Calculate zone statistics
        calculateZoneStats(shots) {
            const zones = {
                rim: { made: 0, total: 0, pct: 0, type: 'rim' },
                paint: { made: 0, total: 0, pct: 0, type: 'paint' },
                mid_baseline_left: { made: 0, total: 0, pct: 0, type: 'mid' },
                mid_baseline_right: { made: 0, total: 0, pct: 0, type: 'mid' },
                mid_elbow: { made: 0, total: 0, pct: 0, type: 'mid' },
                mid_ft: { made: 0, total: 0, pct: 0, type: 'mid' },
                corner3_left: { made: 0, total: 0, pct: 0, type: '3pt' },
                corner3_right: { made: 0, total: 0, pct: 0, type: '3pt' },
                wing3_left: { made: 0, total: 0, pct: 0, type: '3pt' },
                wing3_right: { made: 0, total: 0, pct: 0, type: '3pt' },
                top3: { made: 0, total: 0, pct: 0, type: '3pt' }
            };
            
            shots.forEach(shot => {
                const zone = shot.zone;
                if (zones[zone]) {
                    zones[zone].total++;
                    if (shot.made) zones[zone].made++;
                }
            });
            
            // Calculate percentages
            Object.keys(zones).forEach(z => {
                zones[z].pct = zones[z].total > 0 ? 
                    Math.round(zones[z].made / zones[z].total * 100) : 0;
            });
            
            // Aggregate zones for summary
            zones.corner3 = {
                made: zones.corner3_left.made + zones.corner3_right.made,
                total: zones.corner3_left.total + zones.corner3_right.total,
                type: '3pt'
            };
            zones.corner3.pct = zones.corner3.total > 0 ? Math.round(zones.corner3.made / zones.corner3.total * 100) : 0;
            
            zones.wing3 = {
                made: zones.wing3_left.made + zones.wing3_right.made,
                total: zones.wing3_left.total + zones.wing3_right.total,
                type: '3pt'
            };
            zones.wing3.pct = zones.wing3.total > 0 ? Math.round(zones.wing3.made / zones.wing3.total * 100) : 0;
            
            zones.mid = {
                made: zones.mid_baseline_left.made + zones.mid_baseline_right.made + zones.mid_elbow.made + zones.mid_ft.made,
                total: zones.mid_baseline_left.total + zones.mid_baseline_right.total + zones.mid_elbow.total + zones.mid_ft.total,
                type: 'mid'
            };
            zones.mid.pct = zones.mid.total > 0 ? Math.round(zones.mid.made / zones.mid.total * 100) : 0;
            
            return zones;
        }
        
        // Render the court with shots - 2X BIGGER with proper zones
        renderShotChartCourt(shots, team, player, period) {
            const filtered = this.filterShots(shots, team, player, period);
            const zoneStats = this.calculateZoneStats(filtered);
            
            // SVG viewBox for 2x scale (1880 x 1000)
            const W = 1880;
            const H = 1000;
            
            // Key measurements (scaled 2x)
            const basketX = 110;           // Basket X position from edge
            const paintWidth = 320;        // Paint width
            const paintTop = 340;          // Paint top Y
            const paintBottom = 660;       // Paint bottom Y
            const threePointRadius = 450;  // 3pt arc radius from basket
            const cornerThreeY = 60;       // Where corner 3 ends (Y from edge)
            const restrictedRadius = 80;   // Restricted area radius
            
            // Zone coloring helper
            const getZoneFill = (zone) => {
                const stat = zoneStats[zone];
                if (!stat || stat.total === 0) return 'rgba(255, 255, 255, 0.03)';
                return this.getZoneColor(this.getZoneColorClass(stat.pct, stat.type));
            };
            
            // Zone label helper
            const renderZoneLabel = (x, y, zone, fontSize = 28) => {
                const stat = zoneStats[zone];
                if (!stat || stat.total === 0) return '';
                
                const colorClass = this.getZoneColorClass(stat.pct, stat.type);
                const textColor = colorClass === 'hot' ? '#00ff88' : 
                                 colorClass === 'warm' ? '#00d4ff' : 
                                 colorClass === 'cold' ? '#ff6b6b' : 
                                 colorClass === 'cool' ? '#ffa500' : '#ffffff';
                
                return `
                    <text x="${x}" y="${y}" fill="${textColor}" text-anchor="middle" 
                          font-family="Space Mono, monospace" font-weight="700" font-size="${fontSize}px"
                          style="text-shadow: 0 2px 8px rgba(0,0,0,0.9);">
                        ${stat.pct}%
                    </text>
                    <text x="${x}" y="${y + fontSize * 0.8}" fill="rgba(255,255,255,0.8)" text-anchor="middle" 
                          font-family="Space Mono, monospace" font-size="${fontSize * 0.5}px"
                          style="text-shadow: 0 2px 4px rgba(0,0,0,0.9);">
                        ${stat.made}/${stat.total}
                    </text>
                `;
            };
            
            const courtSVG = `
                <svg viewBox="0 0 ${W} ${H}" preserveAspectRatio="xMidYMid meet">
                    <defs>
                        <linearGradient id="courtGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#1a1a2e"/>
                            <stop offset="100%" style="stop-color:#16213e"/>
                        </linearGradient>
                        <!-- Clip paths for proper zone boundaries -->
                        <clipPath id="leftHalf">
                            <rect x="0" y="0" width="${W/2}" height="${H}"/>
                        </clipPath>
                        <clipPath id="rightHalf">
                            <rect x="${W/2}" y="0" width="${W/2}" height="${H}"/>
                        </clipPath>
                    </defs>
                    
                    <!-- Court background -->
                    <rect x="0" y="0" width="${W}" height="${H}" fill="url(#courtGradient)"/>
                    
                    <!-- ============ LEFT SIDE ZONES ============ -->
                    
                    <!-- Corner 3 Left - Bottom (rectangle at bottom-left) -->
                    <rect x="0" y="0" width="280" height="${cornerThreeY}" fill="${getZoneFill('corner3_left')}" />
                    
                    <!-- Corner 3 Left - Top (rectangle at top-left) -->
                    <rect x="0" y="${H - cornerThreeY}" width="280" height="${cornerThreeY}" fill="${getZoneFill('corner3_left')}" />
                    
                    <!-- Wing 3 Left - Bottom (outside arc, between corner and 45 degrees) -->
                    <path d="M 280 0 L 280 ${cornerThreeY} 
                             A ${threePointRadius} ${threePointRadius} 0 0 1 ${basketX + threePointRadius * 0.7} ${500 - threePointRadius * 0.7}
                             L ${basketX} ${500 - threePointRadius}
                             L 0 ${500 - threePointRadius} L 0 0 Z" 
                          fill="${getZoneFill('wing3_left')}" clip-path="url(#leftHalf)" />
                    
                    <!-- Wing 3 Left - Top -->
                    <path d="M 280 ${H} L 280 ${H - cornerThreeY}
                             A ${threePointRadius} ${threePointRadius} 0 0 0 ${basketX + threePointRadius * 0.7} ${500 + threePointRadius * 0.7}
                             L ${basketX} ${500 + threePointRadius}
                             L 0 ${500 + threePointRadius} L 0 ${H} Z"
                          fill="${getZoneFill('wing3_left')}" clip-path="url(#leftHalf)" />
                    
                    <!-- Top 3 Left (outside arc, in the middle) -->
                    <path d="M ${basketX + threePointRadius * 0.7} ${500 - threePointRadius * 0.7}
                             A ${threePointRadius} ${threePointRadius} 0 0 1 ${basketX + threePointRadius * 0.7} ${500 + threePointRadius * 0.7}
                             L ${W/2} ${500 + threePointRadius * 0.7}
                             L ${W/2} ${500 - threePointRadius * 0.7} Z"
                          fill="${getZoneFill('top3')}" clip-path="url(#leftHalf)" />
                    
                    <!-- Mid-range Left - fills area between paint and 3pt arc -->
                    <path d="M 280 ${cornerThreeY}
                             A ${threePointRadius} ${threePointRadius} 0 0 1 280 ${H - cornerThreeY}
                             L ${paintWidth} ${H - cornerThreeY}
                             L ${paintWidth} ${paintBottom}
                             L 0 ${paintBottom}
                             L 0 ${paintTop}
                             L ${paintWidth} ${paintTop}
                             L ${paintWidth} ${cornerThreeY} Z"
                          fill="${getZoneFill('mid_elbow')}" clip-path="url(#leftHalf)" />
                    
                    <!-- Paint Left (non-restricted area) -->
                    <path d="M 0 ${paintTop} L ${paintWidth} ${paintTop} L ${paintWidth} ${paintBottom} L 0 ${paintBottom} Z"
                          fill="${getZoneFill('paint')}" />
                    
                    <!-- Rim Left (restricted area) -->
                    <circle cx="${basketX}" cy="500" r="${restrictedRadius}" fill="${getZoneFill('rim')}" />
                    
                    <!-- ============ RIGHT SIDE ZONES ============ -->
                    
                    <!-- Corner 3 Right - Bottom -->
                    <rect x="${W - 280}" y="0" width="280" height="${cornerThreeY}" fill="${getZoneFill('corner3_right')}" />
                    
                    <!-- Corner 3 Right - Top -->
                    <rect x="${W - 280}" y="${H - cornerThreeY}" width="280" height="${cornerThreeY}" fill="${getZoneFill('corner3_right')}" />
                    
                    <!-- Wing 3 Right - Bottom -->
                    <path d="M ${W - 280} 0 L ${W - 280} ${cornerThreeY}
                             A ${threePointRadius} ${threePointRadius} 0 0 0 ${W - basketX - threePointRadius * 0.7} ${500 - threePointRadius * 0.7}
                             L ${W - basketX} ${500 - threePointRadius}
                             L ${W} ${500 - threePointRadius} L ${W} 0 Z"
                          fill="${getZoneFill('wing3_right')}" clip-path="url(#rightHalf)" />
                    
                    <!-- Wing 3 Right - Top -->
                    <path d="M ${W - 280} ${H} L ${W - 280} ${H - cornerThreeY}
                             A ${threePointRadius} ${threePointRadius} 0 0 1 ${W - basketX - threePointRadius * 0.7} ${500 + threePointRadius * 0.7}
                             L ${W - basketX} ${500 + threePointRadius}
                             L ${W} ${500 + threePointRadius} L ${W} ${H} Z"
                          fill="${getZoneFill('wing3_right')}" clip-path="url(#rightHalf)" />
                    
                    <!-- Top 3 Right -->
                    <path d="M ${W - basketX - threePointRadius * 0.7} ${500 - threePointRadius * 0.7}
                             A ${threePointRadius} ${threePointRadius} 0 0 0 ${W - basketX - threePointRadius * 0.7} ${500 + threePointRadius * 0.7}
                             L ${W/2} ${500 + threePointRadius * 0.7}
                             L ${W/2} ${500 - threePointRadius * 0.7} Z"
                          fill="${getZoneFill('top3')}" clip-path="url(#rightHalf)" />
                    
                    <!-- Mid-range Right -->
                    <path d="M ${W - 280} ${cornerThreeY}
                             A ${threePointRadius} ${threePointRadius} 0 0 0 ${W - 280} ${H - cornerThreeY}
                             L ${W - paintWidth} ${H - cornerThreeY}
                             L ${W - paintWidth} ${paintBottom}
                             L ${W} ${paintBottom}
                             L ${W} ${paintTop}
                             L ${W - paintWidth} ${paintTop}
                             L ${W - paintWidth} ${cornerThreeY} Z"
                          fill="${getZoneFill('mid_elbow')}" clip-path="url(#rightHalf)" />
                    
                    <!-- Paint Right -->
                    <path d="M ${W} ${paintTop} L ${W - paintWidth} ${paintTop} L ${W - paintWidth} ${paintBottom} L ${W} ${paintBottom} Z"
                          fill="${getZoneFill('paint')}" />
                    
                    <!-- Rim Right -->
                    <circle cx="${W - basketX}" cy="500" r="${restrictedRadius}" fill="${getZoneFill('rim')}" />
                    
                    <!-- ============ COURT LINES ============ -->
                    <!-- Outer boundary -->
                    <rect x="0" y="0" width="${W}" height="${H}" class="court-line" fill="none" stroke-width="4"/>
                    
                    <!-- Half court line -->
                    <line x1="${W/2}" y1="0" x2="${W/2}" y2="${H}" class="court-line" stroke-width="4"/>
                    
                    <!-- Center circle -->
                    <circle cx="${W/2}" cy="${H/2}" r="120" class="court-line" stroke-width="4"/>
                    <circle cx="${W/2}" cy="${H/2}" r="12" fill="rgba(255,255,255,0.3)"/>
                    
                    <!-- LEFT SIDE LINES -->
                    <rect x="0" y="${paintTop}" width="${paintWidth}" height="${paintBottom - paintTop}" class="court-line" stroke-width="4" fill="none"/>
                    <circle cx="${paintWidth}" cy="500" r="120" class="court-line" stroke-width="4" fill="none"/>
                    <circle cx="${basketX}" cy="500" r="${restrictedRadius}" class="court-line" stroke-width="3" fill="none" stroke-dasharray="8,8"/>
                    <circle cx="${basketX}" cy="500" r="16" fill="rgba(255,107,107,0.5)" stroke="rgba(255,255,255,0.6)" stroke-width="4"/>
                    <rect x="${basketX - 32}" y="496" width="32" height="8" fill="rgba(255,255,255,0.4)"/>
                    <path d="M 0 ${cornerThreeY} L 280 ${cornerThreeY} A ${threePointRadius} ${threePointRadius} 0 0 1 280 ${H - cornerThreeY} L 0 ${H - cornerThreeY}" class="court-line" stroke-width="4" fill="none"/>
                    
                    <!-- RIGHT SIDE LINES -->
                    <rect x="${W - paintWidth}" y="${paintTop}" width="${paintWidth}" height="${paintBottom - paintTop}" class="court-line" stroke-width="4" fill="none"/>
                    <circle cx="${W - paintWidth}" cy="500" r="120" class="court-line" stroke-width="4" fill="none"/>
                    <circle cx="${W - basketX}" cy="500" r="${restrictedRadius}" class="court-line" stroke-width="3" fill="none" stroke-dasharray="8,8"/>
                    <circle cx="${W - basketX}" cy="500" r="16" fill="rgba(255,107,107,0.5)" stroke="rgba(255,255,255,0.6)" stroke-width="4"/>
                    <rect x="${W - basketX}" y="496" width="32" height="8" fill="rgba(255,255,255,0.4)"/>
                    <path d="M ${W} ${cornerThreeY} L ${W - 280} ${cornerThreeY} A ${threePointRadius} ${threePointRadius} 0 0 0 ${W - 280} ${H - cornerThreeY} L ${W} ${H - cornerThreeY}" class="court-line" stroke-width="4" fill="none"/>
                    
                    <!-- ============ ZONE LABELS ============ -->
                    <!-- Left side -->
                    ${renderZoneLabel(basketX, 500, 'rim', 28)}
                    ${renderZoneLabel(200, 500, 'paint', 24)}
                    ${renderZoneLabel(140, 30, 'corner3_left', 20)}
                    ${renderZoneLabel(140, 970, 'corner3_left', 20)}
                    ${renderZoneLabel(180, 180, 'wing3_left', 20)}
                    ${renderZoneLabel(180, 820, 'wing3_left', 20)}
                    ${renderZoneLabel(420, 500, 'top3', 24)}
                    ${renderZoneLabel(350, 280, 'mid_elbow', 18)}
                    ${renderZoneLabel(350, 720, 'mid_elbow', 18)}
                    
                    <!-- Right side -->
                    ${renderZoneLabel(W - basketX, 500, 'rim', 28)}
                    ${renderZoneLabel(W - 200, 500, 'paint', 24)}
                    ${renderZoneLabel(W - 140, 30, 'corner3_right', 20)}
                    ${renderZoneLabel(W - 140, 970, 'corner3_right', 20)}
                    ${renderZoneLabel(W - 180, 180, 'wing3_right', 20)}
                    ${renderZoneLabel(W - 180, 820, 'wing3_right', 20)}
                    ${renderZoneLabel(W - 420, 500, 'top3', 24)}
                    ${renderZoneLabel(W - 350, 280, 'mid_elbow', 18)}
                    ${renderZoneLabel(W - 350, 720, 'mid_elbow', 18)}
                    
                    <!-- ============ SHOT MARKERS ============ -->
                    ${filtered.map((shot, i) => {
                        const svgX = shot.x * (W / 100);
                        const svgY = (100 - shot.y) * (H / 100);
                        const markerClass = shot.made ? 'made' : 'missed';
                        
                        return `
                            <circle 
                                class="shot-marker ${markerClass}" 
                                cx="${svgX.toFixed(1)}" 
                                cy="${svgY.toFixed(1)}" 
                                r="10"
                                data-player="${shot.playerName}"
                                data-number="${shot.playerNum}"
                                data-type="${shot.shotType}"
                                data-made="${shot.made}"
                                data-period="${shot.period}"
                                onmouseenter="window.fibaVisualizer.showShotTooltip(event)"
                                onmouseleave="window.fibaVisualizer.hideShotTooltip()"
                            />
                        `;
                    }).join('')}
                </svg>
            `;
            
            return courtSVG;
        }
        
        // Render zone stats cards
        renderZoneStatsCards(shots, team, player, period) {
            const filtered = this.filterShots(shots, team, player, period);
            const zoneStats = this.calculateZoneStats(filtered);
            
            const zoneLabels = {
                rim: { name: '🎯 Rim (Restricted)', type: 'rim', benchmark: 60 },
                paint: { name: '🏀 Paint (Non-Restricted)', type: 'paint', benchmark: 45 },
                mid: { name: '📐 Mid-Range', type: 'mid', benchmark: 40 },
                corner3: { name: '📍 Corner 3', type: '3pt', benchmark: 38 },
                wing3: { name: '🌟 Wing 3', type: '3pt', benchmark: 35 },
                top3: { name: '🔝 Top of Key 3', type: '3pt', benchmark: 35 }
            };
            
            return Object.entries(zoneLabels).map(([zone, label]) => {
                const stats = zoneStats[zone];
                if (!stats || stats.total === 0) return '';
                
                const colorClass = this.getZoneColorClass(stats.pct, label.type);
                
                return `
                    <div class="zone-stat-card">
                        <div class="zone-stat-header">
                            <span class="zone-stat-name">${label.name}</span>
                            <span class="zone-stat-pct ${colorClass}">${stats.pct}%</span>
                        </div>
                        <div class="zone-stat-detail">${stats.made}/${stats.total} shots • Benchmark: ${label.benchmark}%</div>
                        <div class="zone-stat-bar-container">
                            <div class="zone-stat-bar ${colorClass}" style="width: ${Math.min(stats.pct, 100)}%;"></div>
                        </div>
                    </div>
                `;
            }).filter(s => s).join('');
        }
        
        // Render zone bar chart
        renderZoneBarChart(shots, team, player, period) {
            const filtered = this.filterShots(shots, team, player, period);
            const zoneStats = this.calculateZoneStats(filtered);
            
            const maxHeight = 250;
            
            const zoneOrder = [
                { key: 'rim', label: 'RIM', type: 'rim' },
                { key: 'paint', label: 'PAINT', type: 'paint' },
                { key: 'mid', label: 'MID', type: 'mid' },
                { key: 'corner3', label: 'CORNER 3', type: '3pt' },
                { key: 'wing3', label: 'WING 3', type: '3pt' },
                { key: 'top3', label: 'TOP 3', type: '3pt' }
            ];
            
            return zoneOrder.map(zone => {
                const stats = zoneStats[zone.key];
                if (!stats) return '';
                
                const colorClass = this.getZoneColorClass(stats.pct, zone.type);
                const height = stats.total > 0 ? (stats.pct / 100) * maxHeight : 4;
                
                const barColors = {
                    hot: 'linear-gradient(180deg, var(--positive), rgba(0, 255, 136, 0.3))',
                    warm: 'linear-gradient(180deg, var(--accent-cyan), rgba(0, 212, 255, 0.3))',
                    neutral: 'linear-gradient(180deg, var(--text-secondary), rgba(136, 146, 168, 0.3))',
                    cool: 'linear-gradient(180deg, var(--warning), rgba(255, 165, 0, 0.3))',
                    cold: 'linear-gradient(180deg, var(--negative), rgba(255, 107, 107, 0.3))'
                };
                
                return `
                    <div class="shot-bar-item">
                        <div class="shot-bar ${colorClass}" 
                             style="height: ${height}px; background: ${barColors[colorClass]};"
                             data-pct="${stats.pct}%">
                        </div>
                        <div class="shot-bar-label">${zone.label}</div>
                        <div class="shot-bar-count">${stats.made}/${stats.total}</div>
                    </div>
                `;
            }).join('');
        }
        
        // Show shot tooltip - with boundary checking to stay on screen
        showShotTooltip(event) {
            const tooltip = document.getElementById('shot-tooltip');
            if (!tooltip) return;
            
            const element = event.target;
            const player = element.getAttribute('data-player');
            const number = element.getAttribute('data-number');
            const type = element.getAttribute('data-type');
            const made = element.getAttribute('data-made') === 'true';
            const period = element.getAttribute('data-period');
            
            tooltip.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 4px; color: ${made ? 'var(--positive)' : 'var(--negative)'};">
                    ${made ? '✓ MADE' : '✗ MISSED'}
                </div>
                <div>#${number} ${player}</div>
                <div style="color: var(--text-muted); font-size: 11px;">${type}</div>
                <div style="color: var(--text-muted); font-size: 10px;">Q${period}</div>
            `;
            
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Get tooltip dimensions (make visible first to measure)
            tooltip.style.visibility = 'hidden';
            tooltip.style.display = 'block';
            const tooltipWidth = tooltip.offsetWidth;
            const tooltipHeight = tooltip.offsetHeight;
            
            // Calculate position with boundary checking
            let left = event.clientX;
            let top = event.clientY - tooltipHeight - 15; // 15px above cursor
            
            // Check right boundary
            if (left + tooltipWidth / 2 > viewportWidth - 10) {
                left = viewportWidth - tooltipWidth / 2 - 10;
            }
            // Check left boundary
            if (left - tooltipWidth / 2 < 10) {
                left = tooltipWidth / 2 + 10;
            }
            // Check top boundary - if tooltip would go above viewport, show below cursor
            if (top < 10) {
                top = event.clientY + 20; // Show below cursor instead
            }
            // Check bottom boundary
            if (top + tooltipHeight > viewportHeight - 10) {
                top = viewportHeight - tooltipHeight - 10;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.style.visibility = 'visible';
            tooltip.classList.add('active');
        }
        
        // Hide shot tooltip
        hideShotTooltip() {
            const tooltip = document.getElementById('shot-tooltip');
            if (tooltip) tooltip.classList.remove('active');
        }
        
        // ========================================================================
        // SEASON COMPARISON TAB
        // ========================================================================
        
        renderSeasonCompareTab(teamsData) {
            const teamNames = Object.keys(teamsData);
            const homeTeam = teamNames[0];
            const awayTeam = teamNames[1];
            
            return `
                <div class="stat-card glass-card full-width">
                    <div class="card-header">
                        <span class="card-title">📂 Season Stats Comparison</span>
                    </div>
                    
                    <div class="season-upload-section" id="season-upload-section">
                        <p style="color: var(--text-secondary); margin-bottom: 16px;">
                            Upload a CSV with season stats to compare this game's performance against season averages.
                            Required columns: Team, Player_Name, Games, PTS, PPG, FGM, FGA, FG%, 3PM, 3PA, 3P%, FTM, FTA, FT%, OREB, TOV, POSS
                        </p>
                        <div class="upload-box" style="padding: 20px; border: 2px dashed var(--border-accent); border-radius: var(--radius-md); text-align: center; cursor: pointer;">
                            <input type="file" id="season-csv-file" accept=".csv" style="display: none;">
                            <label for="season-csv-file" style="cursor: pointer; color: var(--accent-cyan);">
                                📁 Click to upload season_stats.csv
                            </label>
                        </div>
                    </div>
                    
                    <div id="season-compare-results" style="display: none;">
                        <!-- Results will be rendered here -->
                    </div>
                </div>
            `;
        }
        
        parseSeasonCSV(csvText) {
            // Normalize line endings and handle Windows format
            const normalizedText = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            const lines = normalizedText.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            const players = [];
            
            console.log('CSV Headers:', headers);
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue; // Skip empty lines
                
                const values = lines[i].split(',');
                const player = {};
                headers.forEach((header, idx) => {
                    const val = values[idx]?.trim() || '';
                    player[header] = isNaN(parseFloat(val)) ? val : parseFloat(val);
                });
                players.push(player);
            }
            
            console.log(`Parsed ${players.length} players from CSV`);
            console.log('Sample player:', players[0]);
            
            return players;
        }
        
        calculateSeasonComparison(teamsData, seasonData) {
            const teamNames = Object.keys(teamsData);
            const homeTeam = teamNames[0];
            const awayTeam = teamNames[1];
            const results = { home: [], away: [] };
            
            console.log('Season Compare - Game Teams:', homeTeam, awayTeam);
            console.log('Season Compare - CSV Teams:', [...new Set(seasonData.map(p => p.Team))]);
            
            // Helper function to normalize names for comparison
            const normalizeName = (name) => {
                if (!name) return '';
                return name.toLowerCase()
                    .replace(/[^a-z\s]/g, '') // Remove non-letters except spaces
                    .replace(/\s+/g, ' ')     // Normalize spaces
                    .trim();
            };
            
            // Helper function to check if team names match
            const teamsMatch = (gameTeam, csvTeam) => {
                if (!gameTeam || !csvTeam) return false;
                const gt = gameTeam.toLowerCase();
                const ct = csvTeam.toLowerCase();
                
                // Direct match
                if (gt === ct) return true;
                
                // Check if one contains the other
                if (gt.includes(ct) || ct.includes(gt)) return true;
                
                // Check significant words (ignore short words like "B.", "FC", etc.)
                const gameWords = gt.split(/[\s.]+/).filter(w => w.length > 2);
                const csvWords = ct.split(/[\s.]+/).filter(w => w.length > 2);
                
                // Count matching words
                const matchingWords = gameWords.filter(gw => 
                    csvWords.some(cw => gw.includes(cw) || cw.includes(gw))
                ).length;
                
                // Match if at least 2 significant words match, or 1 if team has few words
                return matchingWords >= 2 || (matchingWords >= 1 && Math.min(gameWords.length, csvWords.length) <= 2);
            };
            
            // Helper function to check if player names match
            const namesMatch = (gameName, csvName, csvVariations) => {
                if (!gameName) return false;
                const gn = normalizeName(gameName);
                
                // Check main name
                if (csvName) {
                    const cn = normalizeName(csvName);
                    if (gn === cn) return true;
                    // Check if last names match (most reliable)
                    const gameLastName = gn.split(' ').pop();
                    const csvLastName = cn.split(' ').pop();
                    if (gameLastName.length > 2 && gameLastName === csvLastName) {
                        // Also check first name starts with same letter or first name matches
                        const gameFirst = gn.split(' ')[0];
                        const csvFirst = cn.split(' ')[0];
                        if (gameFirst[0] === csvFirst[0] || gameFirst === csvFirst) return true;
                    }
                    // Check if one contains the other
                    if (gn.includes(cn) || cn.includes(gn)) return true;
                }
                
                // Check variations
                if (csvVariations) {
                    const variations = csvVariations.split(';').map(v => normalizeName(v.trim()));
                    for (const v of variations) {
                        if (v && (gn === v || gn.includes(v) || v.includes(gn))) return true;
                    }
                }
                
                return false;
            };
            
            // Four Factor weights (from Dean Oliver research, normalized)
            const FOUR_FACTOR_WEIGHTS = {
                efg: 0.40,      // eFG% has highest impact
                tovPct: 0.25,   // TO% 
                orebPct: 0.20,  // OREB%
                ftRate: 0.15    // FT Rate
            };
            
            // Process each team
            [homeTeam, awayTeam].forEach((teamName, idx) => {
                const teamData = teamsData[teamName];
                const teamKey = idx === 0 ? 'home' : 'away';
                
                console.log(`Processing team: ${teamName}, Players:`, teamData.players?.map(p => p.name));
                
                teamData.players.forEach(gamePlayer => {
                    // Find matching season player
                    const seasonPlayer = seasonData.find(sp => {
                        const teamMatch = teamsMatch(teamName, sp.Team);
                        const nameMatch = namesMatch(gamePlayer.name, sp.Player_Name, sp.Name_Variations);
                        return teamMatch && nameMatch;
                    });
                    
                    if (!seasonPlayer) {
                        console.log(`No match for: ${gamePlayer.name} (${teamName})`);
                        return;
                    }
                    
                    if (seasonPlayer.Games < 2) {
                        console.log(`Skipping ${gamePlayer.name} - only ${seasonPlayer.Games} games`);
                        return;
                    }
                    
                    console.log(`Matched: ${gamePlayer.name} -> ${seasonPlayer.Player_Name}`);
                    
                    // Calculate game stats (note: field names from parsePlayerRow)
                    const gameMins = parseFloat(gamePlayer.minutes) || 0;
                    if (gameMins < 5) return; // Skip players with < 5 mins
                    
                    const gamePts = parseFloat(gamePlayer.points) || 0;
                    const gameFgm = parseFloat(gamePlayer.fgm) || 0;
                    const gameFga = parseFloat(gamePlayer.fga) || 0;
                    const gameFg3m = parseFloat(gamePlayer.fg3m) || 0;
                    const gameFg3a = parseFloat(gamePlayer.fg3a) || 0;
                    const gameFtm = parseFloat(gamePlayer.ftm) || 0;
                    const gameFta = parseFloat(gamePlayer.fta) || 0;
                    const gameOreb = parseFloat(gamePlayer.oreb) || 0;
                    const gameTov = parseFloat(gamePlayer.tov) || 0;
                    
                    // Calculate game rates
                    const gameEfg = gameFga > 0 ? ((gameFgm + 0.5 * gameFg3m) / gameFga * 100) : 0;
                    const gameTpc = gameFg3a > 0 ? (gameFg3m / gameFg3a * 100) : 0;
                    const gameFtPct = gameFta > 0 ? (gameFtm / gameFta * 100) : 0;
                    const gameFtRate = gameFga > 0 ? (gameFta / gameFga * 100) : 0;
                    const gamePoss = 0.96 * (gameFga + gameTov + 0.44 * gameFta - gameOreb);
                    const gameTovPct = gamePoss > 0 ? (gameTov / gamePoss * 100) : 0;
                    const gameTs = gameFga > 0 ? (gamePts / (2 * (gameFga + 0.44 * gameFta)) * 100) : 0;
                    
                    // Season per-game averages
                    const seasonGames = seasonPlayer.Games || 1;
                    const seasonPpg = seasonPlayer.PPG || (seasonPlayer.PTS / seasonGames);
                    const seasonFgPct = seasonPlayer['FG%'] || 0;
                    const seasonTpc = seasonPlayer['3P%'] || 0;
                    const seasonFtPct = seasonPlayer['FT%'] || 0;
                    const seasonTovPerGame = (seasonPlayer.TOV || 0) / seasonGames;
                    const seasonOrebPerGame = (seasonPlayer.OREB || 0) / seasonGames;
                    const seasonFgaPerGame = (seasonPlayer.FGA || 0) / seasonGames;
                    const seasonFtaPerGame = (seasonPlayer.FTA || 0) / seasonGames;
                    const seasonFtmPerGame = (seasonPlayer.FTM || 0) / seasonGames;
                    const seasonFgmPerGame = (seasonPlayer.FGM || 0) / seasonGames;
                    const season3pmPerGame = (seasonPlayer['3PM'] || 0) / seasonGames;
                    
                    // Calculate season eFG%
                    const seasonEfg = seasonPlayer.FGA > 0 ? 
                        ((seasonPlayer.FGM + 0.5 * seasonPlayer['3PM']) / seasonPlayer.FGA * 100) : 0;
                    
                    // Calculate season FT Rate
                    const seasonFtRate = seasonPlayer.FGA > 0 ? 
                        ((seasonPlayer.FTA || 0) / seasonPlayer.FGA * 100) : 0;
                    
                    // Calculate season TO%
                    const seasonPoss = seasonPlayer.POSS || (0.96 * (seasonPlayer.FGA + seasonPlayer.TOV + 0.44 * seasonPlayer.FTA - seasonPlayer.OREB));
                    const seasonTovPct = seasonPoss > 0 ? (seasonPlayer.TOV / seasonPoss * 100) : 0;
                    
                    // Calculate season TS%
                    const seasonTs = seasonPlayer.FGA > 0 ? 
                        (seasonPlayer.PTS / (2 * (seasonPlayer.FGA + 0.44 * seasonPlayer.FTA)) * 100) : 0;
                    
                    // Calculate differences
                    const ptsDiff = gamePts - seasonPpg;
                    const efgDiff = gameEfg - seasonEfg;
                    const tpcDiff = gameTpc - seasonTpc;
                    const tovDiff = gameTov - seasonTovPerGame; // Raw TO count difference
                    const orebDiff = gameOreb - seasonOrebPerGame;
                    const ftRateDiff = gameFtRate - seasonFtRate;
                    const tsDiff = gameTs - seasonTs;
                    
                    // ============================================================
                    // EPA Model - Aligned with Margin Tab calculations
                    // Uses same coefficients as calculateBattleMetrics()
                    // ============================================================
                    
                    // TO Impact: Each extra turnover costs ~1.1 points
                    // Negative tovDiff (fewer TOs than season avg) = positive EPA
                    const epaFromTov = -tovDiff * 1.1;
                    
                    // OREB Impact: Each extra OREB worth ~1.1 points
                    const epaFromOreb = orebDiff * 1.1;
                    
                    // eFG% Impact: Uses same 1.77 coefficient as margin tab
                    // Scale by player's FGA (their share of possessions)
                    // Formula: efgDiff * 1.77 * (playerPoss / 100)
                    // Approximate player possessions from FGA
                    const playerPoss = gameFga * 1.2; // ~1.2 possessions per FGA
                    const epaFromEfg = efgDiff * 1.77 * (playerPoss / 100);
                    
                    // FT Rate Impact: Uses same 0.25 coefficient as margin tab
                    const epaFromFtRate = ftRateDiff * 0.25 * (playerPoss / 100);
                    
                    // EPA Battle (possession value: TO + OREB)
                    const epaBattle = epaFromTov + epaFromOreb;
                    
                    // Scoring Battle (efficiency: eFG% + FT Rate)
                    const scoringBattle = epaFromEfg + epaFromFtRate;
                    
                    // Total EPA - all components
                    const totalEpa = epaBattle + scoringBattle;
                    
                    // "Typical Points Added" - raw scoring difference
                    const expectedPts = seasonPpg;
                    const typicalVariance = Math.sqrt(seasonPpg * 0.5 + 5);
                    const zScore = typicalVariance > 0 ? ptsDiff / typicalVariance : 0;
                    const typicalPtsAdded = ptsDiff;
                    
                    // Outlier score - how unusual was this performance?
                    const outlierScore = Math.abs(zScore) + Math.abs(efgDiff / 10) + Math.abs(tsDiff / 10) + Math.abs(totalEpa / 3);
                    
                    results[teamKey].push({
                        name: gamePlayer.name,
                        number: gamePlayer.number,
                        mins: gameMins,
                        // Game stats
                        gamePts,
                        gameFga,
                        gameEfg,
                        gameTpc,
                        gameTov,
                        gameOreb,
                        gameFtRate,
                        gameTs,
                        // Season averages
                        seasonPpg,
                        seasonEfg,
                        seasonTpc,
                        seasonTovPerGame,
                        seasonOrebPerGame,
                        seasonFtRate,
                        seasonTs,
                        // Differences
                        ptsDiff,
                        efgDiff,
                        tpcDiff,
                        tovDiff,
                        orebDiff,
                        ftRateDiff,
                        tsDiff,
                        // EPA breakdown
                        epaFromTov,
                        epaFromOreb,
                        epaFromEfg,
                        epaFromFtRate,
                        epaBattle,
                        scoringBattle,
                        totalEpa,
                        // Outlier metrics
                        zScore,
                        typicalPtsAdded,
                        outlierScore
                    });
                });
            });
            
            // Sort by outlier score
            results.home.sort((a, b) => b.outlierScore - a.outlierScore);
            results.away.sort((a, b) => b.outlierScore - a.outlierScore);
            
            return results;
        }
        
        renderSeasonCompareResults(results, homeTeam, awayTeam) {
            const formatDiff = (val, decimals = 1, lowerBetter = false) => {
                const sign = val >= 0 ? '+' : '';
                const colorClass = lowerBetter ? (val <= 0 ? 'positive' : 'negative') : (val >= 0 ? 'positive' : 'negative');
                return `<span class="${colorClass}">${sign}${val.toFixed(decimals)}</span>`;
            };
            
            const renderTeamResults = (teamResults, teamName, teamClass, debugInfo) => {
                if (teamResults.length === 0) {
                    const csvTeamsStr = debugInfo?.csvTeams?.join(', ') || 'Unknown';
                    const gamePlayers = teamClass === 'home' ? debugInfo?.gamePlayers?.home : debugInfo?.gamePlayers?.away;
                    const gamePlayersStr = gamePlayers?.slice(0, 5).join(', ') + (gamePlayers?.length > 5 ? '...' : '') || 'Unknown';
                    
                    return `
                        <div style="color: var(--text-muted); padding: 16px; background: var(--bg-elevated); border-radius: var(--radius-md);">
                            <p style="margin-bottom: 12px;">⚠️ No matching players found for <strong>${teamName}</strong></p>
                            <div style="font-size: 11px; color: var(--text-secondary);">
                                <p><strong>Debug Info:</strong></p>
                                <p>Game Team: "${teamName}"</p>
                                <p>CSV Teams: ${csvTeamsStr}</p>
                                <p>Game Players: ${gamePlayersStr}</p>
                                <p style="margin-top: 8px; color: var(--accent-cyan);">Check browser console (F12) for detailed matching logs</p>
                            </div>
                        </div>
                    `;
                }
                
                // Find biggest outliers
                const topOutlier = teamResults[0];
                const biggestScorer = [...teamResults].sort((a, b) => b.ptsDiff - a.ptsDiff)[0];
                const biggestEpaContrib = [...teamResults].sort((a, b) => b.totalEpa - a.totalEpa)[0];
                
                return `
                    <div class="season-team-results">
                        <h4 style="color: var(--team-${teamClass}); margin-bottom: 16px; display: flex; align-items: center; gap: 8px;">
                            <span class="team-indicator ${teamClass}"></span>${teamName}
                        </h4>
                        
                        <!-- Key Insights -->
                        <div class="season-insights" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 12px; margin-bottom: 20px;">
                            <div class="insight-card glass-card" style="padding: 12px;">
                                <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">🎯 Biggest Outlier</div>
                                <div style="font-size: 14px; font-weight: 600;">${topOutlier.name}</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">
                                    ${topOutlier.gamePts} pts (${formatDiff(topOutlier.ptsDiff)}) | TS: ${formatDiff(topOutlier.tsDiff)}%
                                </div>
                            </div>
                            <div class="insight-card glass-card" style="padding: 12px;">
                                <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">📈 Above Expected Scoring</div>
                                <div style="font-size: 14px; font-weight: 600;">${biggestScorer.name}</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">
                                    ${formatDiff(biggestScorer.ptsDiff)} pts vs ${biggestScorer.seasonPpg.toFixed(1)} PPG avg
                                </div>
                            </div>
                            <div class="insight-card glass-card" style="padding: 12px;">
                                <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">⚡ Highest EPA</div>
                                <div style="font-size: 14px; font-weight: 600;">${biggestEpaContrib.name}</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">
                                    ${formatDiff(biggestEpaContrib.totalEpa)} expected points
                                </div>
                            </div>
                        </div>
                        
                        <!-- Detailed Table -->
                        <div class="table-container" style="overflow-x: auto;">
                            <table class="stats-table" style="width: 100%; font-size: 11px;">
                                <thead>
                                    <tr>
                                        <th style="text-align: left;">Player</th>
                                        <th>MIN</th>
                                        <th>PTS</th>
                                        <th>vs Avg</th>
                                        <th>eFG%</th>
                                        <th>Δ eFG</th>
                                        <th>TO</th>
                                        <th>Δ TO</th>
                                        <th>OREB</th>
                                        <th>Δ OREB</th>
                                        <th>TS%</th>
                                        <th>Δ TS%</th>
                                        <th>EPA</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${teamResults.map(p => `
                                        <tr>
                                            <td style="text-align: left; font-weight: 500;">#${p.number} ${p.name}</td>
                                            <td>${p.mins.toFixed(0)}</td>
                                            <td><strong>${p.gamePts}</strong></td>
                                            <td>${formatDiff(p.ptsDiff)}</td>
                                            <td>${p.gameEfg.toFixed(1)}%</td>
                                            <td>${formatDiff(p.efgDiff)}</td>
                                            <td>${p.gameTov}</td>
                                            <td>${formatDiff(p.tovDiff, 1, true)}</td>
                                            <td>${p.gameOreb}</td>
                                            <td>${formatDiff(p.orebDiff)}</td>
                                            <td>${p.gameTs.toFixed(1)}%</td>
                                            <td>${formatDiff(p.tsDiff)}</td>
                                            <td><strong>${formatDiff(p.totalEpa)}</strong></td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- NEW: EPA Component Bar Chart -->
                        <div style="margin-top: 24px;">
                            <h5 style="color: var(--text-secondary); margin-bottom: 16px; display: flex; align-items: center; gap: 12px;">
                                EPA Contribution by Component
                                <span style="font-size: 10px; color: var(--text-muted); font-weight: 400;">
                                    (TO Battle + OREB Battle = EPA Battle | eFG% + FT Rate = Scoring Battle)
                                </span>
                            </h5>
                            
                            <!-- Legend -->
                            <div style="display: flex; gap: 20px; margin-bottom: 16px; font-size: 11px; flex-wrap: wrap; padding: 10px 12px; background: var(--bg-glass); border: 1px solid var(--border-subtle); border-radius: var(--radius-sm);">
                                <span style="display: flex; align-items: center; gap: 4px;">
                                    <span style="width: 14px; height: 14px; background: var(--accent-coral); border-radius: 2px; border: 1px solid rgba(255,107,107,0.5);"></span>
                                    TO Impact
                                </span>
                                <span style="display: flex; align-items: center; gap: 4px;">
                                    <span style="width: 14px; height: 14px; background: var(--accent-purple); border-radius: 2px; border: 1px solid rgba(168,85,247,0.5);"></span>
                                    OREB Impact
                                </span>
                                <span style="display: flex; align-items: center; gap: 4px;">
                                    <span style="width: 14px; height: 14px; background: var(--accent-cyan); border-radius: 2px; border: 1px solid rgba(0,212,255,0.5);"></span>
                                    eFG% Impact
                                </span>
                                <span style="display: flex; align-items: center; gap: 4px;">
                                    <span style="width: 14px; height: 14px; background: var(--accent-gold); border-radius: 2px; border: 1px solid rgba(255,208,0,0.5);"></span>
                                    FT Rate Impact
                                </span>
                            </div>
                            
                            <!-- Multi-bar chart for each player -->
                            <div class="epa-multi-bars">
                                ${teamResults.slice(0, 8).map(p => {
                                    // Calculate bar widths (max 120px for |4| points)
                                    const maxBarVal = 4;
                                    const getBarWidth = (val) => Math.min(Math.abs(val) / maxBarVal * 120, 120);
                                    const getBarStyle = (val, color, borderColor) => {
                                        const width = getBarWidth(val);
                                        return `width: ${width}px; background: ${color}; border: 1px solid ${borderColor}; box-shadow: 0 1px 3px rgba(0,0,0,0.2);`;
                                    };
                                    
                                    return `
                                        <div class="epa-player-chart">
                                            <span style="font-size: 12px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${p.name}</span>
                                            
                                            <div style="display: flex; flex-direction: column; gap: 6px;">
                                                <!-- TO Impact -->
                                                <div style="display: flex; align-items: center; gap: 8px; height: 18px;">
                                                    <span style="font-size: 9px; color: var(--text-muted); width: 50px;">TO</span>
                                                    <div style="flex: 1; display: flex; align-items: center; position: relative; height: 16px;">
                                                        <div style="position: absolute; left: 50%; width: 1px; height: 100%; background: var(--border-accent);"></div>
                                                        ${p.epaFromTov >= 0 ? 
                                                            `<div class="epa-bar" style="margin-left: 50%; ${getBarStyle(p.epaFromTov, 'var(--positive)', 'rgba(0,255,136,0.5)')}"></div>` :
                                                            `<div class="epa-bar" style="margin-left: calc(50% - ${getBarWidth(p.epaFromTov)}px); ${getBarStyle(p.epaFromTov, 'var(--accent-coral)', 'rgba(255,107,107,0.5)')}"></div>`
                                                        }
                                                    </div>
                                                    <span style="font-size: 10px; min-width: 45px; text-align: right; font-family: 'Space Mono', monospace; color: ${p.epaFromTov >= 0 ? 'var(--positive)' : 'var(--negative)'};">${p.epaFromTov >= 0 ? '+' : ''}${p.epaFromTov.toFixed(1)}</span>
                                                </div>
                                                
                                                <!-- OREB Impact -->
                                                <div style="display: flex; align-items: center; gap: 8px; height: 18px;">
                                                    <span style="font-size: 9px; color: var(--text-muted); width: 50px;">OREB</span>
                                                    <div style="flex: 1; display: flex; align-items: center; position: relative; height: 16px;">
                                                        <div style="position: absolute; left: 50%; width: 1px; height: 100%; background: var(--border-accent);"></div>
                                                        ${p.epaFromOreb >= 0 ? 
                                                            `<div class="epa-bar" style="margin-left: 50%; ${getBarStyle(p.epaFromOreb, 'var(--accent-purple)', 'rgba(168,85,247,0.5)')}"></div>` :
                                                            `<div class="epa-bar" style="margin-left: calc(50% - ${getBarWidth(p.epaFromOreb)}px); ${getBarStyle(p.epaFromOreb, 'var(--accent-magenta)', 'rgba(255,0,170,0.5)')}"></div>`
                                                        }
                                                    </div>
                                                    <span style="font-size: 10px; min-width: 45px; text-align: right; font-family: 'Space Mono', monospace; color: ${p.epaFromOreb >= 0 ? 'var(--positive)' : 'var(--negative)'};">${p.epaFromOreb >= 0 ? '+' : ''}${p.epaFromOreb.toFixed(1)}</span>
                                                </div>
                                                
                                                <!-- eFG% Impact -->
                                                <div style="display: flex; align-items: center; gap: 8px; height: 18px;">
                                                    <span style="font-size: 9px; color: var(--text-muted); width: 50px;">eFG%</span>
                                                    <div style="flex: 1; display: flex; align-items: center; position: relative; height: 16px;">
                                                        <div style="position: absolute; left: 50%; width: 1px; height: 100%; background: var(--border-accent);"></div>
                                                        ${p.epaFromEfg >= 0 ? 
                                                            `<div class="epa-bar" style="margin-left: 50%; ${getBarStyle(p.epaFromEfg, 'var(--accent-cyan)', 'rgba(0,212,255,0.5)')}"></div>` :
                                                            `<div class="epa-bar" style="margin-left: calc(50% - ${getBarWidth(p.epaFromEfg)}px); ${getBarStyle(p.epaFromEfg, 'var(--accent-coral)', 'rgba(255,107,107,0.5)')}"></div>`
                                                        }
                                                    </div>
                                                    <span style="font-size: 10px; min-width: 45px; text-align: right; font-family: 'Space Mono', monospace; color: ${p.epaFromEfg >= 0 ? 'var(--positive)' : 'var(--negative)'};">${p.epaFromEfg >= 0 ? '+' : ''}${p.epaFromEfg.toFixed(1)}</span>
                                                </div>
                                                
                                                <!-- FT Rate Impact -->
                                                <div style="display: flex; align-items: center; gap: 8px; height: 18px;">
                                                    <span style="font-size: 9px; color: var(--text-muted); width: 50px;">FT Rate</span>
                                                    <div style="flex: 1; display: flex; align-items: center; position: relative; height: 16px;">
                                                        <div style="position: absolute; left: 50%; width: 1px; height: 100%; background: var(--border-accent);"></div>
                                                        ${p.epaFromFtRate >= 0 ? 
                                                            `<div class="epa-bar" style="margin-left: 50%; ${getBarStyle(p.epaFromFtRate, 'var(--accent-gold)', 'rgba(255,208,0,0.5)')}"></div>` :
                                                            `<div class="epa-bar" style="margin-left: calc(50% - ${getBarWidth(p.epaFromFtRate)}px); ${getBarStyle(p.epaFromFtRate, 'var(--negative)', 'rgba(255,107,107,0.5)')}"></div>`
                                                        }
                                                    </div>
                                                    <span style="font-size: 10px; min-width: 45px; text-align: right; font-family: 'Space Mono', monospace; color: ${p.epaFromFtRate >= 0 ? 'var(--positive)' : 'var(--negative)'};">${p.epaFromFtRate >= 0 ? '+' : ''}${p.epaFromFtRate.toFixed(1)}</span>
                                                </div>
                                            </div>
                                            
                                            <div style="text-align: right;">
                                                <div style="font-size: 18px; font-weight: 700; font-family: 'Space Grotesk', sans-serif; color: ${p.totalEpa >= 0 ? 'var(--positive)' : 'var(--negative)'};">
                                                    ${p.totalEpa >= 0 ? '+' : ''}${p.totalEpa.toFixed(1)}
                                                </div>
                                                <div style="font-size: 9px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Total EPA</div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            
                            <!-- EPA Battle vs Scoring Battle Summary -->
                            <div style="margin-top: 20px; padding: 12px; background: var(--bg-glass); border-radius: var(--radius-sm);">
                                <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 8px;">Team Totals vs Season Average</div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; text-align: center;">
                                    <div>
                                        <div style="font-size: 10px; color: var(--accent-coral);">EPA Battle (TO + OREB)</div>
                                        <div style="font-size: 18px; font-weight: 700; color: ${teamResults.reduce((s,p) => s + p.epaBattle, 0) >= 0 ? 'var(--positive)' : 'var(--negative)'};">
                                            ${teamResults.reduce((s,p) => s + p.epaBattle, 0) >= 0 ? '+' : ''}${teamResults.reduce((s,p) => s + p.epaBattle, 0).toFixed(1)}
                                        </div>
                                    </div>
                                    <div>
                                        <div style="font-size: 10px; color: var(--accent-cyan);">Scoring Battle (eFG% + FT)</div>
                                        <div style="font-size: 18px; font-weight: 700; color: ${teamResults.reduce((s,p) => s + p.scoringBattle, 0) >= 0 ? 'var(--positive)' : 'var(--negative)'};">
                                            ${teamResults.reduce((s,p) => s + p.scoringBattle, 0) >= 0 ? '+' : ''}${teamResults.reduce((s,p) => s + p.scoringBattle, 0).toFixed(1)}
                                        </div>
                                    </div>
                                    <div>
                                        <div style="font-size: 10px; color: var(--text-muted);">Total EPA</div>
                                        <div style="font-size: 18px; font-weight: 700; color: ${teamResults.reduce((s,p) => s + p.totalEpa, 0) >= 0 ? 'var(--positive)' : 'var(--negative)'};">
                                            ${teamResults.reduce((s,p) => s + p.totalEpa, 0) >= 0 ? '+' : ''}${teamResults.reduce((s,p) => s + p.totalEpa, 0).toFixed(1)}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            };
            
            // Calculate team totals
            const homeTotalEpa = results.home.reduce((sum, p) => sum + p.totalEpa, 0);
            const awayTotalEpa = results.away.reduce((sum, p) => sum + p.totalEpa, 0);
            const homeTotalPtsDiff = results.home.reduce((sum, p) => sum + p.ptsDiff, 0);
            const awayTotalPtsDiff = results.away.reduce((sum, p) => sum + p.ptsDiff, 0);
            
            return `
                <div class="season-summary" style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-bottom: 24px; padding: 16px; background: var(--bg-elevated); border-radius: var(--radius-md);">
                    <div style="text-align: center;">
                        <div style="font-size: 11px; color: var(--text-muted);">Team EPA vs Season</div>
                        <div style="font-size: 24px; font-weight: 700; color: var(--team-home);">${homeTotalEpa >= 0 ? '+' : ''}${homeTotalEpa.toFixed(1)}</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">${homeTeam}</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 11px; color: var(--text-muted);">Team EPA vs Season</div>
                        <div style="font-size: 24px; font-weight: 700; color: var(--team-away);">${awayTotalEpa >= 0 ? '+' : ''}${awayTotalEpa.toFixed(1)}</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">${awayTeam}</div>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                    ${renderTeamResults(results.home, homeTeam, 'home', results.debugInfo)}
                    ${renderTeamResults(results.away, awayTeam, 'away', results.debugInfo)}
                </div>
            `;
        }
    }

    // Initialize
    const visualizer = new FIBAGameVisualizer();
    window.fibaVisualizer = visualizer;
    </script>
    
    <!-- ═══════════════════════════════════════════════════════════════════════════
         ADDITIONAL PROTECTION LAYER - INTEGRITY VERIFICATION
         ═══════════════════════════════════════════════════════════════════════════ -->
    <script>
    (function(){
        'use strict';
        const _χ={v:'3.1.0',k:Math.random().toString(36),t:Date.now()};
        const _validateIntegrity=()=>{
            const ov=document.getElementById('_gvAuthOverlay');
            const cfg=typeof _GV_CONFIG!=='undefined';
            const bypass=window._gv_bypass||window._gv_unlock||window.UNLOCKED||window._SKIP_AUTH;
            if(bypass){document.body.innerHTML='<div style="position:fixed;inset:0;background:#0a0b0f;display:flex;align-items:center;justify-content:center;color:#ff6b6b;font-family:sans-serif;z-index:999999;"><h1>Access Denied</h1></div>';return false;}
            if(!cfg){console.error('Config missing');return false;}
            return true;
        };
        const _ρ=()=>{
            const funcs=['FIBAGameVisualizer','fibaVisualizer'];
            funcs.forEach(f=>{
                if(window[f]){
                    const orig=window[f];
                    Object.defineProperty(window,f,{
                        get:()=>{if(!_validateIntegrity())return undefined;return orig;},
                        configurable:false
                    });
                }
            });
        };
        setTimeout(_ρ,100);
        setInterval(()=>{
            if(!_validateIntegrity()){
                try{localStorage.clear();sessionStorage.clear();}catch(e){}
            }
        },30000);
        const _detectDebug=()=>{
            const el=document.createElement('div');
            Object.defineProperty(el,'id',{get:()=>{console.warn('Debug detected');}});
        };
        setInterval(_detectDebug,5000);
        window.addEventListener('beforeunload',()=>{_χ.t=0;});
        console.log('%c⚠️ Protected Application','font-size:20px;color:#ff6b6b;font-weight:bold;');
        console.log('%cThis application is protected. Unauthorized access attempts are logged.','font-size:12px;color:#8892a8;');
    })();
    </script>
</body>
</html>