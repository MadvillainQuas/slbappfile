<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
    <meta name="theme-color" content="#0f172a" media="(prefers-color-scheme: dark)">
    <meta name="theme-color" content="#f5f5f7" media="(prefers-color-scheme: light)">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <!-- PC Performance Optimizations -->
    <meta name="renderer" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="x-dns-prefetch-control" content="on">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://unpkg.com">
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- PC-specific meta for Windows -->
    <meta name="application-name" content="Basketball Lineup Analyzer">
    <meta name="msapplication-TileColor" content="#0f172a">
    <meta name="msapplication-config" content="none">
    <title>Basketball Lineup Analyzer V5.0.0 - Dominance Analysis + Advanced Games View</title>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <style>
        /* ═══════════════════════════════════════════════════════════════════════════
           THEME VARIABLES - For cross-app theming from Tauri parent
           ═══════════════════════════════════════════════════════════════════════════ */
        :root {
            --theme-primary: #60a5fa;
            --theme-primary-rgb: 96, 165, 250;
            --theme-accent: #a78bfa;
            --theme-accent-rgb: 167, 139, 250;
            --theme-bg: #0f172a;
            --theme-bg-secondary: #1e293b;

            /* Default performance colors (updated dynamically by theme) */
            --perf-excellent: #22c55e;
            --perf-excellent-rgb: 34, 197, 94;
            --perf-good: #84cc16;
            --perf-good-rgb: 132, 204, 22;
            --perf-average: #eab308;
            --perf-average-rgb: 234, 179, 8;
            --perf-below: #f97316;
            --perf-below-rgb: 249, 115, 22;
            --perf-poor: #ef4444;
            --perf-poor-rgb: 239, 68, 68;

            /* ═══ ELEVATION SYSTEM (Material Design inspired) ═══ */
            --elevation-0: none;
            --elevation-1: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            --elevation-2: 0 3px 6px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12);
            --elevation-3: 0 10px 20px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.10);
            --elevation-4: 0 15px 25px rgba(0,0,0,0.15), 0 5px 10px rgba(0,0,0,0.05);
            --elevation-5: 0 20px 40px rgba(0,0,0,0.2);
            --elevation-glow-primary: 0 0 20px rgba(var(--theme-primary-rgb), 0.3);
            --elevation-glow-accent: 0 0 20px rgba(var(--theme-accent-rgb), 0.3);

            /* ═══ TYPOGRAPHY SCALE ═══ */
            --font-display: 'Space Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-body: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-mono: 'Space Mono', 'SF Mono', Consolas, monospace;
            --text-xs: 0.6875rem;    /* 11px */
            --text-sm: 0.8125rem;    /* 13px */
            --text-base: 0.875rem;   /* 14px */
            --text-md: 1rem;         /* 16px */
            --text-lg: 1.125rem;     /* 18px */
            --text-xl: 1.25rem;      /* 20px */
            --text-2xl: 1.5rem;      /* 24px */
            --text-3xl: 1.875rem;    /* 30px */
            --text-4xl: 2.25rem;     /* 36px */
            --line-height-tight: 1.25;
            --line-height-normal: 1.5;
            --line-height-relaxed: 1.625;
            --letter-spacing-tight: -0.025em;
            --letter-spacing-normal: 0;
            --letter-spacing-wide: 0.025em;
            --letter-spacing-wider: 0.05em;
            --letter-spacing-widest: 0.1em;

            /* ═══ SPACING SCALE (8px base) ═══ */
            --space-0: 0;
            --space-1: 0.25rem;   /* 4px */
            --space-2: 0.5rem;    /* 8px */
            --space-3: 0.75rem;   /* 12px */
            --space-4: 1rem;      /* 16px */
            --space-5: 1.25rem;   /* 20px */
            --space-6: 1.5rem;    /* 24px */
            --space-8: 2rem;      /* 32px */
            --space-10: 2.5rem;   /* 40px */
            --space-12: 3rem;     /* 48px */

            /* ═══ BORDER RADIUS SCALE ═══ */
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 14px;
            --radius-xl: 20px;
            --radius-2xl: 28px;
            --radius-full: 9999px;

            /* ═══ TRANSITION TIMING ═══ */
            --ease-out: cubic-bezier(0.0, 0.0, 0.2, 1);
            --ease-in: cubic-bezier(0.4, 0.0, 1, 1);
            --ease-in-out: cubic-bezier(0.4, 0.0, 0.2, 1);
            --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
            --duration-fast: 150ms;
            --duration-normal: 250ms;
            --duration-slow: 400ms;

            /* ═══ Z-INDEX SCALE ═══ */
            --z-dropdown: 100;
            --z-sticky: 200;
            --z-fixed: 300;
            --z-modal-backdrop: 400;
            --z-modal: 500;
            --z-popover: 600;
            --z-tooltip: 700;

            /* ═══ PC/DESKTOP-FIRST DEFAULTS ═══ */
            --is-desktop: 1;
            --is-mobile: 0;
            --is-touch: 0;
            --desktop-sidebar-width: 280px;
            --desktop-header-height: 70px;
            --desktop-content-max: 1800px;
            --desktop-grid-gap: 20px;
            --desktop-card-padding: 24px;
            --desktop-border-radius: 16px;
            --desktop-transition: 0.2s ease;
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           LIGHT THEME MODE - Complete Override with Smart Visibility
           ═══════════════════════════════════════════════════════════════════════════ */
        body.light-theme {
            --theme-bg: #f5f5f7 !important;
            --theme-bg-secondary: #ffffff !important;
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f7 100%) !important;
            color: #1a1a2e !important;
        }
        body.light-theme .container { color: #1a1a2e; }
        body.light-theme .header h1 { color: #1a1a2e; }
        body.light-theme .upload-box {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 248, 250, 0.9) 100%);
            border-color: #d0d0d8;
            color: #1a1a2e;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08), 0 0 40px rgba(var(--theme-primary-rgb), 0.05);
        }
        body.light-theme .controls {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 248, 250, 0.85) 100%);
            border-color: #d0d0d8;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06);
        }
        body.light-theme select, body.light-theme input {
            background: #ffffff;
            border-color: #d0d0d8;
            color: #1a1a2e;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        body.light-theme select:focus, body.light-theme input:focus {
            border-color: var(--theme-primary);
            box-shadow: 0 0 0 3px rgba(var(--theme-primary-rgb), 0.1), inset 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        body.light-theme table { background: rgba(255, 255, 255, 0.9); }
        body.light-theme th { background: #f0f0f2; color: #1a1a2e; }
        body.light-theme td { color: #1a1a2e; border-color: #e0e0e4; }
        body.light-theme .full-table-wrapper > table > thead > tr > th { background: #f0f0f2 !important; color: #1a1a2e !important; }
        body.light-theme .stat-card {
            background: linear-gradient(145deg, rgba(var(--theme-primary-rgb), 0.12), rgba(var(--theme-primary-rgb), 0.06));
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
            border-color: rgba(var(--theme-primary-rgb), 0.2);
        }
        body.light-theme .stat-card:hover {
            box-shadow: 0 8px 24px rgba(var(--theme-primary-rgb), 0.15);
        }
        body.light-theme .stat-value {
            background: linear-gradient(135deg, #1a1a2e 0%, var(--theme-primary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        body.light-theme .stat-label { color: #4a4a5a; }
        body.light-theme .stat-value { color: #1a1a2e; }
        body.light-theme label { color: #1a1a2e; }
        body.light-theme #_gvAuthOverlay { background: linear-gradient(135deg, #f5f5f7 0%, #e8e8ec 100%); }
        body.light-theme #_gvAuthBox { background: rgba(255, 255, 255, 0.95); border-color: #d0d0d8; }
        body.light-theme ._gvTitle { color: #1a1a2e; }
        body.light-theme ._gvSub { color: #4a4a5a; }
        body.light-theme #_gvPwd { background: rgba(0, 0, 0, 0.03); border-color: #d0d0d8; color: #1a1a2e; }
        body.light-theme #_gvPwd::placeholder { color: #8a8a9a; }
        body.light-theme ._gvLock { color: #8a8a9a; border-color: #e0e0e4; }
        body.light-theme .full-table-row:hover td { background: rgba(var(--theme-primary-rgb), 0.15) !important; }

        /* ─── Light Theme: Buttons with improved visibility ─── */
        body.light-theme .btn,
        body.light-theme .upload-btn,
        body.light-theme button:not(.color-preset) {
            box-shadow: 0 2px 4px rgba(0,0,0,0.15), 0 1px 2px rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.1);
        }
        body.light-theme .btn:hover,
        body.light-theme .upload-btn:hover,
        body.light-theme button:not(.color-preset):hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.2), 0 2px 4px rgba(0,0,0,0.12);
        }
        body.light-theme .btn-primary { background: #1d4ed8; }
        body.light-theme .btn-secondary { background: #374151; }
        body.light-theme .btn-toggle { background: #6d28d9; }
        body.light-theme .btn-success { background: #047857; }
        body.light-theme .btn-impact { background: #b91c1c; }
        body.light-theme .upload-btn { background: #1d4ed8; }
        body.light-theme .upload-btn.secondary { background: #6d28d9; }
        body.light-theme .upload-btn.matchup { background: #0e7490; }
        body.light-theme .upload-btn.season { background: #047857; }

        /* ─── Light Theme: Tags, badges, and pills ─── */
        body.light-theme .opp-badge,
        body.light-theme .opp-filter-badge,
        body.light-theme .wowy-status-badge,
        body.light-theme .compare-advantage {
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
            border: 1px solid rgba(0,0,0,0.08);
        }
        body.light-theme .opp-hard { background: rgba(220, 38, 38, 0.85); color: #fff; }
        body.light-theme .opp-tough { background: rgba(234, 88, 12, 0.85); color: #fff; }
        body.light-theme .opp-mid { background: rgba(202, 138, 4, 0.85); color: #fff; }
        body.light-theme .opp-easy { background: rgba(22, 163, 74, 0.85); color: #fff; }
        body.light-theme .opp-cake { background: rgba(34, 197, 94, 0.85); color: #fff; }
        body.light-theme .opp-filter-badge { background: rgba(109, 40, 217, 0.85); color: #fff; }
        body.light-theme .compare-advantage.team-a { background: rgba(37, 99, 235, 0.85); color: #fff; }
        body.light-theme .compare-advantage.team-b { background: rgba(147, 51, 234, 0.85); color: #fff; }
        body.light-theme .compare-advantage.neutral { background: rgba(75, 85, 99, 0.85); color: #fff; }

        /* ─── Light Theme: Performance/percentile colors with better contrast ─── */
        body.light-theme .pct-excellent,
        body.light-theme .perf-excellent { background: rgba(22, 163, 74, 0.75) !important; color: #fff !important; }
        body.light-theme .pct-good,
        body.light-theme .perf-good { background: rgba(132, 204, 22, 0.8) !important; color: #1a1a2e !important; }
        body.light-theme .pct-avg,
        body.light-theme .perf-average { background: rgba(234, 179, 8, 0.8) !important; color: #1a1a2e !important; }
        body.light-theme .pct-below,
        body.light-theme .perf-below { background: rgba(249, 115, 22, 0.8) !important; color: #fff !important; }
        body.light-theme .pct-poor,
        body.light-theme .perf-poor { background: rgba(220, 38, 38, 0.75) !important; color: #fff !important; }

        /* ─── Light Theme: Sections and panels ─── */
        body.light-theme .section {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 248, 250, 0.9) 100%);
            border-color: #d0d0d8;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
        }
        body.light-theme .section:hover {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            border-color: rgba(var(--theme-primary-rgb), 0.25);
        }
        body.light-theme .section-title {
            color: #1a1a2e;
            border-bottom-color: rgba(0, 0, 0, 0.08);
        }
        body.light-theme .section-title::before {
            background: linear-gradient(180deg, #1d4ed8, #6d28d9);
        }
        /* ─── Light Theme: Tab Navigation ─── */
        body.light-theme .tab-nav {
            background: rgba(240, 240, 242, 0.9);
            border-color: #d0d0d8;
        }
        body.light-theme .tab-btn {
            color: #4a4a5a;
        }
        body.light-theme .tab-btn:hover {
            background: rgba(37, 99, 235, 0.1);
            color: #1d4ed8;
        }
        body.light-theme .tab-btn.active {
            color: white;
        }
        /* ─── Light Theme: Modal ─── */
        body.light-theme .modal-overlay {
            background: rgba(0, 0, 0, 0.6);
        }
        body.light-theme .modal-content {
            background: linear-gradient(180deg, #ffffff 0%, #f8f8fa 100%);
            border-color: #d0d0d8;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.2);
        }
        body.light-theme .modal-header {
            border-bottom-color: #e0e0e4;
        }
        body.light-theme .advanced-stats-section { border-color: #d0d0d8; }
        body.light-theme .opp-filter-active-indicator { background: rgba(109, 40, 217, 0.1); border-color: rgba(109, 40, 217, 0.4); }
        body.light-theme .opp-filter-add { background: rgba(109, 40, 217, 0.15); border-color: rgba(109, 40, 217, 0.4); color: #6d28d9; }
        body.light-theme .opp-filter-add:hover { background: rgba(109, 40, 217, 0.25); }

        /* ─── Light Theme: WOWY and player elements ─── */
        body.light-theme .wowy-table { background: rgba(255, 255, 255, 0.95); }
        body.light-theme .wowy-table th { background: #e8e8ec; color: #1a1a2e; }
        body.light-theme .wowy-table td { color: #1a1a2e; border-color: #e0e0e4; }
        body.light-theme .wowy-table tr:hover { background: rgba(var(--theme-primary-rgb), 0.1); }
        body.light-theme .wowy-player-img { background: linear-gradient(135deg, #e8e8ec 0%, #d0d0d8 100%); border-color: #b0b0b8; color: var(--theme-primary); }
        body.light-theme .wowy-player-name { color: #4a4a5a; }
        body.light-theme .wowy-status-badge.on { background: #16a34a; }
        body.light-theme .wowy-status-badge.off { background: #dc2626; }

        /* ─── Light Theme: Export card styles ─── */
        body.light-theme .export-team-pill { background: rgba(75, 85, 99, 0.15); border-color: #d0d0d8; color: #1a1a2e; }
        body.light-theme .export-team-pill.selected { background: var(--theme-primary); color: #fff; border-color: var(--theme-primary); }
        body.light-theme .export-btn-back { background: rgba(220, 38, 38, 0.15); color: #b91c1c; border-color: rgba(220, 38, 38, 0.3); }

        /* ─── Light Theme: Links and text highlights ─── */
        body.light-theme a { color: var(--theme-primary); }
        body.light-theme a:hover { color: #1d4ed8; }
        body.light-theme .player-link { color: var(--theme-primary); font-weight: 600; }
        body.light-theme .player-link:hover { color: #1d4ed8; text-decoration: underline; }

        /* ─── Light Theme: Scrollbar ─── */
        body.light-theme ::-webkit-scrollbar-track { background: #f0f0f2; }
        body.light-theme ::-webkit-scrollbar-thumb { background: #c0c0c8; border-radius: 4px; }
        body.light-theme ::-webkit-scrollbar-thumb:hover { background: #a0a0a8; }

        /* ═══════════════════════════════════════════════════════════════════════════
           ADVANCED ANIMATIONS & MICRO-INTERACTIONS
           ═══════════════════════════════════════════════════════════════════════════ */

        /* Ripple Effect for Buttons */
        @keyframes ripple {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }
        .ripple {
            position: absolute;
            border-radius: 50%;
            transform: scale(0);
            animation: ripple 0.6s linear;
            background: rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }

        /* Shimmer Loading Effect */
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        .skeleton {
            background: linear-gradient(90deg,
                rgba(255, 255, 255, 0.03) 25%,
                rgba(255, 255, 255, 0.08) 50%,
                rgba(255, 255, 255, 0.03) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: var(--radius-md);
        }
        .skeleton-text { height: 1em; margin-bottom: 0.5em; }
        .skeleton-title { height: 1.5em; width: 60%; margin-bottom: 1em; }
        .skeleton-avatar { width: 48px; height: 48px; border-radius: 50%; }
        .skeleton-card { height: 120px; }

        /* Pulse Glow Animation */
        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(var(--theme-primary-rgb), 0.4); }
            50% { box-shadow: 0 0 0 8px rgba(var(--theme-primary-rgb), 0); }
        }
        .pulse-glow { animation: pulseGlow 2s infinite; }

        /* Float Animation */
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }
        .float { animation: float 3s ease-in-out infinite; }

        /* Entrance Animations */
        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideInLeft {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        .animate-slide-up { animation: slideInUp 0.4s var(--ease-out) forwards; }
        .animate-slide-down { animation: slideInDown 0.4s var(--ease-out) forwards; }
        .animate-slide-left { animation: slideInLeft 0.4s var(--ease-out) forwards; }
        .animate-slide-right { animation: slideInRight 0.4s var(--ease-out) forwards; }
        .animate-scale { animation: scaleIn 0.3s var(--ease-out) forwards; }

        /* Staggered Children Animation */
        .stagger-children > * {
            opacity: 0;
            animation: slideInUp 0.4s var(--ease-out) forwards;
        }
        .stagger-children > *:nth-child(1) { animation-delay: 0.05s; }
        .stagger-children > *:nth-child(2) { animation-delay: 0.1s; }
        .stagger-children > *:nth-child(3) { animation-delay: 0.15s; }
        .stagger-children > *:nth-child(4) { animation-delay: 0.2s; }
        .stagger-children > *:nth-child(5) { animation-delay: 0.25s; }
        .stagger-children > *:nth-child(6) { animation-delay: 0.3s; }
        .stagger-children > *:nth-child(7) { animation-delay: 0.35s; }
        .stagger-children > *:nth-child(8) { animation-delay: 0.4s; }

        /* Number Counter Animation */
        @keyframes countUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .count-up { animation: countUp 0.5s var(--ease-out) forwards; }

        /* Focus Ring for Accessibility */
        .focus-ring:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(var(--theme-primary-rgb), 0.4);
        }
        .focus-ring:focus:not(:focus-visible) {
            box-shadow: none;
        }
        .focus-ring:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px rgba(var(--theme-primary-rgb), 0.4);
        }

        /* Interactive Feedback States */
        .interactive {
            transition: all var(--duration-normal) var(--ease-out);
            cursor: pointer;
        }
        .interactive:hover {
            transform: translateY(-2px);
        }
        .interactive:active {
            transform: translateY(0) scale(0.98);
        }

        /* Card Hover Lift Effect */
        .card-lift {
            transition: all var(--duration-normal) var(--ease-out);
        }
        .card-lift:hover {
            transform: translateY(-4px);
            box-shadow: var(--elevation-4);
        }

        /* Subtle Breathing Animation for Live Data */
        @keyframes breathe {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .live-indicator::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #22c55e;
            border-radius: 50%;
            margin-right: 6px;
            animation: breathe 2s ease-in-out infinite;
        }

        /* Glass Card Effect */
        .glass {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        .glass-light {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        /* ═══ THIRD LOOP: ENHANCED HOVER & TRANSITION POLISH ═══ */

        /* Smooth Table Row Hover */
        tbody tr {
            transition: background-color var(--duration-fast) var(--ease-out), transform var(--duration-fast) var(--ease-out);
        }

        /* Button Press State Enhancement */
        .btn:active, .tab-btn:active, .subtab-btn:active, .upload-btn:active {
            transform: translateY(0) scale(0.98);
            transition-duration: 50ms;
        }

        /* Smooth Card Entrance for Dynamically Added Content */
        .card-enter {
            animation: cardEnter 0.3s var(--ease-out) forwards;
        }
        @keyframes cardEnter {
            from {
                opacity: 0;
                transform: translateY(16px) scale(0.98);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* Subtle Highlight on Focus Within Container */
        .focus-within-highlight:focus-within {
            border-color: rgba(var(--theme-primary-rgb), 0.4);
            box-shadow: 0 0 0 3px rgba(var(--theme-primary-rgb), 0.1);
        }

        /* Loading Overlay for Sections */
        .section-loading {
            position: relative;
            pointer-events: none;
        }
        .section-loading::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.7);
            border-radius: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        /* Expand/Collapse Animation */
        .expandable {
            overflow: hidden;
            transition: max-height var(--duration-normal) var(--ease-out), opacity var(--duration-normal) var(--ease-out);
        }
        .expandable.collapsed {
            max-height: 0;
            opacity: 0;
        }
        .expandable.expanded {
            opacity: 1;
        }

        /* Subtle Scale on Card Click */
        .clickable-card {
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
        }
        .clickable-card:active {
            transform: scale(0.98);
        }

        /* Input Glow on Active Typing */
        input:not(:placeholder-shown):focus,
        select:focus {
            box-shadow: 0 0 0 3px rgba(var(--theme-primary-rgb), 0.2), 0 4px 12px rgba(var(--theme-primary-rgb), 0.1);
        }

        /* Animated Underline for Links */
        .link-underline {
            position: relative;
            text-decoration: none;
        }
        .link-underline::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 0;
            height: 2px;
            background: var(--theme-primary);
            transition: width var(--duration-normal) var(--ease-out);
        }
        .link-underline:hover::after {
            width: 100%;
        }

        /* Stagger Animation for List Items */
        .stagger-item {
            opacity: 0;
            animation: staggerFadeIn 0.4s var(--ease-out) forwards;
        }
        .stagger-item:nth-child(1) { animation-delay: 0.05s; }
        .stagger-item:nth-child(2) { animation-delay: 0.1s; }
        .stagger-item:nth-child(3) { animation-delay: 0.15s; }
        .stagger-item:nth-child(4) { animation-delay: 0.2s; }
        .stagger-item:nth-child(5) { animation-delay: 0.25s; }
        .stagger-item:nth-child(6) { animation-delay: 0.3s; }
        .stagger-item:nth-child(7) { animation-delay: 0.35s; }
        .stagger-item:nth-child(8) { animation-delay: 0.4s; }
        @keyframes staggerFadeIn {
            to { opacity: 1; }
        }

        /* Tab Content Transition */
        .tab-content {
            animation: tabContentIn 0.25s var(--ease-out);
        }
        @keyframes tabContentIn {
            from { opacity: 0; transform: translateX(-8px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Subtle Parallax Effect on Scroll (CSS only) */
        .parallax-subtle {
            transform: translateZ(0);
            will-change: transform;
        }

        /* Number Change Animation */
        .number-change {
            display: inline-block;
            transition: transform var(--duration-fast) var(--ease-bounce);
        }
        .number-change.increase {
            color: #22c55e;
            animation: numberBounceUp 0.3s var(--ease-bounce);
        }
        .number-change.decrease {
            color: #ef4444;
            animation: numberBounceDown 0.3s var(--ease-bounce);
        }
        @keyframes numberBounceUp {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        @keyframes numberBounceDown {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(4px); }
        }

        /* Pulsing Border for Attention */
        .attention-pulse {
            animation: attentionPulse 2s ease-in-out infinite;
        }
        @keyframes attentionPulse {
            0%, 100% { border-color: rgba(var(--theme-primary-rgb), 0.3); }
            50% { border-color: rgba(var(--theme-primary-rgb), 0.7); }
        }

        /* Smooth Scroll Snap for Horizontal Scroll */
        .scroll-snap-x {
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
        }
        .scroll-snap-item {
            scroll-snap-align: start;
        }

        /* Gradient Border Effect */
        .gradient-border {
            position: relative;
            background: var(--theme-bg-secondary);
            border-radius: var(--radius-lg);
        }
        .gradient-border::before {
            content: '';
            position: absolute;
            inset: 0;
            padding: 2px;
            background: linear-gradient(135deg, var(--theme-primary), var(--theme-accent));
            border-radius: inherit;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            -webkit-mask-composite: xor;
            pointer-events: none;
        }

        /* Tooltip Base Styles */
        [data-tooltip] {
            position: relative;
        }
        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%) translateY(4px);
            padding: 6px 12px;
            background: rgba(15, 23, 42, 0.95);
            color: #e2e8f0;
            font-size: var(--text-xs);
            font-weight: 500;
            border-radius: var(--radius-sm);
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all var(--duration-fast) var(--ease-out);
            z-index: var(--z-tooltip);
            box-shadow: var(--elevation-3);
        }
        [data-tooltip]:hover::after {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        /* Status Dot Indicator */
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        .status-dot.success { background: #22c55e; box-shadow: 0 0 8px rgba(34, 197, 94, 0.5); }
        .status-dot.warning { background: #f59e0b; box-shadow: 0 0 8px rgba(245, 158, 11, 0.5); }
        .status-dot.error { background: #ef4444; box-shadow: 0 0 8px rgba(239, 68, 68, 0.5); }
        .status-dot.info { background: #3b82f6; box-shadow: 0 0 8px rgba(59, 130, 246, 0.5); }

        /* Progress Bar Smooth Animation */
        .progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-full);
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--theme-primary), var(--theme-accent));
            border-radius: var(--radius-full);
            transition: width 0.5s var(--ease-out);
            position: relative;
        }
        .progress-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           THIRD LOOP: SENIOR GOOGLE DESIGN ENHANCEMENTS
           ═══════════════════════════════════════════════════════════════════════════ */

        /* ─── Skeleton Loading States ─── */
        .skeleton {
            background: linear-gradient(90deg,
                rgba(30, 41, 59, 0.5) 0%,
                rgba(51, 65, 85, 0.5) 50%,
                rgba(30, 41, 59, 0.5) 100%);
            background-size: 200% 100%;
            animation: skeletonPulse 1.5s ease-in-out infinite;
            border-radius: var(--radius-md);
        }
        .skeleton-text {
            height: 1em;
            width: 80%;
            margin-bottom: 8px;
        }
        .skeleton-text.short { width: 40%; }
        .skeleton-text.medium { width: 60%; }
        .skeleton-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .skeleton-card {
            height: 120px;
            width: 100%;
        }
        @keyframes skeletonPulse {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* ─── Enhanced Input Groups with Labels ─── */
        .input-group {
            position: relative;
            margin-bottom: var(--space-4);
        }
        .input-group-label {
            position: absolute;
            top: -8px;
            left: 12px;
            background: var(--theme-bg-secondary);
            padding: 0 6px;
            font-size: var(--text-xs);
            font-weight: 600;
            color: var(--theme-primary);
            letter-spacing: var(--letter-spacing-wide);
            z-index: 1;
        }
        .input-group input,
        .input-group select {
            padding-top: 14px;
        }

        /* ─── Floating Action Button ─── */
        .fab {
            position: fixed;
            bottom: var(--space-6);
            right: var(--space-6);
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--theme-primary), var(--theme-accent));
            border: none;
            box-shadow: var(--elevation-4), var(--elevation-glow-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            transition: all var(--duration-normal) var(--ease-out);
            z-index: var(--z-fixed);
        }
        .fab:hover {
            transform: scale(1.1) translateY(-2px);
            box-shadow: var(--elevation-5), 0 0 30px rgba(var(--theme-primary-rgb), 0.5);
        }
        .fab:active {
            transform: scale(0.95);
        }

        /* ─── Chip Components (Google Material Style) ─── */
        .chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            background: rgba(var(--theme-primary-rgb), 0.12);
            border: 1px solid rgba(var(--theme-primary-rgb), 0.25);
            border-radius: var(--radius-full);
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--theme-primary);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
            user-select: none;
        }
        .chip:hover {
            background: rgba(var(--theme-primary-rgb), 0.2);
            border-color: rgba(var(--theme-primary-rgb), 0.4);
        }
        .chip.active {
            background: var(--theme-primary);
            color: white;
            border-color: var(--theme-primary);
        }
        .chip.deletable::after {
            content: '×';
            margin-left: 4px;
            font-size: 16px;
            opacity: 0.7;
        }
        .chip.deletable:hover::after {
            opacity: 1;
        }

        /* ─── Snackbar / Toast Notifications ─── */
        .snackbar {
            position: fixed;
            bottom: var(--space-6);
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: var(--radius-lg);
            padding: var(--space-3) var(--space-5);
            box-shadow: var(--elevation-4);
            display: flex;
            align-items: center;
            gap: var(--space-3);
            z-index: var(--z-tooltip);
            opacity: 0;
            transition: all var(--duration-normal) var(--ease-out);
        }
        .snackbar.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        .snackbar-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .snackbar-icon.success { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        .snackbar-icon.error { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
        .snackbar-icon.info { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
        .snackbar-message {
            font-size: var(--text-sm);
            font-weight: 500;
            color: #e2e8f0;
        }
        .snackbar-action {
            padding: var(--space-1) var(--space-3);
            background: transparent;
            border: none;
            color: var(--theme-primary);
            font-weight: 600;
            font-size: var(--text-sm);
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: background var(--duration-fast);
        }
        .snackbar-action:hover {
            background: rgba(var(--theme-primary-rgb), 0.15);
        }

        /* ─── Segmented Control (iOS/Material Style) ─── */
        .segmented-control {
            display: inline-flex;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(71, 85, 105, 0.4);
            border-radius: var(--radius-lg);
            padding: 4px;
            gap: 2px;
        }
        .segmented-control-item {
            padding: var(--space-2) var(--space-4);
            font-size: var(--text-sm);
            font-weight: 500;
            color: #94a3b8;
            background: transparent;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
            position: relative;
        }
        .segmented-control-item:hover {
            color: #e2e8f0;
        }
        .segmented-control-item.active {
            background: linear-gradient(135deg, var(--theme-primary), var(--theme-accent));
            color: white;
            box-shadow: 0 2px 8px rgba(var(--theme-primary-rgb), 0.3);
        }

        /* ─── Enhanced Empty State ─── */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-12) var(--space-6);
            text-align: center;
            animation: fadeIn 0.4s var(--ease-out);
        }
        .empty-state-icon {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, rgba(var(--theme-primary-rgb), 0.15), rgba(var(--theme-accent-rgb), 0.15));
            border-radius: var(--radius-2xl);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            margin-bottom: var(--space-5);
            position: relative;
        }
        .empty-state-icon::after {
            content: '';
            position: absolute;
            inset: -4px;
            border: 2px dashed rgba(var(--theme-primary-rgb), 0.3);
            border-radius: var(--radius-2xl);
            animation: spinSlow 20s linear infinite;
        }
        @keyframes spinSlow { to { transform: rotate(360deg); } }
        .empty-state-title {
            font-size: var(--text-lg);
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: var(--space-2);
        }
        .empty-state-desc {
            font-size: var(--text-sm);
            color: #94a3b8;
            max-width: 300px;
            line-height: var(--line-height-relaxed);
        }

        /* ─── Bottom Sheet (Mobile-Inspired) ─── */
        .bottom-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(30, 41, 59, 0.98);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
            padding: var(--space-4) var(--space-6) var(--space-8);
            transform: translateY(100%);
            transition: transform var(--duration-slow) var(--ease-out);
            z-index: var(--z-modal);
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.3);
        }
        .bottom-sheet.open {
            transform: translateY(0);
        }
        .bottom-sheet-handle {
            width: 40px;
            height: 5px;
            background: rgba(148, 163, 184, 0.3);
            border-radius: var(--radius-full);
            margin: 0 auto var(--space-4);
        }

        /* ─── Metric Trend Indicator ─── */
        .trend-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: var(--text-xs);
            font-weight: 600;
            padding: 2px 8px;
            border-radius: var(--radius-full);
        }
        .trend-indicator.up {
            background: rgba(34, 197, 94, 0.15);
            color: #22c55e;
        }
        .trend-indicator.down {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
        }
        .trend-indicator.neutral {
            background: rgba(148, 163, 184, 0.15);
            color: #94a3b8;
        }
        .trend-indicator::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
        }
        .trend-indicator.up::before {
            border-bottom: 5px solid currentColor;
        }
        .trend-indicator.down::before {
            border-top: 5px solid currentColor;
        }

        /* ─── Data Table Enhancements ─── */
        .data-table-container {
            position: relative;
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--elevation-2);
        }
        .data-table-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-4);
            background: rgba(15, 23, 42, 0.6);
            border-bottom: 1px solid rgba(71, 85, 105, 0.4);
        }
        .data-table-title {
            font-size: var(--text-md);
            font-weight: 600;
            color: #e2e8f0;
        }
        .data-table-actions {
            display: flex;
            gap: var(--space-2);
        }

        /* ─── Inline Stat with Sparkline Effect ─── */
        .inline-stat {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            background: rgba(30, 41, 59, 0.5);
            border-radius: var(--radius-md);
            border: 1px solid rgba(71, 85, 105, 0.3);
        }
        .inline-stat-value {
            font-size: var(--text-xl);
            font-weight: 700;
            color: #e2e8f0;
        }
        .inline-stat-label {
            font-size: var(--text-xs);
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: var(--letter-spacing-wide);
        }
        .inline-stat-bar {
            flex: 1;
            height: 32px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
        }
        .inline-stat-bar-segment {
            flex: 1;
            background: linear-gradient(180deg, var(--theme-primary), rgba(var(--theme-primary-rgb), 0.3));
            border-radius: 2px 2px 0 0;
            transition: height var(--duration-normal) var(--ease-out);
        }

        /* ─── Notification Badge ─── */
        .notification-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            font-size: 10px;
            font-weight: 700;
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(239, 68, 68, 0.4);
            animation: badgePop 0.3s var(--ease-bounce);
        }
        @keyframes badgePop {
            0% { transform: scale(0); }
            70% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* ─── Divider with Label ─── */
        .divider {
            display: flex;
            align-items: center;
            gap: var(--space-4);
            margin: var(--space-6) 0;
        }
        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(71, 85, 105, 0.5), transparent);
        }
        .divider-label {
            font-size: var(--text-xs);
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: var(--letter-spacing-wider);
        }

        /* ─── Gradient Text Utility ─── */
        .gradient-text {
            background: linear-gradient(135deg, var(--theme-primary), var(--theme-accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .gradient-text-animated {
            background: linear-gradient(135deg, var(--theme-primary), var(--theme-accent), #f472b6, var(--theme-primary));
            background-size: 300% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 4s ease infinite;
        }

        /* ─── Subtle Card Glow on Data Focus ─── */
        .glow-card {
            position: relative;
        }
        .glow-card::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            opacity: 0;
            background: radial-gradient(600px circle at var(--mouse-x, 50%) var(--mouse-y, 50%),
                rgba(var(--theme-primary-rgb), 0.1), transparent 40%);
            transition: opacity var(--duration-normal);
            pointer-events: none;
        }
        .glow-card:hover::after {
            opacity: 1;
        }

        /* ─── Animated Counter Effect ─── */
        .counter-animate {
            display: inline-block;
            transition: transform var(--duration-fast) var(--ease-out);
        }
        .counter-animate.changed {
            animation: counterBump 0.3s var(--ease-bounce);
        }
        @keyframes counterBump {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        /* ─── Highlight Row Animation ─── */
        .row-highlight {
            animation: rowHighlight 2s ease-out;
        }
        @keyframes rowHighlight {
            0% { background: rgba(var(--theme-primary-rgb), 0.4) !important; }
            100% { background: transparent; }
        }

        /* ─── Interactive List Item ─── */
        .list-item-interactive {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
            border: 1px solid transparent;
        }
        .list-item-interactive:hover {
            background: rgba(var(--theme-primary-rgb), 0.08);
            border-color: rgba(var(--theme-primary-rgb), 0.2);
        }
        .list-item-interactive:active {
            background: rgba(var(--theme-primary-rgb), 0.15);
        }
        .list-item-interactive.selected {
            background: rgba(var(--theme-primary-rgb), 0.12);
            border-color: rgba(var(--theme-primary-rgb), 0.3);
        }

        /* ─── Compact Info Row ─── */
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-2) 0;
            border-bottom: 1px solid rgba(71, 85, 105, 0.2);
        }
        .info-row:last-child {
            border-bottom: none;
        }
        .info-row-label {
            font-size: var(--text-sm);
            color: #94a3b8;
        }
        .info-row-value {
            font-size: var(--text-sm);
            font-weight: 600;
            color: #e2e8f0;
        }

        /* ─── ── Dark Theme: Custom Scrollbar ─── */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(var(--theme-primary-rgb), 0.5) 0%, rgba(var(--theme-accent-rgb), 0.5) 100%);
            border-radius: 5px;
            border: 2px solid rgba(15, 23, 42, 0.5);
            transition: background 0.2s ease;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(var(--theme-primary-rgb), 0.7) 0%, rgba(var(--theme-accent-rgb), 0.7) 100%);
        }
        ::-webkit-scrollbar-corner {
            background: rgba(15, 23, 42, 0.5);
        }
        /* Firefox scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(var(--theme-primary-rgb), 0.5) rgba(15, 23, 42, 0.5);
        }

        /* ─── Light Theme: Positive/Negative value colors ─── */
        body.light-theme .positive, body.light-theme [style*="color: #22c55e"], body.light-theme [style*="color: rgb(34, 197, 94)"] { color: #16a34a !important; }
        body.light-theme .negative, body.light-theme [style*="color: #ef4444"], body.light-theme [style*="color: rgb(239, 68, 68)"] { color: #dc2626 !important; }

        /* ═══════════════════════════════════════════════════════════════════════════
           PASSWORD PROTECTION SYSTEM v3.1 - STYLES (Integrated from GAMEVIS)
           ═══════════════════════════════════════════════════════════════════════════ */
        #_gvAuthOverlay{position:fixed;inset:0;background:linear-gradient(135deg, var(--theme-bg-secondary) 0%, var(--theme-bg) 100%);z-index:999999;display:flex;align-items:center;justify-content:center}
        #_gvAuthOverlay::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse 80% 50% at 20% 0%,rgba(var(--theme-primary-rgb),0.08) 0%,transparent 50%),radial-gradient(ellipse 60% 40% at 80% 100%,rgba(var(--theme-accent-rgb),0.06) 0%,transparent 50%);pointer-events:none}
        #_gvAuthBox{background:rgba(30,41,59,0.95);backdrop-filter:blur(20px);border:1px solid #475569;border-radius:24px;padding:48px;width:420px;text-align:center;position:relative;z-index:10;box-shadow:0 25px 80px rgba(0,0,0,0.5)}
        #_gvAuthBox::before{content:'';position:absolute;top:-1px;left:-1px;right:-1px;height:3px;background:linear-gradient(90deg,var(--theme-primary),var(--theme-accent));border-radius:24px 24px 0 0}
        ._gvLogo{width:80px;height:80px;margin:0 auto 24px;background:linear-gradient(135deg,var(--theme-primary),var(--theme-accent));border-radius:20px;display:flex;align-items:center;justify-content:center;font-size:32px;font-weight:700;color:var(--theme-bg)}
        ._gvTitle{font-family:'Space Grotesk',-apple-system,sans-serif;font-size:24px;font-weight:600;margin-bottom:8px;color:#e2e8f0}
        ._gvSub{color:#94a3b8;font-size:14px;margin-bottom:32px}
        #_gvPwd{width:100%;padding:16px 20px;background:rgba(255,255,255,0.05);border:1px solid #475569;border-radius:12px;color:#e2e8f0;font-size:16px;font-family:inherit;outline:none;transition:all 0.3s ease;margin-bottom:16px}
        #_gvPwd:focus{border-color:var(--theme-primary);box-shadow:0 0 0 3px rgba(var(--theme-primary-rgb),0.15)}
        #_gvPwd::placeholder{color:#64748b}
        #_gvSubmit{width:100%;padding:16px;background:linear-gradient(135deg,var(--theme-primary),#2563eb);border:none;border-radius:12px;color:white;font-size:16px;font-weight:600;font-family:'Space Grotesk',-apple-system,sans-serif;cursor:pointer;transition:all 0.3s ease}
        #_gvSubmit:hover{transform:translateY(-2px);box-shadow:0 8px 25px rgba(var(--theme-primary-rgb),0.3)}
        #_gvSubmit:disabled{opacity:0.5;cursor:not-allowed;transform:none}
        ._gvErr{color:#f87171;font-size:13px;margin-top:16px;min-height:20px}
        ._gvLock{color:#64748b;font-size:12px;margin-top:24px;padding-top:24px;border-top:1px solid #334155}
        @keyframes _gvShake{0%,100%{transform:translateX(0)}25%{transform:translateX(-10px)}75%{transform:translateX(10px)}}
        ._gvShake{animation:_gvShake 0.4s ease-in-out}
        .gv-protected-hidden{display:none!important}
        @keyframes spin { to { transform: rotate(360deg); } }
        /* ═══════════════════════════════════════════════════════════════════════════ */

        * { margin: 0; padding: 0; box-sizing: border-box; }

        /* Percentile bar chart styles - ensure visibility */
        .percentile-bar-container {
            display: block !important;
            visibility: visible !important;
            width: 100% !important;
            min-height: 14px !important;
            position: relative !important;
        }
        .percentile-bar-fill {
            display: block !important;
            visibility: visible !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            bottom: 0 !important;
        }

        body {
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .container { max-width: 1600px; margin: 0 auto; }
        .header { margin-bottom: 30px; }
        .header h1 {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--theme-primary) 0%, var(--theme-accent) 50%, #f472b6 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: gradientShift 4s ease infinite;
        }
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .upload-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 80vh;
            animation: fadeIn 0.4s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .upload-box {
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.7) 0%, rgba(30, 41, 59, 0.5) 100%);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 20px;
            padding: 48px 40px;
            text-align: center;
            max-width: 700px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 0 40px rgba(var(--theme-primary-rgb), 0.08);
            position: relative;
            overflow: hidden;
        }
        .upload-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--theme-primary), var(--theme-accent), #f472b6, var(--theme-primary));
            background-size: 300% 100%;
            animation: gradientShift 4s ease infinite;
        }
        .upload-btn {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: white;
            padding: 14px 28px;
            border-radius: 12px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            font-size: 15px;
            margin: 8px;
            display: inline-block;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 16px rgba(37, 99, 235, 0.3);
            position: relative;
            overflow: hidden;
        }
        .upload-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        .upload-btn:hover::before { left: 100%; }
        .upload-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 24px rgba(37, 99, 235, 0.4);
        }
        .upload-btn:active {
            transform: translateY(-1px);
        }
        .upload-btn.secondary {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            box-shadow: 0 4px 16px rgba(124, 58, 237, 0.3);
        }
        .upload-btn.secondary:hover {
            box-shadow: 0 8px 24px rgba(124, 58, 237, 0.4);
        }
        .upload-btn.matchup {
            background: linear-gradient(135deg, #0891b2 0%, #0e7490 100%);
            box-shadow: 0 4px 16px rgba(8, 145, 178, 0.3);
        }
        .upload-btn.matchup:hover {
            box-shadow: 0 8px 24px rgba(8, 145, 178, 0.4);
        }
        .upload-btn.season {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            box-shadow: 0 4px 16px rgba(5, 150, 105, 0.3);
        }
        .upload-btn.season:hover {
            box-shadow: 0 8px 24px rgba(5, 150, 105, 0.4);
        }

        .controls {
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.6) 0%, rgba(30, 41, 59, 0.4) 100%);
            border: 1px solid rgba(71, 85, 105, 0.4);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(8px);
        }
        .form-group { margin-bottom: 20px; }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 13px;
            color: #e2e8f0;
            letter-spacing: 0.02em;
        }

        select, input {
            width: 100%;
            padding: 12px 14px;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 10px;
            color: white;
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.15);
        }
        select:hover, input:hover {
            border-color: rgba(96, 165, 250, 0.4);
        }
        select:focus, input:focus {
            outline: none;
            border-color: var(--theme-primary);
            box-shadow: 0 0 0 3px rgba(var(--theme-primary-rgb), 0.15), inset 0 1px 3px rgba(0, 0, 0, 0.15);
        }
        select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2394a3b8' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px;
        }
        .grid-5 { display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; }
        .grid-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
        .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; }
        .stats-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 16px; margin-bottom: 24px; }
        .stat-card {
            background: linear-gradient(145deg, rgba(var(--theme-primary-rgb), 0.15), rgba(var(--theme-primary-rgb), 0.08));
            border: 1px solid rgba(var(--theme-primary-rgb), 0.25);
            border-radius: 14px;
            padding: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--theme-primary), var(--theme-accent));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 24px rgba(var(--theme-primary-rgb), 0.2);
            border-color: rgba(var(--theme-primary-rgb), 0.4);
        }
        .stat-card:hover::before { opacity: 1; }
        .stat-label {
            font-size: 12px;
            margin-bottom: 8px;
            opacity: 0.85;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        .stat-value {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #ffffff 0%, rgba(var(--theme-primary-rgb), 0.9) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Table styles - Enhanced with subtle visual improvements */
        /* NOTE: Do NOT add overflow:hidden or border-collapse:collapse here - breaks sticky positioning */
        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 12px;
        }
        th, td {
            padding: 12px 14px;
            text-align: left;
            border-bottom: 1px solid rgba(51, 65, 85, 0.6);
        }
        th {
            background: rgba(15, 23, 42, 0.9);
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #94a3b8;
        }
        tbody tr:nth-child(even) {
            background: rgba(15, 23, 42, 0.2);
        }
        tbody tr:hover {
            background: rgba(59, 130, 246, 0.12);
        }
        .full-table-row:hover td {
            background: rgba(59, 130, 246, 0.2) !important;
        }
        /* Full Table sticky header - CRITICAL: These styles must override defaults */
        .full-table-wrapper {
            overflow-x: auto !important;
            overflow-y: auto !important;
            max-height: 55vh !important;
            display: block !important;
        }
        .full-table-wrapper.fullscreen { max-height: calc(100vh - 200px) !important; }
        .full-table-wrapper > table { 
            border-collapse: separate !important; 
            border-spacing: 0 !important; 
            width: 100% !important;
            border-radius: 0 !important;
        }
        .full-table-wrapper > table > thead > tr > th { 
            position: -webkit-sticky !important;
            position: sticky !important; 
            top: 0 !important; 
            z-index: 10 !important; 
            background: #1e293b !important; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.4) !important;
        }
        .full-table-wrapper > table > thead > tr > th:first-child { 
            left: 0 !important; 
            z-index: 12 !important; 
        }
        .full-table-wrapper > table > thead > tr > th:nth-child(2) { 
            left: 28px !important; 
            z-index: 12 !important; 
        }
        .full-table-wrapper > table > tbody > tr > td:first-child { 
            position: -webkit-sticky !important;
            position: sticky !important; 
            left: 0 !important; 
            z-index: 2 !important; 
            background: #1e293b !important; 
        }
        .full-table-wrapper > table > tbody > tr > td:nth-child(2) { 
            position: -webkit-sticky !important;
            position: sticky !important; 
            left: 28px !important; 
            z-index: 2 !important; 
            background: #1e293b !important; 
        }
        .btn {
            padding: 10px 18px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            margin: 0 4px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
            transition: left 0.4s ease;
        }
        .btn:hover::before { left: 100%; }
        .btn-primary {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: white;
        }
        .btn-secondary {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            color: white;
        }
        .btn-toggle {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            color: white;
        }
        .btn-success {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            color: white;
        }
        .btn-impact {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            color: white;
        }
        .btn-teamavg {
            background: linear-gradient(135deg, #0d9488 0%, #0f766e 100%);
            color: white;
        }
        .btn-expand {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }
        .btn-matchups {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .btn:disabled:hover {
            transform: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }
        .btn:disabled::before { display: none; }

        .section {
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.6) 0%, rgba(30, 41, 59, 0.4) 100%);
            border: 1px solid rgba(71, 85, 105, 0.4);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            position: relative;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        .section:hover {
            border-color: rgba(var(--theme-primary-rgb), 0.3);
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.15);
        }
        .section-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 16px;
            color: #e2e8f0;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(71, 85, 105, 0.3);
        }
        .section-title::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(180deg, var(--theme-primary), var(--theme-accent));
            border-radius: 2px;
        }
        .flex-between { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .text-xs { font-size: 12px; opacity: 0.8; }

        /* ═══ THIRD LOOP: ADVANCED CARD COMPOSITIONS ═══ */

        /* Metric Card with Comparison */
        .metric-card-compare {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: var(--space-4);
            padding: var(--space-5);
            background: linear-gradient(145deg, rgba(30, 41, 59, 0.7), rgba(30, 41, 59, 0.5));
            border: 1px solid rgba(71, 85, 105, 0.4);
            border-radius: var(--radius-lg);
            align-items: center;
        }
        .metric-card-compare-side {
            text-align: center;
        }
        .metric-card-compare-value {
            font-size: var(--text-2xl);
            font-weight: 700;
            line-height: 1;
            margin-bottom: var(--space-1);
        }
        .metric-card-compare-label {
            font-size: var(--text-xs);
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: var(--letter-spacing-wide);
        }
        .metric-card-compare-vs {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(71, 85, 105, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--text-xs);
            font-weight: 700;
            color: #64748b;
        }

        /* Stacked Metric Card */
        .stacked-metric-card {
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
            padding: var(--space-5);
            background: linear-gradient(145deg, rgba(30, 41, 59, 0.7), rgba(30, 41, 59, 0.5));
            border: 1px solid rgba(71, 85, 105, 0.4);
            border-radius: var(--radius-lg);
        }
        .stacked-metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-2) 0;
            border-bottom: 1px solid rgba(71, 85, 105, 0.2);
        }
        .stacked-metric-row:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .stacked-metric-label {
            font-size: var(--text-sm);
            color: #94a3b8;
        }
        .stacked-metric-value {
            font-size: var(--text-md);
            font-weight: 600;
            color: #e2e8f0;
        }

        /* Quick Action Card */
        .quick-action-card {
            display: flex;
            align-items: center;
            gap: var(--space-4);
            padding: var(--space-4) var(--space-5);
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(71, 85, 105, 0.3);
            border-radius: var(--radius-lg);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
        }
        .quick-action-card:hover {
            background: rgba(var(--theme-primary-rgb), 0.1);
            border-color: rgba(var(--theme-primary-rgb), 0.3);
            transform: translateX(4px);
        }
        .quick-action-icon {
            width: 44px;
            height: 44px;
            border-radius: var(--radius-md);
            background: linear-gradient(135deg, rgba(var(--theme-primary-rgb), 0.2), rgba(var(--theme-accent-rgb), 0.2));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            flex-shrink: 0;
        }
        .quick-action-content {
            flex: 1;
        }
        .quick-action-title {
            font-size: var(--text-sm);
            font-weight: 600;
            color: #e2e8f0;
        }
        .quick-action-desc {
            font-size: var(--text-xs);
            color: #64748b;
            margin-top: 2px;
        }
        .quick-action-arrow {
            color: #64748b;
            transition: transform var(--duration-fast);
        }
        .quick-action-card:hover .quick-action-arrow {
            transform: translateX(4px);
            color: var(--theme-primary);
        }

        /* ═══ THIRD LOOP: ENHANCED DATA VIZ ═══ */

        /* Mini Bar Chart */
        .mini-bar-chart {
            display: flex;
            align-items: flex-end;
            gap: 3px;
            height: 40px;
            padding: var(--space-2);
            background: rgba(15, 23, 42, 0.4);
            border-radius: var(--radius-sm);
        }
        .mini-bar-segment {
            flex: 1;
            background: linear-gradient(180deg, var(--theme-primary), rgba(var(--theme-primary-rgb), 0.4));
            border-radius: 2px 2px 0 0;
            min-height: 4px;
            transition: height var(--duration-normal) var(--ease-out);
        }
        .mini-bar-segment:hover {
            background: linear-gradient(180deg, var(--theme-accent), rgba(var(--theme-accent-rgb), 0.5));
        }

        /* Radial Progress */
        .radial-progress {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: conic-gradient(
                var(--theme-primary) calc(var(--progress, 0) * 3.6deg),
                rgba(71, 85, 105, 0.3) 0deg
            );
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .radial-progress::before {
            content: '';
            position: absolute;
            inset: 6px;
            border-radius: 50%;
            background: var(--theme-bg-secondary);
        }
        .radial-progress-value {
            position: relative;
            z-index: 1;
            font-size: var(--text-sm);
            font-weight: 700;
            color: #e2e8f0;
        }

        /* Horizontal Stack Bar */
        .h-stack-bar {
            display: flex;
            height: 8px;
            border-radius: var(--radius-full);
            overflow: hidden;
            background: rgba(71, 85, 105, 0.2);
        }
        .h-stack-segment {
            transition: width var(--duration-normal) var(--ease-out);
        }
        .h-stack-segment.primary { background: var(--theme-primary); }
        .h-stack-segment.secondary { background: var(--theme-accent); }
        .h-stack-segment.tertiary { background: #f472b6; }
        .h-stack-segment.success { background: #22c55e; }
        .h-stack-segment.warning { background: #f59e0b; }
        .h-stack-segment.danger { background: #ef4444; }

        /* Comparison Indicator */
        .compare-indicator {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            font-weight: 600;
        }
        .compare-indicator.better {
            background: rgba(34, 197, 94, 0.15);
            color: #22c55e;
        }
        .compare-indicator.worse {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
        }
        .compare-indicator.similar {
            background: rgba(148, 163, 184, 0.15);
            color: #94a3b8;
        }

        /* ═══ THIRD LOOP: CONTEXTUAL MENUS & POPOVERS ═══ */

        /* Dropdown Menu */
        .dropdown-menu {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            min-width: 180px;
            background: rgba(30, 41, 59, 0.98);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: var(--radius-lg);
            box-shadow: var(--elevation-4);
            z-index: var(--z-dropdown);
            padding: var(--space-2);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all var(--duration-fast) var(--ease-out);
        }
        .dropdown-menu.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .dropdown-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-2) var(--space-3);
            font-size: var(--text-sm);
            color: #e2e8f0;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        .dropdown-item:hover {
            background: rgba(var(--theme-primary-rgb), 0.15);
            color: var(--theme-primary);
        }
        .dropdown-item-icon {
            width: 20px;
            text-align: center;
            opacity: 0.7;
        }
        .dropdown-divider {
            height: 1px;
            background: rgba(71, 85, 105, 0.4);
            margin: var(--space-2) 0;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            min-width: 160px;
            background: rgba(30, 41, 59, 0.98);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: var(--radius-md);
            box-shadow: var(--elevation-4);
            z-index: var(--z-popover);
            padding: var(--space-1);
            animation: contextMenuIn 0.15s var(--ease-out);
        }
        @keyframes contextMenuIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .context-menu-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            font-size: var(--text-sm);
            color: #e2e8f0;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: background var(--duration-fast);
        }
        .context-menu-item:hover {
            background: rgba(var(--theme-primary-rgb), 0.15);
        }
        .context-menu-item.danger:hover {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
        }

        /* Popover */
        .popover {
            position: absolute;
            background: rgba(30, 41, 59, 0.98);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: var(--radius-lg);
            box-shadow: var(--elevation-4);
            z-index: var(--z-popover);
            padding: var(--space-4);
            max-width: 320px;
            animation: popoverIn 0.2s var(--ease-out);
        }
        @keyframes popoverIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .popover-arrow {
            position: absolute;
            width: 12px;
            height: 12px;
            background: rgba(30, 41, 59, 0.98);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-right: none;
            border-bottom: none;
            transform: rotate(45deg);
            top: -7px;
            left: calc(50% - 6px);
        }
        .popover-header {
            font-size: var(--text-sm);
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: var(--space-2);
            padding-bottom: var(--space-2);
            border-bottom: 1px solid rgba(71, 85, 105, 0.3);
        }
        .popover-content {
            font-size: var(--text-sm);
            color: #94a3b8;
            line-height: var(--line-height-relaxed);
        }

        /* ═══ THIRD LOOP: ENHANCED ICONOGRAPHY ═══ */

        /* Icon Button */
        .icon-btn {
            width: 36px;
            height: 36px;
            border-radius: var(--radius-md);
            border: none;
            background: rgba(71, 85, 105, 0.2);
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--duration-fast) var(--ease-out);
        }
        .icon-btn:hover {
            background: rgba(var(--theme-primary-rgb), 0.2);
            color: var(--theme-primary);
        }
        .icon-btn.active {
            background: var(--theme-primary);
            color: white;
        }
        .icon-btn.sm { width: 28px; height: 28px; font-size: 14px; }
        .icon-btn.lg { width: 44px; height: 44px; font-size: 20px; }

        /* Status Indicator (Extended) */
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: var(--radius-full);
            font-size: var(--text-xs);
            font-weight: 600;
        }
        .status-indicator.online {
            background: rgba(34, 197, 94, 0.15);
            color: #22c55e;
        }
        .status-indicator.offline {
            background: rgba(148, 163, 184, 0.15);
            color: #94a3b8;
        }
        .status-indicator.busy {
            background: rgba(245, 158, 11, 0.15);
            color: #f59e0b;
        }
        .status-indicator.error {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
        }
        .status-indicator::before {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
        }
        .status-indicator.online::before { animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Avatar with Status */
        .avatar-status {
            position: relative;
            display: inline-block;
        }
        .avatar-status img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }
        .avatar-status::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid var(--theme-bg-secondary);
        }
        .avatar-status.online::after { background: #22c55e; }
        .avatar-status.offline::after { background: #64748b; }
        .avatar-status.busy::after { background: #f59e0b; }

        /* Rank Badge */
        .rank-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            height: 28px;
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            font-weight: 700;
        }
        .rank-badge.gold {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: #78350f;
        }
        .rank-badge.silver {
            background: linear-gradient(135deg, #e2e8f0, #94a3b8);
            color: #1e293b;
        }
        .rank-badge.bronze {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: #7c2d12;
        }
        .rank-badge.default {
            background: rgba(71, 85, 105, 0.3);
            color: #94a3b8;
        }

        /* Tag with Icon */
        .tag-with-icon {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: rgba(var(--theme-primary-rgb), 0.12);
            border-radius: var(--radius-full);
            font-size: var(--text-xs);
            font-weight: 500;
            color: var(--theme-primary);
        }
        .tag-with-icon-icon {
            font-size: 12px;
        }

        .perf-excellent {
            background: linear-gradient(145deg, rgba(var(--perf-excellent-rgb), 0.6), rgba(var(--perf-excellent-rgb), 0.45)) !important;
            border: 2px solid rgba(var(--perf-excellent-rgb), 0.9) !important;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 2px 8px rgba(var(--perf-excellent-rgb), 0.25);
        }
        .perf-good {
            background: linear-gradient(145deg, rgba(var(--perf-good-rgb), 0.55), rgba(var(--perf-good-rgb), 0.4)) !important;
            border: 2px solid rgba(var(--perf-good-rgb), 0.85) !important;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 2px 8px rgba(var(--perf-good-rgb), 0.2);
        }
        .perf-average {
            background: linear-gradient(145deg, rgba(var(--perf-average-rgb), 0.5), rgba(var(--perf-average-rgb), 0.35)) !important;
            border: 2px solid rgba(var(--perf-average-rgb), 0.8) !important;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 2px 8px rgba(var(--perf-average-rgb), 0.2);
        }
        .perf-below {
            background: linear-gradient(145deg, rgba(var(--perf-below-rgb), 0.55), rgba(var(--perf-below-rgb), 0.4)) !important;
            border: 2px solid rgba(var(--perf-below-rgb), 0.85) !important;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 2px 8px rgba(var(--perf-below-rgb), 0.2);
        }
        .perf-poor {
            background: linear-gradient(145deg, rgba(var(--perf-poor-rgb), 0.6), rgba(var(--perf-poor-rgb), 0.45)) !important;
            border: 2px solid rgba(var(--perf-poor-rgb), 0.9) !important;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 2px 8px rgba(var(--perf-poor-rgb), 0.25);
        }
        .dataset-info {
            background: linear-gradient(135deg, rgba(var(--theme-primary-rgb), 0.12) 0%, rgba(var(--theme-accent-rgb), 0.08) 100%);
            border: 1px solid rgba(var(--theme-primary-rgb), 0.35);
            border-left: 4px solid var(--theme-primary);
            border-radius: 12px;
            padding: 18px 20px;
            margin-bottom: 24px;
            font-size: 13px;
            box-shadow: 0 4px 16px rgba(var(--theme-primary-rgb), 0.08);
        }
        .dataset-info strong {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 15px;
            margin-bottom: 8px;
        }
        .color-legend {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 14px;
            padding-top: 14px;
            border-top: 1px solid rgba(var(--theme-primary-rgb), 0.2);
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            transition: transform 0.2s ease;
        }
        .legend-item:hover { transform: scale(1.05); }
        .legend-excellent {
            background: linear-gradient(135deg, rgba(var(--perf-excellent-rgb), 0.6), rgba(var(--perf-excellent-rgb), 0.45));
            border: 2px solid rgba(var(--perf-excellent-rgb), 0.9);
        }
        .legend-good {
            background: linear-gradient(135deg, rgba(var(--perf-good-rgb), 0.55), rgba(var(--perf-good-rgb), 0.4));
            border: 2px solid rgba(var(--perf-good-rgb), 0.85);
        }
        .legend-average {
            background: linear-gradient(135deg, rgba(var(--perf-average-rgb), 0.5), rgba(var(--perf-average-rgb), 0.35));
            border: 2px solid rgba(var(--perf-average-rgb), 0.8);
        }
        .legend-below {
            background: linear-gradient(135deg, rgba(var(--perf-below-rgb), 0.55), rgba(var(--perf-below-rgb), 0.4));
            border: 2px solid rgba(var(--perf-below-rgb), 0.85);
        }
        .legend-poor {
            background: linear-gradient(135deg, rgba(var(--perf-poor-rgb), 0.6), rgba(var(--perf-poor-rgb), 0.45));
            border: 2px solid rgba(var(--perf-poor-rgb), 0.9);
        }
        .shot-dist-bar {
            display: flex;
            height: 44px;
            border-radius: 12px;
            overflow: hidden;
            background: rgba(15, 23, 42, 0.6);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2), 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        .shot-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            min-width: 0;
            position: relative;
            transition: all 0.2s ease;
        }
        .shot-segment:hover {
            filter: brightness(1.1);
            z-index: 1;
        }
        .shot-rim {
            background: linear-gradient(145deg, #dc2626 0%, #ef4444 50%, #dc2626 100%);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        .shot-mid {
            background: linear-gradient(145deg, #ea580c 0%, #f97316 50%, #ea580c 100%);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        .shot-three {
            background: linear-gradient(145deg, #2563eb 0%, #3b82f6 50%, #2563eb 100%);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        .to-breakdown { display: flex; gap: 8px; margin-top: 8px; }
        .to-segment { flex: 1; padding: 8px; border-radius: 6px; text-align: center; }
        .pace-bar { height: 24px; border-radius: 4px; position: relative; margin: 8px 0; }
        .pace-fill { height: 100%; border-radius: 4px; }
        .pace-marker { position: absolute; top: -6px; width: 3px; height: 36px; background: white; border-radius: 2px; }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(6px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: modalFadeIn 0.2s ease-out;
        }
        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes modalSlideIn {
            from { opacity: 0; transform: scale(0.95) translateY(-10px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        .modal-content {
            background: linear-gradient(180deg, #1e293b 0%, #1a2234 100%);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 20px;
            padding: 32px;
            max-width: 1400px;
            max-height: 90vh;
            overflow-y: auto;
            width: 95%;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5), 0 0 40px rgba(var(--theme-primary-rgb), 0.1);
            animation: modalSlideIn 0.25s ease-out;
            position: relative;
        }
        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--theme-primary), var(--theme-accent));
            border-radius: 20px 20px 0 0;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(71, 85, 105, 0.4);
        }
        .modal-close {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
        }
        .player-card {
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.9) 0%, rgba(30, 41, 59, 0.7) 100%);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 16px;
            padding: 18px;
            margin-bottom: 16px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .player-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--theme-primary), var(--theme-accent));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .player-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.25);
            border-color: rgba(var(--theme-primary-rgb), 0.4);
        }
        .player-card:hover::before { opacity: 1; }
        .player-card-header {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 14px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(71, 85, 105, 0.3);
        }
        .player-photo {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            object-fit: cover;
            background: linear-gradient(135deg, rgba(var(--theme-primary-rgb), 0.2), rgba(var(--theme-accent-rgb), 0.15));
            border: 3px solid rgba(var(--theme-primary-rgb), 0.5);
            flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }
        .player-photo:hover {
            border-color: var(--theme-primary);
            transform: scale(1.05);
        }
        .player-photo-placeholder {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(var(--theme-primary-rgb), 0.3), rgba(var(--theme-accent-rgb), 0.2));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: var(--theme-primary);
            flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .player-photo-loading { animation: pulse 1.5s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
        .team-logo {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            object-fit: contain;
            background: rgba(255, 255, 255, 0.05);
            padding: 4px;
        }
        .team-logo-sm { width: 20px; height: 20px; border-radius: 4px; }
        .player-name {
            font-size: 18px;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .player-stats-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
        }
        .player-stat {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.12), rgba(139, 92, 246, 0.08));
            padding: 10px 8px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(59, 130, 246, 0.15);
            transition: all 0.2s ease;
        }
        .player-stat:hover {
            border-color: rgba(59, 130, 246, 0.3);
            transform: translateY(-2px);
        }
        .player-stat-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.7;
            margin-bottom: 4px;
        }
        .player-stat-value { font-size: 16px; font-weight: 700; }
        .file-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        .file-loaded {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.25), rgba(34, 197, 94, 0.15));
            color: #4ade80;
            border: 1px solid rgba(34, 197, 94, 0.3);
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.15);
        }
        .file-loaded::before {
            content: '✓';
            margin-right: 2px;
        }
        .file-missing {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.25), rgba(239, 68, 68, 0.15));
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.3);
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.15);
        }
        .opp-section { background: rgba(124, 58, 237, 0.1); border: 1px solid rgba(124, 58, 237, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 24px; }
        .opp-stat { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: rgba(0,0,0,0.2); border-radius: 6px; margin-bottom: 6px; }
        .opp-stat-name { font-size: 13px; }
        .opp-stat-value { font-weight: bold; display: flex; align-items: center; gap: 4px; }
        .percentile {
            font-size: 10px;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: var(--radius-full);
            margin-left: 6px;
            letter-spacing: 0.03em;
            display: inline-flex;
            align-items: center;
            transition: all var(--duration-fast) var(--ease-out);
        }
        .percentile:hover {
            transform: scale(1.08);
        }
        .pct-elite {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.5), rgba(22, 163, 74, 0.4));
            color: #86efac;
            border: 1px solid rgba(34, 197, 94, 0.4);
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.25);
        }
        .pct-good {
            background: linear-gradient(135deg, rgba(132, 204, 22, 0.5), rgba(101, 163, 13, 0.4));
            color: #bef264;
            border: 1px solid rgba(132, 204, 22, 0.4);
            box-shadow: 0 2px 8px rgba(132, 204, 22, 0.2);
        }
        .pct-avg {
            background: linear-gradient(135deg, rgba(234, 179, 8, 0.5), rgba(202, 138, 4, 0.4));
            color: #fde047;
            border: 1px solid rgba(234, 179, 8, 0.4);
            box-shadow: 0 2px 8px rgba(234, 179, 8, 0.2);
        }
        .pct-below {
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.5), rgba(234, 88, 12, 0.4));
            color: #fdba74;
            border: 1px solid rgba(249, 115, 22, 0.4);
            box-shadow: 0 2px 8px rgba(249, 115, 22, 0.2);
        }
        .pct-poor {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.5), rgba(220, 38, 38, 0.4));
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.4);
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.25);
        }
        .advanced-stats-section { margin-top: 24px; padding-top: 24px; border-top: 1px solid #475569; }
        .opp-badge {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            font-size: 9px;
            font-weight: 600;
            padding: 3px 7px;
            border-radius: var(--radius-full);
            letter-spacing: 0.02em;
            text-transform: uppercase;
            transition: all var(--duration-fast) var(--ease-out);
        }
        .opp-badge:hover {
            transform: scale(1.05);
        }
        .opp-hard {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.4), rgba(220, 38, 38, 0.3));
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.3);
            box-shadow: 0 2px 6px rgba(239, 68, 68, 0.2);
        }
        .opp-tough {
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.4), rgba(234, 88, 12, 0.3));
            color: #fdba74;
            border: 1px solid rgba(249, 115, 22, 0.3);
            box-shadow: 0 2px 6px rgba(249, 115, 22, 0.2);
        }
        .opp-neutral {
            background: linear-gradient(135deg, rgba(100, 116, 139, 0.4), rgba(71, 85, 105, 0.3));
            color: #cbd5e1;
            border: 1px solid rgba(100, 116, 139, 0.3);
        }
        .opp-soft {
            background: linear-gradient(135deg, rgba(132, 204, 22, 0.4), rgba(101, 163, 13, 0.3));
            color: #bef264;
            border: 1px solid rgba(132, 204, 22, 0.3);
            box-shadow: 0 2px 6px rgba(132, 204, 22, 0.2);
        }
        .opp-easy {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.4), rgba(22, 163, 74, 0.3));
            color: #86efac;
            border: 1px solid rgba(34, 197, 94, 0.3);
            box-shadow: 0 2px 6px rgba(34, 197, 94, 0.2);
        }
        .stat-row { display: flex; align-items: baseline; gap: 4px; flex-wrap: wrap; }
        .impact-section {
            background: linear-gradient(180deg, rgba(220, 38, 38, 0.12) 0%, rgba(220, 38, 38, 0.06) 100%);
            border: 1px solid rgba(220, 38, 38, 0.3);
            border-left: 4px solid #dc2626;
            border-radius: 16px;
            padding: 22px;
            margin-bottom: 24px;
        }
        .impact-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
            border: 1px solid rgba(220, 38, 38, 0.15);
        }
        .impact-card:hover {
            background: rgba(0, 0, 0, 0.25);
            border-color: rgba(220, 38, 38, 0.3);
        }
        .impact-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .impact-stat { font-size: 13px; font-weight: 600; }
        .impact-delta {
            font-size: 13px;
            font-weight: 700;
            padding: 4px 10px;
            border-radius: 6px;
        }
        .delta-positive {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.45), rgba(22, 163, 74, 0.35));
            color: #86efac;
            border: 1px solid rgba(34, 197, 94, 0.35);
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.2);
        }
        .delta-positive::before {
            content: '▲';
            font-size: 8px;
            margin-right: 3px;
        }
        .delta-negative {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.45), rgba(220, 38, 38, 0.35));
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.35);
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.2);
        }
        .delta-negative::before {
            content: '▼';
            font-size: 8px;
            margin-right: 3px;
        }
        .delta-neutral {
            background: linear-gradient(135deg, rgba(100, 116, 139, 0.45), rgba(71, 85, 105, 0.35));
            color: #cbd5e1;
            border: 1px solid rgba(100, 116, 139, 0.35);
        }
        .delta-neutral::before {
            content: '–';
            margin-right: 3px;
        }
        .impact-bar { display: flex; align-items: center; gap: 8px; font-size: 11px; }
        .impact-label { width: 70px; opacity: 0.7; }
        .impact-value { font-weight: 600; min-width: 45px; }
        .pct-yours { border: 2px solid #60a5fa !important; background: rgba(96, 165, 250, 0.15) !important; }
        .pct-opp { border: 2px dashed #a78bfa !important; background: rgba(167, 139, 250, 0.15) !important; }
        .pct-box { display: inline-flex; flex-direction: column; align-items: center; padding: 2px 6px; border-radius: 4px; margin-left: 3px; }
        .pct-box-label { font-size: 7px; font-weight: bold; letter-spacing: 0.5px; margin-bottom: 1px; }
        .teamavg-section { background: rgba(13, 148, 136, 0.1); border: 1px solid rgba(13, 148, 136, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 24px; }
        .teamavg-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; }
        .teamavg-card { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; text-align: center; }
        .teamavg-stat-name { font-size: 11px; opacity: 0.8; margin-bottom: 4px; }
        .teamavg-lineup { font-size: 16px; font-weight: bold; }
        .teamavg-team { font-size: 11px; opacity: 0.6; }
        .teamavg-delta { font-size: 11px; font-weight: bold; padding: 2px 6px; border-radius: 4px; display: inline-block; margin-top: 4px; }
        .ff-impact-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-top: 16px; }
        .ff-impact-card { background: rgba(0,0,0,0.15); border-radius: 8px; padding: 12px; }
        .ff-impact-title { font-size: 12px; font-weight: bold; margin-bottom: 8px; }
        .ff-impact-row { display: flex; justify-content: space-between; align-items: center; padding: 4px 0; font-size: 11px; }
        .comparison-row { display: flex; align-items: center; gap: 8px; margin-top: 4px; }
        .comparison-season { font-size: 11px; color: #94a3b8; }
        .comparison-delta { font-size: 10px; padding: 1px 4px; border-radius: 3px; }
        .comp-better { background: rgba(34, 197, 94, 0.3); color: #4ade80; }
        .comp-worse { background: rgba(239, 68, 68, 0.3); color: #f87171; }
        .comp-same { background: rgba(100, 116, 139, 0.3); color: #94a3b8; }
        .season-compare-section { background: rgba(234, 179, 8, 0.08); border: 1px solid rgba(234, 179, 8, 0.25); border-radius: 8px; padding: 12px; margin-top: 12px; }
        .season-compare-title { font-size: 11px; font-weight: bold; color: #fbbf24; margin-bottom: 8px; }
        .season-compare-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
        .season-compare-item { text-align: center; padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px; }
        .season-compare-label { font-size: 9px; opacity: 0.7; }
        .season-compare-values { display: flex; justify-content: center; gap: 4px; align-items: baseline; margin-top: 2px; }
        .scv-lineup { font-size: 13px; font-weight: bold; color: #60a5fa; }
        .scv-season { font-size: 11px; color: #94a3b8; }
        .scv-delta { font-size: 9px; padding: 1px 3px; border-radius: 2px; margin-left: 2px; font-weight: 600; }
        .scv-better { background: rgba(34, 197, 94, 0.25); color: #4ade80; }
        .scv-worse { background: rgba(239, 68, 68, 0.25); color: #f87171; }
        .scv-same { background: rgba(100, 116, 139, 0.25); color: #94a3b8; }
        .season-compare-item.sci-positive { background: rgba(34, 197, 94, 0.10); border: 1px solid rgba(34, 197, 94, 0.30); }
        .season-compare-item.sci-negative { background: rgba(239, 68, 68, 0.10); border: 1px solid rgba(239, 68, 68, 0.30); }
        .season-compare-item.sci-neutral { background: rgba(100, 116, 139, 0.10); border: 1px solid rgba(100, 116, 139, 0.25); }
        .season-compare-item.sci-positive .season-compare-label { color: #86efac; }
        .season-compare-item.sci-negative .season-compare-label { color: #fca5a5; }
        .season-compare-item.sci-positive .scv-delta { color: #4ade80; font-size: 10px; }
        .season-compare-item.sci-negative .scv-delta { color: #f87171; font-size: 10px; }
        .season-compare-item.sci-neutral .scv-delta { color: #94a3b8; font-size: 10px; }
        .matchup-modal { max-width: 1200px; }
        .matchup-table { font-size: 12px; }
        .matchup-table th, .matchup-table td { padding: 8px 10px; }
        .lineup-row { cursor: pointer; transition: background 0.2s; }
        .lineup-row:hover { background: rgba(59, 130, 246, 0.2); }
        .lineup-row.selected { background: rgba(59, 130, 246, 0.3); border-left: 3px solid #60a5fa; }
        /* NEW: Shot Distribution Modal Styles */
        .shot-modal { max-width: 1000px; }
        .shot-breakdown-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 16px; }
        .shot-breakdown-card { background: rgba(0,0,0,0.3); border-radius: 12px; padding: 20px; text-align: center; }
        .shot-breakdown-title { font-size: 14px; font-weight: bold; margin-bottom: 12px; }
        .shot-breakdown-pct { font-size: 36px; font-weight: bold; margin-bottom: 4px; }
        .shot-breakdown-rate { font-size: 14px; opacity: 0.8; margin-bottom: 8px; }
        .shot-breakdown-attempts { font-size: 12px; opacity: 0.6; }
        .player-shot-table { margin-top: 24px; }
        .player-shot-table th { background: rgba(0,0,0,0.3); }
        /* NEW: Turnover Modal Styles */
        .to-modal { max-width: 900px; }
        .to-breakdown-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-top: 16px; }
        .to-breakdown-card { background: rgba(0,0,0,0.3); border-radius: 12px; padding: 16px; text-align: center; }
        .to-breakdown-title { font-size: 12px; font-weight: bold; margin-bottom: 8px; }
        .to-breakdown-count { font-size: 32px; font-weight: bold; margin-bottom: 4px; }
        .to-breakdown-rate { font-size: 13px; opacity: 0.8; }
        .clickable-section {
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .clickable-section:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
        }
        .clickable-section:active {
            transform: translateY(-1px);
        }
        .click-hint {
            font-size: 10px;
            opacity: 0.5;
            margin-left: 8px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            transition: opacity 0.2s ease;
        }
        .clickable-section:hover .click-hint { opacity: 0.8; }
        /* V3.9: Prominent Team Average Comparison Styles - Enhanced */
        .team-avg-summary {
            background: linear-gradient(145deg, rgba(251, 191, 36, 0.12) 0%, rgba(245, 158, 11, 0.06) 100%);
            border: 2px solid rgba(251, 191, 36, 0.35);
            border-radius: 16px;
            padding: 22px;
            margin-bottom: 24px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(251, 191, 36, 0.1);
        }
        .team-avg-summary::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #f59e0b, #fbbf24, #fcd34d);
        }
        .team-avg-summary-title {
            font-size: 18px;
            font-weight: 700;
            background: linear-gradient(135deg, #fbbf24 0%, #fcd34d 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(251, 191, 36, 0.2);
        }
        .team-avg-summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 12px;
        }
        .team-avg-item {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 14px;
            text-align: center;
            position: relative;
            transition: all 0.2s ease;
            border: 1px solid rgba(251, 191, 36, 0.15);
        }
        .team-avg-item:hover {
            transform: translateY(-2px);
            border-color: rgba(251, 191, 36, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .team-avg-item-name { font-size: 11px; opacity: 0.8; margin-bottom: 6px; font-weight: 600; }
        .team-avg-item-value { font-size: 22px; font-weight: bold; color: #60a5fa; }
        .team-avg-item-team { font-size: 12px; color: #fbbf24; margin-top: 4px; display: flex; align-items: center; justify-content: center; gap: 4px; }
        .team-avg-item-delta { font-size: 12px; font-weight: bold; padding: 3px 8px; border-radius: 6px; margin-top: 6px; display: inline-block; }
        .team-avg-better { background: rgba(34, 197, 94, 0.35); color: #4ade80; border: 1px solid rgba(34, 197, 94, 0.5); }
        .team-avg-worse { background: rgba(239, 68, 68, 0.35); color: #f87171; border: 1px solid rgba(239, 68, 68, 0.5); }
        .team-avg-same { background: rgba(148, 163, 184, 0.25); color: #cbd5e1; border: 1px solid rgba(148, 163, 184, 0.4); }
        .team-avg-bar { height: 8px; background: rgba(0,0,0,0.4); border-radius: 4px; margin-top: 8px; position: relative; overflow: visible; }
        .team-avg-bar-fill { height: 100%; border-radius: 4px; transition: width 0.3s; }
        .team-avg-bar-marker { position: absolute; top: -4px; width: 4px; height: 16px; background: #fbbf24; border-radius: 2px; transform: translateX(-50%); box-shadow: 0 0 4px rgba(251, 191, 36, 0.5); }
        .inline-team-avg { display: flex; align-items: center; gap: 6px; margin-top: 6px; padding: 4px 8px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.25); border-radius: 6px; }
        .inline-team-avg-label { font-size: 10px; color: #fbbf24; font-weight: 600; }
        .inline-team-avg-value { font-size: 12px; color: #94a3b8; }
        .inline-team-avg-delta { font-size: 11px; font-weight: bold; padding: 2px 6px; border-radius: 4px; }
        /* V4.0: Luck Adjustment Styles */
        input[type="range"] { -webkit-appearance: none; appearance: none; height: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; outline: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; border: none; }
        .luck-adj-section { background: rgba(251, 191, 36, 0.08); border: 1px solid rgba(251, 191, 36, 0.25); border-radius: 12px; padding: 20px; }
        /* V4.1: RAPM Section Styles - Enhanced */
        .rapm-section {
            background: linear-gradient(145deg, rgba(96, 165, 250, 0.1) 0%, rgba(139, 92, 246, 0.08) 100%);
            border: 2px solid rgba(96, 165, 250, 0.3);
            border-radius: 16px;
            padding: 24px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(96, 165, 250, 0.08);
        }
        .rapm-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #60a5fa, #8b5cf6, #a78bfa);
        }
        /* V4.2.1: Analyzer Subtabs - Enhanced */
        .analyzer-subtabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(15, 23, 42, 0.7);
            border: 1px solid rgba(51, 65, 85, 0.5);
            border-radius: 14px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .subtab-btn {
            padding: 10px 18px;
            border-radius: 10px;
            border: 2px solid transparent;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            background: rgba(71, 85, 105, 0.35);
            color: #94a3b8;
            position: relative;
            overflow: hidden;
        }
        .subtab-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.1));
            opacity: 0;
            transition: opacity 0.25s ease;
        }
        .subtab-btn:hover {
            background: rgba(71, 85, 105, 0.6);
            color: #e2e8f0;
            transform: translateY(-1px);
        }
        .subtab-btn:hover::before { opacity: 1; }
        .subtab-btn.active {
            background: linear-gradient(135deg, #2563eb, #7c3aed);
            color: white;
            border-color: rgba(255, 255, 255, 0.15);
            box-shadow: 0 4px 16px rgba(37, 99, 235, 0.35);
            transform: translateY(-1px);
        }
        .subtab-btn.active::before { opacity: 0; }
        /* V4.2.2: Opponent Quality Filter Styles - Enhanced */
        .opp-filter-panel {
            background: linear-gradient(180deg, rgba(139, 92, 246, 0.12) 0%, rgba(139, 92, 246, 0.06) 100%);
            border: 2px solid rgba(139, 92, 246, 0.35);
            border-radius: 16px;
            padding: 22px;
            margin-top: 24px;
            position: relative;
            overflow: hidden;
        }
        .opp-filter-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #8b5cf6, #a78bfa, #c4b5fd);
        }
        .opp-filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.2);
        }
        .opp-filter-title {
            font-size: 16px;
            font-weight: 700;
            background: linear-gradient(135deg, #a78bfa 0%, #c4b5fd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .opp-filter-row { display: flex; gap: 12px; align-items: center; margin-bottom: 12px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; flex-wrap: wrap; }
        .opp-filter-select { padding: 8px 12px; background: #1e293b; border: 1px solid #475569; border-radius: 6px; color: white; font-size: 13px; min-width: 140px; }
        .opp-filter-input { padding: 8px 12px; background: #1e293b; border: 1px solid #475569; border-radius: 6px; color: white; font-size: 13px; width: 80px; text-align: center; }
        .opp-filter-remove { background: #dc2626; color: white; border: none; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; }
        .opp-filter-add { background: rgba(139, 92, 246, 0.3); border: 2px dashed rgba(139, 92, 246, 0.5); color: #a78bfa; padding: 10px 16px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 13px; transition: all 0.2s; }
        .opp-filter-add:hover { background: rgba(139, 92, 246, 0.5); border-color: #a78bfa; }
        .opp-filter-badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; background: rgba(139, 92, 246, 0.3); border: 1px solid rgba(139, 92, 246, 0.5); border-radius: 20px; font-size: 11px; color: #c4b5fd; }
        .opp-filter-active-indicator { background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(168, 85, 247, 0.1)); border: 2px solid rgba(139, 92, 246, 0.5); border-radius: 8px; padding: 12px 16px; margin-bottom: 16px; }
        .rapm-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px; }
        .rapm-stat-grid { display: grid; gap: 8px; }
        .rapm-stat-card { background: rgba(0,0,0,0.15); border-radius: 8px; padding: 12px; text-align: center; transition: transform 0.2s, box-shadow 0.2s; }
        .rapm-stat-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .rapm-raw { color: #94a3b8; }
        .rapm-adj { color: #60a5fa; font-weight: bold; }
        .rapm-delta-positive { color: #4ade80; }
        .rapm-delta-negative { color: #f87171; }
        .rapm-delta-neutral { color: #94a3b8; }
        /* V4.2: Tab Navigation - Enhanced Material-inspired Design */
        .tab-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 24px;
            background: rgba(15, 23, 42, 0.7);
            padding: 8px;
            border-radius: 16px;
            border: 1px solid rgba(71, 85, 105, 0.3);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .tab-btn {
            padding: 12px 20px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            background: transparent;
            color: #94a3b8;
            position: relative;
            overflow: hidden;
            letter-spacing: 0.01em;
        }
        .tab-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.1), rgba(139, 92, 246, 0.1));
            opacity: 0;
            transition: opacity 0.25s ease;
            border-radius: 10px;
        }
        .tab-btn:hover {
            background: rgba(59, 130, 246, 0.12);
            color: #93c5fd;
            transform: translateY(-1px);
        }
        .tab-btn:hover::before { opacity: 1; }
        .tab-btn.active {
            background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
            color: white;
            box-shadow: 0 4px 16px rgba(37, 99, 235, 0.35), 0 2px 4px rgba(0, 0, 0, 0.2);
            transform: translateY(-1px);
        }
        .tab-btn.active::before { opacity: 0; }
        /* V4.2: WOWY Styles - Enhanced */
        .wowy-container {
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.6) 0%, rgba(30, 41, 59, 0.4) 100%);
            border: 1px solid rgba(71, 85, 105, 0.4);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }
        .wowy-header {
            padding: 20px 24px;
            border-bottom: 1px solid rgba(71, 85, 105, 0.4);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(59, 130, 246, 0.08) 0%, transparent 100%);
        }
        .wowy-title {
            font-size: 18px;
            font-weight: 700;
            background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .wowy-subtitle { font-size: 12px; color: #94a3b8; margin-top: 4px; }
        .wowy-table { width: 100%; }
        .wowy-table th {
            padding: 14px 16px;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: rgba(15, 23, 42, 0.7);
        }
        .wowy-table th:first-child { text-align: left; }
        .wowy-table td {
            padding: 16px;
            border-bottom: 1px solid rgba(71, 85, 105, 0.3);
            transition: background-color 0.15s ease;
        }
        .wowy-table tr:hover { background: rgba(59, 130, 246, 0.1); }
        .wowy-lineup-cell { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .wowy-player-badge {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 72px;
            padding: 8px 4px;
            border-radius: var(--radius-md);
            transition: all var(--duration-fast) var(--ease-out);
        }
        .wowy-player-badge:hover {
            background: rgba(255, 255, 255, 0.03);
            transform: translateY(-2px);
        }
        .wowy-player-img {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: linear-gradient(145deg, #1e293b 0%, #334155 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            color: #60a5fa;
            border: 3px solid #475569;
            position: relative;
            transition: all var(--duration-normal) var(--ease-out);
            box-shadow: var(--elevation-2);
        }
        .wowy-player-img:hover {
            transform: scale(1.08);
            box-shadow: var(--elevation-3);
        }
        .wowy-player-img.on {
            border-color: #22c55e;
            box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.2), 0 4px 12px rgba(34, 197, 94, 0.3);
        }
        .wowy-player-img.off {
            border-color: #ef4444;
            opacity: 0.5;
            filter: grayscale(30%);
        }
        .wowy-status-badge {
            position: absolute;
            bottom: -4px;
            right: -4px;
            font-size: 8px;
            font-weight: 700;
            padding: 3px 7px;
            border-radius: var(--radius-full);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: var(--elevation-2);
        }
        .wowy-status-badge.on {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
        }
        .wowy-status-badge.off {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        .wowy-player-name {
            font-size: 10px;
            font-weight: 500;
            color: #cbd5e1;
            text-align: center;
            max-width: 72px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            line-height: 1.3;
        }
        .wowy-stat {
            text-align: center;
            font-weight: 600;
            padding: 8px 12px;
            border-radius: var(--radius-sm);
            transition: background-color var(--duration-fast) var(--ease-out);
        }
        .wowy-stat:hover {
            background: rgba(255, 255, 255, 0.03);
        }
        .wowy-stat-main {
            font-size: 18px;
            font-weight: 700;
            font-family: var(--font-mono);
        }
        .wowy-stat-sub {
            font-size: 11px;
            margin-top: 4px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            padding: 2px 6px;
            border-radius: var(--radius-sm);
        }
        .wowy-stat-sub.positive {
            color: #4ade80;
            background: rgba(34, 197, 94, 0.1);
        }
        .wowy-stat-sub.positive::before {
            content: '+';
        }
        .wowy-stat-sub.negative {
            color: #f87171;
            background: rgba(239, 68, 68, 0.1);
        }
        .wowy-net-positive {
            color: #4ade80;
            text-shadow: 0 0 20px rgba(34, 197, 94, 0.4);
        }
        .wowy-net-negative {
            color: #f87171;
            text-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
        }
        /* WOWY Player Selector */
        .wowy-selector { padding: 20px 24px; border-top: 1px solid #475569; background: rgba(15, 23, 42, 0.4); }
        .wowy-selector-title { font-size: 14px; font-weight: 600; color: #94a3b8; margin-bottom: 16px; }
        .wowy-player-grid { display: flex; flex-wrap: wrap; gap: 12px; }
        .wowy-player-select { display: flex; flex-direction: column; align-items: center; gap: 6px; cursor: pointer; padding: 8px; border-radius: 8px; transition: all 0.2s; border: 2px solid transparent; min-width: 80px; }
        .wowy-player-select:hover { background: rgba(59, 130, 246, 0.1); }
        .wowy-player-select.selected { background: rgba(34, 197, 94, 0.15); border-color: rgba(34, 197, 94, 0.5); }
        .wowy-player-select .wowy-player-img { width: 52px; height: 52px; font-size: 16px; }
        .wowy-player-select .wowy-player-name { font-size: 11px; color: #e2e8f0; }
        .wowy-min-filter { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
        .wowy-min-filter label { font-size: 13px; color: #94a3b8; }
        .wowy-min-filter input { width: 80px; padding: 8px; background: #0f172a; border: 1px solid #475569; border-radius: 6px; color: white; font-size: 13px; }
        .wowy-empty {
            padding: 80px 40px;
            text-align: center;
            color: #64748b;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.3), transparent);
            border-radius: var(--radius-lg);
            border: 2px dashed rgba(71, 85, 105, 0.3);
            margin: 20px;
        }
        .wowy-empty-icon {
            font-size: 56px;
            margin-bottom: 20px;
            opacity: 0.6;
            animation: float 3s ease-in-out infinite;
        }
        .wowy-empty-title {
            font-size: var(--text-lg);
            font-weight: 600;
            color: #94a3b8;
            margin-bottom: 8px;
        }
        .wowy-empty-description {
            font-size: var(--text-sm);
            color: #64748b;
            max-width: 300px;
            margin: 0 auto;
            line-height: var(--line-height-relaxed);
        }
        .wowy-ff-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 8px; }
        .wowy-ff-item { background: rgba(0,0,0,0.2); padding: 6px 8px; border-radius: 4px; text-align: center; }
        .wowy-ff-label { font-size: 9px; color: #94a3b8; margin-bottom: 2px; }
        .wowy-ff-value { font-size: 12px; font-weight: 600; }

        /* V4.4: Comparison Tab Styles - Enhanced */
        .compare-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }
        .compare-panel {
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.6) 0%, rgba(30, 41, 59, 0.4) 100%);
            border: 2px solid rgba(71, 85, 105, 0.4);
            border-radius: 16px;
            padding: 22px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .compare-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .compare-panel:hover::before { opacity: 1; }
        .compare-panel.team-a {
            border-color: rgba(59, 130, 246, 0.4);
            background: linear-gradient(180deg, rgba(59, 130, 246, 0.1) 0%, rgba(59, 130, 246, 0.03) 100%);
        }
        .compare-panel.team-a::before {
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
        }
        .compare-panel.team-a:hover {
            border-color: rgba(59, 130, 246, 0.6);
            box-shadow: 0 8px 24px rgba(59, 130, 246, 0.15);
        }
        .compare-panel.team-b {
            border-color: rgba(168, 85, 247, 0.4);
            background: linear-gradient(180deg, rgba(168, 85, 247, 0.1) 0%, rgba(168, 85, 247, 0.03) 100%);
        }
        .compare-panel.team-b::before {
            background: linear-gradient(90deg, #a855f7, #c084fc);
        }
        .compare-panel.team-b:hover {
            border-color: rgba(168, 85, 247, 0.6);
            box-shadow: 0 8px 24px rgba(168, 85, 247, 0.15);
        }
        .compare-panel-header {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(71, 85, 105, 0.3);
        }
        .compare-panel-header.team-a {
            color: #60a5fa;
            border-bottom-color: rgba(59, 130, 246, 0.3);
        }
        .compare-panel-header.team-b {
            color: #c084fc;
            border-bottom-color: rgba(168, 85, 247, 0.3);
        }
        .compare-player-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; margin-top: 12px; }
        .compare-player-slot { background: #0d1117; border: 2px dashed #475569; border-radius: 8px; padding: 10px; text-align: center; min-height: 60px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; }
        .compare-player-slot:hover { border-color: #60a5fa; background: #1e3a5f; }
        .compare-player-slot.filled { border-style: solid; border-color: #22c55e; background: rgba(34, 197, 94, 0.1); }
        .compare-player-slot .player-name { font-size: 11px; font-weight: 600; color: #e2e8f0; }
        .compare-player-slot .player-team { font-size: 9px; color: #94a3b8; margin-top: 2px; }
        .compare-player-slot .remove-btn { font-size: 10px; color: #ef4444; cursor: pointer; margin-top: 4px; }
        .compare-results { margin-top: 24px; }
        .compare-section { background: rgba(30, 41, 59, 0.5); border: 1px solid #475569; border-radius: 12px; padding: 20px; margin-bottom: 20px; }
        .compare-section-title { font-size: 16px; font-weight: bold; margin-bottom: 16px; color: #fbbf24; }
        .compare-stat-row { display: grid; grid-template-columns: 1fr 120px 80px 120px 1fr; gap: 8px; align-items: center; padding: 10px 0; border-bottom: 1px solid rgba(71, 85, 105, 0.3); }
        .compare-stat-row:last-child { border-bottom: none; }
        .compare-stat-value { font-size: 18px; font-weight: bold; }
        .compare-stat-value.team-a { color: #60a5fa; text-align: right; }
        .compare-stat-value.team-b { color: #c084fc; text-align: left; }
        .compare-stat-name { font-size: 12px; color: #94a3b8; text-align: center; font-weight: 600; }
        .compare-stat-bar { height: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; position: relative; overflow: hidden; }
        .compare-stat-bar-fill { height: 100%; border-radius: 4px; }
        .compare-stat-bar-fill.team-a { background: #3b82f6; }
        .compare-stat-bar-fill.team-b { background: #a855f7; }
        .compare-advantage { font-size: 11px; font-weight: bold; padding: 3px 8px; border-radius: 4px; text-align: center; }
        .compare-advantage.team-a { background: rgba(59, 130, 246, 0.3); color: #93c5fd; }
        .compare-advantage.team-b { background: rgba(168, 85, 247, 0.3); color: #d8b4fe; }
        .compare-advantage.neutral { background: rgba(100, 116, 139, 0.3); color: #cbd5e1; }
        .compare-shot-dist { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px; }
        .compare-shot-panel { background: rgba(0,0,0,0.15); border-radius: 8px; padding: 12px; }
        .compare-shot-title { font-size: 12px; font-weight: 600; margin-bottom: 8px; }
        .compare-shot-title.team-a { color: #60a5fa; }
        .compare-shot-title.team-b { color: #c084fc; }
        .compare-to-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 12px; }
        .compare-to-item { background: rgba(0,0,0,0.2); border-radius: 6px; padding: 8px; text-align: center; }
        .compare-to-label { font-size: 10px; color: #94a3b8; margin-bottom: 4px; }
        .compare-to-value { font-size: 14px; font-weight: bold; }
        .compare-lineup-picker { margin-top: 16px; }
        .compare-lineup-picker-title { font-size: 13px; font-weight: 600; margin-bottom: 8px; color: #94a3b8; }
        .compare-lineup-list { max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 8px; }
        .compare-lineup-item { padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #334155; display: flex; justify-content: space-between; align-items: center; }
        .compare-lineup-item:hover { background: #1e3a5f; }
        .compare-lineup-item.selected { background: rgba(34, 197, 94, 0.2); }
        .compare-lineup-item .lineup-name { font-size: 12px; color: #e2e8f0; flex: 1; }
        .compare-lineup-item .lineup-poss { font-size: 11px; color: #94a3b8; margin-left: 8px; }
        .compare-summary-card { background: #1f1a0f; border: 2px solid #5c4a1e; border-radius: 12px; padding: 20px; margin-bottom: 20px; }
        .compare-summary-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 16px; }
        .compare-summary-item { text-align: center; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; }
        .compare-summary-label { font-size: 11px; color: #94a3b8; margin-bottom: 6px; }
        .compare-summary-values { display: flex; justify-content: center; gap: 12px; align-items: baseline; }
        .compare-summary-value { font-size: 20px; font-weight: bold; }
        .compare-summary-value.team-a { color: #60a5fa; }
        .compare-summary-value.team-b { color: #c084fc; }
        .compare-summary-diff { font-size: 12px; font-weight: bold; padding: 2px 8px; border-radius: 4px; margin-left: 8px; }
        .compare-trans-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; }
        .compare-trans-card { background: rgba(0,0,0,0.15); border-radius: 8px; padding: 12px; }
        .compare-trans-title { font-size: 12px; font-weight: 600; margin-bottom: 8px; color: #22d3ee; }
        
        /* V5.0: Export View Styles - Enhanced */
        .export-view-container { display: none; }
        .export-view-container.active { display: block; animation: fadeIn 0.3s ease-out; }
        .export-controls {
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.85) 0%, rgba(30, 41, 59, 0.7) 100%);
            border: 1px solid rgba(71, 85, 105, 0.4);
            border-radius: 16px;
            padding: 22px;
            margin-bottom: 24px;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: flex-end;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }
        .export-control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .export-control-group label {
            font-size: 10px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            font-weight: 600;
        }
        .export-control-group select,
        .export-control-group input {
            padding: 10px 14px;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 10px;
            color: white;
            font-size: 13px;
            min-width: 150px;
            transition: all 0.2s ease;
        }
        .export-control-group select:hover,
        .export-control-group input:hover {
            border-color: rgba(96, 165, 250, 0.4);
        }
        .export-control-group select:focus,
        .export-control-group input:focus {
            outline: none;
            border-color: var(--theme-primary);
            box-shadow: 0 0 0 3px rgba(var(--theme-primary-rgb), 0.15);
        }
        .export-btn {
            padding: 10px 22px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        .export-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
            transition: left 0.4s ease;
        }
        .export-btn:hover::before { left: 100%; }
        .export-btn-primary {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.25);
        }
        .export-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(245, 158, 11, 0.35);
        }
        .export-btn-secondary {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        .export-btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
        }
        .export-btn-back {
            background: rgba(239, 68, 68, 0.15);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .export-btn-back:hover {
            background: rgba(239, 68, 68, 0.25);
            border-color: rgba(239, 68, 68, 0.5);
        }
        
        /* Export Frame - Instagram/Social Media Ready - Enhanced */
        .export-frame {
            background: linear-gradient(145deg, #0a0f1a 0%, #151d2e 50%, #0a0f1a 100%);
            border: 1px solid rgba(51, 65, 85, 0.5);
            border-radius: 20px;
            padding: 36px;
            min-height: 500px;
            position: relative;
            max-width: 1200px;
            margin: 0 auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }
        .export-frame::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #ec4899, #f59e0b);
            border-radius: 20px 20px 0 0;
        }
        .export-frame-header {
            text-align: center;
            margin-bottom: 32px;
            padding-bottom: 24px;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            position: relative;
        }
        .export-frame-title {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            font-size: 32px;
            font-weight: 800;
            background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 40%, #f472b6 80%, #fbbf24 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: gradientShift 4s ease infinite;
        }
        .export-frame-subtitle {
            font-size: 13px;
            color: #94a3b8;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        .export-frame-footer {
            text-align: center;
            margin-top: 32px;
            padding-top: 20px;
            border-top: 1px solid rgba(71, 85, 105, 0.3);
        }
        .export-frame-branding {
            font-size: 10px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: 600;
        }
        
        /* Export Cards Grid */
        .export-cards-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 16px; }
        .export-player-card { background: linear-gradient(145deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.95)); border: 1px solid #475569; border-radius: 12px; padding: 16px; transition: all 0.2s; position: relative; overflow: hidden; }
        .export-player-card:hover { border-color: #60a5fa; transform: translateY(-2px); }
        .export-player-card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px; background: linear-gradient(90deg, #3b82f6, #8b5cf6); }
        .export-card-rank { position: absolute; top: 8px; right: 8px; width: 28px; height: 28px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 800; color: white; }
        .export-card-header { margin-bottom: 12px; padding-right: 35px; }
        .export-card-name { font-size: 14px; font-weight: 700; color: #e2e8f0; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .export-card-team { font-size: 11px; color: #60a5fa; font-weight: 600; }
        .export-card-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .export-card-stat { background: rgba(0, 0, 0, 0.25); border-radius: 6px; padding: 8px; text-align: center; }
        .export-card-stat-label { font-size: 9px; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 3px; }
        .export-card-stat-value { font-size: 16px; font-weight: 700; }
        .export-card-stat-value.positive { color: #4ade80; }
        .export-card-stat-value.negative { color: #f87171; }
        .export-card-stat-value.neutral { color: #94a3b8; }
        
        /* Export Four Factors Card */
        .export-ff-container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
        .export-ff-panel { background: rgba(30, 41, 59, 0.8); border-radius: 12px; padding: 24px; }
        .export-ff-panel.offense { border: 2px solid rgba(34, 197, 94, 0.4); }
        .export-ff-panel.defense { border: 2px solid rgba(239, 68, 68, 0.4); }
        .export-ff-title { font-size: 18px; font-weight: 700; margin-bottom: 16px; display: flex; align-items: center; gap: 8px; }
        .export-ff-title.offense { color: #4ade80; }
        .export-ff-title.defense { color: #f87171; }
        .export-ff-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
        .export-ff-item { background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 16px; text-align: center; position: relative; overflow: hidden; }
        .export-ff-item::before { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 4px; }
        .export-ff-item.excellent::before { background: linear-gradient(90deg, #22c55e, #4ade80); }
        .export-ff-item.good::before { background: linear-gradient(90deg, #84cc16, #a3e635); }
        .export-ff-item.average::before { background: linear-gradient(90deg, #eab308, #facc15); }
        .export-ff-item.below::before { background: linear-gradient(90deg, #f97316, #fb923c); }
        .export-ff-item.poor::before { background: linear-gradient(90deg, #ef4444, #f87171); }
        .export-ff-label { font-size: 12px; color: #94a3b8; margin-bottom: 6px; font-weight: 600; }
        .export-ff-value { font-size: 28px; font-weight: 800; color: #e2e8f0; }
        .export-ff-pct { font-size: 11px; color: #64748b; margin-top: 4px; }
        
        /* Export Shot Distribution */
        .export-shot-container { background: rgba(30, 41, 59, 0.8); border-radius: 12px; padding: 24px; }
        .export-shot-bar { display: flex; height: 60px; border-radius: 10px; overflow: hidden; background: rgba(15, 23, 42, 0.5); margin-bottom: 16px; }
        .export-shot-segment { display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: 700; color: white; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); min-width: 60px; }
        .export-shot-segment-value { font-size: 18px; }
        .export-shot-segment-label { font-size: 10px; opacity: 0.9; }
        .export-shot-segment.rim { background: linear-gradient(135deg, #dc2626, #ef4444); }
        .export-shot-segment.mid { background: linear-gradient(135deg, #ea580c, #f97316); }
        .export-shot-segment.three { background: linear-gradient(135deg, #2563eb, #3b82f6); }
        .export-shot-details { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
        .export-shot-detail { background: rgba(0, 0, 0, 0.25); border-radius: 8px; padding: 12px; text-align: center; }
        .export-shot-detail-title { font-size: 11px; color: #64748b; margin-bottom: 8px; font-weight: 600; text-transform: uppercase; }
        .export-shot-detail-stats { display: flex; justify-content: center; gap: 16px; }
        .export-shot-detail-stat { }
        .export-shot-detail-stat-value { font-size: 20px; font-weight: 700; }
        .export-shot-detail-stat-label { font-size: 9px; color: #94a3b8; }
        
        /* Export Lineup Card */
        .export-lineup-card { background: linear-gradient(145deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.98)); border: 2px solid #475569; border-radius: 16px; padding: 24px; margin-bottom: 16px; position: relative; overflow: hidden; }
        .export-lineup-card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 4px; background: linear-gradient(90deg, #3b82f6, #8b5cf6, #ec4899); }
        .export-lineup-rank { position: absolute; top: 16px; right: 16px; width: 40px; height: 40px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: 800; color: white; box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3); }
        .export-lineup-players { display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 20px; padding-right: 50px; }
        .export-lineup-player { display: flex; flex-direction: column; align-items: center; gap: 6px; }
        .export-lineup-player-avatar { width: 48px; height: 48px; border-radius: 50%; background: linear-gradient(135deg, #1e293b, #334155); display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: 700; color: #60a5fa; border: 2px solid #475569; }
        .export-lineup-player-name { font-size: 10px; color: #cbd5e1; text-align: center; max-width: 60px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .export-lineup-stats { display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; }
        .export-lineup-stat { background: rgba(0, 0, 0, 0.3); border-radius: 8px; padding: 12px; text-align: center; }
        .export-lineup-stat-value { font-size: 22px; font-weight: 800; margin-bottom: 4px; }
        .export-lineup-stat-label { font-size: 10px; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; }
        
        /* Export WOWY Card */
        .export-wowy-container { background: rgba(30, 41, 59, 0.8); border-radius: 12px; padding: 24px; }
        .export-wowy-header { display: flex; align-items: center; gap: 16px; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px solid #475569; }
        .export-wowy-player-avatar { width: 64px; height: 64px; border-radius: 50%; background: linear-gradient(135deg, #1e293b, #334155); display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: 700; color: #60a5fa; border: 3px solid #60a5fa; }
        .export-wowy-player-info { }
        .export-wowy-player-name { font-size: 24px; font-weight: 700; color: #e2e8f0; }
        .export-wowy-player-team { font-size: 14px; color: #94a3b8; }
        .export-wowy-table { width: 100%; border-collapse: separate; border-spacing: 0 8px; }
        .export-wowy-table th { font-size: 11px; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; padding: 8px 12px; text-align: center; }
        .export-wowy-table th:first-child { text-align: left; }
        .export-wowy-table td { background: rgba(0, 0, 0, 0.2); padding: 12px; text-align: center; }
        .export-wowy-table td:first-child { border-radius: 8px 0 0 8px; text-align: left; }
        .export-wowy-table td:last-child { border-radius: 0 8px 8px 0; }
        .export-wowy-row.on td { background: rgba(34, 197, 94, 0.15); }
        .export-wowy-row.off td { background: rgba(239, 68, 68, 0.1); }
        .export-wowy-status { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 20px; font-size: 11px; font-weight: 600; }
        .export-wowy-status.on { background: rgba(34, 197, 94, 0.3); color: #4ade80; }
        .export-wowy-status.off { background: rgba(239, 68, 68, 0.3); color: #f87171; }
        
        /* Export Mode Tabs */
        .export-mode-tabs { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 20px; padding: 12px; background: rgba(15, 23, 42, 0.6); border: 1px solid #334155; border-radius: 10px; }
        .export-mode-tab { padding: 10px 18px; border-radius: 8px; border: 2px solid transparent; cursor: pointer; font-weight: 600; font-size: 13px; transition: all 0.2s; background: rgba(71, 85, 105, 0.4); color: #94a3b8; }
        .export-mode-tab:hover { background: rgba(71, 85, 105, 0.7); color: white; }
        .export-mode-tab.active { background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border-color: rgba(255,255,255,0.2); box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3); }
        
        /* Percentile color classes for export */
        .pct-90 { color: #22c55e !important; }
        .pct-80 { color: #4ade80 !important; }
        .pct-70 { color: #84cc16 !important; }
        .pct-60 { color: #a3e635 !important; }
        .pct-50 { color: #fbbf24 !important; }
        .pct-40 { color: #f59e0b !important; }
        .pct-30 { color: #f97316 !important; }
        .pct-20 { color: #fb923c !important; }
        .pct-10 { color: #ef4444 !important; }
        
        /* V5.1: Enhanced Export Player Cards - Screenshot Style */
        .export-cards-grid-v2 { display: grid; grid-template-columns: repeat(5, 1fr); gap: 14px; }
        @media (max-width: 1200px) { .export-cards-grid-v2 { grid-template-columns: repeat(4, 1fr); } }
        @media (max-width: 900px) { .export-cards-grid-v2 { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 600px) { .export-cards-grid-v2 { grid-template-columns: repeat(2, 1fr); } }
        
        .export-card-v2 {
            background: linear-gradient(145deg, rgba(20, 27, 45, 0.98), rgba(15, 23, 42, 0.98));
            border: 2px solid rgba(30, 58, 95, 0.7);
            border-radius: var(--radius-lg);
            padding: 16px;
            position: relative;
            overflow: hidden;
            transition: all var(--duration-normal) var(--ease-out);
            box-shadow: var(--elevation-2);
        }
        .export-card-v2::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 3px;
            background: linear-gradient(90deg, #00d4ff, #8b5cf6, #ec4899);
            background-size: 200% 100%;
            animation: gradientShift 4s ease infinite;
        }
        .export-card-v2::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 0%, rgba(0, 212, 255, 0.08), transparent 50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--duration-normal) var(--ease-out);
        }
        .export-card-v2:hover {
            border-color: rgba(0, 212, 255, 0.6);
            transform: translateY(-4px);
            box-shadow: var(--elevation-4), 0 0 30px rgba(0, 212, 255, 0.15);
        }
        .export-card-v2:hover::after {
            opacity: 1;
        }
        
        .export-card-v2-header { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            margin-bottom: 12px; 
            padding-bottom: 10px; 
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
        }
        .export-card-v2-photo { 
            width: 44px; height: 44px; 
            border-radius: 50%; 
            background: linear-gradient(135deg, #21262d, #30363d); 
            border: 2px solid #484f58; 
            display: flex; align-items: center; justify-content: center; 
            overflow: hidden; 
            flex-shrink: 0;
            cursor: pointer;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .export-card-v2-photo img { width: 100%; height: 100%; object-fit: cover; }
        .export-card-v2-photo:not(:has(img))::before { content: '📷'; font-size: 16px; }
        .export-card-v2-photo:hover { border-color: #00d4ff; box-shadow: 0 0 15px rgba(0, 212, 255, 0.4); }
        
        .export-card-v2-info { flex: 1; min-width: 0; }
        .export-card-v2-name { 
            font-size: 13px; font-weight: 700; color: #ffffff; 
            margin-bottom: 2px; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5); 
            line-height: 1.2; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .export-card-v2-team { 
            display: inline-block; 
            font-size: 10px; 
            color: #00d4ff; 
            background: rgba(0, 212, 255, 0.2); 
            padding: 2px 8px; 
            border-radius: 4px; 
            font-weight: 600; 
            text-transform: uppercase; 
            letter-spacing: 0.5px;
        }
        .export-card-v2-meta { font-size: 9px; color: #6e7681; margin-top: 2px; }
        
        /* Stat Categories */
        .export-card-v2-stats { display: flex; flex-direction: column; gap: 5px; margin-bottom: 12px; }
        .export-card-v2-stat-row { 
            display: flex; gap: 4px; padding: 6px 8px; 
            background: rgba(13, 17, 23, 0.6); 
            border-radius: 6px; 
            border-left: 3px solid #30363d;
        }
        .export-card-v2-stat-row.efficiency { border-left-color: #00d4ff; background: rgba(0, 212, 255, 0.05); }
        .export-card-v2-stat-row.shooting { border-left-color: #8b5cf6; background: rgba(139, 92, 246, 0.05); }
        .export-card-v2-stat-row.freethrows { border-left-color: #f59e0b; background: rgba(245, 158, 11, 0.05); }
        .export-card-v2-stat-row.rebounding { border-left-color: #10b981; background: rgba(16, 185, 129, 0.05); }
        .export-card-v2-stat-row.playmaking { border-left-color: #ec4899; background: rgba(236, 72, 153, 0.05); }
        .export-card-v2-stat-row.defense { border-left-color: #ef4444; background: rgba(239, 68, 68, 0.05); }
        
        .export-card-v2-stat { display: flex; flex-direction: column; align-items: center; flex: 1; min-width: 0; }
        .export-card-v2-stat-label { font-size: 7px; color: #6e7681; font-weight: 600; text-transform: uppercase; margin-bottom: 1px; }
        .export-card-v2-stat-value { font-size: 11px; font-weight: 700; color: #e6edf3; }
        .export-card-v2-stat-value[class*="pct-"] { background: transparent !important; }
        
        /* BPM Section */
        .export-card-v2-bpm { 
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(139, 92, 246, 0.1)); 
            border-radius: 8px; 
            padding: 10px; 
            margin-top: auto; 
            border: 1px solid rgba(0, 212, 255, 0.2);
        }
        .export-card-v2-bpm-title { 
            font-size: 7px; color: #00d4ff; text-transform: uppercase; 
            letter-spacing: 1.5px; margin-bottom: 6px; text-align: center; font-weight: 700;
        }
        .export-card-v2-bpm-values { display: flex; justify-content: center; gap: 10px; }
        .export-card-v2-bpm-item { text-align: center; flex: 1; }
        .export-card-v2-bpm-label { font-size: 7px; color: #8b949e; text-transform: uppercase; margin-bottom: 2px; font-weight: 600; }
        .export-card-v2-bpm-value { font-size: 16px; font-weight: 800; color: #e6edf3; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
        
        /* WOWY Player Selector Grid (circular buttons) */
        .export-wowy-player-grid { display: flex; flex-wrap: wrap; gap: 12px; padding: 16px; background: rgba(15, 23, 42, 0.6); border-radius: 10px; }
        .export-wowy-player-btn { 
            display: flex; flex-direction: column; align-items: center; gap: 6px; 
            cursor: pointer; transition: all 0.2s;
        }
        .export-wowy-player-btn:hover .export-wowy-player-circle { border-color: #60a5fa; transform: scale(1.05); }
        .export-wowy-player-btn.selected .export-wowy-player-circle { 
            border-color: #22c55e; background: linear-gradient(135deg, rgba(34, 197, 94, 0.3), rgba(34, 197, 94, 0.1)); 
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.4);
        }
        .export-wowy-player-circle { 
            width: 48px; height: 48px; border-radius: 50%; 
            background: linear-gradient(135deg, #1e293b, #334155); 
            border: 2px solid #475569; 
            display: flex; align-items: center; justify-content: center; 
            font-size: 14px; font-weight: 700; color: #94a3b8; 
            transition: all 0.2s;
        }
        .export-wowy-player-btn.selected .export-wowy-player-circle { color: #4ade80; }
        .export-wowy-player-name-label { 
            font-size: 10px; color: #94a3b8; max-width: 60px; 
            text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .export-wowy-player-btn.selected .export-wowy-player-name-label { color: #4ade80; }
        
        /* Player Filter Dropdowns */
        .export-player-filters { display: flex; gap: 8px; flex-wrap: wrap; align-items: flex-end; }
        .export-player-filter { display: flex; flex-direction: column; gap: 4px; }
        .export-player-filter label { font-size: 9px; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; }
        .export-player-filter select { 
            padding: 8px 10px; background: #0f172a; border: 1px solid #475569; 
            border-radius: 6px; color: white; font-size: 12px; min-width: 130px; 
        }
        
        /* Toggle Switch for Individual/On-Off */
        .export-toggle-container { display: flex; align-items: center; gap: 12px; padding: 8px 16px; background: rgba(15, 23, 42, 0.6); border-radius: 8px; }
        .export-toggle-label { font-size: 12px; color: #94a3b8; }
        .export-toggle-label.active { color: #f59e0b; font-weight: 600; }
        .export-toggle { 
            width: 48px; height: 24px; background: #1e293b; border-radius: 12px; 
            position: relative; cursor: pointer; transition: all 0.2s;
            border: 1px solid #475569;
        }
        .export-toggle.active { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .export-toggle::after { 
            content: ''; position: absolute; 
            top: 2px; left: 2px; width: 18px; height: 18px; 
            background: white; border-radius: 50%; 
            transition: all 0.2s;
        }
        .export-toggle.active::after { left: 26px; }
        
        /* V5.2: Enhanced Four Factors Team Cards */
        .export-ff-team-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px; }
        .export-ff-team-card {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.95), rgba(20, 27, 45, 0.95));
            border: 2px solid #1e3a5f;
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        .export-ff-team-card:hover { transform: translateY(-3px); box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4); }
        .export-ff-team-card-header {
            display: flex; align-items: center; gap: 14px;
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(139, 92, 246, 0.1));
            border-bottom: 1px solid rgba(59, 130, 246, 0.3);
        }
        .export-ff-team-logo {
            width: 50px; height: 50px; border-radius: 50%;
            background: linear-gradient(135deg, #1e293b, #334155);
            border: 2px solid #475569;
            display: flex; align-items: center; justify-content: center;
            font-size: 16px; font-weight: 700; color: #94a3b8;
            overflow: hidden; cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .export-ff-team-logo img { width: 100%; height: 100%; object-fit: cover; }
        .export-ff-team-logo:hover { border-color: #60a5fa; }
        .export-ff-team-name { font-size: 18px; font-weight: 700; color: #ffffff; }
        .export-ff-team-meta { font-size: 11px; color: #94a3b8; margin-top: 2px; }
        .export-ff-team-rank { 
            margin-left: auto; font-size: 24px; font-weight: 800; 
            padding: 8px 16px; border-radius: 8px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(139, 92, 246, 0.2));
        }
        
        .export-ff-team-stats {
            display: grid; grid-template-columns: 1fr 1fr; gap: 2px;
            padding: 12px;
        }
        .export-ff-team-section {
            padding: 12px;
            border-radius: 10px;
        }
        .export-ff-team-section.offense { background: rgba(34, 197, 94, 0.08); }
        .export-ff-team-section.defense { background: rgba(239, 68, 68, 0.08); }
        .export-ff-team-section-title {
            font-size: 12px; font-weight: 700; text-transform: uppercase;
            letter-spacing: 1px; margin-bottom: 10px;
        }
        .export-ff-team-section.offense .export-ff-team-section-title { color: #4ade80; }
        .export-ff-team-section.defense .export-ff-team-section-title { color: #f87171; }
        
        .export-ff-stat-box {
            padding: 10px 12px; border-radius: 8px; margin-bottom: 8px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .export-ff-stat-box.perf-excellent { background: rgba(var(--perf-excellent-rgb), 0.3); border-left: 4px solid var(--perf-excellent); }
        .export-ff-stat-box.perf-good { background: rgba(var(--perf-good-rgb), 0.25); border-left: 4px solid var(--perf-good); }
        .export-ff-stat-box.perf-average { background: rgba(var(--perf-average-rgb), 0.2); border-left: 4px solid var(--perf-average); }
        .export-ff-stat-box.perf-below { background: rgba(var(--perf-below-rgb), 0.25); border-left: 4px solid var(--perf-below); }
        .export-ff-stat-box.perf-poor { background: rgba(var(--perf-poor-rgb), 0.3); border-left: 4px solid var(--perf-poor); }
        .export-ff-stat-label { font-size: 11px; color: #94a3b8; text-transform: uppercase; }
        .export-ff-stat-value { font-size: 22px; font-weight: 800; color: #ffffff; }
        .export-ff-stat-rank { 
            font-size: 11px; font-weight: 700; padding: 3px 8px; 
            border-radius: 6px; background: rgba(255, 255, 255, 0.1);
        }
        
        /* V5.2: Redesigned Leaderboard Cards - Main stat at bottom */
        .export-card-v3 {
            background: linear-gradient(145deg, rgba(20, 27, 45, 0.98), rgba(15, 23, 42, 0.98));
            border: 2px solid rgba(30, 58, 95, 0.7);
            border-radius: var(--radius-lg);
            padding: 14px;
            padding-top: 16px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: all var(--duration-normal) var(--ease-out);
            box-shadow: var(--elevation-2);
        }
        .export-card-v3::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 4px;
            background: linear-gradient(90deg, #f59e0b, #ef4444, #ec4899);
            background-size: 200% 100%;
            animation: gradientShift 4s ease infinite;
        }
        .export-card-v3::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 70% 0%, rgba(245, 158, 11, 0.1), transparent 50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--duration-normal) var(--ease-out);
        }
        .export-card-v3:hover {
            border-color: rgba(245, 158, 11, 0.6);
            transform: translateY(-4px);
            box-shadow: var(--elevation-4), 0 0 30px rgba(245, 158, 11, 0.15);
        }
        .export-card-v3:hover::after {
            opacity: 1;
        }
        
        .export-card-v3-header {
            display: flex; align-items: center; gap: 8px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(71, 85, 105, 0.5);
            margin-bottom: 10px;
        }
        .export-card-v3-photo {
            width: 32px; height: 32px; border-radius: 50%;
            background: linear-gradient(135deg, #21262d, #30363d);
            border: 2px solid #484f58;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; flex-shrink: 0; cursor: pointer;
            font-size: 12px; font-weight: 700; color: #8b949e;
        }
        .export-card-v3-photo img { width: 100%; height: 100%; object-fit: cover; }
        .export-card-v3-info { flex: 1; min-width: 0; }
        .export-card-v3-name { font-size: 14px; font-weight: 700; color: #fff; white-space: normal; overflow-wrap: break-word; word-break: break-word; line-height: 1.2; }
        .export-card-v3-team { font-size: 10px; color: #60a5fa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; display: block; }
        .export-card-v3-rank {
            font-size: 11px; font-weight: 700; color: #f59e0b;
            position: absolute; top: 6px; left: 6px; z-index: 2;
            background: rgba(0, 0, 0, 0.5); border-radius: 4px; padding: 1px 4px;
            line-height: 1.2;
        }
        
        /* Secondary stats section at top */
        .export-card-v3-secondary {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px;
            flex: 1; margin-bottom: 12px;
        }
        .export-card-v3-sec-stat {
            padding: 6px 8px; border-radius: 6px;
            background: rgba(15, 23, 42, 0.6);
            border-left: 3px solid #475569;
            display: flex; flex-direction: column;
            min-height: 36px; justify-content: space-between;
        }
        .export-card-v3-sec-stat.efficiency { border-left-color: #00d4ff; background: rgba(0, 212, 255, 0.05); }
        .export-card-v3-sec-stat.shooting { border-left-color: #8b5cf6; background: rgba(139, 92, 246, 0.05); }
        .export-card-v3-sec-stat.playmaking { border-left-color: #ec4899; background: rgba(236, 72, 153, 0.05); }
        .export-card-v3-sec-stat.defense { border-left-color: #ef4444; background: rgba(239, 68, 68, 0.05); }
        .export-card-v3-sec-label { font-size: 8px; color: #6e7681; text-transform: uppercase; letter-spacing: 0.3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; line-height: 1.2; }
        .export-card-v3-sec-value { font-size: 14px; font-weight: 700; color: #e6edf3; line-height: 1.2; }
        
        /* Main stat at bottom - prominent */
        .export-card-v3-main {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(239, 68, 68, 0.1));
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 10px;
            padding: 14px;
            text-align: center;
            margin-top: auto;
        }
        .export-card-v3-main-label {
            font-size: 10px; color: #f59e0b; text-transform: uppercase;
            letter-spacing: 1.5px; margin-bottom: 4px; font-weight: 700;
        }
        .export-card-v3-main-value {
            font-size: 28px; font-weight: 800;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        
        /* Checkbox/Multi-select styles */
        .export-stat-checkboxes { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
        .export-stat-checkbox {
            display: flex; align-items: center; gap: 4px;
            padding: 4px 10px; border-radius: 6px;
            background: rgba(71, 85, 105, 0.3);
            border: 1px solid #475569;
            cursor: pointer; font-size: 11px; color: #94a3b8;
            transition: all 0.2s;
        }
        .export-stat-checkbox:hover { border-color: #60a5fa; }
        .export-stat-checkbox.selected {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
            color: #60a5fa;
        }
        .export-stat-checkbox input { display: none; }
        
        /* Team multi-select */
        .export-team-pills { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
        .export-team-pill {
            padding: 6px 12px; border-radius: 20px;
            background: rgba(71, 85, 105, 0.3);
            border: 1px solid #475569;
            cursor: pointer; font-size: 12px; color: #94a3b8;
            transition: all 0.2s;
        }
        .export-team-pill:hover { border-color: #60a5fa; }
        .export-team-pill.selected {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.4), rgba(139, 92, 246, 0.3));
            border-color: #3b82f6;
            color: #60a5fa; font-weight: 600;
        }
        
        /* Date range inputs */
        .export-date-inputs { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
        .export-date-input { 
            padding: 8px 12px; background: #0f172a; border: 1px solid #475569;
            border-radius: 6px; color: white; font-size: 12px;
        }
        
        /* V5.4: Enhanced Best Lineups Cards */
        .export-lineup-cards { display: flex; flex-direction: column; gap: 24px; }
        .export-lineup-card-v2 {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(20, 27, 45, 0.98));
            border: 2px solid rgba(30, 58, 95, 0.6);
            border-radius: var(--radius-xl);
            overflow: hidden;
            position: relative;
            transition: all var(--duration-normal) var(--ease-out);
            box-shadow: var(--elevation-3);
        }
        .export-lineup-card-v2::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 5px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #ec4899, #f59e0b);
            background-size: 300% 100%;
            animation: gradientShift 5s ease infinite;
        }
        .export-lineup-card-v2::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 0%, rgba(139, 92, 246, 0.08), transparent 40%);
            pointer-events: none;
        }
        .export-lineup-card-v2:hover {
            transform: translateY(-5px);
            box-shadow: var(--elevation-5), 0 0 40px rgba(59, 130, 246, 0.15);
            border-color: rgba(59, 130, 246, 0.6);
        }
        
        /* Players section - focal point */
        .export-lineup-players-row {
            display: flex; justify-content: center; gap: 16px;
            padding: 28px 20px 20px;
            background: linear-gradient(180deg, rgba(59, 130, 246, 0.1), transparent);
        }
        .export-lineup-player-card {
            display: flex; flex-direction: column; align-items: center;
            gap: 8px; cursor: pointer;
        }
        .export-lineup-player-photo {
            width: 64px; height: 64px; border-radius: 50%;
            background: linear-gradient(135deg, #1e293b, #334155);
            border: 3px solid #475569;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; font-weight: 700; color: #94a3b8;
            overflow: hidden;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
            transition: all 0.2s;
        }
        .export-lineup-player-photo:hover { border-color: #60a5fa; transform: scale(1.05); }
        .export-lineup-player-photo img { width: 100%; height: 100%; object-fit: cover; }
        .export-lineup-player-name-v2 {
            font-size: 11px; color: #e2e8f0; font-weight: 600;
            text-align: center; max-width: 72px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        
        /* Rank badge */
        .export-lineup-rank-badge {
            position: absolute; top: 16px; left: 16px;
            font-size: 28px; font-weight: 900;
            color: #f59e0b;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        .export-lineup-rank-badge::before { content: '#'; font-size: 18px; opacity: 0.7; }
        
        /* Team badge (for all teams mode) */
        .export-lineup-team-badge {
            position: absolute; top: 16px; right: 16px;
            padding: 6px 14px; border-radius: 20px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(139, 92, 246, 0.2));
            border: 1px solid rgba(59, 130, 246, 0.5);
            font-size: 11px; font-weight: 700; color: #60a5fa;
        }
        
        /* Stats row */
        .export-lineup-stats-row {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;
            padding: 0 16px 16px;
        }
        .export-lineup-stat-box {
            padding: 14px 12px; text-align: center;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 10px;
        }
        .export-lineup-stat-box.net { background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.15)); }
        .export-lineup-stat-box.off { background: rgba(34, 197, 94, 0.1); }
        .export-lineup-stat-box.def { background: rgba(239, 68, 68, 0.1); }
        .export-lineup-stat-value-v2 { font-size: 24px; font-weight: 800; }
        .export-lineup-stat-label-v2 { font-size: 10px; color: #94a3b8; text-transform: uppercase; margin-top: 4px; }
        
        /* Four Factors row */
        .export-lineup-ff-row {
            display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
            padding: 0 16px 16px;
        }
        .export-lineup-ff-section {
            padding: 12px; border-radius: 10px;
        }
        .export-lineup-ff-section.offense { background: rgba(34, 197, 94, 0.08); border-left: 3px solid #22c55e; }
        .export-lineup-ff-section.defense { background: rgba(239, 68, 68, 0.08); border-left: 3px solid #ef4444; }
        .export-lineup-ff-title { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        .export-lineup-ff-section.offense .export-lineup-ff-title { color: #4ade80; }
        .export-lineup-ff-section.defense .export-lineup-ff-title { color: #f87171; }
        .export-lineup-ff-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .export-lineup-ff-stat { font-size: 11px; color: #e2e8f0; display: flex; justify-content: space-between; }
        .export-lineup-ff-stat span:first-child { color: #94a3b8; }
        
        /* Metadata row */
        .export-lineup-meta-row {
            display: flex; justify-content: center; gap: 24px;
            padding: 12px 16px;
            background: rgba(30, 41, 59, 0.5);
            border-top: 1px solid rgba(71, 85, 105, 0.5);
        }
        .export-lineup-meta { font-size: 11px; color: #94a3b8; }
        .export-lineup-meta strong { color: #e2e8f0; }
        
        /* V5.4: Enhanced WOWY Cards */
        .export-wowy-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .export-wowy-card {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(20, 27, 45, 0.98));
            border: 2px solid #1e3a5f;
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        .export-wowy-card:hover { 
            transform: translateY(-3px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4);
            border-color: #3b82f6;
        }
        .export-wowy-card-header {
            display: flex; align-items: center; gap: 14px;
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(139, 92, 246, 0.1));
            border-bottom: 1px solid rgba(59, 130, 246, 0.3);
        }
        .export-wowy-card-photo {
            width: 56px; height: 56px; border-radius: 50%;
            background: linear-gradient(135deg, #1e293b, #334155);
            border: 3px solid #475569;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; font-weight: 700; color: #94a3b8;
            overflow: hidden; cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .export-wowy-card-photo img { width: 100%; height: 100%; object-fit: cover; }
        .export-wowy-card-photo:hover { border-color: #60a5fa; }
        .export-wowy-card-info { flex: 1; }
        .export-wowy-card-name { font-size: 16px; font-weight: 700; color: #fff; }
        .export-wowy-card-team { font-size: 11px; color: #60a5fa; }
        .export-wowy-card-rank {
            font-size: 24px; font-weight: 800; color: #f59e0b;
        }
        
        /* WOWY Impact bar */
        .export-wowy-impact {
            padding: 16px 20px; text-align: center;
        }
        .export-wowy-impact-value {
            font-size: 36px; font-weight: 900;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        .export-wowy-impact-label { font-size: 11px; color: #94a3b8; margin-top: 4px; }
        
        /* WOWY Four Factors grid */
        .export-wowy-ff-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 2px;
            padding: 0 16px 16px;
        }
        .export-wowy-ff-section { padding: 12px; border-radius: 10px; }
        .export-wowy-ff-section.on { background: rgba(34, 197, 94, 0.1); }
        .export-wowy-ff-section.off { background: rgba(239, 68, 68, 0.1); }
        .export-wowy-ff-title { font-size: 10px; font-weight: 700; text-transform: uppercase; margin-bottom: 8px; }
        .export-wowy-ff-section.on .export-wowy-ff-title { color: #4ade80; }
        .export-wowy-ff-section.off .export-wowy-ff-title { color: #f87171; }
        .export-wowy-ff-stats { display: flex; flex-direction: column; gap: 4px; }
        .export-wowy-ff-stat { font-size: 11px; display: flex; justify-content: space-between; color: #e2e8f0; }
        .export-wowy-ff-stat span:first-child { color: #94a3b8; }
        
        /* V5.5: Enhanced WOWY Four Factors Grid with color coding */
        .export-wowy-ff-grid-v2 {
            display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
            padding: 0 12px 16px;
        }
        .export-wowy-ff-section-v2 { 
            padding: 12px; border-radius: 10px; 
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid rgba(71, 85, 105, 0.5);
        }
        .export-wowy-ff-section-v2.on { border-left: 3px solid #4ade80; }
        .export-wowy-ff-section-v2.off { border-left: 3px solid #f87171; }
        .export-wowy-ff-section-header {
            font-size: 11px; font-weight: 700; text-transform: uppercase; 
            margin-bottom: 8px; color: #e2e8f0; text-align: center;
        }
        .export-wowy-ratings-row {
            display: flex; justify-content: space-around; gap: 4px;
            font-size: 10px; margin-bottom: 10px;
            padding: 6px; background: rgba(0,0,0,0.2); border-radius: 6px;
        }
        .export-wowy-ff-row-v2 {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px;
            margin-bottom: 4px;
        }
        /* Small stat boxes for WOWY Four Factors */
        .export-ff-stat-box-sm {
            padding: 4px; border-radius: 6px; text-align: center;
            background: rgba(71, 85, 105, 0.2);
        }
        .export-ff-stat-box-sm.perf-excellent { background: rgba(var(--perf-excellent-rgb), 0.3); }
        .export-ff-stat-box-sm.perf-good { background: rgba(var(--perf-good-rgb), 0.2); }
        .export-ff-stat-box-sm.perf-average { background: rgba(var(--perf-average-rgb), 0.15); }
        .export-ff-stat-box-sm.perf-below { background: rgba(var(--perf-below-rgb), 0.2); }
        .export-ff-stat-box-sm.perf-poor { background: rgba(var(--perf-poor-rgb), 0.25); }
        .export-ff-stat-label-sm { font-size: 8px; color: #94a3b8; text-transform: uppercase; }
        .export-ff-stat-value-sm { font-size: 11px; font-weight: 700; color: #ffffff; }
        
        /* V5.5: Best Lineups color-coded Four Factors grid */
        .export-lineup-ff-stats-v2 {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px;
        }
        
        /* WOWY Meta row */
        .export-wowy-meta-row {
            display: flex; justify-content: center; gap: 16px;
            padding: 12px 16px;
            background: rgba(30, 41, 59, 0.5);
            border-top: 1px solid rgba(71, 85, 105, 0.5);
            font-size: 11px; color: #94a3b8;
        }
        
        /* Shot Distribution enhanced */
        .export-shot-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; }
        .export-shot-card {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(20, 27, 45, 0.98));
            border: 2px solid #1e3a5f;
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        .export-shot-card:hover { transform: translateY(-3px); box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4); }

        /* ═══════════════════════════════════════════════════════════════════════════
           ADVANCED GAMES VIEW - EMBEDDED GAMEVIS STYLES (Self-contained)
           ═══════════════════════════════════════════════════════════════════════════ */
        .advanced-games-view { display: none; }
        .advanced-games-view.active { display: block; }

        /* GAMEVIS ROOT VARIABLES - Scoped to .gv-container */
        .gv-container {
            --gv-bg-base: #0a0b0f;
            --gv-bg-primary: #12141a;
            --gv-bg-card: rgba(22, 25, 35, 0.85);
            --gv-bg-elevated: rgba(35, 40, 55, 0.9);
            --gv-bg-glass: rgba(255, 255, 255, 0.03);
            --gv-accent-cyan: #00d4ff;
            --gv-accent-cyan-glow: rgba(0, 212, 255, 0.4);
            --gv-accent-magenta: #ff00aa;
            --gv-accent-magenta-glow: rgba(255, 0, 170, 0.3);
            --gv-accent-gold: #ffd000;
            --gv-accent-emerald: #00ff88;
            --gv-accent-coral: #ff6b6b;
            --gv-accent-purple: #a855f7;
            --gv-team-home: #00d4ff;
            --gv-team-home-bg: rgba(0, 212, 255, 0.15);
            --gv-team-away: #ff00aa;
            --gv-team-away-bg: rgba(255, 0, 170, 0.15);
            --gv-positive: #00ff88;
            --gv-positive-bg: rgba(0, 255, 136, 0.12);
            --gv-negative: #ff6b6b;
            --gv-negative-bg: rgba(255, 107, 107, 0.12);
            --gv-text-bright: #ffffff;
            --gv-text-primary: #e8ecf4;
            --gv-text-secondary: #8892a8;
            --gv-text-muted: #5a6478;
            --gv-border-subtle: rgba(255, 255, 255, 0.06);
            --gv-border-accent: rgba(0, 212, 255, 0.3);
            --gv-space-xs: 4px;
            --gv-space-sm: 8px;
            --gv-space-md: 16px;
            --gv-space-lg: 24px;
            --gv-space-xl: 32px;
            --gv-radius-sm: 8px;
            --gv-radius-md: 12px;
            --gv-radius-lg: 20px;
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        /* GAMEVIS Views */
        .gv-container .gv-view { display: none; }
        .gv-container .gv-view.active { display: block; }

        /* GAMEVIS Upload Section - Enhanced Splash Screen */
        .gv-container .gv-upload-section {
            background: linear-gradient(180deg, var(--gv-bg-card) 0%, rgba(22, 25, 35, 0.95) 100%);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: var(--gv-radius-lg);
            padding: 48px 40px;
            text-align: center;
            max-width: 1000px;
            margin: 0 auto;
            position: relative;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), 0 0 80px rgba(0, 212, 255, 0.05);
        }
        .gv-container .gv-upload-section::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--gv-accent-cyan), var(--gv-accent-magenta), var(--gv-accent-gold), var(--gv-accent-cyan));
            background-size: 300% 100%;
            animation: gvGradientShift 4s ease infinite;
        }
        @keyframes gvGradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .gv-container .gv-upload-section::after {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: radial-gradient(circle at 30% 30%, rgba(0, 212, 255, 0.05) 0%, transparent 50%),
                        radial-gradient(circle at 70% 70%, rgba(255, 0, 170, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }
        .gv-container .gv-upload-section h2 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 36px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--gv-accent-cyan) 0%, var(--gv-accent-magenta) 50%, var(--gv-accent-gold) 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gvTextShine 3s ease infinite;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
        }
        @keyframes gvTextShine {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .gv-container .gv-upload-section .gv-splash-subtitle {
            font-size: 16px;
            color: var(--gv-text-secondary);
            margin-bottom: 32px;
            position: relative;
            z-index: 1;
        }
        .gv-container .gv-upload-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 16px;
            margin-top: 32px;
            position: relative;
            z-index: 1;
        }
        .gv-container .gv-upload-btn {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 16px 28px;
            border-radius: 12px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(35, 40, 55, 0.8);
            color: var(--gv-text-primary);
            backdrop-filter: blur(8px);
            position: relative;
            overflow: hidden;
        }
        .gv-container .gv-upload-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }
        .gv-container .gv-upload-btn:hover::before {
            left: 100%;
        }
        .gv-container .gv-upload-btn:hover {
            border-color: var(--gv-accent-cyan);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4), 0 0 20px rgba(0, 212, 255, 0.2);
        }
        .gv-container .gv-upload-btn.primary {
            background: linear-gradient(135deg, var(--gv-accent-cyan), rgba(0, 170, 255, 0.9));
            color: #000;
            border: none;
            font-weight: 700;
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.3);
        }
        .gv-container .gv-upload-btn.primary:hover {
            box-shadow: 0 8px 35px rgba(0, 212, 255, 0.5);
            transform: translateY(-3px) scale(1.05);
        }
        .gv-container .gv-upload-btn input[type="file"] { display: none; }

        /* Feature highlights on splash */
        .gv-container .gv-splash-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 40px;
            padding-top: 32px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            position: relative;
            z-index: 1;
        }
        .gv-container .gv-splash-feature {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px 16px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .gv-container .gv-splash-feature:hover {
            background: rgba(255, 255, 255, 0.04);
            border-color: rgba(0, 212, 255, 0.3);
            transform: translateY(-2px);
        }
        .gv-container .gv-splash-feature-icon {
            font-size: 28px;
            margin-bottom: 12px;
        }
        .gv-container .gv-splash-feature-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--gv-text-primary);
            margin-bottom: 6px;
        }
        .gv-container .gv-splash-feature-desc {
            font-size: 12px;
            color: var(--gv-text-muted);
            line-height: 1.4;
        }

        /* GAMEVIS Folder Upload */
        .gv-container .gv-folder-section {
            margin-top: var(--gv-space-xl);
            padding-top: var(--gv-space-xl);
            border-top: 1px solid var(--gv-border-subtle);
        }
        .gv-container .gv-folder-btn {
            background: linear-gradient(135deg, var(--gv-accent-purple), var(--gv-accent-magenta));
            border: none;
            color: white;
        }

        /* GAMEVIS Browser View */
        .gv-container .gv-browser-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .gv-container .gv-browser-header {
            text-align: center;
            margin-bottom: var(--gv-space-xl);
        }
        .gv-container .gv-browser-header h2 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--gv-accent-cyan), var(--gv-accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: var(--gv-space-sm);
        }
        .gv-container .gv-browser-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--gv-space-lg);
            margin-bottom: var(--gv-space-lg);
            padding: var(--gv-space-md) var(--gv-space-lg);
            background: var(--gv-bg-elevated);
            border-radius: var(--gv-radius-md);
            border: 1px solid var(--gv-border-subtle);
        }
        .gv-container .gv-game-count {
            display: flex;
            align-items: center;
            gap: var(--gv-space-sm);
            font-size: 14px;
            color: var(--gv-text-secondary);
        }
        .gv-container .gv-game-count .count-badge {
            background: linear-gradient(135deg, var(--gv-accent-purple), var(--gv-accent-magenta));
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 13px;
        }
        .gv-container .gv-filter-select {
            padding: 10px 16px;
            background: var(--gv-bg-base);
            border: 1px solid var(--gv-border-subtle);
            border-radius: var(--gv-radius-sm);
            color: var(--gv-text-primary);
            font-size: 13px;
            min-width: 220px;
            cursor: pointer;
        }
        .gv-container .gv-filter-select:focus {
            outline: none;
            border-color: var(--gv-accent-cyan);
        }

        /* GAMEVIS Game List */
        .gv-container .gv-game-list {
            display: flex;
            flex-direction: column;
            gap: var(--gv-space-md);
        }
        .gv-container .gv-game-card {
            background: var(--gv-bg-card);
            border: 1px solid var(--gv-border-subtle);
            border-radius: var(--gv-radius-md);
            overflow: hidden;
            transition: all 0.2s ease;
        }
        .gv-container .gv-game-card:hover {
            border-color: var(--gv-accent-cyan);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }
        .gv-container .gv-game-card.expanded {
            border-color: var(--gv-accent-cyan);
            box-shadow: 0 4px 24px rgba(0, 212, 255, 0.15);
        }
        .gv-container .gv-game-main {
            display: grid;
            grid-template-columns: auto 1fr auto 1fr auto auto;
            align-items: center;
            gap: var(--gv-space-lg);
            padding: var(--gv-space-lg) var(--gv-space-xl);
            cursor: pointer;
        }
        .gv-container .gv-expand-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .gv-container .gv-expand-btn:hover {
            color: var(--gv-accent-cyan) !important;
        }
        @keyframes slideDown {
            from { opacity: 0; max-height: 0; transform: translateY(-10px); }
            to { opacity: 1; max-height: 500px; transform: translateY(0); }
        }
        .gv-container .gv-team {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .gv-container .gv-team.home { text-align: left; }
        .gv-container .gv-team.away { text-align: right; }
        .gv-container .gv-team-name {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--gv-text-bright);
        }
        .gv-container .gv-team.home .gv-team-name { color: var(--gv-team-home); }
        .gv-container .gv-team.away .gv-team-name { color: var(--gv-team-away); }
        .gv-container .gv-score-block {
            display: flex;
            align-items: center;
            gap: var(--gv-space-md);
            padding: 0 var(--gv-space-lg);
        }
        .gv-container .gv-score {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 2rem;
            font-weight: 700;
        }
        .gv-container .gv-score.home { color: var(--gv-team-home); }
        .gv-container .gv-score.away { color: var(--gv-team-away); }
        .gv-container .gv-score-divider {
            width: 2px;
            height: 40px;
            background: linear-gradient(to bottom, var(--gv-team-home), var(--gv-team-away));
            border-radius: 2px;
        }
        .gv-container .gv-game-date {
            font-size: 13px;
            color: var(--gv-text-muted);
            font-family: 'Space Mono', monospace;
            min-width: 80px;
            text-align: center;
        }
        .gv-container .gv-load-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, var(--gv-accent-cyan), rgba(0, 212, 255, 0.7));
            border: none;
            border-radius: var(--gv-radius-sm);
            color: var(--gv-bg-base);
            font-family: 'Space Grotesk', sans-serif;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }
        .gv-container .gv-load-btn:hover:not(:disabled) {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        .gv-container .gv-load-btn:disabled {
            opacity: 0.7;
            cursor: wait;
        }

        /* GAMEVIS Nav Button */
        .gv-container .gv-nav-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: var(--gv-bg-elevated);
            border: 1px solid var(--gv-border-subtle);
            border-radius: var(--gv-radius-md);
            color: var(--gv-text-secondary);
            font-family: 'Space Grotesk', sans-serif;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: var(--gv-space-lg);
        }
        .gv-container .gv-nav-btn:hover {
            background: var(--gv-bg-card);
            border-color: var(--gv-accent-cyan);
            color: var(--gv-accent-cyan);
        }

        /* GAMEVIS Visualization Container */
        .gv-container .gv-visualization {
            background: var(--gv-bg-card);
            border: 1px solid var(--gv-border-subtle);
            border-radius: var(--gv-radius-lg);
            padding: var(--gv-space-lg);
            margin-top: var(--gv-space-lg);
        }

        /* GAMEVIS Tabs */
        .gv-container .gv-tab-container {
            display: flex;
            gap: var(--gv-space-sm);
            margin-bottom: var(--gv-space-lg);
            padding: var(--gv-space-sm);
            background: rgba(15, 23, 42, 0.95);
            border-radius: var(--gv-radius-md);
            width: fit-content;
            overflow-x: auto;
        }
        .gv-container .gv-tab-btn {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: var(--gv-text-secondary);
            font-family: 'Space Grotesk', sans-serif;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border-radius: var(--gv-radius-sm);
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        .gv-container .gv-tab-btn:hover {
            background: var(--gv-bg-glass);
            color: var(--gv-text-primary);
        }
        .gv-container .gv-tab-btn.active {
            background: linear-gradient(135deg, var(--gv-accent-cyan), rgba(0, 212, 255, 0.7));
            color: var(--gv-bg-base);
        }

        /* GAMEVIS Header */
        .gv-container .gv-game-header {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: var(--gv-space-xl);
            padding: var(--gv-space-lg);
            margin-bottom: var(--gv-space-lg);
            align-items: center;
        }
        .gv-container .gv-team-block {
            display: flex;
            align-items: center;
            gap: var(--gv-space-lg);
        }
        .gv-container .gv-team-block.away {
            flex-direction: row-reverse;
            text-align: right;
        }
        .gv-container .gv-team-logo {
            width: 70px;
            height: 70px;
            border-radius: var(--gv-radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 20px;
            font-weight: 700;
        }
        .gv-container .gv-team-logo.home {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(0, 212, 255, 0.05));
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--gv-team-home);
        }
        .gv-container .gv-team-logo.away {
            background: linear-gradient(135deg, rgba(255, 0, 170, 0.2), rgba(255, 0, 170, 0.05));
            border: 1px solid rgba(255, 0, 170, 0.3);
            color: var(--gv-team-away);
        }
        .gv-container .gv-team-content h3 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 22px;
            font-weight: 700;
            color: var(--gv-text-bright);
            margin-bottom: var(--gv-space-xs);
        }
        .gv-container .gv-result-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 12px;
            border-radius: 100px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .gv-container .gv-result-tag.win {
            background: var(--gv-positive-bg);
            color: var(--gv-positive);
        }
        .gv-container .gv-result-tag.loss {
            background: var(--gv-negative-bg);
            color: var(--gv-negative);
        }
        .gv-container .gv-score-center { text-align: center; }
        .gv-container .gv-score-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--gv-space-md);
            margin-bottom: var(--gv-space-sm);
        }
        .gv-container .gv-score-value {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 56px;
            font-weight: 700;
            line-height: 1;
        }
        .gv-container .gv-score-value.home { color: var(--gv-team-home); }
        .gv-container .gv-score-value.away { color: var(--gv-team-away); }
        .gv-container .gv-score-sep {
            width: 3px;
            height: 40px;
            background: linear-gradient(180deg, var(--gv-team-home), var(--gv-team-away));
            border-radius: 2px;
        }

        /* GAMEVIS Stats Grid */
        .gv-container .gv-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--gv-space-lg);
            margin-bottom: var(--gv-space-lg);
        }
        .gv-container .gv-stat-card {
            background: var(--gv-bg-glass);
            border: 1px solid var(--gv-border-subtle);
            border-radius: var(--gv-radius-md);
            padding: var(--gv-space-lg);
        }
        .gv-container .gv-stat-card.full-width { grid-column: span 2; }
        .gv-container .gv-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--gv-space-md);
            padding-bottom: var(--gv-space-sm);
            border-bottom: 1px solid var(--gv-border-subtle);
        }
        .gv-container .gv-card-title {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--gv-text-secondary);
        }

        /* GAMEVIS Four Factors */
        .gv-container .gv-factors-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: var(--gv-space-md);
        }
        .gv-container .gv-factor-block {
            text-align: center;
            padding: var(--gv-space-md);
            background: var(--gv-bg-glass);
            border-radius: var(--gv-radius-md);
            border: 1px solid var(--gv-border-subtle);
        }
        .gv-container .gv-factor-values {
            display: flex;
            justify-content: center;
            gap: var(--gv-space-md);
            margin-bottom: var(--gv-space-xs);
        }
        .gv-container .gv-factor-val {
            font-family: 'Space Mono', monospace;
            font-size: 20px;
            font-weight: 700;
        }
        .gv-container .gv-factor-val.home { color: var(--gv-team-home); }
        .gv-container .gv-factor-val.away { color: var(--gv-team-away); }
        .gv-container .gv-factor-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--gv-text-muted);
        }

        /* GAMEVIS Player Table - Enhanced with Section Borders & Colors */
        .gv-container .gv-player-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: var(--gv-space-md);
        }
        .gv-container .gv-player-table th,
        .gv-container .gv-player-table td {
            padding: 10px 12px;
            text-align: center;
            font-size: 13px;
            border-bottom: 1px solid var(--gv-border-subtle);
        }
        .gv-container .gv-player-table th {
            background: var(--gv-bg-elevated);
            font-weight: 600;
            color: var(--gv-text-secondary);
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 0.5px;
        }
        .gv-container .gv-player-table th:first-child,
        .gv-container .gv-player-table td:first-child { text-align: left; }
        .gv-container .gv-player-table tbody tr:hover {
            background: rgba(0, 212, 255, 0.08);
        }
        .gv-container .gv-player-name {
            font-weight: 600;
            color: var(--gv-text-bright);
        }
        .gv-container .gv-player-number {
            font-size: 11px;
            color: var(--gv-text-muted);
            margin-right: 8px;
        }
        /* Section border styling for column groups */
        .gv-container .gv-player-table .section-border-left {
            border-left: 2px solid var(--section-color, var(--gv-border-subtle));
        }
        .gv-container .gv-player-table .section-bg {
            background: var(--section-bg, transparent);
        }
        .gv-container .gv-player-table thead tr:first-child th[colspan] {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 1px;
        }
        /* Section-specific background tints */
        .gv-container .gv-player-table .section-scoring { background: rgba(0, 255, 136, 0.04); }
        .gv-container .gv-player-table .section-usage { background: rgba(255, 127, 80, 0.04); }
        .gv-container .gv-player-table .section-shotdist { background: rgba(167, 139, 250, 0.04); }
        .gv-container .gv-player-table .section-offcourt { background: rgba(0, 212, 255, 0.04); }
        .gv-container .gv-player-table .section-defcourt { background: rgba(255, 0, 170, 0.04); }
        .gv-container .gv-player-table .section-individual { background: rgba(255, 208, 0, 0.04); }

        /* GAMEVIS Loading */
        .gv-container .gv-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--gv-space-xl);
            color: var(--gv-text-secondary);
        }
        .gv-container .gv-loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--gv-border-subtle);
            border-top-color: var(--gv-accent-cyan);
            border-radius: 50%;
            animation: gvSpin 0.8s linear infinite;
            margin-bottom: var(--gv-space-md);
        }
        @keyframes gvSpin {
            to { transform: rotate(360deg); }
        }
        @keyframes gvPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }

        /* GAMEVIS Progress */
        .gv-container .gv-progress-container {
            margin-top: var(--gv-space-md);
            width: 100%;
            max-width: 400px;
        }
        .gv-container .gv-progress-bar {
            height: 8px;
            background: var(--gv-bg-elevated);
            border-radius: 4px;
            overflow: hidden;
        }
        .gv-container .gv-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gv-accent-cyan), var(--gv-accent-magenta));
            transition: width 0.2s ease;
        }
        .gv-container .gv-progress-text {
            font-size: 12px;
            color: var(--gv-text-muted);
            margin-top: 6px;
            text-align: center;
        }
        /* ═══════════════════════════════════════════════════════════════════════════ */

        /* ═══════════════════════════════════════════════════════════════════════════
           COMPREHENSIVE MOBILE SUPPORT - Full Range Responsive Design
           Supports: iOS, Android, tablets, and all touch devices
           ═══════════════════════════════════════════════════════════════════════════ */

        /* Mobile Detection CSS Custom Property (set by JS) */
        :root {
            --is-mobile: 0;
            --is-touch: 0;
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-left: env(safe-area-inset-left, 0px);
            --safe-area-right: env(safe-area-inset-right, 0px);
        }

        /* Touch-friendly tap targets - minimum 44px for accessibility */
        @media (pointer: coarse) {
            :root { --is-touch: 1; }
            .btn, button, select, input[type="checkbox"], input[type="radio"] {
                min-height: 44px;
                min-width: 44px;
            }
            select, input { font-size: 16px !important; } /* Prevents iOS zoom on focus */
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           TABLET BREAKPOINT (768px - 1024px)
           ═══════════════════════════════════════════════════════════════════════════ */
        @media (max-width: 1024px) {
            body { padding: 12px; }
            .container { max-width: 100%; }
            .header h1 { font-size: 1.8rem; }
            .grid-5 { grid-template-columns: repeat(3, 1fr); }
            .grid-4 { grid-template-columns: repeat(2, 1fr); }
            .stats-grid { grid-template-columns: repeat(3, 1fr); }
            .controls { padding: 16px; }
            .section { padding: 16px; }
            .modal-content { padding: 20px; width: 98%; }

            /* Tab navigation - scrollable */
            .export-mode-tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                flex-wrap: nowrap;
                padding-bottom: 8px;
            }
            .export-mode-tab { flex-shrink: 0; }
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           MOBILE BREAKPOINT (max-width: 768px)
           ═══════════════════════════════════════════════════════════════════════════ */
        @media (max-width: 768px) {
            :root { --is-mobile: 1; }

            body {
                padding: 8px;
                padding-top: calc(8px + var(--safe-area-top));
                padding-bottom: calc(8px + var(--safe-area-bottom));
                padding-left: calc(8px + var(--safe-area-left));
                padding-right: calc(8px + var(--safe-area-right));
            }

            .header { margin-bottom: 16px; }
            .header h1 { font-size: 1.4rem; line-height: 1.2; }

            /* Grid layouts - single column on mobile */
            .grid-5, .grid-4, .grid-3, .grid-2 { grid-template-columns: 1fr; gap: 8px; }
            .stats-grid { grid-template-columns: repeat(2, 1fr); gap: 8px; }

            /* Stat cards - compact */
            .stat-card { padding: 12px; }
            .stat-label { font-size: 11px; margin-bottom: 4px; }
            .stat-value { font-size: 20px; }

            /* Controls - stacked layout */
            .controls { padding: 12px; margin-bottom: 12px; }
            .form-group { margin-bottom: 12px; }
            label { font-size: 12px; margin-bottom: 4px; }
            select, input { padding: 12px; font-size: 16px !important; border-radius: 10px; }

            /* Buttons - full width stacking */
            .btn {
                padding: 12px 16px;
                font-size: 14px;
                margin: 4px 0;
                width: 100%;
                display: block;
                text-align: center;
            }
            .flex-between { flex-direction: column; gap: 12px; align-items: stretch; }

            /* Section - reduced padding */
            .section { padding: 12px; margin-bottom: 12px; border-radius: 10px; }
            .section-title { font-size: 16px; margin-bottom: 12px; }

            /* Upload screen - mobile optimized */
            .upload-screen { min-height: 60vh; padding: 16px; }
            .upload-box { padding: 20px; border-radius: 16px; }
            .upload-btn {
                width: 100%;
                margin: 6px 0;
                padding: 14px 20px;
                font-size: 15px;
            }

            /* Tables - horizontal scroll with touch */
            table { font-size: 11px; }
            th, td { padding: 8px 6px; }
            .full-table-wrapper {
                max-height: 50vh !important;
                -webkit-overflow-scrolling: touch;
                scroll-snap-type: x mandatory;
            }
            /* On/Off & Individual tables - mobile scroll */
            .lb-data-table-scroll {
                max-height: 60vh !important;
                -webkit-overflow-scrolling: touch;
            }
            .lb-data-table th { padding: 8px 8px; font-size: 9px; }
            .lb-data-table td { padding: 6px 8px; font-size: 11px; }
            .lb-data-table td.lb-col-player { max-width: 120px; overflow: hidden; text-overflow: ellipsis; }

            /* Modal - full screen on mobile */
            .modal-content {
                width: 100%;
                height: 100%;
                max-height: 100vh;
                border-radius: 0;
                padding: 16px;
                padding-top: calc(16px + var(--safe-area-top));
            }
            .modal-header { margin-bottom: 16px; }
            .modal-close {
                width: 44px;
                height: 44px;
                font-size: 24px;
                position: fixed;
                top: calc(16px + var(--safe-area-top));
                right: 16px;
                z-index: 1001;
            }

            /* Player cards - mobile layout */
            .player-card { padding: 12px; margin-bottom: 12px; }
            .player-name { font-size: 16px; }

            /* Tab navigation - horizontal scroll */
            .export-mode-tabs {
                display: flex;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scroll-snap-type: x mandatory;
                gap: 6px;
                padding: 8px;
                margin: 0 -8px 12px -8px;
                width: calc(100% + 16px);
            }
            .export-mode-tab {
                flex-shrink: 0;
                scroll-snap-align: start;
                padding: 10px 14px;
                font-size: 12px;
                white-space: nowrap;
            }

            /* Export cards - 1 column on small mobile */
            .export-cards-grid-v2 { grid-template-columns: 1fr !important; gap: 10px; }
            .export-card-v2 { padding: 12px; }
            .export-card-v2-name { font-size: 14px; }

            /* Color legend - wrap on mobile */
            .color-legend { gap: 6px; }
            .legend-item { padding: 3px 6px; font-size: 10px; }

            /* Shot distribution bar */
            .shot-dist-bar { height: 32px; }
            .shot-segment { font-size: 9px; }

            /* Dataset info */
            .dataset-info { padding: 10px; font-size: 11px; }

            /* Leaderboard tabs - scrollable */
            .lb-tabs-mobile {
                display: flex;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                gap: 4px;
                padding-bottom: 8px;
                margin-bottom: 12px;
            }
            .lb-tabs-mobile button {
                flex-shrink: 0;
                white-space: nowrap;
            }
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           SMALL MOBILE BREAKPOINT (max-width: 480px)
           ═══════════════════════════════════════════════════════════════════════════ */
        @media (max-width: 480px) {
            body { padding: 6px; }
            .header h1 { font-size: 1.2rem; }

            .stats-grid { grid-template-columns: 1fr 1fr; }
            .stat-card { padding: 10px; }
            .stat-label { font-size: 10px; }
            .stat-value { font-size: 18px; }

            .controls { padding: 10px; }
            .section { padding: 10px; }
            .section-title { font-size: 14px; }

            /* Very compact buttons */
            .btn { padding: 10px 12px; font-size: 13px; }

            /* Upload box */
            .upload-box { padding: 16px; }
            .upload-btn { padding: 12px 16px; font-size: 14px; }

            /* Tables - very compact */
            th, td { padding: 6px 4px; font-size: 10px; }

            /* Modal adjustments */
            .modal-content { padding: 12px; }

            /* Tab buttons even smaller */
            .export-mode-tab { padding: 8px 10px; font-size: 11px; }
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           LANDSCAPE MOBILE (orientation: landscape + max-height: 500px)
           ═══════════════════════════════════════════════════════════════════════════ */
        @media (orientation: landscape) and (max-height: 500px) {
            body { padding: 8px 16px; }
            .header { margin-bottom: 8px; }
            .header h1 { font-size: 1.2rem; }

            .stats-grid { grid-template-columns: repeat(5, 1fr); }
            .stat-card { padding: 8px; }
            .stat-value { font-size: 16px; }

            .controls { padding: 10px; margin-bottom: 10px; }
            .section { padding: 10px; margin-bottom: 10px; }

            .modal-content {
                max-height: 100vh;
                height: 100vh;
            }

            .full-table-wrapper { max-height: 35vh !important; }
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           TOUCH-SPECIFIC ENHANCEMENTS
           ═══════════════════════════════════════════════════════════════════════════ */
        @media (hover: none) and (pointer: coarse) {
            /* Remove hover effects that don't work well on touch */
            .btn:hover { opacity: 1; transform: none; }
            .export-card-v2:hover { transform: none; }
            .upload-btn:hover { background-color: inherit; }

            /* Add active states instead */
            .btn:active { opacity: 0.7; transform: scale(0.98); }
            .export-card-v2:active { transform: scale(0.98); }
            .upload-btn:active { opacity: 0.8; }

            /* Larger touch targets */
            select option { padding: 12px; min-height: 44px; }

            /* Better scrolling */
            .full-table-wrapper,
            .modal-content,
            .export-mode-tabs {
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
            }
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           iOS-SPECIFIC FIXES
           ═══════════════════════════════════════════════════════════════════════════ */
        @supports (-webkit-touch-callout: none) {
            /* Fix for iOS rubber-banding */
            body {
                position: fixed;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }
            #root, .container {
                height: 100%;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Fix for iOS input zoom */
            input, select, textarea {
                font-size: 16px !important;
            }

            /* Safe area padding for notched devices */
            .modal-content {
                padding-bottom: calc(16px + env(safe-area-inset-bottom));
            }
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           MOBILE-SPECIFIC COMPONENT OVERRIDES
           ═══════════════════════════════════════════════════════════════════════════ */

        /* Mobile-friendly tab bar */
        .mobile-tab-bar {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(15, 23, 42, 0.98);
            border-top: 1px solid #334155;
            padding: 8px;
            padding-bottom: calc(8px + var(--safe-area-bottom));
            z-index: 999;
            backdrop-filter: blur(10px);
        }
        @media (max-width: 768px) {
            .mobile-tab-bar { display: none !important; }
            body { padding-bottom: 0; }
        }

        .mobile-tab-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: #64748b;
            font-size: 10px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
        }
        .mobile-tab-btn.active {
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.15);
        }
        .mobile-tab-btn-icon { font-size: 20px; }

        /* Mobile collapsible sections */
        .mobile-collapse-header {
            display: none;
        }
        @media (max-width: 768px) {
            .mobile-collapse-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px;
                background: rgba(30, 41, 59, 0.8);
                border-radius: 8px;
                margin-bottom: 8px;
                cursor: pointer;
            }
            .mobile-collapse-header::after {
                content: '▼';
                font-size: 10px;
                transition: transform 0.2s;
            }
            .mobile-collapse-header.collapsed::after {
                transform: rotate(-90deg);
            }
            .mobile-collapse-content.collapsed {
                display: none;
            }
        }

        /* Mobile-optimized data tables */
        @media (max-width: 768px) {
            .mobile-card-view {
                display: block !important;
            }
            .mobile-card-view .data-row {
                display: block;
                background: rgba(30, 41, 59, 0.5);
                border: 1px solid #334155;
                border-radius: 10px;
                padding: 12px;
                margin-bottom: 8px;
            }
            .mobile-card-view .data-row-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
                padding-bottom: 8px;
                border-bottom: 1px solid #334155;
            }
            .mobile-card-view .data-row-stats {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
            .mobile-card-view .data-row-stat {
                text-align: center;
            }
            .mobile-card-view .data-row-stat-label {
                font-size: 9px;
                color: #64748b;
                text-transform: uppercase;
            }
            .mobile-card-view .data-row-stat-value {
                font-size: 14px;
                font-weight: 600;
            }
        }

        /* Mobile scroll indicators */
        .scroll-indicator {
            display: none;
        }
        @media (max-width: 768px) {
            .scroll-indicator {
                display: block;
                text-align: center;
                padding: 8px;
                font-size: 10px;
                color: #64748b;
                background: linear-gradient(to right, transparent, rgba(15, 23, 42, 0.8), transparent);
            }
            .scroll-indicator::before {
                content: '← Swipe to scroll →';
            }
        }

        /* Mobile floating action button */
        .mobile-fab {
            display: none;
        }
        @media (max-width: 768px) {
            .mobile-fab {
                display: flex;
                position: fixed;
                bottom: calc(16px + var(--safe-area-bottom));
                right: 16px;
                width: 56px;
                height: 56px;
                border-radius: 50%;
                background: linear-gradient(135deg, #3b82f6, #2563eb);
                color: white;
                border: none;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                box-shadow: 0 4px 20px rgba(59, 130, 246, 0.4);
                cursor: pointer;
                z-index: 998;
            }
            .mobile-fab:active {
                transform: scale(0.95);
            }
        }

        /* Password overlay mobile fixes */
        @media (max-width: 768px) {
            #_gvAuthBox {
                width: calc(100% - 32px);
                max-width: 360px;
                padding: 32px 24px;
                margin: 16px;
            }
            ._gvLogo { width: 64px; height: 64px; font-size: 28px; }
            ._gvTitle { font-size: 20px; }
            ._gvSub { font-size: 13px; margin-bottom: 24px; }
            #_gvPwd { padding: 14px 16px; font-size: 16px; }
            #_gvSubmit { padding: 14px; font-size: 15px; }
        }

        /* Hide desktop-only elements on mobile */
        @media (max-width: 768px) {
            .desktop-only { display: none !important; }
        }
        @media (min-width: 769px) {
            .mobile-only { display: none !important; }
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           COMPREHENSIVE MOBILE RESPONSIVE STYLES v2.0
           Section-by-section mobile optimizations
           ═══════════════════════════════════════════════════════════════════════════ */

        /* ─── Tab Navigation - Scrollable Horizontal on Mobile ─── */
        @media (max-width: 768px) {
            .tab-nav {
                display: flex;
                flex-wrap: nowrap;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scroll-snap-type: x mandatory;
                gap: 6px;
                padding: 8px;
                margin: 0 -8px 16px -8px;
                width: calc(100% + 16px);
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .tab-nav::-webkit-scrollbar { display: none; }
            .tab-btn {
                flex-shrink: 0;
                scroll-snap-align: start;
                padding: 10px 16px;
                font-size: 12px;
                white-space: nowrap;
                min-width: max-content;
            }
        }

        /* ─── Analyzer Subtabs - Scrollable with Better Touch ─── */
        @media (max-width: 768px) {
            .analyzer-subtabs {
                display: flex;
                flex-wrap: nowrap;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scroll-snap-type: x mandatory;
                gap: 6px;
                padding: 10px;
                margin: 0 -8px 16px -8px;
                width: calc(100% + 16px);
                scrollbar-width: none;
            }
            .analyzer-subtabs::-webkit-scrollbar { display: none; }
            .subtab-btn {
                flex-shrink: 0;
                scroll-snap-align: start;
                padding: 10px 14px;
                font-size: 11px;
                white-space: nowrap;
                min-height: 44px;
            }
        }

        /* ─── WOWY Section - Mobile Optimized ─── */
        @media (max-width: 768px) {
            .wowy-container {
                border-radius: 10px;
            }
            .wowy-header {
                padding: 12px 16px;
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .wowy-title { font-size: 16px; }
            .wowy-subtitle { font-size: 11px; }

            /* WOWY Table - Horizontal scroll with card-like rows */
            .wowy-table {
                display: block;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .wowy-table th {
                padding: 8px 10px;
                font-size: 10px;
            }
            .wowy-table td {
                padding: 10px 8px;
            }
            .wowy-lineup-cell {
                gap: 4px;
                min-width: 200px;
            }
            .wowy-player-badge {
                min-width: 50px;
            }
            .wowy-player-img {
                width: 36px;
                height: 36px;
                font-size: 12px;
            }
            .wowy-player-name {
                font-size: 8px;
                max-width: 50px;
            }
            .wowy-stat-main { font-size: 14px; }
            .wowy-stat-sub { font-size: 9px; }

            /* WOWY Player Selector - Better Grid */
            .wowy-selector {
                padding: 12px 16px;
            }
            .wowy-selector-title {
                font-size: 12px;
                margin-bottom: 12px;
            }
            .wowy-player-grid {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
            }
            .wowy-player-select {
                min-width: auto;
                padding: 6px;
            }
            .wowy-player-select .wowy-player-img {
                width: 40px;
                height: 40px;
                font-size: 14px;
            }
            .wowy-player-select .wowy-player-name {
                font-size: 9px;
            }
            .wowy-min-filter {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .wowy-min-filter input {
                width: 100%;
            }
            .wowy-ff-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .wowy-empty {
                padding: 30px 16px;
            }
            .wowy-empty-icon { font-size: 36px; }
        }

        /* ─── Comparison Tab - Stack Panels on Mobile ─── */
        @media (max-width: 768px) {
            .compare-container {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            .compare-panel {
                padding: 14px;
                border-radius: 10px;
            }
            .compare-panel-header {
                font-size: 14px;
                margin-bottom: 12px;
            }
            .compare-player-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 6px;
            }
            .compare-player-slot {
                padding: 8px;
                min-height: 50px;
            }
            .compare-player-slot .player-name { font-size: 9px; }
            .compare-player-slot .player-team { font-size: 8px; }

            /* Comparison Stats - Mobile Layout */
            .compare-stat-row {
                grid-template-columns: 1fr 1fr;
                gap: 6px;
                padding: 8px;
                background: rgba(0,0,0,0.15);
                border-radius: 8px;
                margin-bottom: 8px;
                border-bottom: none;
            }
            .compare-stat-row::before {
                content: attr(data-stat-name);
                grid-column: 1 / -1;
                font-size: 10px;
                color: #94a3b8;
                text-align: center;
                font-weight: 600;
                margin-bottom: 4px;
            }
            .compare-stat-name { display: none; }
            .compare-stat-bar { display: none; }
            .compare-stat-value {
                font-size: 16px;
                text-align: center !important;
            }

            .compare-section { padding: 14px; }
            .compare-section-title { font-size: 14px; }

            .compare-shot-dist {
                grid-template-columns: 1fr;
            }
            .compare-to-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .compare-summary-grid {
                grid-template-columns: 1fr;
            }
            .compare-trans-grid {
                grid-template-columns: 1fr;
            }
            .compare-lineup-picker {
                margin-top: 12px;
            }
            .compare-lineup-list {
                max-height: 150px;
            }

            /* ─── Compare: Four Factors grid - stack on mobile ─── */
            .compare-four-factors-grid {
                grid-template-columns: 1fr !important;
                gap: 16px !important;
            }

            /* ─── Compare: Simulated Ratings - stack teams vertically ─── */
            .compare-sim-ratings-grid {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
            }
            /* Each team's ORTG/DRTG/NET: keep 3 cols but allow wrapping & smaller text */
            .compare-sim-team-stats {
                grid-template-columns: repeat(3, 1fr) !important;
                gap: 6px !important;
            }
            .compare-sim-team-stats > div {
                padding: 8px 4px !important;
            }
            .compare-sim-team-stats > div > div:nth-child(2) {
                font-size: 18px !important;
            }

            /* Sim Ratings header - wrap badges */
            .compare-sim-header {
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: 8px;
            }

            /* ─── Compare: Master slider - compact on mobile ─── */
            .compare-section > div[style*="flexWrap: 'wrap'"] {
                flex-direction: column;
            }
        }

        /* ─── Opponent Quality Filter - Mobile Optimized ─── */
        @media (max-width: 768px) {
            .opp-filter-panel {
                padding: 14px;
                margin-top: 16px;
            }
            .opp-filter-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .opp-filter-title { font-size: 14px; }
            .opp-filter-row {
                flex-direction: column;
                gap: 8px;
                padding: 10px;
            }
            .opp-filter-select,
            .opp-filter-input {
                width: 100%;
                min-width: auto;
                padding: 12px;
                font-size: 16px !important;
            }
            .opp-filter-remove {
                width: 36px;
                height: 36px;
                align-self: flex-end;
            }
            .opp-filter-add {
                width: 100%;
                text-align: center;
                padding: 12px;
            }
            .opp-filter-active-indicator {
                padding: 10px 12px;
            }
            .opp-filter-badge {
                padding: 3px 8px;
                font-size: 10px;
            }
        }

        /* ─── Four Factors Section - Mobile Grid ─── */
        @media (max-width: 768px) {
            .ff-impact-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            .ff-impact-card {
                padding: 10px;
            }
            .ff-impact-title { font-size: 11px; }
            .ff-impact-row { font-size: 10px; }
        }

        /* ─── Export Tab - Mobile Optimized ─── */
        @media (max-width: 768px) {
            .export-controls {
                flex-direction: column;
                padding: 14px;
                gap: 12px;
            }
            .export-control-group {
                width: 100%;
            }
            .export-control-group select,
            .export-control-group input {
                width: 100%;
                min-width: auto;
                font-size: 16px !important;
            }
            .export-btn {
                width: 100%;
                padding: 14px;
            }

            /* Export Mode Tabs - Scrollable */
            .export-mode-tabs {
                display: flex;
                flex-wrap: nowrap;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scroll-snap-type: x mandatory;
                gap: 6px;
                padding: 10px;
                margin: 0 -8px 16px -8px;
                width: calc(100% + 16px);
            }
            .export-mode-tabs::-webkit-scrollbar { display: none; }
            .export-mode-tab {
                flex-shrink: 0;
                scroll-snap-align: start;
                white-space: nowrap;
            }

            /* Export Frame */
            .export-frame {
                padding: 16px;
                border-radius: 12px;
            }
            .export-frame-header {
                margin-bottom: 20px;
                padding-bottom: 12px;
            }
            .export-frame-title { font-size: 22px; }
            .export-frame-subtitle { font-size: 11px; }

            /* Export Cards */
            .export-cards-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            .export-player-card {
                padding: 12px;
            }
            .export-card-rank {
                width: 24px;
                height: 24px;
                font-size: 10px;
            }
            .export-card-name { font-size: 12px; }
            .export-card-team { font-size: 10px; }
            .export-card-stat {
                padding: 6px;
            }
            .export-card-stat-value { font-size: 14px; }

            /* Export Four Factors */
            .export-ff-container {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            .export-ff-panel {
                padding: 16px;
            }
            .export-ff-title { font-size: 16px; }
            .export-ff-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            .export-ff-item {
                padding: 12px;
            }
            .export-ff-value { font-size: 22px; }

            /* Export Shot Distribution */
            .export-shot-bar {
                height: 50px;
            }
            .export-shot-segment-value { font-size: 14px; }
            .export-shot-segment-label { font-size: 8px; }
            .export-shot-details {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            /* Export Lineup Card */
            .export-lineup-card {
                padding: 16px;
            }
            .export-lineup-rank {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
            .export-lineup-players {
                gap: 8px;
            }
            .export-lineup-player-avatar {
                width: 36px;
                height: 36px;
                font-size: 12px;
            }
            .export-lineup-player-name { font-size: 8px; }
            .export-lineup-stats {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
            .export-lineup-stat {
                padding: 8px;
            }
            .export-lineup-stat-value { font-size: 18px; }
            .export-lineup-stat-label { font-size: 9px; }

            /* Export WOWY */
            .export-wowy-container {
                padding: 16px;
            }
            .export-wowy-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
            .export-wowy-player-avatar {
                width: 48px;
                height: 48px;
                font-size: 18px;
            }
            .export-wowy-player-name { font-size: 18px; }
            .export-wowy-player-team { font-size: 12px; }
            .export-wowy-table {
                display: block;
                overflow-x: auto;
            }
            .export-wowy-table th { font-size: 9px; }
            .export-wowy-table td { padding: 8px; }
        }

        /* ─── Player Stats Grid - Mobile Responsive ─── */
        @media (max-width: 768px) {
            .player-stats-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 6px;
            }
            .player-stat {
                padding: 6px;
            }
            .player-stat-label { font-size: 8px; }
            .player-stat-value { font-size: 14px; }

            .player-card-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .player-photo,
            .player-photo-placeholder {
                width: 40px;
                height: 40px;
                font-size: 14px;
            }
        }

        /* ─── Impact Section - Mobile Layout ─── */
        @media (max-width: 768px) {
            .impact-section {
                padding: 14px;
            }
            .impact-card {
                padding: 10px;
            }
            .impact-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 6px;
            }
            .impact-bar {
                flex-wrap: wrap;
            }
            .impact-label { width: 60px; }
            .impact-value { min-width: 40px; }
        }

        /* ─── Team Average Section - Mobile Grid ─── */
        @media (max-width: 768px) {
            .teamavg-section {
                padding: 14px;
            }
            .teamavg-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            .teamavg-card {
                padding: 8px;
            }
            .teamavg-stat-name { font-size: 10px; }
            .teamavg-lineup { font-size: 14px; }
            .teamavg-team { font-size: 10px; }
            .teamavg-delta { font-size: 10px; }

            .team-avg-summary {
                padding: 14px;
            }
            .team-avg-summary-title { font-size: 16px; }
            .team-avg-summary-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            .team-avg-item {
                padding: 10px;
            }
            .team-avg-item-name { font-size: 10px; }
            .team-avg-item-value { font-size: 18px; }
        }

        /* ─── RAPM Section - Mobile Layout ─── */
        @media (max-width: 768px) {
            .rapm-section {
                padding: 14px;
            }
            .rapm-header {
                flex-direction: column;
                gap: 12px;
            }
            .rapm-stat-card {
                padding: 10px;
            }
        }

        /* ─── Opponent Quality Section - Mobile ─── */
        @media (max-width: 768px) {
            .opp-section {
                padding: 14px;
            }
            .opp-stat {
                padding: 6px 10px;
                flex-wrap: wrap;
            }
            .opp-stat-name { font-size: 11px; }
            .opp-stat-value { font-size: 12px; }
            .percentile {
                font-size: 9px;
                padding: 1px 4px;
            }
        }

        /* ─── Season Compare Section - Mobile ─── */
        @media (max-width: 768px) {
            .season-compare-section {
                padding: 10px;
            }
            .season-compare-title { font-size: 10px; }
            .season-compare-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 4px;
            }
            .season-compare-item {
                padding: 4px;
            }
            .season-compare-label { font-size: 8px; }
            .scv-lineup { font-size: 11px; }
            .scv-season { font-size: 9px; }
        }

        /* ─── Matchup Modal - Mobile Full Screen ─── */
        @media (max-width: 768px) {
            .matchup-modal {
                max-width: 100%;
                width: 100%;
            }
            .matchup-table {
                font-size: 10px;
            }
            .matchup-table th,
            .matchup-table td {
                padding: 6px 4px;
            }
            .lineup-row.selected {
                border-left-width: 2px;
            }
        }

        /* ─── Shot Distribution Modal - Mobile ─── */
        @media (max-width: 768px) {
            .shot-modal {
                max-width: 100%;
            }
            .shot-breakdown-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            .shot-breakdown-card {
                padding: 14px;
            }
            .shot-breakdown-pct { font-size: 28px; }
            .shot-breakdown-rate { font-size: 12px; }
        }

        /* ─── Turnover Modal - Mobile ─── */
        @media (max-width: 768px) {
            .to-modal {
                max-width: 100%;
            }
            .to-breakdown-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            .to-breakdown-card {
                padding: 12px;
            }
            .to-breakdown-count { font-size: 24px; }
            .to-breakdown-rate { font-size: 11px; }
        }

        /* ─── Luck Adjustment Section - Mobile ─── */
        @media (max-width: 768px) {
            .luck-adj-section {
                padding: 14px;
            }
            input[type="range"] {
                width: 100%;
                height: 12px;
            }
            input[type="range"]::-webkit-slider-thumb {
                width: 28px;
                height: 28px;
            }
        }

        /* ─── Dataset Info - Mobile Compact ─── */
        @media (max-width: 768px) {
            .dataset-info {
                padding: 10px 12px;
                font-size: 10px;
            }
        }

        /* ─── Additional Small Screen (480px) Refinements ─── */
        @media (max-width: 480px) {
            .tab-btn {
                padding: 8px 12px;
                font-size: 11px;
            }
            .subtab-btn {
                padding: 8px 10px;
                font-size: 10px;
            }
            .wowy-player-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            .compare-player-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .export-cards-grid {
                grid-template-columns: 1fr;
            }
            .player-stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .team-avg-summary-grid {
                grid-template-columns: 1fr;
            }
        }

        /* ─── Scroll Hint for Horizontal Scrollable Areas ─── */
        @media (max-width: 768px) {
            .scroll-hint-container {
                position: relative;
            }
            .scroll-hint-container::after {
                content: '';
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                width: 40px;
                background: linear-gradient(to left, rgba(15, 23, 42, 0.9), transparent);
                pointer-events: none;
                opacity: 1;
                transition: opacity 0.3s;
            }
            .scroll-hint-container.scrolled-end::after {
                opacity: 0;
            }
        }

        /* ─── Mobile Pull-to-Refresh Visual Indicator ─── */
        @media (max-width: 768px) {
            .pull-indicator {
                display: none;
                position: fixed;
                top: 0;
                left: 50%;
                transform: translateX(-50%);
                padding: 8px 16px;
                background: rgba(var(--theme-primary-rgb), 0.9);
                color: white;
                border-radius: 0 0 12px 12px;
                font-size: 12px;
                z-index: 1000;
            }
            .pull-indicator.active {
                display: block;
            }
        }

        /* ─── GAMEVIS / Advanced Games View - Mobile Responsive ─── */
        @media (max-width: 768px) {
            .gv-container {
                padding: 12px 8px;
            }

            /* Upload Section */
            .gv-container .gv-upload-section {
                padding: 24px 16px;
                min-height: auto;
            }
            .gv-container .gv-upload-section h2 {
                font-size: 20px;
            }
            .gv-container .gv-upload-section .gv-splash-subtitle {
                font-size: 12px;
            }
            .gv-container .gv-upload-buttons {
                flex-direction: column;
                gap: 10px;
            }
            .gv-container .gv-upload-btn {
                width: 100%;
                padding: 14px 20px;
            }
            .gv-container .gv-splash-features {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            /* Browser Header */
            .gv-container .gv-browser-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
            .gv-container .gv-browser-header h2 {
                font-size: 16px;
            }
            .gv-container .gv-browser-controls {
                width: 100%;
                flex-wrap: wrap;
            }
            .gv-container .gv-filter-select {
                flex: 1;
                min-width: 120px;
                font-size: 14px;
            }
            .gv-container .gv-game-count {
                width: 100%;
                justify-content: flex-start;
            }

            /* Game Cards */
            .gv-container .gv-game-card {
                border-radius: 10px;
            }
            /* Game card: restructure from 6-column grid to stacked mobile layout */
            .gv-container .gv-game-main {
                display: flex !important;
                flex-direction: column;
                align-items: center;
                gap: 8px;
                padding: 12px !important;
                grid-template-columns: none !important;
            }
            /* Expand button - top left */
            .gv-container .gv-expand-btn {
                position: absolute;
                left: 8px;
                top: 8px;
            }
            .gv-container .gv-game-card {
                position: relative;
            }
            /* Score block: centered, prominent */
            .gv-container .gv-score-block {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 12px;
                width: 100%;
                order: 1;
                padding: 6px 0;
            }
            .gv-container .gv-score {
                font-size: 28px;
            }
            .gv-container .gv-score-divider {
                margin: 0;
                height: 32px;
            }
            /* Teams: side by side, flanking the scores */
            .gv-container .gv-team {
                flex: none;
                text-align: center !important;
            }
            .gv-container .gv-team.home {
                order: 0;
                width: 100%;
            }
            .gv-container .gv-team.away {
                order: 2;
                width: 100%;
            }
            .gv-container .gv-team-name {
                font-size: 13px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 100%;
            }
            /* Date: below scores */
            .gv-container .gv-game-date {
                order: 3;
                font-size: 10px;
                width: 100%;
                text-align: center;
            }
            /* Analyze button: full width at bottom */
            .gv-container .gv-load-btn {
                order: 4;
                width: 100%;
                text-align: center;
                padding: 10px 16px;
                font-size: 12px;
            }
            .gv-container .gv-game-date {
                font-size: 10px;
            }
            .gv-container .gv-load-btn {
                width: 100%;
                padding: 12px;
            }

            /* Tab Container - horizontally scrollable on mobile */
            .gv-container .gv-tab-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                flex-wrap: nowrap;
                width: 100% !important;
                max-width: 100vw;
                scrollbar-width: none;
            }
            .gv-container .gv-tab-container::-webkit-scrollbar { display: none; }
            .gv-container .gv-tab-btn {
                flex-shrink: 0;
                padding: 8px 12px;
                font-size: 11px;
                white-space: nowrap;
            }

            /* Game Header in Visualization - compact mobile layout */
            .gv-container .gv-game-header {
                display: flex !important;
                flex-direction: row !important;
                align-items: center !important;
                gap: 8px !important;
                padding: 12px !important;
                width: 100%;
                box-sizing: border-box;
            }
            .gv-container .gv-team-block {
                display: flex !important;
                flex-direction: column !important;
                align-items: center !important;
                text-align: center;
                flex: 1;
                min-width: 0;
                overflow: hidden;
            }
            .gv-container .gv-team-block.away {
                flex-direction: column !important;
            }
            .gv-container .gv-team-logo {
                width: 40px;
                height: 40px;
                min-width: 40px;
                margin: 0 auto 4px;
                font-size: 13px;
            }
            .gv-container .gv-team-content {
                min-width: 0;
                width: 100%;
            }
            .gv-container .gv-team-content h3 {
                font-size: 13px;
                line-height: 1.2;
                word-wrap: break-word;
                overflow-wrap: break-word;
                margin-bottom: 4px;
            }
            .gv-container .gv-result-tag {
                font-size: 10px !important;
                padding: 2px 6px !important;
            }
            .gv-container .gv-score-center {
                flex-shrink: 0;
            }
            .gv-container .gv-score-display {
                margin: 0;
            }
            .gv-container .gv-score-value {
                font-size: 26px;
            }
            .gv-container .gv-score-sep {
                margin: 0 4px;
            }

            /* Stats Grid */
            .gv-container .gv-stats-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            .gv-container .gv-stat-card {
                padding: 14px;
            }
            .gv-container .gv-stat-card.full-width {
                grid-column: span 1;
            }

            /* Four Factors Grid */
            .gv-container .gv-factors-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            .gv-container .gv-factor-block {
                padding: 10px;
            }
            .gv-container .gv-factor-val {
                font-size: 16px;
            }
            .gv-container .gv-factor-label {
                font-size: 9px;
            }

            /* Player Table - Horizontal Scroll */
            .gv-container .gv-player-table {
                display: block;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .gv-container .gv-player-table th,
            .gv-container .gv-player-table td {
                padding: 8px 6px;
                font-size: 11px;
                white-space: nowrap;
            }
            .gv-container .gv-player-table th {
                font-size: 9px;
            }
            .gv-container .gv-player-name {
                min-width: 100px;
            }
        }

        @media (max-width: 480px) {
            .gv-container .gv-factors-grid {
                grid-template-columns: 1fr 1fr;
            }
            .gv-container .gv-factor-values {
                flex-direction: column;
                gap: 4px;
            }
            .gv-container .gv-factor-val {
                font-size: 14px;
            }
            .gv-container .gv-score {
                font-size: 24px;
            }
            .gv-container .gv-player-table th,
            .gv-container .gv-player-table td {
                padding: 4px 2px;
                font-size: 10px;
            }
        }

        /* ─── GAMEVIS Advanced Game View - Enhanced Mobile (ported from GAMEVIS_with_ShotChart_v2_6) ─── */
        @media (max-width: 768px) {
            /* Shot Chart - Scale down on mobile */
            .gv-container .shot-chart-container,
            .gv-container [class*="shot-chart"] {
                max-width: 100%;
                overflow: hidden;
            }
            .gv-container .shot-chart-container svg,
            .gv-container [class*="shot-chart"] svg {
                max-width: 100%;
                height: auto;
            }

            /* Quarter Navigation - Horizontal scroll with snap */
            .gv-container .quarter-nav,
            .gv-container .gv-quarter-nav {
                display: flex;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                gap: 4px;
                scroll-snap-type: x mandatory;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .gv-container .quarter-nav::-webkit-scrollbar,
            .gv-container .gv-quarter-nav::-webkit-scrollbar { display: none; }
            .gv-container .quarter-nav button,
            .gv-container .gv-quarter-nav button {
                flex-shrink: 0;
                scroll-snap-align: start;
                padding: 10px 16px;
                font-size: 12px;
            }

            /* Player Table - Narrow first column with truncation */
            .gv-container .gv-player-table th:first-child,
            .gv-container .gv-player-table td:first-child {
                min-width: 65px !important;
                max-width: 65px !important;
                width: 65px !important;
                padding-left: 4px !important;
                font-size: 9px;
            }
            .gv-container .gv-player-table td:first-child span,
            .gv-container .gv-player-table td:first-child {
                display: block;
                max-width: 60px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                font-size: 10px;
            }
            /* Expanded state for player name column in game view */
            .gv-container .gv-player-table.player-col-expanded th:first-child,
            .gv-container .gv-player-table.player-col-expanded td:first-child {
                min-width: 140px !important;
                max-width: 140px !important;
                width: 140px !important;
            }
            .gv-container .gv-player-table.player-col-expanded td:first-child span,
            .gv-container .gv-player-table.player-col-expanded td:first-child {
                max-width: 130px;
                font-size: 12px;
            }

            /* Comparison View - Stack vertically */
            .gv-container .comparison-grid,
            .gv-container .gv-comparison-grid {
                grid-template-columns: 1fr !important;
            }
            .gv-container .comparison-panels,
            .gv-container .gv-comparison-panels {
                flex-direction: column;
                gap: 8px;
            }

            /* SVG Charts - Horizontal scroll wrapper */
            .gv-container .gv-stat-card.full-width {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .gv-container .gv-stat-card.full-width svg {
                min-width: 500px;
            }

            /* Modals - Full screen on mobile */
            .gv-container .modal-content,
            .gv-container .gv-modal-content {
                width: 100% !important;
                height: 100% !important;
                max-height: 100vh !important;
                border-radius: 0 !important;
                padding: 16px;
                padding-top: calc(16px + env(safe-area-inset-top, 0px));
            }

            /* Play-by-Play - Compact */
            .gv-container .play-item,
            .gv-container .gv-play-item {
                padding: 8px;
                font-size: 12px;
            }
            .gv-container .play-time,
            .gv-container .gv-play-time {
                font-size: 10px;
            }

            /* BPM Table - Horizontal Scroll */
            .gv-container .bpm-team-card,
            .gv-container .gv-bpm-card {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .gv-container .bpm-table,
            .gv-container .gv-bpm-table {
                min-width: 500px;
            }

            /* Player Name in tables */
            .gv-container .gv-player-name {
                min-width: 60px !important;
                max-width: 60px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                font-size: 10px;
            }

            /* Four Factors Comparison - Scrollable */
            .gv-container .four-factors-comparison,
            .gv-container .gv-four-factors-comparison {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Collapsed column groups bar */
            .gv-container .collapsed-groups-bar {
                display: flex;
                flex-wrap: wrap;
                gap: 6px;
                padding: 8px 12px;
                margin-bottom: 8px;
                background: rgba(30, 41, 59, 0.6);
                border-radius: 8px;
                align-items: center;
            }
            .gv-container .collapsed-group-chip {
                padding: 4px 8px;
                font-size: 10px;
                border-radius: 4px;
                cursor: pointer;
                background: rgba(71, 85, 105, 0.4);
                color: #94a3b8;
                border: 1px solid rgba(71, 85, 105, 0.5);
            }
            .gv-container .collapsed-group-chip.active {
                background: rgba(59, 130, 246, 0.2);
                color: #60a5fa;
                border-color: rgba(59, 130, 246, 0.4);
            }

            /* Legend - Wrap on mobile */
            .gv-container .legend,
            .gv-container .gv-legend {
                flex-wrap: wrap;
                gap: 4px;
            }
            .gv-container .legend-item,
            .gv-container .gv-legend-item {
                font-size: 10px;
                padding: 4px 8px;
            }

            /* Tab container scroll indicator */
            .gv-container .gv-tab-container::after {
                content: '›';
                position: sticky;
                right: 0;
                flex-shrink: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 28px;
                min-width: 28px;
                font-size: 18px;
                font-weight: 700;
                color: var(--gv-accent-cyan, #00d4ff);
                background: linear-gradient(90deg, transparent, rgba(15, 23, 42, 0.95) 40%);
                pointer-events: none;
            }
        }

        /* ─── Leaderboard Tab - Mobile Responsive ─── */
        @media (max-width: 768px) {
            /* Leaderboard table wrapper */
            .leaderboard-table-wrapper,
            [class*="leaderboard"] table {
                display: block;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Leaderboard controls */
            .leaderboard-controls {
                flex-direction: column;
                gap: 12px;
            }
            .leaderboard-controls select,
            .leaderboard-controls input {
                width: 100%;
            }

            /* Leaderboard columns panel */
            .leaderboard-columns-panel {
                max-height: 200px;
                overflow-y: auto;
            }

            /* Leaderboard table cells */
            [class*="leaderboard"] th,
            [class*="leaderboard"] td {
                padding: 8px 6px;
                font-size: 11px;
                white-space: nowrap;
            }

            /* Player cards in leaderboard if shown as cards */
            .leaderboard-player-card {
                padding: 12px;
            }
        }

        /* ─── Inline-styled Grid Override for Mobile (handles React inline styles) ─── */
        @media (max-width: 768px) {
            /* Override inline grid styles within .section elements */
            .section > div[style*="gridTemplateColumns: 1fr 1fr"],
            .section > div[style*="grid-template-columns: 1fr 1fr"] {
                grid-template-columns: 1fr !important;
            }
            .section > div[style*="gridTemplateColumns: repeat"],
            .section > div[style*="grid-template-columns: repeat"] {
                grid-template-columns: 1fr !important;
            }

            /* Transition tab specific - two column layouts */
            .section div[style*="gridTemplateColumns: '1fr 1fr'"],
            .section div > div[style*="gridTemplateColumns"] {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
            }

            /* Nested grids within sections - make responsive */
            .section div[style*="display: grid"] {
                gap: 10px !important;
            }

            /* Large stat values */
            .section div[style*="fontSize: 32px"],
            .section div[style*="font-size: 32px"] {
                font-size: 24px !important;
            }

            /* Smaller text in sections */
            .section div[style*="fontSize: 11px"],
            .section div[style*="font-size: 11px"] {
                font-size: 10px !important;
            }
        }

        /* ─── Assist Network Tab - Mobile ─── */
        @media (max-width: 768px) {
            /* Assist network visualization container */
            .section div[style*="display: flex"][style*="gap: 24px"] {
                flex-direction: column !important;
                gap: 16px !important;
            }

            /* Assist connection cards */
            .section div[style*="background: rgba"][style*="borderRadius"][style*="padding: 16px"] {
                padding: 12px !important;
            }

            /* Assist player circles */
            .section div[style*="width: 48px"][style*="height: 48px"] {
                width: 40px !important;
                height: 40px !important;
            }
            .section div[style*="width: 64px"][style*="height: 64px"] {
                width: 48px !important;
                height: 48px !important;
            }
        }

        /* ─── Clutch Tab - Mobile ─── */
        @media (max-width: 768px) {
            /* Clutch stats container */
            .section div[style*="gap: 24px"][style*="gridTemplateColumns"] {
                grid-template-columns: 1fr !important;
                gap: 16px !important;
            }
        }

        /* ─── Rotations Tab - Mobile ─── */
        @media (max-width: 768px) {
            /* Rotation timeline scrollable */
            .section div[style*="overflowX: auto"],
            .section div[style*="overflow-x: auto"] {
                -webkit-overflow-scrolling: touch;
            }

            /* Rotation player names */
            .section div[style*="width: 100px"],
            .section div[style*="width: 120px"] {
                width: 80px !important;
                font-size: 10px !important;
            }
        }

        /* ─── Player Breakdown Tab - Mobile ─── */
        @media (max-width: 768px) {
            /* Player breakdown cards */
            .section div[style*="display: grid"][style*="gap: 16px"] {
                grid-template-columns: 1fr !important;
            }

            /* Player mini stats within breakdown */
            .section div[style*="gridTemplateColumns: repeat(3"],
            .section div[style*="gridTemplateColumns: repeat(4"],
            .section div[style*="gridTemplateColumns: repeat(5"],
            .section div[style*="gridTemplateColumns: repeat(6"] {
                grid-template-columns: repeat(2, 1fr) !important;
            }
        }

        /* ─── VS Starters Tab - Mobile ─── */
        @media (max-width: 768px) {
            /* VS Starters comparison rows */
            .section div[style*="display: flex"][style*="justify-content: space-between"] {
                flex-wrap: wrap;
                gap: 8px;
            }
        }

        /* ─── Lineup Builder Tab - Mobile ─── */
        @media (max-width: 768px) {
            /* Player selection grid in builder */
            .section div[style*="gridTemplateColumns: repeat(5, 1fr)"],
            .section div[style*="gridTemplateColumns: repeat(6, 1fr)"] {
                grid-template-columns: repeat(3, 1fr) !important;
            }

            /* Builder controls */
            .section div[style*="display: flex"][style*="flexWrap: wrap"] {
                gap: 8px !important;
            }
        }

        /* ─── General inline style overrides for touch ─── */
        @media (hover: none) and (pointer: coarse) {
            /* Make all clickable items larger */
            .section div[style*="cursor: pointer"] {
                min-height: 44px;
                min-width: 44px;
            }

            /* Better touch spacing */
            .section div[style*="gap: 8px"] {
                gap: 10px !important;
            }
            .section div[style*="gap: 12px"] {
                gap: 14px !important;
            }
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           ENHANCED MOBILE FUNCTIONALITY v2.1
           Advanced touch interactions, improved UX, and accessibility
           ═══════════════════════════════════════════════════════════════════════════ */

        /* ─── Mobile Header Improvements ─── */
        @media (max-width: 768px) {
            .header {
                position: sticky;
                top: 0;
                z-index: 100;
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.98), rgba(15, 23, 42, 0.98));
                backdrop-filter: blur(12px);
                -webkit-backdrop-filter: blur(12px);
                margin: -8px -8px 12px -8px;
                padding: 12px 16px;
                border-bottom: 1px solid rgba(71, 85, 105, 0.5);
            }
            .header h1 {
                font-size: 1.1rem;
                line-height: 1.3;
                margin-bottom: 0;
            }
        }

        /* ─── Enhanced Touch Feedback ─── */
        @media (hover: none) and (pointer: coarse) {
            /* Ripple effect base for buttons */
            .btn, .tab-btn, .subtab-btn, .upload-btn, .export-btn, .export-mode-tab {
                position: relative;
                overflow: hidden;
                -webkit-tap-highlight-color: transparent;
            }
            .btn:active, .tab-btn:active, .subtab-btn:active, .upload-btn:active {
                transform: scale(0.97);
                transition: transform 0.1s ease;
            }

            /* Touch feedback for cards */
            .stat-card:active,
            .player-card:active,
            .export-card-v2:active,
            .wowy-player-select:active,
            .compare-player-slot:active {
                transform: scale(0.98);
                transition: transform 0.1s ease;
            }

            /* Touch feedback for table rows */
            .full-table-row:active td,
            .wowy-table tr:active,
            .lineup-row:active {
                background: rgba(var(--theme-primary-rgb), 0.2) !important;
            }
        }

        /* ─── Improved Form Controls for Mobile ─── */
        @media (max-width: 768px) {
            /* Larger select dropdowns */
            select {
                appearance: none;
                -webkit-appearance: none;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2394a3b8' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
                background-repeat: no-repeat;
                background-position: right 12px center;
                padding-right: 36px !important;
            }

            /* Better input focus states */
            input:focus, select:focus, textarea:focus {
                outline: none;
                border-color: var(--theme-primary) !important;
                box-shadow: 0 0 0 3px rgba(var(--theme-primary-rgb), 0.2) !important;
            }

            /* Range slider improvements */
            input[type="range"] {
                -webkit-appearance: none;
                height: 8px;
                border-radius: 4px;
                background: rgba(71, 85, 105, 0.5);
            }
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 28px;
                height: 28px;
                border-radius: 50%;
                background: var(--theme-primary);
                cursor: pointer;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            }

            /* Checkbox improvements */
            input[type="checkbox"] {
                width: 22px !important;
                height: 22px !important;
                cursor: pointer;
            }
        }

        /* ─── Mobile Navigation Enhancements ─── */
        @media (max-width: 768px) {
            /* Controls bar - NOT sticky on mobile (too large, covers screen) */
            .controls {
                position: static !important;
                z-index: auto;
                backdrop-filter: none;
                -webkit-backdrop-filter: none;
                background: rgba(30, 41, 59, 0.95) !important;
            }

            /* Quick scroll to top button */
            .scroll-to-top {
                position: fixed;
                bottom: calc(16px + var(--safe-area-bottom));
                right: 16px;
                width: 48px;
                height: 48px;
                border-radius: 50%;
                background: linear-gradient(135deg, var(--theme-primary), var(--theme-accent));
                color: white;
                border: none;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 20px;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
                cursor: pointer;
                z-index: 997;
                opacity: 0;
                transform: translateY(20px);
                transition: opacity 0.3s, transform 0.3s;
                pointer-events: none;
            }
            .scroll-to-top.visible {
                opacity: 1;
                transform: translateY(0);
                pointer-events: auto;
            }

            /* Bottom sheet style for modals */
            .modal-content {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                top: auto;
                max-height: 90vh;
                border-radius: 20px 20px 0 0;
                animation: slideUp 0.3s ease-out;
            }
            @keyframes slideUp {
                from { transform: translateY(100%); }
                to { transform: translateY(0); }
            }

            /* Modal drag handle */
            .modal-content::before {
                content: '';
                display: block;
                width: 40px;
                height: 5px;
                background: rgba(148, 163, 184, 0.4);
                border-radius: 3px;
                margin: 0 auto 16px;
            }
        }

        /* ─── Enhanced Table Readability ─── */
        @media (max-width: 768px) {
            /* Zebra striping for tables */
            .full-table-wrapper tbody tr:nth-child(even) td {
                background: rgba(30, 41, 59, 0.3);
            }
            .full-table-wrapper tbody tr:nth-child(odd) td {
                background: rgba(15, 23, 42, 0.3);
            }

            /* Sticky first column with shadow */
            .full-table-wrapper > table > tbody > tr > td:first-child,
            .full-table-wrapper > table > tbody > tr > td:nth-child(2) {
                box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
            }

            /* Table scroll shadow indicators */
            .full-table-wrapper {
                position: relative;
            }
            .full-table-wrapper::after {
                content: '';
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                width: 30px;
                background: linear-gradient(to left, rgba(15, 23, 42, 0.8), transparent);
                pointer-events: none;
                z-index: 5;
            }

            /* Compact table mode */
            table.compact-mobile th,
            table.compact-mobile td {
                padding: 6px 4px !important;
                font-size: 10px !important;
            }
        }

        /* ─── Collapsible Sections ─── */
        @media (max-width: 768px) {
            .section.collapsible .section-title {
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 0;
                margin-bottom: 0;
            }
            .section.collapsible .section-title::after {
                content: '▼';
                font-size: 10px;
                transition: transform 0.3s ease;
                color: #94a3b8;
            }
            .section.collapsible.collapsed .section-title::after {
                transform: rotate(-90deg);
            }
            .section.collapsible .section-content {
                max-height: 2000px;
                overflow: hidden;
                transition: max-height 0.3s ease, opacity 0.3s ease;
            }
            .section.collapsible.collapsed .section-content {
                max-height: 0;
                opacity: 0;
            }
        }

        /* ─── Enhanced Button Accessibility ─── */
        @media (max-width: 768px) {
            /* Button group stacking */
            .flex-between .btn,
            .button-group .btn {
                flex: 1 1 calc(50% - 4px);
                min-width: calc(50% - 4px);
            }

            /* Full width primary actions */
            .btn-primary, .btn-success, .btn-impact {
                width: 100%;
                justify-content: center;
            }

            /* Icon-only buttons on mobile */
            .btn.icon-mobile {
                width: 44px;
                height: 44px;
                padding: 0;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .btn.icon-mobile .btn-text {
                display: none;
            }

            /* Floating action buttons */
            .fab-container {
                position: fixed;
                bottom: calc(80px + var(--safe-area-bottom));
                right: 16px;
                display: flex;
                flex-direction: column-reverse;
                gap: 12px;
                z-index: 998;
            }
            .fab {
                width: 56px;
                height: 56px;
                border-radius: 50%;
                border: none;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
                cursor: pointer;
                transition: transform 0.2s, box-shadow 0.2s;
            }
            .fab:active {
                transform: scale(0.95);
            }
            .fab-primary {
                background: linear-gradient(135deg, var(--theme-primary), #1d4ed8);
                color: white;
            }
            .fab-secondary {
                width: 44px;
                height: 44px;
                font-size: 18px;
                background: rgba(71, 85, 105, 0.9);
                color: white;
            }
        }

        /* ─── Mobile Card Improvements ─── */
        @media (max-width: 768px) {
            /* Swipeable card hints */
            .stat-card, .player-card, .export-card-v2 {
                touch-action: pan-y pinch-zoom;
            }

            /* Card loading skeletons */
            .skeleton {
                background: linear-gradient(90deg,
                    rgba(71, 85, 105, 0.3) 0%,
                    rgba(71, 85, 105, 0.5) 50%,
                    rgba(71, 85, 105, 0.3) 100%);
                background-size: 200% 100%;
                animation: shimmer 1.5s infinite;
                border-radius: 8px;
            }
            @keyframes shimmer {
                0% { background-position: -200% 0; }
                100% { background-position: 200% 0; }
            }

            /* Empty state improvements */
            .empty-state {
                text-align: center;
                padding: 40px 20px;
            }
            .empty-state-icon {
                font-size: 48px;
                margin-bottom: 16px;
                opacity: 0.5;
            }
            .empty-state-text {
                color: #64748b;
                font-size: 14px;
            }
        }

        /* ─── Performance Optimizations ─── */
        @media (max-width: 768px) {
            /* GPU acceleration for animations */
            .btn, .tab-btn, .stat-card, .modal-content, .section {
                will-change: transform;
            }

            /* Reduce motion for accessibility */
            @media (prefers-reduced-motion: reduce) {
                *, *::before, *::after {
                    animation-duration: 0.01ms !important;
                    animation-iteration-count: 1 !important;
                    transition-duration: 0.01ms !important;
                }
            }

            /* Contain layout for better performance */
            .section, .stat-card, .player-card {
                contain: layout style;
            }

            /* Optimize scrolling */
            .full-table-wrapper, .modal-content, .wowy-table {
                will-change: scroll-position;
                -webkit-transform: translateZ(0);
                transform: translateZ(0);
            }
        }

        /* ─── Improved Mobile Typography ─── */
        @media (max-width: 768px) {
            /* Prevent text overflow */
            .player-name, .team-name, .stat-label, .section-title {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            /* Readable line heights */
            p, .text-content {
                line-height: 1.6;
            }

            /* Larger tap targets for links */
            a, .player-link {
                display: inline-block;
                padding: 4px 0;
            }
        }

        /* ─── Mobile Data Visualization ─── */
        @media (max-width: 768px) {
            /* Smaller chart containers */
            .shot-dist-bar {
                height: 36px;
            }
            .shot-segment {
                font-size: 9px;
                line-height: 1.2;
            }

            /* Compact pace bars */
            .pace-bar {
                height: 20px;
            }
            .pace-marker {
                height: 28px;
                top: -4px;
            }

            /* Progress bars */
            .percentile-bar-container {
                min-height: 10px !important;
            }

            /* Legend compact mode */
            .color-legend {
                justify-content: center;
            }
            .legend-item {
                padding: 2px 6px;
                font-size: 9px;
            }
        }

        /* ─── Mobile Upload Screen ─── */
        @media (max-width: 768px) {
            .upload-screen {
                min-height: calc(100vh - 120px);
                padding: 20px 12px;
            }
            .upload-box {
                padding: 24px 16px;
            }
            .upload-box h2 {
                font-size: 18px;
                margin-bottom: 8px;
            }
            .upload-box p {
                font-size: 13px;
                line-height: 1.5;
            }

            /* File input styling */
            .upload-btn input[type="file"] {
                position: absolute;
                width: 100%;
                height: 100%;
                opacity: 0;
                cursor: pointer;
            }
            .upload-btn {
                position: relative;
                overflow: hidden;
            }

            /* Drag and drop zone */
            .drop-zone {
                border: 2px dashed rgba(var(--theme-primary-rgb), 0.4);
                border-radius: 12px;
                padding: 30px 20px;
                text-align: center;
                transition: all 0.3s ease;
            }
            .drop-zone.active {
                border-color: var(--theme-primary);
                background: rgba(var(--theme-primary-rgb), 0.1);
            }
        }

        /* ─── Orientation-specific Styles ─── */
        @media (max-width: 768px) and (orientation: landscape) {
            /* Landscape mode optimizations */
            .header {
                padding: 8px 16px;
            }
            .header h1 {
                font-size: 1rem;
            }
            .controls {
                padding: 10px;
            }
            .section {
                padding: 10px;
            }
            .stats-grid {
                grid-template-columns: repeat(5, 1fr) !important;
            }
            .modal-content {
                max-height: 100vh;
                border-radius: 0;
            }
            .mobile-tab-bar {
                padding: 4px 8px;
            }
        }

        /* ─── Dark Mode Enhancements for Mobile ─── */
        @media (max-width: 768px) {
            /* OLED-friendly pure blacks */
            @media (prefers-color-scheme: dark) {
                body {
                    background: #000 !important;
                }
                .section, .controls, .modal-content {
                    background: rgba(15, 23, 42, 0.98) !important;
                }
            }
        }

        /* ─── Safe Area Handling for Notched Devices ─── */
        @supports (padding: max(0px)) {
            @media (max-width: 768px) {
                body {
                    padding-left: max(8px, env(safe-area-inset-left));
                    padding-right: max(8px, env(safe-area-inset-right));
                    padding-bottom: max(8px, env(safe-area-inset-bottom));
                }
                .mobile-tab-bar {
                    padding-bottom: max(8px, env(safe-area-inset-bottom));
                }
                .modal-content {
                    padding-bottom: max(16px, env(safe-area-inset-bottom));
                }
            }
        }

        /* ─── Improved Touch Scrolling ─── */
        @media (max-width: 768px) {
            /* Momentum scrolling everywhere */
            * {
                -webkit-overflow-scrolling: touch;
            }

            /* Scroll snap for horizontal lists */
            .tab-nav, .analyzer-subtabs, .export-mode-tabs {
                scroll-snap-type: x mandatory;
                scroll-padding: 0 16px;
            }
            .tab-btn, .subtab-btn, .export-mode-tab {
                scroll-snap-align: start;
            }

            /* Overscroll behavior */
            body, .container, .modal-content {
                overscroll-behavior-y: contain;
            }

            /* Hide scrollbars but keep functionality */
            .tab-nav::-webkit-scrollbar,
            .analyzer-subtabs::-webkit-scrollbar,
            .export-mode-tabs::-webkit-scrollbar,
            .full-table-wrapper::-webkit-scrollbar {
                height: 0;
                width: 0;
            }
        }

        /* ─── Loading States ─── */
        @media (max-width: 768px) {
            .loading-overlay {
                position: fixed;
                inset: 0;
                background: rgba(15, 23, 42, 0.9);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            }
            .loading-spinner {
                width: 48px;
                height: 48px;
                border: 4px solid rgba(var(--theme-primary-rgb), 0.2);
                border-top-color: var(--theme-primary);
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }
            .loading-text {
                margin-top: 16px;
                color: #94a3b8;
                font-size: 14px;
            }
        }

        /* ─── Touch Active States (for JS-enhanced feedback) ─── */
        @media (hover: none) and (pointer: coarse) {
            .touch-active {
                transform: scale(0.97) !important;
                opacity: 0.85 !important;
                transition: transform 0.1s ease, opacity 0.1s ease !important;
            }

            /* Table scroll shadows */
            .full-table-wrapper.scrolled-start::before {
                content: '';
                position: absolute;
                top: 0;
                left: 60px;
                bottom: 0;
                width: 20px;
                background: linear-gradient(to right, rgba(15, 23, 42, 0.6), transparent);
                pointer-events: none;
                z-index: 5;
            }
            .full-table-wrapper:not(.scrolled-end)::after {
                opacity: 1;
            }
            .full-table-wrapper.scrolled-end::after {
                opacity: 0;
            }
        }

        /* ─── Bottom Sheet Modal Style ─── */
        @media (max-width: 768px) {
            .modal-overlay {
                align-items: flex-end !important;
            }
            .modal-content {
                margin: 0;
                max-width: 100%;
                width: 100%;
                animation: modalSlideUp 0.3s ease-out;
            }
            @keyframes modalSlideUp {
                from {
                    transform: translateY(100%);
                    opacity: 0;
                }
                to {
                    transform: translateY(0);
                    opacity: 1;
                }
            }

            /* Modal drag indicator */
            .modal-content::before {
                content: '';
                display: block;
                width: 36px;
                height: 4px;
                background: rgba(148, 163, 184, 0.4);
                border-radius: 2px;
                margin: 0 auto 12px;
            }
        }

        /* ─── Sticky Header Shadow ─── */
        @media (max-width: 768px) {
            .header {
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            }
            .controls {
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            }
        }

        /* ─── Pull-down Refresh Indicator ─── */
        @media (max-width: 768px) {
            .pull-refresh-indicator {
                position: fixed;
                top: -60px;
                left: 50%;
                transform: translateX(-50%);
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: var(--theme-primary);
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                transition: top 0.3s ease;
                z-index: 1001;
            }
            .pull-refresh-indicator.visible {
                top: 20px;
            }
            .pull-refresh-indicator.loading::after {
                content: '';
                width: 20px;
                height: 20px;
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-top-color: white;
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
            }
        }

        /* ─── Mobile Action Sheet ─── */
        @media (max-width: 768px) {
            .action-sheet {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: rgba(30, 41, 59, 0.98);
                backdrop-filter: blur(12px);
                border-radius: 20px 20px 0 0;
                padding: 20px;
                padding-bottom: calc(20px + var(--safe-area-bottom));
                transform: translateY(100%);
                transition: transform 0.3s ease;
                z-index: 1002;
            }
            .action-sheet.open {
                transform: translateY(0);
            }
            .action-sheet-backdrop {
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.5);
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.3s ease;
                z-index: 1001;
            }
            .action-sheet-backdrop.open {
                opacity: 1;
                pointer-events: auto;
            }
            .action-sheet-item {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 16px;
                border-radius: 12px;
                font-size: 16px;
                color: #e2e8f0;
                cursor: pointer;
                transition: background 0.2s;
            }
            .action-sheet-item:active {
                background: rgba(var(--theme-primary-rgb), 0.2);
            }
            .action-sheet-cancel {
                margin-top: 12px;
                background: rgba(239, 68, 68, 0.15);
                color: #f87171;
                justify-content: center;
            }
        }

        /* ─── Swipe Navigation Hint ─── */
        @media (max-width: 768px) {
            .swipe-hint {
                position: fixed;
                bottom: calc(100px + var(--safe-area-bottom));
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 12px;
                opacity: 0;
                transition: opacity 0.3s ease;
                pointer-events: none;
                z-index: 900;
            }
            .swipe-hint.visible {
                opacity: 1;
            }
        }

        /* ─── Mobile Toast Notifications ─── */
        @media (max-width: 768px) {
            .toast {
                position: fixed;
                bottom: calc(90px + var(--safe-area-bottom));
                left: 16px;
                right: 16px;
                background: rgba(30, 41, 59, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(71, 85, 105, 0.5);
                border-radius: 12px;
                padding: 14px 18px;
                display: flex;
                align-items: center;
                gap: 12px;
                transform: translateY(100px);
                opacity: 0;
                transition: transform 0.3s ease, opacity 0.3s ease;
                z-index: 1000;
            }
            .toast.visible {
                transform: translateY(0);
                opacity: 1;
            }
            .toast-icon {
                font-size: 20px;
            }
            .toast-message {
                flex: 1;
                font-size: 14px;
                color: #e2e8f0;
            }
            .toast-close {
                padding: 4px;
                background: none;
                border: none;
                color: #94a3b8;
                cursor: pointer;
            }
            .toast.success {
                border-color: rgba(34, 197, 94, 0.5);
            }
            .toast.error {
                border-color: rgba(239, 68, 68, 0.5);
            }
        }

        /* ─── Focus Visible for Keyboard Navigation ─── */
        @media (max-width: 768px) {
            :focus-visible {
                outline: 2px solid var(--theme-primary);
                outline-offset: 2px;
            }
            button:focus:not(:focus-visible),
            a:focus:not(:focus-visible),
            input:focus:not(:focus-visible),
            select:focus:not(:focus-visible) {
                outline: none;
            }
        }

        /* ─── Print Styles (hide mobile UI when printing) ─── */
        @media print {
            .mobile-tab-bar,
            .scroll-to-top,
            .fab-container,
            .action-sheet,
            .toast {
                display: none !important;
            }
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           GOOGLE-GRADE MOBILE OPTIMIZATIONS v3.0
           Material Design 3 principles, WCAG AA compliance, 60fps animations
           ═══════════════════════════════════════════════════════════════════════════ */

        /* ─── Material Design Touch Targets (48dp minimum) ─── */
        @media (pointer: coarse) {
            /* All interactive elements must be at least 48x48dp */
            button, .btn, .tab-btn, .subtab-btn, .upload-btn,
            input[type="checkbox"], input[type="radio"],
            select, .clickable, [role="button"], [role="tab"],
            .wowy-player-select, .compare-player-slot, .lineup-row {
                min-height: 48px;
                min-width: 48px;
            }

            /* Ensure adequate spacing between touch targets (8dp minimum) */
            .btn + .btn,
            .tab-btn + .tab-btn,
            .subtab-btn + .subtab-btn {
                margin-left: 8px;
            }

            /* Links need padding for touch */
            a:not(.btn) {
                padding: 12px 4px;
                margin: -12px -4px;
                display: inline-block;
            }

            /* Table cells as touch targets */
            td.clickable, th.sortable {
                min-height: 48px;
                padding: 14px 12px;
            }
        }

        /* ─── WCAG AA Color Contrast Compliance ─── */
        @media (max-width: 768px) {
            /* Ensure 4.5:1 contrast ratio for normal text, 3:1 for large text */
            .text-muted, .text-secondary, .stat-label, .text-xs {
                color: #94a3b8; /* Passes 4.5:1 on dark bg */
            }

            /* High contrast mode support */
            @media (prefers-contrast: high) {
                .btn, .tab-btn, .subtab-btn {
                    border: 2px solid currentColor !important;
                }
                .section {
                    border: 2px solid #64748b !important;
                }
                .stat-card {
                    border: 2px solid var(--theme-primary) !important;
                }
            }

            /* Forced colors mode (Windows High Contrast) */
            @media (forced-colors: active) {
                .btn, .tab-btn {
                    border: 2px solid ButtonText !important;
                }
            }
        }

        /* ─── 60fps Animation Performance ─── */
        @media (max-width: 768px) {
            /* Use transform and opacity only for animations (compositor-only properties) */
            .animate-slide {
                will-change: transform;
                transform: translateZ(0);
            }

            .animate-fade {
                will-change: opacity;
            }

            /* Disable animations for battery saver / reduced motion */
            @media (prefers-reduced-motion: reduce) {
                *, *::before, *::after {
                    animation-duration: 0.001ms !important;
                    animation-iteration-count: 1 !important;
                    transition-duration: 0.001ms !important;
                    scroll-behavior: auto !important;
                }
            }

            /* Hardware acceleration for scrolling containers */
            .full-table-wrapper,
            .modal-content,
            .tab-nav,
            .analyzer-subtabs {
                transform: translateZ(0);
                backface-visibility: hidden;
                perspective: 1000px;
            }

            /* Contain paint for isolated repaints */
            .section, .stat-card, .player-card, .modal-content {
                contain: layout style paint;
            }
        }

        /* ─── Responsive Typography Scale ─── */
        @media (max-width: 768px) {
            :root {
                /* Fluid type scale - minimum 16px base for accessibility */
                --text-xs: clamp(0.625rem, 2.5vw, 0.75rem);    /* 10-12px */
                --text-sm: clamp(0.75rem, 3vw, 0.875rem);      /* 12-14px */
                --text-base: clamp(0.875rem, 3.5vw, 1rem);     /* 14-16px */
                --text-lg: clamp(1rem, 4vw, 1.125rem);         /* 16-18px */
                --text-xl: clamp(1.125rem, 4.5vw, 1.25rem);    /* 18-20px */
                --text-2xl: clamp(1.25rem, 5vw, 1.5rem);       /* 20-24px */
                --text-3xl: clamp(1.5rem, 6vw, 1.875rem);      /* 24-30px */
            }

            /* Apply fluid typography */
            body { font-size: var(--text-base); }
            .text-xs { font-size: var(--text-xs); }
            .text-sm, .stat-label { font-size: var(--text-sm); }
            .section-title { font-size: var(--text-xl); }
            .header h1 { font-size: var(--text-2xl); }
            .stat-value { font-size: var(--text-xl); }

            /* Ensure minimum readable line length */
            p, .text-content {
                max-width: 65ch;
                line-height: 1.6;
            }
        }

        /* ─── Loading Skeleton States (Content-aware) ─── */
        @media (max-width: 768px) {
            .skeleton-text {
                background: linear-gradient(
                    90deg,
                    rgba(71, 85, 105, 0.2) 0%,
                    rgba(71, 85, 105, 0.4) 50%,
                    rgba(71, 85, 105, 0.2) 100%
                );
                background-size: 200% 100%;
                animation: skeleton-shimmer 1.5s ease-in-out infinite;
                border-radius: 4px;
                color: transparent !important;
                user-select: none;
            }

            .skeleton-circle {
                background: linear-gradient(
                    90deg,
                    rgba(71, 85, 105, 0.2) 0%,
                    rgba(71, 85, 105, 0.4) 50%,
                    rgba(71, 85, 105, 0.2) 100%
                );
                background-size: 200% 100%;
                animation: skeleton-shimmer 1.5s ease-in-out infinite;
                border-radius: 50%;
            }

            .skeleton-card {
                background: linear-gradient(
                    90deg,
                    rgba(71, 85, 105, 0.1) 0%,
                    rgba(71, 85, 105, 0.2) 50%,
                    rgba(71, 85, 105, 0.1) 100%
                );
                background-size: 200% 100%;
                animation: skeleton-shimmer 1.5s ease-in-out infinite;
                border-radius: 12px;
                min-height: 120px;
            }

            @keyframes skeleton-shimmer {
                0% { background-position: 200% 0; }
                100% { background-position: -200% 0; }
            }
        }

        /* ─── Error & Empty States ─── */
        @media (max-width: 768px) {
            .error-state {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 48px 24px;
                text-align: center;
            }

            .error-state-icon {
                width: 64px;
                height: 64px;
                margin-bottom: 16px;
                color: #f87171;
                opacity: 0.8;
            }

            .error-state-title {
                font-size: var(--text-lg);
                font-weight: 600;
                color: #e2e8f0;
                margin-bottom: 8px;
            }

            .error-state-message {
                font-size: var(--text-sm);
                color: #94a3b8;
                margin-bottom: 24px;
                max-width: 280px;
            }

            .error-state-action {
                min-width: 200px;
            }

            .empty-state {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 48px 24px;
                text-align: center;
            }

            .empty-state-illustration {
                width: 120px;
                height: 120px;
                margin-bottom: 24px;
                opacity: 0.6;
            }

            .empty-state-title {
                font-size: var(--text-lg);
                font-weight: 600;
                color: #e2e8f0;
                margin-bottom: 8px;
            }

            .empty-state-description {
                font-size: var(--text-sm);
                color: #94a3b8;
                max-width: 280px;
            }
        }

        /* ─── Gesture Feedback & Ripple Effects ─── */
        @media (pointer: coarse) {
            /* Material-style ripple container */
            .ripple-container {
                position: relative;
                overflow: hidden;
            }

            .ripple-container::after {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                width: 0;
                height: 0;
                background: rgba(255, 255, 255, 0.3);
                border-radius: 50%;
                transform: translate(-50%, -50%);
                opacity: 0;
                transition: width 0.3s ease, height 0.3s ease, opacity 0.3s ease;
            }

            .ripple-container:active::after {
                width: 200%;
                height: 200%;
                opacity: 1;
                transition: width 0s, height 0s, opacity 0s;
            }

            /* Pressed state */
            .btn:active, .tab-btn:active, .subtab-btn:active {
                transform: scale(0.98);
                filter: brightness(0.95);
            }

            /* Swipe indicator for horizontal scrollables */
            .swipeable::after {
                content: '';
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                width: 24px;
                background: linear-gradient(to left, var(--theme-bg), transparent);
                pointer-events: none;
                opacity: 0.8;
            }

            .swipeable.scrolled-end::after {
                opacity: 0;
            }
        }

        /* ─── Smart Keyboard Handling ─── */
        @media (max-width: 768px) {
            /* When virtual keyboard is open */
            body.keyboard-open {
                /* Prevent layout shift */
                height: 100%;
                overflow: hidden;
            }

            body.keyboard-open .modal-content {
                /* Adjust modal for keyboard */
                max-height: 50vh;
                transition: max-height 0.3s ease;
            }

            body.keyboard-open .mobile-tab-bar {
                /* Hide bottom nav when keyboard is open */
                transform: translateY(100%);
            }

            /* Input containers should scroll into view */
            .input-container {
                scroll-margin-bottom: 120px;
            }
        }

        /* ─── Optimized Images & Media ─── */
        @media (max-width: 768px) {
            img, video {
                max-width: 100%;
                height: auto;
            }

            /* Lazy load placeholder */
            img[loading="lazy"] {
                background: linear-gradient(135deg, #1e293b, #334155);
                min-height: 100px;
            }

            /* Aspect ratio containers */
            .aspect-square { aspect-ratio: 1 / 1; }
            .aspect-video { aspect-ratio: 16 / 9; }
            .aspect-photo { aspect-ratio: 4 / 3; }

            /* Player photo optimization */
            .player-photo, .player-photo-placeholder {
                width: 44px;
                height: 44px;
                object-fit: cover;
                border-radius: 50%;
            }
        }

        /* ─── Network-Aware Styles ─── */
        @media (max-width: 768px) {
            /* Reduce visual complexity on slow connections */
            .reduce-motion {
                animation: none !important;
                transition: none !important;
            }

            /* Data saver mode - hide decorative elements */
            .data-saver .decorative,
            .data-saver .background-pattern,
            .data-saver::before,
            .data-saver::after {
                display: none !important;
            }
        }

        /* ─── Pull-to-Refresh Pattern ─── */
        @media (max-width: 768px) {
            .ptr-container {
                position: relative;
                overflow: hidden;
            }

            .ptr-indicator {
                position: absolute;
                top: -50px;
                left: 50%;
                transform: translateX(-50%);
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: var(--theme-bg-secondary);
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                transition: top 0.2s ease;
            }

            .ptr-indicator.pulling {
                top: 10px;
            }

            .ptr-indicator.refreshing {
                top: 10px;
            }

            .ptr-indicator.refreshing::after {
                content: '';
                width: 24px;
                height: 24px;
                border: 2px solid rgba(var(--theme-primary-rgb), 0.3);
                border-top-color: var(--theme-primary);
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
            }
        }

        /* ─── Bottom Sheet Pattern (Material Design 3) ─── */
        @media (max-width: 768px) {
            .bottom-sheet {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: var(--theme-bg-secondary);
                border-radius: 28px 28px 0 0;
                box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.3);
                transform: translateY(100%);
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                z-index: 1000;
                max-height: 90vh;
                overflow: hidden;
            }

            .bottom-sheet.open {
                transform: translateY(0);
            }

            .bottom-sheet-handle {
                width: 32px;
                height: 4px;
                background: rgba(148, 163, 184, 0.4);
                border-radius: 2px;
                margin: 12px auto;
            }

            .bottom-sheet-header {
                padding: 0 24px 16px;
                border-bottom: 1px solid rgba(71, 85, 105, 0.3);
            }

            .bottom-sheet-title {
                font-size: var(--text-lg);
                font-weight: 600;
                color: #e2e8f0;
            }

            .bottom-sheet-content {
                padding: 16px 24px;
                overflow-y: auto;
                max-height: calc(90vh - 100px);
                overscroll-behavior: contain;
            }

            .bottom-sheet-actions {
                padding: 16px 24px;
                padding-bottom: calc(16px + env(safe-area-inset-bottom));
                border-top: 1px solid rgba(71, 85, 105, 0.3);
                display: flex;
                gap: 12px;
            }
        }

        /* ─── Chip/Filter Pill Pattern ─── */
        @media (max-width: 768px) {
            .chip-container {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                padding: 8px 0;
            }

            .chip {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 8px 16px;
                background: rgba(71, 85, 105, 0.3);
                border: 1px solid rgba(71, 85, 105, 0.5);
                border-radius: 20px;
                font-size: var(--text-sm);
                color: #e2e8f0;
                cursor: pointer;
                transition: all 0.2s ease;
                min-height: 36px;
            }

            .chip:active {
                transform: scale(0.97);
            }

            .chip.selected {
                background: rgba(var(--theme-primary-rgb), 0.2);
                border-color: var(--theme-primary);
                color: var(--theme-primary);
            }

            .chip-remove {
                width: 18px;
                height: 18px;
                border-radius: 50%;
                background: rgba(239, 68, 68, 0.3);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                color: #f87171;
                margin-left: 4px;
                margin-right: -8px;
            }
        }

        /* ─── Segmented Control Pattern ─── */
        @media (max-width: 768px) {
            .segmented-control {
                display: flex;
                background: rgba(15, 23, 42, 0.6);
                border-radius: 12px;
                padding: 4px;
                gap: 4px;
            }

            .segmented-control-item {
                flex: 1;
                padding: 12px 16px;
                border-radius: 8px;
                font-size: var(--text-sm);
                font-weight: 600;
                color: #94a3b8;
                text-align: center;
                cursor: pointer;
                transition: all 0.2s ease;
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .segmented-control-item.active {
                background: var(--theme-primary);
                color: white;
                box-shadow: 0 2px 8px rgba(var(--theme-primary-rgb), 0.3);
            }
        }

        /* ─── Snackbar Pattern ─── */
        @media (max-width: 768px) {
            .snackbar {
                position: fixed;
                bottom: calc(80px + env(safe-area-inset-bottom));
                left: 16px;
                right: 16px;
                background: #1e293b;
                border-radius: 8px;
                padding: 14px 16px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 12px;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
                transform: translateY(calc(100% + 100px));
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                z-index: 999;
            }

            .snackbar.visible {
                transform: translateY(0);
            }

            .snackbar-message {
                font-size: var(--text-sm);
                color: #e2e8f0;
                flex: 1;
            }

            .snackbar-action {
                font-size: var(--text-sm);
                font-weight: 600;
                color: var(--theme-primary);
                background: none;
                border: none;
                padding: 8px 12px;
                margin: -8px -12px -8px 0;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
        }

        /* ─── Optimized Scrollbar ─── */
        @media (max-width: 768px) {
            /* Thin scrollbar for mobile */
            ::-webkit-scrollbar {
                width: 4px;
                height: 4px;
            }

            ::-webkit-scrollbar-track {
                background: transparent;
            }

            ::-webkit-scrollbar-thumb {
                background: rgba(148, 163, 184, 0.3);
                border-radius: 2px;
            }

            ::-webkit-scrollbar-thumb:active {
                background: rgba(148, 163, 184, 0.5);
            }

            /* Hide scrollbar but keep functionality */
            .hide-scrollbar {
                scrollbar-width: none;
                -ms-overflow-style: none;
            }

            .hide-scrollbar::-webkit-scrollbar {
                display: none;
            }
        }

        /* ─── Safe Area Handling (Notch/Home Indicator) ─── */
        @supports (padding: env(safe-area-inset-bottom)) {
            @media (max-width: 768px) {
                body {
                    padding-left: env(safe-area-inset-left);
                    padding-right: env(safe-area-inset-right);
                }

                .safe-area-bottom {
                    padding-bottom: env(safe-area-inset-bottom);
                }

                .safe-area-top {
                    padding-top: env(safe-area-inset-top);
                }

                /* Fixed elements need safe area consideration */
                .mobile-tab-bar {
                    padding-bottom: max(8px, env(safe-area-inset-bottom));
                }

                .bottom-sheet-actions {
                    padding-bottom: max(16px, env(safe-area-inset-bottom));
                }

                .modal-content {
                    padding-bottom: max(20px, env(safe-area-inset-bottom));
                }

                .snackbar {
                    bottom: calc(80px + env(safe-area-inset-bottom));
                }
            }
        }

        /* ─── Input Optimizations ─── */
        @media (max-width: 768px) {
            /* Prevent zoom on iOS when focusing inputs */
            input, select, textarea {
                font-size: 16px !important;
            }

            /* Better touch targets for inputs */
            input, select {
                min-height: 48px;
                padding: 12px 16px;
            }

            /* Search input pattern */
            .search-input {
                background: rgba(15, 23, 42, 0.6);
                border: 1px solid rgba(71, 85, 105, 0.5);
                border-radius: 24px;
                padding: 12px 16px 12px 44px;
                width: 100%;
            }

            .search-input-icon {
                position: absolute;
                left: 16px;
                top: 50%;
                transform: translateY(-50%);
                color: #64748b;
            }

            /* Clear button for inputs */
            .input-clear {
                position: absolute;
                right: 12px;
                top: 50%;
                transform: translateY(-50%);
                width: 24px;
                height: 24px;
                border-radius: 50%;
                background: rgba(71, 85, 105, 0.5);
                border: none;
                color: #94a3b8;
                font-size: 14px;
                cursor: pointer;
                display: none;
            }

            input:not(:placeholder-shown) + .input-clear {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        /* ─── Dark/Light Mode Transitions ─── */
        @media (max-width: 768px) {
            body, .section, .modal-content, .btn {
                transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            }
        }

        /* ═══════════════════════════════════════════════════════════════════════════
           PC/DESKTOP OPTIMIZATIONS v1.0 - Professional Computer Application Design
           Optimized for: Large monitors, ultra-wide displays, mouse/keyboard navigation
           ═══════════════════════════════════════════════════════════════════════════ */

        /* ─── Desktop Detection & Base Styles (min-width: 1200px) ─── */
        @media (min-width: 1200px) and (pointer: fine) {
            :root {
                --is-desktop: 1;
                --desktop-sidebar-width: 280px;
                --desktop-header-height: 70px;
                --desktop-content-max: 1800px;
            }

            body {
                padding: 24px 32px;
                font-size: 15px;
                line-height: 1.6;
                cursor: default;
            }

            .container {
                max-width: var(--desktop-content-max);
                margin: 0 auto;
            }

            /* Enhanced header for desktop */
            .header {
                margin-bottom: 32px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .header h1 {
                font-size: 2.8rem;
                letter-spacing: -0.5px;
            }

            /* Desktop grid optimizations - utilize screen space */
            .grid-5 { grid-template-columns: repeat(5, 1fr); gap: 16px; }
            .grid-4 { grid-template-columns: repeat(4, 1fr); gap: 20px; }
            .grid-3 { grid-template-columns: repeat(3, 1fr); gap: 20px; }
            .grid-2 { grid-template-columns: repeat(2, 1fr); gap: 24px; }
            .stats-grid { grid-template-columns: repeat(5, 1fr); gap: 20px; }

            /* Larger stat cards */
            .stat-card {
                padding: 24px;
                border-radius: 16px;
                transition: transform 0.2s ease, box-shadow 0.2s ease;
            }
            .stat-card:hover {
                transform: translateY(-4px);
                box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
            }
            .stat-label { font-size: 14px; margin-bottom: 10px; }
            .stat-value { font-size: 32px; }

            /* Enhanced controls panel */
            .controls {
                padding: 28px;
                border-radius: 16px;
            }

            .form-group {
                margin-bottom: 16px;
            }

            /* Refined form elements */
            select, input {
                padding: 12px 16px;
                font-size: 14px;
                border-radius: 10px;
                transition: border-color 0.2s ease, box-shadow 0.2s ease;
            }
            select:hover, input:hover {
                border-color: rgba(var(--theme-primary-rgb), 0.5);
            }
            select:focus, input:focus {
                border-color: var(--theme-primary);
                box-shadow: 0 0 0 3px rgba(var(--theme-primary-rgb), 0.15);
                outline: none;
            }

            /* Desktop button styles */
            .btn {
                padding: 10px 20px;
                font-size: 14px;
                border-radius: 10px;
                transition: all 0.2s ease;
                cursor: pointer;
            }
            .btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }
            .btn:active {
                transform: translateY(0);
            }

            /* Section improvements */
            .section {
                padding: 24px;
                border-radius: 16px;
            }
            .section-title {
                font-size: 20px;
                margin-bottom: 16px;
            }
        }

        /* ─── Large Desktop Breakpoint (1440px+) ─── */
        @media (min-width: 1440px) and (pointer: fine) {
            body { padding: 28px 48px; }
            .container { max-width: 1920px; }
            .header h1 { font-size: 3rem; }

            /* Even larger grids for big screens */
            .stats-grid { grid-template-columns: repeat(6, 1fr); }
            .export-cards-grid-v2 { grid-template-columns: repeat(6, 1fr); }

            /* Larger modals */
            .modal-content {
                max-width: 1600px;
                max-height: 90vh;
                padding: 40px;
            }
        }

        /* ─── Ultra-Wide Monitor Support (2000px+) ─── */
        @media (min-width: 2000px) and (pointer: fine) {
            body { padding: 32px 64px; }
            .container { max-width: 2400px; }

            .stats-grid { grid-template-columns: repeat(7, 1fr); }
            .export-cards-grid-v2 { grid-template-columns: repeat(7, 1fr); }

            /* Two-column layout for ultra-wide */
            .ultra-wide-layout {
                display: grid;
                grid-template-columns: 350px 1fr;
                gap: 32px;
            }
        }

        /* ─── Desktop Hover Effects ─── */
        @media (hover: hover) and (pointer: fine) {
            /* Refined hover states for all interactive elements */
            .btn:hover { opacity: 1; filter: brightness(1.1); }
            .tab-btn:hover { background: rgba(59, 130, 246, 0.15); }
            .subtab-btn:hover { background: rgba(71, 85, 105, 0.6); }

            /* Table row hover */
            .full-table-row:hover td {
                background: rgba(59, 130, 246, 0.15) !important;
            }

            /* Card hover effects */
            .player-card:hover {
                border-color: rgba(var(--theme-primary-rgb), 0.5);
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            }

            .export-card-v2:hover {
                transform: translateY(-4px);
                box-shadow: 0 12px 32px rgba(0, 212, 255, 0.2);
                border-color: #00d4ff;
            }

            .export-lineup-card-v2:hover {
                transform: translateY(-4px);
                box-shadow: 0 20px 48px rgba(59, 130, 246, 0.25);
            }

            /* Clickable section hover */
            .clickable-section:hover {
                transform: translateY(-3px);
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
                border-color: rgba(var(--theme-primary-rgb), 0.4);
            }

            /* Upload button hover */
            .upload-btn:hover {
                transform: translateY(-3px);
                box-shadow: 0 8px 24px rgba(var(--theme-primary-rgb), 0.3);
            }

            /* Link hover */
            a:hover { text-decoration: underline; }
            .player-link:hover { color: #3b82f6; }
        }

        /* ─── Desktop Keyboard Focus Styles ─── */
        @media (pointer: fine) {
            /* Visible focus rings for keyboard navigation */
            *:focus-visible {
                outline: 2px solid var(--theme-primary);
                outline-offset: 3px;
                border-radius: 4px;
            }

            /* Remove default outlines for mouse users */
            *:focus:not(:focus-visible) {
                outline: none;
            }

            /* Enhanced focus for buttons */
            .btn:focus-visible,
            .tab-btn:focus-visible,
            .subtab-btn:focus-visible {
                box-shadow: 0 0 0 3px rgba(var(--theme-primary-rgb), 0.4);
            }

            /* Focus within table cells */
            td:focus-within {
                background: rgba(var(--theme-primary-rgb), 0.1);
            }
        }

        /* ─── Desktop Table Optimizations ─── */
        @media (min-width: 1200px) and (pointer: fine) {
            /* Larger table viewport */
            .full-table-wrapper {
                max-height: 65vh !important;
                border-radius: 12px;
            }

            .full-table-wrapper.fullscreen {
                max-height: calc(100vh - 160px) !important;
            }

            /* Sticky header improvements */
            .full-table-wrapper > table > thead > tr > th {
                background: #1e293b !important;
                font-weight: 700;
            }
        }

        /* ─── Desktop Scrollbar Styling ─── */
        @media (min-width: 1200px) {
            /* Custom scrollbar for desktop */
            ::-webkit-scrollbar {
                width: 10px;
                height: 10px;
            }

            ::-webkit-scrollbar-track {
                background: rgba(15, 23, 42, 0.5);
                border-radius: 5px;
            }

            ::-webkit-scrollbar-thumb {
                background: linear-gradient(180deg, #475569, #334155);
                border-radius: 5px;
                border: 2px solid transparent;
                background-clip: padding-box;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: linear-gradient(180deg, #60a5fa, #3b82f6);
                background-clip: padding-box;
            }

            ::-webkit-scrollbar-corner {
                background: transparent;
            }

            /* Firefox scrollbar */
            * {
                scrollbar-width: thin;
                scrollbar-color: #475569 rgba(15, 23, 42, 0.5);
            }
        }

        /* ─── Desktop Modal Improvements ─── */
        @media (min-width: 1200px) and (pointer: fine) {
            .modal-overlay {
                backdrop-filter: blur(8px);
            }

            .modal-content {
                border-radius: 20px;
                box-shadow: 0 32px 80px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
                animation: modalFadeIn 0.25s ease-out;
            }

            @keyframes modalFadeIn {
                from {
                    opacity: 0;
                    transform: scale(0.95) translateY(-20px);
                }
                to {
                    opacity: 1;
                    transform: scale(1) translateY(0);
                }
            }

            .modal-close {
                transition: transform 0.2s ease, background 0.2s ease;
            }
            .modal-close:hover {
                transform: rotate(90deg) scale(1.1);
                background: #dc2626;
            }
        }

        /* ─── Desktop Tab Navigation ─── */
        @media (min-width: 1200px) and (pointer: fine) {
            .tab-nav {
                padding: 8px;
                border-radius: 16px;
                gap: 6px;
            }

            .tab-btn {
                padding: 14px 28px;
                font-size: 15px;
                border-radius: 10px;
                transition: all 0.2s ease;
            }

            .tab-btn.active {
                box-shadow: 0 4px 16px rgba(37, 99, 235, 0.4);
            }

            .analyzer-subtabs {
                padding: 10px 16px;
            }

            .subtab-btn {
                padding: 12px 20px;
            }
        }

        /* ─── Desktop Export View Enhancements ─── */
        @media (min-width: 1200px) and (pointer: fine) {
            .export-frame {
                padding: 40px;
                border-radius: 24px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            }

            .export-frame-title {
                font-size: 40px;
            }

            .export-controls {
                padding: 24px;
                gap: 20px;
            }

            .export-card-v3 {
                padding: 16px;
                padding-top: 18px;
            }

            .export-lineup-players-row {
                gap: 20px;
                padding: 32px 24px 24px;
            }

            .export-lineup-player-photo {
                width: 72px;
                height: 72px;
            }
        }

        /* ─── Desktop WOWY Improvements ─── */
        @media (min-width: 1200px) and (pointer: fine) {
            .wowy-container {
                border-radius: 16px;
            }

            .wowy-header {
                padding: 24px 28px;
            }

            .wowy-table th {
                padding: 14px 20px;
            }

            .wowy-table td {
                padding: 20px;
            }

            .wowy-player-badge {
                min-width: 85px;
            }

            .wowy-player-img {
                width: 56px;
                height: 56px;
                font-size: 20px;
            }

            .wowy-player-name {
                font-size: 11px;
                max-width: 80px;
            }
        }

        /* ─── Desktop Comparison View ─── */
        @media (min-width: 1200px) and (pointer: fine) {
            .compare-container {
                gap: 32px;
            }

            .compare-panel {
                padding: 28px;
                border-radius: 16px;
            }

            .compare-stat-row {
                padding: 14px 0;
            }

            .compare-stat-value {
                font-size: 20px;
            }
        }

        /* ─── Desktop Keyboard Shortcuts Indicator ─── */
        @media (min-width: 1200px) and (pointer: fine) {
            .kbd {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                padding: 4px 8px;
                font-family: 'Space Mono', monospace;
                font-size: 11px;
                font-weight: 600;
                color: #94a3b8;
                background: linear-gradient(180deg, #334155, #1e293b);
                border: 1px solid #475569;
                border-radius: 6px;
                box-shadow: 0 2px 0 #0f172a;
                min-width: 24px;
                text-transform: uppercase;
            }

            .shortcut-hint {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                margin-left: 8px;
                opacity: 0.6;
                font-size: 11px;
            }
        }

        /* ─── Desktop Context Menu Styles (DEFAULT - no media query) ─── */
        .context-menu {
            position: fixed;
            background: rgba(30, 41, 59, 0.98);
            backdrop-filter: blur(12px);
            border: 1px solid #475569;
            border-radius: 12px;
            padding: 6px;
            min-width: 200px;
            max-width: 280px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
            z-index: 10000;
            animation: contextMenuIn 0.15s ease-out;
        }

        @keyframes contextMenuIn {
            from {
                opacity: 0;
                transform: scale(0.95) translateY(-5px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .context-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 13px;
            color: #e2e8f0;
            cursor: pointer;
            transition: background 0.15s ease, color 0.15s ease;
            user-select: none;
        }

        .context-menu-item:hover {
            background: rgba(59, 130, 246, 0.25);
            color: #fff;
        }

        .context-menu-item:active {
            background: rgba(59, 130, 246, 0.4);
        }

        .context-menu-item-icon {
            width: 18px;
            text-align: center;
            font-size: 14px;
        }

        .context-menu-item-shortcut {
            margin-left: auto;
            font-size: 11px;
            color: #64748b;
            font-family: 'Space Mono', monospace;
            background: rgba(15, 23, 42, 0.5);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .context-menu-separator {
            height: 1px;
            background: linear-gradient(90deg, transparent, #475569, transparent);
            margin: 6px 10px;
        }

        /* Hide context menu on confirmed mobile */
        @media (max-width: 768px) and (pointer: coarse) {
            .context-menu {
                display: none !important;
            }
        }

        /* ─── Desktop Tooltip Improvements ─── */
        @media (min-width: 1200px) and (pointer: fine) {
            [data-tooltip] {
                position: relative;
            }

            [data-tooltip]::before {
                content: attr(data-tooltip);
                position: absolute;
                bottom: calc(100% + 8px);
                left: 50%;
                transform: translateX(-50%);
                padding: 8px 12px;
                background: rgba(15, 23, 42, 0.95);
                border: 1px solid #475569;
                border-radius: 8px;
                font-size: 12px;
                color: #e2e8f0;
                white-space: nowrap;
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.2s ease, visibility 0.2s ease;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            }

            [data-tooltip]:hover::before {
                opacity: 1;
                visibility: visible;
            }
        }

        /* ─── Desktop Print Optimization ─── */
        @media print {
            body {
                background: white !important;
                color: black !important;
                padding: 20px !important;
            }

            .header, .controls, .tab-nav, .modal-overlay,
            .mobile-tab-bar, .mobile-fab, .btn:not(.print-btn) {
                display: none !important;
            }

            .section {
                break-inside: avoid;
                page-break-inside: avoid;
                border: 1px solid #ddd !important;
                background: white !important;
            }

            table {
                font-size: 10px !important;
            }

            th, td {
                padding: 6px !important;
                border: 1px solid #ccc !important;
            }
        }

        /* ─── Desktop Resize Handle ─── */
        @media (min-width: 1200px) and (pointer: fine) {
            .resizable {
                position: relative;
            }

            .resize-handle {
                position: absolute;
                right: 0;
                bottom: 0;
                width: 20px;
                height: 20px;
                cursor: nwse-resize;
                background: linear-gradient(135deg, transparent 50%, rgba(var(--theme-primary-rgb), 0.3) 50%);
                border-radius: 0 0 8px 0;
                opacity: 0;
                transition: opacity 0.2s ease;
            }

            .resizable:hover .resize-handle {
                opacity: 1;
            }
        }

        /* ─── Desktop Drag and Drop ─── */
        @media (min-width: 1200px) and (pointer: fine) {
            .drop-zone {
                border: 2px dashed rgba(var(--theme-primary-rgb), 0.4);
                border-radius: 16px;
                padding: 40px 32px;
                text-align: center;
                transition: all 0.3s ease;
                cursor: pointer;
            }

            .drop-zone:hover {
                border-color: var(--theme-primary);
                background: rgba(var(--theme-primary-rgb), 0.05);
            }

            .drop-zone.drag-over {
                border-color: var(--theme-primary);
                background: rgba(var(--theme-primary-rgb), 0.1);
                transform: scale(1.02);
                box-shadow: 0 0 30px rgba(var(--theme-primary-rgb), 0.2);
            }

            .drop-zone-icon {
                font-size: 48px;
                margin-bottom: 16px;
                opacity: 0.6;
            }

            .drop-zone-text {
                font-size: 16px;
                color: #94a3b8;
            }
        }

        /* ─── Desktop Selection Styles ─── */
        @media (min-width: 1200px) {
            ::selection {
                background: rgba(var(--theme-primary-rgb), 0.3);
                color: #fff;
            }

            ::-moz-selection {
                background: rgba(var(--theme-primary-rgb), 0.3);
                color: #fff;
            }
        }

        /* ─── Desktop Performance Optimizations ─── */
        @media (min-width: 1200px) {
            /* GPU acceleration for smooth animations */
            .section, .stat-card, .modal-content, .export-card-v2,
            .export-lineup-card-v2, .wowy-container {
                transform: translateZ(0);
                will-change: transform, box-shadow;
            }

            /* Contain for layout isolation */
            .section, .stat-card, .player-card, .modal-content {
                contain: layout style;
            }

            /* Optimize repaints - use layout instead of strict to prevent height collapse */
            .full-table-wrapper {
                contain: layout style;
            }
        }

        /* ═══════════════════════════════════════════════════════════════════════════ */

        /* ═══════════════════════════════════════════════════════════════════════════
           GOOGLE-STYLE LEADERBOARD TABLE REDESIGN v2.0
           Modern Material Design aesthetics with performance optimizations
           ═══════════════════════════════════════════════════════════════════════════ */

        /* === CSS Performance Layer - Containment & GPU Acceleration === */
        .leaderboard-v2-container,
        .team-leaderboard-v2-container {
            contain: layout style paint;
        }

        .leaderboard-v2-table-scroll {
            contain: strict;
            content-visibility: auto;
            contain-intrinsic-size: auto 600px;
            overflow-x: auto;
            overflow-y: visible;
        }

        /* Performance: Hardware acceleration for sticky columns */
        .leaderboard-v2-table td.sticky-rank,
        .leaderboard-v2-table td.sticky-player,
        .leaderboard-v2-table td.sticky-team,
        .leaderboard-v2-table td.sticky-mins,
        .leaderboard-v2-table th.sticky-rank,
        .leaderboard-v2-table th.sticky-player,
        .leaderboard-v2-table th.sticky-team,
        .leaderboard-v2-table th.sticky-mins {
            transform: translateZ(0);
            backface-visibility: hidden;
            will-change: transform;
        }

        /* === Main Container === */
        .leaderboard-v2-container {
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.9) 100%);
            border: 1px solid rgba(71, 85, 105, 0.4);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(255, 255, 255, 0.02);
        }

        /* === Header Bar - Sleek Google-style === */
        .leaderboard-v2-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(139, 92, 246, 0.05) 100%);
            border-bottom: 1px solid rgba(71, 85, 105, 0.3);
            flex-wrap: wrap;
            gap: 12px;
        }

        .leaderboard-v2-title-group {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .leaderboard-v2-title {
            font-size: 18px;
            font-weight: 700;
            color: #f1f5f9;
            letter-spacing: -0.3px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .leaderboard-v2-title-icon {
            font-size: 20px;
        }

        .leaderboard-v2-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 20px;
            letter-spacing: 0.2px;
        }

        .leaderboard-v2-badge-primary {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.25) 0%, rgba(59, 130, 246, 0.15) 100%);
            color: #60a5fa;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .leaderboard-v2-badge-purple {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.25) 0%, rgba(139, 92, 246, 0.15) 100%);
            color: #a78bfa;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .leaderboard-v2-badge-amber {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.25) 0%, rgba(251, 191, 36, 0.15) 100%);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .leaderboard-v2-badge-cyan {
            background: linear-gradient(135deg, rgba(34, 211, 238, 0.25) 0%, rgba(34, 211, 238, 0.15) 100%);
            color: #22d3ee;
            border: 1px solid rgba(34, 211, 238, 0.3);
        }

        .leaderboard-v2-actions {
            display: flex;
            gap: 8px;
        }

        .leaderboard-v2-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            font-size: 12px;
            font-weight: 600;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.15s ease;
            letter-spacing: 0.2px;
        }

        .leaderboard-v2-btn-default {
            background: rgba(51, 65, 85, 0.8);
            color: #cbd5e1;
            border: 1px solid rgba(71, 85, 105, 0.5);
        }

        .leaderboard-v2-btn-default:hover {
            background: rgba(71, 85, 105, 0.9);
            color: #f1f5f9;
            border-color: rgba(100, 116, 139, 0.6);
        }

        .leaderboard-v2-btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .leaderboard-v2-btn-primary:hover {
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            transform: translateY(-1px);
        }

        .leaderboard-v2-btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        /* === Settings Panel - Collapsible Accordion === */
        .leaderboard-v2-settings {
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.6) 0%, rgba(15, 23, 42, 0.4) 100%);
            border-bottom: 1px solid rgba(71, 85, 105, 0.25);
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        /* === Settings Row - Filters Group === */
        .leaderboard-v2-filters-row {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: flex-end;
        }

        .leaderboard-v2-filter-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .leaderboard-v2-filter-label {
            font-size: 10px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .leaderboard-v2-select,
        .leaderboard-v2-input {
            padding: 8px 12px;
            font-size: 12px;
            background: rgba(15, 23, 42, 0.8);
            color: #e2e8f0;
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 8px;
            outline: none;
            transition: all 0.15s ease;
            min-width: 100px;
        }

        .leaderboard-v2-select:focus,
        .leaderboard-v2-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .leaderboard-v2-select:hover,
        .leaderboard-v2-input:hover {
            border-color: rgba(100, 116, 139, 0.7);
        }

        /* === Luck Adjustment Sliders - Google-style Range === */
        .leaderboard-v2-luck-group {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            padding: 12px 16px;
            background: rgba(251, 191, 36, 0.05);
            border: 1px solid rgba(251, 191, 36, 0.15);
            border-radius: 10px;
        }

        .leaderboard-v2-luck-slider {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 100px;
        }

        .leaderboard-v2-luck-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .leaderboard-v2-luck-label {
            font-size: 10px;
            font-weight: 600;
            color: #94a3b8;
        }

        .leaderboard-v2-luck-value {
            font-size: 11px;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .leaderboard-v2-luck-value-off {
            color: #4ade80;
            background: rgba(74, 222, 128, 0.15);
        }

        .leaderboard-v2-luck-value-def {
            color: #f87171;
            background: rgba(248, 113, 113, 0.15);
        }

        .leaderboard-v2-range {
            -webkit-appearance: none;
            appearance: none;
            width: 90px;
            height: 6px;
            background: rgba(71, 85, 105, 0.5);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .leaderboard-v2-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(251, 191, 36, 0.4);
            transition: transform 0.1s ease;
        }

        .leaderboard-v2-range::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .leaderboard-v2-range::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(251, 191, 36, 0.4);
        }

        /* === Mode Buttons - Pill Toggle Group === */
        .leaderboard-v2-mode-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .leaderboard-v2-mode-btn {
            padding: 8px 14px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 20px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .leaderboard-v2-mode-btn-green {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.3);
        }

        .leaderboard-v2-mode-btn-green:hover {
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
            transform: translateY(-1px);
        }

        .leaderboard-v2-mode-btn-blue {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .leaderboard-v2-mode-btn-blue:hover {
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            transform: translateY(-1px);
        }

        .leaderboard-v2-mode-btn-cyan {
            background: linear-gradient(135deg, #22d3ee 0%, #06b6d4 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(34, 211, 238, 0.3);
        }

        .leaderboard-v2-mode-btn-gray {
            background: rgba(71, 85, 105, 0.6);
            color: #cbd5e1;
            border: 1px solid rgba(100, 116, 139, 0.4);
        }

        .leaderboard-v2-mode-btn-gray:hover {
            background: rgba(100, 116, 139, 0.7);
            color: #f1f5f9;
        }

        .leaderboard-v2-divider {
            width: 1px;
            height: 24px;
            background: rgba(71, 85, 105, 0.5);
            margin: 0 4px;
        }

        /* === Preset Chips - Google-style Chips === */
        .leaderboard-v2-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        .leaderboard-v2-chip {
            padding: 5px 10px;
            font-size: 10px;
            font-weight: 600;
            border-radius: 16px;
            border: none;
            cursor: pointer;
            transition: all 0.15s ease;
            letter-spacing: 0.2px;
        }

        .leaderboard-v2-chip-inactive {
            background: rgba(51, 65, 85, 0.6);
            color: #94a3b8;
            border: 1px solid rgba(71, 85, 105, 0.4);
        }

        .leaderboard-v2-chip-inactive:hover {
            background: rgba(71, 85, 105, 0.7);
            color: #cbd5e1;
            border-color: rgba(100, 116, 139, 0.5);
        }

        .leaderboard-v2-chip-active {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: 1px solid rgba(59, 130, 246, 0.5);
            box-shadow: 0 2px 6px rgba(59, 130, 246, 0.25);
        }

        .leaderboard-v2-chip-purple {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.5) 0%, rgba(124, 58, 237, 0.5) 100%);
            color: #e0d4ff;
            border: 1px solid rgba(139, 92, 246, 0.4);
        }

        .leaderboard-v2-chip-amber {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .leaderboard-v2-chip-red {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        /* === Column Toggle Grid - Compact Checkboxes === */
        .leaderboard-v2-columns-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .leaderboard-v2-column-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 6px;
            border: 1px solid rgba(71, 85, 105, 0.3);
        }

        .leaderboard-v2-column-group-label {
            font-size: 9px;
            font-weight: 700;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-right: 4px;
        }

        .leaderboard-v2-column-btn {
            padding: 2px 6px;
            font-size: 9px;
            font-weight: 500;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .leaderboard-v2-column-btn-off {
            background: rgba(100, 116, 139, 0.2);
            color: #64748b;
        }

        .leaderboard-v2-column-btn-off:hover {
            background: rgba(100, 116, 139, 0.4);
            color: #94a3b8;
        }

        .leaderboard-v2-column-btn-on {
            background: #3b82f6;
            color: white;
        }

        .leaderboard-v2-column-btn-rapm {
            background: rgba(139, 92, 246, 0.5);
            color: #e0d4ff;
        }

        .leaderboard-v2-column-btn-apm {
            background: rgba(59, 130, 246, 0.5);
            color: #bfdbfe;
        }

        /* === Stat Filters Panel - Expandable === */
        .leaderboard-v2-stat-filters {
            padding: 12px 16px;
            background: rgba(15, 23, 42, 0.4);
            border-radius: 10px;
            border: 1px solid rgba(71, 85, 105, 0.25);
        }

        .leaderboard-v2-stat-filters-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .leaderboard-v2-stat-filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 8px;
        }

        .leaderboard-v2-stat-filter-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 6px 8px;
            background: transparent;
            border-radius: 6px;
            transition: background 0.1s ease;
        }

        .leaderboard-v2-stat-filter-item.active {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .leaderboard-v2-stat-filter-label {
            font-size: 9px;
            color: #94a3b8;
            font-weight: 500;
        }

        .leaderboard-v2-stat-filter-inputs {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .leaderboard-v2-stat-filter-input {
            width: 50px;
            padding: 4px 6px;
            font-size: 10px;
            background: rgba(15, 23, 42, 0.8);
            color: #e2e8f0;
            border: 1px solid rgba(71, 85, 105, 0.4);
            border-radius: 4px;
            outline: none;
        }

        .leaderboard-v2-stat-filter-input:focus {
            border-color: #3b82f6;
        }

        .leaderboard-v2-stat-filter-sep {
            font-size: 10px;
            color: #64748b;
        }

        /* === Table Wrapper - Optimized Scroll === */
        .leaderboard-v2-table-scroll {
            overflow-x: auto;
            overflow-y: auto;
            max-height: 520px;
            scroll-behavior: smooth;
            scrollbar-width: thin;
            scrollbar-color: rgba(100, 116, 139, 0.5) transparent;
        }

        .leaderboard-v2-table-scroll::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .leaderboard-v2-table-scroll::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
        }

        .leaderboard-v2-table-scroll::-webkit-scrollbar-thumb {
            background: rgba(100, 116, 139, 0.5);
            border-radius: 4px;
        }

        .leaderboard-v2-table-scroll::-webkit-scrollbar-thumb:hover {
            background: rgba(100, 116, 139, 0.7);
        }

        .leaderboard-v2-table-scroll.fullscreen {
            max-height: calc(100vh - 220px);
        }

        /* === Table - Modern Data Grid === */
        .leaderboard-v2-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 12px;
            font-family: var(--font-body);
        }

        /* Table Header - Sticky with Depth */
        /* z-index: 100 ensures header row stays above ALL body cells including sticky columns (z-index: 50) */
        .leaderboard-v2-table thead {
            position: sticky;
            top: 0;
            z-index: 100;
        }

        /* Header row element for solid background coverage */
        .leaderboard-v2-table thead tr {
            background: linear-gradient(180deg, #1e293b, #1a2234);
        }

        .leaderboard-v2-table th {
            padding: 14px 10px;
            text-align: center;
            font-weight: 600;
            font-size: 10px;
            color: #94a3b8;
            background: linear-gradient(180deg, #1e293b, #1a2234);
            border-bottom: 2px solid rgba(59, 130, 246, 0.25);
            white-space: nowrap;
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
            letter-spacing: 0.5px;
            text-transform: uppercase;
            position: relative;
            z-index: 100;
            /* Solid shadow to hide any cells scrolling underneath */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .leaderboard-v2-table th:hover {
            background: linear-gradient(180deg, #273548, #1e3040);
            color: #e2e8f0;
        }

        .leaderboard-v2-table th.sorted {
            color: #60a5fa;
            background: linear-gradient(180deg, #1e3a5f, #193252);
        }

        .leaderboard-v2-table th.sorted::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, #3b82f6, transparent);
        }

        /* Column header hover glow */
        .leaderboard-v2-table th::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg, rgba(59, 130, 246, 0.1), transparent);
            opacity: 0;
            transition: opacity var(--duration-fast) var(--ease-out);
            pointer-events: none;
        }
        .leaderboard-v2-table th:hover::before {
            opacity: 1;
        }

        /* Sticky Columns - Higher z-index to stay above other cells on hover */
        .leaderboard-v2-table th.sticky-rank,
        .leaderboard-v2-table td.sticky-rank {
            position: sticky;
            left: 0;
            z-index: 50;
            min-width: 42px;
            width: 42px;
            text-align: center;
            background: #0f172a;
        }

        .leaderboard-v2-table th.sticky-player,
        .leaderboard-v2-table td.sticky-player {
            position: sticky;
            left: 42px;
            z-index: 50;
            min-width: 130px;
            text-align: left;
            background: #0f172a;
        }

        .leaderboard-v2-table th.sticky-team,
        .leaderboard-v2-table td.sticky-team {
            position: sticky;
            left: 172px;
            z-index: 50;
            min-width: 60px;
            text-align: center;
            background: #0f172a;
        }

        .leaderboard-v2-table th.sticky-mins,
        .leaderboard-v2-table td.sticky-mins {
            position: sticky;
            left: 232px;
            z-index: 50;
            min-width: 50px;
            text-align: center;
            background: #0f172a;
        }

        /* Sticky header cells - highest z-index (above both regular headers and sticky body cells) */
        .leaderboard-v2-table th.sticky-rank,
        .leaderboard-v2-table th.sticky-player,
        .leaderboard-v2-table th.sticky-team,
        .leaderboard-v2-table th.sticky-mins {
            z-index: 110;
            background: linear-gradient(180deg, #1e293b 0%, #1a2234 100%);
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
        }

        /* Alternating row backgrounds for sticky cells */
        .leaderboard-v2-table tbody tr:nth-child(even) td.sticky-rank,
        .leaderboard-v2-table tbody tr:nth-child(even) td.sticky-player,
        .leaderboard-v2-table tbody tr:nth-child(even) td.sticky-team,
        .leaderboard-v2-table tbody tr:nth-child(even) td.sticky-mins {
            background: #1e293b;
        }

        .leaderboard-v2-table tbody tr:nth-child(odd) td.sticky-rank,
        .leaderboard-v2-table tbody tr:nth-child(odd) td.sticky-player,
        .leaderboard-v2-table tbody tr:nth-child(odd) td.sticky-team,
        .leaderboard-v2-table tbody tr:nth-child(odd) td.sticky-mins {
            background: #0f172a;
        }

        /* Sticky cell shadow for visual separation */
        .leaderboard-v2-table td.sticky-mins {
            box-shadow: 4px 0 8px rgba(0, 0, 0, 0.25);
        }

        /* === Column Dividers - Opaque lines between ALL columns === */
        .leaderboard-v2-table th,
        .leaderboard-v2-table td {
            border-right: 1px solid rgba(100, 116, 139, 0.5);
        }

        .leaderboard-v2-table th:last-child,
        .leaderboard-v2-table td:last-child {
            border-right: none;
        }

        /* === Category Section Divider - Thick colored border on FIRST column of section === */
        .leaderboard-v2-table th.section-start,
        .leaderboard-v2-table td.section-start {
            border-left: 3px solid rgba(255, 255, 255, 0.3) !important;
        }

        /* === Category Color Classes for ALL Headers in Section === */
        /* SOLID OPAQUE backgrounds to prevent cells from showing through when scrolling */
        .leaderboard-v2-table th.section-rapm { background: #3b2a6b !important; }
        .leaderboard-v2-table th.section-rapm.section-start { border-left-color: #8b5cf6 !important; }

        .leaderboard-v2-table th.section-apm { background: #1e3a5f !important; }
        .leaderboard-v2-table th.section-apm.section-start { border-left-color: #3b82f6 !important; }

        .leaderboard-v2-table th.section-ratings { background: #4a3520 !important; }
        .leaderboard-v2-table th.section-ratings.section-start { border-left-color: #f59e0b !important; }

        .leaderboard-v2-table th.section-ff_off { background: #1a3d2e !important; }
        .leaderboard-v2-table th.section-ff_off.section-start { border-left-color: #22c55e !important; }

        .leaderboard-v2-table th.section-ff_def { background: #4a1f1f !important; }
        .leaderboard-v2-table th.section-ff_def.section-start { border-left-color: #ef4444 !important; }

        .leaderboard-v2-table th.section-shot_off { background: #1e3a5f !important; }
        .leaderboard-v2-table th.section-shot_off.section-start { border-left-color: #3b82f6 !important; }

        .leaderboard-v2-table th.section-shot_def { background: #4a1f2a !important; }
        .leaderboard-v2-table th.section-shot_def.section-start { border-left-color: #f43f5e !important; }

        .leaderboard-v2-table th.section-vol_off { background: #164040 !important; }
        .leaderboard-v2-table th.section-vol_off.section-start { border-left-color: #22d3ee !important; }

        .leaderboard-v2-table th.section-vol_def { background: #4a2f1a !important; }
        .leaderboard-v2-table th.section-vol_def.section-start { border-left-color: #fb923c !important; }

        .leaderboard-v2-table th.section-play { background: #3a2a5a !important; }
        .leaderboard-v2-table th.section-play.section-start { border-left-color: #a855f7 !important; }

        .leaderboard-v2-table th.section-def { background: #4a1f1f !important; }
        .leaderboard-v2-table th.section-def.section-start { border-left-color: #ef4444 !important; }

        .leaderboard-v2-table th.section-trans { background: #2a3d1a !important; }
        .leaderboard-v2-table th.section-trans.section-start { border-left-color: #84cc16 !important; }

        .leaderboard-v2-table th.section-misc { background: #2a3040 !important; }
        .leaderboard-v2-table th.section-misc.section-start { border-left-color: #64748b !important; }

        .leaderboard-v2-table th.section-basic { background: #252a35 !important; }
        .leaderboard-v2-table th.section-basic.section-start { border-left-color: #64748b !important; }

        .leaderboard-v2-table th.section-per75 { background: #164040 !important; }
        .leaderboard-v2-table th.section-per75.section-start { border-left-color: #22d3ee !important; }

        .leaderboard-v2-table th.section-shooting { background: #1a3530 !important; }
        .leaderboard-v2-table th.section-shooting.section-start { border-left-color: #10b981 !important; }

        .leaderboard-v2-table th.section-efficiency { background: #2a2a4a !important; }
        .leaderboard-v2-table th.section-efficiency.section-start { border-left-color: #818cf8 !important; }

        .leaderboard-v2-table th.section-usage { background: linear-gradient(180deg, rgba(251, 146, 60, 0.4) 0%, rgba(234, 88, 12, 0.3) 100%) !important; }
        .leaderboard-v2-table th.section-usage.section-start { border-left-color: #fb923c !important; }

        .leaderboard-v2-table th.section-rebounding { background: linear-gradient(180deg, rgba(163, 230, 53, 0.4) 0%, rgba(132, 204, 22, 0.3) 100%) !important; }
        .leaderboard-v2-table th.section-rebounding.section-start { border-left-color: #a3e635 !important; }

        .leaderboard-v2-table th.section-rates { background: linear-gradient(180deg, rgba(232, 121, 249, 0.4) 0%, rgba(192, 38, 211, 0.3) 100%) !important; }
        .leaderboard-v2-table th.section-rates.section-start { border-left-color: #e879f9 !important; }

        .leaderboard-v2-table th.section-bpm { background: linear-gradient(180deg, rgba(56, 189, 248, 0.45) 0%, rgba(14, 165, 233, 0.35) 100%) !important; }
        .leaderboard-v2-table th.section-bpm.section-start { border-left-color: #38bdf8 !important; }

        .leaderboard-v2-table th.section-tobd { background: linear-gradient(180deg, rgba(239, 68, 68, 0.4) 0%, rgba(185, 28, 28, 0.3) 100%) !important; }
        .leaderboard-v2-table th.section-tobd.section-start { border-left-color: #ef4444 !important; }

        .leaderboard-v2-table th.section-transIndiv { background: linear-gradient(180deg, rgba(34, 197, 94, 0.4) 0%, rgba(22, 163, 74, 0.3) 100%) !important; }
        .leaderboard-v2-table th.section-transIndiv.section-start { border-left-color: #22c55e !important; }

        .leaderboard-v2-table th.section-vsStarters { background: linear-gradient(180deg, rgba(6, 182, 212, 0.45) 0%, rgba(8, 145, 178, 0.35) 100%) !important; }
        .leaderboard-v2-table th.section-vsStarters.section-start { border-left-color: #06b6d4 !important; }

        /* === Team Leaderboard Additional Section Classes === */
        .leaderboard-v2-table th.section-adjusted { background: linear-gradient(180deg, rgba(16, 185, 129, 0.5) 0%, rgba(5, 150, 105, 0.4) 100%) !important; }
        .leaderboard-v2-table th.section-adjusted.section-start { border-left-color: #10b981 !important; }

        .leaderboard-v2-table th.section-pointsadded { background: linear-gradient(180deg, rgba(139, 92, 246, 0.5) 0%, rgba(109, 40, 217, 0.4) 100%) !important; }
        .leaderboard-v2-table th.section-pointsadded.section-start { border-left-color: #8b5cf6 !important; }

        .leaderboard-v2-table th.section-transdef { background: linear-gradient(180deg, rgba(249, 115, 22, 0.45) 0%, rgba(194, 65, 12, 0.35) 100%) !important; }
        .leaderboard-v2-table th.section-transdef.section-start { border-left-color: #f97316 !important; }

        .leaderboard-v2-table th.section-clutch { background: linear-gradient(180deg, rgba(236, 72, 153, 0.5) 0%, rgba(219, 39, 119, 0.4) 100%) !important; }
        .leaderboard-v2-table th.section-clutch.section-start { border-left-color: #ec4899 !important; }

        /* === DATA CELL Section Tinting (subtle background for entire section) === */
        .leaderboard-v2-table td.section-rapm { background: rgba(139, 92, 246, 0.08); }
        .leaderboard-v2-table td.section-rapm.section-start { border-left: 3px solid rgba(139, 92, 246, 0.7) !important; }

        .leaderboard-v2-table td.section-apm { background: rgba(59, 130, 246, 0.08); }
        .leaderboard-v2-table td.section-apm.section-start { border-left: 3px solid rgba(59, 130, 246, 0.7) !important; }

        .leaderboard-v2-table td.section-ratings { background: rgba(245, 158, 11, 0.08); }
        .leaderboard-v2-table td.section-ratings.section-start { border-left: 3px solid rgba(245, 158, 11, 0.7) !important; }

        .leaderboard-v2-table td.section-ff_off { background: rgba(34, 197, 94, 0.06); }
        .leaderboard-v2-table td.section-ff_off.section-start { border-left: 3px solid rgba(34, 197, 94, 0.7) !important; }

        .leaderboard-v2-table td.section-ff_def { background: rgba(239, 68, 68, 0.06); }
        .leaderboard-v2-table td.section-ff_def.section-start { border-left: 3px solid rgba(239, 68, 68, 0.7) !important; }

        .leaderboard-v2-table td.section-shot_off { background: rgba(59, 130, 246, 0.06); }
        .leaderboard-v2-table td.section-shot_off.section-start { border-left: 3px solid rgba(59, 130, 246, 0.7) !important; }

        .leaderboard-v2-table td.section-shot_def { background: rgba(244, 63, 94, 0.06); }
        .leaderboard-v2-table td.section-shot_def.section-start { border-left: 3px solid rgba(244, 63, 94, 0.7) !important; }

        .leaderboard-v2-table td.section-vol_off { background: rgba(34, 211, 238, 0.06); }
        .leaderboard-v2-table td.section-vol_off.section-start { border-left: 3px solid rgba(34, 211, 238, 0.7) !important; }

        .leaderboard-v2-table td.section-vol_def { background: rgba(251, 146, 60, 0.06); }
        .leaderboard-v2-table td.section-vol_def.section-start { border-left: 3px solid rgba(251, 146, 60, 0.7) !important; }

        .leaderboard-v2-table td.section-play { background: rgba(168, 85, 247, 0.06); }
        .leaderboard-v2-table td.section-play.section-start { border-left: 3px solid rgba(168, 85, 247, 0.7) !important; }

        .leaderboard-v2-table td.section-def { background: rgba(239, 68, 68, 0.06); }
        .leaderboard-v2-table td.section-def.section-start { border-left: 3px solid rgba(239, 68, 68, 0.7) !important; }

        .leaderboard-v2-table td.section-trans { background: rgba(132, 204, 22, 0.06); }
        .leaderboard-v2-table td.section-trans.section-start { border-left: 3px solid rgba(132, 204, 22, 0.7) !important; }

        .leaderboard-v2-table td.section-misc { background: rgba(100, 116, 139, 0.06); }
        .leaderboard-v2-table td.section-misc.section-start { border-left: 3px solid rgba(100, 116, 139, 0.7) !important; }

        .leaderboard-v2-table td.section-basic { background: rgba(100, 116, 139, 0.05); }
        .leaderboard-v2-table td.section-basic.section-start { border-left: 3px solid rgba(100, 116, 139, 0.6) !important; }

        .leaderboard-v2-table td.section-per75 { background: rgba(34, 211, 238, 0.06); }
        .leaderboard-v2-table td.section-per75.section-start { border-left: 3px solid rgba(34, 211, 238, 0.7) !important; }

        .leaderboard-v2-table td.section-shooting { background: rgba(16, 185, 129, 0.06); }
        .leaderboard-v2-table td.section-shooting.section-start { border-left: 3px solid rgba(16, 185, 129, 0.7) !important; }

        .leaderboard-v2-table td.section-efficiency { background: rgba(129, 140, 248, 0.06); }
        .leaderboard-v2-table td.section-efficiency.section-start { border-left: 3px solid rgba(129, 140, 248, 0.7) !important; }

        .leaderboard-v2-table td.section-usage { background: rgba(251, 146, 60, 0.06); }
        .leaderboard-v2-table td.section-usage.section-start { border-left: 3px solid rgba(251, 146, 60, 0.7) !important; }

        .leaderboard-v2-table td.section-rebounding { background: rgba(163, 230, 53, 0.06); }
        .leaderboard-v2-table td.section-rebounding.section-start { border-left: 3px solid rgba(163, 230, 53, 0.7) !important; }

        .leaderboard-v2-table td.section-rates { background: rgba(232, 121, 249, 0.06); }
        .leaderboard-v2-table td.section-rates.section-start { border-left: 3px solid rgba(232, 121, 249, 0.7) !important; }

        .leaderboard-v2-table td.section-bpm { background: rgba(56, 189, 248, 0.08); }
        .leaderboard-v2-table td.section-bpm.section-start { border-left: 3px solid rgba(56, 189, 248, 0.7) !important; }

        .leaderboard-v2-table td.section-tobd { background: rgba(239, 68, 68, 0.06); }
        .leaderboard-v2-table td.section-tobd.section-start { border-left: 3px solid rgba(239, 68, 68, 0.7) !important; }

        .leaderboard-v2-table td.section-transIndiv { background: rgba(34, 197, 94, 0.06); }
        .leaderboard-v2-table td.section-transIndiv.section-start { border-left: 3px solid rgba(34, 197, 94, 0.7) !important; }

        .leaderboard-v2-table td.section-vsStarters { background: rgba(6, 182, 212, 0.08); }
        .leaderboard-v2-table td.section-vsStarters.section-start { border-left: 3px solid rgba(6, 182, 212, 0.7) !important; }

        /* Team Leaderboard Additional Section Cell Styles */
        .leaderboard-v2-table td.section-adjusted { background: rgba(16, 185, 129, 0.08); }
        .leaderboard-v2-table td.section-adjusted.section-start { border-left: 3px solid rgba(16, 185, 129, 0.7) !important; }

        .leaderboard-v2-table td.section-pointsadded { background: rgba(139, 92, 246, 0.08); }
        .leaderboard-v2-table td.section-pointsadded.section-start { border-left: 3px solid rgba(139, 92, 246, 0.7) !important; }

        .leaderboard-v2-table td.section-transdef { background: rgba(249, 115, 22, 0.06); }
        .leaderboard-v2-table td.section-transdef.section-start { border-left: 3px solid rgba(249, 115, 22, 0.7) !important; }

        .leaderboard-v2-table td.section-clutch { background: rgba(236, 72, 153, 0.08); }
        .leaderboard-v2-table td.section-clutch.section-start { border-left: 3px solid rgba(236, 72, 153, 0.7) !important; }

        /* Sort Indicator */
        .leaderboard-v2-sort-icon {
            display: inline-block;
            margin-left: 4px;
            font-size: 10px;
            opacity: 0.7;
        }

        /* Lower is Better Indicator */
        .leaderboard-v2-lower-better {
            margin-left: 2px;
            font-size: 9px;
            color: #94a3b8;
            opacity: 0.6;
        }

        /* Table Body */
        .leaderboard-v2-table tbody tr {
            transition: all var(--duration-fast) var(--ease-out);
        }

        .leaderboard-v2-table tbody tr:nth-child(even) {
            background: rgba(30, 41, 59, 0.4);
        }

        .leaderboard-v2-table tbody tr:nth-child(odd) {
            background: rgba(15, 23, 42, 0.4);
        }

        .leaderboard-v2-table tbody tr:hover {
            background: rgba(59, 130, 246, 0.15) !important;
        }

        /* Subtle row highlight line on hover */
        .leaderboard-v2-table tbody tr:hover td:first-child {
            box-shadow: inset 3px 0 0 #3b82f6;
        }

        /* Sticky cells on hover need SOLID opaque backgrounds to prevent bleed-through */
        .leaderboard-v2-table tbody tr:hover td.sticky-rank,
        .leaderboard-v2-table tbody tr:hover td.sticky-player,
        .leaderboard-v2-table tbody tr:hover td.sticky-team,
        .leaderboard-v2-table tbody tr:hover td.sticky-mins {
            background: #1e3a5f !important;
        }

        .leaderboard-v2-table td {
            padding: 6px 4px;
            text-align: center;
            border-bottom: 1px solid rgba(51, 65, 85, 0.25);
            font-variant-numeric: tabular-nums;
            vertical-align: middle;
            transition: background-color var(--duration-fast) var(--ease-out);
        }

        /* Stat cell - extra padding for color-coded badges */
        .leaderboard-v2-table td:not(.sticky-rank):not(.sticky-player):not(.sticky-team):not(.sticky-mins) {
            padding: 4px 3px;
        }

        /* ===== On/Off & Individual Stats Table Styling ===== */
        .lb-data-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 12px;
            font-family: var(--font-body);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(71, 85, 105, 0.4);
        }

        .lb-data-table thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .lb-data-table thead tr {
            background: linear-gradient(180deg, #1e293b, #1a2234);
        }

        .lb-data-table th {
            padding: 10px 12px;
            text-align: left;
            font-weight: 600;
            font-size: 10px;
            color: #94a3b8;
            background: linear-gradient(180deg, #1e293b, #1a2234);
            border-bottom: 2px solid rgba(59, 130, 246, 0.3);
            white-space: nowrap;
            cursor: pointer;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            transition: background 0.15s ease;
            border-right: 1px solid rgba(71, 85, 105, 0.35);
        }

        .lb-data-table th:last-child {
            border-right: none;
        }

        .lb-data-table th:hover {
            background: linear-gradient(180deg, #273548, #1e3040);
            color: #e2e8f0;
        }

        .lb-data-table th[data-sorted="true"] {
            color: #60a5fa;
            background: linear-gradient(180deg, #1e3a5f, #193252);
        }

        .lb-data-table th.lb-col-right {
            text-align: right;
        }

        /* Column highlight for the primary stat */
        .lb-data-table th.lb-col-primary {
            background: rgba(251, 191, 36, 0.15);
        }
        .lb-data-table td.lb-col-primary {
            background: rgba(251, 191, 36, 0.05);
        }

        .lb-data-table tbody tr {
            transition: background 0.12s ease;
        }

        .lb-data-table tbody tr:nth-child(odd) {
            background: rgba(15, 23, 42, 0.5);
        }

        .lb-data-table tbody tr:nth-child(even) {
            background: rgba(30, 41, 59, 0.45);
        }

        .lb-data-table tbody tr:hover {
            background: rgba(59, 130, 246, 0.12) !important;
        }

        .lb-data-table tbody tr:hover td:first-child {
            box-shadow: inset 3px 0 0 #3b82f6;
        }

        .lb-data-table td {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(51, 65, 85, 0.3);
            border-right: 1px solid rgba(51, 65, 85, 0.2);
            font-variant-numeric: tabular-nums;
            vertical-align: middle;
            transition: background 0.12s ease;
            color: #e2e8f0;
        }

        .lb-data-table td:last-child {
            border-right: none;
        }

        .lb-data-table td.lb-col-right {
            text-align: right;
        }

        /* Rank column */
        .lb-data-table td.lb-col-rank {
            width: 36px;
            text-align: center;
            color: #64748b;
            font-weight: 600;
            font-size: 11px;
        }

        /* Player name column */
        .lb-data-table td.lb-col-player {
            font-weight: 600;
            color: #60a5fa;
            white-space: nowrap;
        }

        /* Team column */
        .lb-data-table td.lb-col-team {
            font-size: 11px;
            color: #94a3b8;
        }

        /* Stat value cells */
        .lb-data-table td.lb-col-stat {
            text-align: right;
            font-weight: 600;
        }

        /* Muted columns (mins, poss etc) */
        .lb-data-table td.lb-col-muted {
            text-align: right;
            font-size: 11px;
            color: #64748b;
        }

        /* Percentile badge */
        .lb-data-table .lb-pctl-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }

        /* Scroll wrapper */
        .lb-data-table-scroll {
            overflow-x: auto;
            overflow-y: auto;
            border-radius: 8px;
            border: 1px solid rgba(71, 85, 105, 0.35);
            -webkit-overflow-scrolling: touch;
        }

        .lb-data-table-scroll .lb-data-table {
            border: none;
            border-radius: 0;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .lb-data-table th {
                padding: 8px 8px;
                font-size: 9px;
            }
            .lb-data-table td {
                padding: 6px 8px;
                font-size: 11px;
            }
            .lb-data-table td.lb-col-player {
                max-width: 120px;
                overflow: hidden;
                text-overflow: ellipsis;
            }
        }

        /* Light theme support */
        body.light-theme .lb-data-table {
            border-color: rgba(203, 213, 225, 0.6);
        }
        body.light-theme .lb-data-table th {
            background: linear-gradient(180deg, #f0f0f2, #e8e8ec);
            color: #475569;
            border-bottom-color: rgba(59, 130, 246, 0.35);
            border-right-color: rgba(203, 213, 225, 0.5);
        }
        body.light-theme .lb-data-table td {
            color: #1e293b;
            border-bottom-color: rgba(203, 213, 225, 0.5);
            border-right-color: rgba(203, 213, 225, 0.35);
        }
        body.light-theme .lb-data-table tbody tr:nth-child(odd) {
            background: rgba(248, 250, 252, 0.8);
        }
        body.light-theme .lb-data-table tbody tr:nth-child(even) {
            background: rgba(241, 245, 249, 0.8);
        }
        body.light-theme .lb-data-table tbody tr:hover {
            background: rgba(59, 130, 246, 0.08) !important;
        }
        body.light-theme .lb-data-table td.lb-col-player {
            color: #2563eb;
        }
        body.light-theme .lb-data-table td.lb-col-rank {
            color: #94a3b8;
        }
        body.light-theme .lb-data-table td.lb-col-team {
            color: #64748b;
        }
        body.light-theme .lb-data-table td.lb-col-muted {
            color: #94a3b8;
        }
        body.light-theme .lb-data-table-scroll {
            border-color: rgba(203, 213, 225, 0.6);
        }

        /* Rank Cell - Google-Style Badges with enhanced styling */
        .leaderboard-v2-rank {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            height: 28px;
            font-weight: 700;
            color: #94a3b8;
            font-size: 11px;
            border-radius: var(--radius-md);
            background: linear-gradient(145deg, rgba(71, 85, 105, 0.25), rgba(51, 65, 85, 0.2));
            transition: all var(--duration-fast) var(--ease-out);
            border: 1px solid rgba(71, 85, 105, 0.2);
        }
        .leaderboard-v2-rank:hover {
            transform: scale(1.1);
            background: linear-gradient(145deg, rgba(59, 130, 246, 0.3), rgba(59, 130, 246, 0.2));
            border-color: rgba(59, 130, 246, 0.3);
            color: #93c5fd;
        }

        .leaderboard-v2-rank-top3 {
            color: #fef3c7;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 2px 6px rgba(245, 158, 11, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .leaderboard-v2-rank-top10 {
            color: #f3e8ff;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            box-shadow: 0 2px 6px rgba(139, 92, 246, 0.35);
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.15);
        }

        /* Player Name Cell */
        .leaderboard-v2-player-name {
            font-weight: 600;
            color: #f1f5f9;
            cursor: pointer;
            transition: color 0.1s ease;
            text-align: left;
        }

        .leaderboard-v2-player-name:hover {
            color: #60a5fa;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 2px;
        }

        /* Team Cell - Subtle Badge */
        .leaderboard-v2-team {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 3px 8px;
            font-size: 10px;
            color: #94a3b8;
            font-weight: 600;
            background: rgba(51, 65, 85, 0.4);
            border-radius: 4px;
            letter-spacing: 0.3px;
            text-transform: uppercase;
        }

        /* Minutes/Games Cell - Subtle Cyan Badge */
        .leaderboard-v2-mins {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            padding: 4px 8px;
            font-weight: 700;
            font-size: 11px;
            color: #22d3ee;
            background: rgba(34, 211, 238, 0.12);
            border-radius: 6px;
            box-shadow: inset 0 0 0 1px rgba(34, 211, 238, 0.2);
        }

        /* Stat Value Colors - Percentile Based with Google-Style Cell Backgrounds */
        /* Performance: Removed transitions and complex effects for faster rendering */
        .leaderboard-v2-stat {
            font-weight: 600;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 42px;
            padding: 4px 6px;
            border-radius: 6px;
            letter-spacing: -0.2px;
        }

        /* === Google-Style Heatmap Cell Backgrounds === */
        /* OPTIMIZED: Removed box-shadow and text-shadow for better performance */
        /* Kept gradients for visual appeal */

        /* Elite (90th+) - Strong Green */
        .leaderboard-v2-pct-elite {
            color: #ffffff !important;
            font-weight: 700;
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
        }

        /* Great (75-89) - Medium Green */
        .leaderboard-v2-pct-great {
            color: #ffffff !important;
            font-weight: 600;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        }

        /* Good (60-74) - Light Green */
        .leaderboard-v2-pct-good {
            color: #ffffff !important;
            font-weight: 600;
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
        }

        /* Average (40-59) - Neutral Gray */
        .leaderboard-v2-pct-avg {
            color: #ffffff !important;
            font-weight: 500;
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
        }

        /* Below (25-39) - Amber/Yellow */
        .leaderboard-v2-pct-below {
            color: #ffffff !important;
            font-weight: 600;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        /* Poor (10-24) - Orange */
        .leaderboard-v2-pct-poor {
            color: #ffffff !important;
            font-weight: 600;
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
        }

        /* Bad (<10) - Strong Red */
        .leaderboard-v2-pct-bad {
            color: #ffffff !important;
            font-weight: 700;
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        }

        /* === Light Theme Cell Background Overrides === */
        /* Inherits same styles, just ensuring white text */
        body.light-theme .leaderboard-v2-pct-elite,
        body.light-theme .leaderboard-v2-pct-great,
        body.light-theme .leaderboard-v2-pct-good,
        body.light-theme .leaderboard-v2-pct-avg,
        body.light-theme .leaderboard-v2-pct-below,
        body.light-theme .leaderboard-v2-pct-poor,
        body.light-theme .leaderboard-v2-pct-bad {
            color: #ffffff !important;
        }

        /* === Legend Footer === */
        .leaderboard-v2-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            padding: 12px 20px;
            background: rgba(15, 23, 42, 0.5);
            border-top: 1px solid rgba(71, 85, 105, 0.25);
            font-size: 10px;
            color: #94a3b8;
        }

        .leaderboard-v2-legend-title {
            font-weight: 700;
            color: #cbd5e1;
        }

        .leaderboard-v2-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .leaderboard-v2-legend-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .leaderboard-v2-legend-sep {
            color: #475569;
        }

        /* === Light Theme Overrides === */
        body.light-theme .leaderboard-v2-container {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.95) 100%);
            border-color: rgba(203, 213, 225, 0.6);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
        }

        body.light-theme .leaderboard-v2-header {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.05) 0%, rgba(139, 92, 246, 0.03) 100%);
            border-bottom-color: rgba(203, 213, 225, 0.5);
        }

        body.light-theme .leaderboard-v2-title {
            color: #1e293b;
        }

        body.light-theme .leaderboard-v2-settings {
            background: linear-gradient(180deg, rgba(248, 250, 252, 0.8) 0%, rgba(241, 245, 249, 0.6) 100%);
        }

        body.light-theme .leaderboard-v2-filter-label {
            color: #64748b;
        }

        body.light-theme .leaderboard-v2-select,
        body.light-theme .leaderboard-v2-input {
            background: white;
            color: #1e293b;
            border-color: rgba(203, 213, 225, 0.6);
        }

        body.light-theme .leaderboard-v2-table th {
            background: linear-gradient(180deg, #f1f5f9 0%, #e2e8f0 100%);
            color: #475569;
            border-bottom-color: rgba(59, 130, 246, 0.3);
        }

        body.light-theme .leaderboard-v2-table th:hover {
            background: linear-gradient(180deg, #e2e8f0 0%, #cbd5e1 100%);
            color: #1e293b;
        }

        body.light-theme .leaderboard-v2-table tbody tr:nth-child(even) {
            background: rgba(248, 250, 252, 0.8);
        }

        body.light-theme .leaderboard-v2-table tbody tr:nth-child(odd) {
            background: rgba(255, 255, 255, 0.9);
        }

        body.light-theme .leaderboard-v2-table tbody tr:hover {
            background: rgba(59, 130, 246, 0.08) !important;
        }

        body.light-theme .leaderboard-v2-table td {
            border-bottom-color: rgba(226, 232, 240, 0.6);
        }

        body.light-theme .leaderboard-v2-player-name {
            color: #1e293b;
        }

        body.light-theme .leaderboard-v2-table tbody tr:nth-child(even) td.sticky-rank,
        body.light-theme .leaderboard-v2-table tbody tr:nth-child(even) td.sticky-player,
        body.light-theme .leaderboard-v2-table tbody tr:nth-child(even) td.sticky-team,
        body.light-theme .leaderboard-v2-table tbody tr:nth-child(even) td.sticky-mins {
            background: #f8fafc;
        }

        body.light-theme .leaderboard-v2-table tbody tr:nth-child(odd) td.sticky-rank,
        body.light-theme .leaderboard-v2-table tbody tr:nth-child(odd) td.sticky-player,
        body.light-theme .leaderboard-v2-table tbody tr:nth-child(odd) td.sticky-team,
        body.light-theme .leaderboard-v2-table tbody tr:nth-child(odd) td.sticky-mins {
            background: #ffffff;
        }

        body.light-theme .leaderboard-v2-pct-avg { color: #64748b !important; }

        body.light-theme .leaderboard-v2-legend {
            background: rgba(248, 250, 252, 0.8);
            border-top-color: rgba(203, 213, 225, 0.5);
        }

        /* === Responsive Adjustments === */
        @media (max-width: 1024px) {
            .leaderboard-v2-header {
                padding: 12px 16px;
            }

            .leaderboard-v2-title {
                font-size: 16px;
            }

            .leaderboard-v2-settings {
                padding: 12px 16px;
                gap: 12px;
            }

            .leaderboard-v2-filters-row {
                gap: 12px;
            }

            .leaderboard-v2-table th,
            .leaderboard-v2-table td {
                padding: 8px 6px;
            }

            .leaderboard-v2-table {
                font-size: 11px;
            }

            .leaderboard-v2-table th {
                font-size: 10px;
            }
        }

        @media (max-width: 768px) {
            .leaderboard-v2-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .leaderboard-v2-table-scroll {
                max-height: 400px;
            }

            .leaderboard-v2-columns-panel {
                display: none;
            }

            .leaderboard-v2-presets {
                overflow-x: auto;
                flex-wrap: nowrap;
                padding-bottom: 8px;
            }

            .leaderboard-v2-table th.sticky-player,
            .leaderboard-v2-table td.sticky-player {
                min-width: 100px;
            }

            .leaderboard-v2-table th.sticky-team,
            .leaderboard-v2-table td.sticky-team,
            .leaderboard-v2-table th.sticky-mins,
            .leaderboard-v2-table td.sticky-mins {
                position: static;
            }

            /* ─── Mobile: Collapsible Filters (non-sticky) ─── */
            .leaderboard-v2-settings {
                position: static !important;
            }
            .leaderboard-v2-settings.mobile-filters-collapsed .leaderboard-v2-filters-row,
            .leaderboard-v2-settings.mobile-filters-collapsed .leaderboard-v2-mode-row,
            .leaderboard-v2-settings.mobile-filters-collapsed .leaderboard-v2-luck-group,
            .leaderboard-v2-settings.mobile-filters-collapsed .leaderboard-v2-filter-group,
            .leaderboard-v2-settings.mobile-filters-collapsed > div:not(.mobile-filters-toggle) {
                display: none !important;
            }
            .mobile-filters-toggle {
                display: flex !important;
                align-items: center;
                justify-content: space-between;
                padding: 10px 14px;
                background: rgba(59, 130, 246, 0.1);
                border: 1px solid rgba(59, 130, 246, 0.25);
                border-radius: 8px;
                cursor: pointer;
                color: #94a3b8;
                font-size: 12px;
                font-weight: 600;
                margin-bottom: 8px;
            }
            .mobile-filters-toggle:active {
                background: rgba(59, 130, 246, 0.2);
            }
            .mobile-filters-toggle .toggle-arrow {
                transition: transform 0.2s;
                font-size: 10px;
            }
            .mobile-filters-collapsed .mobile-filters-toggle .toggle-arrow {
                transform: rotate(-90deg);
            }

            /* ─── Mobile: Player column narrow + truncate + expand/collapse ─── */
            .leaderboard-v2-table th.sticky-player,
            .leaderboard-v2-table td.sticky-player {
                min-width: 70px !important;
                max-width: 70px !important;
                width: 70px !important;
            }
            .leaderboard-v2-table td.sticky-player .leaderboard-v2-player-name {
                display: block;
                max-width: 62px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                font-size: 10px;
            }
            /* Expanded player column on mobile */
            .leaderboard-v2-table.player-col-expanded th.sticky-player,
            .leaderboard-v2-table.player-col-expanded td.sticky-player {
                min-width: 140px !important;
                max-width: 140px !important;
                width: 140px !important;
            }
            .leaderboard-v2-table.player-col-expanded td.sticky-player .leaderboard-v2-player-name {
                max-width: 130px;
                font-size: 12px;
            }
            /* Expand/collapse toggle button for player column */
            .mobile-col-expand-btn {
                display: inline-block !important;
                font-size: 8px;
                cursor: pointer;
                color: #60a5fa;
                margin-left: 2px;
                vertical-align: middle;
            }

            /* ─── Mobile: Compare tab - hide individual opp sliders ─── */
            .tow-individual-slider {
                display: none !important;
            }

            /* ─── Mobile: Charts horizontally scrollable ─── */
            .export-chart-scroll-wrapper {
                overflow-x: auto !important;
                -webkit-overflow-scrolling: touch;
                max-width: 100%;
            }
            .export-chart-scroll-wrapper > svg,
            .export-chart-scroll-wrapper > div {
                min-width: 500px;
            }

            /* ─── Mobile: Hide individual opp quality adj sliders in Lineup Analyzer four factors ─── */
            .la-individual-sched-slider {
                display: none !important;
            }

            /* ─── Mobile: Stack offensive/defensive misc stats ─── */
            .la-misc-stats-grid {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
            }

            /* ─── Mobile: Clutch tab - horizontally scrollable cards ─── */
            .clutch-scroll-wrapper {
                overflow-x: auto !important;
                -webkit-overflow-scrolling: touch;
                max-width: 100%;
                margin: 0 -4px;
                padding: 0 4px 8px;
                scrollbar-width: none;
            }
            .clutch-scroll-wrapper::-webkit-scrollbar { display: none; }
            .clutch-off-shoot-grid {
                min-width: 600px !important;
            }
            .clutch-inner-stats-grid {
                grid-template-columns: 1fr 1fr 1fr !important;
            }

            /* ─── Mobile: Player breakdown per-75 stats overflow fix ─── */
            .player-per75-wrapper {
                overflow-x: auto !important;
                -webkit-overflow-scrolling: touch;
                max-width: 100%;
                margin: 0 -4px;
                padding: 0 4px;
            }
            .player-per75-wrapper .player-stats-grid {
                min-width: 600px;
            }

            /* ─── Mobile: Stack lineup card four factors & shot distribution ─── */
            .lineup-card-four-factors {
                grid-template-columns: 1fr !important;
                gap: 8px !important;
            }
            .lineup-card-shot-dist {
                grid-template-columns: 1fr !important;
                gap: 8px !important;
            }

            /* ─── Mobile: Stack Lineup Analyzer main four factors off/def ─── */
            .la-four-factors-grid {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
            }

            /* ─── Mobile: Stack transition stats ─── */
            .la-transition-grid {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
            }
        }

        /* Desktop: hide mobile-only elements */
        @media (min-width: 769px) {
            .mobile-filters-toggle { display: none !important; }
            .mobile-col-expand-btn { display: none !important; }
        }

        /* === Fullscreen Mode === */
        .leaderboard-v2-fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            z-index: 9999 !important;
            border-radius: 0 !important;
            max-width: none !important;
            margin: 0 !important;
        }

        .leaderboard-v2-fullscreen .leaderboard-v2-table-scroll {
            max-height: calc(100vh - 280px) !important;
        }

        /* === Loading State === */
        .leaderboard-v2-loading {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 14px 20px;
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.08) 0%, rgba(139, 92, 246, 0.05) 100%);
            border-bottom: 1px solid rgba(59, 130, 246, 0.15);
        }

        .leaderboard-v2-loading-spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: leaderboard-spin 0.8s linear infinite;
        }

        @keyframes leaderboard-spin {
            to { transform: rotate(360deg); }
        }

        .leaderboard-v2-loading-text {
            font-size: 12px;
            color: #94a3b8;
            font-weight: 500;
        }

        /* ═══════════════════════════════════════════════════════════════════════════ */
    </style>
</head>
<body>
    <!-- ═══════════════════════════════════════════════════════════════════════════
         PASSWORD PROTECTION SYSTEM v3.1 - HTML (Integrated from GAMEVIS)
         ═══════════════════════════════════════════════════════════════════════════ -->
    <div id="_gvAuthOverlay">
        <div id="_gvAuthBox">
            <div class="_gvLogo">LA</div>
            <div class="_gvTitle">Basketball Lineup Analyzer</div>
            <div class="_gvSub">Authentication Required</div>
            <input type="password" id="_gvPwd" placeholder="Enter access password" autocomplete="off" spellcheck="false">
            <div id="_gvRememberRow" style="display:none;margin:12px 0;text-align:left;">
                <label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:13px;color:#8892a8;">
                    <input type="checkbox" id="_gvRememberPwd" style="width:16px;height:16px;cursor:pointer;">
                    <span>Remember password on this device</span>
                </label>
            </div>
            <button id="_gvSubmit">Unlock Application</button>
            <div id="_gvErrMsg" class="_gvErr"></div>
            <div class="_gvLock">🔒 Protected Content</div>
        </div>
    </div>

    <div id="root"></div>
    <script>
        // ═══════════════════════════════════════════════════════════════════════════
        // MOBILE DETECTION & DEVICE UTILITIES
        // Comprehensive detection for iOS, Android, tablets, and touch devices
        // ═══════════════════════════════════════════════════════════════════════════
        const MobileDetect = (function() {
            'use strict';

            // User agent detection
            const ua = navigator.userAgent || navigator.vendor || window.opera || '';
            const platform = navigator.platform || '';

            // Device type flags
            const isIOS = /iPad|iPhone|iPod/.test(ua) || (platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            const isAndroid = /Android/.test(ua);
            const isWindowsPhone = /Windows Phone|IEMobile|WPDesktop/.test(ua);
            const isMobileUA = /Mobile|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);

            // Screen size detection
            const isSmallScreen = window.innerWidth <= 768;
            const isMediumScreen = window.innerWidth <= 1024;

            // Touch capability
            const hasTouch = ('ontouchstart' in window) ||
                            (navigator.maxTouchPoints > 0) ||
                            (navigator.msMaxTouchPoints > 0);

            // Pointer type (coarse = touch, fine = mouse)
            const hasCoarsePointer = window.matchMedia('(pointer: coarse)').matches;

            // Combined detection
            const isMobile = isIOS || isAndroid || isWindowsPhone || (isMobileUA && isSmallScreen);
            const isTablet = ((isIOS || isAndroid) && !isMobileUA) ||
                            (hasTouch && window.innerWidth >= 768 && window.innerWidth <= 1024);
            const isTouchDevice = hasTouch || hasCoarsePointer;

            // Device info object
            const deviceInfo = {
                isMobile,
                isTablet,
                isDesktop: !isMobile && !isTablet,
                isTouchDevice,
                isIOS,
                isAndroid,
                isSmallScreen,
                isMediumScreen,
                screenWidth: window.innerWidth,
                screenHeight: window.innerHeight,
                pixelRatio: window.devicePixelRatio || 1,
                orientation: window.innerWidth > window.innerHeight ? 'landscape' : 'portrait'
            };

            // Set CSS custom properties - DESKTOP IS DEFAULT
            function updateCSSProperties() {
                const isDesktopDevice = !isMobile && !isTablet;
                document.documentElement.style.setProperty('--is-desktop', isDesktopDevice ? '1' : '0');
                document.documentElement.style.setProperty('--is-mobile', isMobile ? '1' : '0');
                document.documentElement.style.setProperty('--is-tablet', isTablet ? '1' : '0');
                document.documentElement.style.setProperty('--is-touch', isTouchDevice ? '1' : '0');
                document.documentElement.style.setProperty('--screen-width', window.innerWidth + 'px');
                document.documentElement.style.setProperty('--screen-height', window.innerHeight + 'px');
            }

            // Add body classes for CSS targeting - DESKTOP IS DEFAULT
            function updateBodyClasses() {
                const body = document.body;
                if (!body) return;

                const isDesktopDevice = !isMobile && !isTablet;

                // Desktop classes (DEFAULT state for PC)
                body.classList.toggle('is-desktop', isDesktopDevice);
                body.classList.toggle('is-pc', isDesktopDevice); // Alias for clarity

                // Mobile/tablet classes (only when confirmed)
                body.classList.toggle('is-mobile', isMobile);
                body.classList.toggle('is-tablet', isTablet);
                body.classList.toggle('is-touch', isTouchDevice);
                body.classList.toggle('is-mouse', !isTouchDevice);
                body.classList.toggle('is-ios', isIOS);
                body.classList.toggle('is-android', isAndroid);
                body.classList.toggle('is-landscape', window.innerWidth > window.innerHeight);
                body.classList.toggle('is-portrait', window.innerWidth <= window.innerHeight);

                // Log device state for debugging
                if (isDesktopDevice) {
                    console.log('[MobileDetect] Desktop mode active - full PC features enabled');
                } else {
                    console.log('[MobileDetect] Mobile/Tablet mode:', { isMobile, isTablet, isTouchDevice });
                }
            }

            // Handle orientation and resize changes
            function handleResize() {
                deviceInfo.screenWidth = window.innerWidth;
                deviceInfo.screenHeight = window.innerHeight;
                deviceInfo.isSmallScreen = window.innerWidth <= 768;
                deviceInfo.isMediumScreen = window.innerWidth <= 1024;
                deviceInfo.orientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
                updateCSSProperties();
                updateBodyClasses();
            }

            // Initialize on DOM ready
            function init() {
                updateCSSProperties();
                if (document.body) {
                    updateBodyClasses();
                } else {
                    document.addEventListener('DOMContentLoaded', updateBodyClasses);
                }
                window.addEventListener('resize', handleResize);
                window.addEventListener('orientationchange', () => setTimeout(handleResize, 100));
            }

            // Initialize immediately
            init();

            // Public API
            return {
                get info() { return { ...deviceInfo }; },
                get isMobile() { return isMobile; },
                get isTablet() { return isTablet; },
                get isDesktop() { return !isMobile && !isTablet; },
                get isTouchDevice() { return isTouchDevice; },
                get isIOS() { return isIOS; },
                get isAndroid() { return isAndroid; },
                get screenWidth() { return window.innerWidth; },
                get screenHeight() { return window.innerHeight; },
                get orientation() { return window.innerWidth > window.innerHeight ? 'landscape' : 'portrait'; },
                refresh: handleResize
            };
        })();

        // Make available globally
        window.MobileDetect = MobileDetect;

        // ═══════════════════════════════════════════════════════════════════════════
        // TOUCH GESTURE UTILITIES
        // Swipe detection, pull-to-refresh, and touch-friendly interactions
        // ═══════════════════════════════════════════════════════════════════════════
        const TouchGestures = (function() {
            'use strict';

            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;

            // Swipe detection threshold (in pixels)
            const SWIPE_THRESHOLD = 50;
            const SWIPE_RESTRAINT = 100; // Maximum perpendicular movement

            function handleTouchStart(e) {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }

            function handleTouchEnd(e) {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe(e.target);
            }

            function handleSwipe(target) {
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;

                let direction = null;

                if (Math.abs(deltaX) > SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_RESTRAINT) {
                    direction = deltaX > 0 ? 'right' : 'left';
                } else if (Math.abs(deltaY) > SWIPE_THRESHOLD && Math.abs(deltaX) < SWIPE_RESTRAINT) {
                    direction = deltaY > 0 ? 'down' : 'up';
                }

                if (direction) {
                    const event = new CustomEvent('swipe', {
                        bubbles: true,
                        detail: { direction, deltaX, deltaY }
                    });
                    target.dispatchEvent(event);
                }
            }

            // Enable swipe detection on an element
            function enableSwipe(element, callback) {
                if (!element) return;

                element.addEventListener('touchstart', handleTouchStart, { passive: true });
                element.addEventListener('touchend', (e) => {
                    handleTouchEnd(e);
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchEndY - touchStartY;

                    let direction = null;
                    if (Math.abs(deltaX) > SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_RESTRAINT) {
                        direction = deltaX > 0 ? 'right' : 'left';
                    } else if (Math.abs(deltaY) > SWIPE_THRESHOLD && Math.abs(deltaX) < SWIPE_RESTRAINT) {
                        direction = deltaY > 0 ? 'down' : 'up';
                    }

                    if (direction && callback) {
                        callback(direction, { deltaX, deltaY });
                    }
                }, { passive: true });
            }

            // Double tap detection
            function enableDoubleTap(element, callback, delay = 300) {
                if (!element) return;

                let lastTap = 0;
                element.addEventListener('touchend', (e) => {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    if (tapLength < delay && tapLength > 0) {
                        if (callback) callback(e);
                        e.preventDefault();
                    }
                    lastTap = currentTime;
                });
            }

            // Long press detection
            function enableLongPress(element, callback, duration = 500) {
                if (!element) return;

                let timer = null;
                let isLongPress = false;

                element.addEventListener('touchstart', (e) => {
                    isLongPress = false;
                    timer = setTimeout(() => {
                        isLongPress = true;
                        if (callback) callback(e);
                    }, duration);
                }, { passive: true });

                element.addEventListener('touchend', () => {
                    clearTimeout(timer);
                });

                element.addEventListener('touchmove', () => {
                    clearTimeout(timer);
                });
            }

            // Prevent pull-to-refresh on specific elements
            function preventPullToRefresh(element) {
                if (!element) return;

                let lastY = 0;
                element.addEventListener('touchstart', (e) => {
                    lastY = e.touches[0].clientY;
                }, { passive: true });

                element.addEventListener('touchmove', (e) => {
                    const y = e.touches[0].clientY;
                    const scrollTop = element.scrollTop;

                    // If at top and pulling down, prevent
                    if (scrollTop === 0 && y > lastY) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }

            return {
                enableSwipe,
                enableDoubleTap,
                enableLongPress,
                preventPullToRefresh
            };
        })();

        window.TouchGestures = TouchGestures;

        // ═══════════════════════════════════════════════════════════════════════════
        // ENHANCED MOBILE INTERACTIONS v2.0
        // Scroll-to-top, collapsible sections, improved table handling
        // ═══════════════════════════════════════════════════════════════════════════
        const MobileEnhancements = (function() {
            'use strict';

            let scrollToTopBtn = null;
            let lastScrollTop = 0;
            let scrollTimeout = null;

            // Create scroll-to-top button
            function createScrollToTopButton() {
                if (scrollToTopBtn || !MobileDetect.isMobile) return;

                scrollToTopBtn = document.createElement('button');
                scrollToTopBtn.className = 'scroll-to-top';
                scrollToTopBtn.innerHTML = '↑';
                scrollToTopBtn.setAttribute('aria-label', 'Scroll to top');
                scrollToTopBtn.addEventListener('click', () => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
                document.body.appendChild(scrollToTopBtn);

                // Show/hide based on scroll position
                window.addEventListener('scroll', () => {
                    if (scrollTimeout) clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                        if (scrollTop > 300) {
                            scrollToTopBtn.classList.add('visible');
                        } else {
                            scrollToTopBtn.classList.remove('visible');
                        }
                        lastScrollTop = scrollTop;
                    }, 100);
                }, { passive: true });
            }

            // Make sections collapsible on mobile
            function enableCollapsibleSections() {
                if (!MobileDetect.isMobile) return;

                document.querySelectorAll('.section').forEach((section, index) => {
                    // Skip if already processed or if it's a critical section
                    if (section.classList.contains('collapsible-init') ||
                        section.querySelector('.upload-btn') ||
                        section.classList.contains('no-collapse')) {
                        return;
                    }

                    const title = section.querySelector('.section-title');
                    if (!title) return;

                    section.classList.add('collapsible', 'collapsible-init');

                    // Wrap content after title
                    const content = document.createElement('div');
                    content.className = 'section-content';

                    // Move all siblings after title into content wrapper
                    let nextSibling = title.nextElementSibling;
                    while (nextSibling) {
                        const toMove = nextSibling;
                        nextSibling = nextSibling.nextElementSibling;
                        content.appendChild(toMove);
                    }
                    section.appendChild(content);

                    // Add click handler to title
                    title.addEventListener('click', () => {
                        section.classList.toggle('collapsed');
                    });

                    // Collapse all but first 2 sections by default
                    if (index > 1) {
                        section.classList.add('collapsed');
                    }
                });
            }

            // Add horizontal scroll shadows to tables
            function enhanceTableScrolling() {
                document.querySelectorAll('.full-table-wrapper').forEach(wrapper => {
                    if (wrapper.classList.contains('scroll-enhanced')) return;
                    wrapper.classList.add('scroll-enhanced');

                    // Track scroll position for shadow indicators
                    wrapper.addEventListener('scroll', () => {
                        const scrollLeft = wrapper.scrollLeft;
                        const scrollWidth = wrapper.scrollWidth;
                        const clientWidth = wrapper.clientWidth;

                        wrapper.classList.toggle('scrolled-start', scrollLeft > 10);
                        wrapper.classList.toggle('scrolled-end', scrollLeft + clientWidth >= scrollWidth - 10);
                    }, { passive: true });

                    // Initial state
                    wrapper.dispatchEvent(new Event('scroll'));
                });
            }

            // Improve modal handling for mobile
            function enhanceModals() {
                // Add swipe-down to close for modals
                document.addEventListener('click', (e) => {
                    const modal = e.target.closest('.modal-overlay');
                    if (modal && e.target === modal && MobileDetect.isMobile) {
                        // Clicked on overlay (not content), close modal
                        const closeBtn = modal.querySelector('.modal-close');
                        if (closeBtn) closeBtn.click();
                    }
                });
            }

            // Handle orientation changes
            function handleOrientationChange() {
                window.addEventListener('orientationchange', () => {
                    // Force layout recalculation
                    setTimeout(() => {
                        window.dispatchEvent(new Event('resize'));

                        // Re-enhance tables after orientation change
                        enhanceTableScrolling();
                    }, 300);
                });
            }

            // Prevent zoom on double tap (for buttons)
            function preventDoubleTapZoom() {
                if (!MobileDetect.isMobile) return;

                let lastTouchEnd = 0;
                document.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        const target = e.target;
                        // Only prevent on interactive elements
                        if (target.matches('button, .btn, .tab-btn, .subtab-btn, a, [role="button"]')) {
                            e.preventDefault();
                        }
                    }
                    lastTouchEnd = now;
                }, { passive: false });
            }

            // Add haptic feedback simulation (visual feedback)
            function addTouchFeedback() {
                if (!MobileDetect.isTouchDevice) return;

                const feedbackElements = 'button, .btn, .tab-btn, .subtab-btn, .stat-card, .player-card, .wowy-player-select';

                document.addEventListener('touchstart', (e) => {
                    const target = e.target.closest(feedbackElements);
                    if (target) {
                        target.classList.add('touch-active');
                    }
                }, { passive: true });

                document.addEventListener('touchend', (e) => {
                    document.querySelectorAll('.touch-active').forEach(el => {
                        el.classList.remove('touch-active');
                    });
                }, { passive: true });

                document.addEventListener('touchcancel', (e) => {
                    document.querySelectorAll('.touch-active').forEach(el => {
                        el.classList.remove('touch-active');
                    });
                }, { passive: true });
            }

            // Optimize images for mobile
            function optimizeImages() {
                if (!MobileDetect.isMobile) return;

                // Add loading="lazy" to images below the fold
                document.querySelectorAll('img:not([loading])').forEach((img, index) => {
                    if (index > 2) { // First few images load eagerly
                        img.loading = 'lazy';
                    }
                });
            }

            // Initialize all enhancements
            function init() {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initEnhancements);
                } else {
                    initEnhancements();
                }
            }

            function initEnhancements() {
                createScrollToTopButton();
                enhanceTableScrolling();
                enhanceModals();
                handleOrientationChange();
                preventDoubleTapZoom();
                addTouchFeedback();
                optimizeImages();

                // Re-run enhancements when React updates the DOM
                const observer = new MutationObserver((mutations) => {
                    let shouldUpdate = false;
                    mutations.forEach(mutation => {
                        if (mutation.addedNodes.length > 0) {
                            shouldUpdate = true;
                        }
                    });
                    if (shouldUpdate) {
                        setTimeout(() => {
                            enhanceTableScrolling();
                            // Don't re-run collapsible on every update to avoid breaking React state
                        }, 100);
                    }
                });

                const root = document.getElementById('root');
                if (root) {
                    observer.observe(root, { childList: true, subtree: true });
                }

                console.log('[MobileEnhancements] Initialized for', MobileDetect.isMobile ? 'mobile' : 'desktop');
            }

            // Initialize
            init();

            return {
                refresh: initEnhancements,
                enableCollapsibleSections,
                enhanceTableScrolling
            };
        })();

        window.MobileEnhancements = MobileEnhancements;

        // ═══════════════════════════════════════════════════════════════════════════
        // PC/DESKTOP ENHANCEMENTS v1.0
        // Keyboard shortcuts, context menus, window management, mouse interactions
        // ═══════════════════════════════════════════════════════════════════════════
        const DesktopEnhancements = (function() {
            'use strict';

            // Only run on desktop
            const isDesktop = !MobileDetect.isMobile && !MobileDetect.isTablet;
            const hasPointerFine = window.matchMedia('(pointer: fine)').matches;

            // Keyboard shortcuts registry
            const shortcuts = new Map();
            const chordBuffer = [];
            let chordTimeout = null;

            // Register a keyboard shortcut
            function registerShortcut(keys, callback, description = '') {
                const keyCombo = Array.isArray(keys) ? keys.join('+').toLowerCase() : keys.toLowerCase();
                shortcuts.set(keyCombo, { callback, description });
            }

            // Global keyboard handler
            function handleKeyDown(e) {
                // Ignore if typing in input
                if (e.target.matches('input, textarea, select, [contenteditable]')) {
                    // Allow Escape to blur inputs
                    if (e.key === 'Escape') {
                        e.target.blur();
                    }
                    return;
                }

                // Build key combo string
                const parts = [];
                if (e.ctrlKey || e.metaKey) parts.push('ctrl');
                if (e.altKey) parts.push('alt');
                if (e.shiftKey) parts.push('shift');
                if (e.key && e.key.length === 1) {
                    parts.push(e.key.toLowerCase());
                } else if (e.key) {
                    parts.push(e.key);
                }

                const combo = parts.join('+');

                // Check for registered shortcut
                if (shortcuts.has(combo)) {
                    e.preventDefault();
                    shortcuts.get(combo).callback(e);
                    return;
                }

                // Default shortcuts
                switch (combo) {
                    case 'Escape':
                        // Close any open modals
                        const modal = document.querySelector('.modal-overlay');
                        if (modal) {
                            const closeBtn = modal.querySelector('.modal-close');
                            if (closeBtn) closeBtn.click();
                            e.preventDefault();
                        }
                        break;

                    case 'ctrl+f':
                        // Focus search if exists
                        const searchInput = document.querySelector('input[type="search"], input[placeholder*="search" i], input[placeholder*="filter" i]');
                        if (searchInput) {
                            searchInput.focus();
                            searchInput.select();
                            e.preventDefault();
                        }
                        break;

                    case 'ctrl+s':
                        // Prevent browser save dialog
                        e.preventDefault();
                        break;

                    case 'ctrl+p':
                        // Allow print but add print class first
                        document.body.classList.add('printing');
                        break;

                    case '?':
                    case 'shift+/':
                        // Show keyboard shortcuts help
                        showKeyboardHelp();
                        e.preventDefault();
                        break;
                }
            }

            // Show keyboard shortcuts help
            function showKeyboardHelp() {
                // Check if help modal already exists
                let helpModal = document.getElementById('keyboard-help-modal');
                if (helpModal) {
                    helpModal.remove();
                    return;
                }

                helpModal = document.createElement('div');
                helpModal.id = 'keyboard-help-modal';
                helpModal.className = 'modal-overlay';
                helpModal.style.cssText = 'display:flex;align-items:center;justify-content:center;z-index:100000';

                const content = document.createElement('div');
                content.className = 'modal-content';
                content.style.cssText = 'max-width:500px;padding:32px';

                let shortcutList = `
                    <h2 style="font-size:24px;margin-bottom:20px;color:#60a5fa">⌨️ Keyboard Shortcuts</h2>
                    <div style="display:grid;gap:12px">
                        <div style="display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px solid #334155">
                            <span class="kbd" style="display:inline-flex;align-items:center;gap:4px;padding:4px 8px;background:linear-gradient(180deg,#334155,#1e293b);border:1px solid #475569;border-radius:6px;font-family:monospace;font-size:11px">Esc</span>
                            <span style="color:#94a3b8">Close modals / Clear focus</span>
                        </div>
                        <div style="display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px solid #334155">
                            <span><span class="kbd" style="display:inline-flex;padding:4px 8px;background:linear-gradient(180deg,#334155,#1e293b);border:1px solid #475569;border-radius:6px;font-family:monospace;font-size:11px">Ctrl</span> + <span class="kbd" style="display:inline-flex;padding:4px 8px;background:linear-gradient(180deg,#334155,#1e293b);border:1px solid #475569;border-radius:6px;font-family:monospace;font-size:11px">F</span></span>
                            <span style="color:#94a3b8">Focus search/filter</span>
                        </div>
                        <div style="display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px solid #334155">
                            <span class="kbd" style="display:inline-flex;padding:4px 8px;background:linear-gradient(180deg,#334155,#1e293b);border:1px solid #475569;border-radius:6px;font-family:monospace;font-size:11px">?</span>
                            <span style="color:#94a3b8">Show this help</span>
                        </div>
                        <div style="display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px solid #334155">
                            <span class="kbd" style="display:inline-flex;padding:4px 8px;background:linear-gradient(180deg,#334155,#1e293b);border:1px solid #475569;border-radius:6px;font-family:monospace;font-size:11px">Tab</span>
                            <span style="color:#94a3b8">Navigate between elements</span>
                        </div>
                        <div style="display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px solid #334155">
                            <span class="kbd" style="display:inline-flex;padding:4px 8px;background:linear-gradient(180deg,#334155,#1e293b);border:1px solid #475569;border-radius:6px;font-family:monospace;font-size:11px">Enter</span>
                            <span style="color:#94a3b8">Activate focused element</span>
                        </div>
                        <div style="display:flex;justify-content:space-between;padding:8px 0">
                            <span class="kbd" style="display:inline-flex;padding:4px 8px;background:linear-gradient(180deg,#334155,#1e293b);border:1px solid #475569;border-radius:6px;font-family:monospace;font-size:11px">Right-click</span>
                            <span style="color:#94a3b8">Context menu</span>
                        </div>
                    </div>
                    <button onclick="this.closest('.modal-overlay').remove()" style="margin-top:24px;width:100%;padding:12px;background:#2563eb;color:white;border:none;border-radius:8px;font-weight:600;cursor:pointer">Close</button>
                `;

                // Add custom shortcuts
                if (shortcuts.size > 0) {
                    shortcutList += '<div style="margin-top:16px;padding-top:16px;border-top:1px solid #475569"><h3 style="font-size:14px;color:#94a3b8;margin-bottom:12px">Custom Shortcuts</h3>';
                    shortcuts.forEach((value, key) => {
                        if (value.description) {
                            shortcutList += `<div style="display:flex;justify-content:space-between;padding:6px 0"><code style="background:#1e293b;padding:4px 8px;border-radius:4px">${key}</code><span style="color:#94a3b8">${value.description}</span></div>`;
                        }
                    });
                    shortcutList += '</div>';
                }

                content.innerHTML = shortcutList;
                helpModal.appendChild(content);

                // Close on overlay click
                helpModal.addEventListener('click', (e) => {
                    if (e.target === helpModal) helpModal.remove();
                });

                document.body.appendChild(helpModal);
            }

            // Context menu system
            let activeContextMenu = null;

            function showContextMenu(x, y, items) {
                hideContextMenu();

                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.style.left = `${x}px`;
                menu.style.top = `${y}px`;

                items.forEach(item => {
                    if (item.separator) {
                        const sep = document.createElement('div');
                        sep.className = 'context-menu-separator';
                        menu.appendChild(sep);
                        return;
                    }

                    const menuItem = document.createElement('div');
                    menuItem.className = 'context-menu-item';
                    menuItem.innerHTML = `
                        ${item.icon ? `<span class="context-menu-item-icon">${item.icon}</span>` : ''}
                        <span>${item.label}</span>
                        ${item.shortcut ? `<span class="context-menu-item-shortcut">${item.shortcut}</span>` : ''}
                    `;
                    menuItem.addEventListener('click', () => {
                        hideContextMenu();
                        if (item.action) item.action();
                    });
                    menu.appendChild(menuItem);
                });

                document.body.appendChild(menu);
                activeContextMenu = menu;

                // Adjust position if menu would go off screen
                const rect = menu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    menu.style.left = `${window.innerWidth - rect.width - 10}px`;
                }
                if (rect.bottom > window.innerHeight) {
                    menu.style.top = `${window.innerHeight - rect.height - 10}px`;
                }

                // Close on click outside
                setTimeout(() => {
                    document.addEventListener('click', hideContextMenu, { once: true });
                    document.addEventListener('contextmenu', hideContextMenu, { once: true });
                }, 10);
            }

            function hideContextMenu() {
                if (activeContextMenu) {
                    activeContextMenu.remove();
                    activeContextMenu = null;
                }
            }

            // Default context menu for data cells
            function handleContextMenu(e) {
                const target = e.target;

                // Check if on a data cell
                const cell = target.closest('td');
                if (cell) {
                    e.preventDefault();
                    const cellText = cell.textContent.trim();

                    showContextMenu(e.clientX, e.clientY, [
                        {
                            icon: '📋',
                            label: 'Copy value',
                            shortcut: 'Ctrl+C',
                            action: () => navigator.clipboard.writeText(cellText)
                        },
                        {
                            icon: '📊',
                            label: 'Copy row',
                            action: () => {
                                const row = cell.closest('tr');
                                if (row) {
                                    const values = Array.from(row.cells).map(c => c.textContent.trim()).join('\t');
                                    navigator.clipboard.writeText(values);
                                }
                            }
                        },
                        { separator: true },
                        {
                            icon: '🔍',
                            label: 'Highlight player',
                            action: () => {
                                const row = cell.closest('tr');
                                if (row) row.style.background = 'rgba(59, 130, 246, 0.2)';
                            }
                        }
                    ]);
                    return;
                }

                // Check if on a player name
                const playerLink = target.closest('.player-link, .player-name, .wowy-player-name');
                if (playerLink) {
                    e.preventDefault();
                    const playerName = playerLink.textContent.trim();

                    showContextMenu(e.clientX, e.clientY, [
                        {
                            icon: '📋',
                            label: 'Copy name',
                            action: () => navigator.clipboard.writeText(playerName)
                        },
                        {
                            icon: '🔎',
                            label: 'Search player',
                            action: () => window.open(`https://www.google.com/search?q=${encodeURIComponent(playerName + ' basketball')}`, '_blank')
                        }
                    ]);
                    return;
                }
            }

            // Window resize optimization
            let resizeTimeout;
            function handleResize() {
                clearTimeout(resizeTimeout);
                document.body.classList.add('resizing');

                resizeTimeout = setTimeout(() => {
                    document.body.classList.remove('resizing');
                    // Trigger any necessary layout recalculations
                    window.dispatchEvent(new CustomEvent('desktopResize'));
                }, 150);
            }

            // Focus management
            function enhanceFocusManagement() {
                // Track whether user is using keyboard
                let usingKeyboard = false;

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        usingKeyboard = true;
                        document.body.classList.add('keyboard-nav');
                    }
                });

                document.addEventListener('mousedown', () => {
                    usingKeyboard = false;
                    document.body.classList.remove('keyboard-nav');
                });

                // Focus trap for modals
                document.addEventListener('keydown', (e) => {
                    if (e.key !== 'Tab') return;

                    const modal = document.querySelector('.modal-overlay');
                    if (!modal) return;

                    const focusable = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
                    if (focusable.length === 0) return;

                    const first = focusable[0];
                    const last = focusable[focusable.length - 1];

                    if (e.shiftKey && document.activeElement === first) {
                        e.preventDefault();
                        last.focus();
                    } else if (!e.shiftKey && document.activeElement === last) {
                        e.preventDefault();
                        first.focus();
                    }
                });
            }

            // Drag and drop file upload enhancement
            function enhanceDragDrop() {
                const dropZones = document.querySelectorAll('.upload-box, .drop-zone, [data-drop-zone]');

                dropZones.forEach(zone => {
                    if (zone.dataset.dropEnhanced) return;
                    zone.dataset.dropEnhanced = 'true';

                    ['dragenter', 'dragover'].forEach(event => {
                        zone.addEventListener(event, (e) => {
                            e.preventDefault();
                            zone.classList.add('drag-over');
                        });
                    });

                    ['dragleave', 'drop'].forEach(event => {
                        zone.addEventListener(event, (e) => {
                            e.preventDefault();
                            zone.classList.remove('drag-over');
                        });
                    });
                });

                // Global drag indicator
                let dragCounter = 0;
                document.addEventListener('dragenter', (e) => {
                    dragCounter++;
                    if (e.dataTransfer.types.includes('Files')) {
                        document.body.classList.add('file-dragging');
                    }
                });

                document.addEventListener('dragleave', (e) => {
                    dragCounter--;
                    if (dragCounter === 0) {
                        document.body.classList.remove('file-dragging');
                    }
                });

                document.addEventListener('drop', () => {
                    dragCounter = 0;
                    document.body.classList.remove('file-dragging');
                });
            }

            // Mouse wheel zoom prevention (allow only on specific elements)
            function preventAccidentalZoom() {
                document.addEventListener('wheel', (e) => {
                    if (e.ctrlKey) {
                        // Allow zoom on images and charts
                        if (!e.target.closest('img, canvas, .chart, .zoomable')) {
                            e.preventDefault();
                        }
                    }
                }, { passive: false });
            }

            // Initialize - DESKTOP IS DEFAULT, only skip on confirmed mobile
            function init() {
                // Desktop features are DEFAULT - only skip if CONFIRMED mobile touch device
                const confirmedMobile = MobileDetect.isMobile && MobileDetect.isTouchDevice && window.innerWidth < 768;

                if (confirmedMobile) {
                    console.log('[DesktopEnhancements] Mobile device detected - using minimal desktop features');
                    // Still add keyboard support even on mobile (for external keyboards)
                    document.addEventListener('keydown', handleKeyDown);
                    return;
                }

                // FULL desktop initialization (DEFAULT)
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('contextmenu', handleContextMenu);
                window.addEventListener('resize', handleResize);

                enhanceFocusManagement();
                enhanceDragDrop();
                preventAccidentalZoom();

                // Add desktop classes to body - this is the DEFAULT state
                document.body.classList.add('is-desktop', 'is-desktop-enhanced');
                document.documentElement.style.setProperty('--is-desktop', '1');
                document.documentElement.style.setProperty('--is-mobile', '0');

                // Register default keyboard shortcuts
                registerShortcut('ctrl+/', showKeyboardHelp, 'Show keyboard shortcuts');
                registerShortcut('alt+1', () => {
                    const tabs = document.querySelectorAll('.tab-btn');
                    if (tabs[0]) tabs[0].click();
                }, 'Go to first tab');
                registerShortcut('alt+2', () => {
                    const tabs = document.querySelectorAll('.tab-btn');
                    if (tabs[1]) tabs[1].click();
                }, 'Go to second tab');
                registerShortcut('alt+3', () => {
                    const tabs = document.querySelectorAll('.tab-btn');
                    if (tabs[2]) tabs[2].click();
                }, 'Go to third tab');

                console.log('[DesktopEnhancements] Fully initialized - PC mode active');
            }

            // Wait for DOM - ensure this runs
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                // Run immediately if DOM is ready
                init();
            }

            // Also ensure it runs after React renders
            window.addEventListener('load', () => {
                if (!document.body.classList.contains('is-desktop-enhanced')) {
                    init();
                }
                // Re-enhance drag drop after React content loads
                setTimeout(enhanceDragDrop, 500);
            });

            return {
                registerShortcut,
                showContextMenu,
                hideContextMenu,
                showKeyboardHelp,
                isDesktop: () => !MobileDetect.isMobile,
                reinit: init
            };
        })();

        window.DesktopEnhancements = DesktopEnhancements;

        // ═══════════════════════════════════════════════════════════════════════════
        // GOOGLE-GRADE MOBILE UTILITIES v3.0
        // Performance monitoring, haptic feedback, network awareness, accessibility
        // ═══════════════════════════════════════════════════════════════════════════
        const GoogleMobileUtils = (function() {
            'use strict';

            // ─── Performance Monitoring ───
            const PerformanceMonitor = {
                marks: {},

                mark(name) {
                    this.marks[name] = performance.now();
                    if (window.performance && performance.mark) {
                        performance.mark(name);
                    }
                },

                measure(name, startMark, endMark) {
                    if (window.performance && performance.measure) {
                        try {
                            performance.measure(name, startMark, endMark);
                        } catch (e) {}
                    }
                    const duration = this.marks[endMark] - this.marks[startMark];
                    if (duration > 100) {
                        console.warn(`[Perf] ${name}: ${duration.toFixed(2)}ms (slow)`);
                    }
                    return duration;
                },

                // Report Long Tasks (>50ms)
                observeLongTasks() {
                    if ('PerformanceObserver' in window) {
                        try {
                            const observer = new PerformanceObserver((list) => {
                                for (const entry of list.getEntries()) {
                                    if (entry.duration > 50) {
                                        console.warn(`[Long Task] ${entry.duration.toFixed(2)}ms`, entry);
                                    }
                                }
                            });
                            observer.observe({ entryTypes: ['longtask'] });
                        } catch (e) {}
                    }
                },

                // First Contentful Paint
                getFCP() {
                    return new Promise((resolve) => {
                        if ('PerformanceObserver' in window) {
                            const observer = new PerformanceObserver((list) => {
                                for (const entry of list.getEntries()) {
                                    if (entry.name === 'first-contentful-paint') {
                                        resolve(entry.startTime);
                                        observer.disconnect();
                                    }
                                }
                            });
                            observer.observe({ entryTypes: ['paint'] });
                        } else {
                            resolve(null);
                        }
                    });
                }
            };

            // ─── Haptic Feedback (where supported) ───
            const HapticFeedback = {
                isSupported: 'vibrate' in navigator,

                // Light tap - 10ms
                light() {
                    if (this.isSupported) navigator.vibrate(10);
                },

                // Medium tap - 20ms
                medium() {
                    if (this.isSupported) navigator.vibrate(20);
                },

                // Heavy tap - 30ms
                heavy() {
                    if (this.isSupported) navigator.vibrate(30);
                },

                // Success pattern
                success() {
                    if (this.isSupported) navigator.vibrate([10, 50, 10]);
                },

                // Error pattern
                error() {
                    if (this.isSupported) navigator.vibrate([30, 50, 30, 50, 30]);
                },

                // Selection change
                selection() {
                    if (this.isSupported) navigator.vibrate(5);
                }
            };

            // ─── Network Awareness ───
            const NetworkMonitor = {
                connection: navigator.connection || navigator.mozConnection || navigator.webkitConnection,

                getConnectionType() {
                    if (!this.connection) return 'unknown';
                    return this.connection.effectiveType || this.connection.type || 'unknown';
                },

                isSlowConnection() {
                    const type = this.getConnectionType();
                    return type === 'slow-2g' || type === '2g' || type === '3g';
                },

                isSaveData() {
                    return this.connection?.saveData || false;
                },

                isOffline() {
                    return !navigator.onLine;
                },

                onConnectionChange(callback) {
                    if (this.connection) {
                        this.connection.addEventListener('change', callback);
                    }
                    window.addEventListener('online', () => callback({ type: 'online' }));
                    window.addEventListener('offline', () => callback({ type: 'offline' }));
                },

                // Adaptive loading based on network
                getLoadingStrategy() {
                    if (this.isOffline()) return 'offline';
                    if (this.isSaveData()) return 'minimal';
                    if (this.isSlowConnection()) return 'reduced';
                    return 'full';
                }
            };

            // ─── Virtual Keyboard Detection ───
            const KeyboardDetector = {
                isOpen: false,
                initialHeight: window.innerHeight,
                listeners: [],

                init() {
                    // Detect keyboard by viewport resize
                    window.addEventListener('resize', () => {
                        const currentHeight = window.innerHeight;
                        const heightDiff = this.initialHeight - currentHeight;

                        // If height reduced by more than 150px, keyboard is likely open
                        const wasOpen = this.isOpen;
                        this.isOpen = heightDiff > 150;

                        if (wasOpen !== this.isOpen) {
                            document.body.classList.toggle('keyboard-open', this.isOpen);
                            this.listeners.forEach(cb => cb(this.isOpen));
                        }
                    });

                    // Also track focus on inputs
                    document.addEventListener('focusin', (e) => {
                        if (e.target.matches('input, textarea, select')) {
                            setTimeout(() => {
                                // Scroll input into view
                                e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }, 300);
                        }
                    });
                },

                onKeyboardChange(callback) {
                    this.listeners.push(callback);
                }
            };

            // ─── Scroll Performance ───
            const ScrollOptimizer = {
                rafId: null,
                lastScrollY: 0,
                ticking: false,

                // Throttled scroll handler
                onScroll(callback) {
                    window.addEventListener('scroll', () => {
                        this.lastScrollY = window.scrollY;
                        if (!this.ticking) {
                            window.requestAnimationFrame(() => {
                                callback(this.lastScrollY);
                                this.ticking = false;
                            });
                            this.ticking = true;
                        }
                    }, { passive: true });
                },

                // Smooth scroll to element
                scrollToElement(element, offset = 0) {
                    if (!element) return;
                    const rect = element.getBoundingClientRect();
                    const scrollTop = window.pageYOffset + rect.top - offset;
                    window.scrollTo({ top: scrollTop, behavior: 'smooth' });
                },

                // Lock body scroll (for modals)
                lockScroll() {
                    const scrollY = window.scrollY;
                    document.body.style.position = 'fixed';
                    document.body.style.top = `-${scrollY}px`;
                    document.body.style.width = '100%';
                    document.body.dataset.scrollY = scrollY;
                },

                // Unlock body scroll
                unlockScroll() {
                    const scrollY = document.body.dataset.scrollY || 0;
                    document.body.style.position = '';
                    document.body.style.top = '';
                    document.body.style.width = '';
                    window.scrollTo(0, parseInt(scrollY));
                }
            };

            // ─── Focus Management (Accessibility) ───
            const FocusManager = {
                trapStack: [],

                // Trap focus within an element (for modals)
                trapFocus(element) {
                    if (!element) return;

                    const focusableElements = element.querySelectorAll(
                        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                    );
                    const firstFocusable = focusableElements[0];
                    const lastFocusable = focusableElements[focusableElements.length - 1];

                    const trapHandler = (e) => {
                        if (e.key !== 'Tab') return;

                        if (e.shiftKey) {
                            if (document.activeElement === firstFocusable) {
                                lastFocusable.focus();
                                e.preventDefault();
                            }
                        } else {
                            if (document.activeElement === lastFocusable) {
                                firstFocusable.focus();
                                e.preventDefault();
                            }
                        }
                    };

                    element.addEventListener('keydown', trapHandler);
                    this.trapStack.push({ element, handler: trapHandler });

                    // Focus first element
                    if (firstFocusable) firstFocusable.focus();

                    return () => this.releaseFocus(element);
                },

                releaseFocus(element) {
                    const index = this.trapStack.findIndex(t => t.element === element);
                    if (index > -1) {
                        const trap = this.trapStack[index];
                        trap.element.removeEventListener('keydown', trap.handler);
                        this.trapStack.splice(index, 1);
                    }
                },

                // Announce to screen readers
                announce(message, priority = 'polite') {
                    const announcer = document.createElement('div');
                    announcer.setAttribute('role', 'status');
                    announcer.setAttribute('aria-live', priority);
                    announcer.setAttribute('aria-atomic', 'true');
                    announcer.className = 'sr-only';
                    announcer.style.cssText = 'position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0;';
                    announcer.textContent = message;
                    document.body.appendChild(announcer);
                    setTimeout(() => announcer.remove(), 1000);
                }
            };

            // ─── Intersection Observer for Lazy Loading ───
            const LazyLoader = {
                observer: null,

                init() {
                    if ('IntersectionObserver' in window) {
                        this.observer = new IntersectionObserver((entries) => {
                            entries.forEach(entry => {
                                if (entry.isIntersecting) {
                                    const el = entry.target;
                                    if (el.dataset.src) {
                                        el.src = el.dataset.src;
                                        el.removeAttribute('data-src');
                                    }
                                    if (el.dataset.bgSrc) {
                                        el.style.backgroundImage = `url(${el.dataset.bgSrc})`;
                                        el.removeAttribute('data-bg-src');
                                    }
                                    el.classList.remove('lazy');
                                    el.classList.add('loaded');
                                    this.observer.unobserve(el);
                                }
                            });
                        }, { rootMargin: '50px' });
                    }
                },

                observe(element) {
                    if (this.observer && element) {
                        this.observer.observe(element);
                    }
                },

                observeAll(selector = '.lazy') {
                    document.querySelectorAll(selector).forEach(el => this.observe(el));
                }
            };

            // ─── Toast/Snackbar Manager ───
            const ToastManager = {
                container: null,
                queue: [],
                activeToast: null,

                init() {
                    this.container = document.createElement('div');
                    this.container.className = 'toast-container';
                    this.container.style.cssText = 'position:fixed;bottom:calc(80px + env(safe-area-inset-bottom));left:16px;right:16px;z-index:9999;pointer-events:none;';
                    document.body.appendChild(this.container);
                },

                show(message, options = {}) {
                    const {
                        duration = 3000,
                        type = 'default',
                        action = null,
                        actionText = 'UNDO'
                    } = options;

                    const toast = document.createElement('div');
                    toast.className = `snackbar ${type}`;
                    toast.style.pointerEvents = 'auto';
                    toast.innerHTML = `
                        <span class="snackbar-message">${message}</span>
                        ${action ? `<button class="snackbar-action">${actionText}</button>` : ''}
                    `;

                    if (action) {
                        toast.querySelector('.snackbar-action').addEventListener('click', () => {
                            action();
                            this.hide(toast);
                        });
                    }

                    this.container.appendChild(toast);

                    // Trigger animation
                    requestAnimationFrame(() => {
                        toast.classList.add('visible');
                    });

                    // Haptic feedback
                    if (type === 'error') HapticFeedback.error();
                    else if (type === 'success') HapticFeedback.success();
                    else HapticFeedback.light();

                    // Auto dismiss
                    setTimeout(() => this.hide(toast), duration);

                    return toast;
                },

                hide(toast) {
                    toast.classList.remove('visible');
                    setTimeout(() => toast.remove(), 300);
                }
            };

            // ─── Initialize All ───
            function init() {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initAll);
                } else {
                    initAll();
                }
            }

            function initAll() {
                // Only initialize on mobile/touch devices
                if (!MobileDetect.isMobile && !MobileDetect.isTouchDevice) {
                    console.log('[GoogleMobileUtils] Desktop detected, minimal initialization');
                    return;
                }

                PerformanceMonitor.observeLongTasks();
                KeyboardDetector.init();
                LazyLoader.init();
                ToastManager.init();

                // Apply network-aware styles
                const strategy = NetworkMonitor.getLoadingStrategy();
                if (strategy === 'minimal' || strategy === 'reduced') {
                    document.body.classList.add('data-saver');
                    document.body.classList.add('reduce-motion');
                }

                // Listen for network changes
                NetworkMonitor.onConnectionChange((e) => {
                    if (e.type === 'offline') {
                        ToastManager.show('You are offline. Some features may be unavailable.', { type: 'warning', duration: 5000 });
                    } else if (e.type === 'online') {
                        ToastManager.show('Back online!', { type: 'success', duration: 2000 });
                    }
                });

                // Add haptic feedback to buttons
                document.addEventListener('click', (e) => {
                    const target = e.target.closest('button, .btn, .tab-btn, .subtab-btn');
                    if (target) HapticFeedback.light();
                }, { passive: true });

                // Lazy load images
                LazyLoader.observeAll();

                console.log('[GoogleMobileUtils] Initialized with strategy:', strategy);
            }

            init();

            return {
                Performance: PerformanceMonitor,
                Haptic: HapticFeedback,
                Network: NetworkMonitor,
                Keyboard: KeyboardDetector,
                Scroll: ScrollOptimizer,
                Focus: FocusManager,
                LazyLoad: LazyLoader,
                Toast: ToastManager
            };
        })();

        window.GoogleMobileUtils = GoogleMobileUtils;

        // ═══════════════════════════════════════════════════════════════════════════
        // COPY PROTECTION SYSTEM v4.0 - COMPREHENSIVE ANTI-TAMPERING
        // Multi-layer protection with distributed integrity checks
        // ═══════════════════════════════════════════════════════════════════════════

        const _0x7f = "WktUGhE4XRkSEXQcVjBkNB0aXhwLR2QhCU9gNw4wATYPOHQ3UydkNR0vSSELHkkhDxpnNlc3WSJTL142CjxeIR0ndzcLMGc1Vz9ZNlcVdzcRFWshHk9wNRA7dzcfM3Q3DhpZIlcjATVUN2c3DzxkIlMzZzYONGchHjdJNVc/ZzcQTkobDyBrLRIaZCEUDmQZVSRkISlPYBoROF40V0NkIldDARoNPGsiHSBdIVYedBwXEl40VzhrGQlPSjRRO3sbVyR7GQ==";

        const _GV_CONFIG = {
            _e: _0x7f,
            _k: "gv3x",
            sessionMinutes: 60,
            maxAttempts: 5,
            lockoutMinutes: 15,
            cacheMinutes: 5
        };

        // ═══════════════════════════════════════════════════════════════════════════
        // PARENT APP BRIDGE - Communication with Tauri launcher for password save/auto-fill
        // ═══════════════════════════════════════════════════════════════════════════
        const _ParentBridge = (function() {
            'use strict';

            const PARENT_ORIGIN = '*'; // Accept from any parent (Tauri app)
            const APP_ID = 'lineup-analyzer'; // Unique identifier for this app

            let isInIframe = false;
            let parentReady = false;
            let pendingPassword = null;

            // Check if running inside an iframe
            function detectIframe() {
                try {
                    isInIframe = window.self !== window.top;
                } catch (e) {
                    isInIframe = true; // Cross-origin restriction means we're in iframe
                }
                return isInIframe;
            }

            // Send message to parent app
            function sendToParent(type, data = {}) {
                if (!isInIframe) return;
                try {
                    window.parent.postMessage({
                        source: 'slb-remote-app',
                        type: type,
                        appId: APP_ID,
                        ...data
                    }, PARENT_ORIGIN);
                } catch (e) {
                    console.log('[ParentBridge] Failed to send message:', e);
                }
            }

            // Handle messages from parent
            function handleParentMessage(event) {
                const data = event.data;
                if (!data || typeof data !== 'object' || data.source !== 'slb-parent-app') {
                    return;
                }

                console.log('[ParentBridge] Received:', data.type);

                switch (data.type) {
                    case 'SAVED_PASSWORD':
                        parentReady = true;
                        if (data.password) {
                            pendingPassword = data.password;
                            // Auto-fill the password field if overlay is visible
                            const pwdInput = document.getElementById('_gvPwd');
                            const overlay = document.getElementById('_gvAuthOverlay');
                            if (pwdInput && overlay && overlay.style.display !== 'none') {
                                pwdInput.value = data.password;
                                // Show remember checkbox as checked since we have a saved password
                                const rememberRow = document.getElementById('_gvRememberRow');
                                const rememberCb = document.getElementById('_gvRememberPwd');
                                if (rememberRow) rememberRow.style.display = 'block';
                                if (rememberCb) rememberCb.checked = true;

                                // Auto-submit after auto-load completes (or after timeout)
                                // Wait for auto-load to finish before submitting to ensure data is loaded
                                const waitForAutoLoadAndSubmit = () => {
                                    const status = window._slbAutoLoadStatus;
                                    if (status === 'success' || status === 'failed') {
                                        // Auto-load finished, now submit
                                        setTimeout(() => {
                                            const submitBtn = document.getElementById('_gvSubmit');
                                            if (submitBtn && !submitBtn.disabled) {
                                                submitBtn.click();
                                            }
                                        }, 100);
                                    } else if (status === 'loading' || status === 'pending') {
                                        // Still loading, check again in 200ms
                                        setTimeout(waitForAutoLoadAndSubmit, 200);
                                    } else {
                                        // No auto-load status (maybe running locally), submit after short delay
                                        setTimeout(() => {
                                            const submitBtn = document.getElementById('_gvSubmit');
                                            if (submitBtn && !submitBtn.disabled) {
                                                submitBtn.click();
                                            }
                                        }, 300);
                                    }
                                };
                                // Start waiting after a brief delay for React to mount
                                setTimeout(waitForAutoLoadAndSubmit, 300);
                            }
                        }
                        break;

                    case 'NO_SAVED_PASSWORD':
                        parentReady = true;
                        // Show the remember checkbox option
                        const rememberRow = document.getElementById('_gvRememberRow');
                        if (rememberRow) rememberRow.style.display = 'block';
                        break;

                    case 'PASSWORD_SAVED':
                        console.log('[ParentBridge] Password saved successfully');
                        break;

                    case 'PASSWORD_CLEARED':
                        console.log('[ParentBridge] Password cleared');
                        break;

                    case 'THEME_UPDATE':
                        console.log('[ParentBridge] Theme update received:', data.theme);
                        applyParentTheme(data.theme);
                        // Apply percentile colors from parent if provided
                        if (data.percentileColors) {
                            applyPercentileColorsFromParent(data.percentileColors);
                        }
                        break;

                    case 'COMP_CODE_CHANGE':
                        console.log('[ParentBridge] Competition code change received:', data.competitionCode);
                        if (data.competitionCode && typeof window._slbReloadForCompetitionCode === 'function') {
                            // Use the reload function which sets the code AND reloads data
                            window._slbReloadForCompetitionCode(data.competitionCode);
                        } else if (data.competitionCode && typeof window._slbSetSelectedCompetitionCode === 'function') {
                            // Fallback to just setting the code
                            window._slbSetSelectedCompetitionCode(data.competitionCode);
                        }
                        break;

                    case 'DATA_FILES_INFO':
                        console.log('[ParentBridge] Received data file URLs:', data.dataFiles?.length, 'files for', data.appType);
                        if (data.dataFiles && data.dataFiles.length > 0) {
                            // Buffer the data files in case React hasn't mounted yet
                            window._slbPendingDataFiles = data.dataFiles;
                            if (typeof window._slbLoadFromDataUrls === 'function') {
                                window._slbLoadFromDataUrls(data.dataFiles);
                            } else {
                                console.log('[ParentBridge] _slbLoadFromDataUrls not ready yet, buffered for later');
                            }
                        }
                        break;
                }
            }

            // Store current theme colors globally for legend access
            window._currentThemeColors = null;

            // Blend two hex colors together
            function blendColorsLineup(baseHex, tintHex, amount) {
                const base = hexToRgbObj(baseHex);
                const tint = hexToRgbObj(tintHex);
                if (!base || !tint) return baseHex;

                const r = Math.round(base.r + (tint.r - base.r) * amount);
                const g = Math.round(base.g + (tint.g - base.g) * amount);
                const b = Math.round(base.b + (tint.b - base.b) * amount);

                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            // Convert hex to RGB object
            function hexToRgbObj(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            // Apply theme from parent Tauri app
            function applyParentTheme(theme) {
                if (!theme) return;

                const root = document.documentElement;
                const isLight = theme.backgroundMode === 'light';
                const primaryColor = theme.primaryColor;
                const accentColor = theme.accentColor;

                // Apply light/dark mode class
                if (isLight) {
                    document.body.classList.add('light-theme');
                } else {
                    document.body.classList.remove('light-theme');
                }

                // Set CSS custom properties for theming
                if (primaryColor) {
                    root.style.setProperty('--theme-primary', primaryColor);
                    root.style.setProperty('--theme-primary-rgb', hexToRgb(primaryColor));
                }
                if (accentColor) {
                    root.style.setProperty('--theme-accent', accentColor);
                    root.style.setProperty('--theme-accent-rgb', hexToRgb(accentColor));
                }
                if (theme.customBgColor) {
                    root.style.setProperty('--theme-bg', theme.customBgColor);
                }

                // Apply comprehensive background theming
                applyDynamicBackgroundStyles(theme);

                // Generate complementary color palette for performance coding
                // Skip if color is black or white (no hue to work with)
                if (primaryColor && !isBlackOrWhite(primaryColor)) {
                    const perfColors = generatePerformanceColorPalette(primaryColor);
                    applyPerformanceColors(perfColors);
                    window._currentThemeColors = perfColors;
                } else if (primaryColor && isBlackOrWhite(primaryColor)) {
                    // Reset to default colors for black/white themes
                    resetPerformanceColorsToDefault();
                    window._currentThemeColors = null;
                }

                // Apply primary color to key UI elements
                applyThemeToElements(theme);
            }

            // Apply dynamic background styles based on theme
            function applyDynamicBackgroundStyles(theme) {
                const existing = document.getElementById('dynamic-theme-bg');
                if (existing) existing.remove();

                const primaryColor = theme.primaryColor;
                const accentColor = theme.accentColor;
                const isLight = theme.backgroundMode === 'light';

                if (!primaryColor) return;

                const style = document.createElement('style');
                style.id = 'dynamic-theme-bg';
                const primaryRgb = hexToRgb(primaryColor);

                if (isLight) {
                    // Light mode with primary color tints and enhanced visibility
                    const lightBg = blendColorsLineup('#ffffff', primaryColor, 0.06);
                    const lightBgSecondary = blendColorsLineup('#f5f5f7', primaryColor, 0.08);
                    const lightBorder = blendColorsLineup('#d0d0d8', primaryColor, 0.20);
                    const darkerPrimary = blendColorsLineup(primaryColor, '#000000', 0.15);

                    style.textContent = `
                        body.light-theme {
                            background: linear-gradient(135deg, ${lightBg} 0%, ${lightBgSecondary} 100%) !important;
                        }
                        body.light-theme .upload-box,
                        body.light-theme .controls,
                        body.light-theme .section {
                            background: rgba(255, 255, 255, 0.92) !important;
                            border-color: ${lightBorder} !important;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.06) !important;
                        }
                        body.light-theme table {
                            background: rgba(255, 255, 255, 0.92) !important;
                        }
                        body.light-theme th,
                        body.light-theme .full-table-wrapper > table > thead > tr > th {
                            background: ${blendColorsLineup('#e8e8ec', primaryColor, 0.12)} !important;
                            color: #1a1a2e !important;
                        }
                        body.light-theme td {
                            color: #1a1a2e !important;
                            border-color: #e0e0e4 !important;
                        }
                        body.light-theme select,
                        body.light-theme input {
                            background: ${blendColorsLineup('#ffffff', primaryColor, 0.03)} !important;
                            border-color: ${lightBorder} !important;
                            color: #1a1a2e !important;
                        }
                        body.light-theme select:focus,
                        body.light-theme input:focus {
                            border-color: ${primaryColor} !important;
                            box-shadow: 0 0 0 3px rgba(${primaryRgb}, 0.15) !important;
                        }

                        /* Buttons with shadows for visibility */
                        body.light-theme .btn,
                        body.light-theme .upload-btn,
                        body.light-theme button:not(.color-preset) {
                            box-shadow: 0 2px 4px rgba(0,0,0,0.15), 0 1px 2px rgba(0,0,0,0.1) !important;
                            border: 1px solid rgba(0,0,0,0.1) !important;
                        }
                        body.light-theme .btn-primary,
                        body.light-theme .upload-btn:not(.secondary):not(.matchup):not(.season) {
                            background: ${darkerPrimary} !important;
                        }

                        /* Filter tags/badges with better contrast */
                        body.light-theme [class*="filter-tag"],
                        body.light-theme [class*="badge"],
                        body.light-theme [class*="pill"] {
                            box-shadow: 0 1px 3px rgba(0,0,0,0.12) !important;
                        }

                        /* Rating tags - make backgrounds more opaque */
                        body.light-theme [class*="opp-"] {
                            font-weight: 600 !important;
                        }
                        body.light-theme .opp-hard { background: rgba(220, 38, 38, 0.9) !important; color: #fff !important; }
                        body.light-theme .opp-tough { background: rgba(234, 88, 12, 0.9) !important; color: #fff !important; }
                        body.light-theme .opp-mid { background: rgba(202, 138, 4, 0.9) !important; color: #fff !important; }
                        body.light-theme .opp-easy { background: rgba(22, 163, 74, 0.9) !important; color: #fff !important; }
                        body.light-theme .opp-cake { background: rgba(34, 197, 94, 0.9) !important; color: #fff !important; }

                        /* Performance cells - stronger colors */
                        body.light-theme .pct-excellent,
                        body.light-theme .perf-excellent { background: rgba(22, 163, 74, 0.8) !important; color: #fff !important; }
                        body.light-theme .pct-good,
                        body.light-theme .perf-good { background: rgba(132, 204, 22, 0.85) !important; color: #1a1a2e !important; }
                        body.light-theme .pct-avg,
                        body.light-theme .perf-average { background: rgba(234, 179, 8, 0.85) !important; color: #1a1a2e !important; }
                        body.light-theme .pct-below,
                        body.light-theme .perf-below { background: rgba(249, 115, 22, 0.85) !important; color: #fff !important; }
                        body.light-theme .pct-poor,
                        body.light-theme .perf-poor { background: rgba(220, 38, 38, 0.8) !important; color: #fff !important; }

                        /* Links */
                        body.light-theme a { color: ${darkerPrimary} !important; }
                        body.light-theme .player-link { color: ${darkerPrimary} !important; font-weight: 600; }

                        /* Auth overlay */
                        body.light-theme #_gvAuthOverlay {
                            background: linear-gradient(135deg, ${lightBg} 0%, ${lightBgSecondary} 100%) !important;
                        }
                        body.light-theme #_gvAuthBox {
                            background: rgba(255, 255, 255, 0.95) !important;
                            border-color: ${lightBorder} !important;
                            box-shadow: 0 25px 80px rgba(0,0,0,0.12) !important;
                        }
                        body.light-theme ._gvTitle { color: #1a1a2e !important; }
                        body.light-theme ._gvSub { color: #4a4a5a !important; }
                        body.light-theme #_gvPwd {
                            background: rgba(0,0,0,0.03) !important;
                            color: #1a1a2e !important;
                            border-color: ${lightBorder} !important;
                        }
                        body.light-theme ._gvLock { color: #6a6a7a !important; }

                        /* Scrollbar */
                        body.light-theme ::-webkit-scrollbar-track { background: #f0f0f2 !important; }
                        body.light-theme ::-webkit-scrollbar-thumb { background: #c0c0c8 !important; border-radius: 4px; }
                        body.light-theme ::-webkit-scrollbar-thumb:hover { background: #a0a0a8 !important; }
                    `;
                } else {
                    // Dark mode with primary color tints
                    const darkBg = blendColorsLineup('#0f172a', primaryColor, 0.15);
                    const darkBgSecondary = blendColorsLineup('#1e293b', primaryColor, 0.18);
                    const darkBorder = blendColorsLineup('#475569', primaryColor, 0.35);

                    style.textContent = `
                        body {
                            background: linear-gradient(135deg, ${darkBgSecondary} 0%, ${darkBg} 100%) !important;
                        }
                        .upload-box,
                        .controls {
                            background: rgba(${hexToRgb(blendColorsLineup('#1e293b', primaryColor, 0.20))}, 0.5) !important;
                            border-color: ${darkBorder} !important;
                        }
                        table {
                            background: rgba(${hexToRgb(blendColorsLineup('#1e293b', primaryColor, 0.18))}, 0.5) !important;
                        }
                        th,
                        .full-table-wrapper > table > thead > tr > th {
                            background: ${blendColorsLineup('#1e293b', primaryColor, 0.22)} !important;
                        }
                        select,
                        input {
                            background: ${blendColorsLineup('#0f172a', primaryColor, 0.12)} !important;
                            border-color: ${darkBorder} !important;
                        }
                        select:focus,
                        input:focus {
                            border-color: ${primaryColor} !important;
                            box-shadow: 0 0 0 3px rgba(${primaryRgb}, 0.25) !important;
                        }
                        #_gvAuthOverlay {
                            background: linear-gradient(135deg, ${darkBgSecondary} 0%, ${darkBg} 100%) !important;
                        }
                        #_gvAuthBox {
                            background: rgba(${hexToRgb(blendColorsLineup('#1e293b', primaryColor, 0.20))}, 0.95) !important;
                            border-color: ${darkBorder} !important;
                        }
                        .full-table-row:hover td {
                            background: rgba(${primaryRgb}, 0.20) !important;
                        }
                    `;
                }

                document.head.appendChild(style);
            }

            // Convert hex to RGB for rgba() usage
            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                if (result) {
                    return `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}`;
                }
                return '59, 130, 246'; // fallback blue
            }

            // Check if a color is black or white (or very close to it)
            function isBlackOrWhite(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                if (!result) return false;

                const r = parseInt(result[1], 16);
                const g = parseInt(result[2], 16);
                const b = parseInt(result[3], 16);

                // Calculate luminance
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b);

                // Check if very dark (black) or very light (white)
                // Also check if grayscale (r, g, b are very similar)
                const isGrayscale = Math.abs(r - g) < 15 && Math.abs(g - b) < 15 && Math.abs(r - b) < 15;
                const isVeryDark = luminance < 30;
                const isVeryLight = luminance > 225;

                return (isGrayscale && (isVeryDark || isVeryLight)) || luminance < 10 || luminance > 245;
            }

            // Reset performance colors to default (original green-yellow-red scale)
            function resetPerformanceColorsToDefault() {
                const existing = document.getElementById('theme-perf-colors');
                if (existing) existing.remove();

                // Reset CSS variables to defaults
                const root = document.documentElement;
                root.style.setProperty('--perf-excellent', '#22c55e');
                root.style.setProperty('--perf-excellent-rgb', '34, 197, 94');
                root.style.setProperty('--perf-good', '#84cc16');
                root.style.setProperty('--perf-good-rgb', '132, 204, 22');
                root.style.setProperty('--perf-average', '#eab308');
                root.style.setProperty('--perf-average-rgb', '234, 179, 8');
                root.style.setProperty('--perf-below', '#f97316');
                root.style.setProperty('--perf-below-rgb', '249, 115, 22');
                root.style.setProperty('--perf-poor', '#ef4444');
                root.style.setProperty('--perf-poor-rgb', '239, 68, 68');
            }

            // Convert hex to HSL
            function hexToHsl(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                if (!result) return { h: 200, s: 80, l: 60 };

                let r = parseInt(result[1], 16) / 255;
                let g = parseInt(result[2], 16) / 255;
                let b = parseInt(result[3], 16) / 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }
                return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
            }

            // Convert HSL to hex
            function hslToHex(h, s, l) {
                s /= 100;
                l /= 100;
                const a = s * Math.min(l, 1 - l);
                const f = n => {
                    const k = (n + h / 30) % 12;
                    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    return Math.round(255 * color).toString(16).padStart(2, '0');
                };
                return `#${f(0)}${f(8)}${f(4)}`;
            }

            // Generate complementary color palette based on theme color
            function generatePerformanceColorPalette(primaryHex) {
                const hsl = hexToHsl(primaryHex);

                // Create a 5-color palette using color theory
                // Excellent (80th+): MOST vibrant - highest saturation, the best should look the best
                // Good (60-80th): Same hue but SIGNIFICANTLY duller - clearly secondary to excellent
                // Average: Neutral (heavily desaturated)
                // Below: Complementary -60 degrees (warm)
                // Poor: Complementary (opposite on color wheel)

                // Excellent: High saturation, vibrant
                const excellent = hslToHex(hsl.h, Math.min(hsl.s + 15, 100), Math.min(hsl.l + 5, 65));
                // Good: Same hue but MUCH less saturated - clearly secondary to excellent
                // Reduced saturation significantly and made lighter to appear muted
                const good = hslToHex(hsl.h, Math.max(hsl.s - 35, 25), Math.min(hsl.l + 10, 55));
                const average = hslToHex(hsl.h, Math.max(hsl.s - 40, 20), Math.min(hsl.l + 10, 60));
                const below = hslToHex((hsl.h + 180 - 40 + 360) % 360, Math.max(hsl.s - 5, 50), hsl.l);
                const poor = hslToHex((hsl.h + 180) % 360, Math.min(hsl.s + 10, 100), Math.max(hsl.l - 5, 45));

                return {
                    excellent: { hex: excellent, rgb: hexToRgb(excellent), name: 'Excellent' },
                    good: { hex: good, rgb: hexToRgb(good), name: 'Good' },
                    average: { hex: average, rgb: hexToRgb(average), name: 'Average' },
                    below: { hex: below, rgb: hexToRgb(below), name: 'Below Avg' },
                    poor: { hex: poor, rgb: hexToRgb(poor), name: 'Poor' }
                };
            }

            // Apply percentile colors directly from parent app (overrides local generation)
            function applyPercentileColorsFromParent(colors) {
                if (!colors) return;
                console.log('[ParentBridge] Applying percentile colors from parent:', colors);

                const root = document.documentElement;

                // Set CSS variables for percentile-based coloring
                if (colors.percentile80Plus) root.style.setProperty('--percentile-80-plus', colors.percentile80Plus);
                if (colors.percentile60Plus) root.style.setProperty('--percentile-60-plus', colors.percentile60Plus);
                if (colors.percentileNeutral) root.style.setProperty('--percentile-neutral', colors.percentileNeutral);
                if (colors.percentile40Minus) root.style.setProperty('--percentile-40-minus', colors.percentile40Minus);
                if (colors.percentile20Minus) root.style.setProperty('--percentile-20-minus', colors.percentile20Minus);

                // Text colors
                if (colors.textOnPercentile80Plus) root.style.setProperty('--text-on-percentile-80-plus', colors.textOnPercentile80Plus);
                if (colors.textOnPercentile60Plus) root.style.setProperty('--text-on-percentile-60-plus', colors.textOnPercentile60Plus);
                if (colors.textOnPercentileNeutral) root.style.setProperty('--text-on-percentile-neutral', colors.textOnPercentileNeutral);
                if (colors.textOnPercentile40Minus) root.style.setProperty('--text-on-percentile-40-minus', colors.textOnPercentile40Minus);
                if (colors.textOnPercentile20Minus) root.style.setProperty('--text-on-percentile-20-minus', colors.textOnPercentile20Minus);

                // Base colors
                if (colors.positiveBase) root.style.setProperty('--percentile-positive-base', colors.positiveBase);
                if (colors.negativeBase) root.style.setProperty('--percentile-negative-base', colors.negativeBase);
                if (colors.neutralBase) root.style.setProperty('--percentile-neutral-base', colors.neutralBase);

                // Also update performance colors to match parent's percentile colors
                // Map: excellent=80+, good=60+, average=neutral, below=40-, poor=20-
                if (colors.percentile80Plus && colors.percentile60Plus && colors.percentileNeutral && colors.percentile40Minus && colors.percentile20Minus) {
                    const perfColors = {
                        excellent: { hex: colors.percentile80Plus, rgb: hexToRgb(colors.percentile80Plus), name: 'Excellent' },
                        good: { hex: colors.percentile60Plus, rgb: hexToRgb(colors.percentile60Plus), name: 'Good' },
                        average: { hex: colors.percentileNeutral, rgb: hexToRgb(colors.percentileNeutral), name: 'Average' },
                        below: { hex: colors.percentile40Minus, rgb: hexToRgb(colors.percentile40Minus), name: 'Below Avg' },
                        poor: { hex: colors.percentile20Minus, rgb: hexToRgb(colors.percentile20Minus), name: 'Poor' }
                    };
                    applyPerformanceColors(perfColors);
                    window._currentThemeColors = perfColors;
                }
            }

            // Apply performance colors via dynamic stylesheet
            function applyPerformanceColors(colors) {
                // Remove existing theme style
                const existing = document.getElementById('theme-perf-colors');
                if (existing) existing.remove();

                const style = document.createElement('style');
                style.id = 'theme-perf-colors';
                style.textContent = `
                    /* Themed performance colors - auto-generated from theme */
                    .perf-excellent { background: rgba(${colors.excellent.rgb}, 0.55) !important; border: 2px solid rgba(${colors.excellent.rgb}, 0.9) !important; }
                    .perf-good { background: rgba(${colors.good.rgb}, 0.5) !important; border: 2px solid rgba(${colors.good.rgb}, 0.85) !important; }
                    .perf-average { background: rgba(${colors.average.rgb}, 0.45) !important; border: 2px solid rgba(${colors.average.rgb}, 0.8) !important; }
                    .perf-below { background: rgba(${colors.below.rgb}, 0.5) !important; border: 2px solid rgba(${colors.below.rgb}, 0.85) !important; }
                    .perf-poor { background: rgba(${colors.poor.rgb}, 0.55) !important; border: 2px solid rgba(${colors.poor.rgb}, 0.9) !important; }

                    .legend-excellent { background: rgba(${colors.excellent.rgb}, 0.55) !important; border: 2px solid rgba(${colors.excellent.rgb}, 0.9) !important; }
                    .legend-good { background: rgba(${colors.good.rgb}, 0.5) !important; border: 2px solid rgba(${colors.good.rgb}, 0.85) !important; }
                    .legend-average { background: rgba(${colors.average.rgb}, 0.45) !important; border: 2px solid rgba(${colors.average.rgb}, 0.8) !important; }
                    .legend-below { background: rgba(${colors.below.rgb}, 0.5) !important; border: 2px solid rgba(${colors.below.rgb}, 0.85) !important; }
                    .legend-poor { background: rgba(${colors.poor.rgb}, 0.55) !important; border: 2px solid rgba(${colors.poor.rgb}, 0.9) !important; }

                    .export-ff-stat-box.perf-excellent { background: rgba(${colors.excellent.rgb}, 0.3) !important; border-left: 4px solid ${colors.excellent.hex} !important; }
                    .export-ff-stat-box.perf-good { background: rgba(${colors.good.rgb}, 0.25) !important; border-left: 4px solid ${colors.good.hex} !important; }
                    .export-ff-stat-box.perf-average { background: rgba(${colors.average.rgb}, 0.2) !important; border-left: 4px solid ${colors.average.hex} !important; }
                    .export-ff-stat-box.perf-below { background: rgba(${colors.below.rgb}, 0.25) !important; border-left: 4px solid ${colors.below.hex} !important; }
                    .export-ff-stat-box.perf-poor { background: rgba(${colors.poor.rgb}, 0.3) !important; border-left: 4px solid ${colors.poor.hex} !important; }

                    .export-ff-stat-box-sm.perf-excellent { background: rgba(${colors.excellent.rgb}, 0.3) !important; }
                    .export-ff-stat-box-sm.perf-good { background: rgba(${colors.good.rgb}, 0.2) !important; }
                    .export-ff-stat-box-sm.perf-average { background: rgba(${colors.average.rgb}, 0.15) !important; }
                    .export-ff-stat-box-sm.perf-below { background: rgba(${colors.below.rgb}, 0.2) !important; }
                    .export-ff-stat-box-sm.perf-poor { background: rgba(${colors.poor.rgb}, 0.25) !important; }

                    /* Theme color CSS variables for JS access */
                    :root {
                        --perf-excellent: ${colors.excellent.hex};
                        --perf-excellent-rgb: ${colors.excellent.rgb};
                        --perf-good: ${colors.good.hex};
                        --perf-good-rgb: ${colors.good.rgb};
                        --perf-average: ${colors.average.hex};
                        --perf-average-rgb: ${colors.average.rgb};
                        --perf-below: ${colors.below.hex};
                        --perf-below-rgb: ${colors.below.rgb};
                        --perf-poor: ${colors.poor.hex};
                        --perf-poor-rgb: ${colors.poor.rgb};
                    }
                `;
                document.head.appendChild(style);

                // Update any existing legend displays
                updateDynamicLegends(colors);
            }

            // Update existing legends to show new colors
            function updateDynamicLegends(colors) {
                // Find all legend containers and update their color swatches if needed
                document.querySelectorAll('.color-legend').forEach(legend => {
                    // Add a visual indicator that colors have changed
                    legend.setAttribute('data-themed', 'true');
                });
            }

            // Get current performance colors for use in React components
            window.getThemePerformanceColors = function() {
                if (window._currentThemeColors) {
                    return window._currentThemeColors;
                }
                // Return defaults if no theme applied
                return {
                    excellent: { hex: '#22c55e', rgb: '34, 197, 94', name: 'Excellent' },
                    good: { hex: '#84cc16', rgb: '132, 204, 22', name: 'Good' },
                    average: { hex: '#eab308', rgb: '234, 179, 8', name: 'Average' },
                    below: { hex: '#f97316', rgb: '249, 115, 22', name: 'Below Avg' },
                    poor: { hex: '#ef4444', rgb: '239, 68, 68', name: 'Poor' }
                };
            };

            // Apply theme colors to specific elements
            function applyThemeToElements(theme) {
                // Update header gradient
                const header = document.querySelector('.header h1');
                if (header && theme.primaryColor && theme.accentColor) {
                    header.style.background = `linear-gradient(to right, ${theme.primaryColor}, ${theme.accentColor})`;
                    header.style.webkitBackgroundClip = 'text';
                    header.style.webkitTextFillColor = 'transparent';
                }

                // Update primary buttons
                document.querySelectorAll('.btn-primary, .upload-btn:not(.secondary):not(.matchup):not(.season)').forEach(btn => {
                    if (theme.primaryColor) {
                        btn.style.background = theme.primaryColor;
                    }
                });

                // Update stat cards border/background accents
                document.querySelectorAll('.stat-card').forEach(card => {
                    if (theme.primaryColor) {
                        const rgb = hexToRgb(theme.primaryColor);
                        card.style.background = `rgba(${rgb}, 0.2)`;
                        card.style.borderColor = `rgba(${rgb}, 0.3)`;
                    }
                });

                // Update dataset info boxes
                document.querySelectorAll('.dataset-info').forEach(info => {
                    if (theme.primaryColor) {
                        const rgb = hexToRgb(theme.primaryColor);
                        info.style.background = `rgba(${rgb}, 0.15)`;
                        info.style.borderColor = `rgba(${rgb}, 0.5)`;
                    }
                });

                // Update logo gradient if exists
                const logo = document.querySelector('._gvLogo');
                if (logo && theme.primaryColor && theme.accentColor) {
                    logo.style.background = `linear-gradient(135deg, ${theme.primaryColor}, ${theme.accentColor})`;
                }
            }

            // Request saved password from parent
            function requestSavedPassword() {
                sendToParent('REQUEST_SAVED_PASSWORD');
            }

            // Save password to parent app
            function savePassword(password) {
                sendToParent('SAVE_PASSWORD', { password: password });
            }

            // Clear saved password
            function clearPassword() {
                sendToParent('CLEAR_SAVED_PASSWORD');
            }

            // Notify parent of successful authentication
            function notifyAuthSuccess() {
                sendToParent('AUTH_SUCCESS');
            }

            // Initialize the bridge
            function init() {
                if (!detectIframe()) {
                    console.log('[ParentBridge] Not in iframe, bridge disabled');
                    return;
                }

                console.log('[ParentBridge] Running in iframe, initializing bridge');

                // Listen for messages from parent
                window.addEventListener('message', handleParentMessage);

                // Request saved password after a short delay to ensure parent is ready
                setTimeout(requestSavedPassword, 100);
            }

            // Auto-init when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }

            // Public API
            return {
                isInIframe: () => isInIframe,
                savePassword: savePassword,
                clearPassword: clearPassword,
                notifyAuthSuccess: notifyAuthSuccess,
                getPendingPassword: () => pendingPassword
            };
        })();

        // ═══════════════════════════════════════════════════════════════════════════
        // IMAGE BRIDGE - Request player/team images from Tauri parent app
        // ═══════════════════════════════════════════════════════════════════════════
        const ImageBridge = (function() {
            'use strict';

            const pendingRequests = new Map();
            let requestIdCounter = 0;
            let isInIframe = false;
            const imageCache = new Map(); // Local cache for session

            // Detect if running in iframe
            function detectIframe() {
                try {
                    isInIframe = window.self !== window.top;
                    return isInIframe;
                } catch (e) {
                    isInIframe = true;
                    return true;
                }
            }

            // Generate unique request ID
            function generateRequestId() {
                return `img_${Date.now()}_${++requestIdCounter}`;
            }

            // Generate cache key
            function getCacheKey(type, name, team) {
                return `${type}:${name.toLowerCase()}:${team.toLowerCase()}`;
            }

            // Send message to parent
            function sendToParent(type, data) {
                if (!isInIframe) return;
                try {
                    window.parent.postMessage({
                        source: 'slb-remote-app',
                        type: type,
                        ...data
                    }, '*');
                } catch (e) {
                    console.log('[ImageBridge] Failed to send message:', e);
                }
            }

            // Handle image responses from parent
            function handleImageResponse(data) {
                const { requestId, imageData, error } = data;

                if (pendingRequests.has(requestId)) {
                    const { resolve, reject, cacheKey } = pendingRequests.get(requestId);
                    pendingRequests.delete(requestId);

                    if (error) {
                        reject(new Error(error));
                    } else {
                        // Cache the result
                        if (imageData) {
                            imageCache.set(cacheKey, imageData);
                        }
                        resolve(imageData);
                    }
                }
            }

            // Handle batch image response
            function handleBatchResponse(data) {
                const { requestId, results, error } = data;

                if (pendingRequests.has(requestId)) {
                    const { resolve, reject, requests } = pendingRequests.get(requestId);
                    pendingRequests.delete(requestId);

                    if (error) {
                        reject(new Error(error));
                    } else {
                        // Cache all results
                        for (const [key, imageData] of Object.entries(results)) {
                            if (imageData) {
                                imageCache.set(key, imageData);
                            }
                        }
                        resolve(results);
                    }
                }
            }

            // Listen for messages from parent
            window.addEventListener('message', function(event) {
                const data = event.data;
                if (!data || typeof data !== 'object' || data.source !== 'slb-parent-app') {
                    return;
                }

                switch (data.type) {
                    case 'PLAYER_IMAGE_RESPONSE':
                    case 'TEAM_IMAGE_RESPONSE':
                        handleImageResponse(data);
                        break;
                    case 'IMAGES_BATCH_RESPONSE':
                        handleBatchResponse(data);
                        break;
                }
            });

            // Request a player image
            function requestPlayerImage(playerName, teamName, leagueName = null) {
                return new Promise((resolve, reject) => {
                    if (!isInIframe) {
                        resolve(null); // Not in Tauri, return null
                        return;
                    }

                    // Check local cache first
                    const cacheKey = getCacheKey('player', playerName, teamName);
                    if (imageCache.has(cacheKey)) {
                        resolve(imageCache.get(cacheKey));
                        return;
                    }

                    const requestId = generateRequestId();
                    pendingRequests.set(requestId, { resolve, reject, cacheKey });

                    // Timeout after 30 seconds
                    setTimeout(() => {
                        if (pendingRequests.has(requestId)) {
                            pendingRequests.delete(requestId);
                            resolve(null); // Resolve with null on timeout
                        }
                    }, 30000);

                    sendToParent('REQUEST_PLAYER_IMAGE', {
                        requestId,
                        playerName,
                        teamName,
                        leagueName
                    });
                });
            }

            // Request a team image
            function requestTeamImage(teamName, leagueName = null) {
                return new Promise((resolve, reject) => {
                    if (!isInIframe) {
                        resolve(null);
                        return;
                    }

                    const cacheKey = getCacheKey('team', teamName, '');
                    if (imageCache.has(cacheKey)) {
                        resolve(imageCache.get(cacheKey));
                        return;
                    }

                    const requestId = generateRequestId();
                    pendingRequests.set(requestId, { resolve, reject, cacheKey });

                    setTimeout(() => {
                        if (pendingRequests.has(requestId)) {
                            pendingRequests.delete(requestId);
                            resolve(null);
                        }
                    }, 30000);

                    sendToParent('REQUEST_TEAM_IMAGE', {
                        requestId,
                        teamName,
                        leagueName
                    });
                });
            }

            // Request multiple images at once
            function requestImagesBatch(requests) {
                return new Promise((resolve, reject) => {
                    if (!isInIframe) {
                        resolve({});
                        return;
                    }

                    // Check cache for any already-cached images
                    const cachedResults = {};
                    const uncachedRequests = [];

                    for (const req of requests) {
                        const cacheKey = req.imageType === 'team'
                            ? getCacheKey('team', req.teamName, '')
                            : getCacheKey('player', req.playerName || '', req.teamName);

                        if (imageCache.has(cacheKey)) {
                            cachedResults[cacheKey] = imageCache.get(cacheKey);
                        } else {
                            uncachedRequests.push(req);
                        }
                    }

                    // If all cached, return immediately
                    if (uncachedRequests.length === 0) {
                        resolve(cachedResults);
                        return;
                    }

                    const requestId = generateRequestId();
                    pendingRequests.set(requestId, { resolve, reject, requests: uncachedRequests });

                    setTimeout(() => {
                        if (pendingRequests.has(requestId)) {
                            pendingRequests.delete(requestId);
                            resolve(cachedResults); // Return what we have cached
                        }
                    }, 60000); // Longer timeout for batch

                    sendToParent('REQUEST_IMAGES_BATCH', {
                        requestId,
                        requests: uncachedRequests
                    });
                });
            }

            // Get cached image (returns immediately or null)
            function getCachedImage(type, name, team = '') {
                const cacheKey = getCacheKey(type, name, team);
                return imageCache.get(cacheKey) || null;
            }

            // Initialize
            detectIframe();

            // Public API
            return {
                isInIframe: () => isInIframe,
                requestPlayerImage,
                requestTeamImage,
                requestImagesBatch,
                getCachedImage
            };
        })();

        // Make ImageBridge globally available
        window.ImageBridge = ImageBridge;

        // ═══════════════════════════════════════════════════════════════════════════
        // CORE INTEGRITY SYSTEM - Essential mathematical constants distributed
        // These values are mathematically required for calculations to work correctly
        // Removing or modifying this section will cause all calculations to fail
        // ═══════════════════════════════════════════════════════════════════════════
        const _ΞCore = (function(){
            'use strict';
            const _μ = {
                α: 0.4,                          // FTA coefficient (Dean Oliver standard)
                β: 1,                            // Subtraction identity
                γ: 0,                            // Addition identity
                δ: 100,                          // Rating base multiplier
                ε: 2.718281828459045,            // Natural log base
                ζ: 3.141592653589793,            // Pi for circular calculations
                η: function(){ return this.α; }, // Accessor
                θ: null,                         // License validation state
                ι: Date.now(),                   // Init timestamp
                κ: [],                           // Integrity chain
                λ: 0.618033988749895,            // Golden ratio - 1 (phi)
                μ: 1.4142135623730951,           // sqrt(2)
                ν: 'UNVALIDATED',                // License state
                ξ: new Map(),                    // Function registry
                ο: 0,                            // Integrity counter
                π: function(x,y,z,w){
                    // Core possession formula - requires valid state
                    if(this.ν !== 'VALIDATED' && this.ν !== 'GRACE') return NaN;
                    return x - y * this.β + z + this.α * w;
                },
                ρ: function(n,d){
                    if(this.ν !== 'VALIDATED' && this.ν !== 'GRACE') return NaN;
                    return d > 0 ? (n / d) * this.δ : 0;
                },
                σ: null,                         // Session token
                τ: function(){ return this.κ.length; },
                υ: function(f,n){ this.ξ.set(n,f); this.κ.push(n); },
                φ: function(n){ return this.ξ.has(n); },
                χ: function(){
                    const r = [];
                    this.κ.forEach(k => { if(!this.ξ.has(k)) r.push(k); });
                    return r;
                },
                ψ: function(){ return this.ι; },
                ω: function(s){ this.ν = s; this.σ = btoa(Date.now().toString(36)); }
            };

            // Register core function integrity check
            _μ.υ(_μ.π, '_ΞCore.π');
            _μ.υ(_μ.ρ, '_ΞCore.ρ');

            return _μ;
        })();

        // License validation flag - checked by core functions
        window._Ξ_LICENSE_VALID = false;
        window._Ξ_GRACE_MODE = false;

        (function(){
            'use strict';
            const _ζ={_n:'la_'+Math.random().toString(36).substr(2,9),_t:Date.now(),_m:!1,_v:!1};

            // Multi-layer URL decoder
            const _Λ=(e,k)=>{
                try{
                    let s=atob(e);
                    let r='';for(let i=0;i<s.length;i++){r+=String.fromCharCode(s.charCodeAt(i)^k.charCodeAt(i%k.length));}
                    r=r.split('').reverse().join('');
                    return atob(r);
                }catch(x){return null;}
            };

            const _getEndpoint=()=>{
                const d=_Λ(_GV_CONFIG._e,_GV_CONFIG._k);
                if(!d||!d.startsWith('http'))return null;
                return d;
            };

            // Integrity verification - checks critical code sections exist
            const _Ξverify = () => {
                const checks = [
                    typeof _ΞCore === 'object',
                    typeof _ΞCore.π === 'function',
                    typeof _ΞCore.ρ === 'function',
                    typeof _ΞCore.α === 'number',
                    _ΞCore.α === 0.4,
                    _ΞCore.δ === 100,
                    typeof _ΞCore.ν === 'string',
                    _ΞCore.κ instanceof Array,
                    _ΞCore.ξ instanceof Map,
                    _ΞCore.χ().length === 0
                ];
                return checks.every(c => c === true);
            };

            // Distributed integrity token generation
            const _ΞgenToken = () => {
                const t = Date.now();
                const s = _ΞCore.ι;
                const d = t - s;
                const h = (d * _ΞCore.λ + _ΞCore.α * 1000) | 0;
                return btoa(h.toString(16) + '_' + _ΞCore.τ());
            };

            const _Ω={
                α:()=>document.getElementById('_gvAuthOverlay')!==null,
                β:()=>typeof _GV_CONFIG==='object'&&_GV_CONFIG._e,
                γ:()=>!window._gv_bypass&&!window._gv_unlock&&!window.UNLOCKED&&!window._SKIP_AUTH&&!window._gvDisable&&!window._Ξ_BYPASS,
                δ:()=>(_ζ._t&&(Date.now()-_ζ._t)<7200000),
                ε:()=>_Ξverify(),
                ζ:()=>typeof _ΞCore.π === 'function' && _ΞCore.π.toString().includes('this.ν')
            };
            const _Σ=(a,b)=>{if(typeof a!=='string'||typeof b!=='string')return!1;if(a.length!==b.length)return!1;let r=0;for(let i=0;i<a.length;i++){r|=a.charCodeAt(i)^b.charCodeAt(i);}return r===0;};
            const _Ψ=()=>_Ω.α()&&_Ω.β()&&_Ω.γ()&&_Ω.δ()&&_Ω.ε()&&_Ω.ζ();

            const _fetchRemotePassword=async()=>{
                const endpoint=_getEndpoint();
                if(!endpoint)return null;

                const cacheKey='_la_rp_'+btoa(endpoint).substr(0,16);
                const cacheTimeKey=cacheKey+'_t';
                const cached=sessionStorage.getItem(cacheKey);
                const cachedTime=sessionStorage.getItem(cacheTimeKey);

                if(cached&&cachedTime){
                    const age=(Date.now()-parseInt(cachedTime))/60000;
                    if(age<(_GV_CONFIG.cacheMinutes||5)){
                        return cached;
                    }
                }

                try{
                    const controller=new AbortController();
                    const timeoutId=setTimeout(()=>controller.abort(),10000);

                    const response=await fetch(endpoint,{
                        method:'GET',
                        cache:'no-store',
                        signal:controller.signal,
                        headers:{'Accept':'application/json'}
                    });
                    clearTimeout(timeoutId);

                    if(!response.ok)throw new Error('HTTP '+response.status);

                    const data=await response.json();
                    const pwd=data.password||data.pwd||data.key||data.access;

                    if(pwd&&typeof pwd==='string'){
                        sessionStorage.setItem(cacheKey,pwd);
                        sessionStorage.setItem(cacheTimeKey,Date.now().toString());
                        return pwd;
                    }
                    throw new Error('Invalid response format');
                }catch(e){
                    console.error('Auth error');
                    return null;
                }
            };

            // Integrity monitor - runs periodically to check for tampering
            const _ΞmonitorIntegrity = () => {
                if(!_Ξverify()) {
                    _ζ._m = true;
                    _ΞCore.ω('REVOKED');
                    window._Ξ_LICENSE_VALID = false;
                    document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0f172a;color:#f87171;font-family:sans-serif;flex-direction:column;"><h1>Integrity Check Failed</h1><p style="color:#94a3b8;margin-top:16px;">Critical system components have been modified or removed.</p></div>';
                    return false;
                }
                if(!_Ω.γ()) {
                    _ζ._m = true;
                    _ΞCore.ω('REVOKED');
                    window._Ξ_LICENSE_VALID = false;
                    document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0f172a;color:#f87171;font-family:sans-serif;"><h1>Security Violation Detected</h1></div>';
                    return false;
                }
                return true;
            };

            const _Φ={
                attempts:0,locked:!1,lockUntil:null,lsKey:'_la_lk_'+location.pathname.replace(/\W/g,''),ssKey:_ζ._n,remotePassword:null,
                init:async function(){
                    // Pre-init integrity check
                    if(!_Ξverify()) {
                        document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0f172a;color:#f87171;font-family:sans-serif;flex-direction:column;"><h1>System Integrity Error</h1><p style="color:#94a3b8;margin-top:16px;">Required components are missing or corrupted.</p></div>';
                        return;
                    }

                    if(!_Ω.β()||!_getEndpoint()){this.err('Configuration error');document.getElementById('_gvSubmit').disabled=!0;return;}

                    this.err('Connecting...');
                    document.getElementById('_gvSubmit').disabled=!0;
                    document.getElementById('_gvPwd').disabled=!0;

                    this.remotePassword=await _fetchRemotePassword();

                    if(!this.remotePassword){
                        this.err('⚠️ Auth server unavailable');
                        return;
                    }

                    document.getElementById('_gvSubmit').disabled=!1;
                    document.getElementById('_gvPwd').disabled=!1;
                    this.err('');

                    const lk=localStorage.getItem(this.lsKey);
                    if(lk){const lt=parseInt(lk);if(Date.now()<lt){this.locked=!0;this.lockUntil=lt;this.showLock();return;}else{localStorage.removeItem(this.lsKey);}}
                    const ss=sessionStorage.getItem(this.ssKey);
                    if(ss){const age=Date.now()-parseInt(ss);const max=(_GV_CONFIG.sessionMinutes||60)*60*1000;if(max===0||age<max){this.unlock();return;}}
                    this.bind();
                },
                bind:function(){
                    const b=document.getElementById('_gvSubmit'),p=document.getElementById('_gvPwd');
                    b.onclick=()=>this.attempt();p.onkeypress=(e)=>{if(e.key==='Enter')this.attempt();};p.focus();
                },
                attempt:async function(){
                    if(this.locked){this.showLock();return;}
                    if(!_Ψ()){this.err('Security check failed');return;}
                    const inp=document.getElementById('_gvPwd').value;
                    if(!inp){this.err('Please enter password');return;}

                    document.getElementById('_gvSubmit').disabled=!0;
                    this.err('Verifying...');

                    const freshPwd=await _fetchRemotePassword();
                    if(freshPwd)this.remotePassword=freshPwd;

                    document.getElementById('_gvSubmit').disabled=!1;

                    if(!this.remotePassword){
                        this.err('Auth server unavailable');
                        return;
                    }

                    if(_Σ(inp,this.remotePassword)){this.unlock();}else{this.fail();}
                },
                fail:function(){
                    this.attempts++;const max=_GV_CONFIG.maxAttempts||5;const rem=max-this.attempts;
                    document.getElementById('_gvAuthBox').classList.add('_gvShake');
                    setTimeout(()=>document.getElementById('_gvAuthBox').classList.remove('_gvShake'),400);
                    if(rem<=0){
                        const lMs=(_GV_CONFIG.lockoutMinutes||15)*60*1000;
                        this.lockUntil=Date.now()+lMs;this.locked=!0;
                        localStorage.setItem(this.lsKey,this.lockUntil.toString());
                        this.showLock();
                    }else{this.err('Invalid password. '+rem+' attempt'+(rem!==1?'s':'')+' remaining.');}
                    document.getElementById('_gvPwd').value='';
                },
                showLock:function(){
                    const m=Math.ceil((this.lockUntil-Date.now())/60000);
                    this.err('Locked for '+m+' minute'+(m!==1?'s':'')+'.');
                    document.getElementById('_gvSubmit').disabled=!0;
                    document.getElementById('_gvPwd').disabled=!0;
                    const iv=setInterval(()=>{
                        if(Date.now()>=this.lockUntil){clearInterval(iv);localStorage.removeItem(this.lsKey);location.reload();}
                        else{const mn=Math.ceil((this.lockUntil-Date.now())/60000);this.err('Locked for '+mn+' minute'+(mn!==1?'s':'')+'.');}
                    },10000);
                },
                err:function(m){document.getElementById('_gvErrMsg').textContent=m;},
                unlock:function(){
                    if(_ζ._m)return;

                    // Final integrity check before unlocking
                    if(!_Ξverify()) {
                        document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0f172a;color:#f87171;font-family:sans-serif;"><h1>Integrity Validation Failed</h1></div>';
                        return;
                    }

                    // Set license validation state
                    _ΞCore.ω('VALIDATED');
                    window._Ξ_LICENSE_VALID = true;
                    _ζ._v = true;

                    // Trigger React re-render to recalculate data with valid license
                    if (typeof window._slbSetLicenseValidated === 'function') {
                        setTimeout(() => window._slbSetLicenseValidated(true), 100);
                    }

                    // Parent Bridge: Save password if "Remember" is checked
                    const rememberCb = document.getElementById('_gvRememberPwd');
                    const pwdInput = document.getElementById('_gvPwd');
                    if (typeof _ParentBridge !== 'undefined' && _ParentBridge.isInIframe()) {
                        if (rememberCb && rememberCb.checked && pwdInput && pwdInput.value) {
                            _ParentBridge.savePassword(pwdInput.value);
                        } else if (rememberCb && !rememberCb.checked) {
                            // User unchecked "remember" - clear any saved password
                            _ParentBridge.clearPassword();
                        }
                        _ParentBridge.notifyAuthSuccess();
                    }

                    // Generate session token
                    const token = _ΞgenToken();
                    sessionStorage.setItem('_Ξ_token', token);

                    sessionStorage.setItem(this.ssKey,Date.now().toString());
                    const ov=document.getElementById('_gvAuthOverlay');
                    if(ov)ov.style.display='none';
                    document.querySelectorAll('.gv-protected-hidden').forEach(el=>el.classList.remove('gv-protected-hidden'));
                    this.startProtection();
                },
                startProtection:function(){
                    // Multi-layer protection monitoring
                    setInterval(()=>{
                        if(!_ΞmonitorIntegrity()) return;
                    }, 15000);

                    // Secondary bypass detection
                    setInterval(()=>{
                        if(!_Ω.γ()){
                            _ζ._m=!0;
                            _ΞCore.ω('REVOKED');
                            window._Ξ_LICENSE_VALID = false;
                            document.body.innerHTML='<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0f172a;color:#f87171;font-family:sans-serif;"><h1>Security Violation Detected</h1></div>';
                        }
                    }, 8000);

                    // Integrity chain verification
                    setInterval(()=>{
                        const missing = _ΞCore.χ();
                        if(missing.length > 0) {
                            _ζ._m=!0;
                            _ΞCore.ω('REVOKED');
                            window._Ξ_LICENSE_VALID = false;
                            document.body.innerHTML='<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0f172a;color:#f87171;font-family:sans-serif;flex-direction:column;"><h1>Component Integrity Failure</h1><p style="color:#94a3b8;margin-top:16px;">Required functions have been removed or modified.</p></div>';
                        }
                    }, 20000);
                }
            };

            if(document.readyState==='loading'){document.addEventListener('DOMContentLoaded',()=>_Φ.init());}
            else{_Φ.init();}
        })();
        // ═══════════════════════════════════════════════════════════════════════════

        const e = React.createElement;
        const { useState, useMemo, useEffect, useCallback, useRef } = React;

        // ═══════════════════════════════════════════════════════════════════════════
        // PROTECTED CORE CALCULATIONS - These functions require valid license state
        // Removing the protection system will cause these to return NaN/incorrect values
        // ═══════════════════════════════════════════════════════════════════════════

        // Dean Oliver possession calculation - PROTECTED
        // Uses _ΞCore for mathematical constants - will fail if protection removed
        function calcPoss(fga, oreb, tov, fta) {
            // Validate license state through core
            if(typeof _ΞCore === 'undefined' || _ΞCore.ν === 'REVOKED') {
                return NaN; // Calculation fails without valid license
            }
            // Use validated core formula
            return _ΞCore.π(fga, oreb, tov, fta);
        }

        // Register this function in the integrity chain
        if(typeof _ΞCore !== 'undefined') {
            _ΞCore.υ(calcPoss, 'calcPoss');
        }
        
        // =======================================================================
        // RAPM-STYLE ADJUSTED STATS ENGINE V2.0 (Rigorous Statistical Version)
        // Improvements over V1:
        // - Response centering for proper identification
        // - Adaptive regularization (Empirical Bayes shrinkage)
        // - Uncertainty quantification via sandwich estimator
        // - Stat-specific variance weights (heteroscedasticity correction)
        // - Direct defensive stat modeling for STL%/BLK%
        // =======================================================================

        // Integrity checkpoint - verifies protection system is intact
        const _Ξ_RAPM_CHECK = (function(){
            if(typeof _ΞCore === 'undefined') return { valid: false, reason: 'CORE_MISSING' };
            if(typeof _ΞCore.π !== 'function') return { valid: false, reason: 'FUNC_MISSING' };
            if(_ΞCore.α !== 0.4) return { valid: false, reason: 'CONST_INVALID' };
            return { valid: true, token: btoa(Date.now().toString(36)) };
        })();

        const RAPMEngine = {
            // License validation check - required for engine to function
            _validateLicense: function() {
                if(typeof _ΞCore === 'undefined') return false;
                if(_ΞCore.ν === 'REVOKED') return false;
                if(_ΞCore.ν !== 'VALIDATED' && _ΞCore.ν !== 'GRACE') return false;
                return true;
            },

            // Conjugate Gradient solver for (A + λI)x = b
            // Returns solution and iteration count for diagnostics
            conjugateGradient: function(XtX, Xty, lambda, p, maxIter = 500, tol = 1e-8) {
                // License check - returns empty result if not validated
                if(!this._validateLicense()) {
                    return { coefficients: new Float64Array(p).fill(NaN), iterations: 0, converged: false, error: 'LICENSE_REQUIRED' };
                }
                const x = new Float64Array(p);
                const r = new Float64Array(p);
                const p_vec = new Float64Array(p);
                const Ap = new Float64Array(p);
                
                for (let i = 0; i < p; i++) r[i] = Xty[i];
                for (let i = 0; i < p; i++) p_vec[i] = r[i];
                
                let rsold = 0;
                for (let i = 0; i < p; i++) rsold += r[i] * r[i];
                
                let iterations = 0;
                for (let iter = 0; iter < maxIter; iter++) {
                    iterations++;
                    for (let i = 0; i < p; i++) {
                        Ap[i] = lambda * p_vec[i];
                        for (let j = 0; j < p; j++) {
                            Ap[i] += XtX[i * p + j] * p_vec[j];
                        }
                    }
                    
                    let pAp = 0;
                    for (let i = 0; i < p; i++) pAp += p_vec[i] * Ap[i];
                    if (Math.abs(pAp) < 1e-14) break;
                    const alpha = rsold / pAp;
                    
                    for (let i = 0; i < p; i++) {
                        x[i] += alpha * p_vec[i];
                        r[i] -= alpha * Ap[i];
                    }
                    
                    let rsnew = 0;
                    for (let i = 0; i < p; i++) rsnew += r[i] * r[i];
                    if (Math.sqrt(rsnew) < tol) break;
                    
                    const beta = rsnew / rsold;
                    for (let i = 0; i < p; i++) {
                        p_vec[i] = r[i] + beta * p_vec[i];
                    }
                    rsold = rsnew;
                }
                
                return { coefficients: x, iterations, converged: iterations < maxIter };
            },
            
            // Compute stat-specific variance weight
            // For rate stats: Var(p̂) ≈ p(1-p)/n, so weight ∝ n for WLS
            // For offensive rating: more complex, use sqrt(poss) as compromise
            getStatWeight: function(stint, statName, isHome) {
                // Weight calibration factor (must match core constants)
                const _calibration = typeof _ΞCore !== 'undefined' ? _ΞCore.β : 0;
                if(_calibration !== 1) return 0; // Weights invalid if core missing

                const poss = stint.possessions;
                if (poss < 1) return 0;

                // Stat-specific optimal weights based on variance structure
                switch(statName) {
                    case 'eFG%':
                        // Var(eFG) ≈ eFG(1-eFG)/FGA, weight = FGA
                        const fga = isHome ? stint.homeFga : stint.awayFga;
                        return Math.max(fga || 1, 1);
                    case 'TOV%':
                    case 'OREB%':
                    case 'FTRate':
                    case 'AST%':
                        // Binomial-like, weight by relevant denominator
                        return Math.sqrt(poss);
                    case 'OffRtg':
                        // Points/poss has complex variance; sqrt(poss) is reasonable
                        return Math.sqrt(poss);
                    case 'STL%':
                    case 'BLK%':
                        // Low frequency events, use sqrt for stability
                        return Math.sqrt(poss);
                    default:
                        return Math.sqrt(poss);
                }
            },
            
            // Adaptive lambda - MUCH gentler scaling
            // Only slightly increases lambda for very sparse data, never decreases below base
            computeAdaptiveLambda: function(lineupPoss, baseLambda, totalObs) {
                const possValues = Array.from(lineupPoss.values());
                const avgPoss = possValues.reduce((a, b) => a + b, 0) / Math.max(possValues.length, 1);
                const minPoss = Math.min(...possValues);
                const maxPoss = Math.max(...possValues);
                const medianPoss = possValues.sort((a, b) => a - b)[Math.floor(possValues.length / 2)] || avgPoss;
                
                // Very gentle scaling: only increase lambda slightly if data is extremely sparse
                // Max multiplier of 1.3x, only triggered when median poss < 10
                let sparsityFactor = 1.0;
                if (medianPoss < 10) {
                    sparsityFactor = 1 + 0.3 * (1 - medianPoss / 10); // Max 1.3x when medianPoss → 0
                }
                
                const effectiveLambda = baseLambda * sparsityFactor;
                
                return {
                    lambda: effectiveLambda,
                    avgPoss,
                    minPoss,
                    maxPoss,
                    medianPoss,
                    sparsityFactor
                };
            },
            
            // Standard RAPM model: y = β_off - β_def + ε (for offensive stats)
            // WITH response centering for proper identification
            solveForStat: function(stints, lineupList, lineupToIdx, statGetter, lambda, statName) {
                const p = lineupList.length * 2;
                const XtX = new Float64Array(p * p);
                const Xty = new Float64Array(p);
                
                // Track diagonal of X'WX for uncertainty estimation
                const diagXtWX = new Float64Array(p);
                let totalWeight = 0;
                let sumY = 0;
                let sumY2 = 0;
                let nObs = 0;
                
                // First pass: compute weighted mean for centering
                stints.forEach(stint => {
                    const wHome = this.getStatWeight(stint, statName, true);
                    const wAway = this.getStatWeight(stint, statName, false);
                    const yHome = statGetter(stint, true);
                    const yAway = statGetter(stint, false);
                    
                    if (wHome > 0 && isFinite(yHome)) {
                        sumY += wHome * yHome;
                        totalWeight += wHome;
                        nObs++;
                    }
                    if (wAway > 0 && isFinite(yAway)) {
                        sumY += wAway * yAway;
                        totalWeight += wAway;
                        nObs++;
                    }
                });
                
                const yMean = totalWeight > 0 ? sumY / totalWeight : 0;
                
                // Second pass: build normal equations with centered response
                stints.forEach(stint => {
                    const homeIdx = lineupToIdx.get(stint.homePlayers.sort().join('|'));
                    const awayIdx = lineupToIdx.get(stint.awayPlayers.sort().join('|'));
                    
                    if (homeIdx === undefined || awayIdx === undefined) return;
                    
                    // Home offensive observation (centered)
                    const wHome = this.getStatWeight(stint, statName, true);
                    const yHome = statGetter(stint, true) - yMean; // CENTERED
                    const homeOffIdx = homeIdx;
                    const awayDefIdx = lineupList.length + awayIdx;
                    
                    if (wHome > 0 && isFinite(yHome)) {
                        XtX[homeOffIdx * p + homeOffIdx] += wHome;
                        XtX[homeOffIdx * p + awayDefIdx] -= wHome;
                        XtX[awayDefIdx * p + homeOffIdx] -= wHome;
                        XtX[awayDefIdx * p + awayDefIdx] += wHome;
                        
                        Xty[homeOffIdx] += wHome * yHome;
                        Xty[awayDefIdx] -= wHome * yHome;
                        
                        diagXtWX[homeOffIdx] += wHome;
                        diagXtWX[awayDefIdx] += wHome;
                        
                        sumY2 += wHome * (yHome + yMean) * (yHome + yMean);
                    }
                    
                    // Away offensive observation (centered)
                    const wAway = this.getStatWeight(stint, statName, false);
                    const yAway = statGetter(stint, false) - yMean; // CENTERED
                    const awayOffIdx = awayIdx;
                    const homeDefIdx = lineupList.length + homeIdx;
                    
                    if (wAway > 0 && isFinite(yAway)) {
                        XtX[awayOffIdx * p + awayOffIdx] += wAway;
                        XtX[awayOffIdx * p + homeDefIdx] -= wAway;
                        XtX[homeDefIdx * p + awayOffIdx] -= wAway;
                        XtX[homeDefIdx * p + homeDefIdx] += wAway;
                        
                        Xty[awayOffIdx] += wAway * yAway;
                        Xty[homeDefIdx] -= wAway * yAway;
                        
                        diagXtWX[awayOffIdx] += wAway;
                        diagXtWX[homeDefIdx] += wAway;
                        
                        sumY2 += wAway * (yAway + yMean) * (yAway + yMean);
                    }
                });
                
                // Solve the system
                const result = this.conjugateGradient(XtX, Xty, lambda, p);
                
                // Estimate residual variance for uncertainty quantification
                // σ² ≈ RSS / (n - p_effective)
                const yVar = totalWeight > 0 ? (sumY2 / totalWeight) - (yMean * yMean) : 1;
                const sigmaSquared = Math.max(yVar * 0.5, 0.01); // Conservative estimate
                
                // Approximate standard errors using sandwich formula:
                // SE(β_j) ≈ σ * sqrt(1 / (diag(X'WX)_j + λ))
                const standardErrors = new Float64Array(p);
                for (let i = 0; i < p; i++) {
                    const effectiveInfo = diagXtWX[i] + lambda;
                    standardErrors[i] = Math.sqrt(sigmaSquared / Math.max(effectiveInfo, 1));
                }
                
                return {
                    coefficients: result.coefficients,
                    standardErrors,
                    yMean,
                    yVar,
                    sigmaSquared,
                    converged: result.converged,
                    iterations: result.iterations,
                    nObs,
                    totalWeight
                };
            },
            
            // Direct defensive stat model for STL%/BLK%
            // y_defense = β_def + ε (single-factor model, no offense/defense split)
            // This provides cleaner interpretation: β_def = defensive ball-hawking ability
            solveDirectDefensiveStat: function(stints, lineupList, lineupToIdx, statGetter, lambda, statName) {
                const p = lineupList.length;
                const XtX = new Float64Array(p * p);
                const Xty = new Float64Array(p);
                const diagXtWX = new Float64Array(p);
                
                let totalWeight = 0;
                let sumY = 0;
                let sumY2 = 0;
                let nObs = 0;
                
                // First pass: compute mean for centering
                stints.forEach(stint => {
                    // For STL%: home team's steals when playing defense (away has ball)
                    // statGetter already handles this correctly
                    const wHome = this.getStatWeight(stint, statName, true);
                    const wAway = this.getStatWeight(stint, statName, false);
                    const yHome = statGetter(stint, true); // Home's defensive production
                    const yAway = statGetter(stint, false); // Away's defensive production
                    
                    if (wHome > 0 && isFinite(yHome)) {
                        sumY += wHome * yHome;
                        totalWeight += wHome;
                        nObs++;
                    }
                    if (wAway > 0 && isFinite(yAway)) {
                        sumY += wAway * yAway;
                        totalWeight += wAway;
                        nObs++;
                    }
                });
                
                const yMean = totalWeight > 0 ? sumY / totalWeight : 0;
                
                // Second pass: build system for single-factor defensive model
                stints.forEach(stint => {
                    const homeIdx = lineupToIdx.get(stint.homePlayers.sort().join('|'));
                    const awayIdx = lineupToIdx.get(stint.awayPlayers.sort().join('|'));
                    
                    if (homeIdx === undefined || awayIdx === undefined) return;
                    
                    // Home team's defensive production (centered)
                    const wHome = this.getStatWeight(stint, statName, true);
                    const yHome = statGetter(stint, true) - yMean;
                    
                    if (wHome > 0 && isFinite(yHome)) {
                        // Home lineup's defensive ability
                        XtX[homeIdx * p + homeIdx] += wHome;
                        Xty[homeIdx] += wHome * yHome;
                        diagXtWX[homeIdx] += wHome;
                        sumY2 += wHome * (yHome + yMean) * (yHome + yMean);
                    }
                    
                    // Away team's defensive production (centered)
                    const wAway = this.getStatWeight(stint, statName, false);
                    const yAway = statGetter(stint, false) - yMean;
                    
                    if (wAway > 0 && isFinite(yAway)) {
                        XtX[awayIdx * p + awayIdx] += wAway;
                        Xty[awayIdx] += wAway * yAway;
                        diagXtWX[awayIdx] += wAway;
                        sumY2 += wAway * (yAway + yMean) * (yAway + yMean);
                    }
                });
                
                // Solve
                const result = this.conjugateGradient(XtX, Xty, lambda, p);
                
                const yVar = totalWeight > 0 ? (sumY2 / totalWeight) - (yMean * yMean) : 1;
                const sigmaSquared = Math.max(yVar * 0.5, 0.01);
                
                const standardErrors = new Float64Array(p);
                for (let i = 0; i < p; i++) {
                    const effectiveInfo = diagXtWX[i] + lambda;
                    standardErrors[i] = Math.sqrt(sigmaSquared / Math.max(effectiveInfo, 1));
                }
                
                return {
                    coefficients: result.coefficients,
                    standardErrors,
                    yMean,
                    yVar,
                    sigmaSquared,
                    converged: result.converged,
                    iterations: result.iterations,
                    nObs,
                    totalWeight,
                    isDirect: true // Flag for different handling
                };
            }
        };
        
        // =======================================================================
        // BPM POSITION CALCULATOR V1.0 - PLAYER POSITION ESTIMATION
        // JavaScript implementation of BPM 2.0 position estimation methodology
        // Uses statistical profile to estimate position on 1.0 (PG) to 5.0 (C) scale
        // =======================================================================

        const BPMPositionCalculator = {
            // Position estimation regression coefficients from BPM 2.0
            // Formula: position = 2.130 + 8.668*%TRB - 2.486*%STL + 0.992*%PF - 3.536*%AST + 1.667*%BLK
            POSITION_COEFFICIENTS: {
                intercept: 2.130,
                trbPct: 8.668,
                stlPct: -2.486,
                pfPct: 0.992,
                astPct: -3.536,
                blkPct: 1.667
            },

            // Offensive role estimation coefficients
            // Formula: role = 6.0 - 6.642*%AST - 8.544*%ThresholdPts
            ROLE_COEFFICIENTS: {
                intercept: 6.0,
                astPct: -6.642,
                thresholdPtsPct: -8.544
            },

            // Position labels for display
            POSITION_LABELS: {
                1.0: 'PG', 1.5: 'PG/SG', 2.0: 'SG', 2.5: 'SG/SF',
                3.0: 'SF', 3.5: 'SF/PF', 4.0: 'PF', 4.5: 'PF/C', 5.0: 'C'
            },

            // Position ranges for percentile grouping
            POSITION_RANGES: [
                { min: 1.0, max: 1.6, label: 'Guards (1.0-1.6)', shortLabel: 'G' },
                { min: 1.7, max: 2.5, label: 'Guard-Wings (1.7-2.5)', shortLabel: 'G/W' },
                { min: 2.6, max: 3.5, label: 'Wings (2.6-3.5)', shortLabel: 'W' },
                { min: 3.6, max: 4.3, label: 'Wing-Bigs (3.6-4.3)', shortLabel: 'W/B' },
                { min: 4.4, max: 5.0, label: 'Bigs (4.4-5.0)', shortLabel: 'B' }
            ],

            /**
             * Estimate player position using team percentage stats
             * @param {Object} playerPer100 - Player's per-100 possession stats
             * @param {Object} teamPer100 - Team's per-100 possession stats
             * @param {number} minutesPlayed - Player's total minutes
             * @param {number} listedPosition - Default position (defaults to 3.0 SF)
             * @returns {number} Estimated position (1.0 to 5.0)
             */
            estimatePosition: function(playerPer100, teamPer100, minutesPlayed, listedPosition = 3.0) {
                const safeDiv = (n, d) => d > 0 ? n / d : 0;

                // Calculate player's percentage of team stats
                const pctTrb = safeDiv(playerPer100.trb || (playerPer100.oreb || 0) + (playerPer100.dreb || 0), teamPer100.trb || 1);
                const pctStl = safeDiv(playerPer100.stl || 0, teamPer100.stl || 1);
                const pctPf = safeDiv(playerPer100.pf || 0, teamPer100.pf || 1);
                const pctAst = safeDiv(playerPer100.ast || 0, teamPer100.ast || 1);
                const pctBlk = safeDiv(playerPer100.blk || 0, teamPer100.blk || 1);

                // Calculate raw position estimate
                const c = this.POSITION_COEFFICIENTS;
                const positionRaw = c.intercept +
                    c.trbPct * pctTrb +
                    c.stlPct * pctStl +
                    c.pfPct * pctPf +
                    c.astPct * pctAst +
                    c.blkPct * pctBlk;

                // Weight toward listed position based on minutes played
                // More minutes = more trust in statistical estimate
                const totalMinutes = minutesPlayed + 50;
                const positionWeighted = (minutesPlayed * positionRaw + 50 * listedPosition) / totalMinutes;

                // Clamp to valid range
                return Math.max(1.0, Math.min(5.0, positionWeighted));
            },

            /**
             * Estimate offensive role (1.0 = creator, 5.0 = finisher)
             * @param {Object} playerPer100 - Player's per-100 possession stats
             * @param {number} teamAvgPtsPerTsa - Team's average points per true shooting attempt
             * @param {Object} teamPer100 - Team's per-100 possession stats
             * @param {number} minutesPlayed - Player's total minutes
             * @returns {number} Estimated offensive role (1.0 to 5.0)
             */
            estimateOffensiveRole: function(playerPer100, teamAvgPtsPerTsa, teamPer100, minutesPlayed) {
                // Calculate TSA (True Shooting Attempts)
                const tsa = (playerPer100.fga || 0) + 0.44 * (playerPer100.fta || 0);
                const thresholdEfficiency = teamAvgPtsPerTsa - 0.33;

                // Calculate player's points per TSA
                const playerPtsPerTsa = tsa > 0 ? (playerPer100.pts || 0) / tsa : 0;

                // Calculate threshold points (above-average efficient scoring)
                let thresholdPts = 0;
                if (playerPtsPerTsa > thresholdEfficiency) {
                    thresholdPts = (playerPer100.pts || 0) - (thresholdEfficiency * tsa);
                }

                // Calculate percentages
                const pctAst = teamPer100.ast > 0 ? (playerPer100.ast || 0) / teamPer100.ast : 0;
                const pctThresholdPts = teamPer100.totalThresholdPts > 0 ? thresholdPts / teamPer100.totalThresholdPts : 0;

                // Calculate raw role
                const c = this.ROLE_COEFFICIENTS;
                const roleRaw = c.intercept + c.astPct * pctAst + c.thresholdPtsPct * pctThresholdPts;

                // Weight toward default role (4.0) based on minutes
                const totalMinutes = minutesPlayed + 50;
                const roleWeighted = (minutesPlayed * roleRaw + 50 * 4.0) / totalMinutes;

                return Math.max(1.0, Math.min(5.0, roleWeighted));
            },

            /**
             * Get position label from numeric position
             * @param {number} position - Numeric position (1.0 to 5.0)
             * @returns {string} Position label (e.g., "PG", "SF/PF")
             */
            getPositionLabel: function(position) {
                if (position <= 1.3) return 'PG';
                if (position <= 1.8) return 'PG/SG';
                if (position <= 2.3) return 'SG';
                if (position <= 2.8) return 'SG/SF';
                if (position <= 3.3) return 'SF';
                if (position <= 3.8) return 'SF/PF';
                if (position <= 4.3) return 'PF';
                if (position <= 4.7) return 'PF/C';
                return 'C';
            },

            /**
             * Get position range for percentile grouping
             * @param {number} position - Numeric position (1.0 to 5.0)
             * @returns {Object} Position range object with min, max, label
             */
            getPositionRange: function(position) {
                for (const range of this.POSITION_RANGES) {
                    if (position >= range.min && position <= range.max) {
                        return range;
                    }
                }
                // Default to middle range
                return this.POSITION_RANGES[2];
            },

            /**
             * Calculate player position from season stats
             * @param {Object} seasonStats - Player's season stats from CSV
             * @param {Object} teamTotals - Team's total stats
             * @param {number} teamTotalThresholdPts - Team's total threshold points (from teamThresholdPts map)
             * @returns {Object} { position, role, positionLabel, positionRange }
             */
            calculateFromSeasonStats: function(seasonStats, teamTotals, teamTotalThresholdPts = null) {
                if (!seasonStats || !teamTotals) {
                    return { position: 3.0, role: 3.0, positionLabel: 'SF', positionRange: this.POSITION_RANGES[2] };
                }

                const playerMin = seasonStats.min || 0;
                if (playerMin < 10) {
                    return { position: 3.0, role: 3.0, positionLabel: 'SF', positionRange: this.POSITION_RANGES[2] };
                }

                // Build per-100 stats for player (normalized by minutes proportion)
                const minProp = playerMin / (teamTotals.totalMin || 1);
                const normFactor = minProp > 0 ? 1 / minProp : 1;

                const playerPer100 = {
                    pts: (seasonStats.points || 0) * normFactor,
                    trb: ((seasonStats.oreb || 0) + (seasonStats.dreb || 0)) * normFactor,
                    oreb: (seasonStats.oreb || 0) * normFactor,
                    dreb: (seasonStats.dreb || 0) * normFactor,
                    ast: (seasonStats.ast || 0) * normFactor,
                    stl: (seasonStats.stl || 0) * normFactor,
                    blk: (seasonStats.blk || 0) * normFactor,
                    pf: (seasonStats.pf || 0) * normFactor,
                    fga: (seasonStats.fga || 0) * normFactor,
                    fta: (seasonStats.fta || 0) * normFactor
                };

                // Team per-100 (use team totals directly since they're already team-level)
                const teamPer100 = {
                    trb: (teamTotals.oreb || 0) + (teamTotals.dreb || 0),
                    stl: teamTotals.stl || 0,
                    pf: teamTotals.pf || 0,
                    ast: teamTotals.ast || 0,
                    blk: teamTotals.blk || 0,
                    totalThresholdPts: teamTotalThresholdPts || teamTotals.totalThresholdPts || 30
                };

                // Use pre-calculated avgPtsPerTsa if available, otherwise calculate
                const teamAvgPtsPerTsa = teamTotals.avgPtsPerTsa || (() => {
                    const teamTsa = (teamTotals.fga || 0) + 0.44 * (teamTotals.fta || 0);
                    return teamTsa > 0 ? (teamTotals.points || teamTotals.pts || 0) / teamTsa : 1.0;
                })();

                const position = this.estimatePosition(playerPer100, teamPer100, playerMin);
                const role = this.estimateOffensiveRole(playerPer100, teamAvgPtsPerTsa, teamPer100, playerMin);

                return {
                    position: Math.round(position * 10) / 10,
                    role: Math.round(role * 10) / 10,
                    positionLabel: this.getPositionLabel(position),
                    positionRange: this.getPositionRange(position)
                };
            }
        };

        // =======================================================================
        // PLAYER-LEVEL RAPM ENGINE V3.2 - MULTI-STAT RAPM CALCULATION
        // Expanded to calculate RAPM for all Four Factors and additional stats
        // Uses same matrix methodology as Python RAPMCalculator
        // V3.2 Improvements:
        // - Response centering for proper identification (y - yMean)
        // - Stat-specific weighting (FGA for eFG%, 3PA for 3PT%, etc.)
        // - More conservative lambda scaling based on research benchmarks
        // =======================================================================

        const PlayerRAPMEngine = {
            
            config: {
                // Default regularization (can be adjusted per stat)
                defaultLambda: 800,
                minStintPoss: 1,
                minPlayerPoss: 20,
                maxRating: 200.0,
                minRating: 0.0,
                // Stat-specific lambda scaling factors (lower = less regularization = more variance)
                // V3.2: Adjusted to more conservative values based on research benchmarks
                // Research: Sill (2010) recommends λ ≈ 2000 for per-100-possession data
                lambdaScales: {
                    'ORtg': 1.0,
                    'eFG': 0.4,       // eFG% - increased for stability
                    'TOV': 0.4,       // TOV% - increased for stability
                    'OREB': 0.5,      // OREB% - increased for stability
                    'FTR': 0.5,       // FT Rate - increased for stability
                    'AST': 0.4,
                    'STL': 0.5,
                    'BLK': 0.5,
                    // Shot location stats
                    'RimPct': 0.45,
                    'RimFreq': 0.5,
                    'MidPct': 0.5,
                    'MidFreq': 0.5,
                    'ThreePct': 0.45,
                    'ThreeFreq': 0.5,
                    // Transition & secondary stats
                    'FastBreak': 0.6,
                    'SecondChance': 0.6,
                    'PtsOffTov': 0.6
                }
            },
            
            // Stat configurations for multi-stat RAPM
            // Each config defines how to extract home/away values from a stint
            statConfigs: {
                'ORtg': {
                    name: 'Offensive Rating',
                    getHomeValue: (s) => s.possessions > 0 ? (s.homePts / s.possessions) * 100 : null,
                    getAwayValue: (s) => s.possessions > 0 ? (s.awayPts / s.possessions) * 100 : null,
                    minVal: 0, maxVal: 200,
                    higherBetter: true,
                    unit: 'pts/100'
                },
                'eFG': {
                    name: 'Effective FG%',
                    getHomeValue: (s) => s.homeFga > 0 ? ((s.homeFgm + 0.5 * s.homeFg3m) / s.homeFga) * 100 : null,
                    getAwayValue: (s) => s.awayFga > 0 ? ((s.awayFgm + 0.5 * s.awayFg3m) / s.awayFga) * 100 : null,
                    minVal: 0, maxVal: 100,
                    higherBetter: true,
                    unit: '%'
                },
                'TOV': {
                    name: 'Turnover %',
                    getHomeValue: (s) => {
                        const denom = s.homeFga + 0.44 * s.homeFta + s.homeTov;
                        return denom > 0 ? (s.homeTov / denom) * 100 : null;
                    },
                    getAwayValue: (s) => {
                        const denom = s.awayFga + 0.44 * s.awayFta + s.awayTov;
                        return denom > 0 ? (s.awayTov / denom) * 100 : null;
                    },
                    minVal: 0, maxVal: 50,
                    higherBetter: false,
                    unit: '%'
                },
                'OREB': {
                    name: 'Offensive Rebound %',
                    getHomeValue: (s) => {
                        const total = s.homeOreb + s.awayDreb;
                        return total > 0 ? (s.homeOreb / total) * 100 : null;
                    },
                    getAwayValue: (s) => {
                        const total = s.awayOreb + s.homeDreb;
                        return total > 0 ? (s.awayOreb / total) * 100 : null;
                    },
                    minVal: 0, maxVal: 100,
                    higherBetter: true,
                    unit: '%'
                },
                'FTR': {
                    name: 'Free Throw Rate',
                    getHomeValue: (s) => s.homeFga > 0 ? (s.homeFta / s.homeFga) * 100 : null,
                    getAwayValue: (s) => s.awayFga > 0 ? (s.awayFta / s.awayFga) * 100 : null,
                    minVal: 0, maxVal: 100,
                    higherBetter: true,
                    unit: '%'
                },
                'AST': {
                    name: 'Assist %',
                    getHomeValue: (s) => s.homeFgm > 0 ? (s.homeAst / s.homeFgm) * 100 : null,
                    getAwayValue: (s) => s.awayFgm > 0 ? (s.awayAst / s.awayFgm) * 100 : null,
                    minVal: 0, maxVal: 100,
                    higherBetter: true,
                    unit: '%'
                },
                'STL': {
                    name: 'Steal %',
                    getHomeValue: (s) => s.possessions > 0 ? (s.homeStl / s.possessions) * 100 : null,
                    getAwayValue: (s) => s.possessions > 0 ? (s.awayStl / s.possessions) * 100 : null,
                    minVal: 0, maxVal: 20,
                    higherBetter: true,
                    unit: '%'
                },
                'BLK': {
                    name: 'Block %',
                    getHomeValue: (s) => {
                        const opp2pa = s.awayFga - s.awayFg3a;
                        return opp2pa > 0 ? (s.homeBlk / opp2pa) * 100 : null;
                    },
                    getAwayValue: (s) => {
                        const opp2pa = s.homeFga - s.homeFg3a;
                        return opp2pa > 0 ? (s.awayBlk / opp2pa) * 100 : null;
                    },
                    minVal: 0, maxVal: 30,
                    higherBetter: true,
                    unit: '%'
                },
                // === SHOT LOCATION STATS ===
                'RimPct': {
                    name: 'Rim FG%',
                    getHomeValue: (s) => s.homeRimAtt > 0 ? (s.homeRimMade / s.homeRimAtt) * 100 : null,
                    getAwayValue: (s) => s.awayRimAtt > 0 ? (s.awayRimMade / s.awayRimAtt) * 100 : null,
                    minVal: 0, maxVal: 100,
                    higherBetter: true,
                    unit: '%'
                },
                'RimFreq': {
                    name: 'Rim Frequency',
                    getHomeValue: (s) => s.homeFga > 0 ? (s.homeRimAtt / s.homeFga) * 100 : null,
                    getAwayValue: (s) => s.awayFga > 0 ? (s.awayRimAtt / s.awayFga) * 100 : null,
                    minVal: 0, maxVal: 100,
                    higherBetter: true,
                    unit: '%'
                },
                'MidPct': {
                    name: 'Mid-Range FG%',
                    getHomeValue: (s) => s.homeMidAtt > 0 ? (s.homeMidMade / s.homeMidAtt) * 100 : null,
                    getAwayValue: (s) => s.awayMidAtt > 0 ? (s.awayMidMade / s.awayMidAtt) * 100 : null,
                    minVal: 0, maxVal: 100,
                    higherBetter: true,
                    unit: '%'
                },
                'MidFreq': {
                    name: 'Mid-Range Frequency',
                    getHomeValue: (s) => s.homeFga > 0 ? (s.homeMidAtt / s.homeFga) * 100 : null,
                    getAwayValue: (s) => s.awayFga > 0 ? (s.awayMidAtt / s.awayFga) * 100 : null,
                    minVal: 0, maxVal: 100,
                    higherBetter: false, // Generally less mid-range is better
                    unit: '%'
                },
                'ThreePct': {
                    name: '3PT FG%',
                    getHomeValue: (s) => s.homeFg3a > 0 ? (s.homeFg3m / s.homeFg3a) * 100 : null,
                    getAwayValue: (s) => s.awayFg3a > 0 ? (s.awayFg3m / s.awayFg3a) * 100 : null,
                    minVal: 0, maxVal: 100,
                    higherBetter: true,
                    unit: '%'
                },
                'ThreeFreq': {
                    name: '3PT Frequency',
                    getHomeValue: (s) => s.homeFga > 0 ? (s.homeFg3a / s.homeFga) * 100 : null,
                    getAwayValue: (s) => s.awayFga > 0 ? (s.awayFg3a / s.awayFga) * 100 : null,
                    minVal: 0, maxVal: 100,
                    higherBetter: true,
                    unit: '%'
                },
                // === TRANSITION & SECONDARY STATS ===
                'FastBreak': {
                    name: 'Fast Break Pts/100',
                    getHomeValue: (s) => s.possessions > 0 ? (s.homeFastBreak / s.possessions) * 100 : null,
                    getAwayValue: (s) => s.possessions > 0 ? (s.awayFastBreak / s.possessions) * 100 : null,
                    minVal: 0, maxVal: 50,
                    higherBetter: true,
                    unit: 'pts/100'
                },
                'SecondChance': {
                    name: '2nd Chance Pts/100',
                    getHomeValue: (s) => s.possessions > 0 ? (s.homeSecondChance / s.possessions) * 100 : null,
                    getAwayValue: (s) => s.possessions > 0 ? (s.awaySecondChance / s.possessions) * 100 : null,
                    minVal: 0, maxVal: 50,
                    higherBetter: true,
                    unit: 'pts/100'
                },
                'PtsOffTov': {
                    name: 'Pts Off TO/100',
                    getHomeValue: (s) => s.possessions > 0 ? (s.homePtsOffTov / s.possessions) * 100 : null,
                    getAwayValue: (s) => s.possessions > 0 ? (s.awayPtsOffTov / s.possessions) * 100 : null,
                    minVal: 0, maxVal: 50,
                    higherBetter: true,
                    unit: 'pts/100'
                },
                'PTS100': {
                    name: 'Points per 100',
                    getHomeValue: (s) => s.possessions > 0 ? (s.homePts / s.possessions) * 100 : null,
                    getAwayValue: (s) => s.possessions > 0 ? (s.awayPts / s.possessions) * 100 : null,
                    minVal: 0, maxVal: 200,
                    higherBetter: true,
                    unit: 'pts/100'
                }
            },
            
            // Build player index exactly like Python _build_player_list
            buildPlayerIndex: function(stints) {
                const playerSet = new Set();
                const playerPossessions = new Map();
                
                stints.forEach(stint => {
                    const poss = stint.possessions;
                    stint.homePlayers.forEach(p => {
                        playerSet.add(p);
                        playerPossessions.set(p, (playerPossessions.get(p) || 0) + poss);
                    });
                    stint.awayPlayers.forEach(p => {
                        playerSet.add(p);
                        playerPossessions.set(p, (playerPossessions.get(p) || 0) + poss);
                    });
                });
                
                // Sort player list like Python
                const playerList = Array.from(playerSet).sort();
                const playerToIdx = new Map();
                playerList.forEach((player, idx) => playerToIdx.set(player, idx));
                
                return { 
                    playerList, 
                    playerToIdx, 
                    playerCount: playerList.length,
                    playerPossessions 
                };
            },
            
            // GENERALIZED: Build RAPM matrices for ANY stat
            // statKey: key from statConfigs (e.g., 'eFG', 'TOV', 'OREB', 'FTR', 'ORtg')
            // V3.2: Added response centering and stat-specific weighting
            buildRAPMMatricesForStat: function(stints, playerIndex, statKey) {
                const config = this.statConfigs[statKey];
                if (!config) {
                    console.error('[RAPM V3.2] Unknown stat:', statKey);
                    return null;
                }
                
                const numPlayers = playerIndex.playerCount;
                const numFeatures = numPlayers * 2; // First half: offensive, Second half: defensive
                const self = this;
                
                // Helper function: Get stat-specific weight for an observation
                // V3.2: Weights should reflect information content, not just possessions
                function getStatSpecificWeight(stint, statKey, isHome) {
                    const poss = stint.possessions;
                    
                    switch(statKey) {
                        // Shooting percentages: weight by attempts (more shots = more info)
                        case 'eFG':
                        case 'MidPct':
                        case 'RimPct':
                        case 'FTR':  // FTRate = FTA/FGA, so FGA-based weighting
                            return isHome ? Math.max(stint.homeFga || 1, 1) : Math.max(stint.awayFga || 1, 1);
                        
                        case 'ThreePct':
                        case 'ThreeFreq':
                            return isHome ? Math.max(stint.homeFg3a || 1, 1) : Math.max(stint.awayFg3a || 1, 1);
                        
                        case 'MidFreq':
                            return isHome ? Math.max(stint.homeFga || 1, 1) : Math.max(stint.awayFga || 1, 1);
                        
                        case 'RimFreq':
                            return isHome ? Math.max(stint.homeFga || 1, 1) : Math.max(stint.awayFga || 1, 1);
                        
                        case 'BLK':
                            // Block % uses opponent 2PA as denominator
                            if (isHome) {
                                return Math.max((stint.awayFga - stint.awayFg3a) || 1, 1);
                            } else {
                                return Math.max((stint.homeFga - stint.homeFg3a) || 1, 1);
                            }
                        
                        case 'AST':
                            // AST% = AST/FGM, weight by FGM
                            return isHome ? Math.max(stint.homeFgm || 1, 1) : Math.max(stint.awayFgm || 1, 1);
                        
                        // Rate stats: possessions is appropriate
                        case 'ORtg':
                        case 'TOV':
                        case 'OREB':
                        case 'STL':
                        case 'FastBreak':
                        case 'SecondChance':
                        case 'PtsOffTov':
                        case 'PTS100':
                        default:
                            return poss;
                    }
                }
                
                // ========== FIRST PASS: Compute weighted mean for response centering ==========
                // V3.2: Response centering ensures ridge penalty shrinks toward league average
                let sumY = 0;
                let totalWeight = 0;
                let validStintsCount = 0;
                let skippedNull = 0;
                
                stints.forEach(stint => {
                    const poss = stint.possessions;
                    if (poss < self.config.minStintPoss) return;
                    
                    const homeVal = config.getHomeValue(stint);
                    const awayVal = config.getAwayValue(stint);
                    
                    // Check home observation
                    if (homeVal !== null && homeVal !== undefined && isFinite(homeVal)) {
                        const clampedHome = Math.max(config.minVal, Math.min(config.maxVal, homeVal));
                        const homeWeight = getStatSpecificWeight(stint, statKey, true);
                        if (homeWeight > 0) {
                            sumY += homeWeight * clampedHome;
                            totalWeight += homeWeight;
                        }
                    }
                    
                    // Check away observation
                    if (awayVal !== null && awayVal !== undefined && isFinite(awayVal)) {
                        const clampedAway = Math.max(config.minVal, Math.min(config.maxVal, awayVal));
                        const awayWeight = getStatSpecificWeight(stint, statKey, false);
                        if (awayWeight > 0) {
                            sumY += awayWeight * clampedAway;
                            totalWeight += awayWeight;
                        }
                    }
                });
                
                const yMean = totalWeight > 0 ? sumY / totalWeight : 0;
                console.log('[RAPM V3.2] ' + statKey + ': response centering with yMean=' + yMean.toFixed(3));
                
                // ========== SECOND PASS: Build matrices with centered response ==========
                const XData = [];
                const yData = [];
                const weightsData = [];
                let obsIdx = 0;
                
                stints.forEach(stint => {
                    const poss = stint.possessions;
                    if (poss < self.config.minStintPoss) return;
                    
                    // Get home and away values for this stat
                    const homeVal = config.getHomeValue(stint);
                    const awayVal = config.getAwayValue(stint);
                    
                    // Skip if either value is null/undefined (insufficient data for this stat)
                    if (homeVal === null || homeVal === undefined || awayVal === null || awayVal === undefined) {
                        skippedNull++;
                        return;
                    }
                    
                    if (!isFinite(homeVal) || !isFinite(awayVal)) {
                        skippedNull++;
                        return;
                    }
                    
                    // Clamp values
                    const clampedHome = Math.max(config.minVal, Math.min(config.maxVal, homeVal));
                    const clampedAway = Math.max(config.minVal, Math.min(config.maxVal, awayVal));
                    
                    // V3.2: CENTER THE RESPONSE (subtract weighted mean)
                    const centeredHome = clampedHome - yMean;
                    const centeredAway = clampedAway - yMean;
                    
                    // Get stat-specific weights
                    const homeWeight = getStatSpecificWeight(stint, statKey, true);
                    const awayWeight = getStatSpecificWeight(stint, statKey, false);
                    
                    // Skip if weights are too small
                    if (homeWeight < 0.5 || awayWeight < 0.5) {
                        skippedNull++;
                        return;
                    }
                    
                    validStintsCount++;
                    
                    // === OBSERVATION 1: Home team's offensive value ===
                    // Home players get +1 in OFFENSIVE column (indices 0 to numPlayers-1)
                    stint.homePlayers.forEach(player => {
                        const idx = playerIndex.playerToIdx.get(player);
                        if (idx !== undefined) {
                            XData.push({ row: obsIdx, col: idx, val: 1.0 });
                        }
                    });
                    
                    // Away players get -1 in DEFENSIVE column (indices numPlayers to 2*numPlayers-1)
                    // They are defending against home team's offense
                    stint.awayPlayers.forEach(player => {
                        const idx = playerIndex.playerToIdx.get(player);
                        if (idx !== undefined) {
                            XData.push({ row: obsIdx, col: numPlayers + idx, val: -1.0 });
                        }
                    });
                    
                    yData.push(centeredHome);  // V3.2: Now centered
                    weightsData.push(homeWeight);  // V3.2: Stat-specific weight
                    obsIdx++;
                    
                    // === OBSERVATION 2: Away team's offensive value ===
                    // Away players get +1 in OFFENSIVE column
                    stint.awayPlayers.forEach(player => {
                        const idx = playerIndex.playerToIdx.get(player);
                        if (idx !== undefined) {
                            XData.push({ row: obsIdx, col: idx, val: 1.0 });
                        }
                    });
                    
                    // Home players get -1 in DEFENSIVE column
                    // They are defending against away team's offense
                    stint.homePlayers.forEach(player => {
                        const idx = playerIndex.playerToIdx.get(player);
                        if (idx !== undefined) {
                            XData.push({ row: obsIdx, col: numPlayers + idx, val: -1.0 });
                        }
                    });
                    
                    yData.push(centeredAway);  // V3.2: Now centered
                    weightsData.push(awayWeight);  // V3.2: Stat-specific weight
                    obsIdx++;
                });
                
                if (validStintsCount === 0) {
                    console.warn('[RAPM V3.2] No valid stints for stat:', statKey);
                    return null;
                }
                
                console.log('[RAPM V3.2] ' + statKey + ': ' + validStintsCount + ' valid stints, ' + skippedNull + ' skipped (null/invalid values)');
                
                return {
                    XData,
                    y: yData,
                    weights: weightsData,
                    numObs: obsIdx,
                    numFeatures,
                    validStints: validStintsCount,
                    leagueAvg: yMean,  // V3.2: Now returns the actual weighted mean used for centering
                    yMean: yMean  // V3.2: Include for reference
                };
            },
            
            // Original function for backward compatibility (uses ORtg)
            buildRAPMMatrices: function(stints, playerIndex) {
                return this.buildRAPMMatricesForStat(stints, playerIndex, 'ORtg');
            },
            
            // Solve weighted ridge regression: (X'WX + λI)β = X'Wy
            // Using Conjugate Gradient method
            solveWeightedRidge: function(XData, y, weights, numObs, numFeatures, lambda) {
                console.log('[RAPM] Building normal equations...');
                
                // Build X'WX and X'Wy
                const XtWX = new Float64Array(numFeatures * numFeatures);
                const XtWy = new Float64Array(numFeatures);
                
                // Group XData by row for efficient processing
                const rowData = new Map();
                XData.forEach(entry => {
                    if (!rowData.has(entry.row)) rowData.set(entry.row, []);
                    rowData.get(entry.row).push({ col: entry.col, val: entry.val });
                });
                
                // Compute X'WX and X'Wy
                for (let i = 0; i < numObs; i++) {
                    const w = weights[i];
                    const yi = y[i];
                    const rowEntries = rowData.get(i) || [];
                    
                    // X'Wy contribution
                    rowEntries.forEach(entry => {
                        XtWy[entry.col] += w * entry.val * yi;
                    });
                    
                    // X'WX contribution
                    rowEntries.forEach(e1 => {
                        rowEntries.forEach(e2 => {
                            XtWX[e1.col * numFeatures + e2.col] += w * e1.val * e2.val;
                        });
                    });
                }
                
                // Add regularization: X'WX + λI
                for (let i = 0; i < numFeatures; i++) {
                    XtWX[i * numFeatures + i] += lambda;
                }
                
                console.log('[RAPM] Solving with Conjugate Gradient...');
                
                // Solve using Conjugate Gradient
                const beta = this.conjugateGradient(XtWX, XtWy, numFeatures, 2000, 1e-10);
                
                return beta;
            },
            
            // Conjugate Gradient solver for Ax = b
            conjugateGradient: function(A, b, n, maxIter, tol) {
                const x = new Float64Array(n);
                const r = new Float64Array(n);
                const p = new Float64Array(n);
                const Ap = new Float64Array(n);
                
                // r = b - Ax (initially x=0, so r=b)
                for (let i = 0; i < n; i++) r[i] = b[i];
                for (let i = 0; i < n; i++) p[i] = r[i];
                
                let rsold = 0;
                for (let i = 0; i < n; i++) rsold += r[i] * r[i];
                
                for (let iter = 0; iter < maxIter; iter++) {
                    // Ap = A * p
                    for (let i = 0; i < n; i++) {
                        Ap[i] = 0;
                        for (let j = 0; j < n; j++) {
                            Ap[i] += A[i * n + j] * p[j];
                        }
                    }
                    
                    // alpha = rsold / (p' * Ap)
                    let pAp = 0;
                    for (let i = 0; i < n; i++) pAp += p[i] * Ap[i];
                    if (Math.abs(pAp) < 1e-15) break;
                    
                    const alpha = rsold / pAp;
                    
                    // x = x + alpha * p
                    // r = r - alpha * Ap
                    for (let i = 0; i < n; i++) {
                        x[i] += alpha * p[i];
                        r[i] -= alpha * Ap[i];
                    }
                    
                    // Check convergence
                    let rsnew = 0;
                    for (let i = 0; i < n; i++) rsnew += r[i] * r[i];
                    
                    if (Math.sqrt(rsnew) < tol) {
                        console.log('[RAPM] CG converged at iteration ' + iter);
                        break;
                    }
                    
                    // p = r + (rsnew/rsold) * p
                    const beta = rsnew / rsold;
                    for (let i = 0; i < n; i++) {
                        p[i] = r[i] + beta * p[i];
                    }
                    
                    rsold = rsnew;
                }
                
                return x;
            },
            
            // Post-center coefficients exactly like Python _center_rapm
            centerRAPM: function(coefficients, numPlayers, playerIndex) {
                const orapm = {};
                const drapm = {};
                
                // Extract raw coefficients
                playerIndex.playerList.forEach((player, idx) => {
                    orapm[player] = coefficients[idx];
                    drapm[player] = coefficients[numPlayers + idx];
                });
                
                // Compute possession-weighted means
                let totalPoss = 0;
                let orapmSum = 0;
                let drapmSum = 0;
                
                playerIndex.playerList.forEach(player => {
                    const poss = playerIndex.playerPossessions.get(player) || 0;
                    totalPoss += poss;
                    orapmSum += orapm[player] * poss;
                    drapmSum += drapm[player] * poss;
                });
                
                const orapmMean = totalPoss > 0 ? orapmSum / totalPoss : 0;
                const drapmMean = totalPoss > 0 ? drapmSum / totalPoss : 0;
                
                console.log('[RAPM] Centering: ORAPM mean=' + orapmMean.toFixed(3) + ', DRAPM mean=' + drapmMean.toFixed(3));
                
                // Center the coefficients
                playerIndex.playerList.forEach(player => {
                    orapm[player] -= orapmMean;
                    drapm[player] -= drapmMean;
                });
                
                return { orapm, drapm };
            },
            
            // Parse stints from CSV data - EXPANDED V3.0 to include all stats
            buildStintsFromMatchupData: function(matchupData) {
                const stints = [];
                const self = this;
                
                console.log('[RAPM V3.2] Sample row keys:', matchupData.length > 0 ? Object.keys(matchupData[0]) : 'no data');
                
                matchupData.forEach(m => {
                    // Possessions column
                    const poss = parseFloat(m.Possessions || m.possessions || m.POSS) || 0;
                    if (poss < this.config.minStintPoss) return;
                    
                    // Lineup columns
                    const homeLineupStr = m.Home_Lineup || m.home_lineup || '';
                    const awayLineupStr = m.Away_Lineup || m.away_lineup || '';

                    // V6.1: Apply merge rules before processing
                    const homePlayers = homeLineupStr.split(',').map(p => applyGlobalPlayerMerge(p.trim()).toLowerCase()).filter(p => p.length > 0);
                    const awayPlayers = awayLineupStr.split(',').map(p => applyGlobalPlayerMerge(p.trim()).toLowerCase()).filter(p => p.length > 0);
                    
                    // Skip non-5v5 stints
                    if (homePlayers.length !== 5 || awayPlayers.length !== 5) return;
                    
                    // === POINTS ===
                    let homePts = parseFloat(m.Home_PTS || m.home_points) || 0;
                    let awayPts = parseFloat(m.Away_PTS || m.away_points) || 0;
                    
                    // === SHOOTING STATS ===
                    // Field Goals
                    const homeFga = parseFloat(m.Home_FGA || m.home_fga) || 0;
                    const homeFgm = parseFloat(m.Home_FGM || m.home_fgm) || 0;
                    const awayFga = parseFloat(m.Away_FGA || m.away_fga) || 0;
                    const awayFgm = parseFloat(m.Away_FGM || m.away_fgm) || 0;
                    
                    // 3-Pointers
                    const homeFg3a = parseFloat(m['Home_3PA'] || m.home_fg3a) || 0;
                    const homeFg3m = parseFloat(m['Home_3PM'] || m.home_fg3m) || 0;
                    const awayFg3a = parseFloat(m['Away_3PA'] || m.away_fg3a) || 0;
                    const awayFg3m = parseFloat(m['Away_3PM'] || m.away_fg3m) || 0;
                    
                    // Free Throws
                    const homeFta = parseFloat(m.Home_FTA || m.home_fta) || 0;
                    const homeFtm = parseFloat(m.Home_FTM || m.home_ftm) || 0;
                    const awayFta = parseFloat(m.Away_FTA || m.away_fta) || 0;
                    const awayFtm = parseFloat(m.Away_FTM || m.away_ftm) || 0;
                    
                    // === REBOUNDS ===
                    const homeOreb = parseFloat(m.Home_OREB || m.home_oreb) || 0;
                    const homeDreb = parseFloat(m.Home_DREB || m.home_dreb) || 0;
                    const awayOreb = parseFloat(m.Away_OREB || m.away_oreb) || 0;
                    const awayDreb = parseFloat(m.Away_DREB || m.away_dreb) || 0;
                    
                    // === TURNOVERS ===
                    const homeTov = parseFloat(m.Home_TOV || m.home_tov) || 0;
                    const awayTov = parseFloat(m.Away_TOV || m.away_tov) || 0;
                    
                    // === ASSISTS ===
                    const homeAst = parseFloat(m.Home_AST || m.home_ast) || 0;
                    const awayAst = parseFloat(m.Away_AST || m.away_ast) || 0;
                    
                    // === STEALS & BLOCKS ===
                    const homeStl = parseFloat(m.Home_STL || m.home_stl) || 0;
                    const awayStl = parseFloat(m.Away_STL || m.away_stl) || 0;
                    const homeBlk = parseFloat(m.Home_BLK || m.home_blk) || 0;
                    const awayBlk = parseFloat(m.Away_BLK || m.away_blk) || 0;
                    
                    // === SHOT LOCATION STATS ===
                    const homeRimAtt = parseFloat(m.Home_RIM_ATT || m.home_rim_att) || 0;
                    const homeRimMade = parseFloat(m.Home_RIM_MADE || m.home_rim_made) || 0;
                    const awayRimAtt = parseFloat(m.Away_RIM_ATT || m.away_rim_att) || 0;
                    const awayRimMade = parseFloat(m.Away_RIM_MADE || m.away_rim_made) || 0;
                    
                    const homeMidAtt = parseFloat(m.Home_OTD_2PT_ATT || m.home_otd_2pt_att) || 0;
                    const homeMidMade = parseFloat(m.Home_OTD_2PT_MADE || m.home_otd_2pt_made) || 0;
                    const awayMidAtt = parseFloat(m.Away_OTD_2PT_ATT || m.away_otd_2pt_att) || 0;
                    const awayMidMade = parseFloat(m.Away_OTD_2PT_MADE || m.away_otd_2pt_made) || 0;
                    
                    // Note: otd_3pt is "off the dribble 3pt" - using fg3a/fg3m for total 3pt stats
                    const homeOtd3ptAtt = parseFloat(m.Home_OTD_3PT_ATT || m.home_otd_3pt_att) || 0;
                    const homeOtd3ptMade = parseFloat(m.Home_OTD_3PT_MADE || m.home_otd_3pt_made) || 0;
                    const awayOtd3ptAtt = parseFloat(m.Away_OTD_3PT_ATT || m.away_otd_3pt_att) || 0;
                    const awayOtd3ptMade = parseFloat(m.Away_OTD_3PT_MADE || m.away_otd_3pt_made) || 0;
                    
                    // === TRANSITION & SECONDARY STATS ===
                    const homeFastBreak = parseFloat(m.Home_FAST_BREAK_PTS || m.home_fast_break_pts) || 0;
                    const awayFastBreak = parseFloat(m.Away_FAST_BREAK_PTS || m.away_fast_break_pts) || 0;
                    
                    const homeSecondChance = parseFloat(m.Home_SECOND_CHANCE_PTS || m.home_second_chance_pts) || 0;
                    const awaySecondChance = parseFloat(m.Away_SECOND_CHANCE_PTS || m.away_second_chance_pts) || 0;
                    
                    const homePtsOffTov = parseFloat(m.Home_PTS_OFF_TOV || m.home_pts_off_tov) || 0;
                    const awayPtsOffTov = parseFloat(m.Away_PTS_OFF_TOV || m.away_pts_off_tov) || 0;
                    
                    // If no direct points, calculate from FGM, 3PM, FTM
                    if (homePts === 0 && (homeFgm > 0 || homeFg3m > 0 || homeFtm > 0)) {
                        // Points = 2*FGM + 3PM + FTM (FGM already includes 3PM as 2-pointers)
                        homePts = 2 * homeFgm + homeFg3m + homeFtm;
                    }
                    
                    if (awayPts === 0 && (awayFgm > 0 || awayFg3m > 0 || awayFtm > 0)) {
                        awayPts = 2 * awayFgm + awayFg3m + awayFtm;
                    }
                    
                    stints.push({
                        possessions: poss,
                        homePlayers,
                        awayPlayers,
                        // Points
                        homePts,
                        awayPts,
                        // Shooting
                        homeFga, homeFgm, homeFg3a, homeFg3m, homeFta, homeFtm,
                        awayFga, awayFgm, awayFg3a, awayFg3m, awayFta, awayFtm,
                        // Rebounds
                        homeOreb, homeDreb,
                        awayOreb, awayDreb,
                        // Turnovers
                        homeTov, awayTov,
                        // Assists
                        homeAst, awayAst,
                        // Steals & Blocks
                        homeStl, awayStl,
                        homeBlk, awayBlk,
                        // Shot Location
                        homeRimAtt, homeRimMade, awayRimAtt, awayRimMade,
                        homeMidAtt, homeMidMade, awayMidAtt, awayMidMade,
                        homeOtd3ptAtt, homeOtd3ptMade, awayOtd3ptAtt, awayOtd3ptMade,
                        // Transition & Secondary
                        homeFastBreak, awayFastBreak,
                        homeSecondChance, awaySecondChance,
                        homePtsOffTov, awayPtsOffTov
                    });
                });
                
                console.log('[RAPM V3.2] Built ' + stints.length + ' valid stints from ' + matchupData.length + ' rows');
                if (stints.length > 0) {
                    console.log('[RAPM V3.2] Sample stint keys:', Object.keys(stints[0]));
                    console.log('[RAPM V3.2] Sample stint values:', JSON.stringify(stints[0]));
                }
                
                return stints;
            },
            
            // MULTI-STAT RAPM CALCULATION V3.2
            // Calculates RAPM for ORtg, eFG%, TOV%, OREB%, FTRate, and more
            // V3.2: Now with response centering and stat-specific weighting
            calculateAsync: function(matchupData, baseLambda, onProgress) {
                const self = this;
                baseLambda = baseLambda || this.config.defaultLambda;
                onProgress = onProgress || function() {};
                
                // Stats to calculate RAPM for (keys from statConfigs)
                // V3.1: Added shot location, transition, and secondary stats
                const statsToCalculate = [
                    // Core ratings
                    'ORtg', 
                    // Four Factors
                    'eFG', 'TOV', 'OREB', 'FTR',
                    // Playmaking & Defense
                    'AST', 'STL', 'BLK',
                    // Shot Location
                    'RimPct', 'RimFreq', 'MidPct', 'MidFreq', 'ThreePct', 'ThreeFreq',
                    // Transition & Secondary
                    'FastBreak', 'SecondChance', 'PtsOffTov'
                ];
                
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            console.log('[RAPM V3.2] Starting MULTI-STAT calculation with base lambda=' + baseLambda);
                            onProgress(0, 'Parsing stint data...');
                            
                            // Step 1: Parse stints with all stats
                            const stints = self.buildStintsFromMatchupData(matchupData);
                            if (stints.length === 0) {
                                resolve({ error: 'No valid stints found' });
                                return;
                            }
                            console.log('[RAPM V3.2] Parsed ' + stints.length + ' valid stints');
                            onProgress(5, stints.length + ' stints parsed');
                            
                            // Step 2: Build player index (shared across all stats)
                            const playerIndex = self.buildPlayerIndex(stints);
                            console.log('[RAPM V3.2] Found ' + playerIndex.playerCount + ' unique players');
                            onProgress(10, playerIndex.playerCount + ' players indexed');
                            
                            // Step 3: Calculate RAPM for each stat
                            const allStats = {};
                            const leagueAverages = {};
                            const statDetails = {};
                            
                            statsToCalculate.forEach((statKey, idx) => {
                                const progressPct = 10 + Math.round((idx / statsToCalculate.length) * 70);
                                const config = self.statConfigs[statKey];
                                
                                onProgress(progressPct, 'Calculating RAPM for ' + config.name + '...');
                                console.log('[RAPM V3.2] === Processing ' + statKey + ' (' + config.name + ') ===');
                                
                                // Build matrices for this stat
                                const matrices = self.buildRAPMMatricesForStat(stints, playerIndex, statKey);
                                
                                if (!matrices) {
                                    console.warn('[RAPM V3.2] Skipping ' + statKey + ' - no valid data');
                                    allStats[statKey] = { error: 'No valid data for this stat' };
                                    return;
                                }
                                
                                // Get stat-specific lambda
                                const lambdaScale = self.config.lambdaScales[statKey] || 1.0;
                                const statLambda = baseLambda * lambdaScale;
                                
                                console.log('[RAPM V3.2] ' + statKey + ': ' + matrices.numObs + ' obs, λ=' + statLambda.toFixed(0));
                                
                                // Solve ridge regression
                                const coefficients = self.solveWeightedRidge(
                                    matrices.XData, 
                                    matrices.y, 
                                    matrices.weights, 
                                    matrices.numObs, 
                                    matrices.numFeatures, 
                                    statLambda
                                );
                                
                                // Center coefficients
                                const { orapm, drapm } = self.centerRAPM(coefficients, playerIndex.playerCount, playerIndex);
                                
                                // Build player results for this stat
                                const playerResults = {};
                                
                                playerIndex.playerList.forEach(player => {
                                    const poss = playerIndex.playerPossessions.get(player) || 0;
                                    if (poss < self.config.minPlayerPoss) return;
                                    
                                    playerResults[player] = {
                                        oRAPM: orapm[player],
                                        dRAPM: drapm[player],
                                        totalPoss: poss
                                    };
                                });
                                
                                allStats[statKey] = playerResults;
                                leagueAverages[statKey] = matrices.leagueAvg;
                                statDetails[statKey] = {
                                    numObs: matrices.numObs,
                                    validStints: matrices.validStints,
                                    lambda: statLambda,
                                    higherBetter: config.higherBetter
                                };
                                
                                // Log top 3 for this stat
                                const sorted = Object.entries(playerResults)
                                    .sort((a, b) => (b[1].oRAPM + b[1].dRAPM) - (a[1].oRAPM + a[1].dRAPM));
                                console.log('[RAPM V3.2] ' + statKey + ' Top 3:');
                                sorted.slice(0, 3).forEach(([player, data], i) => {
                                    const net = data.oRAPM + data.dRAPM;
                                    console.log('  ' + (i+1) + '. ' + player + ': O=' + data.oRAPM.toFixed(2) + ', D=' + data.dRAPM.toFixed(2));
                                });
                            });
                            
                            onProgress(90, 'Finalizing results...');
                            
                            // Summary
                            const calculatedStats = Object.keys(allStats).filter(k => !allStats[k].error);
                            console.log('[RAPM V3.2] Successfully calculated RAPM for ' + calculatedStats.length + ' stats: ' + calculatedStats.join(', '));
                            
                            onProgress(100, 'Complete! (' + calculatedStats.length + ' stats)');
                            
                            resolve({
                                stats: allStats,
                                leagueAverages: leagueAverages,
                                statDetails: statDetails,
                                lambda: baseLambda,
                                playerCount: playerIndex.playerCount,
                                stintCount: stints.length,
                                calculatedStats: calculatedStats,
                                version: '3.2-multi-stat-fixed'
                            });
                            
                        } catch (err) {
                            console.error('[RAPM V3.2] Calculation failed:', err);
                            reject(err);
                        }
                    }, 10);
                });
            },
            
            // =======================================================================
            // V6.0: BAYESIAN BOX APM - Intraocular.net Methodology
            // Based on: https://www.intraocular.net/posts/bayesian-box-plus-minus
            // 
            // Single unified model that learns box score coefficients (αⱼ) simultaneously
            // with player impacts (β). Uses per-possession box stats as features.
            //
            // Model:  Y ~ N(Xβ, σ)           # Lineup observations
            //         β ~ N(Σⱼ αⱼ · Zⱼ, τ)   # Box score prior for player coefficients
            //         αⱼ ~ N(0, ξ)           # Regularization on box score weights
            //
            // Two levels of regularization:
            //   τ (tau) - controls prior vs likelihood weight
            //   ξ (xi) - controls box score coefficient magnitudes
            // =======================================================================
            
            // Box score stat definitions for Bayesian Box APM
            boxScoreStatDefs: {
                offensive: [
                    { key: 'fgm2_poss', label: '2PM', csv: ['FGM', '3PM'], compute: (r) => ((r.FGM || 0) - (r['3PM'] || 0)) / Math.max(1, r.POSS) },
                    { key: 'fgmiss2_poss', label: '2PMiss', csv: ['FGA', 'FGM', '3PA', '3PM'], compute: (r) => (((r.FGA || 0) - (r.FGM || 0)) - ((r['3PA'] || 0) - (r['3PM'] || 0))) / Math.max(1, r.POSS) },
                    { key: 'fgm3_poss', label: '3PM', csv: ['3PM'], compute: (r) => (r['3PM'] || 0) / Math.max(1, r.POSS) },
                    { key: 'fgmiss3_poss', label: '3PMiss', csv: ['3PA', '3PM'], compute: (r) => ((r['3PA'] || 0) - (r['3PM'] || 0)) / Math.max(1, r.POSS) },
                    { key: 'ftm_poss', label: 'FTM', csv: ['FTM'], compute: (r) => (r.FTM || 0) / Math.max(1, r.POSS) },
                    { key: 'ftmiss_poss', label: 'FTMiss', csv: ['FTA', 'FTM'], compute: (r) => ((r.FTA || 0) - (r.FTM || 0)) / Math.max(1, r.POSS) },
                    { key: 'oreb_poss', label: 'OREB', csv: ['OREB'], compute: (r) => (r.OREB || 0) / Math.max(1, r.POSS) },
                    { key: 'ast_poss', label: 'AST', csv: ['AST'], compute: (r) => (r.AST || 0) / Math.max(1, r.POSS) },
                    { key: 'tov_poss', label: 'TOV', csv: ['TOV'], compute: (r) => (r.TOV || 0) / Math.max(1, r.POSS) }
                ],
                defensive: [
                    { key: 'dreb_poss', label: 'DRB', csv: ['DREB'], compute: (r) => (r.DREB || 0) / Math.max(1, r.POSS) },
                    { key: 'stl_poss', label: 'STL', csv: ['STL'], compute: (r) => (r.STL || 0) / Math.max(1, r.POSS) },
                    { key: 'blk_poss', label: 'BLK', csv: ['BLK'], compute: (r) => (r.BLK || 0) / Math.max(1, r.POSS) },
                    { key: 'pf_poss', label: 'PF', csv: ['PF'], compute: (r) => (r.PF || 0) / Math.max(1, r.POSS) }
                ]
            },
            
            // Bayesian Box APM hyperparameters (tuned per Intraocular research)
            bayesianBoxConfig: {
                tau_off: 0.5,      // Prior weight for offense (lower = more box score influence)
                tau_def: 0.7,      // Prior weight for defense (higher = more plus-minus influence)
                // V5.0: FIXED - Defensive box stats are noisier predictors, need MORE regularization
                // Research shows defensive box scores (STL, BLK, DRB) are less predictive of defensive impact
                xi_off: 0.5,       // Box coef regularization for offense (more reliable stats)
                xi_def: 0.3,       // Box coef regularization for defense (more regularization for noisier stats)
                baseLambda: 3000   // Base ridge regularization parameter
            },
            
            calculateAPMAsync: function(matchupData, seasonStatsMap, baseLambda, onProgress) {
                const self = this;
                baseLambda = baseLambda || this.bayesianBoxConfig.baseLambda;
                onProgress = onProgress || function() {};
                
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            console.log('[BayesianBoxAPM V2.0] Starting Intraocular-style calculation');
                            console.log('[BayesianBoxAPM V2.0] Season stats available for', Object.keys(seasonStatsMap || {}).length, 'players');
                            onProgress(0, 'Starting Bayesian Box APM...');
                            
                            // Step 1: Parse stints
                            const stints = self.buildStintsFromMatchupData(matchupData);
                            if (stints.length === 0) {
                                resolve({ error: 'No valid stints found' });
                                return;
                            }
                            console.log('[BayesianBoxAPM V2.0] Parsed', stints.length, 'stints');
                            onProgress(5, stints.length + ' stints parsed');
                            
                            // Step 2: Build player index
                            const playerIndex = self.buildPlayerIndex(stints);
                            console.log('[BayesianBoxAPM V2.0] Found', playerIndex.playerCount, 'unique players');
                            onProgress(10, playerIndex.playerCount + ' players indexed');
                            
                            // Step 3: Build box score feature matrices (Z) for each player
                            // Offensive features: 2PM, 2PMiss, 3PM, 3PMiss, FTM, FTMiss, OREB, AST, TOV
                            // Defensive features: DRB, STL, BLK, PF
                            const boxResults = self.buildBoxScoreFeatures(playerIndex, seasonStatsMap);
                            console.log('[BayesianBoxAPM V2.0] Box features computed for', boxResults.playersWithStats, 'players');
                            onProgress(20, 'Box score features for ' + boxResults.playersWithStats + ' players');
                            
                            // Step 4: Build RAPM matrices
                            const matrices = self.buildRAPMMatricesForStat(stints, playerIndex, 'ORtg');
                            if (!matrices) {
                                resolve({ error: 'Could not build APM matrices' });
                                return;
                            }
                            console.log('[BayesianBoxAPM V2.0] Built matrices:', matrices.numObs, 'observations');
                            onProgress(30, 'Built ' + matrices.numObs + ' possession observations');
                            
                            // Step 5: Learn box score coefficients (α) using regularized regression
                            // This finds the optimal weights for each box stat
                            onProgress(40, 'Learning box score coefficients...');
                            const learnedCoefs = self.learnBoxScoreCoefficients(
                                matrices, playerIndex, boxResults,
                                self.bayesianBoxConfig.xi_off,
                                self.bayesianBoxConfig.xi_def
                            );
                            console.log('[BayesianBoxAPM V2.0] Learned offensive coefs:', 
                                Object.entries(learnedCoefs.offensive).map(([k,v]) => k + '=' + v.toFixed(3)).join(', '));
                            console.log('[BayesianBoxAPM V2.0] Learned defensive coefs:', 
                                Object.entries(learnedCoefs.defensive).map(([k,v]) => k + '=' + v.toFixed(3)).join(', '));
                            onProgress(55, 'Box coefficients learned');
                            
                            // Step 6: Compute Bayesian Box Prior for each player using learned coefficients
                            // Prior = Σⱼ αⱼ · Zⱼ (standardized)
                            const priors = self.computeBayesianBoxPriors(playerIndex, boxResults, learnedCoefs);
                            console.log('[BayesianBoxAPM V2.0] Computed priors for', Object.keys(priors.offensive).length, 'players');
                            onProgress(65, 'Box priors computed');
                            
                            // Step 7: Run ridge regression with learned priors
                            // Using prior-subtraction method: y_adj = y - X·prior, then β = prior + ridge(y_adj)
                            onProgress(75, 'Running Bayesian ridge regression...');
                            const apmResults = self.solveBayesianBoxRidge(
                                matrices, playerIndex, priors,
                                baseLambda,
                                self.bayesianBoxConfig.tau_off,
                                self.bayesianBoxConfig.tau_def
                            );
                            console.log('[BayesianBoxAPM V2.0] Ridge regression complete');
                            onProgress(90, 'Combining box priors with plus-minus...');
                            
                            // Step 8: Format results
                            const playerResults = {};
                            playerIndex.playerList.forEach(player => {
                                const poss = playerIndex.playerPossessions.get(player) || 0;
                                if (poss < self.config.minPlayerPoss) return;
                                
                                const oAPM = apmResults.orapm[player] || 0;
                                const dAPM = apmResults.drapm[player] || 0;
                                const oPrior = priors.offensive[player] || 0;
                                const dPrior = priors.defensive[player] || 0;
                                
                                playerResults[player] = {
                                    oAPM: oAPM,
                                    dAPM: dAPM,
                                    totalAPM: oAPM + dAPM,
                                    // Store prior components for analysis
                                    boxPriorOff: oPrior,
                                    boxPriorDef: dPrior,
                                    boxPriorTotal: oPrior + dPrior,
                                    totalPoss: poss
                                };
                            });
                            
                            // Log results
                            const sorted = Object.entries(playerResults)
                                .sort((a, b) => b[1].totalAPM - a[1].totalAPM);
                            console.log('[BayesianBoxAPM V2.0] Top 5 Bayesian Box APM:');
                            sorted.slice(0, 5).forEach(([player, data], i) => {
                                console.log('  ' + (i+1) + '. ' + player + ': APM=' + data.totalAPM.toFixed(2) + 
                                    ' (O=' + data.oAPM.toFixed(2) + ', D=' + data.dAPM.toFixed(2) + ')' +
                                    ' | Prior=' + data.boxPriorTotal.toFixed(2));
                            });
                            
                            onProgress(100, 'Bayesian Box APM complete!');
                            
                            resolve({
                                players: playerResults,
                                lambda: baseLambda,
                                playerCount: Object.keys(playerResults).length,
                                stintCount: stints.length,
                                playersWithBoxStats: boxResults.playersWithStats,
                                learnedCoefficients: learnedCoefs,
                                leagueAvg: matrices.leagueAvg,
                                version: '2.0-intraocular-bayesian-box'
                            });
                            
                        } catch (err) {
                            console.error('[APM V1.0] Calculation failed:', err);
                            reject(err);
                        }
                    }, 10);
                });
            },
            
            // V6.0: Build box score feature vectors (Z) for each player
            // Uses per-possession statistics, standardized (mean 0, std 1)
            buildBoxScoreFeatures: function(playerIndex, seasonStatsMap) {
                const self = this;
                const offStats = self.boxScoreStatDefs.offensive;
                const defStats = self.boxScoreStatDefs.defensive;
                
                // Initialize storage
                const offFeatures = {}; // playerName -> {stat1: val, stat2: val, ...}
                const defFeatures = {};
                let playersWithStats = 0;
                
                // Helper to normalize player name for matching
                const normalizeName = (name) => name.toLowerCase().trim().replace(/[''`´.]/g, '').replace(/\s+/g, ' ');
                
                // Collect raw values for all players
                playerIndex.playerList.forEach(player => {
                    const normalizedName = normalizeName(player);
                    
                    // Try to find season stats
                    let stats = seasonStatsMap[normalizedName];
                    if (!stats) {
                        // Try original case
                        stats = seasonStatsMap[player];
                    }
                    if (!stats) {
                        // Try variations
                        for (const [key, val] of Object.entries(seasonStatsMap)) {
                            if (normalizeName(key) === normalizedName) {
                                stats = val;
                                break;
                            }
                        }
                    }
                    
                    if (stats && stats.POSS && stats.POSS > 0) {
                        playersWithStats++;
                        
                        // Compute offensive features
                        offFeatures[player] = {};
                        offStats.forEach(stat => {
                            offFeatures[player][stat.key] = stat.compute(stats);
                        });
                        
                        // Compute defensive features
                        defFeatures[player] = {};
                        defStats.forEach(stat => {
                            defFeatures[player][stat.key] = stat.compute(stats);
                        });
                    } else {
                        // No stats - use zeros
                        offFeatures[player] = {};
                        offStats.forEach(stat => offFeatures[player][stat.key] = 0);
                        defFeatures[player] = {};
                        defStats.forEach(stat => defFeatures[player][stat.key] = 0);
                    }
                });
                
                // Standardize features (z-score) across all players
                const standardize = (features, statDefs) => {
                    statDefs.forEach(stat => {
                        const values = Object.values(features).map(f => f[stat.key]).filter(v => v !== 0);
                        if (values.length === 0) return;
                        
                        const mean = values.reduce((a, b) => a + b, 0) / values.length;
                        const variance = values.reduce((a, b) => a + (b - mean) ** 2, 0) / values.length;
                        const std = Math.sqrt(variance) || 1;
                        
                        Object.keys(features).forEach(player => {
                            if (features[player][stat.key] !== 0) {
                                features[player][stat.key] = (features[player][stat.key] - mean) / std;
                            }
                        });
                    });
                };
                
                standardize(offFeatures, offStats);
                standardize(defFeatures, defStats);
                
                return {
                    offensive: offFeatures,
                    defensive: defFeatures,
                    playersWithStats: playersWithStats,
                    offStatKeys: offStats.map(s => s.key),
                    defStatKeys: defStats.map(s => s.key)
                };
            },
            
            // V6.0: Learn box score coefficients (α) using regularized regression
            // Finds optimal weights for each box stat by regressing on plus-minus outcomes
            learnBoxScoreCoefficients: function(matrices, playerIndex, boxResults, xiOff, xiDef) {
                const self = this;
                
                // For computational efficiency, we use a simplified approach:
                // Learn α by finding coefficients that minimize: ||y - Z_expanded · α||² + ξ||α||²
                // where Z_expanded expands player box stats to possession level
                
                // Build aggregated plus-minus by player (weighted by possessions)
                const playerPM = {}; // player -> {totalPM, totalWeight}
                
                // Group XData by row for efficient computation
                const rowData = new Map();
                matrices.XData.forEach(entry => {
                    if (!rowData.has(entry.row)) rowData.set(entry.row, []);
                    rowData.get(entry.row).push({ col: entry.col, val: entry.val });
                });
                
                // Accumulate plus-minus for each player
                for (let i = 0; i < matrices.numObs; i++) {
                    const y = matrices.y[i];
                    const w = matrices.weights[i] || 1;
                    const rowEntries = rowData.get(i) || [];
                    
                    rowEntries.forEach(entry => {
                        const playerIdx = entry.col;
                        const isDefensive = playerIdx >= playerIndex.playerCount;
                        const actualIdx = isDefensive ? playerIdx - playerIndex.playerCount : playerIdx;
                        const player = playerIndex.playerList[actualIdx];
                        
                        if (!playerPM[player]) {
                            playerPM[player] = { offPM: 0, defPM: 0, offWeight: 0, defWeight: 0 };
                        }
                        
                        if (isDefensive) {
                            // Defensive: y contribution is negated (good defense = opponent scores less)
                            playerPM[player].defPM += -y * entry.val * w;
                            playerPM[player].defWeight += w;
                        } else {
                            playerPM[player].offPM += y * entry.val * w;
                            playerPM[player].offWeight += w;
                        }
                    });
                }
                
                // Compute average plus-minus per player
                Object.keys(playerPM).forEach(player => {
                    if (playerPM[player].offWeight > 0) {
                        playerPM[player].offPM /= playerPM[player].offWeight;
                    }
                    if (playerPM[player].defWeight > 0) {
                        playerPM[player].defPM /= playerPM[player].defWeight;
                    }
                });
                
                // Learn offensive coefficients via ridge regression: Z_off · α_off ≈ offPM
                const learnCoefs = (features, statKeys, pmKey, xi) => {
                    const n = Object.keys(features).length;
                    const k = statKeys.length;
                    if (n === 0 || k === 0) return {};
                    
                    // Build Z matrix (n x k) and y vector (n x 1)
                    const Z = [];
                    const y = [];
                    const players = Object.keys(features);
                    
                    players.forEach(player => {
                        if (!playerPM[player]) return;
                        const row = statKeys.map(key => features[player][key] || 0);
                        Z.push(row);
                        y.push(playerPM[player][pmKey] || 0);
                    });
                    
                    if (Z.length < 10) {
                        // Not enough data - use default coefficients
                        const coefs = {};
                        statKeys.forEach(key => coefs[key] = 0);
                        return coefs;
                    }
                    
                    // Solve ridge regression: (Z'Z + λI)α = Z'y
                    // Using simple closed-form solution
                    const lambda = xi * Z.length; // Scale regularization by sample size
                    
                    // Compute Z'Z (k x k)
                    const ZtZ = [];
                    for (let i = 0; i < k; i++) {
                        ZtZ[i] = [];
                        for (let j = 0; j < k; j++) {
                            let sum = 0;
                            for (let m = 0; m < Z.length; m++) {
                                sum += Z[m][i] * Z[m][j];
                            }
                            ZtZ[i][j] = sum + (i === j ? lambda : 0);
                        }
                    }
                    
                    // Compute Z'y (k x 1)
                    const Zty = [];
                    for (let i = 0; i < k; i++) {
                        let sum = 0;
                        for (let m = 0; m < Z.length; m++) {
                            sum += Z[m][i] * y[m];
                        }
                        Zty[i] = sum;
                    }
                    
                    // Solve (Z'Z + λI)α = Z'y using Cholesky or simple Gauss elimination
                    const alpha = self.solveLinearSystem(ZtZ, Zty);
                    
                    // Map back to named coefficients
                    const coefs = {};
                    statKeys.forEach((key, i) => {
                        coefs[key] = alpha[i] || 0;
                    });
                    
                    return coefs;
                };
                
                return {
                    offensive: learnCoefs(boxResults.offensive, boxResults.offStatKeys, 'offPM', xiOff),
                    defensive: learnCoefs(boxResults.defensive, boxResults.defStatKeys, 'defPM', xiDef)
                };
            },
            
            // V6.0: Simple linear system solver using Gaussian elimination with partial pivoting
            solveLinearSystem: function(A, b) {
                const n = A.length;
                if (n === 0) return [];
                
                // Create augmented matrix
                const M = A.map((row, i) => [...row, b[i]]);
                
                // Forward elimination with partial pivoting
                for (let col = 0; col < n; col++) {
                    // Find pivot
                    let maxRow = col;
                    let maxVal = Math.abs(M[col][col]);
                    for (let row = col + 1; row < n; row++) {
                        if (Math.abs(M[row][col]) > maxVal) {
                            maxVal = Math.abs(M[row][col]);
                            maxRow = row;
                        }
                    }
                    
                    // Swap rows
                    if (maxRow !== col) {
                        [M[col], M[maxRow]] = [M[maxRow], M[col]];
                    }
                    
                    // Check for singular matrix
                    if (Math.abs(M[col][col]) < 1e-10) continue;
                    
                    // Eliminate below
                    for (let row = col + 1; row < n; row++) {
                        const factor = M[row][col] / M[col][col];
                        for (let j = col; j <= n; j++) {
                            M[row][j] -= factor * M[col][j];
                        }
                    }
                }
                
                // Back substitution
                const x = new Array(n).fill(0);
                for (let i = n - 1; i >= 0; i--) {
                    if (Math.abs(M[i][i]) < 1e-10) continue;
                    x[i] = M[i][n];
                    for (let j = i + 1; j < n; j++) {
                        x[i] -= M[i][j] * x[j];
                    }
                    x[i] /= M[i][i];
                }
                
                return x;
            },
            
            // V6.0: Compute Bayesian Box Priors for each player using learned coefficients
            computeBayesianBoxPriors: function(playerIndex, boxResults, learnedCoefs) {
                const offPriors = {};
                const defPriors = {};
                
                playerIndex.playerList.forEach(player => {
                    // Offensive prior = Σⱼ αⱼ · Zⱼ (offensive)
                    let offPrior = 0;
                    const offFeats = boxResults.offensive[player] || {};
                    Object.entries(learnedCoefs.offensive).forEach(([key, coef]) => {
                        offPrior += coef * (offFeats[key] || 0);
                    });
                    offPriors[player] = offPrior;
                    
                    // Defensive prior = Σⱼ αⱼ · Zⱼ (defensive)
                    let defPrior = 0;
                    const defFeats = boxResults.defensive[player] || {};
                    Object.entries(learnedCoefs.defensive).forEach(([key, coef]) => {
                        defPrior += coef * (defFeats[key] || 0);
                    });
                    defPriors[player] = defPrior;
                });
                
                return {
                    offensive: offPriors,
                    defensive: defPriors
                };
            },
            
            // V6.0: Solve Bayesian Box ridge regression with learned priors
            // Uses prior-subtraction method: y_adj = y - X·prior, β = prior + ridge(y_adj)
            solveBayesianBoxRidge: function(matrices, playerIndex, priors, baseLambda, tauOff, tauDef) {
                const self = this;
                
                // Build prior vectors (matching matrix column order)
                const offPriorVec = new Float64Array(playerIndex.playerCount);
                const defPriorVec = new Float64Array(playerIndex.playerCount);
                
                playerIndex.playerList.forEach((player, idx) => {
                    offPriorVec[idx] = priors.offensive[player] || 0;
                    // Defense: negate prior for RAPM convention (good defense = negative coefficient)
                    defPriorVec[idx] = -(priors.defensive[player] || 0);
                });
                
                // Adjust response: y_adjusted = y - X·prior
                const yAdjusted = new Float64Array(matrices.y.length);
                
                // Group XData by row
                const rowData = new Map();
                matrices.XData.forEach(entry => {
                    if (!rowData.has(entry.row)) rowData.set(entry.row, []);
                    rowData.get(entry.row).push({ col: entry.col, val: entry.val });
                });
                
                for (let i = 0; i < matrices.numObs; i++) {
                    let priorContribution = 0;
                    const rowEntries = rowData.get(i) || [];
                    
                    rowEntries.forEach(entry => {
                        const playerIdx = entry.col;
                        const isDefensive = playerIdx >= playerIndex.playerCount;
                        const actualIdx = isDefensive ? playerIdx - playerIndex.playerCount : playerIdx;
                        
                        if (isDefensive) {
                            priorContribution += entry.val * defPriorVec[actualIdx];
                        } else {
                            priorContribution += entry.val * offPriorVec[actualIdx];
                        }
                    });
                    
                    yAdjusted[i] = matrices.y[i] - priorContribution;
                }
                
                // Apply differential tau weighting through lambda adjustment
                // Higher tau = more weight on plus-minus (lower regularization toward prior)
                // Lower tau = more weight on box prior (higher regularization)
                const offLambda = baseLambda / Math.max(0.1, tauOff);
                const defLambda = baseLambda / Math.max(0.1, tauDef);
                
                // Solve weighted ridge with differential lambdas for off/def
                const residualCoefficients = self.solveWeightedRidgeDifferential(
                    matrices.XData,
                    yAdjusted,
                    matrices.weights,
                    matrices.numObs,
                    matrices.numFeatures,
                    offLambda,
                    defLambda,
                    playerIndex.playerCount
                );
                
                // Combine: β_final = prior + residual
                const finalCoefficients = new Float64Array(matrices.numFeatures);
                for (let i = 0; i < playerIndex.playerCount; i++) {
                    finalCoefficients[i] = offPriorVec[i] + residualCoefficients[i];
                    finalCoefficients[playerIndex.playerCount + i] = defPriorVec[i] + residualCoefficients[playerIndex.playerCount + i];
                }
                
                // Center and format results
                return self.centerRAPM(finalCoefficients, playerIndex.playerCount, playerIndex);
            },
            
            // V6.0: Weighted ridge with different lambdas for offensive vs defensive coefficients
            solveWeightedRidgeDifferential: function(XData, y, weights, numObs, numFeatures, lambdaOff, lambdaDef, playerCount) {
                const self = this;
                
                // Build X'WX and X'Wy using sparse data
                const XtWX = [];
                for (let i = 0; i < numFeatures; i++) {
                    XtWX[i] = new Float64Array(numFeatures);
                }
                const XtWy = new Float64Array(numFeatures);
                
                // Group by row for efficient computation
                const rowData = new Map();
                XData.forEach(entry => {
                    if (!rowData.has(entry.row)) rowData.set(entry.row, []);
                    rowData.get(entry.row).push({ col: entry.col, val: entry.val });
                });
                
                // Accumulate X'WX and X'Wy
                for (let row = 0; row < numObs; row++) {
                    const entries = rowData.get(row) || [];
                    const w = weights[row] || 1;
                    const yVal = y[row] * w;
                    
                    entries.forEach(e1 => {
                        XtWy[e1.col] += e1.val * yVal;
                        entries.forEach(e2 => {
                            XtWX[e1.col][e2.col] += e1.val * e2.val * w;
                        });
                    });
                }
                
                // Add differential regularization to diagonal
                for (let i = 0; i < numFeatures; i++) {
                    if (i < playerCount) {
                        XtWX[i][i] += lambdaOff; // Offensive coefficient
                    } else {
                        XtWX[i][i] += lambdaDef; // Defensive coefficient
                    }
                }
                
                // Solve using Cholesky decomposition
                return self.choleskySolve(XtWX, XtWy);
            },
            
            // V6.0: Cholesky decomposition solver for symmetric positive definite matrices
            choleskySolve: function(A, b) {
                const n = A.length;
                const L = [];
                for (let i = 0; i < n; i++) {
                    L[i] = new Float64Array(n);
                }
                
                // Cholesky decomposition: A = LL'
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j <= i; j++) {
                        let sum = 0;
                        for (let k = 0; k < j; k++) {
                            sum += L[i][k] * L[j][k];
                        }
                        if (i === j) {
                            const val = A[i][i] - sum;
                            L[i][j] = val > 0 ? Math.sqrt(val) : 1e-10;
                        } else {
                            L[i][j] = (A[i][j] - sum) / (L[j][j] || 1e-10);
                        }
                    }
                }
                
                // Forward substitution: Ly = b
                const y = new Float64Array(n);
                for (let i = 0; i < n; i++) {
                    let sum = 0;
                    for (let j = 0; j < i; j++) {
                        sum += L[i][j] * y[j];
                    }
                    y[i] = (b[i] - sum) / (L[i][i] || 1e-10);
                }
                
                // Backward substitution: L'x = y
                const x = new Float64Array(n);
                for (let i = n - 1; i >= 0; i--) {
                    let sum = 0;
                    for (let j = i + 1; j < n; j++) {
                        sum += L[j][i] * x[j];
                    }
                    x[i] = (y[i] - sum) / (L[i][i] || 1e-10);
                }
                
                return x;
            },
            
            // V6.0: Helper to get APM value for a player
            getPlayerApmValue: function(apmResults, playerName) {
                if (!apmResults || !apmResults.players) return null;
                
                // Try exact match
                let playerData = apmResults.players[playerName];
                
                // Try lowercase
                if (!playerData) {
                    const lowercaseName = playerName.toLowerCase().trim();
                    playerData = apmResults.players[lowercaseName];
                }
                
                // Try normalized match
                if (!playerData) {
                    const normalizedName = playerName.toLowerCase().trim().replace(/[''`´.]/g, '').replace(/\s+/g, ' ');
                    for (const [key, val] of Object.entries(apmResults.players)) {
                        if (key.toLowerCase().trim().replace(/[''`´.]/g, '').replace(/\s+/g, ' ') === normalizedName) {
                            playerData = val;
                            break;
                        }
                    }
                }
                
                if (!playerData) return null;
                
                return {
                    apm: playerData.totalAPM,
                    oapm: playerData.oAPM,
                    dapm: playerData.dAPM,
                    poss: playerData.totalPoss
                };
            },
            
            // EXPANDED Stat mappings for leaderboard - V3.1 with all stats
            leaderboardStatMapping: {
                // === RATINGS (from ORtg RAPM) ===
                'net': { useRapm: true, rapmStatName: 'ORtg', computeNet: true, higherBetter: true },
                'off': { useRapm: true, rapmStatName: 'ORtg', useDefCoef: false, higherBetter: true },
                'def': { useRapm: true, rapmStatName: 'ORtg', useDefCoef: true, flipSign: true, higherBetter: false },
                
                // === HYBRID APM (RAPM + Bayesian Box) - V5.11 ===
                'apm': { useApm: true, computeNet: true, higherBetter: true },
                'oapm': { useApm: true, useDefCoef: false, higherBetter: true },
                'dapm': { useApm: true, useDefCoef: true, higherBetter: true },
                
                // === OFFENSIVE FOUR FACTORS (from stat-specific RAPM) ===
                'offEfg': { useRapm: true, rapmStatName: 'eFG', useDefCoef: false, higherBetter: true },
                'offTov': { useRapm: true, rapmStatName: 'TOV', useDefCoef: false, flipSign: true, higherBetter: false },
                'offOreb': { useRapm: true, rapmStatName: 'OREB', useDefCoef: false, higherBetter: true },
                'offFtR': { useRapm: true, rapmStatName: 'FTR', useDefCoef: false, higherBetter: true },
                
                // === DEFENSIVE FOUR FACTORS (from stat-specific RAPM, defensive coefficients) ===
                'defEfg': { useRapm: true, rapmStatName: 'eFG', useDefCoef: true, flipSign: true, higherBetter: false },
                'defTov': { useRapm: true, rapmStatName: 'TOV', useDefCoef: true, higherBetter: true },
                'defOreb': { useRapm: true, rapmStatName: 'OREB', useDefCoef: true, flipSign: true, higherBetter: false },
                'defFtR': { useRapm: true, rapmStatName: 'FTR', useDefCoef: true, flipSign: true, higherBetter: false },
                
                // === PLAYMAKING & DEFENSE ===
                'offAst': { useRapm: true, rapmStatName: 'AST', useDefCoef: false, higherBetter: true },
                'defAst': { useRapm: true, rapmStatName: 'AST', useDefCoef: true, flipSign: true, higherBetter: false },
                'stlPct': { useRapm: true, rapmStatName: 'STL', useDefCoef: false, higherBetter: true },
                'blkPct': { useRapm: true, rapmStatName: 'BLK', useDefCoef: false, higherBetter: true },
                
                // === SHOT LOCATION - OFFENSIVE ===
                'rimPct': { useRapm: true, rapmStatName: 'RimPct', useDefCoef: false, higherBetter: true },
                'rimFreq': { useRapm: true, rapmStatName: 'RimFreq', useDefCoef: false, higherBetter: true },
                'midPct': { useRapm: true, rapmStatName: 'MidPct', useDefCoef: false, higherBetter: true },
                'midFreq': { useRapm: true, rapmStatName: 'MidFreq', useDefCoef: false, higherBetter: false },
                'threePct': { useRapm: true, rapmStatName: 'ThreePct', useDefCoef: false, higherBetter: true },
                'threeFreq': { useRapm: true, rapmStatName: 'ThreeFreq', useDefCoef: false, higherBetter: true },
                
                // === SHOT LOCATION - DEFENSIVE (opponent stats) ===
                'rimPctV': { useRapm: true, rapmStatName: 'RimPct', useDefCoef: true, flipSign: true, higherBetter: false },
                'rimFreqV': { useRapm: true, rapmStatName: 'RimFreq', useDefCoef: true, flipSign: true, higherBetter: false },
                'midPctV': { useRapm: true, rapmStatName: 'MidPct', useDefCoef: true, flipSign: true, higherBetter: false },
                'midFreqV': { useRapm: true, rapmStatName: 'MidFreq', useDefCoef: true, higherBetter: true },
                'threePctV': { useRapm: true, rapmStatName: 'ThreePct', useDefCoef: true, flipSign: true, higherBetter: false },
                'threeFreqV': { useRapm: true, rapmStatName: 'ThreeFreq', useDefCoef: true, flipSign: true, higherBetter: false },
                
                // === TRANSITION & SECONDARY - OFFENSIVE ===
                'fastBreak100': { useRapm: true, rapmStatName: 'FastBreak', useDefCoef: false, higherBetter: true },
                'secChance100': { useRapm: true, rapmStatName: 'SecondChance', useDefCoef: false, higherBetter: true },
                'ptsOffTov100': { useRapm: true, rapmStatName: 'PtsOffTov', useDefCoef: false, higherBetter: true },
                
                // === TRANSITION & SECONDARY - DEFENSIVE ===
                'fastBreak100V': { useRapm: true, rapmStatName: 'FastBreak', useDefCoef: true, flipSign: true, higherBetter: false },
                'secChance100V': { useRapm: true, rapmStatName: 'SecondChance', useDefCoef: true, flipSign: true, higherBetter: false },
                'ptsOffTov100V': { useRapm: true, rapmStatName: 'PtsOffTov', useDefCoef: true, flipSign: true, higherBetter: false },
                
                // === NON-RAPM STATS ===
                'clutchNet': { useRapm: false },
                'paceF': { useRapm: false },
                'paceV': { useRapm: false },
                // V5.10: Box Plus/Minus (from CSV or calculated)
                'bpm': { useRapm: false, higherBetter: true },
                'obpm': { useRapm: false, higherBetter: true },
                'dbpm': { useRapm: false, higherBetter: true }
            },
            
            // V3.0 Enhanced: Get RAPM value for any stat
            getPlayerRapmValue: function(rapmResults, playerName, leaderboardStat) {
                const mapping = this.leaderboardStatMapping[leaderboardStat];
                if (!mapping || !mapping.useRapm || !rapmResults || !rapmResults.stats) return null;
                
                const statResults = rapmResults.stats[mapping.rapmStatName];
                if (!statResults || statResults.error) return null;
                
                // V4.9.8.7.31 FIX: Use normalizePlayerName for consistent matching across all systems
                const normalizedName = normalizePlayerName(playerName);
                
                // Try exact normalized match first
                let playerData = statResults[normalizedName];
                
                // If not found, try lowercase match (for backwards compatibility)
                if (!playerData) {
                    const lowercaseName = playerName.toLowerCase().trim();
                    playerData = statResults[lowercaseName];
                }
                
                // If still not found, try fuzzy match using fuzzyMatchPlayerName
                if (!playerData) {
                    for (const key of Object.keys(statResults)) {
                        if (typeof statResults[key] === 'object' && fuzzyMatchPlayerName(playerName, key)) {
                            playerData = statResults[key];
                            break;
                        }
                    }
                }
                
                if (!playerData) return null;
                
                // Get stat config for context
                const statConfig = this.statConfigs[mapping.rapmStatName];
                const statDetails = rapmResults.statDetails ? rapmResults.statDetails[mapping.rapmStatName] : null;
                
                if (mapping.computeNet) {
                    // Net rating: combine offensive and defensive coefficients
                    const oRAPM = playerData.oRAPM || 0;
                    const dRAPM = playerData.dRAPM || 0;
                    let netRAPM = oRAPM + dRAPM;
                    
                    return {
                        rapm: netRAPM,
                        oRAPM: oRAPM,
                        dRAPM: dRAPM,
                        totalPoss: playerData.totalPoss,
                        leagueAvg: rapmResults.leagueAverages[mapping.rapmStatName] || 0,
                        statName: mapping.rapmStatName,
                        higherBetter: mapping.higherBetter
                    };
                }
                
                // Single coefficient (offensive or defensive)
                let rapmValue = mapping.useDefCoef ? playerData.dRAPM : playerData.oRAPM;
                
                // Flip sign if needed (e.g., for defensive stats where lower opponent value is better)
                if (mapping.flipSign) rapmValue = -rapmValue;
                
                return {
                    rapm: rapmValue,
                    oRAPM: playerData.oRAPM,
                    dRAPM: playerData.dRAPM,
                    totalPoss: playerData.totalPoss,
                    leagueAvg: rapmResults.leagueAverages[mapping.rapmStatName] || 0,
                    statName: mapping.rapmStatName,
                    higherBetter: mapping.higherBetter,
                    useDefCoef: mapping.useDefCoef
                };
            },
            
            shouldUseRapm: function(leaderboardStat) {
                const mapping = this.leaderboardStatMapping[leaderboardStat];
                return mapping && mapping.useRapm === true;
            },
            
            // V3.0: Get all RAPM stats for a player (useful for detailed views)
            getPlayerAllRapmStats: function(rapmResults, playerName) {
                if (!rapmResults || !rapmResults.stats) return null;
                
                const normalizedName = normalizePlayerName(playerName);
                const allStats = {};
                
                Object.keys(rapmResults.stats).forEach(statKey => {
                    const statResults = rapmResults.stats[statKey];
                    if (!statResults || statResults.error) return;
                    
                    // Try exact match first
                    let playerData = statResults[normalizedName];
                    
                    // Try fuzzy match if not found
                    if (!playerData) {
                        for (const key of Object.keys(statResults)) {
                            if (typeof statResults[key] === 'object' && fuzzyMatchPlayerName(playerName, key)) {
                                playerData = statResults[key];
                                break;
                            }
                        }
                    }
                    
                    if (!playerData) return;
                    
                    const config = this.statConfigs[statKey];
                    allStats[statKey] = {
                        oRAPM: playerData.oRAPM,
                        dRAPM: playerData.dRAPM,
                        netRAPM: playerData.oRAPM + playerData.dRAPM,
                        totalPoss: playerData.totalPoss,
                        leagueAvg: rapmResults.leagueAverages[statKey] || 0,
                        name: config ? config.name : statKey,
                        higherBetter: config ? config.higherBetter : true
                    };
                });
                
                return allStats;
            }
        };
        
        // Async RAPM calculation V2.0 with all improvements
        // Now uses pre-computed leagueAverages for consistency
        // Ratings (Off/Def/Net) derived via calcSimulatedRatings from adjusted Four Factors
        async function calculateRAPMAsync(matchupData, filtered, allLineupsMap, lambda, leagueAverages, onProgress) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    try {
                        // Validate calculation engine integrity
                        const _Ξ_ENGINE_CHECK = typeof _ΞCore !== 'undefined' &&
                            _ΞCore.ν !== 'REVOKED' &&
                            typeof _ΞCore.π === 'function' &&
                            _ΞCore.α === 0.4;

                        if(!_Ξ_ENGINE_CHECK) {
                            resolve({ error: 'Calculation engine unavailable', code: 'LICENSE_REQUIRED' });
                            return;
                        }

                        if (!leagueAverages) {
                            resolve({ error: 'League averages not provided' });
                            return;
                        }
                        
                        onProgress(5, 'Building stints from matchup data...');
                        
                        // Step 1: Build stints with additional fields for stat-specific weights
                        const stints = [];
                        matchupData.forEach(m => {
                            const poss = parseFloat(m.Possessions) || 0;
                            if (poss < 1) return;
                            
                            // V6.1: Apply merge rules before processing
                            const homePlayers = (m.Home_Lineup || '').split(',').map(p => applyGlobalPlayerMerge(p.trim()).toLowerCase()).filter(p => p);
                            const awayPlayers = (m.Away_Lineup || '').split(',').map(p => applyGlobalPlayerMerge(p.trim()).toLowerCase()).filter(p => p);
                            if (homePlayers.length < 3 || awayPlayers.length < 3) return;
                            
                            const homeFgm = parseFloat(m.Home_FGM) || 0, homeFga = parseFloat(m.Home_FGA) || 0;
                            const home3pm = parseFloat(m['Home_3PM']) || 0, home3pa = parseFloat(m['Home_3PA']) || 0;
                            const homeFta = parseFloat(m.Home_FTA) || 0, homeOreb = parseFloat(m.Home_OREB) || 0;
                            const homeDreb = parseFloat(m.Home_DREB) || 0, homeTov = parseFloat(m.Home_TOV) || 0;
                            const homeAst = parseFloat(m.Home_AST) || 0, homeStl = parseFloat(m.Home_STL) || 0;
                            const homeBlk = parseFloat(m.Home_BLK) || 0;
                            
                            const awayFgm = parseFloat(m.Away_FGM) || 0, awayFga = parseFloat(m.Away_FGA) || 0;
                            const away3pm = parseFloat(m['Away_3PM']) || 0, away3pa = parseFloat(m['Away_3PA']) || 0;
                            const awayFta = parseFloat(m.Away_FTA) || 0, awayOreb = parseFloat(m.Away_OREB) || 0;
                            const awayDreb = parseFloat(m.Away_DREB) || 0, awayTov = parseFloat(m.Away_TOV) || 0;
                            const awayAst = parseFloat(m.Away_AST) || 0, awayStl = parseFloat(m.Away_STL) || 0;
                            const awayBlk = parseFloat(m.Away_BLK) || 0;
                            
                            const homePoss = calcPoss(homeFga, homeOreb, homeTov, homeFta);
                            const awayPoss = calcPoss(awayFga, awayOreb, awayTov, awayFta);
                            
                            // V4.9.8.7.31 FIX: Use Basketball Reference TOV% formula for consistency
                            const homeTovDenom = homeFga + 0.44 * homeFta + homeTov;
                            const awayTovDenom = awayFga + 0.44 * awayFta + awayTov;
                            
                            stints.push({
                                homeTeam: m.Home_Team, awayTeam: m.Away_Team,
                                homePlayers, awayPlayers, possessions: poss,
                                // Store FGA for stat-specific weighting
                                homeFga, awayFga,
                                // Four Factors (for RAPM regression)
                                homeEfg: homeFga > 0 ? ((homeFgm + 0.5 * home3pm) / homeFga) * 100 : 0,
                                homeTovPct: homeTovDenom > 0 ? (homeTov / homeTovDenom) * 100 : 0,
                                homeOrebPct: (homeOreb + awayDreb) > 0 ? (homeOreb / (homeOreb + awayDreb)) * 100 : 0,
                                homeFtRate: homeFga > 0 ? (homeFta / homeFga) * 100 : 0,
                                homeAstPct: homeFgm > 0 ? (homeAst / homeFgm) * 100 : 0,
                                awayEfg: awayFga > 0 ? ((awayFgm + 0.5 * away3pm) / awayFga) * 100 : 0,
                                awayTovPct: awayTovDenom > 0 ? (awayTov / awayTovDenom) * 100 : 0,
                                awayOrebPct: (awayOreb + homeDreb) > 0 ? (awayOreb / (awayOreb + homeDreb)) * 100 : 0,
                                awayFtRate: awayFga > 0 ? (awayFta / awayFga) * 100 : 0,
                                awayAstPct: awayFgm > 0 ? (awayAst / awayFgm) * 100 : 0,
                                // Defensive stats: direct measurement of defensive production
                                homeStlPct: awayPoss > 0 ? (homeStl / awayPoss) * 100 : 0,
                                homeBlkPct: (awayFga - away3pa) > 0 ? (homeBlk / (awayFga - away3pa)) * 100 : 0,
                                awayStlPct: homePoss > 0 ? (awayStl / homePoss) * 100 : 0,
                                awayBlkPct: (homeFga - home3pa) > 0 ? (awayBlk / (homeFga - home3pa)) * 100 : 0,
                            });
                        });
                        
                        if (stints.length < 20) {
                            resolve({ error: 'Insufficient matchup data (' + stints.length + ' stints). Need at least 20.' });
                            return;
                        }
                        
                        onProgress(15, 'Building lineup index (' + stints.length + ' stints)...');
                        
                        // Step 2: Build lineup index
                        const lineupSet = new Set();
                        const lineupPoss = new Map();
                        stints.forEach(stint => {
                            const homeKey = stint.homePlayers.sort().join('|');
                            const awayKey = stint.awayPlayers.sort().join('|');
                            lineupSet.add(homeKey);
                            lineupSet.add(awayKey);
                            lineupPoss.set(homeKey, (lineupPoss.get(homeKey) || 0) + stint.possessions);
                            lineupPoss.set(awayKey, (lineupPoss.get(awayKey) || 0) + stint.possessions);
                        });
                        
                        const lineupList = Array.from(lineupSet);
                        const lineupToIdx = new Map(lineupList.map((l, i) => [l, i]));
                        const n = lineupList.length;
                        
                        // Step 3: Compute adaptive lambda
                        const adaptiveInfo = RAPMEngine.computeAdaptiveLambda(lineupPoss, lambda, stints.length * 2);
                        const effectiveLambda = adaptiveInfo.lambda;
                        
                        onProgress(25, 'Calculating RAPM for ' + n + ' lineups (λ_eff=' + effectiveLambda.toFixed(1) + ')...');
                        
                        // Step 4: Define stat configurations - FOUR FACTORS ONLY (no OffRtg)
                        // Off/Def/Net ratings will be derived via calcSimulatedRatings
                        const statConfigs = [
                            // Four Factors - use off/def model
                            { name: 'eFG%', getter: (s, isHome) => isHome ? s.homeEfg : s.awayEfg, higherBetter: true, model: 'offdef', leagueAvgOff: leagueAverages.offEfg, leagueAvgDef: leagueAverages.defEfg },
                            { name: 'TOV%', getter: (s, isHome) => isHome ? s.homeTovPct : s.awayTovPct, higherBetter: false, model: 'offdef', leagueAvgOff: leagueAverages.offTov, leagueAvgDef: leagueAverages.defTov },
                            { name: 'OREB%', getter: (s, isHome) => isHome ? s.homeOrebPct : s.awayOrebPct, higherBetter: true, model: 'offdef', leagueAvgOff: leagueAverages.offOreb, leagueAvgDef: leagueAverages.defOreb },
                            { name: 'FTRate', getter: (s, isHome) => isHome ? s.homeFtRate : s.awayFtRate, higherBetter: true, model: 'offdef', leagueAvgOff: leagueAverages.offFtR, leagueAvgDef: leagueAverages.defFtR },
                            { name: 'AST%', getter: (s, isHome) => isHome ? s.homeAstPct : s.awayAstPct, higherBetter: true, model: 'offdef', leagueAvgOff: leagueAverages.astPct, leagueAvgDef: leagueAverages.oppAstPct },
                            // Direct defensive stats: model defensive production directly
                            { name: 'STL%', getter: (s, isHome) => isHome ? s.homeStlPct : s.awayStlPct, higherBetter: true, model: 'direct', isDefStat: true, leagueAvgDef: leagueAverages.stlPct },
                            { name: 'BLK%', getter: (s, isHome) => isHome ? s.homeBlkPct : s.awayBlkPct, higherBetter: true, model: 'direct', isDefStat: true, leagueAvgDef: leagueAverages.blkPct },
                        ];
                        
                        const results = {};
                        
                        // Step 5: Calculate each stat with appropriate model
                        statConfigs.forEach((config, idx) => {
                            const progress = 25 + Math.round((idx / statConfigs.length) * 55);
                            onProgress(progress, 'Solving ' + config.name + ' (' + config.model + ' model)...');
                            
                            try {
                                let solveResult;
                                
                                if (config.model === 'direct') {
                                    // Direct defensive stat model (single factor)
                                    solveResult = RAPMEngine.solveDirectDefensiveStat(
                                        stints, lineupList, lineupToIdx, 
                                        config.getter, effectiveLambda, config.name
                                    );
                                    
                                    // For direct model, we only have defensive coefficients
                                    const defRAPM = {};
                                    lineupList.forEach((lineup, i) => {
                                        defRAPM[lineup] = { 
                                            value: solveResult.coefficients[i], 
                                            se: solveResult.standardErrors[i],
                                            poss: lineupPoss.get(lineup) || 0 
                                        };
                                    });
                                    
                                    results[config.name] = { 
                                        oRAPM: null, // No offensive component
                                        dRAPM: defRAPM, 
                                        higherBetter: config.higherBetter, 
                                        leagueAvgOff: config.leagueAvgOff || 0,
                                        leagueAvgDef: config.leagueAvgDef || 0,
                                        isDefStat: true,
                                        isDirect: true,
                                        sigmaSquared: solveResult.sigmaSquared,
                                        converged: solveResult.converged,
                                        nObs: solveResult.nObs
                                    };
                                } else {
                                    // Standard off/def model
                                    solveResult = RAPMEngine.solveForStat(
                                        stints, lineupList, lineupToIdx, 
                                        config.getter, effectiveLambda, config.name
                                    );
                                    
                                    const oRAPM = {};
                                    const dRAPM = {};
                                    lineupList.forEach((lineup, i) => {
                                        oRAPM[lineup] = { 
                                            value: solveResult.coefficients[i], 
                                            se: solveResult.standardErrors[i],
                                            poss: lineupPoss.get(lineup) || 0 
                                        };
                                        dRAPM[lineup] = { 
                                            value: solveResult.coefficients[n + i], 
                                            se: solveResult.standardErrors[n + i],
                                            poss: lineupPoss.get(lineup) || 0 
                                        };
                                    });
                                    
                                    results[config.name] = { 
                                        oRAPM, dRAPM, 
                                        higherBetter: config.higherBetter, 
                                        leagueAvgOff: config.leagueAvgOff || 0,
                                        leagueAvgDef: config.leagueAvgDef || 0,
                                        isDefStat: config.isDefStat || false,
                                        isDirect: false,
                                        sigmaSquared: solveResult.sigmaSquared,
                                        converged: solveResult.converged,
                                        nObs: solveResult.nObs
                                    };
                                }
                            } catch (err) {
                                console.warn('[RAPM V2] Failed for ' + config.name + ':', err);
                            }
                        });
                        
                        onProgress(85, 'Aggregating results for filtered lineups...');
                        
                        // Step 6: Aggregate for filtered lineups with uncertainty propagation
                        const aggregated = {};
                        Object.keys(results).forEach(statName => {
                            const { oRAPM, dRAPM, higherBetter, leagueAvgOff, leagueAvgDef, isDefStat, isDirect, sigmaSquared, converged, nObs } = results[statName];
                            let totalPoss = 0, oSum = 0, dSum = 0, matchCount = 0;
                            let oVarSum = 0, dVarSum = 0; // For uncertainty propagation
                            
                            filtered.forEach(l => {
                                // V6.1: Apply merge rules before generating key
                                const key = l.Lineup.split(',').map(p => applyGlobalPlayerMerge(p.trim()).toLowerCase()).sort().join('|');
                                const dData = dRAPM ? dRAPM[key] : null;
                                const oData = oRAPM ? oRAPM[key] : null;
                                
                                if (isDirect) {
                                    // Direct model: only defensive coefficient
                                    if (dData) {
                                        const poss = l.COMB_POSS || dData.poss;
                                        totalPoss += poss;
                                        dSum += dData.value * poss;
                                        dVarSum += (dData.se * dData.se) * (poss * poss);
                                        matchCount++;
                                    }
                                } else {
                                    // Off/def model
                                    if (oData && dData) {
                                        const poss = l.COMB_POSS || oData.poss;
                                        totalPoss += poss;
                                        oSum += oData.value * poss;
                                        dSum += dData.value * poss;
                                        oVarSum += (oData.se * oData.se) * (poss * poss);
                                        dVarSum += (dData.se * dData.se) * (poss * poss);
                                        matchCount++;
                                    }
                                }
                            });
                            
                            if (matchCount > 0 && totalPoss > 0) {
                                const oRAPMagg = isDirect ? 0 : oSum / totalPoss;
                                const dRAPMagg = dSum / totalPoss;
                                // Propagated standard error: SE(weighted avg) = sqrt(sum(w²σ²)) / sum(w)
                                const oSE = isDirect ? 0 : Math.sqrt(oVarSum) / totalPoss;
                                const dSE = Math.sqrt(dVarSum) / totalPoss;
                                
                                aggregated[statName] = {
                                    oRAPM: oRAPMagg,
                                    dRAPM: dRAPMagg,
                                    oSE: oSE,
                                    dSE: dSE,
                                    // 95% confidence intervals
                                    oCI95: [oRAPMagg - 1.96 * oSE, oRAPMagg + 1.96 * oSE],
                                    dCI95: [dRAPMagg - 1.96 * dSE, dRAPMagg + 1.96 * dSE],
                                    coverage: matchCount / filtered.length,
                                    matchCount,
                                    higherBetter,
                                    leagueAvgOff,
                                    leagueAvgDef,
                                    isDefStat,
                                    isDirect,
                                    converged,
                                    totalPoss,
                                    // Statistical significance flags
                                    oSignificant: Math.abs(oRAPMagg) > 1.96 * oSE,
                                    dSignificant: Math.abs(dRAPMagg) > 1.96 * dSE
                                };
                            }
                        });
                        
                        onProgress(100, 'Complete!');
                        
                        // V4.7.2: Aggregate player-level RAPM from lineup RAPM
                        const playerRAPM = {};
                        const playerPoss = {};
                        
                        Object.keys(results).forEach(statName => {
                            const { oRAPM, dRAPM, isDefStat, isDirect } = results[statName];
                            playerRAPM[statName] = {};
                            
                            // Iterate through all lineups
                            const lineupKeys = dRAPM ? Object.keys(dRAPM) : (oRAPM ? Object.keys(oRAPM) : []);
                            lineupKeys.forEach(lineupKey => {
                                const players = lineupKey.split('|');
                                const oData = oRAPM ? oRAPM[lineupKey] : null;
                                const dData = dRAPM ? dRAPM[lineupKey] : null;
                                const poss = (dData?.poss || oData?.poss || 0);
                                
                                players.forEach(player => {
                                    if (!playerRAPM[statName][player]) {
                                        playerRAPM[statName][player] = { 
                                            oSum: 0, dSum: 0, 
                                            oVarSum: 0, dVarSum: 0,
                                            totalPoss: 0, lineupCount: 0 
                                        };
                                    }
                                    const p = playerRAPM[statName][player];
                                    
                                    if (isDirect) {
                                        // Direct defensive stat
                                        if (dData) {
                                            p.dSum += dData.value * poss;
                                            p.dVarSum += (dData.se * dData.se) * (poss * poss);
                                            p.totalPoss += poss;
                                            p.lineupCount++;
                                        }
                                    } else {
                                        // Off/def model
                                        if (oData && dData) {
                                            p.oSum += oData.value * poss;
                                            p.dSum += dData.value * poss;
                                            p.oVarSum += (oData.se * oData.se) * (poss * poss);
                                            p.dVarSum += (dData.se * dData.se) * (poss * poss);
                                            p.totalPoss += poss;
                                            p.lineupCount++;
                                        }
                                    }
                                    
                                    // Track overall player poss
                                    if (!playerPoss[player]) playerPoss[player] = 0;
                                    playerPoss[player] = Math.max(playerPoss[player], p.totalPoss);
                                });
                            });
                            
                            // Compute final player-level values
                            Object.keys(playerRAPM[statName]).forEach(player => {
                                const p = playerRAPM[statName][player];
                                if (p.totalPoss > 0) {
                                    p.oRAPM = p.oSum / p.totalPoss;
                                    p.dRAPM = p.dSum / p.totalPoss;
                                    p.oSE = Math.sqrt(p.oVarSum) / p.totalPoss;
                                    p.dSE = Math.sqrt(p.dVarSum) / p.totalPoss;
                                }
                            });
                        });
                        
                        resolve({
                            stats: aggregated,
                            rawLineupRAPM: results, // V4.7.2: Include raw lineup data
                            playerRAPM: playerRAPM, // V4.7.2: Player-level aggregated RAPM
                            playerCount: Object.keys(playerPoss).length,
                            stintCount: stints.length,
                            lineupCount: n,
                            lambda: effectiveLambda,
                            baseLambda: lambda,
                            adaptiveInfo,
                            leagueAverages, // Pass through for use in RAPMSection
                            version: '2.0'
                        });
                        
                    } catch (err) {
                        console.error('[RAPM V2] Calculation failed:', err);
                        resolve({ error: err.message });
                    }
                }, 50);
            });
        }
        
        // Get performance class from percentile (for ALL color coding now)
        // V4.9.8.7.30: Updated to handle both number and object { rank, total, pct } formats
        function getPerfFromPct(p) {
            const pct = (typeof p === 'object' && p !== null && 'pct' in p) ? p.pct : p;
            return pct >= 90 ? 'perf-excellent' : pct >= 70 ? 'perf-good' : pct >= 30 ? 'perf-average' : pct >= 10 ? 'perf-below' : 'perf-poor';
        }
        
        function getOppClass(pct) { 
            return pct >= 70 ? 'opp-hard' : pct >= 55 ? 'opp-tough' : pct <= 30 ? 'opp-easy' : pct <= 45 ? 'opp-soft' : 'opp-neutral'; 
        }
        
        // V4.9.8.7.30: Updated getPctClass to handle both number and object formats
        function getPctClass(p) {
            const pct = (typeof p === 'object' && p !== null && 'pct' in p) ? p.pct : p;
            return pct >= 90 ? 'pct-elite' : pct >= 70 ? 'pct-good' : pct >= 30 ? 'pct-avg' : pct >= 10 ? 'pct-below' : 'pct-poor';
        }
        
        function getNetColor(n) { return n >= 8 ? '#10b981' : n >= 3 ? '#84cc16' : n >= -3 ? '#eab308' : n >= -8 ? '#f97316' : '#ef4444'; }
        function getDeltaClass(d, goodIfNeg = true) { const threshold = 1.5; const adj = goodIfNeg ? -d : d; return Math.abs(d) < threshold ? 'delta-neutral' : adj > 0 ? 'delta-positive' : 'delta-negative'; }
        function getDeltaClassPct(d, goodIfPos = true) { const threshold = 1; const adj = goodIfPos ? d : -d; return Math.abs(d) < threshold ? 'delta-neutral' : adj > 0 ? 'delta-positive' : 'delta-negative'; }
        function getCompClass(d, higherBetter = true) { const adj = higherBetter ? d : -d; return Math.abs(d) < 0.5 ? 'comp-same' : adj > 0 ? 'comp-better' : 'comp-worse'; }

        // CSV Parser - Protected function
        function parseCSV(text) {
            // License validation - data parsing requires valid license
            if(typeof _ΞCore === 'undefined' || _ΞCore.ν === 'REVOKED') {
                console.error('License validation failed');
                return [];
            }
            const lines = text.trim().split('\n'), headers = [];
            let cur = '', inQ = false;
            for (let c of lines[0]) { if (c === '"') inQ = !inQ; else if (c === ',' && !inQ) { headers.push(cur.trim().replace(/\r/g, '')); cur = ''; } else cur += c; }
            headers.push(cur.trim().replace(/\r/g, ''));
            return lines.slice(1).map(line => {
                const vals = []; cur = ''; inQ = false;
                for (let c of line) { if (c === '"') inQ = !inQ; else if (c === ',' && !inQ) { vals.push(cur.trim().replace(/\r/g, '')); cur = ''; } else cur += c; }
                vals.push(cur.trim().replace(/\r/g, ''));
                const obj = {}; headers.forEach((h, i) => obj[h] = vals[i] || ''); return obj;
            });
        }

        // Register critical functions in integrity chain
        if(typeof _ΞCore !== 'undefined' && _ΞCore.υ) {
            _ΞCore.υ(parseCSV, 'parseCSV');
            _ΞCore.υ(calcSimulatedRatings, 'calcSimulatedRatings');
        }

        // V6.1: Global player merge rules storage - updated from React component
        // This allows global functions to access merge rules
        let _globalPlayerMergeRules = [];

        // V6.1: Global function to apply player merge using stored rules
        // V6.1.1: Handle transitive merges (if A→B and B→C, then A→C)
        function applyGlobalPlayerMerge(playerName) {
            if (!playerName || _globalPlayerMergeRules.length === 0) return playerName;
            let currentName = playerName.trim();
            let iterations = 0;
            const maxIterations = 10; // Prevent infinite loops from circular rules

            while (iterations < maxIterations) {
                let found = false;
                for (const rule of _globalPlayerMergeRules) {
                    // If current name matches an alias, resolve to primary
                    if (rule.aliases && rule.aliases.includes(currentName)) {
                        currentName = rule.primary;
                        found = true;
                        break;
                    }
                }
                if (!found) break; // No more transformations possible
                iterations++;
            }
            return currentName;
        }

        // V6.1: Function to update global merge rules (called from React)
        function setGlobalPlayerMergeRules(rules) {
            _globalPlayerMergeRules = rules || [];
        }

        function normalizeLineup(lineup) {
            if (!lineup) return '';
            // Core validation check - returns empty if system compromised
            const _Ξ_valid = typeof _ΞCore !== 'undefined' && _ΞCore.γ === 0;
            if(!_Ξ_valid && _ΞCore?.ν === 'REVOKED') return '';
            // V6.1: Apply merge rules before normalization
            return lineup.split(',').map(p => applyGlobalPlayerMerge(p.trim()).toLowerCase()).sort().join('|');
        }

        // Normalize player name for fuzzy matching - removes apostrophes, extra spaces, special chars
        // V6.1: Now also applies merge rules
        function normalizePlayerName(name) {
            if (!name) return '';
            // Apply merge first
            const merged = applyGlobalPlayerMerge(name);
            return merged.toLowerCase()
                .replace(/[''`´'ʼˈ]/g, '')  // Remove all apostrophe variants
                .replace(/[^a-z0-9\s-]/g, '')  // Remove other special chars except hyphen
                .replace(/\s+/g, ' ')  // Normalize multiple spaces
                .trim();
        }
        
        // Enhanced fuzzy player name matching - handles abbreviated first names, apostrophes, special chars
        function fuzzyMatchPlayerName(name1, name2) {
            if (!name1 || !name2) return false;
            const n1 = normalizePlayerName(name1);
            const n2 = normalizePlayerName(name2);
            
            // Exact match after normalization
            if (n1 === n2) return true;
            
            // Split into parts
            const parts1 = n1.split(' ').filter(p => p.length > 0);
            const parts2 = n2.split(' ').filter(p => p.length > 0);
            
            if (parts1.length < 2 || parts2.length < 2) return false;
            
            // Check if last names match exactly
            const lastName1 = parts1[parts1.length - 1];
            const lastName2 = parts2[parts2.length - 1];
            if (lastName1 !== lastName2) return false;
            
            // Check if first name is abbreviated version or starts with same letters
            const firstName1 = parts1[0];
            const firstName2 = parts2[0];
            
            // One is prefix of the other (Aaryn vs Aaryndeep, Rian vs R'ian -> rian)
            if (firstName1.startsWith(firstName2) || firstName2.startsWith(firstName1)) return true;
            
            // First 3+ chars match (handles typos and abbreviations)
            if (firstName1.length >= 3 && firstName2.length >= 3) {
                if (firstName1.substring(0, 3) === firstName2.substring(0, 3)) return true;
            }
            
            // First 2 chars match (for shorter names like "Ri" in Rian)
            if (firstName1.length >= 2 && firstName2.length >= 2) {
                if (firstName1.substring(0, 2) === firstName2.substring(0, 2)) return true;
            }
            
            return false;
        }
        
        // Find best matching player name from a map using fuzzy matching
        function findPlayerInMap(playerName, map) {
            const norm = normalizePlayerName(playerName);
            
            // Try exact match first
            if (map.has(norm)) return map.get(norm);
            
            // Try fuzzy match
            for (const [key, value] of map.entries()) {
                if (fuzzyMatchPlayerName(playerName, key)) {
                    return value;
                }
            }
            
            return null;
        }
        
        // Find player in seasonStatsMap with team verification for better accuracy
        function findPlayerWithTeam(playerName, teamName, seasonStatsMap) {
            const norm = normalizePlayerName(playerName);
            
            // Try exact match first
            if (seasonStatsMap.has(norm)) {
                const stats = seasonStatsMap.get(norm);
                if (!teamName || stats.team === teamName) return stats;
            }
            
            // Try fuzzy match with team verification
            for (const [key, value] of seasonStatsMap.entries()) {
                // Must be same team (if team is provided)
                if (teamName && value.team !== teamName) continue;
                
                if (fuzzyMatchPlayerName(playerName, key)) {
                    return value;
                }
                
                // Also check if the stored name matches
                if (value.name && fuzzyMatchPlayerName(playerName, value.name)) {
                    return value;
                }
            }
            
            return null;
        }

        // Calculate percentile from team averages
        function calcTeamAvgPercentile(val, teamAvgValues, higher = true) {
            if (!teamAvgValues || !teamAvgValues.length) return 50;
            const validVals = teamAvgValues.filter(v => !isNaN(v) && isFinite(v));
            if (!validVals.length) return 50;
            
            const sorted = [...validVals].sort((a, b) => a - b);
            let countBelow = 0;
            for (const v of sorted) {
                if (higher) {
                    if (v < val) countBelow++;
                } else {
                    if (v > val) countBelow++;
                }
            }
            return (countBelow / sorted.length) * 100;
        }
        
        // V4.9.8.7.30: Calculate league rank (1st = best) along with percentile for color coding
        function calcTeamRankAndPct(val, teamAvgValues, higher = true) {
            if (!teamAvgValues || !teamAvgValues.length) return { rank: 1, total: 1, pct: 50 };
            const validVals = teamAvgValues.filter(v => !isNaN(v) && isFinite(v));
            if (!validVals.length) return { rank: 1, total: 1, pct: 50 };
            
            const total = validVals.length;
            // Sort: for "higher is better", sort descending so best is first
            // for "lower is better", sort ascending so best is first
            const sorted = higher 
                ? [...validVals].sort((a, b) => b - a)  // Descending for higher=better
                : [...validVals].sort((a, b) => a - b); // Ascending for lower=better
            
            // Find rank (1-indexed, where 1 = best)
            let rank = 1;
            for (let i = 0; i < sorted.length; i++) {
                if (higher) {
                    if (val >= sorted[i]) { rank = i + 1; break; }
                } else {
                    if (val <= sorted[i]) { rank = i + 1; break; }
                }
                rank = i + 2; // If we haven't found it yet, it's worse than current
            }
            rank = Math.min(rank, total); // Cap at total
            
            // Calculate percentile for color coding (keep existing logic)
            let countBelow = 0;
            for (const v of validVals) {
                if (higher) {
                    if (v < val) countBelow++;
                } else {
                    if (v > val) countBelow++;
                }
            }
            const pct = (countBelow / total) * 100;
            
            return { rank, total, pct };
        }

        // V4.6.3: Professional-level Four Factors to Rating simulation
        // Uses Dean Oliver's theoretical framework with empirically-derived coefficients
        // Based on Kubatko et al. (2007) and Rosenbaum's coefficients
        function calcSimulatedRatings(fourFactors, leagueAvg) {
            // ═══════════════════════════════════════════════════════════════════════════
            // LICENSE VALIDATION - Function requires valid license state
            // ═══════════════════════════════════════════════════════════════════════════
            if(typeof _ΞCore === 'undefined' || _ΞCore.ν === 'REVOKED') {
                return { ortg: NaN, drtg: NaN, net: NaN, error: 'LICENSE_REQUIRED' };
            }

            if (!fourFactors || !leagueAvg) return null;

            // Dean Oliver's Four Factors weights (empirically derived coefficients)
            // These represent approximate points per 100 possessions per percentage point
            // Coefficients use protected mathematical constants for validation
            const _baseMultiplier = typeof _ΞCore !== 'undefined' ? (_ΞCore.δ / 100) : 1;
            const COEFFICIENTS = {
                // Offensive coefficients (positive impact on ORTG)
                offEfg: 1.85 * _baseMultiplier,    // Each 1% better eFG% ≈ +1.85 pts/100
                offTov: -1.25 * _baseMultiplier,   // Each 1% higher TOV% ≈ -1.25 pts/100
                offOreb: 0.60 * _baseMultiplier,   // Each 1% better OREB% ≈ +0.60 pts/100
                offFtR: 0.45 * _baseMultiplier,    // Each 1% higher FT Rate ≈ +0.45 pts/100
                // Defensive coefficients (impact on DRTG - signs inverted for "good defense")
                defEfg: 1.85 * _baseMultiplier,    // Each 1% opponent eFG% ≈ +1.85 pts allowed
                defTov: -1.25 * _baseMultiplier,   // Each 1% opponent TOV% ≈ -1.25 pts allowed (we force TOs)
                defOreb: 0.60 * _baseMultiplier,   // Each 1% opponent OREB% ≈ +0.60 pts allowed
                defFtR: 0.45 * _baseMultiplier     // Each 1% opponent FT Rate ≈ +0.45 pts allowed
            };
            
            // Calculate ORTG using Four Factors deviation from league average
            const ortgDelta = 
                COEFFICIENTS.offEfg * (fourFactors.offEfg - leagueAvg.offEfg) +
                COEFFICIENTS.offTov * (fourFactors.offTov - leagueAvg.offTov) +
                COEFFICIENTS.offOreb * (fourFactors.offOreb - leagueAvg.offOreb) +
                COEFFICIENTS.offFtR * (fourFactors.offFtR - leagueAvg.offFtR);
            
            // Calculate DRTG using Four Factors deviation from league average
            // Note: For defense, league avg references what opponents typically do
            const drtgDelta = 
                COEFFICIENTS.defEfg * (fourFactors.defEfg - leagueAvg.defEfg) +
                COEFFICIENTS.defTov * (fourFactors.defTov - leagueAvg.defTov) +
                COEFFICIENTS.defOreb * (fourFactors.defOreb - leagueAvg.defOreb) +
                COEFFICIENTS.defFtR * (fourFactors.defFtR - leagueAvg.defFtR);
            
            // League average rating (typically ~100 in NBA, varies by league)
            const leagueAvgRating = (leagueAvg.off + leagueAvg.def) / 2 || 100;
            
            // Final simulated ratings
            const simOrtg = leagueAvgRating + ortgDelta;
            const simDrtg = leagueAvgRating + drtgDelta;
            const simNet = simOrtg - simDrtg;
            
            return {
                ortg: simOrtg,
                drtg: simDrtg,
                net: simNet,
                ortgDelta,
                drtgDelta,
                coefficients: COEFFICIENTS
            };
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // PLAYER/TEAM PHOTO COMPONENT - Auto-fetches from Tauri parent
        // ═══════════════════════════════════════════════════════════════════════════
        function PlayerPhoto({ playerName, teamName, leagueName, size = 48, showPlaceholder = true }) {
            const [imageSrc, setImageSrc] = useState(null);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(false);

            useEffect(() => {
                if (!playerName || !teamName) return;
                if (!window.ImageBridge || !window.ImageBridge.isInIframe()) return;

                // Check cache first
                const cached = window.ImageBridge.getCachedImage('player', playerName, teamName);
                if (cached) {
                    setImageSrc(cached);
                    return;
                }

                setLoading(true);
                window.ImageBridge.requestPlayerImage(playerName, teamName, leagueName)
                    .then(dataUrl => {
                        if (dataUrl) {
                            setImageSrc(dataUrl);
                        } else {
                            setError(true);
                        }
                    })
                    .catch(() => setError(true))
                    .finally(() => setLoading(false));
            }, [playerName, teamName, leagueName]);

            // Generate initials for placeholder
            const initials = playerName ? playerName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase() : '?';

            if (imageSrc) {
                return e('img', {
                    src: imageSrc,
                    alt: playerName,
                    className: 'player-photo',
                    style: { width: size, height: size },
                    onError: () => setError(true)
                });
            }

            if (!showPlaceholder) return null;

            return e('div', {
                className: `player-photo-placeholder ${loading ? 'player-photo-loading' : ''}`,
                style: { width: size, height: size, fontSize: size * 0.4 },
                title: playerName
            }, initials);
        }

        function TeamLogo({ teamName, leagueName, size = 32 }) {
            const [imageSrc, setImageSrc] = useState(null);
            const [loading, setLoading] = useState(false);

            useEffect(() => {
                if (!teamName) return;
                if (!window.ImageBridge || !window.ImageBridge.isInIframe()) return;

                const cached = window.ImageBridge.getCachedImage('team', teamName, '');
                if (cached) {
                    setImageSrc(cached);
                    return;
                }

                setLoading(true);
                window.ImageBridge.requestTeamImage(teamName, leagueName)
                    .then(dataUrl => {
                        if (dataUrl) setImageSrc(dataUrl);
                    })
                    .catch(() => {})
                    .finally(() => setLoading(false));
            }, [teamName, leagueName]);

            if (!imageSrc) return null;

            return e('img', {
                src: imageSrc,
                alt: teamName,
                className: size <= 24 ? 'team-logo-sm' : 'team-logo',
                style: { width: size, height: size },
                onError: (e) => { e.target.style.display = 'none'; }
            });
        }

        // Make components globally available
        window.PlayerPhoto = PlayerPhoto;
        window.TeamLogo = TeamLogo;

        function App() {
            // ═══════════════════════════════════════════════════════════════════════════
            // INTEGRITY CHECKPOINT - App component requires valid license
            // ═══════════════════════════════════════════════════════════════════════════
            const _Ξ_APP_VALID = useMemo(() => {
                if(typeof _ΞCore === 'undefined') return false;
                if(_ΞCore.ν === 'REVOKED') return false;
                // Check core functions exist
                if(typeof _ΞCore.π !== 'function') return false;
                if(typeof calcPoss !== 'function') return false;
                // Verify mathematical constants
                if(_ΞCore.α !== 0.4 || _ΞCore.δ !== 100) return false;
                return _ΞCore.ν === 'VALIDATED' || _ΞCore.ν === 'GRACE';
            }, []);

            // Periodic integrity verification
            useEffect(() => {
                const checkIntegrity = () => {
                    if(typeof _ΞCore === 'undefined') return false;
                    if(_ΞCore.ν === 'REVOKED') return false;
                    if(_ΞCore.χ && _ΞCore.χ().length > 0) return false;
                    return true;
                };

                const interval = setInterval(() => {
                    if(!checkIntegrity()) {
                        document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0f172a;color:#f87171;font-family:sans-serif;flex-direction:column;"><h1>Runtime Integrity Error</h1><p style="color:#94a3b8;margin-top:16px;">Application components have been modified.</p></div>';
                    }
                }, 30000);

                return () => clearInterval(interval);
            }, []);

            const [lineupCsv, setLineupCsv] = useState('');
            const [playerCsv, setPlayerCsv] = useState('');
            const [matchupCsv, setMatchupCsv] = useState('');
            const [seasonCsv, setSeasonCsv] = useState('');
            const [assistComboCsv, setAssistComboCsv] = useState('');
            const [clutchCsv, setClutchCsv] = useState('');
            const [stintsCsv, setStintsCsv] = useState('');
            const [playerStintsCsv, setPlayerStintsCsv] = useState('');
            const [lineupFile, setLineupFile] = useState('');
            const [playerStintsFile, setPlayerStintsFile] = useState('');
            const [playerFile, setPlayerFile] = useState('');
            const [stintsFile, setStintsFile] = useState('');
            const [matchupFile, setMatchupFile] = useState('');
            const [seasonFile, setSeasonFile] = useState('');
            const [assistComboFile, setAssistComboFile] = useState('');
            const [clutchFile, setClutchFile] = useState('');
            const [folderLoaded, setFolderLoaded] = useState(null);

            // License validation state - triggers re-render after unlock to recalculate data
            const [licenseValidated, setLicenseValidated] = useState(false);

            // Expose the license state setter globally so the unlock function can trigger a re-render
            useEffect(() => {
                window._slbSetLicenseValidated = setLicenseValidated;
            }, []);

            // ═══════════════════════════════════════════════════════════════════════════
            // MOBILE STATE - Responsive layout and touch interactions
            // ═══════════════════════════════════════════════════════════════════════════
            const [isMobileView, setIsMobileView] = useState(() => window.MobileDetect?.isMobile || window.innerWidth <= 768);
            const [isTabletView, setIsTabletView] = useState(() => window.MobileDetect?.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024));
            const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
            const [mobileActiveSection, setMobileActiveSection] = useState('main'); // 'main', 'controls', 'stats', 'leaderboard', 'export'

            // Listen for resize events to update mobile state
            useEffect(() => {
                const handleResize = () => {
                    const mobile = window.MobileDetect?.isMobile || window.innerWidth <= 768;
                    const tablet = window.MobileDetect?.isTablet || (window.innerWidth > 768 && window.innerWidth <= 1024);
                    setIsMobileView(mobile);
                    setIsTabletView(tablet);
                };

                window.addEventListener('resize', handleResize);
                window.addEventListener('orientationchange', () => setTimeout(handleResize, 100));

                return () => {
                    window.removeEventListener('resize', handleResize);
                    window.removeEventListener('orientationchange', handleResize);
                };
            }, []);

            const [team, setTeam] = useState('');
            const [selPlayers, setSelPlayers] = useState({ p1: '', p2: '', p3: '', p4: '', p5: '' });
            const [exPlayers, setExPlayers] = useState({ e1: '', e2: '', e3: '', e4: '' });
            const [showAdv, setShowAdv] = useState(false);
            const [showModal, setShowModal] = useState(false);
            const [showImpact, setShowImpact] = useState(false);
            const [showTeamAvg, setShowTeamAvg] = useState(false);
            const [showAllLineups, setShowAllLineups] = useState(false);
            const [selectedLineup, setSelectedLineup] = useState(null);
            const [showMatchupsModal, setShowMatchupsModal] = useState(false);
            // NEW: Modal states for shot distribution and turnovers
            const [showShotModal, setShowShotModal] = useState(false);
            const [shotModalType, setShotModalType] = useState('offense'); // 'offense' or 'defense'
            const [showTOModal, setShowTOModal] = useState(false);
            const [toModalType, setTOModalType] = useState('committed'); // 'committed' or 'forced'
            const [showOrebModal, setShowOrebModal] = useState(false);
            const [showAstModal, setShowAstModal] = useState(false);
            const [showLeaderboard, setShowLeaderboard] = useState(false);
            // V5.12: Collapsed header state (collapsed by default)
            const [headerExpanded, setHeaderExpanded] = useState(false);
            const [lbStat, setLbStat] = useState('net');
            const [lbTeam, setLbTeam] = useState('');
            const [lbMinMins, setLbMinMins] = useState(50);
            // Leaderboard view mode: 'table' or 'chart'
            const [lbViewMode, setLbViewMode] = useState('table');
            // Chart axes state
            const [lbChartX, setLbChartX] = useState('scoringBattle');
            const [lbChartY, setLbChartY] = useState('possBattle');
            // Leaderboard luck adjustment slider (0-100)
            const [lbLuckAdj, setLbLuckAdj] = useState(100);
            // Leaderboard sorting state
            const [lbSortCol, setLbSortCol] = useState('diff');
            const [lbSortDir, setLbSortDir] = useState('desc');
            // V4.9.8.6: Leaderboard subtab state (onoff vs individual)
            const [lbSubtab, setLbSubtab] = useState('fullTable');
            const [lbIndivStat, setLbIndivStat] = useState('pts75');
            // Team Leaderboard sort state
            const [teamLbSortBy, setTeamLbSortBy] = useState('adjNet');
            const [teamLbSortAsc, setTeamLbSortAsc] = useState(false);
            const [teamLbFullscreen, setTeamLbFullscreen] = useState(false);
            const [teamLbShowGroups, setTeamLbShowGroups] = useState({
                'Adjusted': true, 'Points Added': true, 'Ratings': false,
                'Off 4 Factors': false, 'Def 4 Factors': false,
                'Off Shot%': false, 'Def Shot%': false,
                'Off Vol': false, 'Def Vol': false,
                'Trans Off': true, 'Trans Def': true,
                'Clutch': false, 'Misc': false
            });
            const [lbIndivSortAsc, setLbIndivSortAsc] = useState(false); // V5.14.2: Sort direction for individual stats
            // V4.9.8.7.17: Show all players in leaderboard (default 50)
            const [lbShowAll, setLbShowAll] = useState(false);
            // V4.9.8.7.17: Toggle to use RAPM or On/Off in leaderboard
            const [lbUseRapm, setLbUseRapm] = useState(true);
            // On/Off Stats tab: method toggle - 'onOff' = ON-OFF diff, 'vsTeam' = ON vs Team Avg
            const [lbOnOffMethod, setLbOnOffMethod] = useState('onOff');
            // Full Table tab: method toggle - 'vsTeam' = ON vs Team Avg, 'onOff' = strict ON-OFF diff
            const [ftOnOffMethod, setFtOnOffMethod] = useState('onOff');
            // V4.0: Luck adjustment sliders (0-100)
            const [offLuckAdj, setOffLuckAdj] = useState(0);
            const [defLuckAdj, setDefLuckAdj] = useState(0);
            // V4.1: RAPM-Adjusted Stats (async calculation)
            const [showRAPM, setShowRAPM] = useState(false);
            const [rapmLambda, setRapmLambda] = useState(800);
            const [rapmStats, setRapmStats] = useState(null);
            const [isCalculatingRAPM, setIsCalculatingRAPM] = useState(false);
            const [rapmProgress, setRapmProgress] = useState(0);
            const [rapmMessage, setRapmMessage] = useState('');
            // V4.2: Tab and WOWY state
            const [activeTab, setActiveTab] = useState('analyzer');
            const [analyzerSubtab, setAnalyzerSubtab] = useState('main');
            // V5.5: SOS Tab Date/Game Range Filters
            const [sosFilterType, setSosFilterType] = useState('all'); // 'all', 'dateRange', 'lastN', 'gameRange'
            const [sosDateStart, setSosDateStart] = useState('');
            const [sosDateEnd, setSosDateEnd] = useState('');
            const [sosLastNGames, setSosLastNGames] = useState(10);
            const [sosGameStart, setSosGameStart] = useState(1);
            const [sosGameEnd, setSosGameEnd] = useState(20);
            const [wowyPlayers, setWowyPlayers] = useState([]);
            const [showTeammateImpact, setShowTeammateImpact] = useState(false); // V4.9.8.7: Teammate impact analysis
            const [showBestCombos, setShowBestCombos] = useState(false); // V4.9.8.7.28: Best combinations feature
            const [bestCombosSize, setBestCombosSize] = useState(3); // 2, 3, 4, or 5 player combos
            const [bestCombosCount, setBestCombosCount] = useState(10); // How many to show
            const [showVsStarters, setShowVsStarters] = useState(false); // VS Starters WOWY mode
            // V4.2.2: Opponent Quality Filters
            const [oppFilters, setOppFilters] = useState([]);
            const [showOppFilterPanel, setShowOppFilterPanel] = useState(false);
            // V4.3: Stat Impact Analysis Modal
            const [showStatImpactModal, setShowStatImpactModal] = useState(false);
            const [statImpactResults, setStatImpactResults] = useState(null);
            const [isCalculatingImpact, setIsCalculatingImpact] = useState(false);
            const [statImpactExpanded, setStatImpactExpanded] = useState(false); // V4.9.8.7.18: Collapsible stat impact section
            const [statImpactOpp, setStatImpactOpp] = useState(null); // V5.0: Optional opponent filter for stat impact tab
            const [statImpactMinPoss, setStatImpactMinPoss] = useState(10); // V5.0: Min possessions for stat impact analysis
            // V4.6.1: Player Impact Correlation
            const [showPlayerImpactModal, setShowPlayerImpactModal] = useState(false);
            const [playerImpactResults, setPlayerImpactResults] = useState(null);
            const [playerImpactPlayer, setPlayerImpactPlayer] = useState('');
            const [playerImpactExpanded, setPlayerImpactExpanded] = useState(false);
            // V4.3: Best Combinations vs Opponent
            const [showCombosModal, setShowCombosModal] = useState(false);
            const [combosResults, setCombosResults] = useState(null);
            const [combosOppTeam, setCombosOppTeam] = useState('');
            const [combosSize, setCombosSize] = useState(2);
            const [combosMinPoss, setCombosMinPoss] = useState(10);
            const [isCalculatingCombos, setIsCalculatingCombos] = useState(false);
            // V4.3.4: Counter Lineups vs Selected Players
            const [showCounterModal, setShowCounterModal] = useState(false);
            const [counterResults, setCounterResults] = useState(null);
            const [isCalculatingCounter, setIsCalculatingCounter] = useState(false);
            const [counterMinPoss, setCounterMinPoss] = useState(5);
            const [counterComboSize, setCounterComboSize] = useState(2);
            const [counterTeam, setCounterTeam] = useState('');
            const [counterIncludePlayers, setCounterIncludePlayers] = useState(''); // V5.0: Text input for player names to include
            // V4.3.7: eFG% Modeling slider - controls prior strength k (possessions needed for ~50% weight)
            const [efgModelWeight, setEfgModelWeight] = useState(100);
            // V4.3.5: Lineup Builder tab
            const [builderPlayers, setBuilderPlayers] = useState({ p1: '', p2: '', p3: '', p4: '', p5: '' });
            const [builderResults, setBuilderResults] = useState(null);
            const [wowyMinPoss, setWowyMinPoss] = useState(20);
            // V4.2.3: Bayesian Shrinkage and Minimum Possession Threshold
            const [minMatchupPoss, setMinMatchupPoss] = useState(0);
            const [bayesianShrinkage, setBayesianShrinkage] = useState(false);
            const [shrinkagePriorWeight, setShrinkagePriorWeight] = useState(30);
            // V4.2: WOWY Luck adjustment sliders
            const [wowyOffLuckAdj, setWowyOffLuckAdj] = useState(0);
            const [wowyDefLuckAdj, setWowyDefLuckAdj] = useState(0);
            // V4.9.8.8: RAPM Luck Adjustment (player-level, not per-stint)
            const [rapmLuckAdj, setRapmLuckAdj] = useState(0);
            // V4.4: Comparison Tab State
            const [compareTeamA, setCompareTeamA] = useState('');
            const [compareTeamB, setCompareTeamB] = useState('');
            const [comparePlayersA, setComparePlayersA] = useState(['', '', '', '', '']);
            const [comparePlayersB, setComparePlayersB] = useState(['', '', '', '', '']);
            const [compareLuckAdj, setCompareLuckAdj] = useState(0);
            // V4.6.1: Prior Strength for Bayesian regression to league average
            const [comparePriorStrength, setComparePriorStrength] = useState(0);
            // V4.4: Opponent strength adjustment per stat (0-100)
            const [compareOppAdj, setCompareOppAdj] = useState({
                offEfg: 0, offTov: 0, offOreb: 0, offFtR: 0,
                defEfg: 0, defTov: 0, defOreb: 0, defFtR: 0
            });
            // V4.6.3: Master slider for universal opp qual adjustment
            const [compareMasterOppAdj, setCompareMasterOppAdj] = useState(0);
            // V4.4: Global relative-to-league toggle
            const [showRelativeToLeague, setShowRelativeToLeague] = useState(false);
            // V4.9.8.7: Improved Assist Graph state
            const [assistMinThreshold, setAssistMinThreshold] = useState(3);
            const [assistHoveredPlayer, setAssistHoveredPlayer] = useState(null);
            const [assistViewMode, setAssistViewMode] = useState('force'); // 'force' or 'arc'
            // V4.9.8.7.17: Game Range Analysis tab state
            const [gameRangeTeam, setGameRangeTeam] = useState('');
            const [gameRangePlayers, setGameRangePlayers] = useState({ p1: '', p2: '', p3: '', p4: '', p5: '' });
            const [gameRangeStart, setGameRangeStart] = useState(1);
            const [gameRangeEnd, setGameRangeEnd] = useState(10);
            const [gameRangeResults, setGameRangeResults] = useState(null)
            const [gameRangeWinFilter, setGameRangeWinFilter] = useState('all') // 'all', 'wins', 'losses'
            // V5.12: Date range filtering for game range
            const [gameRangeDateMode, setGameRangeDateMode] = useState('games'); // 'games' or 'dates'
            const [gameRangeDateStart, setGameRangeDateStart] = useState('');
            const [gameRangeDateEnd, setGameRangeDateEnd] = useState('');
            // V4.5: Schedule strength adjustment for main Four Factors
            const [mainScheduleAdj, setMainScheduleAdj] = useState({
                offEfg: 0, offTov: 0, offOreb: 0, offFtR: 0,
                defEfg: 0, defTov: 0, defOreb: 0, defFtR: 0
            });
            // V4.6.3: Master slider for main Four Factors universal adjustment
            const [mainMasterScheduleAdj, setMainMasterScheduleAdj] = useState(0);
            
            // V4.9.6: Collapsible section states (collapsed by default)
            const [showPlayerFiltersSection, setShowPlayerFiltersSection] = useState(false);
            const [showExtraStatsSection, setShowExtraStatsSection] = useState(false);
            const [showOppQualitySection, setShowOppQualitySection] = useState(false);
            const [showMinPossSection, setShowMinPossSection] = useState(false);
            const [showLuckAdjSection, setShowLuckAdjSection] = useState(false);
            const [showStatImpactSection, setShowStatImpactSection] = useState(false);
            const [showPlayerImpactSection, setShowPlayerImpactSection] = useState(false);
            const [showEfgModelSection, setShowEfgModelSection] = useState(false);
            
            // V6.0: BartTorvik-style Leaderboard Table
            const [leaderboardViewMode, setLeaderboardViewMode] = useState('cards'); // 'cards' or 'table'
            const [leaderboardTableColumns, setLeaderboardTableColumns] = useState(['net', 'off', 'def', 'offEfg', 'defEfg', 'offTov', 'defTov', 'offOreb', 'defOreb']);
            const [leaderboardTableTeamFilter, setLeaderboardTableTeamFilter] = useState('');
            const [leaderboardTableMinMins, setLeaderboardTableMinMins] = useState(50);
            const [leaderboardTableSortBy, setLeaderboardTableSortBy] = useState('net');
            const [leaderboardTableSortAsc, setLeaderboardTableSortAsc] = useState(false);
            const [leaderboardTableShowSettings, setLeaderboardTableShowSettings] = useState(true);
            const [mobileFiltersCollapsed, setMobileFiltersCollapsed] = useState(true);
            const [mobilePlayerColExpanded, setMobilePlayerColExpanded] = useState(false);
            const [mobileTeamColExpanded, setMobileTeamColExpanded] = useState(false);
            const [leaderboardTableUseOnOff, setLeaderboardTableUseOnOff] = useState(true);
            const [leaderboardTableFullscreen, setLeaderboardTableFullscreen] = useState(false);
            const [leaderboardTableStatMode, setLeaderboardTableStatMode] = useState('onoff'); // 'onoff', 'individual', 'rapm'
            const [leaderboardTableOffLuck, setLeaderboardTableOffLuck] = useState(0); // 0-100%
            const [leaderboardTableDefLuck, setLeaderboardTableDefLuck] = useState(0); // 0-100%
            const [leaderboardTableLambda, setLeaderboardTableLambda] = useState(800); // RAPM lambda
            const [leaderboardTableShowFilters, setLeaderboardTableShowFilters] = useState(false);
            const [leaderboardTableStatFilters, setLeaderboardTableStatFilters] = useState({}); // { statKey: { min: null, max: null } }
            const [leaderboardTableVsStarters, setLeaderboardTableVsStarters] = useState(false); // VS. Starters mode
            const [leaderboardTableVsStartersMinGames, setLeaderboardTableVsStartersMinGames] = useState(3); // Min games started to be considered a "regular starter"
            const [fullTableLoading, setFullTableLoading] = useState(false); // Loading indicator for full table
            const [leaderboardTableDisplayLimit, setLeaderboardTableDisplayLimit] = useState(50); // Display limit for performance (load more button)

            // V8.1: Show loading indicator when heavy computation parameters change
            useEffect(() => {
                setFullTableLoading(true);
                setLeaderboardTableDisplayLimit(50); // Reset display limit when filters change
                // Clear loading after a brief delay to allow UI to show spinner before computation
                const timer = setTimeout(() => setFullTableLoading(false), 150);
                return () => clearTimeout(timer);
            }, [leaderboardTableVsStarters, leaderboardTableVsStartersMinGames, leaderboardTableOffLuck, leaderboardTableDefLuck, leaderboardTableTeamFilter, leaderboardTableMinMins]);

            // Player Radar Chart Modal State
            const [showRadarModal, setShowRadarModal] = useState(false);
            const [radarPlayer, setRadarPlayer] = useState(null); // { player, team, stats }
            const [radarMode, setRadarMode] = useState('individual'); // 'individual' or 'onoff'
            const [percentileMode, setPercentileMode] = useState('league'); // 'league' or 'position' - V6.6: Position-based percentiles
            // V6.9: Store full table's data for modal percentile consistency (using ref to avoid re-renders)
            const fullTableDataRef = React.useRef({ data: null, percentileData: null });

            // V6.1: Settings Tab State
            const [themeColor, setThemeColor] = useState(() => {
                try {
                    const saved = localStorage.getItem('lineupAnalyzer_themeColor');
                    return saved || 'blue';
                } catch (e) { return 'blue'; }
            });

            // V6.2: Secondary theme color for accents
            const [secondaryThemeColor, setSecondaryThemeColor] = useState(() => {
                try {
                    const saved = localStorage.getItem('lineupAnalyzer_secondaryThemeColor');
                    return saved || 'purple';
                } catch (e) { return 'purple'; }
            });

            // V6.2: Team filter states for player merge UI
            const [mergePrimaryTeam, setMergePrimaryTeam] = useState('');
            const [mergeAliasTeam, setMergeAliasTeam] = useState('');

            // V6.1: Player Name Merging System
            // playerMergeRules: Array of { primary: 'Canonical Name', aliases: ['Variation 1', 'Variation 2'] }
            const [playerMergeRules, setPlayerMergeRules] = useState(() => {
                try {
                    const saved = localStorage.getItem('lineupAnalyzer_playerMergeRules');
                    const rules = saved ? JSON.parse(saved) : [];
                    // Initialize global rules immediately
                    setGlobalPlayerMergeRules(rules);
                    return rules;
                } catch (e) { return []; }
            });

            // Save merge rules to localStorage and sync to global variable whenever they change
            useEffect(() => {
                try {
                    localStorage.setItem('lineupAnalyzer_playerMergeRules', JSON.stringify(playerMergeRules));
                    // V6.1: Sync to global variable for use by global functions
                    setGlobalPlayerMergeRules(playerMergeRules);
                } catch (e) { console.warn('Could not save player merge rules to localStorage'); }
            }, [playerMergeRules]);

            // Save theme colors to localStorage whenever they change
            useEffect(() => {
                try {
                    localStorage.setItem('lineupAnalyzer_themeColor', themeColor);
                    localStorage.setItem('lineupAnalyzer_secondaryThemeColor', secondaryThemeColor);

                    // V6.2: Extended color definitions with background colors
                    // V6.3: Added white and black themes
                    const colors = {
                        blue: { primary: '#60a5fa', primaryRgb: '96, 165, 250', bgDark: '#0c1929', bgMid: '#0f2942', isLight: false },
                        purple: { primary: '#a78bfa', primaryRgb: '167, 139, 250', bgDark: '#1a0f29', bgMid: '#261542', isLight: false },
                        green: { primary: '#4ade80', primaryRgb: '74, 222, 128', bgDark: '#0a1f14', bgMid: '#0f3321', isLight: false },
                        orange: { primary: '#fb923c', primaryRgb: '251, 146, 60', bgDark: '#1f150a', bgMid: '#33200f', isLight: false },
                        cyan: { primary: '#22d3ee', primaryRgb: '34, 211, 238', bgDark: '#0a1f24', bgMid: '#0f333b', isLight: false },
                        pink: { primary: '#f472b6', primaryRgb: '244, 114, 182', bgDark: '#1f0a18', bgMid: '#330f28', isLight: false },
                        red: { primary: '#f87171', primaryRgb: '248, 113, 113', bgDark: '#1f0a0a', bgMid: '#330f0f', isLight: false },
                        // V6.3: White theme - light background with dark text
                        white: { primary: '#374151', primaryRgb: '55, 65, 81', bgDark: '#f8fafc', bgMid: '#ffffff', isLight: true },
                        // V6.3: Black theme - pure dark with subtle accents
                        black: { primary: '#9ca3af', primaryRgb: '156, 163, 175', bgDark: '#000000', bgMid: '#0a0a0a', isLight: false },
                        // V6.3: Gold and Silver accent colors
                        gold: { primary: '#fbbf24', primaryRgb: '251, 191, 36', bgDark: '#1f1a0a', bgMid: '#332b0f', isLight: false },
                        silver: { primary: '#9ca3af', primaryRgb: '156, 163, 175', bgDark: '#111827', bgMid: '#1f2937', isLight: false }
                    };

                    const tc = colors[themeColor] || colors.blue;
                    const sc = colors[secondaryThemeColor] || colors.purple;

                    // Apply primary theme colors
                    document.documentElement.style.setProperty('--theme-primary', tc.primary);
                    document.documentElement.style.setProperty('--theme-primary-rgb', tc.primaryRgb);

                    // Apply secondary theme colors as accent
                    document.documentElement.style.setProperty('--theme-accent', sc.primary);
                    document.documentElement.style.setProperty('--theme-accent-rgb', sc.primaryRgb);

                    // V6.2: Apply background colors based on primary theme
                    document.documentElement.style.setProperty('--theme-bg', tc.bgDark);
                    document.documentElement.style.setProperty('--theme-bg-secondary', tc.bgMid);

                    // Apply to body background with gradient
                    document.body.style.background = `linear-gradient(135deg, ${tc.bgDark} 0%, ${tc.bgMid} 50%, ${tc.bgDark} 100%)`;
                    document.body.style.backgroundAttachment = 'fixed';

                    // V6.3: Handle light theme mode (white theme)
                    if (tc.isLight) {
                        document.body.classList.add('light-theme');
                        document.body.style.color = '#1a1a2e';
                    } else {
                        document.body.classList.remove('light-theme');
                        document.body.style.color = '#e2e8f0';
                    }

                } catch (e) { console.warn('Could not apply theme color'); }
            }, [themeColor, secondaryThemeColor]);

            // V6.1: Player Name Normalization Function - applies merge rules
            // This function takes a player name and returns the canonical (primary) name if a merge rule exists
            // V6.1.1: Handle transitive merges (if A→B and B→C, then A→C)
            const applyPlayerMerge = useCallback((playerName) => {
                if (!playerName || playerMergeRules.length === 0) return playerName;
                let currentName = playerName.trim();
                let iterations = 0;
                const maxIterations = 10; // Prevent infinite loops from circular rules

                while (iterations < maxIterations) {
                    let found = false;
                    for (const rule of playerMergeRules) {
                        // If current name matches an alias, resolve to primary
                        if (rule.aliases && rule.aliases.includes(currentName)) {
                            currentName = rule.primary;
                            found = true;
                            break;
                        }
                    }
                    if (!found) break; // No more transformations possible
                    iterations++;
                }
                return currentName;
            }, [playerMergeRules]);

            // V6.1: Apply merge to a lineup string (comma or pipe separated)
            const applyMergeToLineup = useCallback((lineupStr, separator = ',') => {
                if (!lineupStr || playerMergeRules.length === 0) return lineupStr;
                return lineupStr.split(separator).map(p => applyPlayerMerge(p.trim())).join(separator);
            }, [applyPlayerMerge, playerMergeRules]);

            // V5.0: Export View State
            const [exportMode, setExportMode] = useState('leaderboard'); // 'leaderboard', 'fourfactors', 'shotdist', 'lineups', 'wowy'
            const [exportTitle, setExportTitle] = useState('Player Leaderboard');
            const [exportSubtitle, setExportSubtitle] = useState('Advanced Analytics');
            const [exportStat, setExportStat] = useState('net');
            const [exportTeam, setExportTeam] = useState('');
            const [exportMinMins, setExportMinMins] = useState(50);
            const [exportMinPoss, setExportMinPoss] = useState(100);
            const [exportTopN, setExportTopN] = useState(10);
            const [exportSortAsc, setExportSortAsc] = useState(false); // false = best to worst (desc), true = worst to best (asc)
            const [exportOffLuckAdj, setExportOffLuckAdj] = useState(0); // 0-100% offensive luck adjustment for leaderboard
            const [exportDefLuckAdj, setExportDefLuckAdj] = useState(0); // 0-100% defensive luck adjustment for leaderboard
            const [exportWowyPlayer, setExportWowyPlayer] = useState('');
            const [exportLineupTeam, setExportLineupTeam] = useState('');
            const [exportLineupMinPoss, setExportLineupMinPoss] = useState(50);
            const [exportFFTeam, setExportFFTeam] = useState('');
            const [exportFFPlayers, setExportFFPlayers] = useState({ p1: '', p2: '', p3: '', p4: '', p5: '' });
            const [exportShotTeam, setExportShotTeam] = useState('');
            const [exportShotPlayers, setExportShotPlayers] = useState({ p1: '', p2: '', p3: '', p4: '', p5: '' });
            // V5.1: Enhanced Export View State
            const [exportUseOnOff, setExportUseOnOff] = useState(true); // Individual stats vs On/Off toggle
            const [exportWowyTeam, setExportWowyTeam] = useState('');
            const [exportWowyPlayers, setExportWowyPlayers] = useState([]); // Selected players for WOWY (circular selection)
            const [exportWowyMinPoss, setExportWowyMinPoss] = useState(5); // Now represents minutes, not possessions
            const [exportPlayerImages, setExportPlayerImages] = useState(() => {
                // Load from localStorage if available
                try {
                    const saved = localStorage.getItem('lineupAnalyzer_playerImages');
                    return saved ? JSON.parse(saved) : {};
                } catch (e) { return {}; }
            }); // Player name -> image URL
            const [exportUseRapm, setExportUseRapm] = useState(false); // Use RAPM when available
            const [exportLineupTopN, setExportLineupTopN] = useState(10);
            
            // V5.2: Enhanced Leaderboard - Secondary stats option
            const [exportShowSecondary, setExportShowSecondary] = useState(true); // Show secondary stats on cards
            const [exportSecondaryStats, setExportSecondaryStats] = useState(['offEfg', 'defEfg', 'astPct', 'stlPct']); // Secondary stats to show
            
            // V5.2: Enhanced Four Factors Export
            const [exportFFShowStats, setExportFFShowStats] = useState(['offEfg', 'offTov', 'offOreb', 'offFtR', 'defEfg', 'defTov', 'defOreb', 'defFtR']); // Stats to show
            const [exportFFOrderBy, setExportFFOrderBy] = useState('net'); // Order teams by stat
            const [exportFFTeamMode, setExportFFTeamMode] = useState('all'); // 'all', 'select'
            const [exportFFSelectedTeams, setExportFFSelectedTeams] = useState([]); // Selected teams when in 'select' mode
            const [exportFFDateMode, setExportFFDateMode] = useState('all'); // 'all', 'after', 'before', 'range'
            const [exportFFDateAfter, setExportFFDateAfter] = useState('');
            const [exportFFDateBefore, setExportFFDateBefore] = useState('');
            const [exportFFTeamImages, setExportFFTeamImages] = useState({}); // Team name -> image URL
            
            // V5.3: Team totals for game-level date filtering
            const [teamTotalsCsv, setTeamTotalsCsv] = useState('');
            const [teamTotalsFile, setTeamTotalsFile] = useState('');
            const [exportFFGameRange, setExportFFGameRange] = useState({ start: 1, end: 100 }); // Game range selector
            // V5.12: Four Factors secondary stats toggle (ratings vs four factors detail)
            const [exportFFShowSecondary, setExportFFShowSecondary] = useState(true); // Show four factors breakdown
            const [exportFFSortedStatOnly, setExportFFSortedStatOnly] = useState(false); // Show only the sorted stat
            const [exportFFShowExtraStats, setExportFFShowExtraStats] = useState(true); // Show Rim/3PT/AST extra stats
            
            // V5.4: Enhanced Shot Distribution - Date/Game Range filtering
            const [exportShotDateMode, setExportShotDateMode] = useState('all');
            const [exportShotDateAfter, setExportShotDateAfter] = useState('');
            const [exportShotDateBefore, setExportShotDateBefore] = useState('');
            const [exportShotGameRange, setExportShotGameRange] = useState({ start: 1, end: 100 });
            const [exportShotTeamMode, setExportShotTeamMode] = useState('single'); // 'single' or 'all'
            
            // V5.4: Enhanced Best Lineups - All teams, date filtering, player images
            const [exportLineupTeamMode, setExportLineupTeamMode] = useState('single'); // 'single' or 'all'
            const [exportLineupDateMode, setExportLineupDateMode] = useState('all');
            const [exportLineupDateAfter, setExportLineupDateAfter] = useState('');
            const [exportLineupDateBefore, setExportLineupDateBefore] = useState('');
            const [exportLineupGameRange, setExportLineupGameRange] = useState({ start: 1, end: 100 });
            const [exportLineupPlayerImages, setExportLineupPlayerImages] = useState({}); // Player name -> image URL
            const [exportLineupSortBy, setExportLineupSortBy] = useState('netRtg'); // 'netRtg', 'offRtg', 'defRtg'
            const [exportLineupOffLuckAdj, setExportLineupOffLuckAdj] = useState(0); // 0-100% offensive luck adjustment
            const [exportLineupDefLuckAdj, setExportLineupDefLuckAdj] = useState(0); // 0-100% defensive luck adjustment
            
            // V5.4: Enhanced WOWY - Best combinations mode, player images, date filtering
            const [exportWowyMode, setExportWowyMode] = useState('single'); // 'single' or 'combinations'
            const [exportWowyDateMode, setExportWowyDateMode] = useState('all');
            const [exportWowyDateAfter, setExportWowyDateAfter] = useState('');
            const [exportWowyDateBefore, setExportWowyDateBefore] = useState('');
            const [exportWowyGameRange, setExportWowyGameRange] = useState({ start: 1, end: 100 });
            const [exportWowyPlayerImages, setExportWowyPlayerImages] = useState({}); // Player name -> image URL
            const [exportWowyCombosTopN, setExportWowyCombosTopN] = useState(10);
            const [exportWowySortAsc, setExportWowySortAsc] = useState(false); // false = best to worst (desc), true = worst to best (asc)
            const [exportWowyOffLuckAdj, setExportWowyOffLuckAdj] = useState(0); // 0-100% offensive luck adjustment
            const [exportWowyDefLuckAdj, setExportWowyDefLuckAdj] = useState(0); // 0-100% defensive luck adjustment
            
            // V5.5: Enhanced export features
            const [exportShowRelative, setExportShowRelative] = useState(false); // Show stats relative to team average (only for on-off mode)
            const [exportWowyCombosSize, setExportWowyCombosSize] = useState(3); // 2, 3, 4, 5 player combos like main WOWY
            const [exportWowySelectedPlayers, setExportWowySelectedPlayers] = useState([]); // Multiple player selection

            // V5.13: WOWY Teammate Impact Analysis mode for export view
            const [exportWowyShowTeammateImpact, setExportWowyShowTeammateImpact] = useState(false);

            // V5.13: WOWY Table View toggle (simple table vs cards)
            const [exportWowyTableView, setExportWowyTableView] = useState(false);

            // V5.6: Enhanced Leaderboard - Variable secondary stats count (1-10)
            const [exportSecondaryCount, setExportSecondaryCount] = useState(4); // How many secondary stats to show (1-10)
            
            // V5.6: Chart View as separate tab
            const [exportChartTitle, setExportChartTitle] = useState('Player Performance Chart');
            const [exportChartXLabel, setExportChartXLabel] = useState('');
            const [exportChartYLabel, setExportChartYLabel] = useState('');
            const [exportChartShowCorrelation, setExportChartShowCorrelation] = useState(false);
            const [exportChartShowLabels, setExportChartShowLabels] = useState(true); // Show player/team names on chart
            const [exportChartSmartLabels, setExportChartSmartLabels] = useState(false); // V5.24: Smart labels - only show outliers
            const [exportChartHighlightTeam, setExportChartHighlightTeam] = useState(''); // V5.24: Team to highlight when all teams shown
            const [exportChartX, setExportChartX] = useState('off'); // X-axis stat
            const [exportChartY, setExportChartY] = useState('def'); // Y-axis stat
            const [exportChartAbsolute, setExportChartAbsolute] = useState(false); // V5.8: false = ON-OFF (relative), true = raw ON (absolute)
            const [exportChartTwinPlot, setExportChartTwinPlot] = useState(false); // V5.9: Twin plot mode
            const [exportChartX2, setExportChartX2] = useState('offEfg'); // Second X-axis stat
            const [exportChartY2, setExportChartY2] = useState('defEfg'); // Second Y-axis stat
            const [exportChartAbsolute2, setExportChartAbsolute2] = useState(false); // Second chart: false = ON-OFF/vs. Lg Avg, true = Absolute
            const [exportChartDataMode, setExportChartDataMode] = useState('players'); // 'players' or 'teams'
            
            // V5.6: WOWY single player view - show teammate combos
            const [exportWowyShowTeammates, setExportWowyShowTeammates] = useState(true);
            
            // V5.6: Applied date filter state (for Four Factors)
            const [exportFFDateApplied, setExportFFDateApplied] = useState(false);
            
            // V5.13: SOS Export View State
            const [exportSOSDateMode, setExportSOSDateMode] = useState('all');
            const [exportSOSDateAfter, setExportSOSDateAfter] = useState('');
            const [exportSOSDateBefore, setExportSOSDateBefore] = useState('');
            const [exportSOSGameRange, setExportSOSGameRange] = useState({ start: 1, end: 100 });
            const [exportSOSTeamImages, setExportSOSTeamImages] = useState(() => {
                // Load from localStorage if available
                try {
                    const saved = localStorage.getItem('lineupAnalyzer_teamImages');
                    return saved ? JSON.parse(saved) : {};
                } catch (e) { return {}; }
            });
            const [exportSOSShowPA, setExportSOSShowPA] = useState(true); // Show Points Added Analysis
            const [exportSOSViewMode, setExportSOSViewMode] = useState('cards'); // 'cards' or 'tables'
            
            // V5.5: Date dropdown state for Four Factors (YYYY-MM-DD format)
            const [exportFFDateYear, setExportFFDateYear] = useState('');
            const [exportFFDateMonth, setExportFFDateMonth] = useState('');
            const [exportFFDateDay, setExportFFDateDay] = useState('');
            const [exportFFDateEndYear, setExportFFDateEndYear] = useState('');
            const [exportFFDateEndMonth, setExportFFDateEndMonth] = useState('');
            const [exportFFDateEndDay, setExportFFDateEndDay] = useState('');
            
            // Show/hide legends toggle
            const [exportShowLegend, setExportShowLegend] = useState(true);

            // ═══════════════════════════════════════════════════════════════════════════
            // V6.0: ADVANCED GAMES VIEW STATE (Embedded GAMEVIS)
            // ═══════════════════════════════════════════════════════════════════════════
            const [gvGameHtmlFiles, setGvGameHtmlFiles] = useState([]); // Array of {gameId, bsContent, pbpContent, scContent}
            const [gvFolderGames, setGvFolderGames] = useState([]); // Parsed game summaries
            const [gvCurrentGame, setGvCurrentGame] = useState(null); // Currently loaded game data
            const [gvView, setGvView] = useState('upload'); // 'upload', 'browser', 'game'
            const [gvTeamFilter, setGvTeamFilter] = useState('');
            const [gvLoading, setGvLoading] = useState(false);
            const [gvLoadProgress, setGvLoadProgress] = useState({ current: 0, total: 0 });
            const [gvError, setGvError] = useState('');
            const [gvActiveTab, setGvActiveTab] = useState('overview'); // Active tab within game view
            const [gvHalfStatsView, setGvHalfStatsView] = useState('first'); // 'first', 'second', 'ot1', etc.
            const [gvLineupTeamFilter, setGvLineupTeamFilter] = useState('all');
            const [gvLineupSortBy, setGvLineupSortBy] = useState('minutes');
            const [gvLineupViewMode, setGvLineupViewMode] = useState('cards');
            // Player table column groups collapse state
            const [gvCollapsedGroups, setGvCollapsedGroups] = useState({});
            const [gvPlayerSortKey, setGvPlayerSortKey] = useState('minutes');
            const [gvPlayerSortAsc, setGvPlayerSortAsc] = useState(false);
            const [gvPlayerTableTeam, setGvPlayerTableTeam] = useState('all'); // 'all', 'home', 'away'
            const [gvExpandedGames, setGvExpandedGames] = useState({}); // Track expanded game rows in library
            // ═══════════════════════════════════════════════════════════════════════════

            // Comprehensive stat definitions for legends
            const statDefinitions = {
                // Player Ratings (ON-OFF mode)
                net: { name: 'Net Rating', desc: 'Points scored minus points allowed per 100 possessions', unit: 'pts/100' },
                off: { name: 'Off Rating', desc: 'Points scored per 100 possessions', unit: 'pts/100' },
                def: { name: 'Def Rating', desc: 'Points allowed per 100 possessions (lower is better)', unit: 'pts/100' },
                
                // Team Ratings (Absolute)
                adjOrtg: { name: 'Adj Off Rtg', desc: 'SOS-adjusted offensive rating', unit: 'pts/100' },
                adjDrtg: { name: 'Adj Def Rtg', desc: 'SOS-adjusted defensive rating (lower is better)', unit: 'pts/100' },
                adjNet: { name: 'Adj Net Rtg', desc: 'SOS-adjusted net rating (adjORtg - adjDRtg)', unit: 'pts/100' },
                rawOrtg: { name: 'Raw Off Rtg', desc: 'Unadjusted offensive rating', unit: 'pts/100' },
                rawDrtg: { name: 'Raw Def Rtg', desc: 'Unadjusted defensive rating (lower is better)', unit: 'pts/100' },
                rawNet: { name: 'Raw Net Rtg', desc: 'Unadjusted net rating', unit: 'pts/100' },
                
                // Team Ratings vs League Average
                adjOrtgVsLg: { name: 'Adj Off vs Lg', desc: 'Adjusted offensive rating relative to league average', unit: '±pts/100' },
                adjDrtgVsLg: { name: 'Adj Def vs Lg', desc: 'Adjusted defensive rating vs league (+ = better defense)', unit: '±pts/100' },
                adjNetVsLg: { name: 'Adj Net vs Lg', desc: 'Adjusted net rating relative to league average', unit: '±pts/100' },
                rawOrtgVsLg: { name: 'Raw Off vs Lg', desc: 'Raw offensive rating relative to league average', unit: '±pts/100' },
                rawDrtgVsLg: { name: 'Raw Def vs Lg', desc: 'Raw defensive rating vs league (+ = better defense)', unit: '±pts/100' },
                rawNetVsLg: { name: 'Raw Net vs Lg', desc: 'Raw net rating relative to league average', unit: '±pts/100' },
                
                // Record & Expected Wins
                wins: { name: 'Wins', desc: 'Total games won', unit: 'games' },
                losses: { name: 'Losses', desc: 'Total games lost', unit: 'games' },
                winPct: { name: 'Win %', desc: 'Percentage of games won', unit: '%' },
                pythExpWins: { name: 'Pyth xWins', desc: 'Expected wins based on points scored/allowed (Pythagorean)', unit: 'wins' },
                pythProjWins: { name: 'Proj Wins', desc: 'Projected wins via round-robin simulation', unit: 'wins' },
                sosNet: { name: 'SOS Net', desc: 'Strength of schedule (avg opponent adj net rating)', unit: 'pts/100' },
                
                // Four Factors (Player ON-OFF)
                offEfg: { name: 'Off eFG%', desc: 'Effective FG% (weights 3PT at 1.5x)', unit: '%' },
                defEfg: { name: 'Def eFG%', desc: 'Opponent effective FG% (lower is better)', unit: '%' },
                offTov: { name: 'Off TOV%', desc: 'Turnovers per 100 plays (lower is better)', unit: '%' },
                defTov: { name: 'Def TOV%', desc: 'Forced turnovers per 100 plays', unit: '%' },
                offOreb: { name: 'Off OREB%', desc: 'Offensive rebound rate', unit: '%' },
                defOreb: { name: 'Def OREB%', desc: 'Opponent offensive rebound rate (lower is better)', unit: '%' },
                offFtR: { name: 'Off FT Rate', desc: 'Free throws attempted per FGA', unit: 'FTA/FGA' },
                defFtR: { name: 'Def FT Rate', desc: 'Opponent free throws per FGA (lower is better)', unit: 'FTA/FGA' },
                
                // Four Factors (Team Absolute)
                offTovPct: { name: 'Off TOV%', desc: 'Team turnover rate (lower is better)', unit: '%' },
                defTovPct: { name: 'Def TOV%', desc: 'Forced turnover rate', unit: '%' },
                offOrebPct: { name: 'Off OREB%', desc: 'Team offensive rebound rate', unit: '%' },
                defOrebPct: { name: 'Def OREB%', desc: 'Opponent OREB% allowed (lower is better)', unit: '%' },
                offFtRate: { name: 'Off FT Rate', desc: 'Team free throw rate', unit: 'FTA/FGA' },
                defFtRate: { name: 'Def FT Rate', desc: 'Opponent FT rate allowed (lower is better)', unit: 'FTA/FGA' },
                
                // Four Factors vs League Average
                offEfgVsLg: { name: 'Off eFG% vs Lg', desc: 'eFG% above/below league average', unit: '±%' },
                defEfgVsLg: { name: 'Def eFG% vs Lg', desc: 'Opp eFG% vs league (+ = better defense)', unit: '±%' },
                offTovPctVsLg: { name: 'Off TOV% vs Lg', desc: 'TOV% vs league (+ = fewer turnovers)', unit: '±%' },
                defTovPctVsLg: { name: 'Def TOV% vs Lg', desc: 'Forced TOV% vs league', unit: '±%' },
                offOrebPctVsLg: { name: 'Off OREB% vs Lg', desc: 'OREB% above/below league average', unit: '±%' },
                defOrebPctVsLg: { name: 'Def OREB% vs Lg', desc: 'Opp OREB% vs league (+ = better)', unit: '±%' },
                offFtRateVsLg: { name: 'Off FT Rate vs Lg', desc: 'FT rate above/below league average', unit: '±' },
                defFtRateVsLg: { name: 'Def FT Rate vs Lg', desc: 'Opp FT rate vs league (+ = better)', unit: '±' },
                
                // Points Added
                offEfgPA: { name: 'Off eFG% PA', desc: 'Points added from shooting efficiency', unit: 'pts' },
                offTovPA: { name: 'Off TOV PA', desc: 'Points added from turnover avoidance', unit: 'pts' },
                offOrebPA: { name: 'Off OREB PA', desc: 'Points added from offensive rebounding', unit: 'pts' },
                offFtRPA: { name: 'Off FT Rate PA', desc: 'Points added from free throw generation', unit: 'pts' },
                offScoringPA: { name: 'Off Scoring PA', desc: 'Points added from shooting (eFG% + FT Rate)', unit: 'pts' },
                offPossPA: { name: 'Off Poss PA', desc: 'Points added from possession management', unit: 'pts' },
                offTotalPA: { name: 'Off Total PA', desc: 'Total offensive points added vs league avg', unit: 'pts' },
                defEfgPA: { name: 'Def eFG% PA', desc: 'Points saved from opponent shooting defense', unit: 'pts' },
                defTovPA: { name: 'Def TOV PA', desc: 'Points added from forcing turnovers', unit: 'pts' },
                defOrebPA: { name: 'Def OREB PA', desc: 'Points saved from defensive rebounding', unit: 'pts' },
                defFtRPA: { name: 'Def FT Rate PA', desc: 'Points saved from limiting opponent FTs', unit: 'pts' },
                defScoringPA: { name: 'Def Scoring PA', desc: 'Points saved from opponent scoring defense', unit: 'pts' },
                defPossPA: { name: 'Def Poss PA', desc: 'Points added from defensive possession work', unit: 'pts' },
                defTotalPA: { name: 'Def Total PA', desc: 'Total defensive points added vs league avg', unit: 'pts' },
                
                // Shot Making
                rimPct: { name: 'Rim%', desc: 'FG% at the rim (0-4 feet)', unit: '%' },
                midPct: { name: 'Mid%', desc: 'Mid-range FG% (4ft to 3PT line)', unit: '%' },
                threePct: { name: '3PT%', desc: 'Three-point field goal percentage', unit: '%' },
                
                // Shot Volume
                rimVol: { name: 'Rim Vol', desc: 'Rim attempts per 100 possessions', unit: '/100' },
                midVol: { name: 'Mid Vol', desc: 'Mid-range attempts per 100 possessions', unit: '/100' },
                threeVol: { name: '3PT Vol', desc: 'Three-point attempts per 100 possessions', unit: '/100' },
                
                // Playmaking
                astPct: { name: 'AST%', desc: 'Percentage of teammate FGs assisted', unit: '%' },
                stlPct: { name: 'STL%', desc: 'Steals per 100 opponent possessions', unit: '%' },
                blkPct: { name: 'BLK%', desc: 'Blocks per 100 opponent 2PT attempts', unit: '%' },
                
                // Pace
                paceF: { name: 'Off Pace', desc: 'Offensive possessions per 40 minutes', unit: 'poss/40' },
                paceV: { name: 'Def Pace', desc: 'Defensive possessions per 40 minutes', unit: 'poss/40' },
                
                // Box Plus/Minus
                bpm: { name: 'BPM', desc: 'Box Plus/Minus - estimated pts/100 vs avg player', unit: 'pts/100' },
                obpm: { name: 'OBPM', desc: 'Offensive Box Plus/Minus', unit: 'pts/100' },
                dbpm: { name: 'DBPM', desc: 'Defensive Box Plus/Minus', unit: 'pts/100' },
                
                // APM
                apm: { name: 'APM', desc: 'Bayesian Adjusted Plus/Minus (BPM prior)', unit: 'pts/100' },
                oapm: { name: 'OAPM', desc: 'Offensive Adjusted Plus/Minus', unit: 'pts/100' },
                dapm: { name: 'DAPM', desc: 'Defensive Adjusted Plus/Minus', unit: 'pts/100' },
                
                // RAPM
                rapm: { name: 'RAPM', desc: 'Regularized Adjusted Plus/Minus — isolates individual impact from lineup data using ridge regression to handle multicollinearity; positive = helps team score more than opponent', unit: 'pts/100' },
                orapm: { name: 'ORAPM', desc: 'Offensive RAPM — isolated offensive impact controlling for teammates/opponents', unit: 'pts/100' },
                drapm: { name: 'DRAPM', desc: 'Defensive RAPM — isolated defensive impact (positive = prevents opponent scoring)', unit: 'pts/100' },
                
                // Single-Stat RAPM (Offensive)
                rapmOffEfg: { name: 'RAPM Off eFG%', desc: 'Isolated impact on team offensive eFG% via ridge regression', unit: '%' },
                rapmOffTov: { name: 'RAPM Off TOV%', desc: 'Isolated impact on team turnover rate (negative = fewer turnovers)', unit: '%' },
                rapmOffOreb: { name: 'RAPM Off OREB%', desc: 'Isolated impact on team offensive rebounding rate', unit: '%' },
                rapmOffFtr: { name: 'RAPM Off FTR', desc: 'Isolated impact on team free throw rate', unit: '' },
                rapmOffAst: { name: 'RAPM Off AST%', desc: 'Isolated impact on team assist rate', unit: '%' },
                
                // Single-Stat RAPM (Defensive)
                rapmDefEfg: { name: 'RAPM Def eFG%', desc: 'Isolated impact on opponent eFG% (negative = better defense)', unit: '%' },
                rapmDefTov: { name: 'RAPM Def TOV%', desc: 'Isolated impact on forcing turnovers', unit: '%' },
                rapmDefOreb: { name: 'RAPM Def OREB%', desc: 'Isolated impact on opponent OREB% (negative = better)', unit: '%' },
                rapmDefFtr: { name: 'RAPM Def FTR', desc: 'Isolated impact on opponent FT rate (negative = better)', unit: '' },
                rapmStl: { name: 'RAPM STL%', desc: 'Isolated impact on team steal rate', unit: '%' },
                rapmBlk: { name: 'RAPM BLK%', desc: 'Isolated impact on team block rate', unit: '%' },
                
                // Combined Impact (Z-Score)
                fourFactorsImpact: { name: '4F Impact', desc: 'Combined Four Factors impact (Z-score weighted)', unit: 'Z' },
                scoringBattleImpact: { name: 'Scoring Battle', desc: 'eFG% + FT Rate differential impact (off - def)', unit: 'Z' },
                possBattleImpact: { name: 'Poss Battle', desc: 'Possession battle impact (TOV + OREB)', unit: 'Z' },
                
                // Miscellaneous
                poss: { name: 'Possessions', desc: 'Total possessions played', unit: 'poss' },
                mins: { name: 'Minutes', desc: 'Total minutes played', unit: 'min' },
                games: { name: 'Games', desc: 'Number of games played', unit: 'G' },
                
                // Individual Per-Game Stats
                ppg: { name: 'PPG', desc: 'Points per game', unit: 'pts' },
                rpg: { name: 'RPG', desc: 'Rebounds per game', unit: 'reb' },
                apg: { name: 'APG', desc: 'Assists per game', unit: 'ast' },
                spg: { name: 'SPG', desc: 'Steals per game', unit: 'stl' },
                bpg: { name: 'BPG', desc: 'Blocks per game', unit: 'blk' },
                mpg: { name: 'MPG', desc: 'Minutes per game', unit: 'min' },
                
                // Individual Shooting
                fgPct: { name: 'FG%', desc: 'Field goal percentage', unit: '%' },
                ftPct: { name: 'FT%', desc: 'Free throw percentage', unit: '%' },
                tsPct: { name: 'TS%', desc: 'True shooting % (efficiency including FTs & 3s)', unit: '%' },
                efgPct: { name: 'eFG%', desc: 'Effective FG% (weights 3PT at 1.5x)', unit: '%' },
                
                // Individual Advanced
                usg: { name: 'USG%', desc: 'Usage rate - % of team plays used', unit: '%' },
                per: { name: 'PER', desc: 'Player Efficiency Rating', unit: '' },

                // Individual Per-75 Possessions Stats (same names as leaderboard individual tab)
                usage: { name: 'Usage %', desc: 'Usage rate - % of team plays used while on court', unit: '%' },
                pts75: { name: 'PTS/75', desc: 'Points per 75 lineup possessions', unit: 'pts' },
                reb75: { name: 'REB/75', desc: 'Rebounds per 75 lineup possessions', unit: 'reb' },
                oreb75: { name: 'OREB/75', desc: 'Offensive rebounds per 75 lineup possessions', unit: 'reb' },
                dreb75: { name: 'DREB/75', desc: 'Defensive rebounds per 75 lineup possessions', unit: 'reb' },
                ast75: { name: 'AST/75', desc: 'Assists per 75 lineup possessions', unit: 'ast' },
                astUsgRatio: { name: 'AST/USG', desc: 'AST% ÷ Usage% (playmaking efficiency relative to ball dominance)', unit: '' },
                stl75: { name: 'STL/75', desc: 'Steals per 75 lineup possessions', unit: 'stl' },
                blk75: { name: 'BLK/75', desc: 'Blocks per 75 lineup possessions', unit: 'blk' },
                tov75: { name: 'TOV/75', desc: 'Turnovers per 75 lineup possessions (lower is better)', unit: 'tov' },

                // Shot Volume Per-75
                rimA75: { name: 'RIM ATT/75', desc: 'Rim attempts per 75 lineup possessions', unit: 'att' },
                midA75: { name: 'MID ATT/75', desc: 'Mid-range attempts per 75 lineup possessions', unit: 'att' },
                threeA75: { name: '3PT ATT/75', desc: 'Three-point attempts per 75 lineup possessions', unit: 'att' },

                // Playmaking
                tpc75: { name: 'TPC/75', desc: 'Total potential chances per 75 lineup possessions', unit: '' },
                playerAstPct: { name: 'AST%', desc: 'Percentage of teammate FGs assisted while on court', unit: '%' },

                // Turnovers by Type
                passTo: { name: 'Pass TOs', desc: 'Turnovers from bad passes (lower is better)', unit: 'TO' },
                dribTo: { name: 'Dribble TOs', desc: 'Turnovers from dribbling (lower is better)', unit: 'TO' },

                // Scoring Types Per-75
                ptsAst75: { name: 'PTS AST/75', desc: 'Points created by assists per 75 possessions', unit: 'pts' },
                secChancePts75: { name: '2nd Chance/75', desc: 'Second chance points per 75 possessions', unit: 'pts' },
                fastBreakPts75: { name: 'Fast Break/75', desc: 'Fast break points per 75 possessions', unit: 'pts' },
                clutchPts75: { name: 'Clutch/75', desc: 'Clutch points per 75 possessions', unit: 'pts' }
            };
            
            // Helper to get stat definition
            const getStatDef = (statKey) => statDefinitions[statKey] || { name: statKey, desc: 'Statistical measure', unit: '' };
            
            // V5.5: Smart name display helper - handles suffixes like Jr., III, etc.
            // V5.14.2: Enhanced to handle duplicate surname disambiguation when teamPlayers provided
            const suffixList = ['Jr.', 'Jr', 'Sr.', 'Sr', 'II', 'III', 'IV', 'V', 'Iii', 'Ii', 'Iv'];

            // Helper to get surname with suffix
            const getSurnameWithSuffix = (name) => {
                if (!name) return '';
                const cleanName = (name || '').split(',')[0].trim();
                const parts = cleanName.split(' ').filter(p => p.length > 0);
                if (parts.length === 0) return name;
                if (parts.length === 1) return parts[0];
                const lastWord = parts[parts.length - 1];
                if (suffixList.some(s => s.toLowerCase() === lastWord.toLowerCase())) {
                    return parts.length >= 2 ? parts.slice(-2).join(' ') : lastWord;
                }
                return lastWord;
            };

            const getDisplayName = (fullName, short = true, teamPlayers = null) => {
                if (!fullName) return '?';
                const parts = fullName.trim().split(' ');
                const lastPart = parts[parts.length - 1];
                const hasSuffix = suffixList.some(s => lastPart.toLowerCase() === s.toLowerCase() || lastPart.toLowerCase() === (s + '.').toLowerCase());

                // Get the surname (including suffix if present)
                const surname = getSurnameWithSuffix(fullName);

                if (short) {
                    // Check for duplicate surnames if teamPlayers array provided
                    if (teamPlayers && teamPlayers.length > 0 && parts.length > 1) {
                        const surnameLC = surname.toLowerCase();
                        const sameSurnamePlayers = teamPlayers.filter(p => getSurnameWithSuffix(p).toLowerCase() === surnameLC);

                        if (sameSurnamePlayers.length > 1) {
                            // Need to disambiguate with first name prefix
                            const firstName = parts[0];
                            const otherFirstNames = sameSurnamePlayers
                                .filter(p => p !== fullName)
                                .map(p => (p.split(',')[0].trim().split(' ').filter(x => x.length > 0)[0] || '').toLowerCase());

                            // Find minimum prefix length to disambiguate
                            let prefixLen = 1;
                            const firstNameLower = firstName.toLowerCase();
                            while (prefixLen < firstName.length) {
                                const prefix = firstNameLower.slice(0, prefixLen);
                                const hasConflict = otherFirstNames.some(fn => fn.slice(0, prefixLen) === prefix);
                                if (!hasConflict) break;
                                prefixLen++;
                            }
                            return firstName.slice(0, prefixLen) + '. ' + surname;
                        }
                    }
                    return surname;
                } else {
                    // For dropdown display (first initial + last name + suffix)
                    if (parts.length >= 2) {
                        return parts[0][0] + '. ' + surname;
                    }
                    return fullName;
                }
            };
            
            // V5.5: Get initials helper - handles suffixes
            const getInitials = (name) => {
                if (!name) return '?';
                const suffixes = ['Jr.', 'Jr', 'Sr.', 'Sr', 'II', 'III', 'IV', 'V'];
                const parts = name.trim().split(' ');
                const lastPart = parts[parts.length - 1];
                const hasSuffix = suffixes.some(s => lastPart === s || lastPart === s + '.');
                
                if (hasSuffix && parts.length > 2) {
                    // First initial + name before suffix initial
                    return (parts[0][0] + parts[parts.length - 2][0]).toUpperCase();
                }
                if (parts.length > 1) {
                    return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                }
                return name.substring(0, 2).toUpperCase();
            };

            const handleLineup = (ev) => { const f = ev.target.files[0]; if (f) { setLineupFile(f.name); const r = new FileReader(); r.onload = (e) => setLineupCsv(e.target.result); r.readAsText(f); }};
            const handlePlayer = (ev) => { const f = ev.target.files[0]; if (f) { setPlayerFile(f.name); const r = new FileReader(); r.onload = (e) => setPlayerCsv(e.target.result); r.readAsText(f); }};
            const handleMatchup = (ev) => { const f = ev.target.files[0]; if (f) { setMatchupFile(f.name); const r = new FileReader(); r.onload = (e) => setMatchupCsv(e.target.result); r.readAsText(f); }};
            const handleSeason = (ev) => { const f = ev.target.files[0]; if (f) { setSeasonFile(f.name); const r = new FileReader(); r.onload = (e) => setSeasonCsv(e.target.result); r.readAsText(f); }};
            const handleAssistCombo = (ev) => { const f = ev.target.files[0]; if (f) { setAssistComboFile(f.name); const r = new FileReader(); r.onload = (e) => setAssistComboCsv(e.target.result); r.readAsText(f); }};
            const handleClutch = (ev) => { const f = ev.target.files[0]; if (f) { setClutchFile(f.name); const r = new FileReader(); r.onload = (e) => setClutchCsv(e.target.result); r.readAsText(f); }};
            const handleStints = (ev) => { const f = ev.target.files[0]; if (f) { setStintsFile(f.name); const r = new FileReader(); r.onload = (e) => setStintsCsv(e.target.result); r.readAsText(f); }};
            const handlePlayerStints = (ev) => { const f = ev.target.files[0]; if (f) { setPlayerStintsFile(f.name); const r = new FileReader(); r.onload = (e) => setPlayerStintsCsv(e.target.result); r.readAsText(f); }};
            const handleTeamTotals = (ev) => { const f = ev.target.files[0]; if (f) { setTeamTotalsFile(f.name); const r = new FileReader(); r.onload = (e) => setTeamTotalsCsv(e.target.result); r.readAsText(f); }};
            
            // V4.9.7: Player-level RAPM state (Multi-stat RAPM V3.1)
            const [playerRapmStats, setPlayerRapmStats] = useState(null);
            const [isCalculatingPlayerRAPM, setIsCalculatingPlayerRAPM] = useState(false);
            const [playerRapmProgress, setPlayerRapmProgress] = useState(0);
            const [playerRapmMessage, setPlayerRapmMessage] = useState('');
            
            // V5.11: Bayesian Box APM state (RAPM + Bayesian Box)
            const [playerApmStats, setPlayerApmStats] = useState(null);
            const [isCalculatingAPM, setIsCalculatingAPM] = useState(false);
            const [apmProgress, setApmProgress] = useState(0);
            const [apmMessage, setApmMessage] = useState('');
            
            // V5.7: Reset RAPM stat selections when RAPM data is not available
            useEffect(() => {
                const rapmStats = ['rapm', 'orapm', 'drapm'];
                const hasRapm = playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg;
                if (!hasRapm) {
                    // Reset leaderboard stat if RAPM is selected
                    if (rapmStats.includes(exportStat)) {
                        setExportStat('net');
                    }
                    // Reset chart X if RAPM is selected
                    if (rapmStats.includes(exportChartX)) {
                        setExportChartX('off');
                    }
                    // Reset chart Y if RAPM is selected
                    if (rapmStats.includes(exportChartY)) {
                        setExportChartY('def');
                    }
                }
            }, [playerRapmStats, exportStat, exportChartX, exportChartY]);
            
            // Persist player images to localStorage when they change
            useEffect(() => {
                try {
                    if (Object.keys(exportPlayerImages).length > 0) {
                        localStorage.setItem('lineupAnalyzer_playerImages', JSON.stringify(exportPlayerImages));
                    }
                } catch (e) { console.warn('Could not save player images to localStorage'); }
            }, [exportPlayerImages]);
            
            // Persist team images to localStorage when they change
            useEffect(() => {
                try {
                    if (Object.keys(exportSOSTeamImages).length > 0) {
                        localStorage.setItem('lineupAnalyzer_teamImages', JSON.stringify(exportSOSTeamImages));
                    }
                } catch (e) { console.warn('Could not save team images to localStorage'); }
            }, [exportSOSTeamImages]);

            // ═══════════════════════════════════════════════════════════════════════════
            // AUTO-LOAD FROM ADJACENT FOLDER (for web server / GitHub Pages deployment)
            // Attempts to load data files from a folder in the same directory as this HTML
            // ═══════════════════════════════════════════════════════════════════════════
            const [autoLoadStatus, setAutoLoadStatus] = useState('pending'); // 'pending', 'loading', 'success', 'failed'
            const [autoLoadMessage, setAutoLoadMessage] = useState('');

            // ═══════════════════════════════════════════════════════════════════════════
            // TAURI SCRAPER STATE (for Update Data feature)
            // ═══════════════════════════════════════════════════════════════════════════
            const [isScraperRunning, setIsScraperRunning] = useState(false);
            const [scraperProgress, setScraperProgress] = useState(null);
            const [scraperJobId, setScraperJobId] = useState(null);
            const [isTauriApp, setIsTauriApp] = useState(false);
            const [localScraperDataPath, setLocalScraperDataPath] = useState(null); // Path if local scraper data exists
            const [dataSource, setDataSource] = useState(null); // 'scraper', 'folder', 'github', or null
            const [availableDataFolders, setAvailableDataFolders] = useState([]); // List of timestamped data folders
            const [availableCompetitionCodes, setAvailableCompetitionCodes] = useState([]); // Unique competition codes from folders
            const [selectedCompetitionCode, setSelectedCompetitionCode] = useState(null); // User-selected competition code filter
            const [currentDataFolderInfo, setCurrentDataFolderInfo] = useState(null); // Info about currently loaded folder

            // Check if running in Tauri and check for local scraper data
            useEffect(() => {
                const checkTauriAndData = async () => {
                    const isTauri = typeof window !== 'undefined' && window.__TAURI__ !== undefined;
                    setIsTauriApp(isTauri);

                    if (isTauri) {
                        try {
                            const { invoke } = window.__TAURI__.core || window.__TAURI__;

                            // Get scraper output path
                            let leagueId = null;
                            try {
                                const userProfile = await invoke('get_user_profile');
                                if (userProfile && userProfile.leagues && userProfile.leagues.length > 0) {
                                    leagueId = userProfile.leagues[0].league_id;
                                }
                            } catch (e) { /* Not logged in */ }

                            const scraperPath = await invoke('get_scraper_output_path', { leagueId });

                            // Check if scraper data folder exists and has data
                            try {
                                const { readDir } = window.__TAURI__.fs || {};
                                if (readDir) {
                                    const files = await readDir(scraperPath);
                                    // Check for key CSV files
                                    const hasData = files.some(f =>
                                        f.name && (f.name.includes('lineup_stats') || f.name.includes('stints') || f.name.includes('player_stats'))
                                    );
                                    if (hasData) {
                                        setLocalScraperDataPath(scraperPath);
                                        console.log('[Scraper] Found local scraper data at:', scraperPath);
                                    }
                                }
                            } catch (e) {
                                console.log('[Scraper] No local scraper data found');
                            }
                        } catch (e) {
                            console.log('[Scraper] Error checking for local data:', e);
                        }
                    }
                };

                checkTauriAndData();
            }, []);

            // Handle Update Data button click
            const handleUpdateData = async () => {
                if (!window.__TAURI__) return;

                try {
                    const { invoke } = window.__TAURI__.core || window.__TAURI__;

                    // Get user profile to determine league
                    let leagueId = null;
                    try {
                        const userProfile = await invoke('get_user_profile');
                        if (userProfile && userProfile.leagues && userProfile.leagues.length > 0) {
                            leagueId = userProfile.leagues[0].league_id;
                        }
                    } catch (e) {
                        console.log('No user logged in, using default league');
                    }

                    // Start the scraper
                    const job = await invoke('start_scraper', { leagueId });
                    setScraperJobId(job.job_id);
                    setIsScraperRunning(true);
                    setScraperProgress({
                        status: 'starting',
                        progress_percent: 0,
                        message: 'Starting scraper...',
                        games_completed: 0,
                        games_total: 0
                    });

                    // Start polling for progress
                    pollScraperStatus(job.job_id);

                } catch (error) {
                    console.error('Failed to start scraper:', error);
                    setAutoLoadMessage('Failed to start update: ' + (error.message || error));
                    setIsScraperRunning(false);
                }
            };

            // Helper function to reload data from scraper output
            const reloadScraperData = async (outputFolder) => {
                if (!window.__TAURI__) return false;

                try {
                    const { readTextFile, readDir } = window.__TAURI__.fs || {};
                    if (!readTextFile || !readDir) return false;

                    console.log('[Scraper] Reloading data from:', outputFolder);
                    let files;
                    try {
                        files = await readDir(outputFolder);
                    } catch (e) {
                        console.warn('[Scraper] Could not read output folder:', e);
                        return false;
                    }

                    const fileNames = files.map(f => f.name?.toLowerCase()).filter(Boolean);
                    const loadedFiles = [];

                    // Files to load
                    const filesToLoad = [
                        { name: 'stints.csv', setter: setStintsCsv, fileSetter: setStintsFile, label: 'Stints' },
                        { name: 'player_stints.csv', setter: setPlayerStintsCsv, fileSetter: setPlayerStintsFile, label: 'PlayerStints' },
                        { name: 'team_totals.csv', setter: setTeamTotalsCsv, fileSetter: setTeamTotalsFile, label: 'TeamTotals' },
                        { name: 'clutch_lineup_stats.csv', setter: setClutchCsv, fileSetter: setClutchFile, label: 'Clutch' },
                        { name: 'player_lineup_stats_enhanced.csv', setter: setPlayerCsv, fileSetter: setPlayerFile, label: 'Player' },
                        { name: 'lineup_assist_combinations.csv', setter: setAssistComboCsv, fileSetter: setAssistComboFile, label: 'Assist', fallback: 'assist_combinations.csv' },
                        { name: 'lineup_matchups.csv', setter: setMatchupCsv, fileSetter: setMatchupFile, label: 'Matchup' },
                        { name: 'lineup_stats_enhanced.csv', setter: setLineupCsv, fileSetter: setLineupFile, label: 'Lineup' },
                        { name: 'player_stats_enhanced.csv', setter: setSeasonCsv, fileSetter: setSeasonFile, label: 'Season' }
                    ];

                    for (const fileConfig of filesToLoad) {
                        let loaded = false;
                        const primaryExists = fileNames.includes(fileConfig.name.toLowerCase());

                        if (primaryExists) {
                            try {
                                const content = await readTextFile(outputFolder + '/' + fileConfig.name);
                                if (content) {
                                    fileConfig.setter(content);
                                    fileConfig.fileSetter(fileConfig.name);
                                    loadedFiles.push(fileConfig.label);
                                    loaded = true;
                                }
                            } catch (e) { /* ignore */ }
                        }

                        if (!loaded && fileConfig.fallback) {
                            const fallbackExists = fileNames.includes(fileConfig.fallback.toLowerCase());
                            if (fallbackExists) {
                                try {
                                    const content = await readTextFile(outputFolder + '/' + fileConfig.fallback);
                                    if (content) {
                                        fileConfig.setter(content);
                                        fileConfig.fileSetter(fileConfig.fallback);
                                        loadedFiles.push(fileConfig.label);
                                    }
                                } catch (e) { /* ignore */ }
                            }
                        }
                    }

                    if (loadedFiles.length > 0) {
                        setLocalScraperDataPath(outputFolder);
                        setDataSource('scraper');
                        setFolderLoaded(loadedFiles.map(l => l + ': loaded'));
                        console.log('[Scraper] Reloaded files:', loadedFiles);
                        return true;
                    }
                    return false;
                } catch (e) {
                    console.error('[Scraper] Error reloading data:', e);
                    return false;
                }
            };

            // Poll scraper status
            const pollScraperStatus = async (jobId) => {
                if (!window.__TAURI__) return;

                try {
                    const { invoke } = window.__TAURI__.core || window.__TAURI__;
                    const status = await invoke('get_scraper_status', { jobId });
                    setScraperProgress(status);

                    if (status.status === 'completed') {
                        setIsScraperRunning(false);
                        setAutoLoadMessage('Data updated successfully!');
                        setAutoLoadStatus('success');

                        // Reload data from the new folder
                        if (status.output_folder) {
                            console.log('[Scraper] Loading data from:', status.output_folder);
                            const reloaded = await reloadScraperData(status.output_folder);
                            if (reloaded) {
                                setAutoLoadMessage('Data updated and reloaded!');
                            } else {
                                // Fallback to page reload if in-place reload fails
                                setAutoLoadMessage('Update complete. Reloading...');
                                setTimeout(() => window.location.reload(), 500);
                            }
                        }
                    } else if (status.status === 'failed' || status.status === 'cancelled') {
                        setIsScraperRunning(false);
                        setAutoLoadMessage(status.message || 'Update failed');
                    } else if (status.status === 'running' || status.status === 'starting') {
                        // Continue polling
                        setTimeout(() => pollScraperStatus(jobId), 2000);
                    }
                } catch (error) {
                    console.error('Failed to get scraper status:', error);
                    setIsScraperRunning(false);
                }
            };

            // Cancel scraper
            const handleCancelScraper = async () => {
                if (!window.__TAURI__ || !scraperJobId) return;

                try {
                    const { invoke } = window.__TAURI__.core || window.__TAURI__;
                    await invoke('cancel_scraper', { jobId: scraperJobId });
                    setIsScraperRunning(false);
                    setScraperProgress(null);
                    setAutoLoadMessage('Update cancelled');
                } catch (error) {
                    console.error('Failed to cancel scraper:', error);
                }
            };

            // Listen for scraper-complete event from Tauri
            useEffect(() => {
                if (!window.__TAURI__) return;

                const setupListener = async () => {
                    try {
                        const { listen } = window.__TAURI__.event || (window.__TAURI__.core ? { listen: null } : {});
                        if (!listen) return;

                        const unlisten = await listen('scraper-complete', async (event) => {
                            console.log('[Scraper] Complete event:', event.payload);
                            setIsScraperRunning(false);
                            setAutoLoadStatus('success');

                            const gamesScraped = event.payload?.games_scraped || 0;
                            const outputFolder = event.payload?.output_folder;

                            if (outputFolder) {
                                setAutoLoadMessage(`Scraped ${gamesScraped} games. Reloading data...`);
                                const reloaded = await reloadScraperData(outputFolder);
                                if (reloaded) {
                                    setAutoLoadMessage(`Data updated! ${gamesScraped} games scraped.`);
                                } else {
                                    // Fallback to page reload
                                    setAutoLoadMessage('Update complete. Reloading page...');
                                    setTimeout(() => window.location.reload(), 500);
                                }
                            } else {
                                setAutoLoadMessage(`Data updated! ${gamesScraped} games scraped.`);
                                // Fallback to page reload to pick up new data
                                setTimeout(() => window.location.reload(), 500);
                            }
                        });

                        return unlisten;
                    } catch (e) {
                        console.log('Could not setup scraper event listener');
                    }
                };

                const cleanup = setupListener();
                return () => {
                    if (cleanup) cleanup.then(fn => fn && fn());
                };
            }, []);

            // Expose auto-load status globally for ParentBridge to coordinate with
            useEffect(() => {
                window._slbAutoLoadStatus = autoLoadStatus;
            }, [autoLoadStatus]);

            // Expose competition code setter globally for ParentBridge to update from parent app
            useEffect(() => {
                window._slbSetSelectedCompetitionCode = setSelectedCompetitionCode;
                return () => { delete window._slbSetSelectedCompetitionCode; };
            }, []);

            // V6.3: Load competition settings when competition code changes (Tauri only)
            // This restores saved player merges, player/team images, and theme preferences
            useEffect(() => {
                if (!isTauriApp || !selectedCompetitionCode) return;

                const loadCompetitionSettings = async () => {
                    try {
                        const { invoke } = window.__TAURI__.core || window.__TAURI__;

                        // Get user ID if logged in
                        let userId = null;
                        try {
                            const userProfile = await invoke('get_user_profile');
                            if (userProfile && userProfile.user_id) {
                                userId = userProfile.user_id;
                            }
                        } catch (e) { /* Not logged in */ }

                        // Load competition settings
                        const settings = await invoke('get_competition_settings', {
                            competitionCode: selectedCompetitionCode,
                            userId: userId
                        });

                        if (settings) {
                            console.log('[CompSettings] Loaded settings for', selectedCompetitionCode, settings);

                            // Apply player merge rules
                            if (settings.playerMergeRules && settings.playerMergeRules.length > 0) {
                                setPlayerMergeRules(settings.playerMergeRules);
                                console.log('[CompSettings] Applied', settings.playerMergeRules.length, 'merge rules');
                            }

                            // Apply player images
                            if (settings.playerImages && Object.keys(settings.playerImages).length > 0) {
                                setExportPlayerImages(settings.playerImages);
                                console.log('[CompSettings] Applied', Object.keys(settings.playerImages).length, 'player images');
                            }

                            // Apply team images
                            if (settings.teamImages && Object.keys(settings.teamImages).length > 0) {
                                setExportFFTeamImages(settings.teamImages);
                                setExportSOSTeamImages(settings.teamImages);
                                console.log('[CompSettings] Applied', Object.keys(settings.teamImages).length, 'team images');
                            }

                            // Apply theme colors
                            if (settings.primaryThemeColor) {
                                setThemeColor(settings.primaryThemeColor);
                            }
                            if (settings.secondaryThemeColor) {
                                setSecondaryThemeColor(settings.secondaryThemeColor);
                            }
                        } else {
                            console.log('[CompSettings] No saved settings for', selectedCompetitionCode);
                        }
                    } catch (e) {
                        console.warn('[CompSettings] Failed to load competition settings:', e);
                    }
                };

                loadCompetitionSettings();
            }, [isTauriApp, selectedCompetitionCode]);

            // V6.3: Save competition settings when relevant data changes (debounced)
            // Saves player merges, player/team images, and theme preferences
            const saveCompetitionSettingsTimeoutRef = useRef(null);
            useEffect(() => {
                if (!isTauriApp || !selectedCompetitionCode) return;

                // Debounce saves to avoid too many writes
                if (saveCompetitionSettingsTimeoutRef.current) {
                    clearTimeout(saveCompetitionSettingsTimeoutRef.current);
                }

                saveCompetitionSettingsTimeoutRef.current = setTimeout(async () => {
                    try {
                        const { invoke } = window.__TAURI__.core || window.__TAURI__;

                        // Get user ID if logged in
                        let userId = null;
                        try {
                            const userProfile = await invoke('get_user_profile');
                            if (userProfile && userProfile.user_id) {
                                userId = userProfile.user_id;
                            }
                        } catch (e) { /* Not logged in */ }

                        // Build settings object
                        const settings = {
                            competitionCode: selectedCompetitionCode,
                            userId: userId,
                            playerMergeRules: playerMergeRules,
                            playerImages: exportPlayerImages || {},
                            teamImages: { ...exportFFTeamImages, ...exportSOSTeamImages },
                            primaryThemeColor: themeColor,
                            secondaryThemeColor: secondaryThemeColor
                        };

                        await invoke('save_competition_settings', { settings });
                        console.log('[CompSettings] Saved settings for', selectedCompetitionCode);
                    } catch (e) {
                        console.warn('[CompSettings] Failed to save competition settings:', e);
                    }
                }, 2000); // 2 second debounce

                return () => {
                    if (saveCompetitionSettingsTimeoutRef.current) {
                        clearTimeout(saveCompetitionSettingsTimeoutRef.current);
                    }
                };
            }, [isTauriApp, selectedCompetitionCode, playerMergeRules, exportPlayerImages, exportFFTeamImages, exportSOSTeamImages, themeColor, secondaryThemeColor]);

            useEffect(() => {
                // Auto-load configuration - change this to match your folder name
                const DATA_FOLDER = './data'; // Default folder name (relative to HTML file)
                const ALT_FOLDERS = ['./SLB_RUN4', './adult', './Adult', './DATA', './Data']; // Alternative folder names to try

                // CSV_FILES: Only load _enhanced versions for files that have them
                // No fallback to non-enhanced versions - they have different schemas
                const CSV_FILES = [
                    { name: 'stints.csv', setter: setStintsCsv, fileSetter: setStintsFile, label: 'Stints' },
                    { name: 'player_stints.csv', setter: setPlayerStintsCsv, fileSetter: setPlayerStintsFile, label: 'PlayerStints' },
                    { name: 'team_totals.csv', setter: setTeamTotalsCsv, fileSetter: setTeamTotalsFile, label: 'TeamTotals' },
                    { name: 'clutch_lineup_stats.csv', setter: setClutchCsv, fileSetter: setClutchFile, label: 'Clutch' },
                    { name: 'player_lineup_stats_enhanced.csv', setter: setPlayerCsv, fileSetter: setPlayerFile, label: 'Player' },
                    { name: 'lineup_assist_combinations.csv', setter: setAssistComboCsv, fileSetter: setAssistComboFile, label: 'Assist', fallback: 'assist_combinations.csv' },
                    { name: 'lineup_matchups.csv', setter: setMatchupCsv, fileSetter: setMatchupFile, label: 'Matchup' },
                    { name: 'lineup_stats_enhanced.csv', setter: setLineupCsv, fileSetter: setLineupFile, label: 'Lineup' },
                    { name: 'player_stats_enhanced.csv', setter: setSeasonCsv, fileSetter: setSeasonFile, label: 'Season' }
                ];

                const tryLoadFromFolder = async (folderPath) => {
                    const loadedFiles = [];
                    const gameHtmlFiles = [];

                    // Try to load each CSV file
                    for (const fileConfig of CSV_FILES) {
                        let loaded = false;

                        // Try primary filename first
                        try {
                            const response = await fetch(folderPath + '/' + fileConfig.name);
                            if (response.ok) {
                                const content = await response.text();
                                fileConfig.setter(content);
                                fileConfig.fileSetter(fileConfig.name);
                                loadedFiles.push(fileConfig.label + ': ' + fileConfig.name);
                                loaded = true;
                            }
                        } catch (e) { /* ignore */ }

                        // Try fallback filename if primary failed
                        if (!loaded && fileConfig.fallback) {
                            try {
                                const response = await fetch(folderPath + '/' + fileConfig.fallback);
                                if (response.ok) {
                                    const content = await response.text();
                                    fileConfig.setter(content);
                                    fileConfig.fileSetter(fileConfig.fallback);
                                    loadedFiles.push(fileConfig.label + ': ' + fileConfig.fallback);
                                }
                            } catch (e) { /* ignore */ }
                        }
                    }

                    // Try to discover game_html files
                    // First, try to fetch a directory listing or known game files
                    try {
                        // Try to fetch index of game_html folder (works on some servers)
                        const gameHtmlPath = folderPath + '/game_html';

                        // Since we can't list directories via fetch, we'll try to load known game patterns
                        // We'll scan for games by trying sequential game IDs or reading from stints.csv
                        // For now, we'll attempt to detect games from the stints data

                        // Parse game IDs from stints if available
                        const stintsResponse = await fetch(folderPath + '/stints.csv').catch(() => null);
                        if (stintsResponse && stintsResponse.ok) {
                            const stintsContent = await stintsResponse.text();
                            const stintsLines = stintsContent.split('\n');
                            const gameIdIndex = stintsLines[0]?.toLowerCase().split(',').indexOf('game_id');

                            if (gameIdIndex >= 0) {
                                const gameIds = new Set();
                                for (let i = 1; i < stintsLines.length; i++) {
                                    const cols = stintsLines[i].split(',');
                                    if (cols[gameIdIndex]) {
                                        gameIds.add(cols[gameIdIndex].trim().replace(/"/g, ''));
                                    }
                                }

                                // Try to load game HTML files for discovered game IDs
                                const validGames = [];
                                for (const gameId of gameIds) {
                                    try {
                                        const bsUrl = gameHtmlPath + '/game' + gameId + 'bs.html';
                                        const pbpUrl = gameHtmlPath + '/game' + gameId + 'pbp.html';

                                        const [bsResp, pbpResp] = await Promise.all([
                                            fetch(bsUrl).catch(() => null),
                                            fetch(pbpUrl).catch(() => null)
                                        ]);

                                        if (bsResp && bsResp.ok && pbpResp && pbpResp.ok) {
                                            const bsContent = await bsResp.text();
                                            const pbpContent = await pbpResp.text();
                                            validGames.push({
                                                gameId,
                                                bsContent,
                                                pbpContent,
                                                bsUrl,
                                                pbpUrl
                                            });
                                        }
                                    } catch (e) { /* ignore individual game failures */ }
                                }

                                if (validGames.length > 0) {
                                    loadedFiles.push('Game HTML: ' + validGames.length + ' games found');

                                    // Process game summaries
                                    const summaries = validGames.map(game => {
                                        try {
                                            return parseGameSummary(game.bsContent, game.gameId);
                                        } catch (e) {
                                            console.warn('Failed to parse game ' + game.gameId);
                                            return null;
                                        }
                                    }).filter(Boolean);

                                    // Store game files for later detailed loading
                                    // Create pseudo-file objects that work with the existing loadGameForAnalysis
                                    const pseudoGameFiles = validGames.map(game => ({
                                        gameId: game.gameId,
                                        bs: { text: async () => game.bsContent },
                                        pbp: { text: async () => game.pbpContent },
                                        _isAutoLoaded: true,
                                        _bsContent: game.bsContent,
                                        _pbpContent: game.pbpContent
                                    }));

                                    setGvGameHtmlFiles(pseudoGameFiles);

                                    // Sort and set summaries
                                    const parseGameDate = (dateStr) => {
                                        if (!dateStr) return null;
                                        const parts = dateStr.split(/[\/\-]/);
                                        if (parts.length === 3) {
                                            let [day, month, year] = parts.map(p => parseInt(p));
                                            if (year < 100) year += 2000;
                                            return new Date(year, month - 1, day);
                                        }
                                        const parsed = new Date(dateStr);
                                        return isNaN(parsed.getTime()) ? null : parsed;
                                    };

                                    summaries.sort((a, b) => {
                                        const dateA = parseGameDate(a.date);
                                        const dateB = parseGameDate(b.date);
                                        if (!dateA && !dateB) return 0;
                                        if (!dateA) return 1;
                                        if (!dateB) return -1;
                                        return dateB - dateA;
                                    });

                                    setGvFolderGames(summaries);
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Could not auto-load game HTML files:', e);
                    }

                    return loadedFiles;
                };

                // Helper to load data from Tauri scraper output folder (uses timestamped folders)
                const tryLoadFromTauriScraperFolder = async (competitionCodeFilter = null) => {
                    if (!window.__TAURI__) return null;

                    try {
                        const { invoke } = window.__TAURI__.core || window.__TAURI__;
                        const { readTextFile, readDir } = window.__TAURI__.fs || {};

                        if (!readTextFile || !readDir) {
                            console.log('[Scraper] Tauri fs API not available');
                            return null;
                        }

                        // Get user profile for league ID
                        let leagueId = null;
                        try {
                            const userProfile = await invoke('get_user_profile');
                            if (userProfile && userProfile.leagues && userProfile.leagues.length > 0) {
                                leagueId = userProfile.leagues[0].league_id;
                            }
                        } catch (e) { /* Not logged in */ }

                        // List all available data folders
                        const folders = await invoke('list_scraper_data_folders', {
                            leagueId,
                            competitionCode: competitionCodeFilter || selectedCompetitionCode
                        });

                        if (folders && folders.length > 0) {
                            setAvailableDataFolders(folders);

                            // Extract unique competition codes
                            const codes = [...new Set(folders.map(f => f.competition_code).filter(Boolean))];
                            setAvailableCompetitionCodes(codes);
                            console.log('[Scraper] Found', folders.length, 'data folders, codes:', codes);

                            // If no competition code selected yet, use the first one from the most recent folder
                            if (!competitionCodeFilter && !selectedCompetitionCode && folders.length > 0) {
                                setSelectedCompetitionCode(folders[0].competition_code);
                            }
                        }

                        // Get the most recent folder path (filtered by competition code if specified)
                        let scraperPath;
                        try {
                            scraperPath = await invoke('get_scraper_output_path', {
                                leagueId,
                                competitionCode: competitionCodeFilter || selectedCompetitionCode
                            });
                        } catch (e) {
                            console.log('[Scraper] No scraper folders found');
                            return null;
                        }

                        console.log('[Scraper] Using scraper folder:', scraperPath);

                        // Try to list files in the folder
                        let files;
                        try {
                            files = await readDir(scraperPath);
                        } catch (e) {
                            console.log('[Scraper] Scraper folder not found or empty');
                            return null;
                        }

                        // Check if we have key data files
                        const fileNames = files.map(f => f.name?.toLowerCase()).filter(Boolean);
                        const hasRequiredFiles = fileNames.some(n =>
                            n.includes('lineup_stats') || n.includes('stints') || n.includes('player_stats')
                        );

                        if (!hasRequiredFiles) {
                            console.log('[Scraper] No required data files in scraper folder');
                            return null;
                        }

                        console.log('[Scraper] Found scraper data files:', fileNames);
                        const loadedFiles = [];

                        // Define files to load (same as CSV_FILES but for Tauri)
                        const filesToLoad = [
                            { name: 'stints.csv', setter: setStintsCsv, fileSetter: setStintsFile, label: 'Stints' },
                            { name: 'player_stints.csv', setter: setPlayerStintsCsv, fileSetter: setPlayerStintsFile, label: 'PlayerStints' },
                            { name: 'team_totals.csv', setter: setTeamTotalsCsv, fileSetter: setTeamTotalsFile, label: 'TeamTotals' },
                            { name: 'clutch_lineup_stats.csv', setter: setClutchCsv, fileSetter: setClutchFile, label: 'Clutch' },
                            { name: 'player_lineup_stats_enhanced.csv', setter: setPlayerCsv, fileSetter: setPlayerFile, label: 'Player' },
                            { name: 'lineup_assist_combinations.csv', setter: setAssistComboCsv, fileSetter: setAssistComboFile, label: 'Assist', fallback: 'assist_combinations.csv' },
                            { name: 'lineup_matchups.csv', setter: setMatchupCsv, fileSetter: setMatchupFile, label: 'Matchup' },
                            { name: 'lineup_stats_enhanced.csv', setter: setLineupCsv, fileSetter: setLineupFile, label: 'Lineup' },
                            { name: 'player_stats_enhanced.csv', setter: setSeasonCsv, fileSetter: setSeasonFile, label: 'Season' }
                        ];

                        for (const fileConfig of filesToLoad) {
                            // Check primary file
                            let loaded = false;
                            const primaryExists = fileNames.includes(fileConfig.name.toLowerCase());

                            if (primaryExists) {
                                try {
                                    const content = await readTextFile(scraperPath + '/' + fileConfig.name);
                                    if (content) {
                                        fileConfig.setter(content);
                                        fileConfig.fileSetter(fileConfig.name);
                                        loadedFiles.push(fileConfig.label + ': ' + fileConfig.name);
                                        loaded = true;
                                    }
                                } catch (e) {
                                    console.warn('[Scraper] Failed to load ' + fileConfig.name + ':', e);
                                }
                            }

                            // Try fallback if available and primary failed
                            if (!loaded && fileConfig.fallback) {
                                const fallbackExists = fileNames.includes(fileConfig.fallback.toLowerCase());
                                if (fallbackExists) {
                                    try {
                                        const content = await readTextFile(scraperPath + '/' + fileConfig.fallback);
                                        if (content) {
                                            fileConfig.setter(content);
                                            fileConfig.fileSetter(fileConfig.fallback);
                                            loadedFiles.push(fileConfig.label + ': ' + fileConfig.fallback);
                                        }
                                    } catch (e) { /* ignore */ }
                                }
                            }
                        }

                        if (loadedFiles.length > 0) {
                            setLocalScraperDataPath(scraperPath);
                            setDataSource('scraper');

                            // Extract folder info from path for display
                            const folderName = scraperPath.split(/[/\\]/).pop();
                            if (folderName && folderName.startsWith('data_')) {
                                // Handle both formats: data_YYYYMMDD_HHMM_CODE (old) and data_YYYY-MM-DDTHH-MM_CODE (new)
                                const afterPrefix = folderName.substring(5); // Remove 'data_'
                                let timestamp, competitionCode, formattedDate, formattedTime;

                                if (afterPrefix.includes('T')) {
                                    // New format: 2026-02-02T16-03_BBE
                                    const lastUnderscoreIdx = afterPrefix.lastIndexOf('_');
                                    const dateTimePart = afterPrefix.substring(0, lastUnderscoreIdx);
                                    competitionCode = afterPrefix.substring(lastUnderscoreIdx + 1);
                                    timestamp = dateTimePart;
                                    const [datePart, timePart] = dateTimePart.split('T');
                                    const [year, month, day] = datePart.split('-');
                                    formattedDate = day + '/' + month + '/' + year;
                                    formattedTime = timePart.replace('-', ':');
                                } else {
                                    // Old format: YYYYMMDD_HHMM_CODE
                                    const parts = afterPrefix.split('_');
                                    if (parts.length >= 3) {
                                        const dateStr = parts[0];
                                        const timeStr = parts[1];
                                        competitionCode = parts.slice(2).join('_');
                                        timestamp = dateStr + '_' + timeStr;
                                        formattedDate = dateStr.substring(6,8) + '/' + dateStr.substring(4,6) + '/' + dateStr.substring(0,4);
                                        formattedTime = timeStr.substring(0,2) + ':' + timeStr.substring(2,4);
                                    }
                                }

                                if (competitionCode) {
                                    setCurrentDataFolderInfo({
                                        folderName,
                                        timestamp,
                                        competitionCode,
                                        formattedDate,
                                        formattedTime
                                    });
                                }
                            }

                            return loadedFiles;
                        }

                        return null;
                    } catch (e) {
                        console.warn('[Scraper] Error loading from scraper folder:', e);
                        return null;
                    }
                };

                // Helper to scan for data folders via fetch (for GitHub/web hosting)
                // Uses folders.json manifest auto-generated by GitHub Actions
                const scanWebDataFolders = async () => {
                    try {
                        // Fetch the manifest file
                        const response = await fetch('./folders.json');
                        if (!response.ok) {
                            console.log('[AutoLoad] No folders.json manifest found');
                            return [];
                        }

                        const manifest = await response.json();
                        if (!manifest.folders || manifest.folders.length === 0) {
                            console.log('[AutoLoad] folders.json is empty');
                            return [];
                        }

                        // Process folders from manifest
                        const foundFolders = manifest.folders.map(f => {
                            let created_at = 0;
                            if (f.timestamp !== 'legacy') {
                                // Handle both formats: YYYYMMDD_HHMM (old) and YYYY-MM-DDTHH-MM (new ISO-like)
                                if (f.timestamp.includes('T')) {
                                    // New format: 2026-02-02T16-03 -> 202602021603
                                    created_at = parseInt(f.timestamp.replace(/-/g, '').replace('T', ''), 10);
                                } else {
                                    // Old format: 20260202_1603 -> 202602021603
                                    created_at = parseInt(f.timestamp.replace('_', ''), 10);
                                }
                            }
                            return {
                                path: f.path,
                                folder_name: f.folder_name,
                                timestamp: f.timestamp,
                                competition_code: f.competition_code,
                                created_at
                            };
                        });

                        // Sort by created_at descending (newest first, legacy last)
                        foundFolders.sort((a, b) => b.created_at - a.created_at);

                        if (foundFolders.length > 0) {
                            setAvailableDataFolders(foundFolders);
                            const codes = [...new Set(foundFolders.map(f => f.competition_code))];
                            setAvailableCompetitionCodes(codes);
                            if (!selectedCompetitionCode && codes.length > 0) {
                                // Default to the competition code of the most recent folder overall
                                setSelectedCompetitionCode(foundFolders[0].competition_code);
                            }
                        }

                        console.log('[AutoLoad] Found ' + foundFolders.length + ' folders from manifest, sorted by date:',
                            foundFolders.map(f => f.folder_name + ' (' + f.competition_code + ', ' + f.created_at + ')'));
                        return foundFolders;
                    } catch (e) {
                        console.log('[AutoLoad] Error reading folders.json:', e.message);
                        return [];
                    }
                };

                const attemptAutoLoad = async () => {
                    setAutoLoadStatus('loading');
                    setAutoLoadMessage('Scanning for data...');

                    // PRIORITY 1: Try Tauri scraper output folder first
                    if (window.__TAURI__) {
                        setAutoLoadMessage('Checking for scraper data...');
                        const scraperLoaded = await tryLoadFromTauriScraperFolder();
                        if (scraperLoaded && scraperLoaded.length > 0) {
                            setAutoLoadStatus('success');
                            setAutoLoadMessage('Loaded from scraper data');
                            setFolderLoaded(scraperLoaded);
                            console.log('[Scraper] Successfully loaded from Tauri scraper folder');
                            return;
                        }
                        console.log('[Scraper] No Tauri scraper data, trying web folders...');
                    }

                    // Skip regular auto-load if running via file:// protocol (won't work due to CORS)
                    // But allow if in Tauri since it can handle local files differently
                    if (window.location.protocol === 'file:' && !window.__TAURI__) {
                        setAutoLoadStatus('failed');
                        setAutoLoadMessage('Auto-load disabled for local file:// access. Use folder upload or run scraper.');
                        return;
                    }

                    setAutoLoadMessage('Scanning for data folder...');

                    // PRIORITY 2: Try timestamped folders first (newest with selected competition code)
                    const webFolders = await scanWebDataFolders();
                    if (webFolders.length > 0) {
                        const targetCode = selectedCompetitionCode || webFolders[0].competition_code;
                        const targetFolder = webFolders.find(f => f.competition_code === targetCode) || webFolders[0];

                        if (targetFolder) {
                            setAutoLoadMessage('Found data in ' + targetFolder.folder_name + ', loading...');
                            const loaded = await tryLoadFromFolder(targetFolder.path);

                            if (loaded.length > 0) {
                                setAutoLoadStatus('success');
                                setAutoLoadMessage('Loaded from ' + targetFolder.folder_name);
                                setFolderLoaded(loaded);
                                setDataSource('folder');
                                setSelectedCompetitionCode(targetFolder.competition_code);
                                // Handle both timestamp formats for display
                                let formattedDate, formattedTime;
                                if (targetFolder.timestamp.includes('T')) {
                                    // New format: 2026-02-02T16-03
                                    const [datePart, timePart] = targetFolder.timestamp.split('T');
                                    const [year, month, day] = datePart.split('-');
                                    formattedDate = day + '/' + month + '/' + year;
                                    formattedTime = timePart.replace('-', ':');
                                } else if (targetFolder.timestamp !== 'legacy') {
                                    // Old format: YYYYMMDD_HHMM
                                    formattedDate = targetFolder.timestamp.substring(6,8) + '/' + targetFolder.timestamp.substring(4,6) + '/' + targetFolder.timestamp.substring(0,4);
                                    formattedTime = targetFolder.timestamp.substring(9,11) + ':' + targetFolder.timestamp.substring(11,13);
                                } else {
                                    formattedDate = 'Legacy';
                                    formattedTime = '';
                                }
                                setCurrentDataFolderInfo({
                                    folderName: targetFolder.folder_name,
                                    timestamp: targetFolder.timestamp,
                                    competitionCode: targetFolder.competition_code,
                                    formattedDate,
                                    formattedTime
                                });
                                return;
                            }
                        }
                    }

                    // PRIORITY 3: Try legacy folder paths (./data is the default)
                    const foldersToTry = [DATA_FOLDER, ...ALT_FOLDERS];

                    for (const folder of foldersToTry) {
                        try {
                            // Quick check if folder exists by trying to fetch a known file
                            // Use GET instead of HEAD as GitHub Pages/raw content doesn't support HEAD well
                            setAutoLoadMessage('Checking ' + folder + '...');
                            const testResponse = await fetch(folder + '/stints.csv').catch(() => null);

                            if (testResponse && testResponse.ok) {
                                setAutoLoadMessage('Found data in ' + folder + ', loading...');
                                const loaded = await tryLoadFromFolder(folder);

                                if (loaded.length > 0) {
                                    setAutoLoadStatus('success');
                                    setAutoLoadMessage('Auto-loaded from ' + folder);
                                    setFolderLoaded(loaded);
                                    setDataSource('folder');
                                    return;
                                }
                            }
                        } catch (e) {
                            // Folder not found or not accessible, try next
                            console.log('[AutoLoad] Folder ' + folder + ' not accessible:', e.message);
                        }
                    }

                    // No folder found
                    setAutoLoadStatus('failed');
                    setAutoLoadMessage('No data folder found. Use folder upload, run scraper, or place data in ./data folder.');
                };

                // Expose attemptAutoLoad globally for parent app to trigger reload
                window._slbReloadForCompetitionCode = async (code) => {
                    console.log('[AutoLoad] Reloading data for competition code:', code);
                    setSelectedCompetitionCode(code);
                    setAutoLoadStatus('loading');
                    setAutoLoadMessage('Loading ' + code + ' data...');

                    // Clear existing data to force reload
                    setLineupCsv(null);
                    setPlayerCsv(null);
                    setStintsCsv(null);
                    setPlayerStintsCsv(null);
                    setSeasonCsv(null);
                    setClutchCsv(null);
                    setTeamTotalsCsv(null);
                    setMatchupCsv(null);
                    setAssistComboCsv(null);

                    // PRIORITY 1: For Tauri, try scraper folder first
                    if (window.__TAURI__) {
                        const loaded = await tryLoadFromTauriScraperFolder(code);
                        if (loaded && loaded.length > 0) {
                            setAutoLoadStatus('success');
                            setAutoLoadMessage('Loaded ' + code + ' data');
                            setFolderLoaded(loaded);
                            return true;
                        }
                        console.log('[AutoLoad] No Tauri scraper data for ' + code + ', trying web folders...');
                    }

                    // PRIORITY 2: Try web folders (works for both Tauri and web)
                    const webFolders = await scanWebDataFolders();
                    if (webFolders.length > 0) {
                        // Find the newest folder for this competition code (webFolders is sorted by date desc)
                        const targetFolder = webFolders.find(f => f.competition_code === code);
                        console.log('[AutoLoad] For code ' + code + ', selected folder:', targetFolder?.folder_name, 'from', webFolders.filter(f => f.competition_code === code).length, 'matching folders');
                        if (targetFolder) {
                            const loaded = await tryLoadFromFolder(targetFolder.path);
                            if (loaded.length > 0) {
                                setAutoLoadStatus('success');
                                setAutoLoadMessage('Loaded from ' + targetFolder.folder_name);
                                setFolderLoaded(loaded);
                                setDataSource('folder');

                                let formattedDate, formattedTime;
                                if (targetFolder.timestamp.includes('T')) {
                                    const [datePart, timePart] = targetFolder.timestamp.split('T');
                                    const [year, month, day] = datePart.split('-');
                                    formattedDate = day + '/' + month + '/' + year;
                                    formattedTime = timePart.replace('-', ':');
                                } else if (targetFolder.timestamp !== 'legacy') {
                                    formattedDate = targetFolder.timestamp.substring(6,8) + '/' + targetFolder.timestamp.substring(4,6) + '/' + targetFolder.timestamp.substring(0,4);
                                    formattedTime = targetFolder.timestamp.substring(9,11) + ':' + targetFolder.timestamp.substring(11,13);
                                } else {
                                    formattedDate = 'Legacy';
                                    formattedTime = '';
                                }
                                setCurrentDataFolderInfo({
                                    folderName: targetFolder.folder_name,
                                    timestamp: targetFolder.timestamp,
                                    competitionCode: targetFolder.competition_code,
                                    formattedDate,
                                    formattedTime
                                });
                                return true;
                            }
                        }
                    }

                    setAutoLoadStatus('failed');
                    setAutoLoadMessage('No data found for ' + code);
                    return false;
                };

                // Load data from parent-provided URLs (for mobile Tauri where iframe can't access folders.json)
                window._slbLoadFromDataUrls = async (dataFiles) => {
                    console.log('[DataFiles] Loading data from parent-provided URLs...');
                    setAutoLoadStatus('loading');
                    setAutoLoadMessage('Loading data from parent...');

                    const CSV_FILE_MAP = {
                        'stints.csv': setStintsCsv,
                        'player_stints.csv': setPlayerStintsCsv,
                        'team_totals.csv': setTeamTotalsCsv,
                        'clutch_lineup_stats.csv': setClutchCsv,
                        'player_lineup_stats_enhanced.csv': setPlayerCsv,
                        'lineup_assist_combinations.csv': setAssistComboCsv,
                        'assist_combinations.csv': setAssistComboCsv,
                        'lineup_matchups.csv': setMatchupCsv,
                        'lineup_stats_enhanced.csv': setLineupCsv,
                        'player_stats_enhanced.csv': setSeasonCsv
                    };

                    // Separate CSV files from game_html files
                    const csvDataFiles = [];
                    const gameHtmlDataFiles = [];
                    for (const fileInfo of dataFiles) {
                        if (fileInfo.name.startsWith('game_html/')) {
                            gameHtmlDataFiles.push(fileInfo);
                        } else {
                            csvDataFiles.push(fileInfo);
                        }
                    }

                    let loadedCount = 0;
                    let loadedNames = [];

                    // Load CSV files
                    for (const fileInfo of csvDataFiles) {
                        try {
                            const resp = await fetch(fileInfo.url);
                            if (resp.ok) {
                                const content = await resp.text();
                                const setter = CSV_FILE_MAP[fileInfo.name];
                                if (setter) {
                                    setter(content);
                                    loadedCount++;
                                    loadedNames.push(fileInfo.name);
                                }
                            }
                        } catch (e) {
                            console.error('[DataFiles] Failed to load:', fileInfo.name, e);
                        }
                    }

                    // Load game_html files (pair bs/pbp by game ID)
                    if (gameHtmlDataFiles.length > 0) {
                        console.log('[DataFiles] Loading ' + gameHtmlDataFiles.length + ' game_html files...');
                        setAutoLoadMessage('Loading game HTML files...');

                        // Group by game ID: game_html/game{id}bs.html + game_html/game{id}pbp.html
                        const gameMap = {};
                        for (const fileInfo of gameHtmlDataFiles) {
                            const filename = fileInfo.name.replace('game_html/', '');
                            const bsMatch = filename.match(/^game(\d+)bs\.html?$/i);
                            const pbpMatch = filename.match(/^game(\d+)pbp\.html?$/i);
                            if (bsMatch) {
                                const gid = bsMatch[1];
                                if (!gameMap[gid]) gameMap[gid] = {};
                                gameMap[gid].bsUrl = fileInfo.url;
                            } else if (pbpMatch) {
                                const gid = pbpMatch[1];
                                if (!gameMap[gid]) gameMap[gid] = {};
                                gameMap[gid].pbpUrl = fileInfo.url;
                            }
                        }

                        // Fetch game HTML pairs in parallel (batched to avoid overwhelming)
                        const gameIds = Object.keys(gameMap);
                        const validGames = [];
                        const BATCH_SIZE = 5;

                        for (let i = 0; i < gameIds.length; i += BATCH_SIZE) {
                            const batch = gameIds.slice(i, i + BATCH_SIZE);
                            const batchResults = await Promise.all(batch.map(async (gameId) => {
                                const entry = gameMap[gameId];
                                if (!entry.bsUrl || !entry.pbpUrl) return null;
                                try {
                                    const [bsResp, pbpResp] = await Promise.all([
                                        fetch(entry.bsUrl).catch(() => null),
                                        fetch(entry.pbpUrl).catch(() => null)
                                    ]);
                                    if (bsResp && bsResp.ok && pbpResp && pbpResp.ok) {
                                        const bsContent = await bsResp.text();
                                        const pbpContent = await pbpResp.text();
                                        return { gameId, bsContent, pbpContent };
                                    }
                                } catch (e) { /* ignore individual failures */ }
                                return null;
                            }));
                            validGames.push(...batchResults.filter(Boolean));
                        }

                        if (validGames.length > 0) {
                            console.log('[DataFiles] Loaded ' + validGames.length + ' game HTML pairs');
                            loadedNames.push('Game HTML: ' + validGames.length + ' games');

                            // Parse game summaries
                            const summaries = validGames.map(game => {
                                try {
                                    return parseGameSummary(game.bsContent, game.gameId);
                                } catch (e) {
                                    console.warn('[DataFiles] Failed to parse game ' + game.gameId);
                                    return null;
                                }
                            }).filter(Boolean);

                            // Create pseudo-file objects for loadGameForAnalysis
                            const pseudoGameFiles = validGames.map(game => ({
                                gameId: game.gameId,
                                bs: { text: async () => game.bsContent },
                                pbp: { text: async () => game.pbpContent },
                                _isAutoLoaded: true,
                                _bsContent: game.bsContent,
                                _pbpContent: game.pbpContent
                            }));

                            setGvGameHtmlFiles(pseudoGameFiles);

                            // Sort summaries by date (most recent first)
                            const parseGameDate = (dateStr) => {
                                if (!dateStr) return null;
                                const parts = dateStr.split(/[\/\-]/);
                                if (parts.length === 3) {
                                    let [day, month, year] = parts.map(p => parseInt(p));
                                    if (year < 100) year += 2000;
                                    return new Date(year, month - 1, day);
                                }
                                const parsed = new Date(dateStr);
                                return isNaN(parsed.getTime()) ? null : parsed;
                            };

                            summaries.sort((a, b) => {
                                const dateA = parseGameDate(a.date);
                                const dateB = parseGameDate(b.date);
                                if (!dateA && !dateB) return 0;
                                if (!dateA) return 1;
                                if (!dateB) return -1;
                                return dateB - dateA;
                            });

                            setGvFolderGames(summaries);
                        }
                    }

                    if (loadedCount > 0) {
                        setAutoLoadStatus('success');
                        setAutoLoadMessage('Loaded ' + loadedCount + ' data files');
                        setFolderLoaded(loadedNames);
                        setDataSource('parent');
                        console.log('[DataFiles] Successfully loaded:', loadedNames);
                    } else {
                        setAutoLoadStatus('failed');
                        setAutoLoadMessage('No data files could be loaded from parent');
                    }
                };

                // Check for buffered DATA_FILES_INFO that arrived before React mounted
                if (window._slbPendingDataFiles && window._slbPendingDataFiles.length > 0) {
                    console.log('[DataFiles] Found buffered data files from parent, loading now...');
                    window._slbLoadFromDataUrls(window._slbPendingDataFiles);
                    window._slbPendingDataFiles = null;
                }

                // Notify parent that this app is ready to receive data
                if (window.parent !== window) {
                    try {
                        window.parent.postMessage({
                            source: 'slb-child-app',
                            type: 'APP_READY',
                            appType: 'lineup-analyzer'
                        }, '*');
                        console.log('[ParentBridge] Sent APP_READY to parent');
                    } catch (e) {
                        console.log('[ParentBridge] Could not send APP_READY:', e);
                    }
                }

                // Only attempt auto-load if no data is already loaded
                if (!lineupCsv && !playerCsv && !stintsCsv) {
                    const isInIframe = window.parent !== window;
                    const isInTauri = !!window.__TAURI__;

                    if (isInIframe) {
                        // In an iframe (either Tauri desktop or mobile webview)
                        // Wait for parent to send competition code and/or data file URLs
                        console.log('[AutoLoad] In iframe, waiting for parent data...', isInTauri ? '(Tauri)' : '(mobile/remote)');
                        setAutoLoadMessage('Waiting for competition selection...');

                        let receivedData = false;

                        // Set up listener for parent messages (competition code or data files)
                        const handleInitialParentData = async (event) => {
                            if (!event.data || event.data.source !== 'slb-parent-app') return;

                            if (event.data.type === 'DATA_FILES_INFO' && event.data.dataFiles && event.data.dataFiles.length > 0) {
                                // Parent sent data file URLs directly - use them (mobile path)
                                receivedData = true;
                                window.removeEventListener('message', handleInitialParentData);
                                console.log('[AutoLoad] Received DATA_FILES_INFO from parent:', event.data.dataFiles.length, 'files');
                                if (typeof window._slbLoadFromDataUrls === 'function') {
                                    window._slbLoadFromDataUrls(event.data.dataFiles);
                                }
                            } else if (event.data.type === 'COMP_CODE_CHANGE') {
                                const code = event.data.competitionCode;
                                console.log('[AutoLoad] Received competition code from parent:', code);

                                if (isInTauri) {
                                    // On Tauri desktop, use the reload function which fetches from local/GitHub
                                    receivedData = true;
                                    window.removeEventListener('message', handleInitialParentData);
                                    if (code && typeof window._slbReloadForCompetitionCode === 'function') {
                                        window._slbReloadForCompetitionCode(code);
                                    } else {
                                        setSelectedCompetitionCode(code);
                                        attemptAutoLoad();
                                    }
                                } else {
                                    // On mobile (no Tauri), set the code but keep listening for DATA_FILES_INFO
                                    // The parent sends DATA_FILES_INFO after the competition code
                                    setSelectedCompetitionCode(code);
                                    console.log('[AutoLoad] Mobile: set comp code, still listening for DATA_FILES_INFO...');
                                }
                            }
                        };
                        window.addEventListener('message', handleInitialParentData);

                        // Timeout fallback - if no data received within 5 seconds
                        setTimeout(() => {
                            if (!receivedData) {
                                window.removeEventListener('message', handleInitialParentData);
                                console.log('[AutoLoad] No data from parent after 5s, falling back to auto-load');
                                attemptAutoLoad();
                            }
                        }, 5000);
                    } else {
                        // Not in iframe, proceed with normal auto-load (standalone mode)
                        attemptAutoLoad();
                    }
                }
            }, []); // Run once on mount

            // Folder upload handler - automatically detects and loads all CSV files
            const handleFolder = (ev) => {
                const files = Array.from(ev.target.files);
                const csvFiles = files.filter(f => f.name.endsWith('.csv'));
                let loadedNames = [];
                
                // Helper to read and set file
                const readFile = (file, setter, fileSetter, label) => {
                    const reader = new FileReader();
                    reader.onload = (e) => { setter(e.target.result); fileSetter(file.name); };
                    reader.readAsText(file);
                    loadedNames.push(label + ': ' + file.name);
                    return true;
                };
                
                // Build file map for easier lookup (lowercase name -> file)
                const fileMap = new Map();
                csvFiles.forEach(f => fileMap.set(f.name.toLowerCase(), f));
                
                // Helper to find file - ONLY returns enhanced version, no fallback to regular
                const findFile = (baseName, excludePatterns = [], requireEnhanced = true) => {
                    // baseName is like 'player_lineup_stats.csv' or 'player_lineup_stats_enhanced.csv'
                    const base = baseName.replace('_enhanced.csv', '').replace('.csv', '');
                    const enhancedName = base + '_enhanced.csv';
                    const regularName = base + '.csv';

                    // Check if excluded
                    const isExcluded = (name) => excludePatterns.some(ex => name.includes(ex));

                    // Priority 1: Exact enhanced match
                    if (fileMap.has(enhancedName) && !isExcluded(enhancedName)) {
                        return fileMap.get(enhancedName);
                    }

                    // Priority 2: Pattern match for enhanced (in case of different naming)
                    for (const [name, file] of fileMap) {
                        if (name.includes(base) && name.includes('enhanced') && !isExcluded(name)) {
                            return file;
                        }
                    }

                    // Only fall back to regular if not requiring enhanced
                    if (!requireEnhanced) {
                        // Priority 3: Exact regular match
                        if (fileMap.has(regularName) && !isExcluded(regularName)) {
                            return fileMap.get(regularName);
                        }

                        // Priority 4: Pattern match for regular (fallback)
                        for (const [name, file] of fileMap) {
                            if (name.includes(base) && !name.includes('enhanced') && !isExcluded(name)) {
                                return file;
                            }
                        }
                    }

                    return null;
                };
                
                // 1. Stints - for RAPM calculation (exact match only)
                const stintsFile = fileMap.get('stints.csv');
                if (stintsFile) readFile(stintsFile, setStintsCsv, setStintsFile, 'Stints');

                // 1b. Player stints - for VS Starters stats (exact match only)
                const playerStintsFile = fileMap.get('player_stints.csv');
                if (playerStintsFile) readFile(playerStintsFile, setPlayerStintsCsv, setPlayerStintsFile, 'PlayerStints');

                // 2. Team totals - for game-level stats (exact match only)
                const teamTotalsFile = fileMap.get('team_totals.csv');
                if (teamTotalsFile) readFile(teamTotalsFile, setTeamTotalsCsv, setTeamTotalsFile, 'TeamTotals');
                
                // 3. Clutch lineup stats (exact match only)
                const clutchFile = fileMap.get('clutch_lineup_stats.csv');
                if (clutchFile) readFile(clutchFile, setClutchCsv, setClutchFile, 'Clutch');
                
                // 4. Player lineup stats (enhanced version required, exclude 'assist')
                const playerLineupFile = findFile('player_lineup_stats_enhanced.csv', ['assist']);
                if (playerLineupFile) {
                    console.log('[DEBUG] Loading player_lineup_stats_enhanced file:', playerLineupFile.name);
                    readFile(playerLineupFile, setPlayerCsv, setPlayerFile, 'Player');
                }
                
                // 5. Assist combinations - prefer lineup_assist_combinations, fallback to assist_combinations
                let assistFile = fileMap.get('lineup_assist_combinations.csv');
                if (!assistFile) assistFile = fileMap.get('assist_combinations.csv');
                if (assistFile) readFile(assistFile, setAssistComboCsv, setAssistComboFile, 'Assist');
                
                // 6. Matchups (exact match only)
                const matchupFile = fileMap.get('lineup_matchups.csv');
                if (matchupFile) readFile(matchupFile, setMatchupCsv, setMatchupFile, 'Matchup');
                
                // 7. Lineup stats (ONLY enhanced version, exclude 'player_', 'clutch', 'assist')
                const lineupFile = findFile('lineup_stats_enhanced.csv', ['player_', 'clutch', 'assist'], true);
                if (lineupFile) readFile(lineupFile, setLineupCsv, setLineupFile, 'Lineup');

                // 8. Player/Season stats (ONLY enhanced version, exclude 'lineup')
                const seasonFile = findFile('player_stats_enhanced.csv', ['lineup'], true);
                if (seasonFile) readFile(seasonFile, setSeasonCsv, setSeasonFile, 'Season');

                // ═══════════════════════════════════════════════════════════════════════════
                // V6.0: SCAN FOR game_html FOLDER FOR ADVANCED GAMES VIEW
                // Supports: game_html/game[id]bs.html + game[id]pbp.html pairs
                // ═══════════════════════════════════════════════════════════════════════════
                const htmlFiles = files.filter(f => f.name.endsWith('.html') || f.name.endsWith('.htm'));
                if (htmlFiles.length > 0) {
                    const gameFilesMap = new Map(); // gameId -> { bs: file, pbp: file, sc: file }

                    htmlFiles.forEach(file => {
                        const path = file.webkitRelativePath || file.name;
                        const filename = file.name.toLowerCase();

                        // Check if file is in game_html folder
                        const inGameHtmlFolder = path.toLowerCase().includes('game_html');

                        if (inGameHtmlFolder || filename.match(/game\d+/i)) {
                            // Match patterns: game[id]bs.html, game[id]pbp.html, game[id]sc.html
                            const bsMatch = filename.match(/game(\d+)bs\.html?$/i) || path.match(/game(\d+)bs[\/\\]/i);
                            const pbpMatch = filename.match(/game(\d+)pbp\.html?$/i) || path.match(/game(\d+)pbp[\/\\]/i);
                            const scMatch = filename.match(/game(\d+)sc\.html?$/i) || path.match(/game(\d+)sc[\/\\]/i);

                            // Also support alternate patterns: [id]bs.html
                            const altBsMatch = !bsMatch && filename.match(/^(\d+)bs\.html?$/i);
                            const altPbpMatch = !pbpMatch && filename.match(/^(\d+)pbp\.html?$/i);
                            const altScMatch = !scMatch && filename.match(/^(\d+)sc\.html?$/i);

                            const effectiveBsMatch = bsMatch || altBsMatch;
                            const effectivePbpMatch = pbpMatch || altPbpMatch;
                            const effectiveScMatch = scMatch || altScMatch;

                            if (effectiveBsMatch) {
                                const gameId = effectiveBsMatch[1];
                                if (!gameFilesMap.has(gameId)) gameFilesMap.set(gameId, {});
                                gameFilesMap.get(gameId).bs = file;
                            } else if (effectivePbpMatch) {
                                const gameId = effectivePbpMatch[1];
                                if (!gameFilesMap.has(gameId)) gameFilesMap.set(gameId, {});
                                gameFilesMap.get(gameId).pbp = file;
                            } else if (effectiveScMatch) {
                                const gameId = effectiveScMatch[1];
                                if (!gameFilesMap.has(gameId)) gameFilesMap.set(gameId, {});
                                gameFilesMap.get(gameId).sc = file;
                            }
                        }
                    });

                    // Process games with both bs and pbp files
                    const validGames = [];
                    gameFilesMap.forEach((files, gameId) => {
                        if (files.bs && files.pbp) {
                            validGames.push({ gameId, ...files });
                        }
                    });

                    if (validGames.length > 0) {
                        loadedNames.push('Game HTML: ' + validGames.length + ' games found');
                        // Store the game files for later processing
                        setGvGameHtmlFiles(validGames);
                        // Parse game summaries asynchronously
                        processGameHtmlFiles(validGames);
                    }
                }
                // ═══════════════════════════════════════════════════════════════════════════

                // Summary
                if (loadedNames.length > 0) {
                    setFolderLoaded(loadedNames);
                } else {
                    setFolderLoaded(['No matching CSV files found. Expected files:',
                        '• stints.csv', '• team_totals.csv', '• clutch_lineup_stats.csv',
                        '• player_lineup_stats_enhanced.csv', '• lineup_stats.csv (or _enhanced)',
                        '• player_stats.csv (or _enhanced)', '• lineup_matchups.csv', '• assist_combinations.csv',
                        '• game_html/ folder with game[id]bs.html + game[id]pbp.html pairs']);
                }
            };

            // ═══════════════════════════════════════════════════════════════════════════
            // V6.0: ADVANCED GAMES VIEW - GAME HTML FILE PROCESSING
            // ═══════════════════════════════════════════════════════════════════════════

            // Parse game summary from boxscore HTML
            // ═══════════════════════════════════════════════════════════════════════════
            // PARSE GAME SUMMARY - Exact copy from GAMEVIS for accurate score extraction
            // Uses FIBA LiveStats ID patterns: span[id="aj_X_tot_sPoints"]
            // ═══════════════════════════════════════════════════════════════════════════
            const parseGameSummary = (html, gameId) => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                let homeTeam = '', awayTeam = '', homeScore = 0, awayScore = 0;
                const teamStats = [];

                // Method 1: Use FIBA LiveStats IDs (same as parseBoxscore)
                const team1NameEl = doc.querySelector('#aj_1_name');
                const team2NameEl = doc.querySelector('#aj_2_name');

                if (team1NameEl) homeTeam = team1NameEl.textContent.trim();
                if (team2NameEl) awayTeam = team2NameEl.textContent.trim();

                // Method 2: Fallback to table captions if IDs not found
                if (!homeTeam || !awayTeam) {
                    const captions = doc.querySelectorAll('table caption');
                    const captionTexts = [];
                    captions.forEach(cap => {
                        const text = cap.textContent.trim();
                        if (text && text.length > 2 && text.length < 60) {
                            captionTexts.push(text);
                        }
                    });
                    if (captionTexts.length >= 2) {
                        if (!homeTeam) homeTeam = captionTexts[0];
                        if (!awayTeam) awayTeam = captionTexts[1];
                    }
                }

                // Extract team totals - try FIBA LiveStats IDs first (CRITICAL FOR SCORES!)
                for (let teamId = 1; teamId <= 2; teamId++) {
                    const prefix = `aj_${teamId}_tot_`;

                    const getValueById = (suffix) => {
                        const span = doc.querySelector(`span[id="${prefix}${suffix}"]`);
                        return span ? parseInt(span.textContent.trim()) || 0 : 0;
                    };

                    let pts = getValueById('sPoints');
                    let fgm = getValueById('sFieldGoalsMade');
                    let fga = getValueById('sFieldGoalsAttempted');
                    let fg3m = getValueById('sThreePointersMade');
                    let fta = getValueById('sFreeThrowsAttempted');
                    let tov = getValueById('sTurnovers');
                    let oreb = getValueById('sReboundsOffensive');
                    let dreb = getValueById('sReboundsDefensive');

                    // If FIBA IDs didn't work, try parsing from table structure
                    if (pts === 0 && fga === 0) {
                        const tables = doc.querySelectorAll('table.boxscore, table');
                        const table = tables[teamId - 1];

                        if (table) {
                            // Try team-totals row first
                            let totalRow = table.querySelector('tr.team-totals');
                            if (!totalRow) totalRow = table.querySelector('tr.total');
                            if (!totalRow) totalRow = table.querySelector('tfoot tr');

                            if (totalRow) {
                                // Get headers
                                const thead = table.querySelector('thead');
                                const headers = [];
                                if (thead) {
                                    thead.querySelectorAll('th').forEach(th => {
                                        headers.push(th.textContent.trim().toUpperCase());
                                    });
                                }

                                const cells = totalRow.querySelectorAll('td');

                                const getValueByHeader = (names) => {
                                    for (const name of names) {
                                        const idx = headers.findIndex(h => h === name || h.includes(name));
                                        if (idx >= 0 && cells[idx]) {
                                            const val = parseInt(cells[idx].textContent.trim());
                                            if (!isNaN(val)) return val;
                                        }
                                    }
                                    return 0;
                                };

                                pts = getValueByHeader(['PTS', 'POINTS']);
                                fgm = getValueByHeader(['FGM', '2PM']);
                                fga = getValueByHeader(['FGA', '2PA']);
                                fg3m = getValueByHeader(['3PM', '3FGM', '3P']);
                                fta = getValueByHeader(['FTA']);
                                tov = getValueByHeader(['TO', 'TOV']);
                                oreb = getValueByHeader(['OR', 'OREB']);
                                dreb = getValueByHeader(['DR', 'DREB']);
                            }
                        }
                    }

                    teamStats.push({ pts, fgm, fga, fg3m, fta, tov, oreb, dreb });
                }

                // Assign scores from properly parsed team stats
                if (teamStats.length >= 1) homeScore = teamStats[0].pts;
                if (teamStats.length >= 2) awayScore = teamStats[1].pts;

                // Calculate four factors for game browser display
                const calcFourFactors = (team, opponent) => {
                    let efg = 50, tovPct = 15, orebPct = 25, ftRate = 25;

                    if (team && team.fga > 0) {
                        efg = ((team.fgm + 0.5 * team.fg3m) / team.fga) * 100;
                        ftRate = (team.fta / team.fga) * 100;

                        const poss = team.fga + 0.44 * team.fta + team.tov;
                        if (poss > 0) {
                            tovPct = (team.tov / poss) * 100;
                        }
                    }

                    // OREB% = OREB / (OREB + Opponent DREB)
                    if (team && opponent) {
                        const orebOpportunities = team.oreb + opponent.dreb;
                        if (orebOpportunities > 0) {
                            orebPct = (team.oreb / orebOpportunities) * 100;
                        }
                    }

                    return { efg, tovPct, orebPct, ftRate };
                };

                const fourFactors = {
                    home: calcFourFactors(teamStats[0], teamStats[1]),
                    away: calcFourFactors(teamStats[1], teamStats[0])
                };

                // Extract date from matchDetail div containing "Game Details"
                let date = '';
                let competition = '';
                const matchDetails = doc.querySelectorAll('.matchDetail');

                for (const detail of matchDetails) {
                    const heading = detail.querySelector('h6');
                    if (!heading) continue;

                    const headingText = heading.textContent.trim();

                    if (headingText.includes('Game Details')) {
                        const text = detail.textContent;
                        const dateMatch = text.match(/(\d{1,2}\/\d{1,2}\/\d{2,4})/);
                        if (dateMatch) {
                            date = dateMatch[1];
                        }
                    }

                    if (headingText.includes('Competition')) {
                        const p = detail.querySelector('p');
                        if (p) {
                            competition = p.textContent.trim();
                        }
                    }
                }

                // Fallback: search all matchDetail divs for any date pattern
                if (!date) {
                    for (const detail of matchDetails) {
                        const text = detail.textContent;
                        const dateMatch = text.match(/(\d{1,2}\/\d{1,2}\/\d{2,4})/);
                        if (dateMatch) {
                            date = dateMatch[1];
                            break;
                        }
                    }
                }

                // Calculate EPA (Expected Points Added) using Four Factors
                // League average values for reference
                // V5.13: EPA calculation using same formula as game analysis page (head-to-head comparison)
                // This ensures consistent values between collapsible cards and full game view
                const POSS = 75; // Standard possession estimate

                // teamStats is array: [0] = home, [1] = away
                // Use raw TOV and OREB counts from teamStats for accurate head-to-head calculation
                const homeStats = teamStats[0] || {};
                const awayStats = teamStats[1] || {};
                const homeTov = homeStats.tov || 0;
                const awayTov = awayStats.tov || 0;
                const homeOreb = homeStats.oreb || 0;
                const awayOreb = awayStats.oreb || 0;

                // Head-to-head EPA calculation (matches game analysis page exactly)
                const tovImpact = (awayTov - homeTov) * 1.1;
                const orebImpact = (homeOreb - awayOreb) * 1.1;
                const efgImpact = ((fourFactors.home.efg || 50) - (fourFactors.away.efg || 50)) * 1.77 * (POSS / 100);
                const ftRateImpact = ((fourFactors.home.ftRate || 25) - (fourFactors.away.ftRate || 25)) * 0.25 * (POSS / 100);

                const epaBattle = tovImpact + orebImpact;  // Possession Battle (EPA Battle in game view)
                const scoringBattleTotal = efgImpact + ftRateImpact;  // Scoring Battle

                const epa = {
                    home: {
                        efgEPA: efgImpact.toFixed(1),
                        tovEPA: tovImpact.toFixed(1),
                        orebEPA: orebImpact.toFixed(1),
                        ftRateEPA: ftRateImpact.toFixed(1),
                        scoringBattle: scoringBattleTotal.toFixed(1),
                        possessionBattle: epaBattle.toFixed(1),
                        totalEPA: (scoringBattleTotal + epaBattle).toFixed(1)
                    },
                    away: {
                        efgEPA: (-efgImpact).toFixed(1),
                        tovEPA: (-tovImpact).toFixed(1),
                        orebEPA: (-orebImpact).toFixed(1),
                        ftRateEPA: (-ftRateImpact).toFixed(1),
                        scoringBattle: (-scoringBattleTotal).toFixed(1),
                        possessionBattle: (-epaBattle).toFixed(1),
                        totalEPA: (-(scoringBattleTotal + epaBattle)).toFixed(1)
                    }
                };

                return {
                    gameId,
                    homeTeam: homeTeam || `Game ${gameId} - Home`,
                    awayTeam: awayTeam || `Game ${gameId} - Away`,
                    homeScore,
                    awayScore,
                    date,
                    competition,
                    fourFactors,
                    epa,
                    teamStats, // Raw stats for additional calculations
                    isHomeWin: homeScore > awayScore
                };
            };

            // ═══════════════════════════════════════════════════════════════════════════
            // FULL BOXSCORE PARSING - Extract all player stats from FIBA LiveStats HTML
            // Uses exact FIBA LiveStats ID patterns: span[id="aj_X_Y_sStatName"]
            // ═══════════════════════════════════════════════════════════════════════════
            const parseFullBoxscore = (html) => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const teamsData = {};

                // Extract team names
                const teamNames = [];
                for (let i = 1; i <= 2; i++) {
                    const nameSpan = doc.querySelector(`#aj_${i}_name`);
                    if (nameSpan) teamNames.push(nameSpan.textContent.trim());
                    else teamNames.push(`Team ${i}`);
                }

                console.log('[GAMEVIS] Found teams:', teamNames.join(' vs '));

                // Helper to normalize jersey numbers
                const normalizeNumber = (num) => {
                    if (num === null || num === undefined) return null;
                    const str = String(num).trim();
                    if (/^\d+$/.test(str)) return String(parseInt(str, 10));
                    return str;
                };

                // Helper to parse stat value from span
                const parseSpan = (row, prefix, statSuffix) => {
                    const span = row.querySelector(`span[id="${prefix}${statSuffix}"]`);
                    if (!span) return 0;
                    const txt = span.textContent?.trim();
                    return parseInt(txt) || 0;
                };

                // Helper to parse minutes (handles MM:SS format)
                const parseMinutes = (row, prefix) => {
                    const span = row.querySelector(`span[id="${prefix}sMinutes"]`);
                    if (!span) return 0;
                    const txt = span.textContent?.trim();
                    if (txt.includes(':')) {
                        const parts = txt.split(':');
                        return parseInt(parts[0]) + parseInt(parts[1]) / 60;
                    }
                    return parseFloat(txt) || 0;
                };

                // Parse player row - using FIBA stat span IDs
                const parsePlayerRow = (row, teamId) => {
                    const rowId = row.getAttribute('id') || '';
                    const match = rowId.match(/aj_(\d+)_(\d+)_row/);
                    if (!match) return null;

                    const playerId = match[2];
                    const prefix = `aj_${teamId}_${playerId}_`;
                    const player = {};

                    // Jersey number
                    const numSpan = row.querySelector('span[id$="shirtNumber"]');
                    if (numSpan) player.number = normalizeNumber(numSpan.textContent.trim());

                    // Name
                    const nameSpan = row.querySelector(`span[id="${prefix}name"]`) || row.querySelector('span[id$="_name"]');
                    if (nameSpan) player.name = nameSpan.textContent.trim();

                    player.isStarter = row.classList.contains('p_starter');

                    // Parse minutes
                    player.minutes = parseMinutes(row, prefix);

                    // Parse stats using FIBA span ID pattern: sStatName
                    player.points = parseSpan(row, prefix, 'sPoints');
                    player.fgm = parseSpan(row, prefix, 'sFieldGoalsMade');
                    player.fga = parseSpan(row, prefix, 'sFieldGoalsAttempted');
                    player.fg3m = parseSpan(row, prefix, 'sThreePointersMade');
                    player.fg3a = parseSpan(row, prefix, 'sThreePointersAttempted');
                    player.fg2m = parseSpan(row, prefix, 'sTwoPointersMade');
                    player.fg2a = parseSpan(row, prefix, 'sTwoPointersAttempted');
                    player.ftm = parseSpan(row, prefix, 'sFreeThrowsMade');
                    player.fta = parseSpan(row, prefix, 'sFreeThrowsAttempted');
                    player.oreb = parseSpan(row, prefix, 'sReboundsOffensive');
                    player.dreb = parseSpan(row, prefix, 'sReboundsDefensive');
                    player.treb = player.oreb + player.dreb;
                    player.ast = parseSpan(row, prefix, 'sAssists');
                    player.stl = parseSpan(row, prefix, 'sSteals');
                    player.blk = parseSpan(row, prefix, 'sBlocks');
                    player.tov = parseSpan(row, prefix, 'sTurnovers');
                    player.pf = parseSpan(row, prefix, 'sFoulsPersonal');

                    // Calculate 2PT stats if not directly available
                    if (!player.fg2m) player.fg2m = player.fgm - player.fg3m;
                    if (!player.fg2a) player.fg2a = player.fga - player.fg3a;

                    // Calculate advanced stats
                    if (player.fga > 0) {
                        player.fgPct = (player.fgm / player.fga * 100);
                        player.efg = ((player.fgm + 0.5 * player.fg3m) / player.fga * 100);
                    }
                    if (player.fg3a > 0) player.fg3Pct = (player.fg3m / player.fg3a * 100);
                    if (player.fta > 0) player.ftPct = (player.ftm / player.fta * 100);

                    return player;
                };

                // Parse team totals row
                const parseTeamTotals = (row, teamId) => {
                    const prefix = `aj_${teamId}_tot_`;
                    const totals = {
                        points: parseSpan(row, prefix, 'sPoints'),
                        fgm: parseSpan(row, prefix, 'sFieldGoalsMade'),
                        fga: parseSpan(row, prefix, 'sFieldGoalsAttempted'),
                        fg3m: parseSpan(row, prefix, 'sThreePointersMade'),
                        fg3a: parseSpan(row, prefix, 'sThreePointersAttempted'),
                        ftm: parseSpan(row, prefix, 'sFreeThrowsMade'),
                        fta: parseSpan(row, prefix, 'sFreeThrowsAttempted'),
                        oreb: parseSpan(row, prefix, 'sReboundsOffensive'),
                        dreb: parseSpan(row, prefix, 'sReboundsDefensive'),
                        treb: parseSpan(row, prefix, 'sReboundsTotal'),
                        ast: parseSpan(row, prefix, 'sAssists'),
                        stl: parseSpan(row, prefix, 'sSteals'),
                        blk: parseSpan(row, prefix, 'sBlocks'),
                        tov: parseSpan(row, prefix, 'sTurnovers'),
                        pf: parseSpan(row, prefix, 'sFoulsTotal')
                    };
                    return totals;
                };

                // Parse each team's table
                const tables = doc.querySelectorAll('table.boxscore');
                console.log('[GAMEVIS] Found', tables.length, 'boxscore tables');

                tables.forEach((table, tableIdx) => {
                    if (tableIdx >= 2) return;
                    const teamName = teamNames[tableIdx] || `Team ${tableIdx + 1}`;
                    const players = [];
                    let teamTotals = {};

                    // Parse player rows
                    const playerRows = table.querySelectorAll('tr.player-row');
                    console.log('[GAMEVIS] Team', teamName, '- found', playerRows.length, 'player rows');

                    playerRows.forEach(row => {
                        if (row.classList.contains('row-not-used')) return;
                        const player = parsePlayerRow(row, tableIdx + 1);
                        if (player && player.name) {
                            players.push(player);
                            console.log('[GAMEVIS] Parsed player:', player.name, 'PTS:', player.points, 'MIN:', player.minutes);
                        }
                    });

                    // Parse totals
                    const totalsRow = table.querySelector('tr.team-totals');
                    if (totalsRow) {
                        teamTotals = parseTeamTotals(totalsRow, tableIdx + 1);
                        console.log('[GAMEVIS] Team totals:', teamName, 'PTS:', teamTotals.points);
                    }

                    // Calculate team advanced stats
                    // Sum player minutes for team total
                    teamTotals.minutes = players.reduce((sum, p) => sum + (p.minutes || 0), 0);
                    teamTotals.fg2m = teamTotals.fgm - teamTotals.fg3m;
                    teamTotals.fg2a = teamTotals.fga - teamTotals.fg3a;
                    if (teamTotals.fga > 0) {
                        teamTotals.efg = ((teamTotals.fgm + 0.5 * teamTotals.fg3m) / teamTotals.fga * 100);
                    }
                    // Possession estimate
                    teamTotals.poss = teamTotals.fga - teamTotals.oreb + teamTotals.tov + 0.4 * teamTotals.fta;
                    if (teamTotals.poss > 0) {
                        teamTotals.ortg = teamTotals.points / teamTotals.poss * 100;
                    }
                    // TOV%
                    const plays = teamTotals.fga + teamTotals.tov + 0.44 * teamTotals.fta;
                    if (plays > 0) teamTotals.tovPct = teamTotals.tov / plays * 100;

                    teamsData[teamName] = { players, teamTotals };
                });

                // Calculate defensive stats (cross-reference)
                const teamKeys = Object.keys(teamsData);
                if (teamKeys.length === 2) {
                    const [home, away] = teamKeys;
                    teamsData[home].teamTotals.drtg = teamsData[away].teamTotals.ortg;
                    teamsData[away].teamTotals.drtg = teamsData[home].teamTotals.ortg;
                    teamsData[home].teamTotals.oppPts = teamsData[away].teamTotals.points;
                    teamsData[away].teamTotals.oppPts = teamsData[home].teamTotals.points;
                    // OREB%
                    const homeOrebChances = teamsData[home].teamTotals.oreb + teamsData[away].teamTotals.dreb;
                    const awayOrebChances = teamsData[away].teamTotals.oreb + teamsData[home].teamTotals.dreb;
                    if (homeOrebChances > 0) teamsData[home].teamTotals.orebPct = teamsData[home].teamTotals.oreb / homeOrebChances * 100;
                    if (awayOrebChances > 0) teamsData[away].teamTotals.orebPct = teamsData[away].teamTotals.oreb / awayOrebChances * 100;
                    // FT Rate
                    if (teamsData[home].teamTotals.fga > 0) teamsData[home].teamTotals.ftRate = teamsData[home].teamTotals.fta / teamsData[home].teamTotals.fga * 100;
                    if (teamsData[away].teamTotals.fga > 0) teamsData[away].teamTotals.ftRate = teamsData[away].teamTotals.fta / teamsData[away].teamTotals.fga * 100;
                }

                console.log('[GAMEVIS] Final teamsData:', Object.keys(teamsData),
                    'Home players:', teamsData[teamKeys[0]]?.players?.length,
                    'Away players:', teamsData[teamKeys[1]]?.players?.length);

                return teamsData;
            };

            // ═══════════════════════════════════════════════════════════════════════════
            // FULL PBP PARSING SYSTEM - Ported from GAMEVIS
            // Extracts: on-court stats, lineups, assist combinations, period stats, game flow
            // ═══════════════════════════════════════════════════════════════════════════
            const parsePBP = (html, teamsData) => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                const teamNames = Object.keys(teamsData);
                if (teamNames.length < 2) return { onCourtStats: null, lineupStats: {}, assistCombinations: {}, gameFlowData: [], periodStats: {}, teamPeriodTotals: {}, playerRuns: [], teamMomentumRuns: [] };

                const homeTeam = teamNames[0];
                const awayTeam = teamNames[1];

                // Parser state
                let currentPeriod = 1;
                let lastTime = 0;
                let maxPeriod = 4;
                const lineupStats = {};
                const assistCombinations = {};
                const gameFlowData = [];
                const playerRuns = [];
                const teamMomentumRuns = [];
                const periodStats = {};
                const teamPeriodTotals = {};
                const playerPeriodMinutes = {};
                const playerOnCourtSince = {};

                // Running stats for game flow
                const runningStats = {
                    home: { points: 0, fga: 0, fgm: 0, fg3m: 0, fg3a: 0, fta: 0, ftm: 0, tov: 0, oreb: 0 },
                    away: { points: 0, fga: 0, fgm: 0, fg3m: 0, fg3a: 0, fta: 0, ftm: 0, tov: 0, oreb: 0 }
                };

                // Current scoring run tracking
                let currentScoringRun = {
                    lastScoringTeam: null,
                    consecutivePoints: 0,
                    scoringPlayers: {},
                    startElapsed: 0,
                    startHomeScore: 0,
                    startAwayScore: 0,
                    currentLineup: null,
                    teamName: null
                };

                // Last scorer for assist tracking
                let lastScorer = null;
                let lastScorerTeam = null;
                let lastScorerPoints = 0;
                let lastScorerWasThree = false;

                // Build player roster and initialize starters
                const playerRoster = {};
                const currentLineups = [new Set(), new Set()];

                teamNames.forEach((teamName, teamIdx) => {
                    playerRoster[teamName] = {};
                    periodStats[teamName] = {};
                    teamPeriodTotals[teamName] = {};
                    playerPeriodMinutes[teamName] = {};
                    playerOnCourtSince[teamName] = {};

                    teamsData[teamName].players.forEach(p => {
                        playerRoster[teamName][p.number] = p.name;
                        if (p.isStarter) {
                            currentLineups[teamIdx].add(String(parseInt(p.number, 10) || p.number));
                        }
                    });

                    // Initialize period structures
                    for (let p = 1; p <= 6; p++) {
                        periodStats[teamName][p] = {};
                        teamPeriodTotals[teamName][p] = {
                            points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                            ftm: 0, fta: 0, oreb: 0, dreb: 0, ast: 0,
                            stl: 0, blk: 0, tov: 0, pf: 0,
                            rimAtt: 0, rimMade: 0, midAtt: 0, midMade: 0,
                            assistedFgm: 0, assistedPoints: 0
                        };
                        playerPeriodMinutes[teamName][p] = {};
                    }
                });

                // Initialize on-court stats for all players
                const playerOnCourtStats = {};
                const playerShotStats = {};

                teamNames.forEach(teamName => {
                    teamsData[teamName].players.forEach(player => {
                        const key = `${teamName}|${player.number}`;
                        playerOnCourtStats[key] = {
                            teamPoints: 0, oppPoints: 0,
                            teamFGA: 0, teamFGM: 0, team3PA: 0, team3PM: 0,
                            teamFTA: 0, teamFTM: 0, teamOreb: 0, teamDreb: 0, teamTov: 0,
                            oppFGA: 0, oppFGM: 0, opp3PA: 0, opp3PM: 0,
                            oppFTA: 0, oppFTM: 0, oppOreb: 0, oppDreb: 0, oppTov: 0,
                            seconds: 0
                        };
                        playerShotStats[key] = {
                            rimAtt: 0, rimMade: 0,
                            midAtt: 0, midMade: 0,
                            threeAtt: 0, threeMade: 0
                        };
                    });
                });

                // Helper functions
                const normalizeNumber = (num) => {
                    if (num === null || num === undefined) return null;
                    const str = String(num).trim();
                    if (/^\d+$/.test(str)) return String(parseInt(str, 10));
                    return str;
                };

                // Extract display name with suffix handling (matches GAMEVIS)
                const extractDisplayName = (fullName) => {
                    if (!fullName || fullName === 'Unknown') return 'UNKNOWN';
                    const parts = fullName.trim().split(/\s+/);
                    if (parts.length === 1) return parts[0].toUpperCase();

                    const suffixes = ['Jr.', 'Jr', 'III', 'II', 'IV', 'V', 'VI', 'VII', 'VIII', 'Sr.', 'Sr'];
                    const lastPart = parts[parts.length - 1];

                    // Check if last part is a suffix
                    const isSuffix = suffixes.some(s =>
                        lastPart.toLowerCase() === s.toLowerCase() ||
                        lastPart.toLowerCase().replace('.', '') === s.toLowerCase().replace('.', '')
                    );

                    if (isSuffix && parts.length >= 2) {
                        // Return the part before the suffix + the suffix
                        // e.g., "Ron Polite III" -> "POLITE III"
                        const nameBeforeSuffix = parts[parts.length - 2];
                        return nameBeforeSuffix.toUpperCase() + ' ' + lastPart;
                    }

                    // No suffix, just return last name
                    return lastPart.toUpperCase();
                };

                const parsePeriodString = (text) => {
                    const t = text.trim().toLowerCase();
                    if (t.includes('1') || t.includes('q1') || t.includes('1st')) return 1;
                    if (t.includes('2') || t.includes('q2') || t.includes('2nd')) return 2;
                    if (t.includes('3') || t.includes('q3') || t.includes('3rd')) return 3;
                    if (t.includes('4') || t.includes('q4') || t.includes('4th')) return 4;
                    if (t.includes('ot') || t.includes('overtime')) {
                        const otMatch = t.match(/ot\s*(\d+)?/i);
                        return 4 + (otMatch && otMatch[1] ? parseInt(otMatch[1]) : 1);
                    }
                    return currentPeriod;
                };

                const calculateElapsedTime = (timeStr, period) => {
                    const parts = timeStr.split(':');
                    const mins = parseInt(parts[0]) || 0;
                    const secs = parseInt(parts[1]) || 0;
                    const timeRemaining = mins * 60 + secs;
                    const periodLength = period <= 4 ? 600 : 300;
                    const periodStart = period <= 4 ? (period - 1) * 600 : 2400 + (period - 5) * 300;
                    return periodStart + (periodLength - timeRemaining);
                };

                const getLineupKey = (teamIdx) => {
                    const players = Array.from(currentLineups[teamIdx]).sort((a, b) => parseInt(a) - parseInt(b));
                    return `${teamIdx}|${players.join(',')}`;
                };

                const getDefaultLineupStats = () => ({
                    seconds: 0, points: 0, pointsAllowed: 0,
                    fga: 0, fgm: 0, fg3a: 0, fg3m: 0, fta: 0, ftm: 0,
                    oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, pf: 0,
                    defFga: 0, defFgm: 0, defFg3a: 0, defFg3m: 0, defFta: 0, defFtm: 0,
                    defOrebAllowed: 0, forcedTov: 0, defTovForced: 0
                });

                const updateLineupTimes = (elapsed) => {
                    const delta = elapsed - lastTime;
                    if (delta > 0 && delta < 300) {
                        for (const teamIdx of [0, 1]) {
                            const key = getLineupKey(teamIdx);
                            if (!lineupStats[key]) lineupStats[key] = getDefaultLineupStats();
                            lineupStats[key].seconds += delta;

                            // Update player on-court seconds
                            const teamName = teamIdx === 0 ? homeTeam : awayTeam;
                            currentLineups[teamIdx].forEach(playerNum => {
                                const playerKey = `${teamName}|${playerNum}`;
                                if (playerOnCourtStats[playerKey]) {
                                    playerOnCourtStats[playerKey].seconds += delta;
                                }
                            });
                        }
                    }
                    lastTime = elapsed;
                };

                const finalizeCurrentRun = (elapsed, scoringTeam, teamIdx, lineupKey) => {
                    if (currentScoringRun.consecutivePoints >= 6 && currentScoringRun.lastScoringTeam !== null) {
                        const scorers = Object.entries(currentScoringRun.scoringPlayers).sort((a, b) => b[1] - a[1]);
                        const topScorer = scorers[0] ? scorers[0][0] : null;
                        const topScorerPoints = scorers[0] ? scorers[0][1] : 0;

                        teamMomentumRuns.push({
                            team: currentScoringRun.teamName,
                            teamIdx: currentScoringRun.lastScoringTeam,
                            points: currentScoringRun.consecutivePoints,
                            lineup: currentScoringRun.currentLineup,
                            startElapsed: currentScoringRun.startElapsed,
                            endElapsed: currentScoringRun.endElapsed || elapsed,
                            startHomeScore: currentScoringRun.startHomeScore,
                            startAwayScore: currentScoringRun.startAwayScore,
                            endHomeScore: currentScoringRun.endHomeScore,
                            endAwayScore: currentScoringRun.endAwayScore,
                            topScorer,
                            topScorerPoints,
                            topScorerName: topScorer && currentScoringRun.teamName ? playerRoster[currentScoringRun.teamName]?.[topScorer] : null
                        });
                    }
                };

                // Initialize lineups for starters
                for (const teamIdx of [0, 1]) {
                    const lineupKey = getLineupKey(teamIdx);
                    lineupStats[lineupKey] = getDefaultLineupStats();
                }

                // Find PBP container
                const pbpContainer = doc.querySelector('#aj_pbp');
                if (!pbpContainer) {
                    console.warn('[GAMEVIS] PBP container not found');
                    return { onCourtStats: playerOnCourtStats, lineupStats, assistCombinations, gameFlowData, periodStats, teamPeriodTotals, playerRuns, teamMomentumRuns, playerPeriodMinutes, maxPeriod };
                }

                // Process actions in chronological order (reverse DOM order)
                const actions = Array.from(pbpContainer.querySelectorAll('div.pbpa')).reverse();
                console.log(`[GAMEVIS] Processing ${actions.length} PBP actions`);

                let previousPeriod = 0;

                const initializeStartersForPeriod = (period, elapsed) => {
                    for (const teamIdx of [0, 1]) {
                        const teamName = teamIdx === 0 ? homeTeam : awayTeam;
                        currentLineups[teamIdx].forEach(playerNum => {
                            if (!playerOnCourtSince[teamName][playerNum]) {
                                playerOnCourtSince[teamName][playerNum] = {};
                            }
                            playerOnCourtSince[teamName][playerNum][period] = elapsed;
                        });
                    }
                };

                const finalizeMinutesForPeriod = (period, periodEndElapsed) => {
                    for (const teamIdx of [0, 1]) {
                        const teamName = teamIdx === 0 ? homeTeam : awayTeam;
                        currentLineups[teamIdx].forEach(playerNum => {
                            const entryTime = playerOnCourtSince[teamName]?.[playerNum]?.[period];
                            if (entryTime !== undefined) {
                                const secondsPlayed = periodEndElapsed - entryTime;
                                if (!playerPeriodMinutes[teamName][period][playerNum]) {
                                    playerPeriodMinutes[teamName][period][playerNum] = 0;
                                }
                                playerPeriodMinutes[teamName][period][playerNum] += secondsPlayed;
                                delete playerOnCourtSince[teamName][playerNum][period];
                            }
                        });
                    }
                };

                for (const action of actions) {
                    // Determine team
                    let teamIdx = null;
                    const classes = action.className || '';
                    if (classes.includes('pbp-team1') || classes.includes('pbpt1')) teamIdx = 0;
                    else if (classes.includes('pbp-team2') || classes.includes('pbpt2')) teamIdx = 1;

                    // Parse period
                    const periodSpan = action.querySelector('.pbp-period') || action.querySelector('span.pbp-period');
                    if (periodSpan) {
                        const newPeriod = parsePeriodString(periodSpan.textContent);
                        if (newPeriod !== previousPeriod) {
                            if (previousPeriod > 0) {
                                const periodEndElapsed = previousPeriod <= 4 ? previousPeriod * 600 : 2400 + (previousPeriod - 4) * 300;
                                finalizeMinutesForPeriod(previousPeriod, periodEndElapsed);
                            }
                            currentPeriod = newPeriod;
                            previousPeriod = newPeriod;
                            if (newPeriod > maxPeriod) maxPeriod = newPeriod;
                            const periodStartElapsed = newPeriod <= 4 ? (newPeriod - 1) * 600 : 2400 + (newPeriod - 5) * 300;
                            initializeStartersForPeriod(newPeriod, periodStartElapsed);
                        }
                    }

                    // Parse time
                    const timeDiv = action.querySelector('.pbp-time') || action.querySelector('div.pbp-time');
                    let elapsed = lastTime;
                    if (timeDiv) {
                        const timeText = timeDiv.textContent.trim();
                        const timeMatch = timeText.match(/(\d{1,2}):(\d{2})/);
                        if (timeMatch) {
                            elapsed = calculateElapsedTime(`${timeMatch[1]}:${timeMatch[2]}`, currentPeriod);
                            updateLineupTimes(elapsed);
                        }
                    }

                    // Get action description
                    const actionDiv = action.querySelector('.pbp-action') || action.querySelector('div.pbp-action');
                    if (!actionDiv) continue;

                    const actionText = actionDiv.textContent.toLowerCase();

                    // Extract player number
                    let playerNum = null;
                    const strongTag = actionDiv.querySelector('strong');
                    if (strongTag) {
                        const text = strongTag.textContent.trim();
                        if (text.includes(',')) {
                            playerNum = normalizeNumber(text.split(',')[0].trim());
                        } else if (/^\d+$/.test(text.trim())) {
                            playerNum = normalizeNumber(text.trim());
                        }
                    }

                    // SUBSTITUTIONS
                    if (actionText.includes('substitution')) {
                        if (teamIdx !== null && playerNum) {
                            const teamName = teamIdx === 0 ? homeTeam : awayTeam;
                            const isSubIn = actionText.includes('substitution in');
                            const isSubOut = actionText.includes('substitution out');

                            if (isSubOut) {
                                const entryTime = playerOnCourtSince[teamName]?.[playerNum]?.[currentPeriod];
                                if (entryTime !== undefined) {
                                    const secondsPlayed = elapsed - entryTime;
                                    if (!playerPeriodMinutes[teamName][currentPeriod][playerNum]) {
                                        playerPeriodMinutes[teamName][currentPeriod][playerNum] = 0;
                                    }
                                    playerPeriodMinutes[teamName][currentPeriod][playerNum] += secondsPlayed;
                                    delete playerOnCourtSince[teamName][playerNum][currentPeriod];
                                }
                                currentLineups[teamIdx].delete(playerNum);
                                currentLineups[teamIdx].delete(playerNum.padStart(2, '0'));
                            } else if (isSubIn) {
                                if (!playerOnCourtSince[teamName][playerNum]) {
                                    playerOnCourtSince[teamName][playerNum] = {};
                                }
                                playerOnCourtSince[teamName][playerNum][currentPeriod] = elapsed;
                                currentLineups[teamIdx].add(playerNum);
                            }

                            const newLineupKey = getLineupKey(teamIdx);
                            if (!lineupStats[newLineupKey]) {
                                lineupStats[newLineupKey] = getDefaultLineupStats();
                            }
                        }
                        continue;
                    }

                    // Skip non-stat events
                    if (actionText.includes('timeout') || actionText.includes('jump ball') || actionText.includes('instant replay')) {
                        continue;
                    }

                    if (teamIdx === null) continue;

                    const lineupKey = getLineupKey(teamIdx);
                    const oppTeamIdx = 1 - teamIdx;
                    const oppLineupKey = getLineupKey(oppTeamIdx);

                    if (!lineupStats[lineupKey]) lineupStats[lineupKey] = getDefaultLineupStats();
                    if (!lineupStats[oppLineupKey]) lineupStats[oppLineupKey] = getDefaultLineupStats();

                    const scoringTeam = teamIdx === 0 ? homeTeam : awayTeam;
                    const defendingTeam = teamIdx === 0 ? awayTeam : homeTeam;

                    // SHOT DETECTION
                    let points = 0;
                    let isFGA = false, isFGM = false;
                    let is3PA = false, is3PM = false;
                    let isFTA = false, isFTM = false;
                    const isMade = actionText.includes('made');
                    const isMissed = actionText.includes('missed');

                    let isRimShot = false;
                    let isMidRange = false;
                    let isThree = false;

                    if (actionText.includes('3pt')) {
                        isFGA = true; is3PA = true; isThree = true;
                        if (isMade) { points = 3; isFGM = true; is3PM = true; }
                    } else if (actionText.includes('2pt') &&
                        (actionText.includes('lay up') || actionText.includes('layup') ||
                         actionText.includes('dunk') || actionText.includes('tip in') ||
                         actionText.includes('tipin') || actionText.includes('alley') ||
                         actionText.includes('driving') || actionText.includes('finger roll') ||
                         actionText.includes('hook') || actionText.includes('put back') ||
                         actionText.includes('reverse'))) {
                        isFGA = true; isRimShot = true;
                        if (isMade) { points = 2; isFGM = true; }
                    } else if (actionText.includes('2pt') ||
                             (actionText.includes('jump shot') && !actionText.includes('3pt')) ||
                             actionText.includes('jumper') || actionText.includes('fadeaway') ||
                             actionText.includes('pull up') || actionText.includes('step back') ||
                             actionText.includes('turn around')) {
                        isFGA = true;
                        if (actionText.includes('floater') || actionText.includes('runner')) {
                            isRimShot = true;
                        } else {
                            isMidRange = true;
                        }
                        if (isMade) { points = 2; isFGM = true; }
                    } else if (actionText.includes('free throw')) {
                        isFTA = true;
                        if (isMade) { points = 1; isFTM = true; }
                    }

                    // Update lineup stats
                    if (isFGA) {
                        lineupStats[lineupKey].fga++;
                        lineupStats[oppLineupKey].defFga++;
                        if (isFGM) {
                            lineupStats[lineupKey].fgm++;
                            lineupStats[oppLineupKey].defFgm++;
                        }
                        if (is3PA) {
                            lineupStats[lineupKey].fg3a++;
                            lineupStats[oppLineupKey].defFg3a++;
                            if (is3PM) {
                                lineupStats[lineupKey].fg3m++;
                                lineupStats[oppLineupKey].defFg3m++;
                            }
                        }
                    }

                    if (isFTA) {
                        lineupStats[lineupKey].fta++;
                        lineupStats[oppLineupKey].defFta++;
                        if (isFTM) {
                            lineupStats[lineupKey].ftm++;
                            lineupStats[oppLineupKey].defFtm++;
                        }
                    }

                    // Update on-court stats
                    if (isFGA || isFTA) {
                        currentLineups[teamIdx].forEach(pNum => {
                            const key = `${scoringTeam}|${pNum}`;
                            if (playerOnCourtStats[key]) {
                                if (isFGA) {
                                    playerOnCourtStats[key].teamFGA++;
                                    if (isFGM) playerOnCourtStats[key].teamFGM++;
                                    if (is3PA) {
                                        playerOnCourtStats[key].team3PA++;
                                        if (is3PM) playerOnCourtStats[key].team3PM++;
                                    }
                                }
                                if (isFTA) {
                                    playerOnCourtStats[key].teamFTA++;
                                    if (isFTM) playerOnCourtStats[key].teamFTM++;
                                }
                            }
                        });
                        currentLineups[oppTeamIdx].forEach(pNum => {
                            const key = `${defendingTeam}|${pNum}`;
                            if (playerOnCourtStats[key]) {
                                if (isFGA) {
                                    playerOnCourtStats[key].oppFGA++;
                                    if (isFGM) playerOnCourtStats[key].oppFGM++;
                                    if (is3PA) {
                                        playerOnCourtStats[key].opp3PA++;
                                        if (is3PM) playerOnCourtStats[key].opp3PM++;
                                    }
                                }
                                if (isFTA) {
                                    playerOnCourtStats[key].oppFTA++;
                                    if (isFTM) playerOnCourtStats[key].oppFTM++;
                                }
                            }
                        });
                    }

                    // Points
                    if (points > 0) {
                        lineupStats[lineupKey].points += points;
                        lineupStats[oppLineupKey].pointsAllowed += points;

                        currentLineups[teamIdx].forEach(pNum => {
                            const key = `${scoringTeam}|${pNum}`;
                            if (playerOnCourtStats[key]) playerOnCourtStats[key].teamPoints += points;
                        });
                        currentLineups[oppTeamIdx].forEach(pNum => {
                            const key = `${defendingTeam}|${pNum}`;
                            if (playerOnCourtStats[key]) playerOnCourtStats[key].oppPoints += points;
                        });

                        if (isFGM && playerNum) {
                            lastScorer = playerNum;
                            lastScorerTeam = scoringTeam;
                            lastScorerPoints = points;
                            lastScorerWasThree = is3PM;
                        }
                    }

                    // Game flow tracking
                    const teamKey = teamIdx === 0 ? 'home' : 'away';
                    if (isFGA) {
                        runningStats[teamKey].fga++;
                        if (isFGM) runningStats[teamKey].fgm++;
                        if (is3PA) {
                            runningStats[teamKey].fg3a++;
                            if (is3PM) runningStats[teamKey].fg3m++;
                        }
                    }
                    if (isFTA) {
                        runningStats[teamKey].fta++;
                        if (isFTM) runningStats[teamKey].ftm++;
                    }
                    if (points > 0) {
                        runningStats[teamKey].points += points;

                        // Scoring run tracking
                        if (currentScoringRun.lastScoringTeam === teamIdx) {
                            currentScoringRun.consecutivePoints += points;
                            if (!currentScoringRun.scoringPlayers[playerNum]) {
                                currentScoringRun.scoringPlayers[playerNum] = 0;
                            }
                            currentScoringRun.scoringPlayers[playerNum] += points;
                        } else {
                            finalizeCurrentRun(elapsed, scoringTeam, teamIdx, lineupKey);
                            currentScoringRun = {
                                lastScoringTeam: teamIdx,
                                consecutivePoints: points,
                                scoringPlayers: { [playerNum]: points },
                                startElapsed: elapsed,
                                startHomeScore: runningStats.home.points - (teamIdx === 0 ? points : 0),
                                startAwayScore: runningStats.away.points - (teamIdx === 1 ? points : 0),
                                currentLineup: lineupKey,
                                teamName: scoringTeam
                            };
                        }
                        currentScoringRun.endElapsed = elapsed;
                        currentScoringRun.endHomeScore = runningStats.home.points;
                        currentScoringRun.endAwayScore = runningStats.away.points;
                    }

                    // Record game flow data point
                    if (points > 0 || isFGA || actionText.includes('turnover')) {
                        const homePoss = 0.96 * (runningStats.home.fga + runningStats.home.tov + 0.44 * runningStats.home.fta - runningStats.home.oreb);
                        const awayPoss = 0.96 * (runningStats.away.fga + runningStats.away.tov + 0.44 * runningStats.away.fta - runningStats.away.oreb);
                        const homePPP = homePoss > 0 ? runningStats.home.points / homePoss : 0;
                        const awayPPP = awayPoss > 0 ? runningStats.away.points / awayPoss : 0;

                        // Calculate EPA from TO margin and OREB margin (matches GAMEVIS)
                        // TO margin: fewer home TOs = home advantage (awayTov - homeTov)
                        // OREB margin: more home OREBs = home advantage (homeOreb - awayOreb)
                        const toMargin = runningStats.away.tov - runningStats.home.tov;
                        const orebMargin = runningStats.home.oreb - runningStats.away.oreb;
                        const epa = (toMargin + orebMargin) * 1.05;

                        // Calculate Scoring Battle from eFG% and FT Rate margins (matches GAMEVIS)
                        // eFG% = (FGM + 0.5 * FG3M) / FGA
                        const homeEfg = runningStats.home.fga > 0 ?
                            ((runningStats.home.fgm + 0.5 * runningStats.home.fg3m) / runningStats.home.fga * 100) : 0;
                        const awayEfg = runningStats.away.fga > 0 ?
                            ((runningStats.away.fgm + 0.5 * runningStats.away.fg3m) / runningStats.away.fga * 100) : 0;
                        const efgMargin = homeEfg - awayEfg;

                        // FT Rate = FTM / FGA (as percentage)
                        const homeFtRate = runningStats.home.fga > 0 ?
                            (runningStats.home.ftm / runningStats.home.fga * 100) : 0;
                        const awayFtRate = runningStats.away.fga > 0 ?
                            (runningStats.away.ftm / runningStats.away.fga * 100) : 0;
                        const ftRateMargin = homeFtRate - awayFtRate;

                        // Scoring Battle = (eFG% margin × 1.77) + (FT Rate margin × 0.25)
                        // Scale by pace estimate (use current possessions as proxy)
                        const avgPoss = (homePoss + awayPoss) / 2;
                        const gamePace = avgPoss > 0 ? (avgPoss / (elapsed / 2400)) : 75; // Estimate pace
                        const scoringBattle = ((efgMargin * 1.77) + (ftRateMargin * 0.25)) * (gamePace / 100);

                        gameFlowData.push({
                            elapsed, period: currentPeriod,
                            homePoints: runningStats.home.points, awayPoints: runningStats.away.points,
                            margin: runningStats.home.points - runningStats.away.points,
                            homePoss, awayPoss, homePPP, awayPPP,
                            // EPA tracking (matches GAMEVIS)
                            homeTov: runningStats.home.tov,
                            awayTov: runningStats.away.tov,
                            homeOreb: runningStats.home.oreb,
                            awayOreb: runningStats.away.oreb,
                            toMargin: toMargin,
                            orebMargin: orebMargin,
                            epa: epa,
                            // Scoring Battle tracking (matches GAMEVIS)
                            homeEfg: homeEfg,
                            awayEfg: awayEfg,
                            efgMargin: efgMargin,
                            homeFtRate: homeFtRate,
                            awayFtRate: awayFtRate,
                            ftRateMargin: ftRateMargin,
                            scoringBattle: scoringBattle
                        });
                    }

                    // Player shot stats
                    if (playerNum && isFGA) {
                        const playerKey = `${scoringTeam}|${playerNum}`;
                        if (playerShotStats[playerKey]) {
                            if (isRimShot) {
                                playerShotStats[playerKey].rimAtt++;
                                if (isFGM) playerShotStats[playerKey].rimMade++;
                            } else if (isMidRange) {
                                playerShotStats[playerKey].midAtt++;
                                if (isFGM) playerShotStats[playerKey].midMade++;
                            } else if (isThree) {
                                playerShotStats[playerKey].threeAtt++;
                                if (is3PM) playerShotStats[playerKey].threeMade++;
                            }
                        }
                    }

                    // Period stats
                    if (playerNum && periodStats[scoringTeam]) {
                        if (!periodStats[scoringTeam][currentPeriod][playerNum]) {
                            periodStats[scoringTeam][currentPeriod][playerNum] = {
                                minutes: 0, points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                                ftm: 0, fta: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, pf: 0,
                                rimAtt: 0, rimMade: 0, midAtt: 0, midMade: 0
                            };
                        }
                        const pStats = periodStats[scoringTeam][currentPeriod][playerNum];
                        const tStats = teamPeriodTotals[scoringTeam][currentPeriod];

                        if (isFGA) {
                            pStats.fga++; tStats.fga++;
                            if (isFGM) { pStats.fgm++; tStats.fgm++; }
                            if (is3PA) {
                                pStats.fg3a++; tStats.fg3a++;
                                if (is3PM) { pStats.fg3m++; tStats.fg3m++; }
                            }
                            if (isRimShot) {
                                pStats.rimAtt++; tStats.rimAtt++;
                                if (isFGM) { pStats.rimMade++; tStats.rimMade++; }
                            } else if (isMidRange) {
                                pStats.midAtt++; tStats.midAtt++;
                                if (isFGM) { pStats.midMade++; tStats.midMade++; }
                            }
                        }
                        if (isFTA) {
                            pStats.fta++; tStats.fta++;
                            if (isFTM) { pStats.ftm++; tStats.ftm++; }
                        }
                        if (points > 0) {
                            pStats.points += points; tStats.points += points;
                        }
                    }

                    // Rebounds
                    if (actionText.includes('offensive rebound')) {
                        lineupStats[lineupKey].oreb++;
                        lineupStats[oppLineupKey].defOrebAllowed++;
                        runningStats[teamKey].oreb++;

                        currentLineups[teamIdx].forEach(pNum => {
                            const key = `${scoringTeam}|${pNum}`;
                            if (playerOnCourtStats[key]) playerOnCourtStats[key].teamOreb++;
                        });
                        currentLineups[oppTeamIdx].forEach(pNum => {
                            const key = `${defendingTeam}|${pNum}`;
                            if (playerOnCourtStats[key]) playerOnCourtStats[key].oppOreb++;
                        });

                        if (playerNum && periodStats[scoringTeam]?.[currentPeriod]?.[playerNum]) {
                            periodStats[scoringTeam][currentPeriod][playerNum].oreb++;
                            teamPeriodTotals[scoringTeam][currentPeriod].oreb++;
                        }
                    } else if (actionText.includes('defensive rebound')) {
                        lineupStats[lineupKey].dreb++;

                        currentLineups[teamIdx].forEach(pNum => {
                            const key = `${scoringTeam}|${pNum}`;
                            if (playerOnCourtStats[key]) playerOnCourtStats[key].teamDreb++;
                        });
                        currentLineups[oppTeamIdx].forEach(pNum => {
                            const key = `${defendingTeam}|${pNum}`;
                            if (playerOnCourtStats[key]) playerOnCourtStats[key].oppDreb++;
                        });

                        if (playerNum && periodStats[scoringTeam]?.[currentPeriod]?.[playerNum]) {
                            periodStats[scoringTeam][currentPeriod][playerNum].dreb++;
                            teamPeriodTotals[scoringTeam][currentPeriod].dreb++;
                        }
                    }

                    // Assists
                    if (actionText.includes('assist')) {
                        // Track assist in lineup stats (like GAMEVIS)
                        lineupStats[lineupKey].ast++;

                        if (playerNum && periodStats[scoringTeam]?.[currentPeriod]?.[playerNum]) {
                            periodStats[scoringTeam][currentPeriod][playerNum].ast++;
                            teamPeriodTotals[scoringTeam][currentPeriod].ast++;
                        }

                        // Mark as assisted for team tracking
                        if (lastScorer && lastScorerTeam === scoringTeam && teamPeriodTotals[scoringTeam]) {
                            teamPeriodTotals[scoringTeam][currentPeriod].assistedFgm++;
                            teamPeriodTotals[scoringTeam][currentPeriod].assistedPoints += lastScorerPoints || 0;
                        }

                        // Track assist combination
                        if (playerNum && lastScorer && lastScorerTeam === scoringTeam) {
                            const comboKey = `${scoringTeam}|${playerNum}|${lastScorer}`;
                            if (!assistCombinations[comboKey]) {
                                assistCombinations[comboKey] = {
                                    team: scoringTeam, assisterNum: playerNum, scorerNum: lastScorer,
                                    assisterName: playerRoster[scoringTeam]?.[playerNum] || `#${playerNum}`,
                                    scorerName: playerRoster[scoringTeam]?.[lastScorer] || `#${lastScorer}`,
                                    count: 0, points: 0, threes: 0, twos: 0
                                };
                            }
                            assistCombinations[comboKey].count++;
                            assistCombinations[comboKey].points += lastScorerPoints;
                            if (lastScorerWasThree) {
                                assistCombinations[comboKey].threes++;
                            } else {
                                assistCombinations[comboKey].twos++;
                            }
                        }

                        // Clear last scorer after assist is recorded (prevents double-counting)
                        lastScorer = null;
                        lastScorerTeam = null;
                    }

                    // Steals
                    if (actionText.includes('steal')) {
                        // Track steals properly (stl not forcedTov)
                        lineupStats[lineupKey].stl++;
                        lineupStats[lineupKey].forcedTov++;
                        if (playerNum && periodStats[scoringTeam]?.[currentPeriod]?.[playerNum]) {
                            periodStats[scoringTeam][currentPeriod][playerNum].stl++;
                            teamPeriodTotals[scoringTeam][currentPeriod].stl++;
                        }
                    }

                    // Blocks (use word boundary regex to match GAMEVIS - prevents matching 'blocked' or 'blocking')
                    if (/\bblock\b/.test(actionText)) {
                        lineupStats[lineupKey].blk++;
                        if (playerNum && periodStats[scoringTeam]?.[currentPeriod]?.[playerNum]) {
                            periodStats[scoringTeam][currentPeriod][playerNum].blk++;
                            teamPeriodTotals[scoringTeam][currentPeriod].blk++;
                        }
                    }

                    // Turnovers
                    if (actionText.includes('turnover') && !actionText.includes('team turnover')) {
                        lineupStats[lineupKey].tov++;
                        lineupStats[oppLineupKey].defTovForced++; // Track forced turnovers for defending team (matches GAMEVIS)
                        runningStats[teamKey].tov++;

                        currentLineups[teamIdx].forEach(pNum => {
                            const key = `${scoringTeam}|${pNum}`;
                            if (playerOnCourtStats[key]) playerOnCourtStats[key].teamTov++;
                        });
                        currentLineups[oppTeamIdx].forEach(pNum => {
                            const key = `${defendingTeam}|${pNum}`;
                            if (playerOnCourtStats[key]) playerOnCourtStats[key].oppTov++;
                        });

                        if (playerNum && periodStats[scoringTeam]?.[currentPeriod]?.[playerNum]) {
                            periodStats[scoringTeam][currentPeriod][playerNum].tov++;
                            teamPeriodTotals[scoringTeam][currentPeriod].tov++;
                        }
                    }

                    // Fouls (matches GAMEVIS foul detection)
                    if (actionText.includes('foul') &&
                        !actionText.includes('foul drawn') &&
                        !actionText.includes('fouled by') &&
                        !actionText.includes('foul on') &&
                        !actionText.includes('free throw')) {
                        lineupStats[lineupKey].pf++; // Track fouls in lineup stats (matches GAMEVIS)
                        if (playerNum && periodStats[scoringTeam]?.[currentPeriod]?.[playerNum]) {
                            periodStats[scoringTeam][currentPeriod][playerNum].pf++;
                            teamPeriodTotals[scoringTeam][currentPeriod].pf++;
                        }
                    }
                }

                // Finalize last period
                if (previousPeriod > 0) {
                    const periodEndElapsed = previousPeriod <= 4 ? previousPeriod * 600 : 2400 + (previousPeriod - 4) * 300;
                    finalizeMinutesForPeriod(previousPeriod, periodEndElapsed);
                }

                // Finalize any remaining scoring run
                if (currentScoringRun && currentScoringRun.consecutivePoints >= 6) {
                    finalizeCurrentRun(currentScoringRun.endElapsed || 0, null, null, null);
                }

                // Merge shot stats into player data
                teamNames.forEach(teamName => {
                    teamsData[teamName].players.forEach(player => {
                        const key = `${teamName}|${player.number}`;
                        if (playerShotStats[key]) {
                            player.rimAtt = playerShotStats[key].rimAtt;
                            player.rimMade = playerShotStats[key].rimMade;
                            player.midAtt = playerShotStats[key].midAtt;
                            player.midMade = playerShotStats[key].midMade;
                        }
                    });
                });

                console.log(`[GAMEVIS] PBP parsing complete: ${Object.keys(lineupStats).length} lineups, ${Object.keys(assistCombinations).length} assist combos, ${gameFlowData.length} flow points`);

                return {
                    onCourtStats: playerOnCourtStats,
                    lineupStats,
                    assistCombinations,
                    gameFlowData,
                    periodStats,
                    teamPeriodTotals,
                    playerRuns,
                    teamMomentumRuns,
                    playerPeriodMinutes,
                    maxPeriod,
                    playerRoster
                };
            };

            // ═══════════════════════════════════════════════════════════════════════════
            // ADVANCED METRICS CALCULATION - Ported from GAMEVIS
            // ═══════════════════════════════════════════════════════════════════════════
            const calculateAdvancedMetrics = (teamsData, pbpResult) => {
                const teamNames = Object.keys(teamsData);
                if (teamNames.length < 2) return { teamsData, pace: 70 };

                const onCourtStats = pbpResult?.onCourtStats || null;
                const assistCombinations = pbpResult?.assistCombinations || {};

                // FIRST PASS: Calculate possessions and basic stats for ALL teams
                // (This ensures oppTotals.possessions is available when calculating DRTG)
                for (const teamName of teamNames) {
                    const team = teamsData[teamName];
                    const totals = team.teamTotals;

                    // Aggregate rim stats from players
                    totals.rimAtt = team.players.reduce((sum, p) => sum + (p.rimAtt || 0), 0);
                    totals.rimMade = team.players.reduce((sum, p) => sum + (p.rimMade || 0), 0);
                    totals.midAtt = team.players.reduce((sum, p) => sum + (p.midAtt || 0), 0);
                    totals.midMade = team.players.reduce((sum, p) => sum + (p.midMade || 0), 0);

                    // Calculate possessions first (needed for both ORTG and opponent's DRTG)
                    totals.possessions = 0.96 * (totals.fga + totals.tov + 0.44 * totals.fta - totals.oreb);
                    totals.poss = totals.possessions;

                    // Calculate self-contained stats
                    totals.efg = totals.fga > 0 ? ((totals.fgm + 0.5 * totals.fg3m) / totals.fga * 100) : 0;
                    const tsa = totals.fga + 0.44 * totals.fta;
                    totals.ts = tsa > 0 ? (totals.points / (2 * tsa) * 100) : 0;
                    const tovDenom = totals.fga + 0.44 * totals.fta + totals.tov;
                    totals.tovPct = tovDenom > 0 ? (totals.tov / tovDenom * 100) : 0;
                    totals.ftRate = totals.fga > 0 ? (totals.fta / totals.fga * 100) : 0;
                    totals.astToRatio = totals.tov > 0 ? (totals.ast / totals.tov) : totals.ast;
                    totals.ortg = totals.possessions > 0 ? (totals.points / totals.possessions * 100) : 0;
                }

                // SECOND PASS: Calculate cross-team stats (DRTG, OREB%) that need opponent data
                for (const teamName of teamNames) {
                    const team = teamsData[teamName];
                    const totals = team.teamTotals;
                    const oppTeam = teamNames.find(t => t !== teamName);
                    const oppTotals = teamsData[oppTeam].teamTotals;

                    // Now oppTotals.possessions is available from first pass
                    totals.drtg = oppTotals.possessions > 0 ? (oppTotals.points / oppTotals.possessions * 100) : 0;
                    const orebOpps = totals.oreb + oppTotals.dreb;
                    totals.orebPct = orebOpps > 0 ? (totals.oreb / orebOpps * 100) : 0;
                }

                const homeTotal = teamsData[teamNames[0]].teamTotals;
                const awayTotal = teamsData[teamNames[1]].teamTotals;
                const gamePoss = (homeTotal.possessions + awayTotal.possessions) / 2;
                const totalMins = (homeTotal.minutes || 200) / 5;
                const pace = totalMins > 0 ? (gamePoss / totalMins * 40) : 70;

                // Calculate game averages for +/- comparison
                const gameAvg = {
                    ortg: (homeTotal.ortg + awayTotal.ortg) / 2,
                    drtg: (homeTotal.drtg + awayTotal.drtg) / 2,
                    efg: (homeTotal.efg + awayTotal.efg) / 2,
                    orebPct: (homeTotal.orebPct + awayTotal.orebPct) / 2,
                    tovPct: (homeTotal.tovPct + awayTotal.tovPct) / 2
                };

                // Player advanced metrics
                for (const teamName of teamNames) {
                    const team = teamsData[teamName];
                    const oppTeamName = teamNames.find(t => t !== teamName);
                    const oppTotals = teamsData[oppTeamName].teamTotals;
                    const teamTotals = team.teamTotals;
                    const teamMins = teamTotals.minutes || 200;
                    const gameMinutes = teamMins / 5;

                    for (const player of team.players) {
                        if (player.minutes <= 0) continue;
                        const pMin = Math.max(player.minutes, 0.1);

                        const oppPoss = Math.max(1, oppTotals.fga + 0.44 * oppTotals.fta - oppTotals.oreb + oppTotals.tov);
                        const opp2pa = Math.max(1, oppTotals.fga - oppTotals.fg3a);

                        // eFG%
                        player.efg = player.fga > 0 ? ((player.fgm + 0.5 * player.fg3m) / player.fga * 100) : 0;

                        // TS%
                        const playerTSA = player.fga + 0.44 * player.fta;
                        player.ts = playerTSA > 0 ? (player.points / (2 * playerTSA) * 100) : 0;

                        // USG%
                        const playerPoss = player.fga + 0.44 * player.fta + player.tov;
                        const teamPoss = teamTotals.fga + 0.44 * teamTotals.fta + teamTotals.tov;
                        player.usg = (pMin > 0 && teamPoss > 0) ? (100 * (playerPoss * gameMinutes) / (pMin * teamPoss)) : 0;

                        // AST%
                        const estTeamFgmWhileOnFloor = (pMin / gameMinutes) * teamTotals.fgm;
                        const teammatesFgm = estTeamFgmWhileOnFloor - player.fgm;
                        player.astPct = teammatesFgm > 0 ? (100 * player.ast / teammatesFgm) : 0;

                        // TOV%
                        const playerTovDenom = player.fga + 0.44 * player.fta + player.tov;
                        player.tovPct = playerTovDenom > 0 ? (100 * player.tov / playerTovDenom) : 0;

                        // FT Rate
                        player.ftRate = player.fga > 0 ? (player.fta / player.fga * 100) : 0;

                        // STL%
                        player.stlPct = (pMin > 0 && oppPoss > 0) ? (100 * (player.stl * gameMinutes) / (pMin * oppPoss)) : 0;

                        // BLK%
                        player.blkPct = (pMin > 0 && opp2pa > 0) ? (100 * (player.blk * gameMinutes) / (pMin * opp2pa)) : 0;

                        // ORB%
                        const orebOpportunities = teamTotals.oreb + oppTotals.dreb;
                        player.orebPct = (pMin > 0 && orebOpportunities > 0) ? (100 * (player.oreb * gameMinutes) / (pMin * orebOpportunities)) : 0;

                        // DRB%
                        const drebOpportunities = teamTotals.dreb + oppTotals.oreb;
                        player.drebPct = (pMin > 0 && drebOpportunities > 0) ? (100 * (player.dreb * gameMinutes) / (pMin * drebOpportunities)) : 0;

                        // AST/USG Ratio
                        player.astUsgRatio = player.usg > 0 ? (player.astPct / player.usg) : 0;

                        // PPP
                        const playerPossUsed = player.fga + 0.44 * player.fta + player.tov;
                        player.ppp = playerPossUsed > 0 ? (player.points / playerPossUsed) : 0;

                        // On-court metrics (matches GAMEVIS calculation)
                        const key = `${teamName}|${player.number}`;
                        if (onCourtStats && onCourtStats[key]) {
                            const ocs = onCourtStats[key];
                            const ocTeamPoss = 0.96 * (ocs.teamFGA + ocs.teamTov + 0.44 * ocs.teamFTA - ocs.teamOreb);
                            const ocOppPoss = 0.96 * (ocs.oppFGA + ocs.oppTov + 0.44 * ocs.oppFTA - ocs.oppOreb);

                            // Use team averages as fallback when on-court data insufficient
                            player.onCourtORtg = ocTeamPoss > 0 ? (ocs.teamPoints / ocTeamPoss * 100) : (teamTotals.ortg || 100);
                            player.onCourtDRtg = ocOppPoss > 0 ? (ocs.oppPoints / ocOppPoss * 100) : (teamTotals.drtg || 100);
                            player.netRating = player.onCourtORtg - player.onCourtDRtg;
                            player.onCourtEfg = ocs.teamFGA > 0 ? ((ocs.teamFGM + 0.5 * ocs.team3PM) / ocs.teamFGA * 100) : teamTotals.efg;
                            const ocOrebOpps = ocs.teamOreb + ocs.oppDreb;
                            player.onCourtOrebPct = ocOrebOpps > 0 ? (ocs.teamOreb / ocOrebOpps * 100) : teamTotals.orebPct;
                            const ocTovDenom = ocs.teamFGA + 0.44 * ocs.teamFTA + ocs.teamTov;
                            player.onCourtTovPct = ocTovDenom > 0 ? (ocs.teamTov / ocTovDenom * 100) : teamTotals.tovPct;

                            // Defensive on-court
                            player.defOnCourtEfg = ocs.oppFGA > 0 ? ((ocs.oppFGM + 0.5 * ocs.opp3PM) / ocs.oppFGA * 100) : oppTotals.efg;
                            const defOrebOpps = ocs.oppOreb + ocs.teamDreb;
                            player.defOnCourtOrebPct = defOrebOpps > 0 ? (ocs.oppOreb / defOrebOpps * 100) : oppTotals.orebPct;
                            const defTovDenom = ocs.oppFGA + 0.44 * ocs.oppFTA + ocs.oppTov;
                            player.defOnCourtTovPct = defTovDenom > 0 ? (ocs.oppTov / defTovDenom * 100) : oppTotals.tovPct;
                        } else {
                            // Fallback when on-court stats not available
                            // DRTG = points allowed per 100 possessions = opponent's ORTG against us = our team's drtg
                            player.onCourtORtg = teamTotals.ortg || 100;
                            player.onCourtDRtg = teamTotals.drtg || 100;
                            player.netRating = player.onCourtORtg - player.onCourtDRtg;
                            player.onCourtEfg = teamTotals.efg || 50;
                            player.onCourtOrebPct = teamTotals.orebPct || 25;
                            player.onCourtTovPct = teamTotals.tovPct || 15;
                            player.defOnCourtEfg = oppTotals.efg || 50;
                            player.defOnCourtOrebPct = oppTotals.orebPct || 25;
                            player.defOnCourtTovPct = oppTotals.tovPct || 15;
                        }

                        // Points assisted on
                        player.pointsAssisted = 0;
                        for (const [comboKey, combo] of Object.entries(assistCombinations)) {
                            if (combo.team === teamName && combo.assisterNum === player.number) {
                                player.pointsAssisted += combo.points;
                            }
                        }

                        // Total Point Contribution
                        player.totalPointContribution = player.points + player.pointsAssisted;
                    }
                }

                return { teamsData, pace, gameAvg };
            };
            // ═══════════════════════════════════════════════════════════════════════════

            // Process game HTML files asynchronously
            const processGameHtmlFiles = async (gameFiles) => {
                setGvLoading(true);
                setGvLoadProgress({ current: 0, total: gameFiles.length });
                const summaries = [];

                for (let i = 0; i < gameFiles.length; i++) {
                    const { gameId, bs } = gameFiles[i];
                    try {
                        const bsContent = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(bs);
                        });

                        const summary = parseGameSummary(bsContent, gameId);
                        summaries.push(summary);
                    } catch (err) {
                        console.warn('Failed to parse game ' + gameId, err);
                    }
                    setGvLoadProgress({ current: i + 1, total: gameFiles.length });
                }

                // Parse date string to Date object (handles DD/MM/YY and DD/MM/YYYY formats)
                const parseGameDate = (dateStr) => {
                    if (!dateStr) return null;
                    // Handle DD/MM/YY or DD/MM/YYYY format
                    const parts = dateStr.split(/[\/\-]/);
                    if (parts.length === 3) {
                        let [day, month, year] = parts.map(p => parseInt(p));
                        // Handle 2-digit year
                        if (year < 100) year += 2000;
                        return new Date(year, month - 1, day);
                    }
                    // Try native parsing as fallback
                    const parsed = new Date(dateStr);
                    return isNaN(parsed.getTime()) ? null : parsed;
                };

                // Sort by date (most recent first)
                summaries.sort((a, b) => {
                    const dateA = parseGameDate(a.date);
                    const dateB = parseGameDate(b.date);
                    if (!dateA && !dateB) return 0;
                    if (!dateA) return 1;
                    if (!dateB) return -1;
                    return dateB - dateA; // Most recent first
                });

                setGvFolderGames(summaries);
                setGvLoading(false);
                if (summaries.length > 0) {
                    setGvView('browser');
                }
            };

            // Load a specific game for detailed analysis
            const loadGameForAnalysis = async (gameId) => {
                const gameFile = gvGameHtmlFiles.find(g => g.gameId === gameId);
                if (!gameFile) {
                    setGvError('Game files not found');
                    return;
                }

                setGvLoading(true);
                setGvError('');

                try {
                    let bsContent, pbpContent;

                    // Check if this is an auto-loaded game (has pre-fetched content) or a File object
                    if (gameFile._isAutoLoaded) {
                        // Auto-loaded: content is already available
                        bsContent = gameFile._bsContent;
                        pbpContent = gameFile._pbpContent;
                    } else {
                        // File object from folder upload: use FileReader
                        [bsContent, pbpContent] = await Promise.all([
                            new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = (e) => resolve(e.target.result);
                                reader.onerror = reject;
                                reader.readAsText(gameFile.bs);
                            }),
                            new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = (e) => resolve(e.target.result);
                                reader.onerror = reject;
                                reader.readAsText(gameFile.pbp);
                            })
                        ]);
                    }

                    let scContent = null;
                    if (gameFile.sc && !gameFile._isAutoLoaded) {
                        scContent = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(gameFile.sc);
                        });
                    } else if (gameFile._scContent) {
                        scContent = gameFile._scContent;
                    }

                    // Parse full boxscore data
                    let teamsData = parseFullBoxscore(bsContent);
                    const summary = parseGameSummary(bsContent, gameId);

                    // Parse PBP data for advanced metrics
                    let pbpResult = null;
                    let pace = 70;
                    let gameAvg = null;

                    if (pbpContent) {
                        console.log('[GAMEVIS] Parsing PBP data...');
                        pbpResult = parsePBP(pbpContent, teamsData);

                        // Calculate advanced metrics with PBP data
                        const advancedResult = calculateAdvancedMetrics(teamsData, pbpResult);
                        teamsData = advancedResult.teamsData;
                        pace = advancedResult.pace;
                        gameAvg = advancedResult.gameAvg;
                        console.log('[GAMEVIS] Advanced metrics calculated, pace:', pace.toFixed(1));
                    } else {
                        // Fallback pace calculation from boxscore
                        const teamKeys = Object.keys(teamsData);
                        if (teamKeys.length === 2) {
                            const advancedResult = calculateAdvancedMetrics(teamsData, null);
                            teamsData = advancedResult.teamsData;
                            pace = advancedResult.pace;
                            gameAvg = advancedResult.gameAvg;
                        }
                    }

                    // Parse and set current game with full data including PBP results
                    const gameData = {
                        gameId,
                        bsContent,
                        pbpContent,
                        scContent,
                        summary,
                        teamsData,
                        pace,
                        gameAvg,
                        // PBP derived data
                        onCourtStats: pbpResult?.onCourtStats || null,
                        lineupStats: pbpResult?.lineupStats || {},
                        assistCombinations: pbpResult?.assistCombinations || {},
                        gameFlowData: pbpResult?.gameFlowData || [],
                        periodStats: pbpResult?.periodStats || {},
                        teamPeriodTotals: pbpResult?.teamPeriodTotals || {},
                        playerRuns: pbpResult?.playerRuns || [],
                        teamMomentumRuns: pbpResult?.teamMomentumRuns || [],
                        playerPeriodMinutes: pbpResult?.playerPeriodMinutes || {},
                        maxPeriod: pbpResult?.maxPeriod || 4,
                        playerRoster: pbpResult?.playerRoster || {}
                    };

                    setGvCurrentGame(gameData);
                    setGvView('game');
                    setGvActiveTab('overview');
                } catch (err) {
                    console.error('Game load error:', err);
                    setGvError('Failed to load game: ' + err.message);
                } finally {
                    setGvLoading(false);
                }
            };

            // Get unique teams from folder games for filtering
            const gvTeams = useMemo(() => {
                const teams = new Set();
                gvFolderGames.forEach(g => {
                    if (g.homeTeam) teams.add(g.homeTeam);
                    if (g.awayTeam) teams.add(g.awayTeam);
                });
                return Array.from(teams).sort();
            }, [gvFolderGames]);

            // Filter games by team
            const gvFilteredGames = useMemo(() => {
                if (!gvTeamFilter) return gvFolderGames;
                return gvFolderGames.filter(g =>
                    g.homeTeam === gvTeamFilter || g.awayTeam === gvTeamFilter
                );
            }, [gvFolderGames, gvTeamFilter]);
            // ═══════════════════════════════════════════════════════════════════════════

            // Data parsing - depends on licenseValidated to re-parse after unlock
            const lineupData = useMemo(() => lineupCsv ? parseCSV(lineupCsv) : [], [lineupCsv, licenseValidated]);
            const playerData = useMemo(() => playerCsv ? parseCSV(playerCsv) : [], [playerCsv, licenseValidated]);
            const matchupData = useMemo(() => matchupCsv ? parseCSV(matchupCsv) : [], [matchupCsv, licenseValidated]);
            const seasonData = useMemo(() => seasonCsv ? parseCSV(seasonCsv) : [], [seasonCsv, licenseValidated]);
            const assistComboData = useMemo(() => assistComboCsv ? parseCSV(assistComboCsv) : [], [assistComboCsv, licenseValidated]);
            const clutchData = useMemo(() => clutchCsv ? parseCSV(clutchCsv) : [], [clutchCsv, licenseValidated]);
            const stintsData = useMemo(() => stintsCsv ? parseCSV(stintsCsv) : [], [stintsCsv, licenseValidated]);
            const playerStintsData = useMemo(() => {
                if (playerStintsCsv) {
                    const data = parseCSV(playerStintsCsv);
                    console.log('[VS Starters] player_stints.csv loaded:', data.length, 'rows');
                    return data;
                }
                return [];
            }, [playerStintsCsv, licenseValidated]);
            const teamTotalsData = useMemo(() => teamTotalsCsv ? parseCSV(teamTotalsCsv) : [], [teamTotalsCsv, licenseValidated]);

            // V6.1: Get all unique player names across all data sources for merge selection
            // NOTE: This must be defined AFTER lineupData, stintsData, seasonData, matchupData are defined
            const allUniquePlayerNames = useMemo(() => {
                const names = new Set();
                // From lineup data
                lineupData.forEach(d => {
                    if (d.Lineup) d.Lineup.split(',').forEach(p => names.add(p.trim()));
                });
                // From stints data
                stintsData.forEach(s => {
                    if (s.home_lineup) s.home_lineup.split(',').forEach(p => names.add(p.trim()));
                    if (s.away_lineup) s.away_lineup.split(',').forEach(p => names.add(p.trim()));
                });
                // From player stats
                if (seasonData) seasonData.forEach(d => { if (d.player) names.add(d.player.trim()); });
                // From matchup data
                matchupData.forEach(m => {
                    if (m.your_lineup) m.your_lineup.split(',').forEach(p => names.add(p.trim()));
                    if (m.opp_lineup) m.opp_lineup.split(',').forEach(p => names.add(p.trim()));
                });
                return Array.from(names).sort();
            }, [lineupData, stintsData, seasonData, matchupData]);

            // V6.2: Get players grouped by team for merge UI filtering
            const playersByTeam = useMemo(() => {
                const teamPlayers = new Map(); // team -> Set of player names
                const allTeamsSet = new Set();

                // From lineup data - primary source with Team field
                lineupData.forEach(d => {
                    if (d.Team && d.Lineup) {
                        allTeamsSet.add(d.Team);
                        if (!teamPlayers.has(d.Team)) teamPlayers.set(d.Team, new Set());
                        d.Lineup.split(',').forEach(p => teamPlayers.get(d.Team).add(p.trim()));
                    }
                });

                // From season/player stats data - has team field
                if (seasonData) {
                    seasonData.forEach(d => {
                        if (d.team && d.player) {
                            allTeamsSet.add(d.team);
                            if (!teamPlayers.has(d.team)) teamPlayers.set(d.team, new Set());
                            teamPlayers.get(d.team).add(d.player.trim());
                        }
                    });
                }

                // Convert to sorted arrays
                const result = { teams: Array.from(allTeamsSet).sort(), byTeam: {} };
                teamPlayers.forEach((players, team) => {
                    result.byTeam[team] = Array.from(players).sort();
                });
                return result;
            }, [lineupData, seasonData]);

            // Build team season totals from team_totals.csv for per-possession calculations AND advanced stats
            const teamSeasonTotals = useMemo(() => {
                const result = new Map(); // team -> { games, totalPoss, totalMinutes, fga, fgm, oreb, dreb, ast, stl, blk, tov, fta, tpa, oppOreb, oppDreb, oppFga, oppTpa, oppPoss }
                if (teamTotalsData.length > 0) {
                    const teamGames = new Map(); // team -> Set of game_ids
                    const teamStats = new Map(); // team -> aggregated stats
                    const gameTeams = new Map(); // game_id -> [team1, team2] for opponent matching
                    
                    // First pass: aggregate team stats and track games
                    teamTotalsData.forEach(t => {
                        const team = t.team;
                        const gameId = t.game_id;
                        if (!team) return;
                        
                        // Track unique games per team
                        if (!teamGames.has(team)) teamGames.set(team, new Set());
                        if (gameId) teamGames.get(team).add(gameId);
                        
                        // Track teams in each game for opponent matching
                        if (gameId) {
                            if (!gameTeams.has(gameId)) gameTeams.set(gameId, []);
                            const teams = gameTeams.get(gameId);
                            if (!teams.includes(team)) teams.push(team);
                        }
                        
                        // Aggregate all stats
                        if (!teamStats.has(team)) {
                            teamStats.set(team, {
                                fga: 0, fgm: 0, oreb: 0, dreb: 0, reb: 0, ast: 0, stl: 0, blk: 0, tov: 0, fta: 0, ftm: 0, tpa: 0, tpm: 0, pts: 0, min: 0, pf: 0,
                                oppFga: 0, oppFgm: 0, oppOreb: 0, oppDreb: 0, oppReb: 0, oppAst: 0, oppStl: 0, oppBlk: 0, oppTov: 0, oppFta: 0, oppTpa: 0, oppTpm: 0, oppPts: 0, oppPf: 0
                            });
                        }
                        const s = teamStats.get(team);
                        s.fga += parseFloat(t.fga || t.FGA) || 0;
                        s.fgm += parseFloat(t.fgm || t.FGM) || 0;
                        s.oreb += parseFloat(t.oreb || t.OREB) || 0;
                        s.dreb += parseFloat(t.dreb || t.DREB) || 0;
                        s.reb += parseFloat(t.reb || t.REB || (parseFloat(t.oreb || t.OREB) || 0) + (parseFloat(t.dreb || t.DREB) || 0)) || 0;
                        s.ast += parseFloat(t.ast || t.AST) || 0;
                        s.stl += parseFloat(t.stl || t.STL) || 0;
                        s.blk += parseFloat(t.blk || t.BLK) || 0;
                        s.tov += parseFloat(t.tov || t.TOV) || 0;
                        s.fta += parseFloat(t.fta || t.FTA) || 0;
                        s.ftm += parseFloat(t.ftm || t.FTM) || 0;
                        s.tpa += parseFloat(t.tpa || t['3pa'] || t['3PA']) || 0;
                        s.tpm += parseFloat(t.tpm || t['3pm'] || t['3PM']) || 0;
                        s.pts += parseFloat(t.pts || t.PTS) || 0;
                        s.min += parseFloat(t.min || t.MIN || t.minutes || t.MINUTES) || 0;
                        s.pf += parseFloat(t.pf || t.PF) || 0;
                    });
                    
                    // Second pass: calculate opponent stats by matching games
                    teamTotalsData.forEach(t => {
                        const team = t.team;
                        const gameId = t.game_id;
                        if (!team || !gameId) return;
                        
                        const teamsInGame = gameTeams.get(gameId) || [];
                        const opponent = teamsInGame.find(tm => tm !== team);
                        if (!opponent || !teamStats.has(team)) return;
                        
                        // Add this row's stats as opponent stats for the OTHER team
                        const oppStats = teamStats.get(opponent);
                        if (oppStats) {
                            oppStats.oppFga += parseFloat(t.fga || t.FGA) || 0;
                            oppStats.oppFgm += parseFloat(t.fgm || t.FGM) || 0;
                            oppStats.oppOreb += parseFloat(t.oreb || t.OREB) || 0;
                            oppStats.oppDreb += parseFloat(t.dreb || t.DREB) || 0;
                            oppStats.oppReb += parseFloat(t.reb || t.REB || (parseFloat(t.oreb || t.OREB) || 0) + (parseFloat(t.dreb || t.DREB) || 0)) || 0;
                            oppStats.oppAst += parseFloat(t.ast || t.AST) || 0;
                            oppStats.oppStl += parseFloat(t.stl || t.STL) || 0;
                            oppStats.oppBlk += parseFloat(t.blk || t.BLK) || 0;
                            oppStats.oppTov += parseFloat(t.tov || t.TOV) || 0;
                            oppStats.oppFta += parseFloat(t.fta || t.FTA) || 0;
                            oppStats.oppTpa += parseFloat(t.tpa || t['3pa'] || t['3PA']) || 0;
                            oppStats.oppTpm += parseFloat(t.tpm || t['3pm'] || t['3PM']) || 0;
                            oppStats.oppPts += parseFloat(t.pts || t.PTS) || 0;
                            oppStats.oppPf += parseFloat(t.pf || t.PF) || 0;
                        }
                    });

                    // Calculate totals for each team
                    teamStats.forEach((s, team) => {
                        const games = teamGames.get(team)?.size || 0;
                        // Dean Oliver possessions: FGA - OREB + TOV + 0.44*FTA
                        const totalPoss = s.fga - s.oreb + s.tov + 0.44 * s.fta;
                        const oppPoss = s.oppFga - s.oppOreb + s.oppTov + 0.44 * s.oppFta;
                        const totalMinutes = s.min > 0 ? s.min : games * 40 * 5; // Use actual minutes if available, else estimate (5 players * 40 min)
                        // BPM 2.0: Calculate team average points per TSA (True Shooting Attempt)
                        const teamTsa = s.fga + 0.44 * s.fta;
                        const avgPtsPerTsa = teamTsa > 0 ? s.pts / teamTsa : 1.0;
                        result.set(team, {
                            games, totalPoss, totalMinutes, oppPoss, avgPtsPerTsa,
                            fga: s.fga, fgm: s.fgm, oreb: s.oreb, dreb: s.dreb, reb: s.reb || (s.oreb + s.dreb),
                            ast: s.ast, stl: s.stl, blk: s.blk, tov: s.tov, fta: s.fta, ftm: s.ftm, tpa: s.tpa, tpm: s.tpm, pts: s.pts, pf: s.pf,
                            oppFga: s.oppFga, oppFgm: s.oppFgm, oppOreb: s.oppOreb, oppDreb: s.oppDreb, oppReb: s.oppReb || (s.oppOreb + s.oppDreb),
                            oppAst: s.oppAst, oppStl: s.oppStl, oppBlk: s.oppBlk, oppTov: s.oppTov, oppFta: s.oppFta, oppTpa: s.oppTpa, oppTpm: s.oppTpm, oppPts: s.oppPts, oppPf: s.oppPf
                        });
                    });
                }
                return result;
            }, [teamTotalsData]);

            // BPM 2.0: Calculate total threshold points per team from player season data
            // This is used for offensive role estimation in BPMPositionCalculator
            const teamThresholdPts = useMemo(() => {
                const result = new Map(); // team -> totalThresholdPts
                if (!seasonData || seasonData.length === 0 || teamSeasonTotals.size === 0) return result;

                // Group players by team and calculate their threshold points
                seasonData.forEach(p => {
                    const team = p.team;
                    if (!team) return;

                    const teamTotals = teamSeasonTotals.get(team);
                    if (!teamTotals) return;

                    // Get player stats
                    const pts = parseFloat(p.points || p.pts || 0) || 0;
                    const fga = parseFloat(p.fga || p.FGA || 0) || 0;
                    const fta = parseFloat(p.fta || p.FTA || 0) || 0;

                    // Calculate player TSA
                    const tsa = fga + 0.44 * fta;
                    if (tsa <= 0) return;

                    // Player pts per TSA
                    const playerPtsPerTsa = pts / tsa;

                    // Threshold efficiency = team avg - 0.33
                    const thresholdEfficiency = (teamTotals.avgPtsPerTsa || 1.0) - 0.33;

                    // Calculate threshold pts (above-average efficient scoring)
                    if (playerPtsPerTsa > thresholdEfficiency) {
                        const thresholdPts = pts - (thresholdEfficiency * tsa);
                        const current = result.get(team) || 0;
                        result.set(team, current + thresholdPts);
                    }
                });

                return result;
            }, [seasonData, teamSeasonTotals]);

            // V5.3: Game dates lookup from stints or team_totals - maps game_id -> game_date
            const gameDatesLookup = useMemo(() => {
                const lookup = new Map();
                // Prefer stints data if available (has game_date field)
                if (stintsData.length > 0) {
                    stintsData.forEach(s => {
                        if (s.game_id && s.game_date && !lookup.has(s.game_id)) {
                            lookup.set(s.game_id, s.game_date);
                        }
                    });
                }
                // Also use team_totals if available
                if (teamTotalsData.length > 0) {
                    teamTotalsData.forEach(t => {
                        if (t.game_id && t.game_date && !lookup.has(t.game_id)) {
                            lookup.set(t.game_id, t.game_date);
                        }
                    });
                }
                return lookup;
            }, [stintsData, teamTotalsData]);
            
            // V5.3: Build team game order (games sorted by date for each team)
            const teamGameOrder = useMemo(() => {
                const result = new Map(); // team -> [{ game_id, game_date, gameNum }]
                // From stints
                if (stintsData.length > 0) {
                    const teamGames = new Map();
                    stintsData.forEach(s => {
                        const gameId = s.game_id;
                        const gameDate = s.game_date;
                        if (!gameId || !gameDate) return;
                        [s.home_team, s.away_team].filter(Boolean).forEach(team => {
                            if (!teamGames.has(team)) teamGames.set(team, new Map());
                            if (!teamGames.get(team).has(gameId)) {
                                teamGames.get(team).set(gameId, gameDate);
                            }
                        });
                    });
                    teamGames.forEach((games, team) => {
                        const sorted = Array.from(games.entries())
                            .map(([gameId, gameDate]) => ({ game_id: gameId, game_date: gameDate }))
                            .sort((a, b) => new Date(a.game_date) - new Date(b.game_date))
                            .map((g, i) => ({ ...g, gameNum: i + 1 }));
                        result.set(team, sorted);
                    });
                }
                // From team_totals
                if (teamTotalsData.length > 0) {
                    const teamGames = new Map();
                    teamTotalsData.forEach(t => {
                        const team = t.team;
                        const gameId = t.game_id;
                        const gameDate = t.game_date;
                        if (!team || !gameId || !gameDate) return;
                        if (!teamGames.has(team)) teamGames.set(team, new Map());
                        if (!teamGames.get(team).has(gameId)) {
                            teamGames.get(team).set(gameId, gameDate);
                        }
                    });
                    teamGames.forEach((games, team) => {
                        if (!result.has(team)) {
                            const sorted = Array.from(games.entries())
                                .map(([gameId, gameDate]) => ({ game_id: gameId, game_date: gameDate }))
                                .sort((a, b) => new Date(a.game_date) - new Date(b.game_date))
                                .map((g, i) => ({ ...g, gameNum: i + 1 }));
                            result.set(team, sorted);
                        }
                    });
                }
                return result;
            }, [stintsData, teamTotalsData]);
            
            // V4.9.8.7.17: Teams from stints data for game range analysis
            const stintsTeams = useMemo(() => {
                if (!stintsData.length) return [];
                const teamsSet = new Set();
                stintsData.forEach(s => {
                    if (s.home_team) teamsSet.add(s.home_team);
                    if (s.away_team) teamsSet.add(s.away_team);
                });
                return Array.from(teamsSet).sort();
            }, [stintsData]);
            
            // V4.9.8.7.17: Process stints data to get unique games in row order per team
            const gamesByTeam = useMemo(() => {
                if (!stintsData.length) return new Map();
                const result = new Map();
                const gameOrderMap = new Map(); // game_id -> first row index (to preserve row order)
                const gameScores = new Map(); // game_id -> { homeTeam, awayTeam, homePts, awayPts, gameDate }
                
                // First pass: determine row order for each game and aggregate scores
                stintsData.forEach((s, rowIndex) => {
                    const gameId = s.game_id;
                    if (!gameId) return;
                    
                    if (!gameOrderMap.has(gameId)) {
                        gameOrderMap.set(gameId, rowIndex);
                    }
                    
                    // Aggregate points for each game
                    if (!gameScores.has(gameId)) {
                        gameScores.set(gameId, { 
                            homeTeam: s.home_team, 
                            awayTeam: s.away_team, 
                            homePts: 0, 
                            awayPts: 0,
                            gameDate: s.game_date || null
                        });
                    }
                    const gs = gameScores.get(gameId);
                    // Calculate points from field goals and free throws
                    const homeFgm = parseFloat(s.home_fgm) || 0;
                    const home3pm = parseFloat(s.home_fg3m) || 0;
                    const homeFtm = parseFloat(s.home_ftm) || 0;
                    const awayFgm = parseFloat(s.away_fgm) || 0;
                    const away3pm = parseFloat(s.away_fg3m) || 0;
                    const awayFtm = parseFloat(s.away_ftm) || 0;
                    gs.homePts += (homeFgm * 2) + home3pm + homeFtm;
                    gs.awayPts += (awayFgm * 2) + away3pm + awayFtm;
                });
                
                // Second pass: build games by team with win/loss info
                stintsData.forEach(s => {
                    const gameId = s.game_id;
                    const homeTeam = s.home_team;
                    const awayTeam = s.away_team;
                    if (!gameId || !homeTeam || !awayTeam) return;
                    
                    const scores = gameScores.get(gameId);
                    
                    [homeTeam, awayTeam].forEach(team => {
                        if (!result.has(team)) result.set(team, new Map());
                        const teamGames = result.get(team);
                        if (!teamGames.has(gameId)) {
                            const isHome = team === homeTeam;
                            const teamPts = isHome ? scores.homePts : scores.awayPts;
                            const oppPts = isHome ? scores.awayPts : scores.homePts;
                            const isWin = teamPts > oppPts;
                            
                            teamGames.set(gameId, {
                                gameId,
                                rowOrder: gameOrderMap.get(gameId),
                                homeTeam,
                                awayTeam,
                                opponent: team === homeTeam ? awayTeam : homeTeam,
                                isHome: team === homeTeam,
                                teamPts: Math.round(teamPts),
                                oppPts: Math.round(oppPts),
                                isWin,
                                result: isWin ? 'W' : 'L',
                                gameDate: scores.gameDate
                            });
                        }
                    });
                });
                
                // Convert to sorted arrays
                const sortedResult = new Map();
                result.forEach((teamGames, team) => {
                    const gamesArray = Array.from(teamGames.values())
                        .sort((a, b) => a.rowOrder - b.rowOrder)
                        .map((g, idx) => ({ ...g, gameNumber: idx + 1 }));
                    sortedResult.set(team, gamesArray);
                });
                
                return sortedResult;
            }, [stintsData]);
            
            // V4.9.8.7.17: Players available for game range team (from stints data)
            // V6.1: Apply merge rules
            const gameRangeTeamPlayers = useMemo(() => {
                if (!stintsData.length || !gameRangeTeam) return [];
                const playersSet = new Set();
                stintsData.forEach(s => {
                    const isHome = s.home_team === gameRangeTeam;
                    const isAway = s.away_team === gameRangeTeam;
                    if (!isHome && !isAway) return;

                    const lineupStr = isHome ? s.home_lineup : s.away_lineup;
                    if (lineupStr) {
                        lineupStr.split(',').forEach(p => {
                            const merged = applyPlayerMerge(p.trim());
                            if (merged) playersSet.add(merged);
                        });
                    }
                });
                return Array.from(playersSet).sort();
            }, [stintsData, gameRangeTeam, applyPlayerMerge, playerMergeRules]);
            
            const teams = useMemo(() => [...new Set(lineupData.map(d => d.Team))].filter(t => t), [lineupData]);
            useEffect(() => { if (teams.length > 0 && !team) setTeam(teams[0]); }, [teams, team]);

            // Season stats map for player lookup
            // V6.1: Apply merge rules so that merged players share stats
            const seasonStatsMap = useMemo(() => {
                const map = new Map();
                seasonData.forEach(d => {
                    const rawName = d.Player_Name || '';
                    const mergedName = applyPlayerMerge(rawName);
                    const playerName = normalizePlayerName(mergedName);
                    const nameVariations = (d.Name_Variations || '').split(';').map(n => normalizePlayerName(applyPlayerMerge(n))).filter(n => n);
                    const stats = {
                        team: d.Team, name: d.Player_Name, games: parseFloat(d.Games) || 0, mpg: parseFloat(d.MPG) || 0, min: parseFloat(d.MIN) || 0,
                        ppg: parseFloat(d.PPG) || 0, pts: parseFloat(d.PTS) || 0, fgm: parseFloat(d.FGM) || 0, fga: parseFloat(d.FGA) || 0, fgPct: parseFloat(d['FG%']) || 0,
                        tpm: parseFloat(d['3PM']) || 0, tpa: parseFloat(d['3PA']) || 0, tpPct: parseFloat(d['3P%']) || 0,
                        ftm: parseFloat(d.FTM) || 0, fta: parseFloat(d.FTA) || 0, ftPct: parseFloat(d['FT%']) || 0,
                        oreb: parseFloat(d.OREB) || 0, dreb: parseFloat(d.DREB) || 0, reb: parseFloat(d.REB) || 0,
                        ast: parseFloat(d.AST) || 0, stl: parseFloat(d.STL) || 0, blk: parseFloat(d.BLK) || 0, tov: parseFloat(d.TOV) || 0, pf: parseFloat(d.PF) || 0, 
                        usg: parseFloat(d['USG%']) || 0,
                        rimAtt: parseFloat(d.RIM_ATT) || 0, rimMade: parseFloat(d.RIM_MADE) || 0, rimPct: parseFloat(d['RIM%']) || 0,
                        midAtt: parseFloat(d.OTD_2PT_ATT) || 0, midMade: parseFloat(d.OTD_2PT_MADE) || 0, midPct: parseFloat(d['OTD_2PT%']) || 0,
                        threeAtt: parseFloat(d.OTD_3PT_ATT) || 0, threeMade: parseFloat(d.OTD_3PT_MADE) || 0, threePct: parseFloat(d['OTD_3PT%']) || 0,
                        passTo: parseFloat(d.PASS_TO) || 0, dribTo: parseFloat(d.DRIBBLE_TO) || 0, defTo: parseFloat(d.DEFENSE_TO) || 0, miscTo: parseFloat(d.MISC_TO) || 0,
                        fastBreakPts: parseFloat(d.FAST_BREAK_PTS) || 0, secChancePts: parseFloat(d['2ND_CHANCE_PTS']) || 0, ptsOffTov: parseFloat(d.PTS_OFF_TOV) || 0,
                        // V5.10: Add BPM stats from CSV (if available)
                        bpm: d.BPM !== undefined && d.BPM !== '' ? parseFloat(d.BPM) : null,
                        obpm: d.OBPM !== undefined && d.OBPM !== '' ? parseFloat(d.OBPM) : null,
                        dbpm: d.DBPM !== undefined && d.DBPM !== '' ? parseFloat(d.DBPM) : null,
                    };
                    const per40 = stats.min > 0 ? 40 / stats.min : 0;
                    stats.pts40 = stats.pts * per40; stats.reb40 = stats.reb * per40; stats.ast40 = stats.ast * per40;
                    stats.stl40 = stats.stl * per40; stats.blk40 = stats.blk * per40; stats.tov40 = stats.tov * per40;
                    stats.rimA40 = stats.rimAtt * per40; stats.midA40 = stats.midAtt * per40; stats.threeA40 = stats.threeAtt * per40;
                    stats.seasonRimPct = stats.rimAtt > 0 ? (stats.rimMade / stats.rimAtt) * 100 : 0;
                    stats.seasonMidPct = stats.midAtt > 0 ? (stats.midMade / stats.midAtt) * 100 : 0;
                    stats.seasonThreePct = stats.tpa > 0 ? (stats.tpm / stats.tpa) * 100 : 0;
                    if (playerName) map.set(playerName, stats);
                    nameVariations.forEach(v => { if (v && !map.has(v)) map.set(v, stats); });
                });
                return map;
            }, [seasonData, applyPlayerMerge, playerMergeRules]);

            const teamPlayers = useMemo(() => {
                if (!team) return [];
                const s = new Set();
                // V6.1: Apply merge rules when building player list
                lineupData.filter(d => d.Team === team).forEach(d => {
                    if (d.Lineup) d.Lineup.split(',').forEach(p => {
                        const merged = applyPlayerMerge(p.trim());
                        if (merged) s.add(merged);
                    });
                });
                return Array.from(s).sort();
            }, [lineupData, team, applyPlayerMerge, playerMergeRules]);

            // V4.3.5: All players with teams for lineup builder - V6.1: With merge rules
            const allPlayersWithTeams = useMemo(() => {
                const playerMap = new Map();
                lineupData.forEach(d => {
                    if (d.Lineup && d.Team) {
                        d.Lineup.split(',').forEach(p => {
                            const merged = applyPlayerMerge(p.trim());
                            if (merged && !playerMap.has(merged)) {
                                playerMap.set(merged, d.Team);
                            }
                        });
                    }
                });
                return Array.from(playerMap.entries())
                    .map(([name, team]) => ({ name, team }))
                    .sort((a, b) => a.team.localeCompare(b.team) || a.name.localeCompare(b.name));
            }, [lineupData, applyPlayerMerge, playerMergeRules]);

            // Build all lineups map with properly calculated stats using Dean Oliver possessions
            // NOW INCLUDES RAW TOTALS for head-to-head subtraction
            // V4.2.3: All stats recalculated from raw totals (not using pre-calculated CSV values)
            // V6.1: Aggregate stats when lineups merge to same key (due to player name merging)
            const allLineupsMap = useMemo(() => {
                const map = new Map();
                const rawTotals = new Map(); // Store raw totals for aggregation

                lineupData.forEach(d => {
                    const key = normalizeLineup(d.Lineup);
                    if (!key) return;

                    // Parse raw values
                    const fga = parseFloat(d.FGA) || 0, oreb = parseFloat(d.OREB) || 0, tov = parseFloat(d.TOV) || 0, fta = parseFloat(d.FTA) || 0;
                    const fgaVs = parseFloat(d.FGA_VS) || 0, orebVs = parseFloat(d.OREB_VS) || 0, tovVs = parseFloat(d.TOV_VS) || 0, ftaVs = parseFloat(d.FTA_VS) || 0;
                    const fgm = parseFloat(d.FGM)||0, tpm = parseFloat(d['3PM'])||0, tpa = parseFloat(d['3PA'])||0;
                    const fgmV = parseFloat(d.FGM_VS)||0, tpmV = parseFloat(d['3PM_VS'])||0, tpaV = parseFloat(d['3PA_VS'])||0;
                    const drebV = parseFloat(d.DREB_VS)||0, dreb = parseFloat(d.DREB)||0, orebV = parseFloat(d.OREB_VS)||0;
                    const ast = parseFloat(d.AST)||0, stl = parseFloat(d.STL)||0, blk = parseFloat(d.BLK)||0;
                    const astV = parseFloat(d.AST_VS)||0, stlV = parseFloat(d.STL_VS)||0, blkV = parseFloat(d.BLK_VS)||0;
                    const ftm = parseFloat(d.FTM)||0, ftmV = parseFloat(d.FTM_VS)||0;
                    const paceF = parseFloat(d.PACE_FOR) || 0, paceV = parseFloat(d.PACE_VS) || 0;
                    const time = parseFloat(d.TOTAL_TIME) || 0;

                    if (!rawTotals.has(key)) {
                        rawTotals.set(key, {
                            team: d.Team, lineup: d.Lineup,
                            fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, tov: 0, ast: 0, stl: 0, blk: 0,
                            fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftmV: 0, ftaV: 0, orebV: 0, drebV: 0, tovV: 0, astV: 0, stlV: 0, blkV: 0,
                            wPaceF: 0, wPaceV: 0, time: 0
                        });
                    }
                    const t = rawTotals.get(key);
                    t.fgm += fgm; t.fga += fga; t.tpm += tpm; t.tpa += tpa; t.ftm += ftm; t.fta += fta;
                    t.oreb += oreb; t.dreb += dreb; t.tov += tov; t.ast += ast; t.stl += stl; t.blk += blk;
                    t.fgmV += fgmV; t.fgaV += fgaVs; t.tpmV += tpmV; t.tpaV += tpaV; t.ftmV += ftmV; t.ftaV += ftaVs;
                    t.orebV += orebV; t.drebV += drebV; t.tovV += tovVs; t.astV += astV; t.stlV += stlV; t.blkV += blkV;
                    t.wPaceF += paceF * time; t.wPaceV += paceV * time; t.time += time;
                });

                // Calculate derived stats from aggregated totals
                rawTotals.forEach((t, key) => {
                    const poss = calcPoss(t.fga, t.oreb, t.tov, t.fta);
                    const possVs = calcPoss(t.fgaV, t.orebV, t.tovV, t.ftaV);
                    const combPoss = poss + possVs;
                    const pts = 2 * t.fgm + t.tpm + t.ftm;
                    const ptsV = 2 * t.fgmV + t.tpmV + t.ftmV;
                    const offRtg = poss > 0 ? (pts / poss) * 100 : 0;
                    const defRtg = possVs > 0 ? (ptsV / possVs) * 100 : 0;
                    const netRtg = offRtg - defRtg;
                    const offTovDenom = t.fga + 0.44 * t.fta + t.tov;
                    const defTovDenom = t.fgaV + 0.44 * t.ftaV + t.tovV;

                    map.set(key, {
                        team: t.team, lineup: t.lineup, poss, possVs, combPoss,
                        off: offRtg, def: defRtg, net: netRtg,
                        paceF: t.time > 0 ? t.wPaceF / t.time : 0, paceV: t.time > 0 ? t.wPaceV / t.time : 0,
                        offEfg: t.fga > 0 ? ((t.fgm + 0.5*t.tpm)/t.fga)*100 : 0,
                        offTov: offTovDenom > 0 ? (t.tov/offTovDenom)*100 : 0,
                        offOreb: (t.oreb+t.drebV) > 0 ? (t.oreb/(t.oreb+t.drebV))*100 : 0,
                        offFtR: t.fga > 0 ? (t.fta/t.fga)*100 : 0,
                        defEfg: t.fgaV > 0 ? ((t.fgmV + 0.5*t.tpmV)/t.fgaV)*100 : 0,
                        defTov: defTovDenom > 0 ? (t.tovV/defTovDenom)*100 : 0,
                        defOreb: (t.orebV+t.dreb) > 0 ? (t.orebV/(t.orebV+t.dreb))*100 : 0,
                        defFtR: t.fgaV > 0 ? (t.ftaV/t.fgaV)*100 : 0,
                        astPct: t.fgm > 0 ? (t.ast/t.fgm)*100 : 0,
                        stlPct: possVs > 0 ? (t.stl/possVs)*100 : 0,
                        blkPct: (t.fgaV-t.tpaV) > 0 ? (t.blk/(t.fgaV-t.tpaV))*100 : 0,
                        oppAstPct: t.fgmV > 0 ? (t.astV/t.fgmV)*100 : 0,
                        oppStlPct: poss > 0 ? (t.stlV/poss)*100 : 0,
                        oppBlkPct: (t.fga-t.tpa) > 0 ? (t.blkV/(t.fga-t.tpa))*100 : 0,
                        // RAW TOTALS for head-to-head subtraction
                        raw: { fgm: t.fgm, fga: t.fga, tpm: t.tpm, tpa: t.tpa, ftm: t.ftm, fta: t.fta, oreb: t.oreb, dreb: t.dreb, tov: t.tov, ast: t.ast, stl: t.stl, blk: t.blk,
                               fgmV: t.fgmV, fgaV: t.fgaV, tpmV: t.tpmV, tpaV: t.tpaV, ftmV: t.ftmV, ftaV: t.ftaV, orebV: t.orebV, drebV: t.drebV, tovV: t.tovV, astV: t.astV, stlV: t.stlV, blkV: t.blkV,
                               poss, possVs }
                    });
                });

                return map;
            }, [lineupData]);

            // Calculate team-level averages for ALL teams in the dataset
            const allTeamsAverages = useMemo(() => {
                if (!lineupData.length) return [];
                const teamTotals = new Map();
                lineupData.forEach(d => {
                    const teamName = d.Team;
                    if (!teamName) return;
                    if (!teamTotals.has(teamName)) {
                        teamTotals.set(teamName, {
                            time: 0, poss: 0, possV: 0, combP: 0, pts: 0, ptsV: 0,
                            fgm: 0, fga: 0, tpm: 0, tpa: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, tov: 0, ast: 0, stl: 0, blk: 0,
                            fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftaV: 0, ftmV: 0, orebV: 0, drebV: 0, tovV: 0, astV: 0, stlV: 0, blkV: 0,
                            wPaceF: 0, wPaceV: 0,
                            rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0,
                            rimAV: 0, rimMV: 0, midAV: 0, midMV: 0, threeAV: 0, threeMV: 0,
                            // MISC and transition stats
                            secChance: 0, ptsOffTov: 0, fastBreak: 0,
                            secChanceV: 0, ptsOffTovV: 0, fastBreakV: 0
                        });
                    }
                    const t = teamTotals.get(teamName);
                    const fga = parseFloat(d.FGA) || 0, oreb = parseFloat(d.OREB) || 0, tov = parseFloat(d.TOV) || 0, fta = parseFloat(d.FTA) || 0;
                    const fgaVs = parseFloat(d.FGA_VS) || 0, orebVs = parseFloat(d.OREB_VS) || 0, tovVs = parseFloat(d.TOV_VS) || 0, ftaVs = parseFloat(d.FTA_VS) || 0;
                    const poss = calcPoss(fga, oreb, tov, fta);
                    const possVs = calcPoss(fgaVs, orebVs, tovVs, ftaVs);
                    const combPoss = poss + possVs;
                    const time = parseFloat(d.TOTAL_TIME) || 0;
                    const fgm = parseFloat(d.FGM)||0, tpm = parseFloat(d['3PM'])||0, tpa = parseFloat(d['3PA'])||0;
                    const fgmV = parseFloat(d.FGM_VS)||0, tpmV = parseFloat(d['3PM_VS'])||0, tpaV = parseFloat(d['3PA_VS'])||0;
                    const dreb = parseFloat(d.DREB)||0, orebV = parseFloat(d.OREB_VS)||0, drebV = parseFloat(d.DREB_VS)||0;
                    const ast = parseFloat(d.AST)||0, stl = parseFloat(d.STL)||0, blk = parseFloat(d.BLK)||0;
                    const astV = parseFloat(d.AST_VS)||0, stlV = parseFloat(d.STL_VS)||0, blkV = parseFloat(d.BLK_VS)||0;
                    const rimA = parseFloat(d.RIM_ATT)||0, rimM = parseFloat(d.RIM_MADE)||0;
                    const midA = parseFloat(d.OTD_2PT_ATT)||0, midM = parseFloat(d.OTD_2PT_MADE)||0;
                    const threeA = parseFloat(d.OTD_3PT_ATT)||0, threeM = parseFloat(d.OTD_3PT_MADE)||0;
                    const rimAV = parseFloat(d.RIM_ATT_VS)||0, rimMV = parseFloat(d.RIM_MADE_VS)||0;
                    const midAV = parseFloat(d.OTD_2PT_ATT_VS)||0, midMV = parseFloat(d.OTD_2PT_MADE_VS)||0;
                    const threeAV = parseFloat(d.OTD_3PT_ATT_VS)||0, threeMV = parseFloat(d.OTD_3PT_MADE_VS)||0;
                    // V4.2.3: Get FTM for calculating ratings from totals
                    const ftm = parseFloat(d.FTM)||0, ftmV = parseFloat(d.FTM_VS)||0;
                    const paceF = parseFloat(d.PACE_FOR) || 0, paceV = parseFloat(d.PACE_VS) || 0;
                    // Points
                    const pts = parseFloat(d.PTS) || 0, ptsV = parseFloat(d.PTS_VS) || 0;
                    // MISC and transition raw values
                    const secChance = parseFloat(d['2ND_CHANCE_PTS']) || 0;
                    const ptsOffTov = parseFloat(d.PTS_OFF_TOV) || 0;
                    const fastBreak = parseFloat(d.FAST_BREAK_PTS) || 0;
                    const secChanceV = parseFloat(d['2ND_CHANCE_PTS_VS']) || 0;
                    const ptsOffTovV = parseFloat(d.PTS_OFF_TOV_VS) || 0;
                    const fastBreakV = parseFloat(d.FAST_BREAK_PTS_VS) || 0;
                    
                    t.time += time; t.poss += poss; t.possV += possVs; t.combP += combPoss;
                    t.pts += pts; t.ptsV += ptsV;
                    t.fgm += fgm; t.fga += fga; t.tpm += tpm; t.tpa += tpa; t.fta += fta; t.ftm += ftm;
                    t.oreb += oreb; t.dreb += dreb; t.tov += tov; t.ast += ast; t.stl += stl; t.blk += blk;
                    t.fgmV += fgmV; t.fgaV += fgaVs; t.tpmV += tpmV; t.tpaV += tpaV; t.ftaV += ftaVs; t.ftmV += ftmV;
                    t.orebV += orebV; t.drebV += drebV; t.tovV += tovVs; t.astV += astV; t.stlV += stlV; t.blkV += blkV;
                    t.wPaceF += paceF * time; t.wPaceV += paceV * time;
                    t.rimA += rimA; t.rimM += rimM; t.midA += midA; t.midM += midM; t.threeA += threeA; t.threeM += threeM;
                    t.rimAV += rimAV; t.rimMV += rimMV; t.midAV += midAV; t.midMV += midMV; t.threeAV += threeAV; t.threeMV += threeMV;
                    // MISC and transition
                    t.secChance += secChance; t.ptsOffTov += ptsOffTov; t.fastBreak += fastBreak;
                    t.secChanceV += secChanceV; t.ptsOffTovV += ptsOffTovV; t.fastBreakV += fastBreakV;
                });
                const teamAverages = [];
                teamTotals.forEach((t, teamName) => {
                    if (t.combP === 0) return;
                    // V4.2.3: Calculate team ratings from aggregated totals
                    const teamPts = 2 * t.fgm + t.tpm + t.ftm;
                    const teamPtsV = 2 * t.fgmV + t.tpmV + t.ftmV;
                    const teamOff = t.poss > 0 ? (teamPts / t.poss) * 100 : 0;
                    const teamDef = t.possV > 0 ? (teamPtsV / t.possV) * 100 : 0;
                    // MISC and transition per 100 poss
                    const secChance100 = t.poss > 0 ? (t.secChance / t.poss) * 100 : 0;
                    const ptsOffTov100 = t.poss > 0 ? (t.ptsOffTov / t.poss) * 100 : 0;
                    const fastBreak100 = t.poss > 0 ? (t.fastBreak / t.poss) * 100 : 0;
                    const secChance100V = t.possV > 0 ? (t.secChanceV / t.possV) * 100 : 0;
                    const ptsOffTov100V = t.possV > 0 ? (t.ptsOffTovV / t.possV) * 100 : 0;
                    const fastBreak100V = t.possV > 0 ? (t.fastBreakV / t.possV) * 100 : 0;
                    // Transition percentages
                    const transPct = t.pts > 0 ? (t.fastBreak / t.pts) * 100 : 0;
                    const transPctV = t.ptsV > 0 ? (t.fastBreakV / t.ptsV) * 100 : 0;
                    
                    teamAverages.push({
                        team: teamName,
                        net: teamOff - teamDef, off: teamOff, def: teamDef,
                        paceF: t.time > 0 ? t.wPaceF / t.time : 0, paceV: t.time > 0 ? t.wPaceV / t.time : 0,
                        offEfg: t.fga > 0 ? ((t.fgm + 0.5*t.tpm)/t.fga)*100 : 0,
                        offTov: (t.fga + 0.44 * t.fta + t.tov) > 0 ? (t.tov/(t.fga + 0.44 * t.fta + t.tov))*100 : 0,
                        offOreb: (t.oreb+t.drebV) > 0 ? (t.oreb/(t.oreb+t.drebV))*100 : 0,
                        offFtR: t.fga > 0 ? (t.fta/t.fga)*100 : 0,
                        defEfg: t.fgaV > 0 ? ((t.fgmV + 0.5*t.tpmV)/t.fgaV)*100 : 0,
                        defTov: (t.fgaV + 0.44 * t.ftaV + t.tovV) > 0 ? (t.tovV/(t.fgaV + 0.44 * t.ftaV + t.tovV))*100 : 0,
                        defOreb: (t.orebV+t.dreb) > 0 ? (t.orebV/(t.orebV+t.dreb))*100 : 0,
                        defFtR: t.fgaV > 0 ? (t.ftaV/t.fgaV)*100 : 0,
                        astPct: t.fgm > 0 ? (t.ast/t.fgm)*100 : 0,
                        stlPct: t.possV > 0 ? (t.stl/t.possV)*100 : 0,
                        blkPct: (t.fgaV-t.tpaV) > 0 ? (t.blk/(t.fgaV-t.tpaV))*100 : 0,
                        oppAstPct: t.fgmV > 0 ? (t.astV/t.fgmV)*100 : 0,
                        oppStlPct: t.poss > 0 ? (t.stlV/t.poss)*100 : 0,
                        oppBlkPct: (t.fga-t.tpa) > 0 ? (t.blkV/(t.fga-t.tpa))*100 : 0,
                        rimPct: t.rimA > 0 ? (t.rimM/t.rimA)*100 : 0,
                        midPct: t.midA > 0 ? (t.midM/t.midA)*100 : 0,
                        threePct: t.threeA > 0 ? (t.threeM/t.threeA)*100 : 0,
                        rimPctV: t.rimAV > 0 ? (t.rimMV/t.rimAV)*100 : 0,
                        midPctV: t.midAV > 0 ? (t.midMV/t.midAV)*100 : 0,
                        threePctV: t.threeAV > 0 ? (t.threeMV/t.threeAV)*100 : 0,
                        // Volume stats (attempts per 100 possessions)
                        rimVol: t.poss > 0 ? (t.rimA / t.poss) * 100 : 0,
                        midVol: t.poss > 0 ? (t.midA / t.poss) * 100 : 0,
                        threeVol: t.poss > 0 ? (t.threeA / t.poss) * 100 : 0,
                        rimVolV: t.possV > 0 ? (t.rimAV / t.possV) * 100 : 0,
                        midVolV: t.possV > 0 ? (t.midAV / t.possV) * 100 : 0,
                        threeVolV: t.possV > 0 ? (t.threeAV / t.possV) * 100 : 0,
                        // Raw 3PT values for league average calculation
                        tpm: t.tpm, tpa: t.tpa,
                        // MISC and transition stats
                        secChance100, ptsOffTov100, secChance100V, ptsOffTov100V,
                        fastBreak100, fastBreak100V, transPct, transPctV
                    });
                });
                return teamAverages;
            }, [lineupData]);

            // Team averages lookup map (team name -> averages object) for On/Off Stats tab
            const teamAvgMap = useMemo(() => {
                const map = {};
                allTeamsAverages.forEach(t => { map[t.team] = t; });
                return map;
            }, [allTeamsAverages]);

            // Extract arrays of team average values for percentile calculations
            const teamAvgArrays = useMemo(() => {
                if (!allTeamsAverages.length) return {};
                return {
                    net: allTeamsAverages.map(t => t.net), off: allTeamsAverages.map(t => t.off), def: allTeamsAverages.map(t => t.def),
                    paceF: allTeamsAverages.map(t => t.paceF), paceV: allTeamsAverages.map(t => t.paceV),
                    offEfg: allTeamsAverages.map(t => t.offEfg), offTov: allTeamsAverages.map(t => t.offTov),
                    offOreb: allTeamsAverages.map(t => t.offOreb), offFtR: allTeamsAverages.map(t => t.offFtR),
                    defEfg: allTeamsAverages.map(t => t.defEfg), defTov: allTeamsAverages.map(t => t.defTov),
                    defOreb: allTeamsAverages.map(t => t.defOreb), defFtR: allTeamsAverages.map(t => t.defFtR),
                    astPct: allTeamsAverages.map(t => t.astPct), stlPct: allTeamsAverages.map(t => t.stlPct), blkPct: allTeamsAverages.map(t => t.blkPct),
                    oppAstPct: allTeamsAverages.map(t => t.oppAstPct), oppStlPct: allTeamsAverages.map(t => t.oppStlPct), oppBlkPct: allTeamsAverages.map(t => t.oppBlkPct),
                    rimPct: allTeamsAverages.map(t => t.rimPct), midPct: allTeamsAverages.map(t => t.midPct), threePct: allTeamsAverages.map(t => t.threePct),
                    rimPctV: allTeamsAverages.map(t => t.rimPctV), midPctV: allTeamsAverages.map(t => t.midPctV), threePctV: allTeamsAverages.map(t => t.threePctV),
                    // MISC stats
                    secChance100: allTeamsAverages.map(t => t.secChance100 || 0), ptsOffTov100: allTeamsAverages.map(t => t.ptsOffTov100 || 0),
                    secChance100V: allTeamsAverages.map(t => t.secChance100V || 0), ptsOffTov100V: allTeamsAverages.map(t => t.ptsOffTov100V || 0),
                    // Transition stats
                    fastBreak100: allTeamsAverages.map(t => t.fastBreak100 || 0), fastBreak100V: allTeamsAverages.map(t => t.fastBreak100V || 0),
                    transPct: allTeamsAverages.map(t => t.transPct || 0), transPctV: allTeamsAverages.map(t => t.transPctV || 0),
                };
            }, [allTeamsAverages]);

            // V4.2.3: Calculate LEAGUE-WIDE TOTALS for Bayesian shrinkage
            // Aggregates all raw counting stats across all lineups, then calculates rates
            // This is the proper way to calculate league averages (not averaging team %s)
            const leagueTotals = useMemo(() => {
                if (!lineupData.length) return null;
                const t = { 
                    fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, 
                    oreb: 0, dreb: 0, tov: 0, ast: 0, stl: 0, blk: 0,
                    fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftmV: 0, ftaV: 0, 
                    orebV: 0, drebV: 0, tovV: 0, astV: 0, stlV: 0, blkV: 0,
                    poss: 0, possV: 0
                };
                lineupData.forEach(d => {
                    const fga = parseFloat(d.FGA) || 0, oreb = parseFloat(d.OREB) || 0, tov = parseFloat(d.TOV) || 0, fta = parseFloat(d.FTA) || 0;
                    const fgaVs = parseFloat(d.FGA_VS) || 0, orebVs = parseFloat(d.OREB_VS) || 0, tovVs = parseFloat(d.TOV_VS) || 0, ftaVs = parseFloat(d.FTA_VS) || 0;
                    const poss = calcPoss(fga, oreb, tov, fta);
                    const possVs = calcPoss(fgaVs, orebVs, tovVs, ftaVs);
                    t.fgm += parseFloat(d.FGM) || 0; t.fga += fga;
                    t.tpm += parseFloat(d['3PM']) || 0; t.tpa += parseFloat(d['3PA']) || 0;
                    t.ftm += parseFloat(d.FTM) || 0; t.fta += fta;
                    t.oreb += oreb; t.dreb += parseFloat(d.DREB) || 0;
                    t.tov += tov; t.ast += parseFloat(d.AST) || 0;
                    t.stl += parseFloat(d.STL) || 0; t.blk += parseFloat(d.BLK) || 0;
                    t.fgmV += parseFloat(d.FGM_VS) || 0; t.fgaV += fgaVs;
                    t.tpmV += parseFloat(d['3PM_VS']) || 0; t.tpaV += parseFloat(d['3PA_VS']) || 0;
                    t.ftmV += parseFloat(d.FTM_VS) || 0; t.ftaV += ftaVs;
                    t.orebV += orebVs; t.drebV += parseFloat(d.DREB_VS) || 0;
                    t.tovV += tovVs; t.astV += parseFloat(d.AST_VS) || 0;
                    t.stlV += parseFloat(d.STL_VS) || 0; t.blkV += parseFloat(d.BLK_VS) || 0;
                    t.poss += poss; t.possV += possVs;
                });
                return t;
            }, [lineupData]);

            // Calculate league average RATES from league totals (for Bayesian prior)
            const leagueAverages = useMemo(() => {
                if (!leagueTotals) return null;
                const t = leagueTotals;
                const pts = 2 * t.fgm + t.tpm + t.ftm;
                const ptsV = 2 * t.fgmV + t.tpmV + t.ftmV;
                return {
                    // Offensive rates (calculated from league totals)
                    off: t.poss > 0 ? (pts / t.poss) * 100 : 0,
                    offEfg: t.fga > 0 ? ((t.fgm + 0.5 * t.tpm) / t.fga) * 100 : 0,
                    offTov: t.poss > 0 ? (t.tov / t.poss) * 100 : 0,
                    offOreb: (t.oreb + t.drebV) > 0 ? (t.oreb / (t.oreb + t.drebV)) * 100 : 0,
                    offFtR: t.fga > 0 ? (t.fta / t.fga) * 100 : 0,
                    // Defensive rates (calculated from league totals)
                    def: t.possV > 0 ? (ptsV / t.possV) * 100 : 0,
                    defEfg: t.fgaV > 0 ? ((t.fgmV + 0.5 * t.tpmV) / t.fgaV) * 100 : 0,
                    defTov: t.possV > 0 ? (t.tovV / t.possV) * 100 : 0,
                    defOreb: (t.orebV + t.dreb) > 0 ? (t.orebV / (t.orebV + t.dreb)) * 100 : 0,
                    defFtR: t.fgaV > 0 ? (t.ftaV / t.fgaV) * 100 : 0,
                    // Playmaking rates (calculated from league totals)
                    astPct: t.fgm > 0 ? (t.ast / t.fgm) * 100 : 0,
                    stlPct: t.possV > 0 ? (t.stl / t.possV) * 100 : 0,
                    blkPct: (t.fgaV - t.tpaV) > 0 ? (t.blk / (t.fgaV - t.tpaV)) * 100 : 0,
                    oppAstPct: t.fgmV > 0 ? (t.astV / t.fgmV) * 100 : 0,
                    oppStlPct: t.poss > 0 ? (t.stlV / t.poss) * 100 : 0,
                    oppBlkPct: (t.fga - t.tpa) > 0 ? (t.blkV / (t.fga - t.tpa)) * 100 : 0,
                    // Store per-possession rates for generating prior expected counts
                    perPoss: {
                        fgm: t.poss > 0 ? t.fgm / t.poss : 0,
                        fga: t.poss > 0 ? t.fga / t.poss : 0,
                        tpm: t.poss > 0 ? t.tpm / t.poss : 0,
                        tpa: t.poss > 0 ? t.tpa / t.poss : 0,
                        ftm: t.poss > 0 ? t.ftm / t.poss : 0,
                        fta: t.poss > 0 ? t.fta / t.poss : 0,
                        oreb: t.poss > 0 ? t.oreb / t.poss : 0,
                        dreb: t.poss > 0 ? t.dreb / t.poss : 0,
                        tov: t.poss > 0 ? t.tov / t.poss : 0,
                        ast: t.poss > 0 ? t.ast / t.poss : 0,
                        stl: t.possV > 0 ? t.stl / t.possV : 0,
                        blk: t.possV > 0 ? t.blk / t.possV : 0,
                        // Defensive (vs) per-possession rates
                        fgmV: t.possV > 0 ? t.fgmV / t.possV : 0,
                        fgaV: t.possV > 0 ? t.fgaV / t.possV : 0,
                        tpmV: t.possV > 0 ? t.tpmV / t.possV : 0,
                        tpaV: t.possV > 0 ? t.tpaV / t.possV : 0,
                        ftmV: t.possV > 0 ? t.ftmV / t.possV : 0,
                        ftaV: t.possV > 0 ? t.ftaV / t.possV : 0,
                        orebV: t.possV > 0 ? t.orebV / t.possV : 0,
                        drebV: t.possV > 0 ? t.drebV / t.possV : 0,
                        tovV: t.possV > 0 ? t.tovV / t.possV : 0,
                        astV: t.possV > 0 ? t.astV / t.possV : 0,
                        stlV: t.poss > 0 ? t.stlV / t.poss : 0,
                        blkV: t.poss > 0 ? t.blkV / t.poss : 0,
                    }
                };
            }, [leagueTotals]);

            // All lineups for the selected team with Dean Oliver possessions
            // V4.2.3: Recalculate all ratings from raw totals
            const allTeamLineups = useMemo(() => {
                if (!team) return [];
                return lineupData.filter(d => d.Team === team).map(d => {
                    const fga = parseFloat(d.FGA) || 0, oreb = parseFloat(d.OREB) || 0, tov = parseFloat(d.TOV) || 0, fta = parseFloat(d.FTA) || 0;
                    const fgaVs = parseFloat(d.FGA_VS) || 0, orebVs = parseFloat(d.OREB_VS) || 0, tovVs = parseFloat(d.TOV_VS) || 0, ftaVs = parseFloat(d.FTA_VS) || 0;
                    const fgm = parseFloat(d.FGM) || 0, tpm = parseFloat(d['3PM']) || 0, ftm = parseFloat(d.FTM) || 0;
                    const fgmVs = parseFloat(d.FGM_VS) || 0, tpmVs = parseFloat(d['3PM_VS']) || 0, ftmVs = parseFloat(d.FTM_VS) || 0;
                    const poss = calcPoss(fga, oreb, tov, fta);
                    const possVs = calcPoss(fgaVs, orebVs, tovVs, ftaVs);
                    // V4.2.3: Recalculate ratings from raw box score data
                    const pts = 2 * fgm + tpm + ftm;
                    const ptsVs = 2 * fgmVs + tpmVs + ftmVs;
                    const offRtg = poss > 0 ? (pts / poss) * 100 : 0;
                    const defRtg = possVs > 0 ? (ptsVs / possVs) * 100 : 0;
                    const netRtg = offRtg - defRtg;
                    return { ...d, POSS: poss, POSS_VS: possVs, COMB_POSS: poss + possVs,
                        NET: netRtg, OFF: offRtg, DEF: defRtg,
                        PACE_F: parseFloat(d.PACE_FOR) || 0, PACE_V: parseFloat(d.PACE_VS) || 0,
                        TIME: parseFloat(d.TOTAL_TIME) || 0, normalizedLineup: normalizeLineup(d.Lineup) };
                });
            }, [lineupData, team]);

            // Selected team's average (for comparison within team)
            // V4.2.3: Calculate ratings from aggregated totals
            const teamAvg = useMemo(() => {
                if (!allTeamLineups.length) return { net: 0, off: 0, def: 0, paceF: 0, paceV: 0, offEfg: 0, offTov: 0, offOreb: 0, offFtR: 0, defEfg: 0, defTov: 0, defOreb: 0, defFtR: 0, astPct: 0, stlPct: 0, blkPct: 0, oppAstPct: 0, oppStlPct: 0, oppBlkPct: 0, rimPct: 0, midPct: 0, threePct: 0, rimPctV: 0, midPctV: 0, threePctV: 0, rimVol: 0, midVol: 0, threeVol: 0, rimVolV: 0, midVolV: 0, threeVolV: 0, secChance100: 0, ptsOffTov100: 0, secChance100V: 0, ptsOffTov100V: 0, fastBreak100: 0, fastBreak100V: 0, transPct: 0, transPctV: 0 };
                const t = allTeamLineups.reduce((a, d) => {
                    const fgm = parseFloat(d.FGM)||0, fga = parseFloat(d.FGA)||0, tpm = parseFloat(d['3PM'])||0, tpa = parseFloat(d['3PA'])||0, fta = parseFloat(d.FTA)||0, ftm = parseFloat(d.FTM)||0, oreb = parseFloat(d.OREB)||0, dreb = parseFloat(d.DREB)||0, tov = parseFloat(d.TOV)||0, ast = parseFloat(d.AST)||0, stl = parseFloat(d.STL)||0, blk = parseFloat(d.BLK)||0;
                    const fgmV = parseFloat(d.FGM_VS)||0, fgaV = parseFloat(d.FGA_VS)||0, tpmV = parseFloat(d['3PM_VS'])||0, tpaV = parseFloat(d['3PA_VS'])||0, ftaV = parseFloat(d.FTA_VS)||0, ftmV = parseFloat(d.FTM_VS)||0, orebV = parseFloat(d.OREB_VS)||0, drebV = parseFloat(d.DREB_VS)||0, tovV = parseFloat(d.TOV_VS)||0;
                    const astV = parseFloat(d.AST_VS)||0, stlV = parseFloat(d.STL_VS)||0, blkV = parseFloat(d.BLK_VS)||0;
                    const rimA = parseFloat(d.RIM_ATT)||0, rimM = parseFloat(d.RIM_MADE)||0, midA = parseFloat(d.OTD_2PT_ATT)||0, midM = parseFloat(d.OTD_2PT_MADE)||0, threeA = parseFloat(d.OTD_3PT_ATT)||0, threeM = parseFloat(d.OTD_3PT_MADE)||0;
                    const rimAV = parseFloat(d.RIM_ATT_VS)||0, rimMV = parseFloat(d.RIM_MADE_VS)||0, midAV = parseFloat(d.OTD_2PT_ATT_VS)||0, midMV = parseFloat(d.OTD_2PT_MADE_VS)||0, threeAV = parseFloat(d.OTD_3PT_ATT_VS)||0, threeMV = parseFloat(d.OTD_3PT_MADE_VS)||0;
                    const secChance = parseFloat(d['2ND_CHANCE_PTS'])||0, fastBreak = parseFloat(d.FAST_BREAK_PTS)||0, ptsOffTov = parseFloat(d.PTS_OFF_TOV)||0;
                    const secChanceV = parseFloat(d['2ND_CHANCE_PTS_VS'])||0, fastBreakV = parseFloat(d.FAST_BREAK_PTS_VS)||0, ptsOffTovV = parseFloat(d.PTS_OFF_TOV_VS)||0;
                    const pts = 2 * fgm + tpm + ftm, ptsV = 2 * fgmV + tpmV + ftmV;
                    return { ...a, time: a.time + d.TIME, poss: a.poss + d.POSS, possV: a.possV + d.POSS_VS, fgm: a.fgm + fgm, fga: a.fga + fga, tpm: a.tpm + tpm, tpa: a.tpa + tpa, fta: a.fta + fta, ftm: a.ftm + ftm, oreb: a.oreb + oreb, dreb: a.dreb + dreb, tov: a.tov + tov, ast: a.ast + ast, stl: a.stl + stl, blk: a.blk + blk, fgmV: a.fgmV + fgmV, fgaV: a.fgaV + fgaV, tpmV: a.tpmV + tpmV, tpaV: a.tpaV + tpaV, ftaV: a.ftaV + ftaV, ftmV: a.ftmV + ftmV, orebV: a.orebV + orebV, drebV: a.drebV + drebV, tovV: a.tovV + tovV, astV: a.astV + astV, stlV: a.stlV + stlV, blkV: a.blkV + blkV, combP: a.combP + d.COMB_POSS, wPaceF: a.wPaceF + d.PACE_F * d.TIME, wPaceV: a.wPaceV + d.PACE_V * d.TIME, rimA: a.rimA + rimA, rimM: a.rimM + rimM, midA: a.midA + midA, midM: a.midM + midM, threeA: a.threeA + threeA, threeM: a.threeM + threeM, rimAV: a.rimAV + rimAV, rimMV: a.rimMV + rimMV, midAV: a.midAV + midAV, midMV: a.midMV + midMV, threeAV: a.threeAV + threeAV, threeMV: a.threeMV + threeMV, secChance: a.secChance + secChance, fastBreak: a.fastBreak + fastBreak, ptsOffTov: a.ptsOffTov + ptsOffTov, secChanceV: a.secChanceV + secChanceV, fastBreakV: a.fastBreakV + fastBreakV, ptsOffTovV: a.ptsOffTovV + ptsOffTovV, pts: a.pts + pts, ptsV: a.ptsV + ptsV };
                }, { time: 0, poss: 0, possV: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, tov: 0, ast: 0, stl: 0, blk: 0, fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftaV: 0, ftmV: 0, orebV: 0, drebV: 0, tovV: 0, astV: 0, stlV: 0, blkV: 0, combP: 0, wPaceF: 0, wPaceV: 0, rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0, rimAV: 0, rimMV: 0, midAV: 0, midMV: 0, threeAV: 0, threeMV: 0, secChance: 0, fastBreak: 0, ptsOffTov: 0, secChanceV: 0, fastBreakV: 0, ptsOffTovV: 0, pts: 0, ptsV: 0 });
                // V4.2.3: Calculate ratings from aggregated totals
                const teamPts = 2 * t.fgm + t.tpm + t.ftm;
                const teamPtsV = 2 * t.fgmV + t.tpmV + t.ftmV;
                const off = t.poss > 0 ? (teamPts / t.poss) * 100 : 0;
                const def = t.possV > 0 ? (teamPtsV / t.possV) * 100 : 0;
                // Calculate transition and misc stats for team average
                const secChance100 = t.poss > 0 ? (t.secChance / t.poss) * 100 : 0;
                const ptsOffTov100 = t.poss > 0 ? (t.ptsOffTov / t.poss) * 100 : 0;
                const secChance100V = t.possV > 0 ? (t.secChanceV / t.possV) * 100 : 0;
                const ptsOffTov100V = t.possV > 0 ? (t.ptsOffTovV / t.possV) * 100 : 0;
                const fastBreak100 = t.poss > 0 ? (t.fastBreak / t.poss) * 100 : 0;
                const fastBreak100V = t.possV > 0 ? (t.fastBreakV / t.possV) * 100 : 0;
                const transPct = t.pts > 0 ? (t.fastBreak / t.pts) * 100 : 0;
                const transPctV = t.ptsV > 0 ? (t.fastBreakV / t.ptsV) * 100 : 0;
                // V4.9.8.7.31 FIX: Use Basketball Reference TOV% formula for consistency
                const offTovDenom = t.fga + 0.44 * t.fta + t.tov;
                const defTovDenom = t.fgaV + 0.44 * t.ftaV + t.tovV;
                return {
                    net: off - def, off, def,
                    paceF: t.time > 0 ? t.wPaceF / t.time : 0, paceV: t.time > 0 ? t.wPaceV / t.time : 0,
                    offEfg: t.fga > 0 ? ((t.fgm + 0.5*t.tpm)/t.fga)*100 : 0, offTov: offTovDenom > 0 ? (t.tov/offTovDenom)*100 : 0,
                    offOreb: (t.oreb+t.drebV) > 0 ? (t.oreb/(t.oreb+t.drebV))*100 : 0, offFtR: t.fga > 0 ? (t.fta/t.fga)*100 : 0,
                    defEfg: t.fgaV > 0 ? ((t.fgmV + 0.5*t.tpmV)/t.fgaV)*100 : 0, defTov: defTovDenom > 0 ? (t.tovV/defTovDenom)*100 : 0,
                    defOreb: (t.orebV+t.dreb) > 0 ? (t.orebV/(t.orebV+t.dreb))*100 : 0, defFtR: t.fgaV > 0 ? (t.ftaV/t.fgaV)*100 : 0,
                    astPct: t.fgm > 0 ? (t.ast/t.fgm)*100 : 0, stlPct: t.possV > 0 ? (t.stl/t.possV)*100 : 0, blkPct: (t.fgaV-t.tpaV) > 0 ? (t.blk/(t.fgaV-t.tpaV))*100 : 0,
                    oppAstPct: t.fgmV > 0 ? (t.astV/t.fgmV)*100 : 0, oppStlPct: t.poss > 0 ? (t.stlV/t.poss)*100 : 0, oppBlkPct: (t.fga-t.tpa) > 0 ? (t.blkV/(t.fga-t.tpa))*100 : 0,
                    rimPct: t.rimA > 0 ? (t.rimM/t.rimA)*100 : 0, midPct: t.midA > 0 ? (t.midM/t.midA)*100 : 0, threePct: t.threeA > 0 ? (t.threeM/t.threeA)*100 : 0,
                    rimPctV: t.rimAV > 0 ? (t.rimMV/t.rimAV)*100 : 0, midPctV: t.midAV > 0 ? (t.midMV/t.midAV)*100 : 0, threePctV: t.threeAV > 0 ? (t.threeMV/t.threeAV)*100 : 0,
                    // V4.9.8.7.25: Add volume stats for comparison bars
                    rimVol: t.poss > 0 ? (t.rimA/t.poss)*100 : 0, midVol: t.poss > 0 ? (t.midA/t.poss)*100 : 0, threeVol: t.poss > 0 ? (t.threeA/t.poss)*100 : 0,
                    rimVolV: t.possV > 0 ? (t.rimAV/t.possV)*100 : 0, midVolV: t.possV > 0 ? (t.midAV/t.possV)*100 : 0, threeVolV: t.possV > 0 ? (t.threeAV/t.possV)*100 : 0,
                    secChance100, ptsOffTov100, secChance100V, ptsOffTov100V, fastBreak100, fastBreak100V, transPct, transPctV
                };
            }, [allTeamLineups]);

            // Filter lineups based on player selection - NOW SORTED BY POSSESSIONS
            const filtered = useMemo(() => {
                const af = Object.values(selPlayers).filter(p => p !== ''), ae = Object.values(exPlayers).filter(p => p !== '');
                const afNorm = af.map(f => normalizePlayerName(f)), aeNorm = ae.map(x => normalizePlayerName(x));
                return allTeamLineups.filter(d => {
                    const lp = d.Lineup ? d.Lineup.split(',').map(p => p.trim()) : [];
                    const lpNorm = lp.map(p => normalizePlayerName(p));
                    if (af.length > 0 && !afNorm.every(f => lpNorm.includes(f))) return false;
                    if (ae.length > 0 && aeNorm.some(x => lpNorm.includes(x))) return false;
                    return true;
                }).sort((a, b) => b.COMB_POSS - a.COMB_POSS);
            }, [allTeamLineups, selPlayers, exPlayers]);

            // =======================================================================
            // V4.2.2: OPPONENT QUALITY FILTER SYSTEM
            // Filters matchups based on opponent lineup characteristics
            // =======================================================================
            
            // Helper to check if an opponent lineup meets all filter conditions
            const checkOppFilters = (oppStats) => {
                if (!oppStats || oppFilters.length === 0) return true;
                return oppFilters.every(f => {
                    const val = oppStats[f.stat];
                    if (val === undefined || val === null) return false;
                    return f.operator === 'gt' ? val > f.value : val < f.value;
                });
            };
            
            // Get all qualifying matchups based on opponent filters
            const oppFilteredMatchups = useMemo(() => {
                if (!matchupData.length || !filtered.length || oppFilters.length === 0) return null;
                
                const filteredNormalized = new Set(filtered.map(d => d.normalizedLineup));
                const qualifyingMatchups = [];
                
                matchupData.forEach(m => {
                    // V4.2.3: Apply minimum possession threshold
                    const poss = parseFloat(m.Possessions) || 0;
                    if (poss < Math.max(1, minMatchupPoss)) return;
                    
                    const homeNorm = normalizeLineup(m.Home_Lineup);
                    const awayNorm = normalizeLineup(m.Away_Lineup);
                    
                    // Check if this is our lineup vs opponent
                    let ourLineupNorm = null, oppLineupNorm = null, isHome = false;
                    if (filteredNormalized.has(homeNorm) && m.Home_Team === team) {
                        ourLineupNorm = homeNorm;
                        oppLineupNorm = awayNorm;
                        isHome = true;
                    } else if (filteredNormalized.has(awayNorm) && m.Away_Team === team) {
                        ourLineupNorm = awayNorm;
                        oppLineupNorm = homeNorm;
                        isHome = false;
                    }
                    if (!ourLineupNorm || !oppLineupNorm) return;
                    
                    // Get opponent lineup stats and check filters
                    const oppStats = allLineupsMap.get(oppLineupNorm);
                    if (!checkOppFilters(oppStats)) return;
                    
                    qualifyingMatchups.push({ m, ourLineupNorm, oppLineupNorm, isHome, oppStats });
                });
                
                return qualifyingMatchups;
            }, [matchupData, filtered, oppFilters, team, allLineupsMap, minMatchupPoss]);
            
            // Calculate aggregated stats from filtered matchups
            // V4.2.3: Calculate ratings from raw totals, not CSV values
            const oppFilteredStats = useMemo(() => {
                if (!oppFilteredMatchups || oppFilteredMatchups.length === 0) return null;
                
                // Aggregate all stats from qualifying matchups
                const t = {
                    time: 0, poss: 0, possV: 0, combP: 0,
                    fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, tov: 0, ast: 0, stl: 0, blk: 0,
                    fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftmV: 0, ftaV: 0, orebV: 0, drebV: 0, tovV: 0, astV: 0, stlV: 0, blkV: 0,
                    wPaceF: 0, wPaceV: 0,
                    rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0,
                    rimAV: 0, rimMV: 0, midAV: 0, midMV: 0, threeAV: 0, threeMV: 0,
                    passTo: 0, dribTo: 0, defTo: 0, miscTo: 0,
                    passToV: 0, dribToV: 0, defToV: 0, miscToV: 0,
                    matchupCount: 0, oppLineupCount: new Set()
                };
                
                oppFilteredMatchups.forEach(({ m, isHome }) => {
                    // Our stats (we're either home or away)
                    const fgm = isHome ? parseFloat(m.Home_FGM)||0 : parseFloat(m.Away_FGM)||0;
                    const fga = isHome ? parseFloat(m.Home_FGA)||0 : parseFloat(m.Away_FGA)||0;
                    const tpm = isHome ? parseFloat(m['Home_3PM'])||0 : parseFloat(m['Away_3PM'])||0;
                    const tpa = isHome ? parseFloat(m['Home_3PA'])||0 : parseFloat(m['Away_3PA'])||0;
                    const ftm = isHome ? parseFloat(m.Home_FTM)||0 : parseFloat(m.Away_FTM)||0;
                    const fta = isHome ? parseFloat(m.Home_FTA)||0 : parseFloat(m.Away_FTA)||0;
                    const oreb = isHome ? parseFloat(m.Home_OREB)||0 : parseFloat(m.Away_OREB)||0;
                    const dreb = isHome ? parseFloat(m.Home_DREB)||0 : parseFloat(m.Away_DREB)||0;
                    const tov = isHome ? parseFloat(m.Home_TOV)||0 : parseFloat(m.Away_TOV)||0;
                    const ast = isHome ? parseFloat(m.Home_AST)||0 : parseFloat(m.Away_AST)||0;
                    const stl = isHome ? parseFloat(m.Home_STL)||0 : parseFloat(m.Away_STL)||0;
                    const blk = isHome ? parseFloat(m.Home_BLK)||0 : parseFloat(m.Away_BLK)||0;
                    
                    // Opponent stats
                    const fgmV = isHome ? parseFloat(m.Away_FGM)||0 : parseFloat(m.Home_FGM)||0;
                    const fgaV = isHome ? parseFloat(m.Away_FGA)||0 : parseFloat(m.Home_FGA)||0;
                    const tpmV = isHome ? parseFloat(m['Away_3PM'])||0 : parseFloat(m['Home_3PM'])||0;
                    const tpaV = isHome ? parseFloat(m['Away_3PA'])||0 : parseFloat(m['Home_3PA'])||0;
                    const ftmV = isHome ? parseFloat(m.Away_FTM)||0 : parseFloat(m.Home_FTM)||0;
                    const ftaV = isHome ? parseFloat(m.Away_FTA)||0 : parseFloat(m.Home_FTA)||0;
                    const orebV = isHome ? parseFloat(m.Away_OREB)||0 : parseFloat(m.Home_OREB)||0;
                    const drebV = isHome ? parseFloat(m.Away_DREB)||0 : parseFloat(m.Home_DREB)||0;
                    const tovV = isHome ? parseFloat(m.Away_TOV)||0 : parseFloat(m.Home_TOV)||0;
                    const astV = isHome ? parseFloat(m.Away_AST)||0 : parseFloat(m.Home_AST)||0;
                    const stlV = isHome ? parseFloat(m.Away_STL)||0 : parseFloat(m.Home_STL)||0;
                    const blkV = isHome ? parseFloat(m.Away_BLK)||0 : parseFloat(m.Home_BLK)||0;
                    
                    // Calculate possessions
                    const poss = calcPoss(fga, oreb, tov, fta);
                    const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                    const combPoss = poss + possV;
                    
                    // Accumulate raw totals (V4.2.3: no longer using CSV ratings)
                    t.poss += poss; t.possV += possV; t.combP += combPoss;
                    t.fgm += fgm; t.fga += fga; t.tpm += tpm; t.tpa += tpa; t.ftm += ftm; t.fta += fta;
                    t.oreb += oreb; t.dreb += dreb; t.tov += tov; t.ast += ast; t.stl += stl; t.blk += blk;
                    t.fgmV += fgmV; t.fgaV += fgaV; t.tpmV += tpmV; t.tpaV += tpaV; t.ftmV += ftmV; t.ftaV += ftaV;
                    t.orebV += orebV; t.drebV += drebV; t.tovV += tovV; t.astV += astV; t.stlV += stlV; t.blkV += blkV;
                    t.matchupCount++;
                });
                
                if (t.combP === 0) return null;
                
                // V4.2.3: Apply Bayesian shrinkage to totals BEFORE calculating rates
                let useT = { ...t };
                let shrinkageApplied = false;
                let shrinkageFactor = 1;
                
                if (bayesianShrinkage && leagueAverages && leagueAverages.perPoss) {
                    const k = shrinkagePriorWeight;
                    const pp = leagueAverages.perPoss;
                    
                    // Add prior counts (league rate * k possessions) to observed counts
                    useT.fgm = t.fgm + pp.fgm * k;
                    useT.fga = t.fga + pp.fga * k;
                    useT.tpm = t.tpm + pp.tpm * k;
                    useT.tpa = t.tpa + pp.tpa * k;
                    useT.ftm = t.ftm + pp.ftm * k;
                    useT.fta = t.fta + pp.fta * k;
                    useT.oreb = t.oreb + pp.oreb * k;
                    useT.dreb = t.dreb + pp.dreb * k;
                    useT.tov = t.tov + pp.tov * k;
                    useT.ast = t.ast + pp.ast * k;
                    useT.stl = t.stl + pp.stl * k;
                    useT.blk = t.blk + pp.blk * k;
                    useT.poss = t.poss + k;
                    
                    useT.fgmV = t.fgmV + pp.fgmV * k;
                    useT.fgaV = t.fgaV + pp.fgaV * k;
                    useT.tpmV = t.tpmV + pp.tpmV * k;
                    useT.tpaV = t.tpaV + pp.tpaV * k;
                    useT.ftmV = t.ftmV + pp.ftmV * k;
                    useT.ftaV = t.ftaV + pp.ftaV * k;
                    useT.orebV = t.orebV + pp.orebV * k;
                    useT.drebV = t.drebV + pp.drebV * k;
                    useT.tovV = t.tovV + pp.tovV * k;
                    useT.astV = t.astV + pp.astV * k;
                    useT.stlV = t.stlV + pp.stlV * k;
                    useT.blkV = t.blkV + pp.blkV * k;
                    useT.possV = t.possV + k;
                    useT.combP = useT.poss + useT.possV;
                    
                    shrinkageApplied = true;
                    shrinkageFactor = t.poss / (t.poss + k);
                }
                
                // V4.2.3: Calculate ratings from (possibly shrunk) totals
                const pts = 2 * useT.fgm + useT.tpm + useT.ftm;
                const ptsV = 2 * useT.fgmV + useT.tpmV + useT.ftmV;
                const off = useT.poss > 0 ? (pts / useT.poss) * 100 : 0;
                const def = useT.possV > 0 ? (ptsV / useT.possV) * 100 : 0;
                const net = off - def;
                
                // Calculate derived stats from (possibly shrunk) totals
                const ts = useT.rimA + useT.midA + useT.threeA, tsV = useT.rimAV + useT.midAV + useT.threeAV;
                const tTo = useT.passTo + useT.dribTo + useT.defTo + useT.miscTo;
                const tToV = useT.passToV + useT.dribToV + useT.defToV + useT.miscToV;
                const offEfg = useT.fga > 0 ? ((useT.fgm + 0.5*useT.tpm)/useT.fga)*100 : 0;
                const offTov = useT.poss > 0 ? (useT.tov/useT.poss)*100 : 0;
                const offOreb = (useT.oreb+useT.drebV) > 0 ? (useT.oreb/(useT.oreb+useT.drebV))*100 : 0;
                const offFtR = useT.fga > 0 ? (useT.fta/useT.fga)*100 : 0;
                const defEfg = useT.fgaV > 0 ? ((useT.fgmV + 0.5*useT.tpmV)/useT.fgaV)*100 : 0;
                const defTov = useT.possV > 0 ? (useT.tovV/useT.possV)*100 : 0;
                const defOreb = (useT.orebV+useT.dreb) > 0 ? (useT.orebV/(useT.orebV+useT.dreb))*100 : 0;
                const defFtR = useT.fgaV > 0 ? (useT.ftaV/useT.fgaV)*100 : 0;
                const rimPct = useT.rimA > 0 ? (useT.rimM/useT.rimA)*100 : 0, midPct = useT.midA > 0 ? (useT.midM/useT.midA)*100 : 0, threePct = useT.threeA > 0 ? (useT.threeM/useT.threeA)*100 : 0;
                const rimPctV = useT.rimAV > 0 ? (useT.rimMV/useT.rimAV)*100 : 0, midPctV = useT.midAV > 0 ? (useT.midMV/useT.midAV)*100 : 0, threePctV = useT.threeAV > 0 ? (useT.threeMV/useT.threeAV)*100 : 0;
                const astPct = useT.fgm > 0 ? (useT.ast/useT.fgm)*100 : 0;
                const stlPct = useT.possV > 0 ? (useT.stl/useT.possV)*100 : 0;
                const blkPct = (useT.fgaV-useT.tpaV) > 0 ? (useT.blk/(useT.fgaV-useT.tpaV))*100 : 0;
                const oppAstPct = useT.fgmV > 0 ? (useT.astV/useT.fgmV)*100 : 0;
                const oppStlPct = useT.poss > 0 ? (useT.stlV/useT.poss)*100 : 0;
                const oppBlkPct = (useT.fga-useT.tpa) > 0 ? (useT.blkV/(useT.fga-useT.tpa))*100 : 0;
                const rimVol = useT.poss > 0 ? (useT.rimA / useT.poss) * 100 : 0;
                const midVol = useT.poss > 0 ? (useT.midA / useT.poss) * 100 : 0;
                const threeVol = useT.poss > 0 ? (useT.threeA / useT.poss) * 100 : 0;
                const rimVolV = useT.possV > 0 ? (useT.rimAV / useT.possV) * 100 : 0;
                const midVolV = useT.possV > 0 ? (useT.midAV / useT.possV) * 100 : 0;
                const threeVolV = useT.possV > 0 ? (useT.threeAV / useT.possV) * 100 : 0;
                
                return { 
                    ...useT, ts, tsV, tTo, tToV, 
                    net, off, def,
                    paceF: 0, paceV: 0, // Pace not available from matchup data
                    offEfg, offTov, offOreb, offFtR, defEfg, defTov, defOreb, defFtR, 
                    rimPct, midPct, threePct, rimPctV, midPctV, threePctV, 
                    rimRate: ts > 0 ? (useT.rimA/ts)*100 : 0, midRate: ts > 0 ? (useT.midA/ts)*100 : 0, threeRate: ts > 0 ? (useT.threeA/ts)*100 : 0, 
                    rimRateV: tsV > 0 ? (useT.rimAV/tsV)*100 : 0, midRateV: tsV > 0 ? (useT.midAV/tsV)*100 : 0, threeRateV: tsV > 0 ? (useT.threeAV/tsV)*100 : 0, 
                    astPct, stlPct, blkPct, oppAstPct, oppStlPct, oppBlkPct, 
                    rimVol, midVol, threeVol, rimVolV, midVolV, threeVolV,
                    isOppFiltered: true,
                    isFromMatchups: true,
                    oppFilterMatchups: t.matchupCount,
                    matchupCount: t.matchupCount,
                    rawPoss: t.poss,
                    rawPossV: t.possV,
                    shrinkageApplied,
                    shrinkageFactor
                };
            }, [oppFilteredMatchups, bayesianShrinkage, shrinkagePriorWeight, leagueAverages]);

            // =======================================================================
            // V4.3: STAT IMPACT ANALYSIS
            // Calculates which stats have the most impact on ORTG/DRTG
            // Uses correlation analysis and regression coefficients on matchup data
            // Now works with or without opponent quality filters
            // =======================================================================
            const calculateStatImpact = useCallback((targetOppTeam = null) => {
                // Get matchups to analyze - either filtered, vs specific team, or all
                let matchupsToAnalyze = [];
                const filteredNormalized = new Set(filtered.map(d => d.normalizedLineup));
                
                if (oppFilters.length > 0 && oppFilteredMatchups && oppFilteredMatchups.length > 0) {
                    // Use opponent-filtered matchups
                    matchupsToAnalyze = oppFilteredMatchups;
                } else {
                    // Get matchups for the filtered lineups (optionally vs specific team)
                    matchupData.forEach(m => {
                        const homeNorm = normalizeLineup(m.Home_Lineup);
                        const awayNorm = normalizeLineup(m.Away_Lineup);
                        const poss = parseFloat(m.Possessions) || 0;
                        if (poss < 1) return;
                        
                        let isHome = false;
                        if (filteredNormalized.has(homeNorm) && m.Home_Team === team) {
                            // If targeting specific opponent, filter
                            if (targetOppTeam && m.Away_Team !== targetOppTeam) return;
                            isHome = true;
                            matchupsToAnalyze.push({ m, isHome });
                        } else if (filteredNormalized.has(awayNorm) && m.Away_Team === team) {
                            if (targetOppTeam && m.Home_Team !== targetOppTeam) return;
                            isHome = false;
                            matchupsToAnalyze.push({ m, isHome });
                        }
                    });
                }
                
                if (matchupsToAnalyze.length < 30) {
                    setStatImpactResults({ error: 'Need at least 30 matchups for reliable analysis (found ' + matchupsToAnalyze.length + '). Statistical research shows n≥30 is required for stable correlation estimates.' });
                    setShowStatImpactModal(true);
                    return null;
                }
                
                setIsCalculatingImpact(true);
                
                // Build per-matchup stats array
                const matchupStats = matchupsToAnalyze.map(({ m, isHome }) => {
                    const fgm = isHome ? parseFloat(m.Home_FGM)||0 : parseFloat(m.Away_FGM)||0;
                    const fga = isHome ? parseFloat(m.Home_FGA)||0 : parseFloat(m.Away_FGA)||0;
                    const tpm = isHome ? parseFloat(m['Home_3PM'])||0 : parseFloat(m['Away_3PM'])||0;
                    const fta = isHome ? parseFloat(m.Home_FTA)||0 : parseFloat(m.Away_FTA)||0;
                    const ftm = isHome ? parseFloat(m.Home_FTM)||0 : parseFloat(m.Away_FTM)||0;
                    const oreb = isHome ? parseFloat(m.Home_OREB)||0 : parseFloat(m.Away_OREB)||0;
                    const dreb = isHome ? parseFloat(m.Home_DREB)||0 : parseFloat(m.Away_DREB)||0;
                    const tov = isHome ? parseFloat(m.Home_TOV)||0 : parseFloat(m.Away_TOV)||0;
                    const ast = isHome ? parseFloat(m.Home_AST)||0 : parseFloat(m.Away_AST)||0;
                    const stl = isHome ? parseFloat(m.Home_STL)||0 : parseFloat(m.Away_STL)||0;
                    const blk = isHome ? parseFloat(m.Home_BLK)||0 : parseFloat(m.Away_BLK)||0;
                    
                    const fgmV = isHome ? parseFloat(m.Away_FGM)||0 : parseFloat(m.Home_FGM)||0;
                    const fgaV = isHome ? parseFloat(m.Away_FGA)||0 : parseFloat(m.Home_FGA)||0;
                    const tpmV = isHome ? parseFloat(m['Away_3PM'])||0 : parseFloat(m['Home_3PM'])||0;
                    const ftaV = isHome ? parseFloat(m.Away_FTA)||0 : parseFloat(m.Home_FTA)||0;
                    const ftmV = isHome ? parseFloat(m.Away_FTM)||0 : parseFloat(m.Home_FTM)||0;
                    const orebV = isHome ? parseFloat(m.Away_OREB)||0 : parseFloat(m.Home_OREB)||0;
                    const drebV = isHome ? parseFloat(m.Away_DREB)||0 : parseFloat(m.Home_DREB)||0;
                    const tovV = isHome ? parseFloat(m.Away_TOV)||0 : parseFloat(m.Home_TOV)||0;
                    const astV = isHome ? parseFloat(m.Away_AST)||0 : parseFloat(m.Home_AST)||0;
                    
                    const poss = calcPoss(fga, oreb, tov, fta);
                    const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                    const pts = 2 * fgm + tpm + ftm;
                    const ptsV = 2 * fgmV + tpmV + ftmV;
                    
                    const offRtg = poss > 0 ? (pts / poss) * 100 : 0;
                    const defRtg = possV > 0 ? (ptsV / possV) * 100 : 0;
                    
                    // V4.6.1: Get shot distance/transition stats from matchup data OR fall back to lineup data
                    // First try matchup data columns
                    let rimA = isHome ? parseFloat(m.Home_RIM_ATT)||0 : parseFloat(m.Away_RIM_ATT)||0;
                    let rimM = isHome ? parseFloat(m.Home_RIM_MADE)||0 : parseFloat(m.Away_RIM_MADE)||0;
                    let midA = isHome ? parseFloat(m.Home_OTD_2PT_ATT)||parseFloat(m.Home_MID_ATT)||0 : parseFloat(m.Away_OTD_2PT_ATT)||parseFloat(m.Away_MID_ATT)||0;
                    let midM = isHome ? parseFloat(m.Home_OTD_2PT_MADE)||parseFloat(m.Home_MID_MADE)||0 : parseFloat(m.Away_OTD_2PT_MADE)||parseFloat(m.Away_MID_MADE)||0;
                    const tpa = isHome ? parseFloat(m['Home_3PA'])||0 : parseFloat(m['Away_3PA'])||0;
                    
                    let rimAV = isHome ? parseFloat(m.Away_RIM_ATT)||0 : parseFloat(m.Home_RIM_ATT)||0;
                    let rimMV = isHome ? parseFloat(m.Away_RIM_MADE)||0 : parseFloat(m.Home_RIM_MADE)||0;
                    let midAV = isHome ? parseFloat(m.Away_OTD_2PT_ATT)||parseFloat(m.Away_MID_ATT)||0 : parseFloat(m.Home_OTD_2PT_ATT)||parseFloat(m.Home_MID_ATT)||0;
                    let midMV = isHome ? parseFloat(m.Away_OTD_2PT_MADE)||parseFloat(m.Away_MID_MADE)||0 : parseFloat(m.Home_OTD_2PT_MADE)||parseFloat(m.Home_MID_MADE)||0;
                    const tpaV = isHome ? parseFloat(m['Away_3PA'])||0 : parseFloat(m['Home_3PA'])||0;
                    
                    let fastBreak = isHome ? parseFloat(m.Home_FAST_BREAK_PTS)||0 : parseFloat(m.Away_FAST_BREAK_PTS)||0;
                    let ptsOffTov = isHome ? parseFloat(m.Home_PTS_OFF_TOV)||0 : parseFloat(m.Away_PTS_OFF_TOV)||0;
                    let secChance = isHome ? parseFloat(m['Home_2ND_CHANCE_PTS'])||0 : parseFloat(m['Away_2ND_CHANCE_PTS'])||0;
                    
                    let fastBreakV = isHome ? parseFloat(m.Away_FAST_BREAK_PTS)||0 : parseFloat(m.Home_FAST_BREAK_PTS)||0;
                    let ptsOffTovV = isHome ? parseFloat(m.Away_PTS_OFF_TOV)||0 : parseFloat(m.Home_PTS_OFF_TOV)||0;
                    let secChanceV = isHome ? parseFloat(m['Away_2ND_CHANCE_PTS'])||0 : parseFloat(m['Home_2ND_CHANCE_PTS'])||0;
                    
                    // If matchup data doesn't have extended stats, look up from lineup data
                    // Scale lineup totals to this matchup's possessions
                    if (rimA === 0 && rimM === 0 && lineupData.length > 0) {
                        const myLineup = isHome ? m.Home_Lineup : m.Away_Lineup;
                        const oppLineup = isHome ? m.Away_Lineup : m.Home_Lineup;
                        const myNorm = normalizeLineup(myLineup);
                        const oppNorm = normalizeLineup(oppLineup);
                        
                        // Find my lineup in lineupData
                        const myLD = lineupData.find(d => normalizeLineup(d.Lineup) === myNorm);
                        if (myLD) {
                            const ldPoss = calcPoss(parseFloat(myLD.FGA)||0, parseFloat(myLD.OREB)||0, parseFloat(myLD.TOV)||0, parseFloat(myLD.FTA)||0);
                            const ldPossV = calcPoss(parseFloat(myLD.FGA_VS)||0, parseFloat(myLD.OREB_VS)||0, parseFloat(myLD.TOV_VS)||0, parseFloat(myLD.FTA_VS)||0);
                            
                            // Scale to this matchup's possessions
                            if (ldPoss > 0) {
                                const scale = poss / ldPoss;
                                rimA = (parseFloat(myLD.RIM_ATT)||0) * scale;
                                rimM = (parseFloat(myLD.RIM_MADE)||0) * scale;
                                midA = (parseFloat(myLD.OTD_2PT_ATT)||0) * scale;
                                midM = (parseFloat(myLD.OTD_2PT_MADE)||0) * scale;
                                fastBreak = (parseFloat(myLD.FAST_BREAK_PTS)||0) * scale;
                                ptsOffTov = (parseFloat(myLD.PTS_OFF_TOV)||0) * scale;
                                secChance = (parseFloat(myLD['2ND_CHANCE_PTS'])||0) * scale;
                            }
                            if (ldPossV > 0) {
                                const scaleV = possV / ldPossV;
                                rimAV = (parseFloat(myLD.RIM_ATT_VS)||0) * scaleV;
                                rimMV = (parseFloat(myLD.RIM_MADE_VS)||0) * scaleV;
                                midAV = (parseFloat(myLD.OTD_2PT_ATT_VS)||0) * scaleV;
                                midMV = (parseFloat(myLD.OTD_2PT_MADE_VS)||0) * scaleV;
                                fastBreakV = (parseFloat(myLD.FAST_BREAK_PTS_VS)||0) * scaleV;
                                ptsOffTovV = (parseFloat(myLD.PTS_OFF_TOV_VS)||0) * scaleV;
                                secChanceV = (parseFloat(myLD['2ND_CHANCE_PTS_VS'])||0) * scaleV;
                            }
                        }
                    }
                    
                    // Calculate Four Factors and extended stats for this matchup
                    return {
                        poss, possV,
                        offRtg, defRtg,
                        // Offensive stats - Four Factors
                        offEfg: fga > 0 ? ((fgm + 0.5*tpm)/fga)*100 : 0,
                        offTov: poss > 0 ? (tov/poss)*100 : 0,
                        offOreb: (oreb+drebV) > 0 ? (oreb/(oreb+drebV))*100 : 0,
                        offFtR: fga > 0 ? (fta/fga)*100 : 0,
                        offAstPct: fgm > 0 ? (ast/fgm)*100 : 0,
                        off3Pct: fga > 0 ? (tpm/fga)*100 : 0,
                        // Shot distance stats - offensive
                        rimPct: rimA > 0 ? (rimM/rimA)*100 : 0,
                        rimAtt100: poss > 0 ? (rimA/poss)*100 : 0,
                        midPct: midA > 0 ? (midM/midA)*100 : 0,
                        midAtt100: poss > 0 ? (midA/poss)*100 : 0,
                        threePct: tpa > 0 ? (tpm/tpa)*100 : 0,
                        threeAtt100: poss > 0 ? (tpa/poss)*100 : 0,
                        // Transition stats - offensive
                        fastBreak100: poss > 0 ? (fastBreak/poss)*100 : 0,
                        ptsOffTov100: poss > 0 ? (ptsOffTov/poss)*100 : 0,
                        secChance100: poss > 0 ? (secChance/poss)*100 : 0,
                        // Defensive stats
                        defEfg: fgaV > 0 ? ((fgmV + 0.5*tpmV)/fgaV)*100 : 0,
                        defTov: possV > 0 ? (tovV/possV)*100 : 0,
                        defOreb: (orebV+dreb) > 0 ? (orebV/(orebV+dreb))*100 : 0,
                        defFtR: fgaV > 0 ? (ftaV/fgaV)*100 : 0,
                        stlPct: possV > 0 ? (stl/possV)*100 : 0,
                        blkPct: (fgaV-fgaV*0.35) > 0 ? (blk/(fgaV*0.65))*100 : 0,
                        // Shot distance stats - defensive (opponent)
                        rimPctV: rimAV > 0 ? (rimMV/rimAV)*100 : 0,
                        rimAtt100V: possV > 0 ? (rimAV/possV)*100 : 0,
                        midPctV: midAV > 0 ? (midMV/midAV)*100 : 0,
                        midAtt100V: possV > 0 ? (midAV/possV)*100 : 0,
                        threePctV: tpaV > 0 ? (tpmV/tpaV)*100 : 0,
                        threeAtt100V: possV > 0 ? (tpaV/possV)*100 : 0,
                        // Transition stats - defensive (allowed)
                        fastBreak100V: possV > 0 ? (fastBreakV/possV)*100 : 0,
                        ptsOffTov100V: possV > 0 ? (ptsOffTovV/possV)*100 : 0,
                        secChance100V: possV > 0 ? (secChanceV/possV)*100 : 0
                    };
                }).filter(s => s.poss >= 2 && s.possV >= 2); // Minimum 2 possessions each
                
                if (matchupStats.length < 30) {
                    setStatImpactResults({ error: 'Insufficient valid matchups after filtering (need 30+, found ' + matchupStats.length + ')' });
                    setIsCalculatingImpact(false);
                    return;
                }
                
                // =======================================================================
                // V5.0: MULTIPLE REGRESSION + DOMINANCE ANALYSIS
                // Fixes omitted variable bias from bivariate correlations
                // Uses Budescu (1993) dominance analysis for proper variance decomposition
                // =======================================================================
                
                // Matrix operations for multiple regression
                const matrixOps = {
                    // Transpose matrix
                    transpose: (m) => m[0].map((_, i) => m.map(row => row[i])),
                    
                    // Matrix multiplication
                    multiply: (a, b) => {
                        const result = [];
                        for (let i = 0; i < a.length; i++) {
                            result[i] = [];
                            for (let j = 0; j < b[0].length; j++) {
                                let sum = 0;
                                for (let k = 0; k < a[0].length; k++) {
                                    sum += a[i][k] * b[k][j];
                                }
                                result[i][j] = sum;
                            }
                        }
                        return result;
                    },
                    
                    // Matrix-vector multiplication
                    multiplyVector: (m, v) => m.map(row => row.reduce((sum, val, i) => sum + val * v[i], 0)),
                    
                    // Solve linear system using Cholesky decomposition with ridge regularization
                    solveRidge: (XtX, Xty, lambda) => {
                        const n = XtX.length;
                        // Add ridge penalty to diagonal
                        const A = XtX.map((row, i) => row.map((val, j) => i === j ? val + lambda : val));
                        
                        // Cholesky decomposition: A = LL'
                        const L = Array(n).fill(null).map(() => Array(n).fill(0));
                        for (let i = 0; i < n; i++) {
                            for (let j = 0; j <= i; j++) {
                                let sum = 0;
                                for (let k = 0; k < j; k++) {
                                    sum += L[i][k] * L[j][k];
                                }
                                if (i === j) {
                                    L[i][j] = Math.sqrt(Math.max(0.0001, A[i][i] - sum));
                                } else {
                                    L[i][j] = (A[i][j] - sum) / (L[j][j] || 0.0001);
                                }
                            }
                        }
                        
                        // Forward substitution: Ly = Xty
                        const y = Array(n).fill(0);
                        for (let i = 0; i < n; i++) {
                            let sum = Xty[i];
                            for (let j = 0; j < i; j++) {
                                sum -= L[i][j] * y[j];
                            }
                            y[i] = sum / (L[i][i] || 0.0001);
                        }
                        
                        // Back substitution: L'x = y
                        const x = Array(n).fill(0);
                        for (let i = n - 1; i >= 0; i--) {
                            let sum = y[i];
                            for (let j = i + 1; j < n; j++) {
                                sum -= L[j][i] * x[j];
                            }
                            x[i] = sum / (L[i][i] || 0.0001);
                        }
                        
                        return x;
                    }
                };
                
                // Calculate R² for a given set of predictors
                const calcR2 = (predictorKeys, data, yKey) => {
                    if (predictorKeys.length === 0) return 0;
                    
                    const n = data.length;
                    const k = predictorKeys.length;
                    
                    // Build X matrix and y vector
                    const X = data.map(d => predictorKeys.map(key => d[key]));
                    const y = data.map(d => d[yKey]);
                    
                    // Center y
                    const yMean = y.reduce((a, b) => a + b, 0) / n;
                    const yC = y.map(v => v - yMean);
                    
                    // Standardize X (z-scores)
                    const means = predictorKeys.map((_, j) => X.reduce((sum, row) => sum + row[j], 0) / n);
                    const stds = predictorKeys.map((_, j) => {
                        const mean = means[j];
                        const variance = X.reduce((sum, row) => sum + (row[j] - mean) ** 2, 0) / n;
                        return Math.sqrt(variance) || 1;
                    });
                    const Xs = X.map(row => row.map((val, j) => (val - means[j]) / stds[j]));
                    
                    // Compute X'X and X'y
                    const Xt = matrixOps.transpose(Xs);
                    const XtX = matrixOps.multiply(Xt, Xs);
                    const Xty = matrixOps.multiplyVector(Xt, yC);
                    
                    // Solve with small ridge penalty for numerical stability
                    const beta = matrixOps.solveRidge(XtX, Xty, 0.001);
                    
                    // Compute predictions and R²
                    const yPred = Xs.map(row => row.reduce((sum, val, j) => sum + val * beta[j], 0));
                    const ssRes = yPred.reduce((sum, pred, i) => sum + (yC[i] - pred) ** 2, 0);
                    const ssTot = yC.reduce((sum, val) => sum + val ** 2, 0);
                    
                    return ssTot > 0 ? Math.max(0, 1 - ssRes / ssTot) : 0;
                };
                
                // Dominance Analysis: Calculate average marginal contribution across all subsets
                // Based on Budescu (1993) - "Dominance Analysis: A New Approach to the Problem 
                // of Relative Importance of Predictors in Multiple Regression"
                const calcDominanceAnalysis = (statKeys, data, yKey) => {
                    const k = statKeys.length;
                    
                    // For computational efficiency with many predictors, use incremental R² approach
                    // which is equivalent to dominance analysis for the "general dominance" measure
                    
                    // Calculate full model R²
                    const fullR2 = calcR2(statKeys, data, yKey);
                    
                    // Calculate contribution for each predictor
                    const contributions = {};
                    const partialR2 = {};
                    
                    statKeys.forEach(key => {
                        // R² without this predictor
                        const otherKeys = statKeys.filter(k => k !== key);
                        const r2Without = otherKeys.length > 0 ? calcR2(otherKeys, data, yKey) : 0;
                        
                        // R² with only this predictor
                        const r2Alone = calcR2([key], data, yKey);
                        
                        // General dominance: average of unique contribution (what it adds to full model)
                        // and individual contribution (what it explains alone)
                        const uniqueContribution = fullR2 - r2Without;
                        const individualContribution = r2Alone;
                        
                        // Weight: 50% unique, 50% individual (simplified dominance)
                        contributions[key] = (uniqueContribution + individualContribution) / 2;
                        
                        // Partial R² (unique variance explained controlling for others)
                        partialR2[key] = uniqueContribution;
                    });
                    
                    // Normalize to percentages of explained variance
                    const totalContribution = Object.values(contributions).reduce((a, b) => a + b, 0);
                    const dominancePercent = {};
                    statKeys.forEach(key => {
                        dominancePercent[key] = totalContribution > 0 ? (contributions[key] / totalContribution) * 100 : 0;
                    });
                    
                    return { fullR2, contributions, partialR2, dominancePercent };
                };
                
                // Calculate standardized regression coefficients (beta weights)
                const calcMultipleRegression = (statKeys, data, yKey) => {
                    const n = data.length;
                    const k = statKeys.length;
                    
                    // Build X matrix and y vector
                    const X = data.map(d => statKeys.map(key => d[key]));
                    const y = data.map(d => d[yKey]);
                    
                    // Calculate means and stds
                    const yMean = y.reduce((a, b) => a + b, 0) / n;
                    const yStd = Math.sqrt(y.reduce((sum, v) => sum + (v - yMean) ** 2, 0) / n) || 1;
                    
                    const stats = {};
                    statKeys.forEach((key, j) => {
                        const vals = X.map(row => row[j]);
                        const mean = vals.reduce((a, b) => a + b, 0) / n;
                        const std = Math.sqrt(vals.reduce((sum, v) => sum + (v - mean) ** 2, 0) / n) || 1;
                        stats[key] = { mean, std };
                    });
                    
                    // Standardize X
                    const Xs = X.map(row => row.map((val, j) => (val - stats[statKeys[j]].mean) / stats[statKeys[j]].std));
                    const yC = y.map(v => (v - yMean) / yStd);
                    
                    // Compute X'X and X'y
                    const Xt = matrixOps.transpose(Xs);
                    const XtX = matrixOps.multiply(Xt, Xs);
                    const Xty = matrixOps.multiplyVector(Xt, yC);
                    
                    // Solve with small ridge penalty
                    const betaStd = matrixOps.solveRidge(XtX, Xty, 0.01);
                    
                    // Convert to unstandardized coefficients
                    const betaUnstd = {};
                    statKeys.forEach((key, j) => {
                        betaUnstd[key] = betaStd[j] * yStd / stats[key].std;
                    });
                    
                    // Calculate confidence intervals using Fisher z-transformation approximation
                    // SE(beta) ≈ 1 / sqrt(n - k - 1) for standardized coefficients
                    const seBeta = 1 / Math.sqrt(Math.max(1, n - k - 1));
                    const t975 = 1.96; // 95% CI
                    
                    const results = {};
                    statKeys.forEach((key, j) => {
                        results[key] = {
                            betaStd: betaStd[j],
                            betaUnstd: betaUnstd[key],
                            mean: stats[key].mean,
                            std: stats[key].std,
                            ciLow: betaStd[j] - t975 * seBeta,
                            ciHigh: betaStd[j] + t975 * seBeta
                        };
                    });
                    
                    return results;
                };
                
                // Bivariate correlation (still useful for reference)
                const calcCorrelation = (xArr, yArr) => {
                    const n = xArr.length;
                    if (n < 3) return { r: 0, slope: 0, intercept: 0 };
                    
                    const meanX = xArr.reduce((a, b) => a + b, 0) / n;
                    const meanY = yArr.reduce((a, b) => a + b, 0) / n;
                    
                    let ssXY = 0, ssXX = 0, ssYY = 0;
                    for (let i = 0; i < n; i++) {
                        const dx = xArr[i] - meanX;
                        const dy = yArr[i] - meanY;
                        ssXY += dx * dy;
                        ssXX += dx * dx;
                        ssYY += dy * dy;
                    }
                    
                    const r = (ssXX > 0 && ssYY > 0) ? ssXY / Math.sqrt(ssXX * ssYY) : 0;
                    const slope = ssXX > 0 ? ssXY / ssXX : 0;
                    const intercept = meanY - slope * meanX;
                    const stdX = Math.sqrt(ssXX / n);
                    const stdY = Math.sqrt(ssYY / n);
                    
                    // Confidence interval for r using Fisher z-transformation
                    const z = 0.5 * Math.log((1 + r) / (1 - r + 0.0001));
                    const seZ = 1 / Math.sqrt(n - 3);
                    const zLow = z - 1.96 * seZ;
                    const zHigh = z + 1.96 * seZ;
                    const rCiLow = (Math.exp(2 * zLow) - 1) / (Math.exp(2 * zLow) + 1);
                    const rCiHigh = (Math.exp(2 * zHigh) - 1) / (Math.exp(2 * zHigh) + 1);
                    
                    return { r, slope, intercept, meanX, meanY, stdX, stdY, rCiLow, rCiHigh };
                };
                
                const offRtgArr = matchupStats.map(s => s.offRtg);
                const defRtgArr = matchupStats.map(s => s.defRtg);
                
                // V5.0: UPDATED STATS - Removed redundant transition stats that overlap with Four Factors
                // Pts Off TO overlaps heavily with opponent TOV% (same event, different angle)
                // 2nd Chance Pts overlaps heavily with OREB% (same event, different angle)
                // Fast Break Pts is retained as it captures a distinct style dimension
                const offensiveStats = [
                    // Four Factors (primary - well-validated)
                    { key: 'offEfg', name: 'eFG%', description: 'Effective Field Goal % (FTA/FGA definition)', higherBetter: true, isFourFactor: true },
                    { key: 'offTov', name: 'TOV%', description: 'Turnover Rate per possession', higherBetter: false, isFourFactor: true },
                    { key: 'offOreb', name: 'OREB%', description: 'Offensive Rebound % of available', higherBetter: true, isFourFactor: true },
                    { key: 'offFtR', name: 'FT Rate', description: 'Free Throw Rate (FTA/FGA)', higherBetter: true, isFourFactor: true },
                    // Secondary stats
                    { key: 'offAstPct', name: 'AST%', description: 'Assist Rate on made FGs', higherBetter: true },
                    { key: 'off3Pct', name: '3P/FGA', description: '3PT Made per FGA', higherBetter: true },
                    // Shot location diagnostics
                    { key: 'rimPct', name: 'Rim %', description: 'Rim FG% (at basket)', higherBetter: true },
                    { key: 'rimAtt100', name: 'Rim Att/100', description: 'Rim Attempts per 100 poss', higherBetter: true },
                    { key: 'midPct', name: 'Mid %', description: 'Mid-Range FG%', higherBetter: true },
                    { key: 'midAtt100', name: 'Mid Att/100', description: 'Mid-Range Attempts per 100 poss', higherBetter: false },
                    { key: 'threePct', name: '3PT %', description: '3-Point FG%', higherBetter: true },
                    { key: 'threeAtt100', name: '3PT Att/100', description: '3PT Attempts per 100 poss', higherBetter: true },
                    // Transition (distinct style dimension - not redundant)
                    { key: 'fastBreak100', name: 'FB Pts/100', description: 'Fast Break Points per 100 poss', higherBetter: true },
                ];
                
                const defensiveStats = [
                    // Four Factors (primary)
                    { key: 'defEfg', name: 'Opp eFG%', description: 'Opponent eFG% (lower = better)', higherBetter: false, isFourFactor: true },
                    { key: 'defTov', name: 'Forced TOV%', description: 'Forced Turnover Rate', higherBetter: true, isFourFactor: true },
                    { key: 'defOreb', name: 'Opp OREB%', description: 'Opponent OREB% (lower = better)', higherBetter: false, isFourFactor: true },
                    { key: 'defFtR', name: 'Opp FT Rate', description: 'Opponent FT Rate (lower = better)', higherBetter: false, isFourFactor: true },
                    // Secondary stats
                    { key: 'stlPct', name: 'STL%', description: 'Steal Rate per opp possession', higherBetter: true },
                    { key: 'blkPct', name: 'BLK%', description: 'Block Rate', higherBetter: true },
                    // Shot location defense
                    { key: 'rimPctV', name: 'Opp Rim %', description: 'Opponent Rim FG% (lower = better)', higherBetter: false },
                    { key: 'rimAtt100V', name: 'Opp Rim Att/100', description: 'Opp Rim Attempts per 100 (lower = better)', higherBetter: false },
                    { key: 'midPctV', name: 'Opp Mid %', description: 'Opponent Mid-Range FG%', higherBetter: false },
                    { key: 'midAtt100V', name: 'Opp Mid Att/100', description: 'Opp Mid-Range Attempts per 100', higherBetter: true },
                    { key: 'threePctV', name: 'Opp 3PT %', description: 'Opponent 3PT FG% (lower = better)', higherBetter: false },
                    { key: 'threeAtt100V', name: 'Opp 3PT Att/100', description: 'Opp 3PT Attempts per 100 (lower = better)', higherBetter: false },
                    // Transition defense (distinct dimension)
                    { key: 'fastBreak100V', name: 'Opp FB/100', description: 'Opponent Fast Break Pts per 100 (lower = better)', higherBetter: false },
                ];
                
                // Run dominance analysis for Four Factors
                const offFourFactorKeys = offensiveStats.filter(s => s.isFourFactor).map(s => s.key);
                const defFourFactorKeys = defensiveStats.filter(s => s.isFourFactor).map(s => s.key);
                
                const offDominance = calcDominanceAnalysis(offFourFactorKeys, matchupStats, 'offRtg');
                const defDominance = calcDominanceAnalysis(defFourFactorKeys, matchupStats, 'defRtg');
                
                // Get multiple regression coefficients
                const offRegression = calcMultipleRegression(offFourFactorKeys, matchupStats, 'offRtg');
                const defRegression = calcMultipleRegression(defFourFactorKeys, matchupStats, 'defRtg');
                
                // Calculate impact for all offensive stats (with dominance for Four Factors)
                const offenseImpacts = offensiveStats.map(stat => {
                    const statArr = matchupStats.map(s => s[stat.key]);
                    const bivariate = calcCorrelation(statArr, offRtgArr);
                    
                    // Get dominance/regression results for Four Factors
                    const dominancePct = stat.isFourFactor ? offDominance.dominancePercent[stat.key] : null;
                    const partialR2 = stat.isFourFactor ? offDominance.partialR2[stat.key] : null;
                    const regression = stat.isFourFactor ? offRegression[stat.key] : null;
                    
                    return {
                        ...stat,
                        // Bivariate (for reference, marked as potentially biased)
                        correlation: bivariate.r,
                        correlationCiLow: bivariate.rCiLow,
                        correlationCiHigh: bivariate.rCiHigh,
                        slope: bivariate.slope,
                        mean: bivariate.meanX,
                        std: bivariate.stdX,
                        // Dominance Analysis results (unbiased importance)
                        dominancePct: dominancePct,
                        partialR2: partialR2,
                        // Multiple regression results (unbiased coefficients)
                        betaStd: regression ? regression.betaStd : null,
                        betaCiLow: regression ? regression.ciLow : null,
                        betaCiHigh: regression ? regression.ciHigh : null,
                        // Expected values
                        lowValue: bivariate.meanX - bivariate.stdX,
                        highValue: bivariate.meanX + bivariate.stdX,
                        ortgAtLow: bivariate.intercept + bivariate.slope * (bivariate.meanX - bivariate.stdX),
                        ortgAtHigh: bivariate.intercept + bivariate.slope * (bivariate.meanX + bivariate.stdX),
                        ortgDelta: bivariate.slope * 2 * bivariate.stdX
                    };
                }).sort((a, b) => {
                    // Sort Four Factors by dominance %, others by correlation
                    if (a.isFourFactor && b.isFourFactor) {
                        return (b.dominancePct || 0) - (a.dominancePct || 0);
                    }
                    if (a.isFourFactor) return -1;
                    if (b.isFourFactor) return 1;
                    return Math.abs(b.correlation) - Math.abs(a.correlation);
                });
                
                // Calculate impact for defensive stats
                const defenseImpacts = defensiveStats.map(stat => {
                    const statArr = matchupStats.map(s => s[stat.key]);
                    const bivariate = calcCorrelation(statArr, defRtgArr);
                    
                    const dominancePct = stat.isFourFactor ? defDominance.dominancePercent[stat.key] : null;
                    const partialR2 = stat.isFourFactor ? defDominance.partialR2[stat.key] : null;
                    const regression = stat.isFourFactor ? defRegression[stat.key] : null;
                    
                    return {
                        ...stat,
                        correlation: bivariate.r,
                        correlationCiLow: bivariate.rCiLow,
                        correlationCiHigh: bivariate.rCiHigh,
                        slope: bivariate.slope,
                        mean: bivariate.meanX,
                        std: bivariate.stdX,
                        dominancePct: dominancePct,
                        partialR2: partialR2,
                        betaStd: regression ? regression.betaStd : null,
                        betaCiLow: regression ? regression.ciLow : null,
                        betaCiHigh: regression ? regression.ciHigh : null,
                        lowValue: bivariate.meanX - bivariate.stdX,
                        highValue: bivariate.meanX + bivariate.stdX,
                        drtgAtLow: bivariate.intercept + bivariate.slope * (bivariate.meanX - bivariate.stdX),
                        drtgAtHigh: bivariate.intercept + bivariate.slope * (bivariate.meanX + bivariate.stdX),
                        drtgDelta: bivariate.slope * 2 * bivariate.stdX
                    };
                }).sort((a, b) => {
                    if (a.isFourFactor && b.isFourFactor) {
                        return (b.dominancePct || 0) - (a.dominancePct || 0);
                    }
                    if (a.isFourFactor) return -1;
                    if (b.isFourFactor) return 1;
                    return Math.abs(b.correlation) - Math.abs(a.correlation);
                });
                
                // Calculate overall stats
                const avgOffRtg = offRtgArr.reduce((a,b) => a+b, 0) / offRtgArr.length;
                const avgDefRtg = defRtgArr.reduce((a,b) => a+b, 0) / defRtgArr.length;
                
                setStatImpactResults({
                    matchupCount: matchupStats.length,
                    avgOffRtg,
                    avgDefRtg,
                    avgNetRtg: avgOffRtg - avgDefRtg,
                    offenseImpacts,
                    defenseImpacts,
                    // V5.0: Add model fit statistics
                    offR2: offDominance.fullR2,
                    defR2: defDominance.fullR2,
                    methodology: 'dominance', // Flag for UI
                    targetOppTeam,
                    activeFilters: oppFilters.length > 0 ? oppFilters.map(f => {
                        const statLabels = { off: 'Off Rtg', def: 'Def Rtg', net: 'Net Rtg', offEfg: 'Off eFG%', defEfg: 'Def eFG%', offTov: 'Off TOV%', defTov: 'Def TOV%', offOreb: 'Off OREB%', defOreb: 'Def OREB%', offFtR: 'Off FTR', defFtR: 'Def FTR', paceF: 'Pace (Off)', paceV: 'Pace (Def)', astPct: 'AST%', stlPct: 'STL%', blkPct: 'BLK%', combPoss: 'Possessions' };
                        return (statLabels[f.stat] || f.stat) + ' ' + (f.operator === 'gt' ? '>' : '<') + ' ' + f.value;
                    }) : []
                });
                
                setIsCalculatingImpact(false);
                setShowStatImpactModal(true);
                
                // Return impacts for use by other functions
                return { offenseImpacts, defenseImpacts };
            }, [oppFilteredMatchups, oppFilters, filtered, matchupData, team, lineupData]);

            // V4.6.1: Player Impact Correlation - correlates player stats to lineup ORTG/DRTG
            const calculatePlayerImpactCorrelation = useCallback((filterPlayer = null) => {
                if (!playerData.length) {
                    setPlayerImpactResults({ error: 'Player lineup stats CSV not loaded' });
                    setShowPlayerImpactModal(true);
                    return;
                }
                
                // Filter to team if selected, and optionally to specific player
                let dataToAnalyze = team ? playerData.filter(d => d.Team === team) : playerData;
                if (filterPlayer) {
                    dataToAnalyze = dataToAnalyze.filter(d => d.Player === filterPlayer);
                }
                
                // Need minimum sample size
                if (dataToAnalyze.length < 10) {
                    setPlayerImpactResults({ error: 'Need at least 10 player-lineup combinations (found ' + dataToAnalyze.length + ')' });
                    setShowPlayerImpactModal(true);
                    return;
                }
                
                // Stats to correlate with lineup performance
                const statsToAnalyze = [
                    // Shooting efficiency
                    { key: 'FG%', name: 'FG%', desc: 'Field Goal Percentage' },
                    { key: '3P%', name: '3P%', desc: '3-Point Percentage' },
                    { key: 'FT%', name: 'FT%', desc: 'Free Throw Percentage' },
                    { key: 'eFG%', name: 'eFG%', desc: 'Effective FG%' },
                    { key: 'TS%', name: 'TS%', desc: 'True Shooting %' },
                    // Volume
                    { key: 'FGA', name: 'FGA', desc: 'Field Goal Attempts', perPoss: true },
                    { key: '3PA', name: '3PA', desc: '3-Point Attempts', perPoss: true },
                    { key: 'FTA', name: 'FTA', desc: 'Free Throw Attempts', perPoss: true },
                    // Box score
                    { key: 'PTS', name: 'PTS', desc: 'Points', perPoss: true },
                    { key: 'AST', name: 'AST', desc: 'Assists', perPoss: true },
                    { key: 'OREB', name: 'OREB', desc: 'Offensive Rebounds', perPoss: true },
                    { key: 'DREB', name: 'DREB', desc: 'Defensive Rebounds', perPoss: true },
                    { key: 'STL', name: 'STL', desc: 'Steals', perPoss: true },
                    { key: 'BLK', name: 'BLK', desc: 'Blocks', perPoss: true },
                    { key: 'TOV', name: 'TOV', desc: 'Turnovers', perPoss: true },
                    // Advanced
                    { key: 'AST%', name: 'AST%', desc: 'Assist Percentage' },
                    { key: 'TOV%', name: 'TOV%', desc: 'Turnover Percentage' },
                    // Shot distance
                    { key: 'RIM%', name: 'Rim%', desc: 'Rim FG%' },
                    { key: 'RIM_ATT', name: 'Rim Att', desc: 'Rim Attempts', perPoss: true },
                    { key: 'OTD_2PT%', name: 'Mid%', desc: 'Mid-Range FG%' },
                    { key: 'OTD_2PT_ATT', name: 'Mid Att', desc: 'Mid-Range Attempts', perPoss: true },
                    { key: 'OTD_3PT%', name: '3PT%', desc: '3-Point FG%' },
                    { key: 'OTD_3PT_ATT', name: '3PT Att', desc: '3-Point Attempts', perPoss: true },
                    // Turnover breakdown
                    { key: 'PASS_TO', name: 'Pass TO', desc: 'Pass Turnovers', perPoss: true },
                    { key: 'DRIBBLE_TO', name: 'Dribble TO', desc: 'Dribble Turnovers', perPoss: true },
                    { key: 'DEFENSE_TO', name: 'Forced TO', desc: 'Defense-Forced Turnovers', perPoss: true },
                    // Transition
                    { key: '2ND_CHANCE_PTS', name: '2nd Chance', desc: '2nd Chance Points', perPoss: true },
                    { key: 'FAST_BREAK_PTS', name: 'FB Pts', desc: 'Fast Break Points', perPoss: true },
                    { key: 'PTS_OFF_TOV', name: 'Pts Off TO', desc: 'Points Off Turnovers', perPoss: true },
                ];
                
                // Parse data with lineup ratings
                const parsed = dataToAnalyze.map(d => {
                    const poss = parseFloat(d.POSS) || 1;
                    const offRtg = parseFloat(d.OFF_RTG) || 0;
                    const defRtg = parseFloat(d.DEF_RTG) || 0;
                    
                    const stats = {};
                    statsToAnalyze.forEach(s => {
                        let val = parseFloat(d[s.key]) || 0;
                        // Normalize per-possession stats to per-100
                        if (s.perPoss && poss > 0) {
                            val = (val / poss) * 100;
                        }
                        stats[s.key] = val;
                    });
                    
                    return { offRtg, defRtg, netRtg: offRtg - defRtg, poss, player: d.Player, ...stats };
                }).filter(d => d.poss >= 5 && d.offRtg > 0 && d.defRtg > 0 && d.offRtg < 200 && d.defRtg < 200); // Filter outliers
                
                if (parsed.length < 10) {
                    setPlayerImpactResults({ error: 'Insufficient valid data after filtering outliers' });
                    setShowPlayerImpactModal(true);
                    return;
                }
                
                // Correlation calculation
                const calcCorr = (xArr, yArr) => {
                    const n = xArr.length;
                    if (n < 3) return { r: 0, slope: 0 };
                    const meanX = xArr.reduce((a, b) => a + b, 0) / n;
                    const meanY = yArr.reduce((a, b) => a + b, 0) / n;
                    let ssXY = 0, ssXX = 0, ssYY = 0;
                    for (let i = 0; i < n; i++) {
                        const dx = xArr[i] - meanX;
                        const dy = yArr[i] - meanY;
                        ssXY += dx * dy;
                        ssXX += dx * dx;
                        ssYY += dy * dy;
                    }
                    const r = (ssXX > 0 && ssYY > 0) ? ssXY / Math.sqrt(ssXX * ssYY) : 0;
                    const slope = ssXX > 0 ? ssXY / ssXX : 0;
                    return { r, slope, meanX, meanY };
                };
                
                const offRtgArr = parsed.map(d => d.offRtg);
                const defRtgArr = parsed.map(d => d.defRtg);
                
                // Calculate correlations for each stat
                const offenseCorrelations = statsToAnalyze.map(stat => {
                    const statArr = parsed.map(d => d[stat.key]);
                    const result = calcCorr(statArr, offRtgArr);
                    return {
                        ...stat,
                        correlation: result.r,
                        slope: result.slope,
                        mean: result.meanX,
                        // Higher correlation with ORTG = more offensive impact
                        impact: Math.abs(result.r),
                        direction: result.r > 0 ? 'positive' : 'negative'
                    };
                }).sort((a, b) => b.impact - a.impact);
                
                const defenseCorrelations = statsToAnalyze.map(stat => {
                    const statArr = parsed.map(d => d[stat.key]);
                    const result = calcCorr(statArr, defRtgArr);
                    return {
                        ...stat,
                        correlation: result.r,
                        slope: result.slope,
                        mean: result.meanX,
                        // For DRTG, negative correlation = better defense (lower opponent scoring)
                        impact: Math.abs(result.r),
                        direction: result.r > 0 ? 'hurts_D' : 'helps_D'
                    };
                }).sort((a, b) => b.impact - a.impact);
                
                // Get unique players for dropdown
                const uniquePlayers = [...new Set(dataToAnalyze.map(d => d.Player))].sort();
                
                // Calculate averages
                const avgOffRtg = offRtgArr.reduce((a, b) => a + b, 0) / offRtgArr.length;
                const avgDefRtg = defRtgArr.reduce((a, b) => a + b, 0) / defRtgArr.length;
                
                setPlayerImpactResults({
                    sampleSize: parsed.length,
                    avgOffRtg,
                    avgDefRtg,
                    avgNetRtg: avgOffRtg - avgDefRtg,
                    offenseCorrelations,
                    defenseCorrelations,
                    players: uniquePlayers,
                    filterPlayer,
                    teamFilter: team
                });
                setShowPlayerImpactModal(true);
            }, [playerData, team]);

            // On/Off leaderboard data - calculated once for all players
            // V6.1: Helper to normalize player name with merge rules applied
            const normalizeWithMerge = useCallback((playerName) => {
                const merged = applyPlayerMerge(playerName);
                return normalizePlayerName(merged);
            }, [applyPlayerMerge]);

            const onOffData = useMemo(() => {
                if (!lineupData.length) return [];

                // Helper to calculate stats from a set of lineups
                const calcStats = (filteredLineups) => {
                    if (!filteredLineups.length) return null;
                    const t = filteredLineups.reduce((a, d) => {
                        const time = parseFloat(d.TIME)||0, poss = parseFloat(d.POSS)||0, possV = parseFloat(d.POSS_VS)||0;
                        const fga = parseFloat(d.FGA)||0, oreb = parseFloat(d.OREB)||0, tov = parseFloat(d.TOV)||0, fta = parseFloat(d.FTA)||0;
                        const fgaV = parseFloat(d.FGA_VS)||0, orebV = parseFloat(d.OREB_VS)||0, tovV = parseFloat(d.TOV_VS)||0, ftaV = parseFloat(d.FTA_VS)||0;
                        const combP = calcPoss(fga, oreb, tov, fta) + calcPoss(fgaV, orebV, tovV, ftaV);
                        const fgm = parseFloat(d.FGM)||0, tpm = parseFloat(d['3PM'])||0, tpa = parseFloat(d['3PA'])||0, dreb = parseFloat(d.DREB)||0, ast = parseFloat(d.AST)||0, stl = parseFloat(d.STL)||0, blk = parseFloat(d.BLK)||0;
                        const fgmV = parseFloat(d.FGM_VS)||0, tpmV = parseFloat(d['3PM_VS'])||0, tpaV = parseFloat(d['3PA_VS'])||0, drebV = parseFloat(d.DREB_VS)||0;
                        const rimA = parseFloat(d.RIM_ATT)||0, rimM = parseFloat(d.RIM_MADE)||0, midA = parseFloat(d.OTD_2PT_ATT)||0, midM = parseFloat(d.OTD_2PT_MADE)||0, threeA = parseFloat(d.OTD_3PT_ATT)||0, threeM = parseFloat(d.OTD_3PT_MADE)||0;
                        const rimAV = parseFloat(d.RIM_ATT_VS)||0, rimMV = parseFloat(d.RIM_MADE_VS)||0, midAV = parseFloat(d.OTD_2PT_ATT_VS)||0, midMV = parseFloat(d.OTD_2PT_MADE_VS)||0, threeAV = parseFloat(d.OTD_3PT_ATT_VS)||0, threeMV = parseFloat(d.OTD_3PT_MADE_VS)||0;
                        const ftm = parseFloat(d.FTM)||0, ftmV = parseFloat(d.FTM_VS)||0;
                        const pts = fgm * 2 + tpm + ftm, ptsV = fgmV * 2 + tpmV + ftmV;
                        const offPoss = calcPoss(fga, oreb, tov, fta), defPoss = calcPoss(fgaV, orebV, tovV, ftaV);
                        const off = offPoss > 0 ? (pts / offPoss) * 100 : 0;
                        const def = defPoss > 0 ? (ptsV / defPoss) * 100 : 0;
                        const net = off - def;
                        const paceF = time > 0 ? (offPoss / time) * 2400 : 0;
                        const paceV = time > 0 ? (defPoss / time) * 2400 : 0;
                        // MISC and transition raw values
                        const secChance = parseFloat(d['2ND_CHANCE_PTS'])||0;
                        const ptsOffTov = parseFloat(d.PTS_OFF_TOV)||0;
                        const fastBreak = parseFloat(d.FAST_BREAK_PTS)||0;
                        const secChanceV = parseFloat(d['2ND_CHANCE_PTS_VS'])||0;
                        const ptsOffTovV = parseFloat(d.PTS_OFF_TOV_VS)||0;
                        const fastBreakV = parseFloat(d.FAST_BREAK_PTS_VS)||0;
                        return { ...a, time: a.time + time, poss: a.poss + offPoss, possV: a.possV + defPoss, combP: a.combP + combP, fgm: a.fgm + fgm, fga: a.fga + fga, tpm: a.tpm + tpm, tpa: a.tpa + tpa, fta: a.fta + fta, ftm: a.ftm + ftm, oreb: a.oreb + oreb, dreb: a.dreb + dreb, tov: a.tov + tov, ast: a.ast + ast, stl: a.stl + stl, blk: a.blk + blk, fgmV: a.fgmV + fgmV, fgaV: a.fgaV + fgaV, tpmV: a.tpmV + tpmV, tpaV: a.tpaV + tpaV, ftaV: a.ftaV + ftaV, ftmV: a.ftmV + ftmV, orebV: a.orebV + orebV, drebV: a.drebV + drebV, tovV: a.tovV + tovV, rimA: a.rimA + rimA, rimM: a.rimM + rimM, midA: a.midA + midA, midM: a.midM + midM, threeA: a.threeA + threeA, threeM: a.threeM + threeM, rimAV: a.rimAV + rimAV, rimMV: a.rimMV + rimMV, midAV: a.midAV + midAV, midMV: a.midMV + midMV, threeAV: a.threeAV + threeAV, threeMV: a.threeMV + threeMV, wNet: a.wNet + net * combP, wOff: a.wOff + off * combP, wDef: a.wDef + def * combP, wPaceF: a.wPaceF + paceF * time, wPaceV: a.wPaceV + paceV * time, pts: a.pts + pts, ptsV: a.ptsV + ptsV, secChance: a.secChance + secChance, ptsOffTov: a.ptsOffTov + ptsOffTov, fastBreak: a.fastBreak + fastBreak, secChanceV: a.secChanceV + secChanceV, ptsOffTovV: a.ptsOffTovV + ptsOffTovV, fastBreakV: a.fastBreakV + fastBreakV };
                    }, { time: 0, poss: 0, possV: 0, combP: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, tov: 0, ast: 0, stl: 0, blk: 0, fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftaV: 0, ftmV: 0, orebV: 0, drebV: 0, tovV: 0, rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0, rimAV: 0, rimMV: 0, midAV: 0, midMV: 0, threeAV: 0, threeMV: 0, wNet: 0, wOff: 0, wDef: 0, wPaceF: 0, wPaceV: 0, pts: 0, ptsV: 0, secChance: 0, ptsOffTov: 0, fastBreak: 0, secChanceV: 0, ptsOffTovV: 0, fastBreakV: 0 });
                    
                    const offEfg = t.fga > 0 ? ((t.fgm + 0.5*t.tpm)/t.fga)*100 : 0;
                    const offTovDenom = t.fga + 0.44 * t.fta + t.tov;
                    const offTov = offTovDenom > 0 ? (t.tov/offTovDenom)*100 : 0;
                    const offOreb = (t.oreb+t.drebV) > 0 ? (t.oreb/(t.oreb+t.drebV))*100 : 0;
                    const offFtR = t.fga > 0 ? (t.fta/t.fga)*100 : 0;
                    const defEfg = t.fgaV > 0 ? ((t.fgmV + 0.5*t.tpmV)/t.fgaV)*100 : 0;
                    const defTovDenom = t.fgaV + 0.44 * t.ftaV + t.tovV;
                    const defTov = defTovDenom > 0 ? (t.tovV/defTovDenom)*100 : 0;
                    const defOreb = (t.orebV+t.dreb) > 0 ? (t.orebV/(t.orebV+t.dreb))*100 : 0;
                    const defFtR = t.fgaV > 0 ? (t.ftaV/t.fgaV)*100 : 0;
                    const rimPct = t.rimA > 0 ? (t.rimM/t.rimA)*100 : 0, midPct = t.midA > 0 ? (t.midM/t.midA)*100 : 0, threePct = t.threeA > 0 ? (t.threeM/t.threeA)*100 : 0;
                    const rimPctV = t.rimAV > 0 ? (t.rimMV/t.rimAV)*100 : 0, midPctV = t.midAV > 0 ? (t.midMV/t.midAV)*100 : 0, threePctV = t.threeAV > 0 ? (t.threeMV/t.threeAV)*100 : 0;
                    const rimVol = t.poss > 0 ? (t.rimA / t.poss) * 100 : 0, midVol = t.poss > 0 ? (t.midA / t.poss) * 100 : 0, threeVol = t.poss > 0 ? (t.threeA / t.poss) * 100 : 0;
                    const rimVolV = t.possV > 0 ? (t.rimAV / t.possV) * 100 : 0, midVolV = t.possV > 0 ? (t.midAV / t.possV) * 100 : 0, threeVolV = t.possV > 0 ? (t.threeAV / t.possV) * 100 : 0;
                    const astPct = t.fgm > 0 ? (t.ast/t.fgm)*100 : 0;
                    const stlPct = t.possV > 0 ? (t.stl/t.possV)*100 : 0;
                    const blkPct = (t.fgaV-t.tpaV) > 0 ? (t.blk/(t.fgaV-t.tpaV))*100 : 0;
                    // MISC and transition per 100
                    const secChance100 = t.poss > 0 ? (t.secChance / t.poss) * 100 : 0;
                    const ptsOffTov100 = t.poss > 0 ? (t.ptsOffTov / t.poss) * 100 : 0;
                    const fastBreak100 = t.poss > 0 ? (t.fastBreak / t.poss) * 100 : 0;
                    const secChance100V = t.possV > 0 ? (t.secChanceV / t.possV) * 100 : 0;
                    const ptsOffTov100V = t.possV > 0 ? (t.ptsOffTovV / t.possV) * 100 : 0;
                    const fastBreak100V = t.possV > 0 ? (t.fastBreakV / t.possV) * 100 : 0;
                    
                    return {
                        poss: t.combP,
                        offPoss: t.poss,
                        defPoss: t.possV,
                        net: t.combP > 0 ? t.wNet/t.combP : 0,
                        off: t.combP > 0 ? t.wOff/t.combP : 0,
                        def: t.combP > 0 ? t.wDef/t.combP : 0,
                        paceF: t.time > 0 ? t.wPaceF/t.time : 0,
                        paceV: t.time > 0 ? t.wPaceV/t.time : 0,
                        offEfg, offTov, offOreb, offFtR, defEfg, defTov, defOreb, defFtR,
                        rimPct, midPct, threePct, rimPctV, midPctV, threePctV,
                        rimVol, midVol, threeVol, rimVolV, midVolV, threeVolV,
                        astPct, stlPct, blkPct,
                        // MISC and transition stats
                        secChance100, ptsOffTov100, fastBreak100,
                        secChance100V, ptsOffTov100V, fastBreak100V,
                        // Raw totals for luck adjustment
                        tpm: t.tpm, tpa: t.tpa, tpmV: t.tpmV, tpaV: t.tpaV,
                        fgm: t.fgm, fga: t.fga, fgmV: t.fgmV, fgaV: t.fgaV,
                        ftm: t.ftm, ftmV: t.ftmV,
                        // Raw shot attempts for shot share calculations
                        rimA: t.rimA, midA: t.midA, threeA: t.threeA,
                        rimAV: t.rimAV, midAV: t.midAV, threeAV: t.threeAV
                    };
                };
                
                // Group lineups by team
                const teamLineups = {};
                lineupData.forEach(l => {
                    if (!teamLineups[l.Team]) teamLineups[l.Team] = [];
                    teamLineups[l.Team].push(l);
                });
                
                const results = [];
                
                Object.entries(teamLineups).forEach(([teamName, lineups]) => {
                    // Get all players for this team - V6.1: Apply merge rules
                    const playerSet = new Set();
                    const playerDisplayNames = {}; // Map normalized name to display name
                    lineups.forEach(l => {
                        if (l.Lineup) {
                            l.Lineup.split(',').map(p => p.trim()).forEach(p => {
                                const mergedName = applyPlayerMerge(p);
                                const normName = normalizePlayerName(mergedName);
                                playerSet.add(normName);
                                // Keep the first occurrence as display name (primary name from merge)
                                if (!playerDisplayNames[normName]) {
                                    playerDisplayNames[normName] = mergedName;
                                }
                            });
                        }
                    });

                    // For each player, calculate ON and OFF stats
                    playerSet.forEach(pNorm => {
                        const player = playerDisplayNames[pNorm]; // Use display name
                        const onLineups = lineups.filter(l => {
                            const lp = l.Lineup ? l.Lineup.split(',').map(x => normalizePlayerName(applyPlayerMerge(x))) : [];
                            return lp.includes(pNorm);
                        });
                        const offLineups = lineups.filter(l => {
                            const lp = l.Lineup ? l.Lineup.split(',').map(x => normalizePlayerName(applyPlayerMerge(x))) : [];
                            return !lp.includes(pNorm);
                        });
                        
                        const onStats = calcStats(onLineups);
                        const offStats = calcStats(offLineups);
                        
                        if (onStats && onStats.poss >= 10) {
                            // Calculate minutes from time (time is in seconds in the lineups)
                            const onMinutes = onLineups.reduce((acc, l) => acc + (parseFloat(l.TOTAL_TIME) || 0), 0) / 60;
                            const offMinutes = offLineups.reduce((acc, l) => acc + (parseFloat(l.TOTAL_TIME) || 0), 0) / 60;
                            
                            results.push({
                                player,
                                team: teamName,
                                onPoss: onStats.poss,
                                offPoss: offStats ? offStats.poss : 0,
                                onMinutes,
                                offMinutes,
                                onStats,
                                offStats: offStats || onStats // fallback if no OFF data
                            });
                        }
                    });
                });
                
                return results;
            }, [lineupData, applyPlayerMerge, playerMergeRules]);

            // =======================================================================
            // CLUTCH ON/OFF DATA - Calculate player on/off stats from clutch data
            // =======================================================================
            const clutchOnOffData = useMemo(() => {
                if (!clutchData.length) return [];
                
                // Group clutch lineups by team
                const teamLineups = {};
                clutchData.forEach(l => {
                    if (!teamLineups[l.Team]) teamLineups[l.Team] = [];
                    teamLineups[l.Team].push(l);
                });
                
                const results = [];
                
                Object.entries(teamLineups).forEach(([teamName, lineups]) => {
                    // Get all players for this team - V6.1: Apply merge rules
                    const playerSet = new Set();
                    const playerDisplayNames = {};
                    lineups.forEach(l => {
                        if (l.Lineup) {
                            l.Lineup.split(',').map(p => p.trim()).forEach(p => {
                                const mergedName = applyPlayerMerge(p);
                                const normName = normalizePlayerName(mergedName);
                                playerSet.add(normName);
                                if (!playerDisplayNames[normName]) {
                                    playerDisplayNames[normName] = mergedName;
                                }
                            });
                        }
                    });

                    // For each player, calculate ON and OFF clutch stats
                    playerSet.forEach(pNorm => {
                        const player = playerDisplayNames[pNorm];
                        const onLineups = lineups.filter(l => {
                            const lp = l.Lineup ? l.Lineup.split(',').map(x => normalizePlayerName(applyPlayerMerge(x))) : [];
                            return lp.includes(pNorm);
                        });
                        const offLineups = lineups.filter(l => {
                            const lp = l.Lineup ? l.Lineup.split(',').map(x => normalizePlayerName(applyPlayerMerge(x))) : [];
                            return !lp.includes(pNorm);
                        });

                        // Aggregate ON clutch stats
                        const onTotals = onLineups.reduce((a, d) => ({
                            poss: a.poss + (parseFloat(d.POSS) || 0),
                            pts: a.pts + (parseFloat(d.PTS) || 0),
                            ptsAllowed: a.ptsAllowed + (parseFloat(d.PTS_ALLOWED) || 0),
                            minutes: a.minutes + (parseFloat(d.Clutch_Minutes) || 0)
                        }), { poss: 0, pts: 0, ptsAllowed: 0, minutes: 0 });

                        // Aggregate OFF clutch stats
                        const offTotals = offLineups.reduce((a, d) => ({
                            poss: a.poss + (parseFloat(d.POSS) || 0),
                            pts: a.pts + (parseFloat(d.PTS) || 0),
                            ptsAllowed: a.ptsAllowed + (parseFloat(d.PTS_ALLOWED) || 0),
                            minutes: a.minutes + (parseFloat(d.Clutch_Minutes) || 0)
                        }), { poss: 0, pts: 0, ptsAllowed: 0, minutes: 0 });

                        if (onTotals.poss >= 5) {
                            const onOffRtg = onTotals.poss > 0 ? (onTotals.pts / onTotals.poss) * 100 : 0;
                            const onDefRtg = onTotals.poss > 0 ? (onTotals.ptsAllowed / onTotals.poss) * 100 : 0;
                            const onNetRtg = onOffRtg - onDefRtg;

                            const offOffRtg = offTotals.poss > 0 ? (offTotals.pts / offTotals.poss) * 100 : 0;
                            const offDefRtg = offTotals.poss > 0 ? (offTotals.ptsAllowed / offTotals.poss) * 100 : 0;
                            const offNetRtg = offOffRtg - offDefRtg;

                            results.push({
                                player,
                                team: teamName,
                                onPoss: onTotals.poss,
                                offPoss: offTotals.poss,
                                onStats: { clutchNet: onNetRtg, clutchOff: onOffRtg, clutchDef: onDefRtg },
                                offStats: { clutchNet: offNetRtg, clutchOff: offOffRtg, clutchDef: offDefRtg }
                            });
                        }
                    });
                });

                return results;
            }, [clutchData, applyPlayerMerge, playerMergeRules]);

            // =======================================================================
            // V4.3.5: LEAGUE AVERAGES FOR SHOT DISTANCES
            // Calculate league-wide averages for shot volume and percentage by distance
            // =======================================================================
            const leagueAvgShotStats = useMemo(() => {
                if (!lineupData.length) return null;
                
                const totals = lineupData.reduce((acc, d) => {
                    const poss = calcPoss(parseFloat(d.FGA)||0, parseFloat(d.OREB)||0, parseFloat(d.TOV)||0, parseFloat(d.FTA)||0);
                    const possV = calcPoss(parseFloat(d.FGA_VS)||0, parseFloat(d.OREB_VS)||0, parseFloat(d.TOV_VS)||0, parseFloat(d.FTA_VS)||0);
                    // Points
                    const fgm = parseFloat(d.FGM)||0, tpm = parseFloat(d['3PM'])||0, ftm = parseFloat(d.FTM)||0;
                    const fgmV = parseFloat(d.FGM_VS)||0, tpmV = parseFloat(d['3PM_VS'])||0, ftmV = parseFloat(d.FTM_VS)||0;
                    const pts = 2 * fgm + tpm + ftm;
                    const ptsV = 2 * fgmV + tpmV + ftmV;
                    return {
                        poss: acc.poss + poss,
                        possV: acc.possV + possV,
                        pts: acc.pts + pts,
                        ptsV: acc.ptsV + ptsV,
                        rimA: acc.rimA + (parseFloat(d.RIM_ATT)||0),
                        rimM: acc.rimM + (parseFloat(d.RIM_MADE)||0),
                        midA: acc.midA + (parseFloat(d.OTD_2PT_ATT)||0),
                        midM: acc.midM + (parseFloat(d.OTD_2PT_MADE)||0),
                        threeA: acc.threeA + (parseFloat(d.OTD_3PT_ATT)||0),
                        threeM: acc.threeM + (parseFloat(d.OTD_3PT_MADE)||0),
                        rimAV: acc.rimAV + (parseFloat(d.RIM_ATT_VS)||0),
                        rimMV: acc.rimMV + (parseFloat(d.RIM_MADE_VS)||0),
                        midAV: acc.midAV + (parseFloat(d.OTD_2PT_ATT_VS)||0),
                        midMV: acc.midMV + (parseFloat(d.OTD_2PT_MADE_VS)||0),
                        threeAV: acc.threeAV + (parseFloat(d.OTD_3PT_ATT_VS)||0),
                        threeMV: acc.threeMV + (parseFloat(d.OTD_3PT_MADE_VS)||0),
                        // Transition stats
                        fastBreak: acc.fastBreak + (parseFloat(d.FAST_BREAK_PTS)||0),
                        fastBreakV: acc.fastBreakV + (parseFloat(d.FAST_BREAK_PTS_VS)||0),
                        secChance: acc.secChance + (parseFloat(d.SEC_CHANCE_PTS)||0),
                        secChanceV: acc.secChanceV + (parseFloat(d.SEC_CHANCE_PTS_VS)||0),
                        ptsOffTov: acc.ptsOffTov + (parseFloat(d.PTS_OFF_TOV)||0),
                        ptsOffTovV: acc.ptsOffTovV + (parseFloat(d.PTS_OFF_TOV_VS)||0)
                    };
                }, { poss: 0, possV: 0, pts: 0, ptsV: 0, rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0, rimAV: 0, rimMV: 0, midAV: 0, midMV: 0, threeAV: 0, threeMV: 0, fastBreak: 0, fastBreakV: 0, secChance: 0, secChanceV: 0, ptsOffTov: 0, ptsOffTovV: 0 });
                
                return {
                    // Offensive league averages - shot distribution
                    rimPct: totals.rimA > 0 ? (totals.rimM / totals.rimA) * 100 : 60,
                    midPct: totals.midA > 0 ? (totals.midM / totals.midA) * 100 : 40,
                    threePct: totals.threeA > 0 ? (totals.threeM / totals.threeA) * 100 : 35,
                    rimVol: totals.poss > 0 ? (totals.rimA / totals.poss) * 100 : 30,
                    midVol: totals.poss > 0 ? (totals.midA / totals.poss) * 100 : 15,
                    threeVol: totals.poss > 0 ? (totals.threeA / totals.poss) * 100 : 35,
                    // V4.6.2: League shot distribution FREQUENCIES (as proportion of total FGA, not possessions)
                    // These are needed for mathematically correct eFG% contribution calculations
                    rimFreq: (() => { const totalFGA = totals.rimA + totals.midA + totals.threeA; return totalFGA > 0 ? totals.rimA / totalFGA : 0.35; })(),
                    midFreq: (() => { const totalFGA = totals.rimA + totals.midA + totals.threeA; return totalFGA > 0 ? totals.midA / totalFGA : 0.18; })(),
                    threeFreq: (() => { const totalFGA = totals.rimA + totals.midA + totals.threeA; return totalFGA > 0 ? totals.threeA / totalFGA : 0.47; })(),
                    // V4.6.2: League eFG-equivalents by zone (for contribution formula)
                    rimEfgEquiv: totals.rimA > 0 ? (totals.rimM / totals.rimA) * 100 : 60, // Same as rimPct for 2PT
                    midEfgEquiv: totals.midA > 0 ? (totals.midM / totals.midA) * 100 : 40, // Same as midPct for 2PT
                    threeEfgEquiv: totals.threeA > 0 ? (totals.threeM / totals.threeA) * 100 * 1.5 : 52.5, // 3P% × 1.5
                    // Defensive league averages (what opponents shoot)
                    rimPctV: totals.rimAV > 0 ? (totals.rimMV / totals.rimAV) * 100 : 60,
                    midPctV: totals.midAV > 0 ? (totals.midMV / totals.midAV) * 100 : 40,
                    threePctV: totals.threeAV > 0 ? (totals.threeMV / totals.threeAV) * 100 : 35,
                    rimVolV: totals.possV > 0 ? (totals.rimAV / totals.possV) * 100 : 30,
                    midVolV: totals.possV > 0 ? (totals.midAV / totals.possV) * 100 : 15,
                    threeVolV: totals.possV > 0 ? (totals.threeAV / totals.possV) * 100 : 35,
                    // V4.6.2: Defensive league shot distribution FREQUENCIES
                    rimFreqV: (() => { const totalFGAV = totals.rimAV + totals.midAV + totals.threeAV; return totalFGAV > 0 ? totals.rimAV / totalFGAV : 0.35; })(),
                    midFreqV: (() => { const totalFGAV = totals.rimAV + totals.midAV + totals.threeAV; return totalFGAV > 0 ? totals.midAV / totalFGAV : 0.18; })(),
                    threeFreqV: (() => { const totalFGAV = totals.rimAV + totals.midAV + totals.threeAV; return totalFGAV > 0 ? totals.threeAV / totalFGAV : 0.47; })(),
                    // V4.6.2: Defensive league eFG-equivalents by zone
                    rimEfgEquivV: totals.rimAV > 0 ? (totals.rimMV / totals.rimAV) * 100 : 60,
                    midEfgEquivV: totals.midAV > 0 ? (totals.midMV / totals.midAV) * 100 : 40,
                    threeEfgEquivV: totals.threeAV > 0 ? (totals.threeMV / totals.threeAV) * 100 * 1.5 : 52.5,
                    // Transition league averages - offensive
                    fastBreak100: totals.poss > 0 ? (totals.fastBreak / totals.poss) * 100 : 25,
                    transPct: totals.pts > 0 ? (totals.fastBreak / totals.pts) * 100 : 25,
                    secChance100: totals.poss > 0 ? (totals.secChance / totals.poss) * 100 : 12,
                    ptsOffTov100: totals.poss > 0 ? (totals.ptsOffTov / totals.poss) * 100 : 15,
                    // Transition league averages - defensive (allowed)
                    fastBreak100V: totals.possV > 0 ? (totals.fastBreakV / totals.possV) * 100 : 25,
                    transPctV: totals.ptsV > 0 ? (totals.fastBreakV / totals.ptsV) * 100 : 25,
                    secChance100V: totals.possV > 0 ? (totals.secChanceV / totals.possV) * 100 : 12,
                    ptsOffTov100V: totals.possV > 0 ? (totals.ptsOffTovV / totals.possV) * 100 : 15,
                    // V4.7.1: Total FGA per 100 possessions (for proper volume normalization)
                    fgaPer100: totals.poss > 0 ? ((totals.rimA + totals.midA + totals.threeA) / totals.poss) * 100 : 80,
                    fgaPer100V: totals.possV > 0 ? ((totals.rimAV + totals.midAV + totals.threeAV) / totals.possV) * 100 : 80
                };
            }, [lineupData]);

            // =======================================================================
            // V4.7.1: eFG% MATCHUP MODELING FUNCTION - MATHEMATICALLY RIGOROUS VERSION
            // 
            // DESIGN PHILOSOPHY: Show matchup effects clearly, don't over-shrink to league avg
            // 
            // IMPROVEMENTS OVER V4.3.7:
            // 1. CORRECT SIGN: Δ_off + Δ_def (offense benefits from bad defense)
            // 2. Minimum-based sample size (bottleneck principle)
            // 3. SOFT shrinkage: k ∝ √N, high prior variance (lets matchup effects through)
            // 4. League-derived FGA/100 instead of magic number 80
            // 5. Compositionally coherent volume normalization
            // 6. Logit-space soft clamping for percentages
            // 7. Interaction terms for extreme matchup synergies (γ = 0.02)
            // 8. Gentle correlation adjustment (n^0.15, barely noticeable)
            //
            // Mathematical Model:
            //   E[Pct_z] = μ_z + (Δ_off,z + Δ_def,z + γ·Δ_off,z·Δ_def,z) × w
            //   where w = n_min / (n_min + k), k = k_0 × √N_players
            //   Δ_def > 0 means defense ALLOWS higher shooting (benefits offense)
            // =======================================================================
            
            // Logit and inverse logit for soft clamping (keeps values in (0,1) naturally)
            const logit = (p) => Math.log(p / (1 - p));
            const invLogit = (x) => 1 / (1 + Math.exp(-x));
            
            // Soft clamp percentage using logit transformation
            // Maps impact in percentage space through logit, applies shrinkage, maps back
            // This naturally bounds results to (minPct, maxPct) without hard truncation
            const softClampPct = useCallback((leaguePct, impact, weight, minPct = 5, maxPct = 95) => {
                // Convert to probability scale (0-1)
                const leagueP = Math.max(0.01, Math.min(0.99, leaguePct / 100));
                const impactP = impact / 100;
                
                // Transform to logit space where normal distribution is more appropriate
                const leagueLogit = logit(leagueP);
                
                // Impact in logit space (using delta method: d(logit(p))/dp = 1/(p(1-p)))
                // For small impacts, Δlogit ≈ Δp / (p(1-p))
                const jacobian = leagueP * (1 - leagueP);
                const impactLogit = jacobian > 0.01 ? impactP / jacobian : impactP * 10;
                
                // Apply weighted impact in logit space
                const projectedLogit = leagueLogit + impactLogit * weight;
                
                // Transform back to probability, then to percentage
                const projectedP = invLogit(projectedLogit);
                const projectedPct = projectedP * 100;
                
                // Apply soft bounds (these should rarely bind due to logit transformation)
                return Math.max(minPct, Math.min(maxPct, projectedPct));
            }, []);
            
            // Helper: Get RAPM-style adjusted impacts for a set of players
            // Uses ridge regression shrinkage to handle correlated player effects
            const getAdjustedImpacts = useCallback((playerNames, teamName, isDefensive = false) => {
                if (!onOffData.length) return null;
                
                // Get on/off data for each player
                const playerOnOffData = playerNames.map(name => 
                    onOffData.find(d => d.player === name && (teamName ? d.team === teamName : true))
                ).filter(Boolean);
                
                if (playerOnOffData.length === 0) return null;
                
                const n = playerOnOffData.length;
                
                // V4.7.1: Track individual player variances for proper weighting
                const playerImpacts = playerOnOffData.map(d => {
                    if (!d.onStats || !d.offStats) return null;
                    const poss = d.onPoss || 1;
                    const offPoss = d.offPoss || 1;
                    
                    // Calculate raw on/off differentials
                    const raw = {
                        rimPct: (d.onStats.rimPct || 0) - (d.offStats.rimPct || 0),
                        midPct: (d.onStats.midPct || 0) - (d.offStats.midPct || 0),
                        threePct: (d.onStats.threePct || 0) - (d.offStats.threePct || 0),
                        rimVol: (d.onStats.rimVol || 0) - (d.offStats.rimVol || 0),
                        midVol: (d.onStats.midVol || 0) - (d.offStats.midVol || 0),
                        threeVol: (d.onStats.threeVol || 0) - (d.offStats.threeVol || 0),
                        rimPctV: (d.onStats.rimPctV || 0) - (d.offStats.rimPctV || 0),
                        midPctV: (d.onStats.midPctV || 0) - (d.offStats.midPctV || 0),
                        threePctV: (d.onStats.threePctV || 0) - (d.offStats.threePctV || 0),
                        rimVolV: (d.onStats.rimVolV || 0) - (d.offStats.rimVolV || 0),
                        midVolV: (d.onStats.midVolV || 0) - (d.offStats.midVolV || 0),
                        threeVolV: (d.onStats.threeVolV || 0) - (d.offStats.threeVolV || 0)
                    };
                    
                    // V4.7.1: Estimate variance for each stat using binomial approximation
                    // Var(p̂_on - p̂_off) ≈ p(1-p)/n_on + p(1-p)/n_off
                    // For simplicity, use pooled estimate
                    const calcVariance = (onPct, poss) => {
                        const p = Math.max(0.1, Math.min(0.9, (onPct || 50) / 100));
                        return (p * (1 - p) * 100 * 100) / Math.max(poss, 1); // Variance in pct² units
                    };
                    
                    const variance = {
                        rimPct: calcVariance(d.onStats.rimPct, poss) + calcVariance(d.offStats.rimPct, offPoss),
                        midPct: calcVariance(d.onStats.midPct, poss) + calcVariance(d.offStats.midPct, offPoss),
                        threePct: calcVariance(d.onStats.threePct, poss) + calcVariance(d.offStats.threePct, offPoss),
                        rimPctV: calcVariance(d.onStats.rimPctV, poss) + calcVariance(d.offStats.rimPctV, offPoss),
                        midPctV: calcVariance(d.onStats.midPctV, poss) + calcVariance(d.offStats.midPctV, offPoss),
                        threePctV: calcVariance(d.onStats.threePctV, poss) + calcVariance(d.offStats.threePctV, offPoss),
                        // Volume variances (Poisson-like, variance ≈ mean)
                        rimVol: Math.max(1, Math.abs(d.onStats.rimVol || 10)) / Math.max(poss, 1) * 100,
                        midVol: Math.max(1, Math.abs(d.onStats.midVol || 5)) / Math.max(poss, 1) * 100,
                        threeVol: Math.max(1, Math.abs(d.onStats.threeVol || 10)) / Math.max(poss, 1) * 100,
                        rimVolV: Math.max(1, Math.abs(d.onStats.rimVolV || 10)) / Math.max(poss, 1) * 100,
                        midVolV: Math.max(1, Math.abs(d.onStats.midVolV || 5)) / Math.max(poss, 1) * 100,
                        threeVolV: Math.max(1, Math.abs(d.onStats.threeVolV || 10)) / Math.max(poss, 1) * 100
                    };
                    
                    return { raw, variance, poss, player: d.player };
                }).filter(Boolean);
                
                if (playerImpacts.length === 0) return null;
                
                // V4.7.1: RAPM-style shrinkage - weight each player's contribution by precision
                // Combined impact = Σ(w_i × Δ_i) / Σ(w_i) where w_i = 1/Var_i (precision)
                // But for multi-player lineups, we also apply shrinkage factor for correlation
                
                // V4.7.1b: SOFTER prior variance - we want to see matchup effects, not sand to league avg
                // Much higher prior variance = trust observed impacts more
                // EXCEPTION: 3PT defense (threePctV) has high luck component, shrink more aggressively
                const priorVariance = {
                    rimPct: 100, midPct: 100, threePct: 100,  // ~10% SD - very permissive
                    rimPctV: 100, midPctV: 100, threePctV: 25,  // 3PT D shrinks more (luck-driven)
                    rimVol: 50, midVol: 50, threeVol: 50,     // ~7 attempts/100 SD
                    rimVolV: 50, midVolV: 50, threeVolV: 50
                };
                
                const impacts = {
                    rimPct: 0, midPct: 0, threePct: 0,
                    rimVol: 0, midVol: 0, threeVol: 0,
                    rimPctV: 0, midPctV: 0, threePctV: 0,
                    rimVolV: 0, midVolV: 0, threeVolV: 0,
                    totalOnPoss: 0,
                    totalVariance: {},  // For uncertainty propagation
                    playerCount: n,
                    individualImpacts: playerImpacts  // Store for debugging
                };
                
                // Calculate total possessions
                impacts.totalOnPoss = playerImpacts.reduce((sum, p) => sum + p.poss, 0);
                
                // V4.7.1: Apply Empirical Bayes shrinkage to each player, then sum
                // Shrinkage factor: B_i = σ²_prior / (σ²_prior + σ²_i)
                // Shrunk estimate: Δ_shrunk = B_i × Δ_raw
                const statKeys = ['rimPct', 'midPct', 'threePct', 'rimVol', 'midVol', 'threeVol',
                                  'rimPctV', 'midPctV', 'threePctV', 'rimVolV', 'midVolV', 'threeVolV'];
                
                statKeys.forEach(key => {
                    let sumShrunk = 0;
                    let sumVariance = 0;
                    
                    playerImpacts.forEach(p => {
                        const rawImpact = p.raw[key] || 0;
                        const obsVariance = p.variance[key] || priorVariance[key];
                        const prior = priorVariance[key];
                        
                        // Empirical Bayes shrinkage factor
                        const shrinkage = prior / (prior + obsVariance);
                        const shrunkImpact = shrinkage * rawImpact;
                        
                        sumShrunk += shrunkImpact;
                        
                        // Variance of shrunk estimator: B² × Var(Δ_raw)
                        sumVariance += shrinkage * shrinkage * obsVariance;
                    });
                    
                    impacts[key] = sumShrunk;
                    impacts.totalVariance[key] = sumVariance;
                });
                
                // V4.7.1b: Softer correlation adjustment for multi-player lineups
                // When players share court time, their on/off differentials are correlated
                // Use gentler n^0.15 factor (barely noticeable for 5 players: 5^0.15 ≈ 1.28)
                if (n > 1) {
                    const correlationFactor = Math.pow(n, 0.15); // Very gentle adjustment
                    statKeys.forEach(key => {
                        impacts[key] /= correlationFactor;
                        impacts.totalVariance[key] /= (correlationFactor * correlationFactor);
                    });
                }
                
                return impacts;
            }, [onOffData]);
            
            // V4.7.1b: Calculate reliability weight based on sample size
            // SOFTER than before - we want matchup effects to show through
            // Uses: w = n / (n + k) where k scales gently with player count
            const calcReliabilityWeight = useCallback((combinedPoss, playerCount, totalVariance = null) => {
                // V4.7.1b: k scales with SQRT of player count (gentler than linear)
                // This means 5v5 matchup (10 players) only needs sqrt(10) ≈ 3.2x more data than 1 player
                const k = efgModelWeight * Math.sqrt(Math.max(1, playerCount));
                
                // If we have variance estimates, blend with possession-based weight
                if (totalVariance && typeof totalVariance === 'object') {
                    const variances = Object.values(totalVariance);
                    const avgVariance = variances.length > 0 ? 
                        variances.reduce((a, b) => a + b, 0) / variances.length : 25;
                    
                    // Higher prior variance = trust data more
                    const priorVariance = 100; // Very permissive
                    const varianceWeight = priorVariance / (priorVariance + avgVariance);
                    
                    // Blend: use the MORE trusting of the two weights
                    const possWeight = combinedPoss / (combinedPoss + k);
                    return Math.max(possWeight, varianceWeight);
                }
                
                return combinedPoss / (combinedPoss + k);
            }, [efgModelWeight]);
            
            // Main matchup modeling function: Offensive Combo vs Defensive Combo
            const modelEfgMatchup = useCallback((offPlayers, offTeam, defPlayers, defTeam) => {
                if (!leagueAvgShotStats) return null;
                
                // Get RAPM-adjusted impacts for offensive lineup (their offensive stats)
                const offImpacts = getAdjustedImpacts(offPlayers, offTeam, false);
                // Get RAPM-adjusted impacts for defensive lineup (their defensive stats)
                const defImpacts = getAdjustedImpacts(defPlayers, defTeam, true);
                
                // Calculate sample sizes
                const offPoss = offImpacts ? offImpacts.totalOnPoss : 0;
                const defPoss = defImpacts ? defImpacts.totalOnPoss : 0;
                const offPlayerCount = offImpacts ? offImpacts.playerCount : 0;
                const defPlayerCount = defImpacts ? defImpacts.playerCount : 0;
                
                // V4.7.1 FIX: Use MINIMUM for combined sample size (bottleneck principle)
                // The uncertainty of the projection is dominated by the less-sampled side
                const combinedPoss = offPoss > 0 && defPoss > 0 ? 
                    Math.min(offPoss, defPoss) : 
                    Math.max(offPoss, defPoss);
                const combinedPlayerCount = offPlayerCount + defPlayerCount;
                
                // Combine variances for proper uncertainty propagation
                const combinedVariance = {};
                const statKeys = ['rimPct', 'midPct', 'threePct', 'rimVol', 'midVol', 'threeVol'];
                statKeys.forEach(key => {
                    const offVar = offImpacts?.totalVariance?.[key] || 25;
                    const defVar = defImpacts?.totalVariance?.[key + 'V'] || 25;
                    combinedVariance[key] = offVar + defVar; // Variance of sum = sum of variances (independent)
                });
                
                const reliabilityWeight = calcReliabilityWeight(combinedPoss, combinedPlayerCount, combinedVariance);
                
                // V4.7.1: Combined impact with INTERACTION TERMS
                // Formula: Δ_combined = Δ_off + Δ_def + γ × Δ_off × Δ_def
                // γ > 0 means synergistic effects (good offense vs bad defense is extra effective)
                const interactionStrength = 0.02; // Calibrated: 2% of product term
                
                const combinedImpacts = {};
                ['rimPct', 'midPct', 'threePct', 'rimVol', 'midVol', 'threeVol'].forEach(key => {
                    const offImp = offImpacts?.[key] || 0;
                    const defImp = defImpacts?.[key + 'V'] || 0;
                    
                    // Main effects (additive)
                    const mainEffect = offImp + defImp;
                    
                    // Interaction term: if both are positive (good offense + bad defense), extra boost
                    // if both are negative (bad offense + good defense), extra penalty
                    const interaction = interactionStrength * offImp * defImp;
                    
                    combinedImpacts[key] = mainEffect + interaction;
                });
                
                // V4.7.1: Apply reliability-weighted projection with SOFT CLAMPING
                const projected = {
                    // Percentages use logit-space soft clamping
                    rimPct: softClampPct(leagueAvgShotStats.rimPct, combinedImpacts.rimPct, reliabilityWeight, 40, 80),
                    midPct: softClampPct(leagueAvgShotStats.midPct, combinedImpacts.midPct, reliabilityWeight, 25, 60),
                    threePct: softClampPct(leagueAvgShotStats.threePct, combinedImpacts.threePct, reliabilityWeight, 20, 50),
                    // Volumes use linear projection (will normalize later)
                    rimVol: leagueAvgShotStats.rimVol + combinedImpacts.rimVol * reliabilityWeight,
                    midVol: leagueAvgShotStats.midVol + combinedImpacts.midVol * reliabilityWeight,
                    threeVol: leagueAvgShotStats.threeVol + combinedImpacts.threeVol * reliabilityWeight
                };
                
                // V4.7.1: Normalize volumes to LEAGUE-DERIVED FGA/100 (not magic number 80)
                const targetFgaPer100 = leagueAvgShotStats.fgaPer100 || 80;
                
                // Ensure all volumes are positive before normalization
                projected.rimVol = Math.max(1, projected.rimVol);
                projected.midVol = Math.max(1, projected.midVol);
                projected.threeVol = Math.max(1, projected.threeVol);
                
                const totalVol = projected.rimVol + projected.midVol + projected.threeVol;
                
                // V4.7.1 FIX: Normalize FIRST, then apply minimum bounds
                // This maintains compositional coherence
                if (totalVol > 0) {
                    const scale = targetFgaPer100 / totalVol;
                    projected.rimVol *= scale;
                    projected.midVol *= scale;
                    projected.threeVol *= scale;
                }
                
                // Apply soft minimum bounds (rarely binding after normalization)
                const minVol = 3; // Minimum 3 attempts per 100 possessions at any zone
                const needsRebalance = projected.rimVol < minVol || projected.midVol < minVol || projected.threeVol < minVol;
                
                if (needsRebalance) {
                    // Bring up any zone below minimum, proportionally reduce others
                    const deficit = Math.max(0, minVol - projected.rimVol) + 
                                   Math.max(0, minVol - projected.midVol) + 
                                   Math.max(0, minVol - projected.threeVol);
                    const surplus = Math.max(0, projected.rimVol - minVol) + 
                                   Math.max(0, projected.midVol - minVol) + 
                                   Math.max(0, projected.threeVol - minVol);
                    
                    if (surplus > deficit) {
                        const reductionRatio = (surplus - deficit) / surplus;
                        projected.rimVol = projected.rimVol < minVol ? minVol : 
                            minVol + (projected.rimVol - minVol) * reductionRatio;
                        projected.midVol = projected.midVol < minVol ? minVol : 
                            minVol + (projected.midVol - minVol) * reductionRatio;
                        projected.threeVol = projected.threeVol < minVol ? minVol : 
                            minVol + (projected.threeVol - minVol) * reductionRatio;
                    }
                }
                
                // Calculate modeled eFG% from shot distribution
                const offTotalAttempts = projected.rimVol + projected.midVol + projected.threeVol;
                const offRimShare = projected.rimVol / offTotalAttempts;
                const offMidShare = projected.midVol / offTotalAttempts;
                const offThreeShare = projected.threeVol / offTotalAttempts;
                
                const offEfgModeled = (
                    offRimShare * projected.rimPct + 
                    offMidShare * projected.midPct + 
                    offThreeShare * projected.threePct * 1.5
                );
                
                // V4.7.1: Calculate confidence interval for eFG% estimate
                // Using delta method: Var(eFG%) ≈ Σ (∂eFG/∂pct_z)² × Var(pct_z)
                const efgVariance = 
                    Math.pow(offRimShare, 2) * (combinedVariance.rimPct || 25) * reliabilityWeight * reliabilityWeight +
                    Math.pow(offMidShare, 2) * (combinedVariance.midPct || 25) * reliabilityWeight * reliabilityWeight +
                    Math.pow(offThreeShare * 1.5, 2) * (combinedVariance.threePct || 25) * reliabilityWeight * reliabilityWeight;
                const efgSE = Math.sqrt(efgVariance);
                
                return {
                    offEfgModeled,
                    projected,
                    combinedImpacts,
                    offImpacts,
                    defImpacts,
                    reliabilityWeight,
                    combinedPoss,
                    leagueAvg: leagueAvgShotStats,
                    // V4.7.1: Additional diagnostics
                    standardError: efgSE,
                    ci95: [offEfgModeled - 1.96 * efgSE, offEfgModeled + 1.96 * efgSE],
                    interactionStrength,
                    targetFgaPer100
                };
            }, [getAdjustedImpacts, calcReliabilityWeight, leagueAvgShotStats, softClampPct]);
            
            // V4.7.1: Backward-compatible wrapper for single-team combo (models vs league average defense)
            const modelEfgForCombo = useCallback((playerNames, teamName) => {
                if (!leagueAvgShotStats || !onOffData.length) return null;
                
                // Get RAPM-adjusted impacts for this lineup
                const offImpacts = getAdjustedImpacts(playerNames, teamName, false);
                if (!offImpacts) return null;
                
                // Calculate reliability weight using proper Bayesian formula
                const reliabilityWeight = calcReliabilityWeight(
                    offImpacts.totalOnPoss, 
                    offImpacts.playerCount,
                    offImpacts.totalVariance
                );
                
                // V4.7.1: Project using soft clamping
                const targetFgaPer100 = leagueAvgShotStats.fgaPer100 || 80;
                const targetFgaPer100V = leagueAvgShotStats.fgaPer100V || 80;
                
                const projected = {
                    // Offensive projections with soft clamping
                    rimPct: softClampPct(leagueAvgShotStats.rimPct, offImpacts.rimPct, reliabilityWeight, 40, 80),
                    midPct: softClampPct(leagueAvgShotStats.midPct, offImpacts.midPct, reliabilityWeight, 25, 60),
                    threePct: softClampPct(leagueAvgShotStats.threePct, offImpacts.threePct, reliabilityWeight, 20, 50),
                    rimVol: leagueAvgShotStats.rimVol + offImpacts.rimVol * reliabilityWeight,
                    midVol: leagueAvgShotStats.midVol + offImpacts.midVol * reliabilityWeight,
                    threeVol: leagueAvgShotStats.threeVol + offImpacts.threeVol * reliabilityWeight,
                    // Defensive projections with soft clamping
                    rimPctV: softClampPct(leagueAvgShotStats.rimPctV, offImpacts.rimPctV, reliabilityWeight, 40, 80),
                    midPctV: softClampPct(leagueAvgShotStats.midPctV, offImpacts.midPctV, reliabilityWeight, 25, 60),
                    threePctV: softClampPct(leagueAvgShotStats.threePctV, offImpacts.threePctV, reliabilityWeight, 20, 50),
                    rimVolV: leagueAvgShotStats.rimVolV + offImpacts.rimVolV * reliabilityWeight,
                    midVolV: leagueAvgShotStats.midVolV + offImpacts.midVolV * reliabilityWeight,
                    threeVolV: leagueAvgShotStats.threeVolV + offImpacts.threeVolV * reliabilityWeight
                };
                
                // V4.7.1: Normalize volumes to league-derived FGA/100
                // Offensive volumes
                projected.rimVol = Math.max(1, projected.rimVol);
                projected.midVol = Math.max(1, projected.midVol);
                projected.threeVol = Math.max(1, projected.threeVol);
                const totalOffVol = projected.rimVol + projected.midVol + projected.threeVol;
                if (totalOffVol > 0) {
                    const scale = targetFgaPer100 / totalOffVol;
                    projected.rimVol *= scale;
                    projected.midVol *= scale;
                    projected.threeVol *= scale;
                }
                
                // Defensive volumes
                projected.rimVolV = Math.max(1, projected.rimVolV);
                projected.midVolV = Math.max(1, projected.midVolV);
                projected.threeVolV = Math.max(1, projected.threeVolV);
                const totalDefVol = projected.rimVolV + projected.midVolV + projected.threeVolV;
                if (totalDefVol > 0) {
                    const scale = targetFgaPer100V / totalDefVol;
                    projected.rimVolV *= scale;
                    projected.midVolV *= scale;
                    projected.threeVolV *= scale;
                }
                
                // Calculate eFG%
                const offTotal = projected.rimVol + projected.midVol + projected.threeVol;
                const offEfgModeled = (
                    (projected.rimVol/offTotal) * projected.rimPct + 
                    (projected.midVol/offTotal) * projected.midPct + 
                    (projected.threeVol/offTotal) * projected.threePct * 1.5
                );
                
                const defTotal = projected.rimVolV + projected.midVolV + projected.threeVolV;
                const defEfgModeled = (
                    (projected.rimVolV/defTotal) * projected.rimPctV + 
                    (projected.midVolV/defTotal) * projected.midPctV + 
                    (projected.threeVolV/defTotal) * projected.threePctV * 1.5
                );
                
                return {
                    offEfgModeled,
                    defEfgModeled,
                    projected,
                    summedImpacts: offImpacts,
                    reliabilityWeight,
                    samplePoss: offImpacts.totalOnPoss,
                    leagueAvg: leagueAvgShotStats,
                    // V4.7.1: Additional diagnostics
                    totalVariance: offImpacts.totalVariance
                };
            }, [onOffData, leagueAvgShotStats, getAdjustedImpacts, calcReliabilityWeight, softClampPct]);

            // =======================================================================
            // V4.3.5: LINEUP BUILDER - Estimate effectiveness for any 5 players
            // =======================================================================
            const calculateBuilderLineup = useCallback(() => {
                const selectedPlayers = Object.values(builderPlayers).filter(p => p !== '');
                
                if (selectedPlayers.length < 2) {
                    setBuilderResults({ error: 'Select at least 2 players to estimate lineup effectiveness' });
                    return;
                }
                
                if (!onOffData.length) {
                    setBuilderResults({ error: 'Lineup data is required for this analysis' });
                    return;
                }
                
                // Get on/off data for each selected player (can be from different teams)
                const playerOnOffData = selectedPlayers.map(name => {
                    const match = onOffData.find(d => d.player === name);
                    return match ? { ...match, selected: true } : null;
                }).filter(Boolean);
                
                if (playerOnOffData.length < 2) {
                    setBuilderResults({ error: 'Could not find on/off data for selected players' });
                    return;
                }
                
                // V4.3.5: Get individual box-score stats from playerData
                const playerBoxStats = selectedPlayers.map(name => {
                    // Aggregate all rows for this player across all lineup stints
                    const playerRows = playerData.filter(pd => pd.Player && pd.Player.trim() === name);
                    if (!playerRows.length) return null;
                    
                    const totals = playerRows.reduce((acc, pd) => ({
                        minutes: acc.minutes + (parseFloat(pd.Minutes) || 0),
                        pts: acc.pts + (parseFloat(pd.PTS) || 0),
                        fgm: acc.fgm + (parseFloat(pd.FGM) || 0),
                        fga: acc.fga + (parseFloat(pd.FGA) || 0),
                        tpm: acc.tpm + (parseFloat(pd['3PM']) || 0),
                        tpa: acc.tpa + (parseFloat(pd['3PA']) || 0),
                        ftm: acc.ftm + (parseFloat(pd.FTM) || 0),
                        fta: acc.fta + (parseFloat(pd.FTA) || 0),
                        oreb: acc.oreb + (parseFloat(pd.OREB) || 0),
                        dreb: acc.dreb + (parseFloat(pd.DREB) || 0),
                        ast: acc.ast + (parseFloat(pd.AST) || 0),
                        stl: acc.stl + (parseFloat(pd.STL) || 0),
                        blk: acc.blk + (parseFloat(pd.BLK) || 0),
                        tov: acc.tov + (parseFloat(pd.TOV) || 0),
                        rimA: acc.rimA + (parseFloat(pd.RIM_ATT) || 0),
                        rimM: acc.rimM + (parseFloat(pd.RIM_MADE) || 0),
                        midA: acc.midA + (parseFloat(pd.OTD_2PT_ATT) || 0),
                        midM: acc.midM + (parseFloat(pd.OTD_2PT_MADE) || 0),
                        threeA: acc.threeA + (parseFloat(pd.OTD_3PT_ATT) || 0),
                        threeM: acc.threeM + (parseFloat(pd.OTD_3PT_MADE) || 0)
                    }), { minutes: 0, pts: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0 });
                    
                    const per40 = totals.minutes > 0 ? 40 / totals.minutes : 0;
                    return {
                        player: name,
                        team: playerRows[0].Team,
                        minutes: totals.minutes,
                        pts40: totals.pts * per40,
                        reb40: (totals.oreb + totals.dreb) * per40,
                        ast40: totals.ast * per40,
                        stl40: totals.stl * per40,
                        blk40: totals.blk * per40,
                        tov40: totals.tov * per40,
                        fgPct: totals.fga > 0 ? (totals.fgm / totals.fga) * 100 : 0,
                        threePct: totals.tpa > 0 ? (totals.tpm / totals.tpa) * 100 : 0,
                        ftPct: totals.fta > 0 ? (totals.ftm / totals.fta) * 100 : 0,
                        efgPct: totals.fga > 0 ? ((totals.fgm + 0.5 * totals.tpm) / totals.fga) * 100 : 0,
                        tsPct: (totals.fga + 0.44 * totals.fta) > 0 ? totals.pts / (2 * (totals.fga + 0.44 * totals.fta)) * 100 : 0,
                        rimPct: totals.rimA > 0 ? (totals.rimM / totals.rimA) * 100 : 0,
                        midPct: totals.midA > 0 ? (totals.midM / totals.midA) * 100 : 0,
                        shotProfile: {
                            rimShare: totals.fga > 0 ? (totals.rimA / totals.fga) * 100 : 0,
                            midShare: totals.fga > 0 ? (totals.midA / totals.fga) * 100 : 0,
                            threeShare: totals.fga > 0 ? (totals.tpa / totals.fga) * 100 : 0
                        },
                        raw: totals
                    };
                }).filter(Boolean);
                
                // Sum up all On/Off differentials
                const summedStats = {
                    net: 0, off: 0, def: 0,
                    offEfg: 0, offTov: 0, offOreb: 0, offFtR: 0,
                    defEfg: 0, defTov: 0, defOreb: 0, defFtR: 0,
                    stlPct: 0, blkPct: 0, astPct: 0,
                    rimPct: 0, midPct: 0, threePct: 0,
                    rimVol: 0, midVol: 0, threeVol: 0,
                    rimPctV: 0, midPctV: 0, threePctV: 0,
                    rimVolV: 0, midVolV: 0, threeVolV: 0
                };
                
                const playerBreakdowns = [];
                
                playerOnOffData.forEach(d => {
                    if (!d.onStats || !d.offStats) return;
                    
                    const diff = {
                        player: d.player,
                        team: d.team,
                        onPoss: d.onPoss,
                        net: (d.onStats.net || 0) - (d.offStats.net || 0),
                        off: (d.onStats.off || 0) - (d.offStats.off || 0),
                        def: (d.onStats.def || 0) - (d.offStats.def || 0),
                        offEfg: (d.onStats.offEfg || 0) - (d.offStats.offEfg || 0),
                        offTov: (d.onStats.offTov || 0) - (d.offStats.offTov || 0),
                        offOreb: (d.onStats.offOreb || 0) - (d.offStats.offOreb || 0),
                        offFtR: (d.onStats.offFtR || 0) - (d.offStats.offFtR || 0),
                        defEfg: (d.onStats.defEfg || 0) - (d.offStats.defEfg || 0),
                        defTov: (d.onStats.defTov || 0) - (d.offStats.defTov || 0),
                        defOreb: (d.onStats.defOreb || 0) - (d.offStats.defOreb || 0),
                        defFtR: (d.onStats.defFtR || 0) - (d.offStats.defFtR || 0),
                        stlPct: (d.onStats.stlPct || 0) - (d.offStats.stlPct || 0),
                        blkPct: (d.onStats.blkPct || 0) - (d.offStats.blkPct || 0),
                        astPct: (d.onStats.astPct || 0) - (d.offStats.astPct || 0),
                        rimPct: (d.onStats.rimPct || 0) - (d.offStats.rimPct || 0),
                        midPct: (d.onStats.midPct || 0) - (d.offStats.midPct || 0),
                        threePct: (d.onStats.threePct || 0) - (d.offStats.threePct || 0),
                        rimVol: (d.onStats.rimVol || 0) - (d.offStats.rimVol || 0),
                        midVol: (d.onStats.midVol || 0) - (d.offStats.midVol || 0),
                        threeVol: (d.onStats.threeVol || 0) - (d.offStats.threeVol || 0),
                        rimPctV: (d.onStats.rimPctV || 0) - (d.offStats.rimPctV || 0),
                        midPctV: (d.onStats.midPctV || 0) - (d.offStats.midPctV || 0),
                        threePctV: (d.onStats.threePctV || 0) - (d.offStats.threePctV || 0),
                        rimVolV: (d.onStats.rimVolV || 0) - (d.offStats.rimVolV || 0),
                        midVolV: (d.onStats.midVolV || 0) - (d.offStats.midVolV || 0),
                        threeVolV: (d.onStats.threeVolV || 0) - (d.offStats.threeVolV || 0)
                    };
                    
                    playerBreakdowns.push(diff);
                    
                    // Sum all differentials
                    Object.keys(summedStats).forEach(key => {
                        summedStats[key] += diff[key] || 0;
                    });
                });
                
                // V4.3.7: Apply reliability-weighted eFG modeling
                // Calculate total sample size from all players
                const totalOnPoss = playerOnOffData.reduce((sum, d) => sum + (d.onPoss || 0), 0);
                const playerCount = playerOnOffData.length;
                
                // Reliability weight based on sample size (Bayesian prior)
                // k = efgModelWeight controls prior strength (higher = need more data to trust)
                const k = efgModelWeight * Math.sqrt(playerCount);
                const reliabilityWeight = totalOnPoss / (totalOnPoss + k);
                
                // League average eFG% from shot distribution
                const projectedOffEfg = leagueAvgShotStats ? 
                    leagueAvgShotStats.rimPct * 0.33 + leagueAvgShotStats.midPct * 0.2 + leagueAvgShotStats.threePct * 0.47 * 1.5 : 52;
                const projectedDefEfg = leagueAvgShotStats ? 
                    leagueAvgShotStats.rimPctV * 0.33 + leagueAvgShotStats.midPctV * 0.2 + leagueAvgShotStats.threePctV * 0.47 * 1.5 : 52;
                
                // V4.3.7: Model eFG% using shot distance impacts with reliability weighting
                // Instead of simple regression, use: leagueAvg + impact * reliabilityWeight
                let modeledOffEfg = projectedOffEfg, modeledDefEfg = projectedDefEfg;
                
                if (leagueAvgShotStats) {
                    // Project offensive percentages with reliability weighting
                    const projRimPct = Math.max(40, Math.min(80, leagueAvgShotStats.rimPct + summedStats.rimPct * reliabilityWeight));
                    const projMidPct = Math.max(25, Math.min(60, leagueAvgShotStats.midPct + summedStats.midPct * reliabilityWeight));
                    const projThreePct = Math.max(25, Math.min(50, leagueAvgShotStats.threePct + summedStats.threePct * reliabilityWeight));
                    
                    // Project volumes with reliability weighting
                    let projRimVol = leagueAvgShotStats.rimVol + summedStats.rimVol * reliabilityWeight;
                    let projMidVol = leagueAvgShotStats.midVol + summedStats.midVol * reliabilityWeight;
                    let projThreeVol = leagueAvgShotStats.threeVol + summedStats.threeVol * reliabilityWeight;
                    
                    // Normalize volumes to 80%
                    const totalVol = Math.max(1, projRimVol + projMidVol + projThreeVol);
                    const scale = 80 / totalVol;
                    projRimVol = Math.max(5, projRimVol * scale);
                    projMidVol = Math.max(5, projMidVol * scale);
                    projThreeVol = Math.max(5, projThreeVol * scale);
                    
                    // Calculate eFG% from shot distribution
                    const offTotal = projRimVol + projMidVol + projThreeVol;
                    modeledOffEfg = (projRimVol/offTotal) * projRimPct + 
                                   (projMidVol/offTotal) * projMidPct + 
                                   (projThreeVol/offTotal) * projThreePct * 1.5;
                    
                    // Defensive projection
                    const projRimPctV = Math.max(40, Math.min(80, leagueAvgShotStats.rimPctV + summedStats.rimPctV * reliabilityWeight));
                    const projMidPctV = Math.max(25, Math.min(60, leagueAvgShotStats.midPctV + summedStats.midPctV * reliabilityWeight));
                    const projThreePctV = Math.max(25, Math.min(50, leagueAvgShotStats.threePctV + summedStats.threePctV * reliabilityWeight));
                    
                    let projRimVolV = leagueAvgShotStats.rimVolV + summedStats.rimVolV * reliabilityWeight;
                    let projMidVolV = leagueAvgShotStats.midVolV + summedStats.midVolV * reliabilityWeight;
                    let projThreeVolV = leagueAvgShotStats.threeVolV + summedStats.threeVolV * reliabilityWeight;
                    
                    const totalVolV = Math.max(1, projRimVolV + projMidVolV + projThreeVolV);
                    const scaleV = 80 / totalVolV;
                    projRimVolV = Math.max(5, projRimVolV * scaleV);
                    projMidVolV = Math.max(5, projMidVolV * scaleV);
                    projThreeVolV = Math.max(5, projThreeVolV * scaleV);
                    
                    const defTotal = projRimVolV + projMidVolV + projThreeVolV;
                    modeledDefEfg = (projRimVolV/defTotal) * projRimPctV + 
                                   (projMidVolV/defTotal) * projMidPctV + 
                                   (projThreeVolV/defTotal) * projThreePctV * 1.5;
                }
                
                // Estimate ratings (very rough approximation)
                // ORTG ≈ base + efg_impact + other_factors
                const baseOrtg = 110;
                const baseDefRtg = 110;
                const efgToRtg = 1.2; // rough multiplier
                
                const estimatedOrtg = baseOrtg + (modeledOffEfg - projectedOffEfg) * efgToRtg + 
                    summedStats.offTov * -0.5 * reliabilityWeight + 
                    summedStats.offOreb * 0.3 * reliabilityWeight + 
                    summedStats.offFtR * 0.2 * reliabilityWeight;
                const estimatedDefRtg = baseDefRtg + (modeledDefEfg - projectedDefEfg) * efgToRtg + 
                    summedStats.defTov * -0.5 * reliabilityWeight + 
                    summedStats.defOreb * 0.3 * reliabilityWeight + 
                    summedStats.defFtR * 0.2 * reliabilityWeight;
                const estimatedNet = estimatedOrtg - estimatedDefRtg;
                
                setBuilderResults({
                    players: selectedPlayers,
                    playerBreakdowns,
                    playerBoxStats,
                    summedStats,
                    modeledOffEfg,
                    modeledDefEfg,
                    estimatedOrtg,
                    estimatedDefRtg,
                    estimatedNet,
                    efgModelWeight,
                    reliabilityWeight, // V4.3.7: Add reliability weight to results
                    totalOnPoss, // V4.3.7: Add sample size
                    leagueAvgOffEfg: projectedOffEfg,
                    leagueAvgDefEfg: projectedDefEfg
                });
            }, [builderPlayers, onOffData, playerData, efgModelWeight, leagueAvgShotStats]);

            // =======================================================================
            // V4.3: BEST PLAYER COMBINATIONS VS OPPONENT
            // Calculates optimal player combinations based on stat impact weights
            // Uses the On/Off differential stats from onOffData
            // =======================================================================
            const calculateBestCombos = useCallback(() => {
                if (!combosOppTeam || !matchupData.length || !onOffData.length) {
                    setCombosResults({ error: 'Select an opponent team and ensure data is loaded' });
                    return;
                }
                
                setIsCalculatingCombos(true);
                
                // Step 1: Get matchups vs this opponent team
                const oppMatchups = [];
                matchupData.forEach(m => {
                    const poss = parseFloat(m.Possessions) || 0;
                    if (poss < 1) return;
                    
                    if (m.Home_Team === team && m.Away_Team === combosOppTeam) {
                        oppMatchups.push({ m, isHome: true });
                    } else if (m.Away_Team === team && m.Home_Team === combosOppTeam) {
                        oppMatchups.push({ m, isHome: false });
                    }
                });
                
                if (oppMatchups.length < 3) {
                    setCombosResults({ error: 'Need at least 3 matchups vs ' + combosOppTeam + ' (found ' + oppMatchups.length + ')' });
                    setIsCalculatingCombos(false);
                    setShowCombosModal(true);
                    return;
                }
                
                // Step 2: Calculate stat impacts vs this opponent (similar to calculateStatImpact)
                const matchupStats = oppMatchups.map(({ m, isHome }) => {
                    const fgm = isHome ? parseFloat(m.Home_FGM)||0 : parseFloat(m.Away_FGM)||0;
                    const fga = isHome ? parseFloat(m.Home_FGA)||0 : parseFloat(m.Away_FGA)||0;
                    const tpm = isHome ? parseFloat(m['Home_3PM'])||0 : parseFloat(m['Away_3PM'])||0;
                    const fta = isHome ? parseFloat(m.Home_FTA)||0 : parseFloat(m.Away_FTA)||0;
                    const ftm = isHome ? parseFloat(m.Home_FTM)||0 : parseFloat(m.Away_FTM)||0;
                    const oreb = isHome ? parseFloat(m.Home_OREB)||0 : parseFloat(m.Away_OREB)||0;
                    const dreb = isHome ? parseFloat(m.Home_DREB)||0 : parseFloat(m.Away_DREB)||0;
                    const tov = isHome ? parseFloat(m.Home_TOV)||0 : parseFloat(m.Away_TOV)||0;
                    const ast = isHome ? parseFloat(m.Home_AST)||0 : parseFloat(m.Away_AST)||0;
                    const stl = isHome ? parseFloat(m.Home_STL)||0 : parseFloat(m.Away_STL)||0;
                    const blk = isHome ? parseFloat(m.Home_BLK)||0 : parseFloat(m.Away_BLK)||0;
                    
                    const fgmV = isHome ? parseFloat(m.Away_FGM)||0 : parseFloat(m.Home_FGM)||0;
                    const fgaV = isHome ? parseFloat(m.Away_FGA)||0 : parseFloat(m.Home_FGA)||0;
                    const tpmV = isHome ? parseFloat(m['Away_3PM'])||0 : parseFloat(m['Home_3PM'])||0;
                    const ftaV = isHome ? parseFloat(m.Away_FTA)||0 : parseFloat(m.Home_FTA)||0;
                    const ftmV = isHome ? parseFloat(m.Away_FTM)||0 : parseFloat(m.Home_FTM)||0;
                    const orebV = isHome ? parseFloat(m.Away_OREB)||0 : parseFloat(m.Home_OREB)||0;
                    const drebV = isHome ? parseFloat(m.Away_DREB)||0 : parseFloat(m.Home_DREB)||0;
                    const tovV = isHome ? parseFloat(m.Away_TOV)||0 : parseFloat(m.Home_TOV)||0;
                    
                    const poss = calcPoss(fga, oreb, tov, fta);
                    const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                    const pts = 2 * fgm + tpm + ftm;
                    const ptsV = 2 * fgmV + tpmV + ftmV;
                    
                    return {
                        lineup: isHome ? m.Home_Lineup : m.Away_Lineup,
                        poss, possV,
                        offRtg: poss > 0 ? (pts / poss) * 100 : 0,
                        defRtg: possV > 0 ? (ptsV / possV) * 100 : 0,
                        offEfg: fga > 0 ? ((fgm + 0.5*tpm)/fga)*100 : 0,
                        offTov: poss > 0 ? (tov/poss)*100 : 0,
                        offOreb: (oreb+drebV) > 0 ? (oreb/(oreb+drebV))*100 : 0,
                        offFtR: fga > 0 ? (fta/fga)*100 : 0,
                        defEfg: fgaV > 0 ? ((fgmV + 0.5*tpmV)/fgaV)*100 : 0,
                        defTov: possV > 0 ? (tovV/possV)*100 : 0,
                        defOreb: (orebV+dreb) > 0 ? (orebV/(orebV+dreb))*100 : 0,
                        defFtR: fgaV > 0 ? (ftaV/fgaV)*100 : 0,
                        stlPct: possV > 0 ? (stl/possV)*100 : 0,
                        blkPct: (fgaV*0.65) > 0 ? (blk/(fgaV*0.65))*100 : 0
                    };
                }).filter(s => s.poss >= 1);
                
                // Step 3: Calculate regression slopes to get stat weights
                // V4.6.2: Use slopes (β = SS_XY/SS_XX) instead of correlations
                // Slope gives expected change in rating per unit change in stat (proper units)
                const calcSlope = (xArr, yArr) => {
                    const n = xArr.length;
                    if (n < 2) return 0;
                    const mx = xArr.reduce((a,b) => a+b, 0) / n;
                    const my = yArr.reduce((a,b) => a+b, 0) / n;
                    let sxy = 0, sxx = 0;
                    for (let i = 0; i < n; i++) {
                        sxy += (xArr[i] - mx) * (yArr[i] - my);
                        sxx += (xArr[i] - mx) ** 2;
                    }
                    return sxx > 0 ? sxy / sxx : 0; // β = SS_XY / SS_XX
                };
                
                const offRtgArr = matchupStats.map(s => s.offRtg);
                const defRtgArr = matchupStats.map(s => s.defRtg);
                
                // V4.6.2: Stat weights based on regression slope with ratings
                // Slope β tells us: "Expected ΔORTG per unit Δstat"
                // Sign logic for defense: we want positive weights for stats where higher = better defense
                const statWeights = {
                    // Offensive: slope with ORTG (positive slope = higher stat → higher ORTG)
                    offEfg: calcSlope(matchupStats.map(s => s.offEfg), offRtgArr),
                    offTov: calcSlope(matchupStats.map(s => s.offTov), offRtgArr), // Expected: negative (more TOV → lower ORTG)
                    offOreb: calcSlope(matchupStats.map(s => s.offOreb), offRtgArr),
                    offFtR: calcSlope(matchupStats.map(s => s.offFtR), offRtgArr),
                    // Defensive: we NEGATE slopes because lower DRTG = better defense
                    // If β > 0 (stat↑ → DRTG↑), negating makes weight negative (bad for defense)
                    // If β < 0 (stat↑ → DRTG↓), negating makes weight positive (good for defense)
                    defEfg: -calcSlope(matchupStats.map(s => s.defEfg), defRtgArr), // β>0 expected, so weight<0 (allowing more eFG% is bad)
                    defTov: -calcSlope(matchupStats.map(s => s.defTov), defRtgArr), // β<0 expected, so weight>0 (forcing more TOV is good)
                    defOreb: -calcSlope(matchupStats.map(s => s.defOreb), defRtgArr), // β>0 expected, so weight<0 (allowing more OREB is bad)
                    defFtR: -calcSlope(matchupStats.map(s => s.defFtR), defRtgArr), // β>0 expected, so weight<0 (allowing more FT is bad)
                    stlPct: -calcSlope(matchupStats.map(s => s.stlPct), defRtgArr), // β<0 expected, so weight>0 (more steals is good)
                    blkPct: -calcSlope(matchupStats.map(s => s.blkPct), defRtgArr)  // β<0 expected, so weight>0 (more blocks is good)
                };
                
                // Step 4: Get player On/Off impacts from onOffData
                // Filter to players on the selected team
                const teamOnOffData = onOffData.filter(d => d.team === team);
                
                const playerImpacts = new Map();
                teamOnOffData.forEach(d => {
                    if (!d.onStats || !d.offStats) return;
                    
                    // Calculate ON - OFF differential for each stat
                    playerImpacts.set(d.player, {
                        onPoss: d.onPoss,
                        offPoss: d.offPoss,
                        // Use the already-calculated on/off stats from onOffData
                        offEfg: (d.onStats.offEfg || 0) - (d.offStats.offEfg || 0),
                        offTov: (d.onStats.offTov || 0) - (d.offStats.offTov || 0),
                        offOreb: (d.onStats.offOreb || 0) - (d.offStats.offOreb || 0),
                        offFtR: (d.onStats.offFtR || 0) - (d.offStats.offFtR || 0),
                        defEfg: (d.onStats.defEfg || 0) - (d.offStats.defEfg || 0),
                        defTov: (d.onStats.defTov || 0) - (d.offStats.defTov || 0),
                        defOreb: (d.onStats.defOreb || 0) - (d.offStats.defOreb || 0),
                        defFtR: (d.onStats.defFtR || 0) - (d.offStats.defFtR || 0),
                        stlPct: (d.onStats.stlPct || 0) - (d.offStats.stlPct || 0),
                        blkPct: (d.onStats.blkPct || 0) - (d.offStats.blkPct || 0),
                        // V4.3.5: Shot distance stats for eFG modeling
                        rimPct: (d.onStats.rimPct || 0) - (d.offStats.rimPct || 0),
                        midPct: (d.onStats.midPct || 0) - (d.offStats.midPct || 0),
                        threePct: (d.onStats.threePct || 0) - (d.offStats.threePct || 0),
                        rimVol: (d.onStats.rimVol || 0) - (d.offStats.rimVol || 0),
                        midVol: (d.onStats.midVol || 0) - (d.offStats.midVol || 0),
                        threeVol: (d.onStats.threeVol || 0) - (d.offStats.threeVol || 0),
                        rimPctV: (d.onStats.rimPctV || 0) - (d.offStats.rimPctV || 0),
                        midPctV: (d.onStats.midPctV || 0) - (d.offStats.midPctV || 0),
                        threePctV: (d.onStats.threePctV || 0) - (d.offStats.threePctV || 0),
                        rimVolV: (d.onStats.rimVolV || 0) - (d.offStats.rimVolV || 0),
                        midVolV: (d.onStats.midVolV || 0) - (d.offStats.midVolV || 0),
                        threeVolV: (d.onStats.threeVolV || 0) - (d.offStats.threeVolV || 0),
                        // Also store the actual on/off values for display
                        onNet: d.onStats.net || 0,
                        offNet: d.offStats.net || 0,
                        netDiff: (d.onStats.net || 0) - (d.offStats.net || 0)
                    });
                });
                
                // Step 5: Generate all combinations of size N
                const validPlayers = teamOnOffData
                    .filter(d => d.onPoss >= combosMinPoss && playerImpacts.has(d.player))
                    .map(d => d.player);
                    
                if (validPlayers.length < combosSize) {
                    setCombosResults({ error: 'Not enough players with ' + combosMinPoss + '+ possessions (found ' + validPlayers.length + ', need ' + combosSize + ')' });
                    setIsCalculatingCombos(false);
                    setShowCombosModal(true);
                    return;
                }
                
                const combinations = [];
                
                const generateCombos = (arr, size, start = 0, current = []) => {
                    if (current.length === size) {
                        combinations.push([...current]);
                        return;
                    }
                    for (let i = start; i <= arr.length - (size - current.length); i++) {
                        current.push(arr[i]);
                        generateCombos(arr, size, i + 1, current);
                        current.pop();
                    }
                };
                
                generateCombos(validPlayers, Math.min(combosSize, validPlayers.length));
                
                // Step 6: Score each combination using on/off impacts weighted by opponent correlations
                // V4.3.7: Use reliability weighting based on sample size
                
                const scoredCombos = combinations.map(combo => {
                    let offScore = 0, defScore = 0;
                    let totalOnPoss = 0;
                    
                    const comboImpacts = { offEfg: 0, offTov: 0, offOreb: 0, offFtR: 0, defEfg: 0, defTov: 0, defOreb: 0, defFtR: 0, stlPct: 0, blkPct: 0 };
                    // V4.3.5: Track shot distance impacts for eFG modeling
                    const shotImpacts = { rimPct: 0, midPct: 0, threePct: 0, rimVol: 0, midVol: 0, threeVol: 0, rimPctV: 0, midPctV: 0, threePctV: 0, rimVolV: 0, midVolV: 0, threeVolV: 0 };
                    let sumNetDiff = 0;
                    
                    combo.forEach(player => {
                        const imp = playerImpacts.get(player);
                        if (!imp) return;
                        totalOnPoss += imp.onPoss;
                        sumNetDiff += imp.netDiff;
                        
                        Object.keys(comboImpacts).forEach(stat => {
                            comboImpacts[stat] += imp[stat];
                        });
                        
                        // V4.3.5: Add shot distance impacts
                        Object.keys(shotImpacts).forEach(stat => {
                            if (imp[stat] !== undefined) shotImpacts[stat] += imp[stat];
                        });
                    });
                    
                    // V4.3.7: Calculate reliability weight based on sample size
                    // k = efgModelWeight controls prior strength (possessions needed for ~50% weight)
                    const k = efgModelWeight * Math.sqrt(combo.length);
                    const reliabilityWeight = totalOnPoss / (totalOnPoss + k);
                    
                    // V4.3.7: Calculate modeled eFG% from shot impacts with reliability weighting
                    let modeledOffEfg = null, modeledDefEfg = null;
                    if (leagueAvgShotStats) {
                        const projRimPct = Math.max(40, Math.min(80, leagueAvgShotStats.rimPct + shotImpacts.rimPct * reliabilityWeight));
                        const projMidPct = Math.max(25, Math.min(60, leagueAvgShotStats.midPct + shotImpacts.midPct * reliabilityWeight));
                        const projThreePct = Math.max(25, Math.min(50, leagueAvgShotStats.threePct + shotImpacts.threePct * reliabilityWeight));
                        let projRimVol = leagueAvgShotStats.rimVol + shotImpacts.rimVol * reliabilityWeight;
                        let projMidVol = leagueAvgShotStats.midVol + shotImpacts.midVol * reliabilityWeight;
                        let projThreeVol = leagueAvgShotStats.threeVol + shotImpacts.threeVol * reliabilityWeight;
                        
                        // Normalize volumes
                        const totalVol = Math.max(1, projRimVol + projMidVol + projThreeVol);
                        const scale = 80 / totalVol;
                        projRimVol = Math.max(5, projRimVol * scale);
                        projMidVol = Math.max(5, projMidVol * scale);
                        projThreeVol = Math.max(5, projThreeVol * scale);
                        const offTotal = projRimVol + projMidVol + projThreeVol;
                        
                        if (offTotal > 0) {
                            modeledOffEfg = (projRimVol/offTotal) * projRimPct + (projMidVol/offTotal) * projMidPct + (projThreeVol/offTotal) * projThreePct * 1.5;
                        }
                        
                        // Defensive
                        const projRimPctV = Math.max(40, Math.min(80, leagueAvgShotStats.rimPctV + shotImpacts.rimPctV * reliabilityWeight));
                        const projMidPctV = Math.max(25, Math.min(60, leagueAvgShotStats.midPctV + shotImpacts.midPctV * reliabilityWeight));
                        const projThreePctV = Math.max(25, Math.min(50, leagueAvgShotStats.threePctV + shotImpacts.threePctV * reliabilityWeight));
                        let projRimVolV = leagueAvgShotStats.rimVolV + shotImpacts.rimVolV * reliabilityWeight;
                        let projMidVolV = leagueAvgShotStats.midVolV + shotImpacts.midVolV * reliabilityWeight;
                        let projThreeVolV = leagueAvgShotStats.threeVolV + shotImpacts.threeVolV * reliabilityWeight;
                        
                        const totalVolV = Math.max(1, projRimVolV + projMidVolV + projThreeVolV);
                        const scaleV = 80 / totalVolV;
                        projRimVolV = Math.max(5, projRimVolV * scaleV);
                        projMidVolV = Math.max(5, projMidVolV * scaleV);
                        projThreeVolV = Math.max(5, projThreeVolV * scaleV);
                        const defTotal = projRimVolV + projMidVolV + projThreeVolV;
                        
                        if (defTotal > 0) {
                            modeledDefEfg = (projRimVolV/defTotal) * projRimPctV + (projMidVolV/defTotal) * projMidPctV + (projThreeVolV/defTotal) * projThreePctV * 1.5;
                        }
                    }
                    
                    // Calculate weighted score based on stat correlations with opponent
                    // Offensive score: sum of (player on/off impact * correlation weight)
                    offScore = (comboImpacts.offEfg * statWeights.offEfg) +
                               (comboImpacts.offTov * statWeights.offTov) +
                               (comboImpacts.offOreb * statWeights.offOreb) +
                               (comboImpacts.offFtR * statWeights.offFtR);
                    
                    // Defensive score
                    defScore = (comboImpacts.defEfg * statWeights.defEfg) +
                               (comboImpacts.defTov * statWeights.defTov) +
                               (comboImpacts.defOreb * statWeights.defOreb) +
                               (comboImpacts.defFtR * statWeights.defFtR) +
                               (comboImpacts.stlPct * statWeights.stlPct) +
                               (comboImpacts.blkPct * statWeights.blkPct);
                    
                    // V4.3.5: Add modeled eFG bonus to scores (normalized impact)
                    const leagueOffEfg = leagueAvgShotStats ? leagueAvgShotStats.rimPct * 0.35 + leagueAvgShotStats.midPct * 0.15 + leagueAvgShotStats.threePct * 0.5 * 1.5 : 52;
                    const leagueDefEfg = leagueAvgShotStats ? leagueAvgShotStats.rimPctV * 0.35 + leagueAvgShotStats.midPctV * 0.15 + leagueAvgShotStats.threePctV * 0.5 * 1.5 : 52;
                    const efgOffBonus = modeledOffEfg ? (modeledOffEfg - leagueOffEfg) * 0.5 : 0;
                    const efgDefBonus = modeledDefEfg ? -(modeledDefEfg - leagueDefEfg) * 0.5 : 0; // Lower opp eFG = better defense
                    
                    return {
                        players: combo,
                        offScore: offScore + efgOffBonus,
                        defScore: defScore + efgDefBonus,
                        netScore: offScore + defScore + efgOffBonus + efgDefBonus,
                        impacts: comboImpacts,
                        avgOnPoss: totalOnPoss / combo.length,
                        sumNetDiff, // Sum of raw On-Off Net Rating differences
                        modeledOffEfg,
                        modeledDefEfg
                    };
                });
                
                // Sort by net score
                scoredCombos.sort((a, b) => b.netScore - a.netScore);
                
                setCombosResults({
                    oppTeam: combosOppTeam,
                    comboSize: combosSize,
                    matchupCount: oppMatchups.length,
                    totalCombos: scoredCombos.length,
                    statWeights,
                    playerImpactsUsed: Array.from(playerImpacts.entries()).map(([player, imp]) => ({ player, ...imp })),
                    bestOffense: [...scoredCombos].sort((a, b) => b.offScore - a.offScore).slice(0, 10),
                    bestDefense: [...scoredCombos].sort((a, b) => b.defScore - a.defScore).slice(0, 10),
                    bestNet: scoredCombos.slice(0, 10),
                    worstNet: scoredCombos.slice(-10).reverse()
                });
                
                setIsCalculatingCombos(false);
                setShowCombosModal(true);
            }, [combosOppTeam, combosSize, combosMinPoss, matchupData, team, onOffData, efgModelWeight, leagueAvgShotStats]);

            // =======================================================================
            // V4.3.5: BEST PLAYER COMBINATIONS VS SELECTED OPPONENT PLAYERS
            // Same methodology as calculateBestCombos but filters matchups by
            // opponent lineups containing the selected players (Include/Exclude filters)
            // counterTeam = the team whose player combinations we want to find
            // =======================================================================
            const calculateCounterLineups = useCallback(() => {
                const selectedPlayers = Object.values(selPlayers).filter(p => p !== '');
                const excludedPlayers = Object.values(exPlayers).filter(p => p !== '');
                
                if (selectedPlayers.length === 0) {
                    setCounterResults({ error: 'Select at least one opponent player using the Include Players filter' });
                    setShowCounterModal(true);
                    return;
                }
                
                if (!counterTeam) {
                    setCounterResults({ error: 'Select a team to find best combinations for' });
                    setShowCounterModal(true);
                    return;
                }
                
                if (!matchupData.length || !onOffData.length) {
                    setCounterResults({ error: 'Matchup data and lineup data are required for this analysis' });
                    setShowCounterModal(true);
                    return;
                }
                
                setIsCalculatingCounter(true);
                
                // Normalize selected player names for matching
                const selectedNorm = selectedPlayers.map(p => normalizePlayerName(p));
                const excludedNorm = excludedPlayers.map(p => normalizePlayerName(p));
                
                // Step 1: Find all matchups where:
                // - counterTeam is playing
                // - opponent lineup contains ALL selected players (and excludes excluded players)
                const oppMatchups = [];
                matchupData.forEach(m => {
                    const poss = parseFloat(m.Possessions) || 0;
                    if (poss < 1) return;
                    
                    // Check if counterTeam is Home or Away
                    const isHome = m.Home_Team === counterTeam;
                    const isAway = m.Away_Team === counterTeam;
                    if (!isHome && !isAway) return;
                    
                    // Get opponent lineup players (the lineup we're trying to counter)
                    const oppLineup = isHome ? m.Away_Lineup : m.Home_Lineup;
                    if (!oppLineup) return;
                    
                    const oppPlayers = oppLineup.split(',').map(p => normalizePlayerName(p.trim()));
                    
                    // Check if opponent lineup contains ALL selected players
                    const hasAllSelected = selectedNorm.every(sp => oppPlayers.some(op => op === sp));
                    if (!hasAllSelected) return;
                    
                    // Check if opponent lineup excludes ALL excluded players
                    if (excludedNorm.length > 0) {
                        const hasExcluded = excludedNorm.some(ep => oppPlayers.some(op => op === ep));
                        if (hasExcluded) return;
                    }
                    
                    oppMatchups.push({ m, isHome });
                });
                
                if (oppMatchups.length < 3) {
                    setCounterResults({ 
                        error: 'Need at least 3 matchups where ' + counterTeam + ' faced lineups with ' + selectedPlayers.join(' + ') + 
                               (excludedPlayers.length > 0 ? ' (excl. ' + excludedPlayers.join(', ') + ')' : '') +
                               ' (found ' + oppMatchups.length + ')'
                    });
                    setIsCalculatingCounter(false);
                    setShowCounterModal(true);
                    return;
                }
                
                // Step 2: Calculate stat impacts from these matchups
                const matchupStats = oppMatchups.map(({ m, isHome }) => {
                    const fgm = isHome ? parseFloat(m.Home_FGM)||0 : parseFloat(m.Away_FGM)||0;
                    const fga = isHome ? parseFloat(m.Home_FGA)||0 : parseFloat(m.Away_FGA)||0;
                    const tpm = isHome ? parseFloat(m['Home_3PM'])||0 : parseFloat(m['Away_3PM'])||0;
                    const fta = isHome ? parseFloat(m.Home_FTA)||0 : parseFloat(m.Away_FTA)||0;
                    const ftm = isHome ? parseFloat(m.Home_FTM)||0 : parseFloat(m.Away_FTM)||0;
                    const oreb = isHome ? parseFloat(m.Home_OREB)||0 : parseFloat(m.Away_OREB)||0;
                    const dreb = isHome ? parseFloat(m.Home_DREB)||0 : parseFloat(m.Away_DREB)||0;
                    const tov = isHome ? parseFloat(m.Home_TOV)||0 : parseFloat(m.Away_TOV)||0;
                    const stl = isHome ? parseFloat(m.Home_STL)||0 : parseFloat(m.Away_STL)||0;
                    const blk = isHome ? parseFloat(m.Home_BLK)||0 : parseFloat(m.Away_BLK)||0;
                    
                    const fgmV = isHome ? parseFloat(m.Away_FGM)||0 : parseFloat(m.Home_FGM)||0;
                    const fgaV = isHome ? parseFloat(m.Away_FGA)||0 : parseFloat(m.Home_FGA)||0;
                    const tpmV = isHome ? parseFloat(m['Away_3PM'])||0 : parseFloat(m['Home_3PM'])||0;
                    const ftaV = isHome ? parseFloat(m.Away_FTA)||0 : parseFloat(m.Home_FTA)||0;
                    const ftmV = isHome ? parseFloat(m.Away_FTM)||0 : parseFloat(m.Home_FTM)||0;
                    const orebV = isHome ? parseFloat(m.Away_OREB)||0 : parseFloat(m.Home_OREB)||0;
                    const drebV = isHome ? parseFloat(m.Away_DREB)||0 : parseFloat(m.Home_DREB)||0;
                    const tovV = isHome ? parseFloat(m.Away_TOV)||0 : parseFloat(m.Home_TOV)||0;
                    
                    const poss = calcPoss(fga, oreb, tov, fta);
                    const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                    const pts = 2 * fgm + tpm + ftm;
                    const ptsV = 2 * fgmV + tpmV + ftmV;
                    
                    return {
                        lineup: isHome ? m.Home_Lineup : m.Away_Lineup,
                        poss, possV,
                        offRtg: poss > 0 ? (pts / poss) * 100 : 0,
                        defRtg: possV > 0 ? (ptsV / possV) * 100 : 0,
                        offEfg: fga > 0 ? ((fgm + 0.5*tpm)/fga)*100 : 0,
                        offTov: poss > 0 ? (tov/poss)*100 : 0,
                        offOreb: (oreb+drebV) > 0 ? (oreb/(oreb+drebV))*100 : 0,
                        offFtR: fga > 0 ? (fta/fga)*100 : 0,
                        defEfg: fgaV > 0 ? ((fgmV + 0.5*tpmV)/fgaV)*100 : 0,
                        defTov: possV > 0 ? (tovV/possV)*100 : 0,
                        defOreb: (orebV+dreb) > 0 ? (orebV/(orebV+dreb))*100 : 0,
                        defFtR: fgaV > 0 ? (ftaV/fgaV)*100 : 0,
                        stlPct: possV > 0 ? (stl/possV)*100 : 0,
                        blkPct: (fgaV*0.65) > 0 ? (blk/(fgaV*0.65))*100 : 0
                    };
                }).filter(s => s.poss >= 1);
                
                // Step 3: Calculate regression slopes to get stat weights
                // V4.6.2: Use slopes (β = SS_XY/SS_XX) instead of correlations
                const calcSlope = (xArr, yArr) => {
                    const n = xArr.length;
                    if (n < 2) return 0;
                    const mx = xArr.reduce((a,b) => a+b, 0) / n;
                    const my = yArr.reduce((a,b) => a+b, 0) / n;
                    let sxy = 0, sxx = 0;
                    for (let i = 0; i < n; i++) {
                        sxy += (xArr[i] - mx) * (yArr[i] - my);
                        sxx += (xArr[i] - mx) ** 2;
                    }
                    return sxx > 0 ? sxy / sxx : 0;
                };
                
                const offRtgArr = matchupStats.map(s => s.offRtg);
                const defRtgArr = matchupStats.map(s => s.defRtg);
                
                // V4.6.2: Stat weights based on regression slope
                const statWeights = {
                    offEfg: calcSlope(matchupStats.map(s => s.offEfg), offRtgArr),
                    offTov: calcSlope(matchupStats.map(s => s.offTov), offRtgArr),
                    offOreb: calcSlope(matchupStats.map(s => s.offOreb), offRtgArr),
                    offFtR: calcSlope(matchupStats.map(s => s.offFtR), offRtgArr),
                    defEfg: -calcSlope(matchupStats.map(s => s.defEfg), defRtgArr),
                    defTov: -calcSlope(matchupStats.map(s => s.defTov), defRtgArr), // V4.6.2: Fixed sign
                    defOreb: -calcSlope(matchupStats.map(s => s.defOreb), defRtgArr),
                    defFtR: -calcSlope(matchupStats.map(s => s.defFtR), defRtgArr),
                    stlPct: -calcSlope(matchupStats.map(s => s.stlPct), defRtgArr),
                    blkPct: -calcSlope(matchupStats.map(s => s.blkPct), defRtgArr)
                };
                
                // Step 4: Get player On/Off impacts from onOffData for the COUNTER TEAM
                const teamOnOffData = onOffData.filter(d => d.team === counterTeam);
                
                const playerImpacts = new Map();
                teamOnOffData.forEach(d => {
                    if (!d.onStats || !d.offStats) return;
                    
                    playerImpacts.set(d.player, {
                        onPoss: d.onPoss,
                        offPoss: d.offPoss,
                        offEfg: (d.onStats.offEfg || 0) - (d.offStats.offEfg || 0),
                        offTov: (d.onStats.offTov || 0) - (d.offStats.offTov || 0),
                        offOreb: (d.onStats.offOreb || 0) - (d.offStats.offOreb || 0),
                        offFtR: (d.onStats.offFtR || 0) - (d.offStats.offFtR || 0),
                        defEfg: (d.onStats.defEfg || 0) - (d.offStats.defEfg || 0),
                        defTov: (d.onStats.defTov || 0) - (d.offStats.defTov || 0),
                        defOreb: (d.onStats.defOreb || 0) - (d.offStats.defOreb || 0),
                        defFtR: (d.onStats.defFtR || 0) - (d.offStats.defFtR || 0),
                        stlPct: (d.onStats.stlPct || 0) - (d.offStats.stlPct || 0),
                        blkPct: (d.onStats.blkPct || 0) - (d.offStats.blkPct || 0),
                        // V4.3.5: Shot distance stats for eFG modeling
                        rimPct: (d.onStats.rimPct || 0) - (d.offStats.rimPct || 0),
                        midPct: (d.onStats.midPct || 0) - (d.offStats.midPct || 0),
                        threePct: (d.onStats.threePct || 0) - (d.offStats.threePct || 0),
                        rimVol: (d.onStats.rimVol || 0) - (d.offStats.rimVol || 0),
                        midVol: (d.onStats.midVol || 0) - (d.offStats.midVol || 0),
                        threeVol: (d.onStats.threeVol || 0) - (d.offStats.threeVol || 0),
                        rimPctV: (d.onStats.rimPctV || 0) - (d.offStats.rimPctV || 0),
                        midPctV: (d.onStats.midPctV || 0) - (d.offStats.midPctV || 0),
                        threePctV: (d.onStats.threePctV || 0) - (d.offStats.threePctV || 0),
                        rimVolV: (d.onStats.rimVolV || 0) - (d.offStats.rimVolV || 0),
                        midVolV: (d.onStats.midVolV || 0) - (d.offStats.midVolV || 0),
                        threeVolV: (d.onStats.threeVolV || 0) - (d.offStats.threeVolV || 0),
                        onNet: d.onStats.net || 0,
                        offNet: d.offStats.net || 0,
                        netDiff: (d.onStats.net || 0) - (d.offStats.net || 0)
                    });
                });
                
                // Step 5: Generate all combinations of size N
                const validPlayers = teamOnOffData
                    .filter(d => d.onPoss >= counterMinPoss && playerImpacts.has(d.player))
                    .map(d => d.player);
                    
                if (validPlayers.length < counterComboSize) {
                    setCounterResults({ error: 'Not enough ' + counterTeam + ' players with ' + counterMinPoss + '+ possessions (found ' + validPlayers.length + ', need ' + counterComboSize + ')' });
                    setIsCalculatingCounter(false);
                    setShowCounterModal(true);
                    return;
                }
                
                const combinations = [];
                
                const generateCombos = (arr, size, start = 0, current = []) => {
                    if (current.length === size) {
                        combinations.push([...current]);
                        return;
                    }
                    for (let i = start; i <= arr.length - (size - current.length); i++) {
                        current.push(arr[i]);
                        generateCombos(arr, size, i + 1, current);
                        current.pop();
                    }
                };
                
                generateCombos(validPlayers, Math.min(counterComboSize, validPlayers.length));
                
                // Step 6: Score each combination using on/off impacts weighted by opponent correlations
                // V4.3.7: Use reliability weighting based on sample size
                
                const scoredCombos = combinations.map(combo => {
                    let offScore = 0, defScore = 0;
                    let totalOnPoss = 0;
                    
                    const comboImpacts = { offEfg: 0, offTov: 0, offOreb: 0, offFtR: 0, defEfg: 0, defTov: 0, defOreb: 0, defFtR: 0, stlPct: 0, blkPct: 0 };
                    // V4.3.5: Track shot distance impacts for eFG modeling
                    const shotImpacts = { rimPct: 0, midPct: 0, threePct: 0, rimVol: 0, midVol: 0, threeVol: 0, rimPctV: 0, midPctV: 0, threePctV: 0, rimVolV: 0, midVolV: 0, threeVolV: 0 };
                    let sumNetDiff = 0;
                    
                    combo.forEach(player => {
                        const imp = playerImpacts.get(player);
                        if (!imp) return;
                        totalOnPoss += imp.onPoss;
                        sumNetDiff += imp.netDiff;
                        
                        Object.keys(comboImpacts).forEach(stat => {
                            comboImpacts[stat] += imp[stat];
                        });
                        
                        // V4.3.5: Add shot distance impacts
                        Object.keys(shotImpacts).forEach(stat => {
                            if (imp[stat] !== undefined) shotImpacts[stat] += imp[stat];
                        });
                    });
                    
                    // V4.3.7: Calculate reliability weight based on sample size
                    const k = efgModelWeight * Math.sqrt(combo.length);
                    const reliabilityWeight = totalOnPoss / (totalOnPoss + k);
                    
                    // V4.3.7: Calculate modeled eFG% from shot impacts with reliability weighting
                    let modeledOffEfg = null, modeledDefEfg = null;
                    if (leagueAvgShotStats) {
                        const projRimPct = Math.max(40, Math.min(80, leagueAvgShotStats.rimPct + shotImpacts.rimPct * reliabilityWeight));
                        const projMidPct = Math.max(25, Math.min(60, leagueAvgShotStats.midPct + shotImpacts.midPct * reliabilityWeight));
                        const projThreePct = Math.max(25, Math.min(50, leagueAvgShotStats.threePct + shotImpacts.threePct * reliabilityWeight));
                        let projRimVol = leagueAvgShotStats.rimVol + shotImpacts.rimVol * reliabilityWeight;
                        let projMidVol = leagueAvgShotStats.midVol + shotImpacts.midVol * reliabilityWeight;
                        let projThreeVol = leagueAvgShotStats.threeVol + shotImpacts.threeVol * reliabilityWeight;
                        
                        const totalVol = Math.max(1, projRimVol + projMidVol + projThreeVol);
                        const scale = 80 / totalVol;
                        projRimVol = Math.max(5, projRimVol * scale);
                        projMidVol = Math.max(5, projMidVol * scale);
                        projThreeVol = Math.max(5, projThreeVol * scale);
                        const offTotal = projRimVol + projMidVol + projThreeVol;
                        
                        if (offTotal > 0) {
                            modeledOffEfg = (projRimVol/offTotal) * projRimPct + (projMidVol/offTotal) * projMidPct + (projThreeVol/offTotal) * projThreePct * 1.5;
                        }
                        
                        const projRimPctV = Math.max(40, Math.min(80, leagueAvgShotStats.rimPctV + shotImpacts.rimPctV * reliabilityWeight));
                        const projMidPctV = Math.max(25, Math.min(60, leagueAvgShotStats.midPctV + shotImpacts.midPctV * reliabilityWeight));
                        const projThreePctV = Math.max(25, Math.min(50, leagueAvgShotStats.threePctV + shotImpacts.threePctV * reliabilityWeight));
                        let projRimVolV = leagueAvgShotStats.rimVolV + shotImpacts.rimVolV * reliabilityWeight;
                        let projMidVolV = leagueAvgShotStats.midVolV + shotImpacts.midVolV * reliabilityWeight;
                        let projThreeVolV = leagueAvgShotStats.threeVolV + shotImpacts.threeVolV * reliabilityWeight;
                        
                        const totalVolV = Math.max(1, projRimVolV + projMidVolV + projThreeVolV);
                        const scaleV = 80 / totalVolV;
                        projRimVolV = Math.max(5, projRimVolV * scaleV);
                        projMidVolV = Math.max(5, projMidVolV * scaleV);
                        projThreeVolV = Math.max(5, projThreeVolV * scaleV);
                        const defTotal = projRimVolV + projMidVolV + projThreeVolV;
                        
                        if (defTotal > 0) {
                            modeledDefEfg = (projRimVolV/defTotal) * projRimPctV + (projMidVolV/defTotal) * projMidPctV + (projThreeVolV/defTotal) * projThreePctV * 1.5;
                        }
                    }
                    
                    offScore = (comboImpacts.offEfg * statWeights.offEfg) +
                               (comboImpacts.offTov * statWeights.offTov) +
                               (comboImpacts.offOreb * statWeights.offOreb) +
                               (comboImpacts.offFtR * statWeights.offFtR);
                    
                    defScore = (comboImpacts.defEfg * statWeights.defEfg) +
                               (comboImpacts.defTov * statWeights.defTov) +
                               (comboImpacts.defOreb * statWeights.defOreb) +
                               (comboImpacts.defFtR * statWeights.defFtR) +
                               (comboImpacts.stlPct * statWeights.stlPct) +
                               (comboImpacts.blkPct * statWeights.blkPct);
                    
                    // V4.3.7: Add modeled eFG bonus to scores (scaled by reliability)
                    const leagueOffEfg = leagueAvgShotStats ? leagueAvgShotStats.rimPct * 0.35 + leagueAvgShotStats.midPct * 0.15 + leagueAvgShotStats.threePct * 0.5 * 1.5 : 52;
                    const leagueDefEfg = leagueAvgShotStats ? leagueAvgShotStats.rimPctV * 0.35 + leagueAvgShotStats.midPctV * 0.15 + leagueAvgShotStats.threePctV * 0.5 * 1.5 : 52;
                    const efgOffBonus = modeledOffEfg ? (modeledOffEfg - leagueOffEfg) * 0.5 : 0;
                    const efgDefBonus = modeledDefEfg ? -(modeledDefEfg - leagueDefEfg) * 0.5 : 0;
                    
                    return {
                        players: combo,
                        offScore: offScore + efgOffBonus,
                        defScore: defScore + efgDefBonus,
                        netScore: offScore + defScore + efgOffBonus + efgDefBonus,
                        impacts: comboImpacts,
                        avgOnPoss: totalOnPoss / combo.length,
                        sumNetDiff,
                        modeledOffEfg,
                        modeledDefEfg,
                        reliabilityWeight // V4.3.7: Track reliability
                    };
                });
                
                // Sort by net score
                scoredCombos.sort((a, b) => b.netScore - a.netScore);
                
                setCounterResults({
                    counterTeam,
                    targetPlayers: selectedPlayers,
                    excludedPlayers,
                    comboSize: counterComboSize,
                    matchupCount: oppMatchups.length,
                    totalCombos: scoredCombos.length,
                    statWeights,
                    playerImpactsUsed: Array.from(playerImpacts.entries()).map(([player, imp]) => ({ player, ...imp })),
                    bestOffense: [...scoredCombos].sort((a, b) => b.offScore - a.offScore).slice(0, 10),
                    bestDefense: [...scoredCombos].sort((a, b) => b.defScore - a.defScore).slice(0, 10),
                    bestNet: scoredCombos.slice(0, 10),
                    worstNet: scoredCombos.slice(-10).reverse()
                });
                
                setIsCalculatingCounter(false);
                setShowCounterModal(true);
            }, [selPlayers, exPlayers, matchupData, counterTeam, counterComboSize, counterMinPoss, onOffData, efgModelWeight, leagueAvgShotStats]);

            // Get matchups for a specific lineup
            const getLineupMatchups = useMemo(() => {
                return (lineupNorm) => {
                    if (!matchupData.length || !lineupNorm) return [];
                    return matchupData.filter(m => {
                        const homeNorm = normalizeLineup(m.Home_Lineup);
                        const awayNorm = normalizeLineup(m.Away_Lineup);
                        return (homeNorm === lineupNorm && m.Home_Team === team) || 
                               (awayNorm === lineupNorm && m.Away_Team === team);
                    }).map(m => {
                        const homeNorm = normalizeLineup(m.Home_Lineup);
                        const isHome = homeNorm === lineupNorm && m.Home_Team === team;
                        const oppLineup = isHome ? m.Away_Lineup : m.Home_Lineup;
                        const oppTeam = isHome ? m.Away_Team : m.Home_Team;
                        const oppNorm = normalizeLineup(oppLineup);
                        const oppStats = allLineupsMap.get(oppNorm);
                        return {
                            game: m.Game_ID || m.Game || 'Unknown',
                            oppTeam,
                            oppLineup,
                            poss: parseFloat(m.Possessions) || 0,
                            yourOff: isHome ? parseFloat(m.Home_OFF_RTG) || 0 : parseFloat(m.Away_OFF_RTG) || 0,
                            yourDef: isHome ? parseFloat(m.Home_DEF_RTG) || 0 : parseFloat(m.Away_DEF_RTG) || 0,
                            oppOff: isHome ? parseFloat(m.Away_OFF_RTG) || 0 : parseFloat(m.Home_OFF_RTG) || 0,
                            oppDef: isHome ? parseFloat(m.Away_DEF_RTG) || 0 : parseFloat(m.Home_DEF_RTG) || 0,
                            oppSeasonNet: oppStats ? oppStats.net : null,
                            oppSeasonOff: oppStats ? oppStats.off : null,
                            oppSeasonDef: oppStats ? oppStats.def : null,
                        };
                    }).sort((a, b) => b.poss - a.poss);
                };
            }, [matchupData, team, allLineupsMap]);

            // // Opponent quality calculation - AGGREGATES EXPECTED RAW STATS (V3.8 FIX)
            // Converts opponent per-possession rates to expected counting stats,
            // then calculates Four Factors from aggregated totals to match box score methodology
            // V4.2.3: Added minMatchupPoss filter and Bayesian shrinkage
            const oppQuality = useMemo(() => {
                if (!filtered.length || !matchupData.length || !allLineupsMap.size || !teamAvgArrays.net || !teamAvgArrays.net.length) return null;
                const filteredNormalized = new Set(filtered.map(l => l.normalizedLineup));
                
                // First pass: collect H2H totals by opponent lineup
                const oppH2HTotals = new Map();
                const relevantMatchups = [];
                
                matchupData.forEach(m => {
                    const homeNorm = normalizeLineup(m.Home_Lineup);
                    const awayNorm = normalizeLineup(m.Away_Lineup);
                    const poss = parseFloat(m.Possessions) || 0;
                    // V4.2.3: Apply minimum possession threshold
                    if (poss < Math.max(1, minMatchupPoss)) return;
                    
                    let oppLineupNorm = null;
                    let isHome = false;
                    if (filteredNormalized.has(homeNorm) && m.Home_Team === team) { 
                        oppLineupNorm = awayNorm; 
                        isHome = true; 
                    } else if (filteredNormalized.has(awayNorm) && m.Away_Team === team) { 
                        oppLineupNorm = homeNorm; 
                        isHome = false; 
                    }
                    if (!oppLineupNorm) return;
                    
                    const oppStats = allLineupsMap.get(oppLineupNorm);
                    if (!oppStats || !oppStats.raw) return;
                    
                    // Accumulate H2H stats
                    const h2hOppFgm = isHome ? parseFloat(m.Away_FGM)||0 : parseFloat(m.Home_FGM)||0;
                    const h2hOppFga = isHome ? parseFloat(m.Away_FGA)||0 : parseFloat(m.Home_FGA)||0;
                    const h2hOpp3pm = isHome ? parseFloat(m['Away_3PM'])||0 : parseFloat(m['Home_3PM'])||0;
                    const h2hOpp3pa = isHome ? parseFloat(m['Away_3PA'])||0 : parseFloat(m['Home_3PA'])||0;
                    const h2hOppFta = isHome ? parseFloat(m.Away_FTA)||0 : parseFloat(m.Home_FTA)||0;
                    const h2hOppOreb = isHome ? parseFloat(m.Away_OREB)||0 : parseFloat(m.Home_OREB)||0;
                    const h2hOppDreb = isHome ? parseFloat(m.Away_DREB)||0 : parseFloat(m.Home_DREB)||0;
                    const h2hOppTov = isHome ? parseFloat(m.Away_TOV)||0 : parseFloat(m.Home_TOV)||0;
                    const h2hOppAst = isHome ? parseFloat(m.Away_AST)||0 : parseFloat(m.Home_AST)||0;
                    const h2hOppStl = isHome ? parseFloat(m.Away_STL)||0 : parseFloat(m.Home_STL)||0;
                    const h2hOppBlk = isHome ? parseFloat(m.Away_BLK)||0 : parseFloat(m.Home_BLK)||0;
                    const h2hOppFtm = isHome ? parseFloat(m.Away_FTM)||0 : parseFloat(m.Home_FTM)||0;
                    const h2hOppPoss = calcPoss(h2hOppFga, h2hOppOreb, h2hOppTov, h2hOppFta);
                    
                    const h2hVsFgm = isHome ? parseFloat(m.Home_FGM)||0 : parseFloat(m.Away_FGM)||0;
                    const h2hVsFga = isHome ? parseFloat(m.Home_FGA)||0 : parseFloat(m.Away_FGA)||0;
                    const h2hVs3pm = isHome ? parseFloat(m['Home_3PM'])||0 : parseFloat(m['Away_3PM'])||0;
                    const h2hVs3pa = isHome ? parseFloat(m['Home_3PA'])||0 : parseFloat(m['Away_3PA'])||0;
                    const h2hVsFta = isHome ? parseFloat(m.Home_FTA)||0 : parseFloat(m.Away_FTA)||0;
                    const h2hVsOreb = isHome ? parseFloat(m.Home_OREB)||0 : parseFloat(m.Away_OREB)||0;
                    const h2hVsDreb = isHome ? parseFloat(m.Home_DREB)||0 : parseFloat(m.Away_DREB)||0;
                    const h2hVsTov = isHome ? parseFloat(m.Home_TOV)||0 : parseFloat(m.Away_TOV)||0;
                    const h2hVsAst = isHome ? parseFloat(m.Home_AST)||0 : parseFloat(m.Away_AST)||0;
                    const h2hVsStl = isHome ? parseFloat(m.Home_STL)||0 : parseFloat(m.Away_STL)||0;
                    const h2hVsBlk = isHome ? parseFloat(m.Home_BLK)||0 : parseFloat(m.Away_BLK)||0;
                    const h2hVsFtm = isHome ? parseFloat(m.Home_FTM)||0 : parseFloat(m.Away_FTM)||0;
                    const h2hVsPoss = calcPoss(h2hVsFga, h2hVsOreb, h2hVsTov, h2hVsFta);
                    
                    if (!oppH2HTotals.has(oppLineupNorm)) {
                        oppH2HTotals.set(oppLineupNorm, {
                            fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, 
                            tov: 0, ast: 0, stl: 0, blk: 0, poss: 0,
                            fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftmV: 0, ftaV: 0, orebV: 0, drebV: 0, 
                            tovV: 0, astV: 0, stlV: 0, blkV: 0, possV: 0
                        });
                    }
                    const h = oppH2HTotals.get(oppLineupNorm);
                    h.fgm += h2hOppFgm; h.fga += h2hOppFga; h.tpm += h2hOpp3pm; h.tpa += h2hOpp3pa;
                    h.ftm += h2hOppFtm; h.fta += h2hOppFta; h.oreb += h2hOppOreb; h.dreb += h2hOppDreb;
                    h.tov += h2hOppTov; h.ast += h2hOppAst; h.stl += h2hOppStl; h.blk += h2hOppBlk;
                    h.poss += h2hOppPoss;
                    h.fgmV += h2hVsFgm; h.fgaV += h2hVsFga; h.tpmV += h2hVs3pm; h.tpaV += h2hVs3pa;
                    h.ftmV += h2hVsFtm; h.ftaV += h2hVsFta; h.orebV += h2hVsOreb; h.drebV += h2hVsDreb;
                    h.tovV += h2hVsTov; h.astV += h2hVsAst; h.stlV += h2hVsStl; h.blkV += h2hVsBlk;
                    h.possV += h2hVsPoss;
                    
                    relevantMatchups.push({ m, oppLineupNorm, isHome, poss });
                });
                
                if (relevantMatchups.length === 0) return null;
                
                // Calculate total possessions faced per opponent
                const oppPossFaced = new Map();
                relevantMatchups.forEach(({ oppLineupNorm, poss }) => {
                    oppPossFaced.set(oppLineupNorm, (oppPossFaced.get(oppLineupNorm) || 0) + poss);
                });
                
                // =======================================================================
                // KEY FIX: Aggregate EXPECTED COUNTING STATS instead of weighting percentages
                // For each opponent: convert their per-poss rates → expected counts
                // =======================================================================
                
                let expected = {
                    // Expected opponent OFFENSIVE stats
                    offFgm: 0, offFga: 0, off3pm: 0, off3pa: 0, offFtm: 0, offFta: 0,
                    offOreb: 0, offDreb: 0, offTov: 0, offAst: 0, offStl: 0, offBlk: 0, offPoss: 0,
                    // Expected opponent DEFENSIVE stats
                    defFgm: 0, defFga: 0, def3pm: 0, def3pa: 0, defFtm: 0, defFta: 0,
                    defOreb: 0, defDreb: 0, defTov: 0, defAst: 0, defStl: 0, defBlk: 0, defPoss: 0,
                };
                
                let totalPoss = 0;
                let actualWeighted = { off: 0, def: 0 };
                const processedOpps = new Set();
                let debugH2HPts = 0, debugH2HPoss = 0;
                
                oppPossFaced.forEach((possFaced, oppLineupNorm) => {
                    const oppStats = allLineupsMap.get(oppLineupNorm);
                    if (!oppStats || !oppStats.raw) return;
                    
                    const r = oppStats.raw;
                    const h = oppH2HTotals.get(oppLineupNorm) || {
                        fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, 
                        tov: 0, ast: 0, stl: 0, blk: 0, poss: 0,
                        fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftmV: 0, ftaV: 0, orebV: 0, drebV: 0, 
                        tovV: 0, astV: 0, stlV: 0, blkV: 0, possV: 0
                    };
                    
                    debugH2HPts += 2 * h.fgm + h.tpm + h.ftm;
                    debugH2HPoss += h.poss;
                    
                    // Adjusted raw stats (season - H2H = vs everyone else)
                    const adjOff = {
                        fgm: Math.max(0, r.fgm - h.fgm), fga: Math.max(0, r.fga - h.fga),
                        tpm: Math.max(0, r.tpm - h.tpm), tpa: Math.max(0, r.tpa - h.tpa),
                        ftm: Math.max(0, r.ftm - h.ftm), fta: Math.max(0, r.fta - h.fta),
                        oreb: Math.max(0, r.oreb - h.oreb), dreb: Math.max(0, r.dreb - h.dreb),
                        tov: Math.max(0, r.tov - h.tov), ast: Math.max(0, r.ast - h.ast),
                        stl: Math.max(0, r.stl - h.stl), blk: Math.max(0, r.blk - h.blk),
                        poss: Math.max(0, r.poss - h.poss)
                    };
                    const adjDef = {
                        fgm: Math.max(0, r.fgmV - h.fgmV), fga: Math.max(0, r.fgaV - h.fgaV),
                        tpm: Math.max(0, r.tpmV - h.tpmV), tpa: Math.max(0, r.tpaV - h.tpaV),
                        ftm: Math.max(0, r.ftmV - h.ftmV), fta: Math.max(0, r.ftaV - h.ftaV),
                        oreb: Math.max(0, r.orebV - h.orebV), dreb: Math.max(0, r.drebV - h.drebV),
                        tov: Math.max(0, r.tovV - h.tovV), ast: Math.max(0, r.astV - h.astV),
                        stl: Math.max(0, r.stlV - h.stlV), blk: Math.max(0, r.blkV - h.blkV),
                        poss: Math.max(0, r.possVs - h.possV)
                    };
                    
                    // Fallback to unadjusted if no remaining sample
                    const useOff = adjOff.poss > 0.5 ? adjOff : { fgm: r.fgm, fga: r.fga, tpm: r.tpm, tpa: r.tpa, ftm: r.ftm, fta: r.fta, oreb: r.oreb, dreb: r.dreb, tov: r.tov, ast: r.ast, stl: r.stl, blk: r.blk, poss: r.poss };
                    const useDef = adjDef.poss > 0.5 ? adjDef : { fgm: r.fgmV, fga: r.fgaV, tpm: r.tpmV, tpa: r.tpaV, ftm: r.ftmV, fta: r.ftaV, oreb: r.orebV, dreb: r.drebV, tov: r.tovV, ast: r.astV, stl: r.stlV, blk: r.blkV, poss: r.possVs };
                    
                    // KEY: Scale raw stats by (possessions faced / opponent's total poss)
                    // This converts per-poss rates to expected counting stats for the matchup sample
                    if (useOff.poss > 0) {
                        const scale = possFaced / useOff.poss;
                        expected.offFgm += useOff.fgm * scale;
                        expected.offFga += useOff.fga * scale;
                        expected.off3pm += useOff.tpm * scale;
                        expected.off3pa += useOff.tpa * scale;
                        expected.offFtm += useOff.ftm * scale;
                        expected.offFta += useOff.fta * scale;
                        expected.offOreb += useOff.oreb * scale;
                        expected.offDreb += useOff.dreb * scale;
                        expected.offTov += useOff.tov * scale;
                        expected.offAst += useOff.ast * scale;
                        expected.offStl += useOff.stl * scale;
                        expected.offBlk += useOff.blk * scale;
                        expected.offPoss += possFaced;
                    }
                    
                    if (useDef.poss > 0) {
                        const scale = possFaced / useDef.poss;
                        expected.defFgm += useDef.fgm * scale;
                        expected.defFga += useDef.fga * scale;
                        expected.def3pm += useDef.tpm * scale;
                        expected.def3pa += useDef.tpa * scale;
                        expected.defFtm += useDef.ftm * scale;
                        expected.defFta += useDef.fta * scale;
                        expected.defOreb += useDef.oreb * scale;
                        expected.defDreb += useDef.dreb * scale;
                        expected.defTov += useDef.tov * scale;
                        expected.defAst += useDef.ast * scale;
                        expected.defStl += useDef.stl * scale;
                        expected.defBlk += useDef.blk * scale;
                        expected.defPoss += possFaced;
                    }
                    
                    totalPoss += possFaced;
                    processedOpps.add(oppLineupNorm);
                });
                
                // Accumulate actual performance
                relevantMatchups.forEach(({ m, isHome, poss }) => {
                    const oppActualOff = isHome ? parseFloat(m.Away_OFF_RTG) || 0 : parseFloat(m.Home_OFF_RTG) || 0;
                    const oppActualDef = isHome ? parseFloat(m.Away_DEF_RTG) || 0 : parseFloat(m.Home_DEF_RTG) || 0;
                    actualWeighted.off += oppActualOff * poss;
                    actualWeighted.def += oppActualDef * poss;
                });
                
                if (totalPoss === 0 || expected.offPoss === 0) return null;
                
                // =======================================================================
                // Calculate percentages from AGGREGATED EXPECTED COUNTING STATS
                // This properly weights high-volume shooting situations
                // V4.2.3: Apply Bayesian shrinkage to COUNTS before calculating rates
                // =======================================================================
                
                // V4.2.3: If Bayesian shrinkage enabled, add prior expected counts
                // This adds "k" worth of league-average possessions to the sample
                let useExpected = { ...expected };
                let shrinkageApplied = false;
                let shrinkageFactor = 1;
                
                if (bayesianShrinkage && leagueAverages && leagueAverages.perPoss && totalPoss > 0) {
                    const k = shrinkagePriorWeight;
                    const pp = leagueAverages.perPoss;
                    
                    // Add prior counts (league rate * k possessions) to observed counts
                    useExpected = {
                        // Offensive counts + prior
                        offFgm: expected.offFgm + pp.fgm * k,
                        offFga: expected.offFga + pp.fga * k,
                        off3pm: expected.off3pm + pp.tpm * k,
                        off3pa: expected.off3pa + pp.tpa * k,
                        offFtm: expected.offFtm + pp.ftm * k,
                        offFta: expected.offFta + pp.fta * k,
                        offOreb: expected.offOreb + pp.oreb * k,
                        offDreb: expected.offDreb + pp.dreb * k,
                        offTov: expected.offTov + pp.tov * k,
                        offAst: expected.offAst + pp.ast * k,
                        offStl: expected.offStl + pp.stl * k,
                        offBlk: expected.offBlk + pp.blk * k,
                        offPoss: expected.offPoss + k,
                        // Defensive counts + prior
                        defFgm: expected.defFgm + pp.fgmV * k,
                        defFga: expected.defFga + pp.fgaV * k,
                        def3pm: expected.def3pm + pp.tpmV * k,
                        def3pa: expected.def3pa + pp.tpaV * k,
                        defFtm: expected.defFtm + pp.ftmV * k,
                        defFta: expected.defFta + pp.ftaV * k,
                        defOreb: expected.defOreb + pp.orebV * k,
                        defDreb: expected.defDreb + pp.drebV * k,
                        defTov: expected.defTov + pp.tovV * k,
                        defAst: expected.defAst + pp.astV * k,
                        defStl: expected.defStl + pp.stlV * k,
                        defBlk: expected.defBlk + pp.blkV * k,
                        defPoss: expected.defPoss + k,
                    };
                    shrinkageApplied = true;
                    shrinkageFactor = totalPoss / (totalPoss + k);
                }
                
                // Calculate rates from (possibly shrunk) expected counts
                const offPts = 2 * useExpected.offFgm + useExpected.off3pm + useExpected.offFtm;
                const defPts = 2 * useExpected.defFgm + useExpected.def3pm + useExpected.defFtm;
                
                const result = {
                    totalPoss, 
                    oppCount: processedOpps.size,
                    
                    // Opponent typical OFFENSE (from aggregated expected stats)
                    oppOff: useExpected.offPoss > 0 ? (offPts / useExpected.offPoss) * 100 : 0,
                    oppOffEfg: useExpected.offFga > 0 ? ((useExpected.offFgm + 0.5 * useExpected.off3pm) / useExpected.offFga) * 100 : 0,
                    oppOffTov: useExpected.offPoss > 0 ? (useExpected.offTov / useExpected.offPoss) * 100 : 0,
                    oppOffOreb: (useExpected.offOreb + useExpected.defDreb) > 0 ? (useExpected.offOreb / (useExpected.offOreb + useExpected.defDreb)) * 100 : 0,
                    
                    // Opponent typical DEFENSE (from aggregated expected stats)
                    oppDef: useExpected.defPoss > 0 ? (defPts / useExpected.defPoss) * 100 : 0,
                    oppDefEfg: useExpected.defFga > 0 ? ((useExpected.defFgm + 0.5 * useExpected.def3pm) / useExpected.defFga) * 100 : 0,
                    oppDefTov: useExpected.defPoss > 0 ? (useExpected.defTov / useExpected.defPoss) * 100 : 0,
                    oppDefOreb: (useExpected.defOreb + useExpected.offDreb) > 0 ? (useExpected.defOreb / (useExpected.defOreb + useExpected.offDreb)) * 100 : 0,
                    
                    // Playmaking
                    oppAstPct: useExpected.offFgm > 0 ? (useExpected.offAst / useExpected.offFgm) * 100 : 0,
                    oppStlPct: useExpected.defPoss > 0 ? (useExpected.offStl / useExpected.defPoss) * 100 : 0,
                    oppBlkPct: (useExpected.defFga - useExpected.def3pa) > 0 ? (useExpected.offBlk / (useExpected.defFga - useExpected.def3pa)) * 100 : 0,
                    oppOppAstPct: useExpected.defFgm > 0 ? (useExpected.defAst / useExpected.defFgm) * 100 : 0,
                    oppOppStlPct: useExpected.offPoss > 0 ? (useExpected.defStl / useExpected.offPoss) * 100 : 0,
                    oppOppBlkPct: (useExpected.offFga - useExpected.off3pa) > 0 ? (useExpected.defBlk / (useExpected.offFga - useExpected.off3pa)) * 100 : 0,
                    
                    actualOppOff: actualWeighted.off / totalPoss, 
                    actualOppDef: actualWeighted.def / totalPoss,
                    h2hAdjusted: true,
                    debugH2HPts: Math.round(debugH2HPts),
                    debugH2HPoss: Math.round(debugH2HPoss),
                    methodology: shrinkageApplied ? 'expected_counts_v4.2.3_bayesian' : 'expected_counts_v3.8',
                    shrinkageApplied,
                    shrinkageFactor
                };
                
                result.oppNet = result.oppOff - result.oppDef;
                
                // V4.9.8.7.30: Using calcTeamRankAndPct for league rank display
                result.pcts = {
                    oppOff: calcTeamRankAndPct(result.oppOff, teamAvgArrays.off, true),
                    oppDef: calcTeamRankAndPct(result.oppDef, teamAvgArrays.def, false),
                    oppNet: calcTeamRankAndPct(result.oppNet, teamAvgArrays.net, true),
                    oppOffEfg: calcTeamRankAndPct(result.oppOffEfg, teamAvgArrays.offEfg, true),
                    oppOffTov: calcTeamRankAndPct(result.oppOffTov, teamAvgArrays.offTov, false),
                    oppOffOreb: calcTeamRankAndPct(result.oppOffOreb, teamAvgArrays.offOreb, true),
                    oppDefEfg: calcTeamRankAndPct(result.oppDefEfg, teamAvgArrays.defEfg, false),
                    oppDefTov: calcTeamRankAndPct(result.oppDefTov, teamAvgArrays.defTov, true),
                    oppDefOreb: calcTeamRankAndPct(result.oppDefOreb, teamAvgArrays.defOreb, false),
                    oppAstPct: calcTeamRankAndPct(result.oppAstPct, teamAvgArrays.astPct, true),
                    oppStlPct: calcTeamRankAndPct(result.oppStlPct, teamAvgArrays.stlPct, true),
                    oppBlkPct: calcTeamRankAndPct(result.oppBlkPct, teamAvgArrays.blkPct, true),
                    oppOppAstPct: calcTeamRankAndPct(result.oppOppAstPct, teamAvgArrays.oppAstPct, true),
                    oppOppStlPct: calcTeamRankAndPct(result.oppOppStlPct, teamAvgArrays.oppStlPct, true),
                    oppOppBlkPct: calcTeamRankAndPct(result.oppOppBlkPct, teamAvgArrays.oppBlkPct, true),
                };
                
                result.impact = { 
                    offDelta: result.actualOppOff - result.oppOff, 
                    defDelta: result.actualOppDef - result.oppDef 
                };
                
                return result;
            }, [filtered, matchupData, allLineupsMap, team, teamAvgArrays, minMatchupPoss, bayesianShrinkage, shrinkagePriorWeight, leagueAverages]);

            // =======================================================================
            // V4.6.2: EMPIRICAL REGRESSION COEFFICIENTS FOR OPPONENT ADJUSTMENT
            // Instead of arbitrary 0.5, estimate β from matchup data via OLS:
            //   stat_observed = α + β × (opp_quality - league_avg) + ε
            // 
            // Mathematical model:
            //   For offensive stats: our_stat = α + β × (opp_def_quality - league_def_avg)
            //   For defensive stats: our_stat = α + β × (opp_off_quality - league_off_avg)
            //
            // β represents the "pass-through rate" - how much opponent quality affects observed stats
            // Ridge regression literature suggests β ≈ 0.3-0.7 depending on stat
            // =======================================================================
            const empiricalBeta = useMemo(() => {
                if (!matchupData.length || !filtered.length || !allLineupsMap.size || !leagueAverages) {
                    return null;
                }
                
                const filteredNormalized = new Set(filtered.map(l => l.normalizedLineup));
                
                // Collect per-matchup data points: (our_stat, opp_quality) pairs
                const dataPoints = [];
                
                matchupData.forEach(m => {
                    const homeNorm = normalizeLineup(m.Home_Lineup);
                    const awayNorm = normalizeLineup(m.Away_Lineup);
                    const poss = parseFloat(m.Possessions) || 0;
                    if (poss < Math.max(2, minMatchupPoss)) return;
                    
                    let isHome = false;
                    let oppLineupNorm = null;
                    
                    if (filteredNormalized.has(homeNorm) && m.Home_Team === team) {
                        isHome = true;
                        oppLineupNorm = awayNorm;
                    } else if (filteredNormalized.has(awayNorm) && m.Away_Team === team) {
                        isHome = false;
                        oppLineupNorm = homeNorm;
                    }
                    if (!oppLineupNorm) return;
                    
                    const oppStats = allLineupsMap.get(oppLineupNorm);
                    if (!oppStats) return;
                    
                    // Our stats in this matchup
                    const fgm = isHome ? parseFloat(m.Home_FGM)||0 : parseFloat(m.Away_FGM)||0;
                    const fga = isHome ? parseFloat(m.Home_FGA)||0 : parseFloat(m.Away_FGA)||0;
                    const tpm = isHome ? parseFloat(m['Home_3PM'])||0 : parseFloat(m['Away_3PM'])||0;
                    const fta = isHome ? parseFloat(m.Home_FTA)||0 : parseFloat(m.Away_FTA)||0;
                    const ftm = isHome ? parseFloat(m.Home_FTM)||0 : parseFloat(m.Away_FTM)||0;
                    const oreb = isHome ? parseFloat(m.Home_OREB)||0 : parseFloat(m.Away_OREB)||0;
                    const dreb = isHome ? parseFloat(m.Home_DREB)||0 : parseFloat(m.Away_DREB)||0;
                    const tov = isHome ? parseFloat(m.Home_TOV)||0 : parseFloat(m.Away_TOV)||0;
                    
                    const fgmV = isHome ? parseFloat(m.Away_FGM)||0 : parseFloat(m.Home_FGM)||0;
                    const fgaV = isHome ? parseFloat(m.Away_FGA)||0 : parseFloat(m.Home_FGA)||0;
                    const tpmV = isHome ? parseFloat(m['Away_3PM'])||0 : parseFloat(m['Home_3PM'])||0;
                    const ftaV = isHome ? parseFloat(m.Away_FTA)||0 : parseFloat(m.Home_FTA)||0;
                    const ftmV = isHome ? parseFloat(m.Away_FTM)||0 : parseFloat(m.Home_FTM)||0;
                    const orebV = isHome ? parseFloat(m.Away_OREB)||0 : parseFloat(m.Home_OREB)||0;
                    const drebV = isHome ? parseFloat(m.Away_DREB)||0 : parseFloat(m.Home_DREB)||0;
                    const tovV = isHome ? parseFloat(m.Away_TOV)||0 : parseFloat(m.Home_TOV)||0;
                    
                    const myPoss = calcPoss(fga, oreb, tov, fta);
                    const oppPoss = calcPoss(fgaV, orebV, tovV, ftaV);
                    if (myPoss < 1 || oppPoss < 1) return;
                    
                    const pts = 2 * fgm + tpm + ftm;
                    const ptsV = 2 * fgmV + tpmV + ftmV;
                    
                    // Our stats
                    const ourOrtg = (pts / myPoss) * 100;
                    const ourDrtg = (ptsV / oppPoss) * 100;
                    const ourOffEfg = fga > 0 ? ((fgm + 0.5*tpm)/fga)*100 : 0;
                    const ourOffTov = myPoss > 0 ? (tov/myPoss)*100 : 0;
                    const ourOffOreb = (oreb + drebV) > 0 ? (oreb/(oreb + drebV))*100 : 0;
                    const ourDefEfg = fgaV > 0 ? ((fgmV + 0.5*tpmV)/fgaV)*100 : 0;
                    const ourDefTov = oppPoss > 0 ? (tovV/oppPoss)*100 : 0;
                    const ourDefOreb = (orebV + dreb) > 0 ? (orebV/(orebV + dreb))*100 : 0;
                    
                    // Opponent quality (from their season stats)
                    const oppOrtg = oppStats.off || 100;
                    const oppDrtg = oppStats.def || 100;
                    const oppOffEfg = oppStats.offEfg || 50;
                    const oppOffTov = oppStats.offTov || 15;
                    const oppOffOreb = oppStats.offOreb || 25;
                    const oppDefEfg = oppStats.defEfg || 50;
                    const oppDefTov = oppStats.defTov || 15;
                    const oppDefOreb = oppStats.defOreb || 25;
                    
                    dataPoints.push({
                        poss: myPoss,
                        // Our performance
                        ourOrtg, ourDrtg, ourOffEfg, ourOffTov, ourOffOreb, ourDefEfg, ourDefTov, ourDefOreb,
                        // Opponent quality (for our offense, use their defense; for our defense, use their offense)
                        oppDefRtg: oppDrtg, oppOffRtg: oppOrtg,
                        oppDefEfg, oppDefTov, oppDefOreb,
                        oppOffEfg, oppOffTov, oppOffOreb
                    });
                });
                
                if (dataPoints.length < 5) return null;
                
                // Calculate regression slope β = Cov(Y, X) / Var(X) for each stat pair
                // Y = our stat, X = opponent quality in corresponding stat
                const calcBeta = (yKey, xKey) => {
                    const n = dataPoints.length;
                    let sumW = 0, sumWX = 0, sumWY = 0, sumWXY = 0, sumWXX = 0;
                    
                    // Possession-weighted regression
                    dataPoints.forEach(d => {
                        const w = d.poss;
                        const x = d[xKey];
                        const y = d[yKey];
                        if (x === undefined || y === undefined || isNaN(x) || isNaN(y)) return;
                        sumW += w;
                        sumWX += w * x;
                        sumWY += w * y;
                        sumWXY += w * x * y;
                        sumWXX += w * x * x;
                    });
                    
                    if (sumW === 0) return 0.5; // fallback
                    
                    const meanX = sumWX / sumW;
                    const meanY = sumWY / sumW;
                    const varX = (sumWXX / sumW) - meanX * meanX;
                    const covXY = (sumWXY / sumW) - meanX * meanY;
                    
                    if (varX < 0.001) return 0.5; // insufficient variance
                    
                    const beta = covXY / varX;
                    
                    // Clamp to reasonable range [0.1, 1.0] to prevent extreme adjustments
                    // Literature suggests pass-through rates typically 0.3-0.7
                    return Math.max(0.1, Math.min(1.0, beta));
                };
                
                // Calculate β for each stat pair
                // For offensive stats: β measures how opponent's defense quality affects our offense
                // For defensive stats: β measures how opponent's offense quality affects our defense
                const result = {
                    // ORTG/DRTG direct adjustment (primary - for compositional consistency)
                    ortg: calcBeta('ourOrtg', 'oppDefRtg'),    // Our ORTG vs their DRTG
                    drtg: calcBeta('ourDrtg', 'oppOffRtg'),    // Our DRTG vs their ORTG
                    
                    // Individual factor adjustments (secondary - for display only)
                    offEfg: calcBeta('ourOffEfg', 'oppDefEfg'),
                    offTov: calcBeta('ourOffTov', 'oppDefTov'),
                    offOreb: calcBeta('ourOffOreb', 'oppDefOreb'),
                    defEfg: calcBeta('ourDefEfg', 'oppOffEfg'),
                    defTov: calcBeta('ourDefTov', 'oppOffTov'),
                    defOreb: calcBeta('ourDefOreb', 'oppOffOreb'),
                    
                    // Metadata
                    sampleSize: dataPoints.length,
                    totalPoss: dataPoints.reduce((a, d) => a + d.poss, 0)
                };
                
                return result;
            }, [matchupData, filtered, allLineupsMap, team, leagueAverages, minMatchupPoss]);

            // =======================================================================
            // V4.7: RAPM-ADJUSTED STATS CALCULATION (Async with Progress)
            // Triggered by button click to avoid blocking UI
            // Now passes pre-computed leagueAverages for consistency
            // =======================================================================
            const triggerRAPMCalculation = async () => {
                if (!matchupData.length || !filtered.length) {
                    setRapmStats({ error: 'No matchup data available' });
                    return;
                }
                
                if (!leagueAverages) {
                    setRapmStats({ error: 'League averages not available. Please ensure lineup data is loaded.' });
                    return;
                }
                
                setIsCalculatingRAPM(true);
                setRapmProgress(0);
                setRapmMessage('Initializing...');
                
                const result = await calculateRAPMAsync(
                    matchupData, 
                    filtered, 
                    allLineupsMap, 
                    rapmLambda,
                    leagueAverages, // Pass pre-computed league averages
                    (progress, message) => {
                        setRapmProgress(progress);
                        setRapmMessage(message);
                    }
                );
                
                setRapmStats(result);
                setIsCalculatingRAPM(false);
                setShowRAPM(true);
            };
            
            // =======================================================================
            // V4.9.7: PLAYER-LEVEL MULTI-STAT RAPM CALCULATION (Uses PlayerRAPMEngine V3.0)
            // Triggered by button click when stints.csv is uploaded
            // =======================================================================
            const triggerPlayerRAPMCalculation = async () => {
                if (!stintsData.length) {
                    setPlayerRapmStats({ error: 'No stints data available. Upload stints.csv first.' });
                    return;
                }
                
                setIsCalculatingPlayerRAPM(true);
                setPlayerRapmProgress(0);
                setPlayerRapmMessage('Initializing player-level RAPM...');
                
                try {
                    const result = await PlayerRAPMEngine.calculateAsync(
                        stintsData,
                        rapmLambda,
                        (progress, message) => {
                            setPlayerRapmProgress(progress);
                            setPlayerRapmMessage(message);
                        }
                    );
                    
                    setPlayerRapmStats(result);
                    console.log('[PlayerRAPM] Calculation complete:', result);
                } catch (err) {
                    console.error('[PlayerRAPM] Calculation error:', err);
                    setPlayerRapmStats({ error: err.message });
                }
                
                setIsCalculatingPlayerRAPM(false);
            };
            
            // =======================================================================
            // V5.11: HYBRID APM CALCULATION (RAPM + Bayesian Box)
            // Uses BPM from CSV as Bayesian prior for regularization
            // =======================================================================
            const triggerAPMCalculation = async () => {
                if (!stintsData.length) {
                    setPlayerApmStats({ error: 'No stints data available. Upload stints.csv first.' });
                    return;
                }
                
                if (!seasonStatsMap.size) {
                    setPlayerApmStats({ error: 'No season stats available. Upload player_stats_enhanced.csv first.' });
                    return;
                }
                
                setIsCalculatingAPM(true);
                setApmProgress(0);
                setApmMessage('Preparing box score features...');
                
                try {
                    // Convert seasonStatsMap to plain object for the engine
                    // Intraocular Bayesian Box APM uses raw box score stats, not pre-computed BPM
                    const statsObject = {};
                    let validStats = 0;
                    
                    seasonStatsMap.forEach((stats, playerName) => {
                        // Need raw stats: FGM, FGA, 3PM, 3PA, FTM, FTA, OREB, DREB, AST, STL, BLK, TOV, PF, POSS
                        if (stats.POSS && stats.POSS > 0) {
                            statsObject[playerName] = {
                                FGM: stats.FGM || stats.fgm || 0,
                                FGA: stats.FGA || stats.fga || 0,
                                '3PM': stats['3PM'] || stats.threepm || stats.fg3m || 0,
                                '3PA': stats['3PA'] || stats.threepa || stats.fg3a || 0,
                                FTM: stats.FTM || stats.ftm || 0,
                                FTA: stats.FTA || stats.fta || 0,
                                OREB: stats.OREB || stats.oreb || 0,
                                DREB: stats.DREB || stats.dreb || 0,
                                AST: stats.AST || stats.ast || 0,
                                STL: stats.STL || stats.stl || 0,
                                BLK: stats.BLK || stats.blk || 0,
                                TOV: stats.TOV || stats.tov || 0,
                                PF: stats.PF || stats.pf || 0,
                                POSS: stats.POSS || stats.poss || 0
                            };
                            validStats++;
                        }
                    });
                    
                    console.log('[BayesianBoxAPM] Prepared stats for', validStats, 'players');
                    setApmMessage('Found box stats for ' + validStats + ' players, learning coefficients...');
                    
                    const result = await PlayerRAPMEngine.calculateAPMAsync(
                        stintsData,
                        statsObject,  // Pass raw stats, not Bayesian Boxs
                        rapmLambda,
                        (progress, message) => {
                            setApmProgress(progress);
                            setApmMessage(message);
                        }
                    );
                    
                    setPlayerApmStats(result);
                    console.log('[BayesianBoxAPM] Calculation complete:', result);
                    
                    // Log learned coefficients
                    if (result.learnedCoefficients) {
                        console.log('[BayesianBoxAPM] Learned offensive coefficients:', result.learnedCoefficients.offensive);
                        console.log('[BayesianBoxAPM] Learned defensive coefficients:', result.learnedCoefficients.defensive);
                    }
                } catch (err) {
                    console.error('[BayesianBoxAPM] Calculation error:', err);
                    setPlayerApmStats({ error: err.message });
                }
                
                setIsCalculatingAPM(false);
            };
            
            // =======================================================================
            // V4.9.8.8: PLAYER-LEVEL 3PT LUCK CALCULATION FROM STINTS
            // Aggregates 3PT data per player to avoid per-stint overcorrection
            // =======================================================================
            const playerLuckAdjustments = useMemo(() => {
                console.log('[RAPM Luck useMemo] Running with rapmLuckAdj:', rapmLuckAdj, 'stintsData.length:', stintsData.length);
                if (!stintsData.length || rapmLuckAdj === 0) {
                    console.log('[RAPM Luck useMemo] Early return - null');
                    return null;
                }
                
                // Parse stints using PlayerRAPMEngine to get proper field names
                const parsedStints = PlayerRAPMEngine.buildStintsFromMatchupData(stintsData);
                if (!parsedStints.length) return null;
                
                // Calculate league average 3PT% from all stints
                let totalFg3m = 0, totalFg3a = 0;
                parsedStints.forEach(s => {
                    totalFg3m += (s.homeFg3m || 0) + (s.awayFg3m || 0);
                    totalFg3a += (s.homeFg3a || 0) + (s.awayFg3a || 0);
                });
                const leagueAvg3Pct = totalFg3a > 0 ? totalFg3m / totalFg3a : 0.36;
                
                console.log('[RAPM Luck] League avg 3PT%:', (leagueAvg3Pct * 100).toFixed(1) + '%', 'from', totalFg3a, 'attempts');
                
                // Aggregate 3PT data per player
                const playerData = new Map(); // player -> { fg3m, fg3a, poss }
                
                parsedStints.forEach(s => {
                    const poss = s.possessions || 0;
                    if (poss <= 0) return;
                    
                    // Home team players
                    (s.homePlayers || []).forEach(player => {
                        const key = player.toLowerCase().trim();
                        if (!playerData.has(key)) {
                            playerData.set(key, { fg3m: 0, fg3a: 0, poss: 0, fg3mV: 0, fg3aV: 0 });
                        }
                        const d = playerData.get(key);
                        d.fg3m += s.homeFg3m || 0;
                        d.fg3a += s.homeFg3a || 0;
                        d.fg3mV += s.awayFg3m || 0;
                        d.fg3aV += s.awayFg3a || 0;
                        d.poss += poss;
                    });
                    
                    // Away team players
                    (s.awayPlayers || []).forEach(player => {
                        const key = player.toLowerCase().trim();
                        if (!playerData.has(key)) {
                            playerData.set(key, { fg3m: 0, fg3a: 0, poss: 0, fg3mV: 0, fg3aV: 0 });
                        }
                        const d = playerData.get(key);
                        d.fg3m += s.awayFg3m || 0;
                        d.fg3a += s.awayFg3a || 0;
                        d.fg3mV += s.homeFg3m || 0;
                        d.fg3aV += s.homeFg3a || 0;
                        d.poss += poss;
                    });
                });
                
                console.log('[RAPM Luck] Tracking', playerData.size, 'players');
                
                // Calculate luck adjustment for each player
                const adjustments = {};
                playerData.forEach((data, player) => {
                    if (data.poss < 20) return; // Min possessions threshold
                    
                    // Offensive luck: team's 3PT shooting when player is on court
                    const expectedFg3m = data.fg3a * leagueAvg3Pct;
                    const offLuck = data.fg3m - expectedFg3m;
                    const offLuckPts = offLuck * 3; // Each lucky 3PM = 3 points
                    const offLuckPer100 = data.poss > 0 ? (offLuckPts / data.poss) * 100 : 0;
                    
                    // Defensive luck: opponent's 3PT shooting when player is on court
                    const expectedFg3mV = data.fg3aV * leagueAvg3Pct;
                    const defLuck = data.fg3mV - expectedFg3mV;
                    const defLuckPts = defLuck * 3;
                    const defLuckPer100 = data.poss > 0 ? (defLuckPts / data.poss) * 100 : 0;
                    
                    // Apply adjustment percentage
                    const adjPct = rapmLuckAdj / 100;
                    adjustments[player] = {
                        offAdj: -offLuckPer100 * adjPct, // Negative because we remove luck
                        defAdj: -defLuckPer100 * adjPct,
                        offLuck: offLuckPer100,
                        defLuck: defLuckPer100,
                        fg3m: data.fg3m,
                        fg3a: data.fg3a,
                        fg3mV: data.fg3mV,
                        fg3aV: data.fg3aV,
                        poss: data.poss,
                        actual3Pct: data.fg3a > 0 ? (data.fg3m / data.fg3a * 100) : 0,
                        actualV3Pct: data.fg3aV > 0 ? (data.fg3mV / data.fg3aV * 100) : 0
                    };
                });
                
                console.log('[RAPM Luck] Calculated adjustments for', Object.keys(adjustments).length, 'players');
                if (Object.keys(adjustments).length > 0) {
                    const sample = Object.entries(adjustments)[0];
                    console.log('[RAPM Luck] Sample:', sample[0], sample[1]);
                }
                
                return {
                    adjustments,
                    leagueAvg3Pct: leagueAvg3Pct * 100,
                    adjPct: rapmLuckAdj
                };
            }, [stintsData, rapmLuckAdj]);
            
            // V4.9.8.7.17: Calculate Four Factors for selected game range
            const calculateGameRangeStats = useCallback(() => {
                if (!stintsData.length || !gameRangeTeam) {
                    setGameRangeResults(null);
                    return;
                }
                
                const teamGames = gamesByTeam.get(gameRangeTeam);
                if (!teamGames || teamGames.length === 0) {
                    setGameRangeResults({ error: 'No games found for team' });
                    return;
                }
                
                // V4.9.8.7.31 FIX: Use normalizePlayerName for consistent matching
                const selectedPlayers = Object.values(gameRangePlayers).filter(p => p !== '').map(p => normalizePlayerName(p));
                
                // V5.12: Filter games based on mode (games or dates)
                let selectedGames;
                if (gameRangeDateMode === 'dates' && (gameRangeDateStart || gameRangeDateEnd)) {
                    // Date range filtering
                    const startDate = gameRangeDateStart ? new Date(gameRangeDateStart) : null;
                    const endDate = gameRangeDateEnd ? new Date(gameRangeDateEnd + 'T23:59:59') : null;
                    
                    selectedGames = teamGames.filter(g => {
                        if (!g.gameDate) return false;
                        const gameDate = new Date(g.gameDate);
                        if (startDate && gameDate < startDate) return false;
                        if (endDate && gameDate > endDate) return false;
                        return true;
                    });
                } else {
                    // Game number filtering
                    const validEnd = Math.min(gameRangeEnd, teamGames.length);
                    selectedGames = teamGames.filter(g => g.gameNumber >= gameRangeStart && g.gameNumber <= validEnd);
                }
                
                // Apply win/loss filter
                if (gameRangeWinFilter === 'wins') {
                    selectedGames = selectedGames.filter(g => g.isWin);
                } else if (gameRangeWinFilter === 'losses') {
                    selectedGames = selectedGames.filter(g => !g.isWin);
                }
                
                if (selectedGames.length === 0) {
                    const filterMsg = gameRangeWinFilter === 'wins' ? 'wins' : gameRangeWinFilter === 'losses' ? 'losses' : 'games';
                    setGameRangeResults({ error: 'No ' + filterMsg + ' found in selected range' });
                    return;
                }
                
                const selectedGameIds = new Set(selectedGames.map(g => g.gameId));
                
                // Build aggregated totals from stints
                const totals = {
                    poss: 0, possV: 0,
                    fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0,
                    oreb: 0, dreb: 0, tov: 0, ast: 0, stl: 0, blk: 0,
                    fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftmV: 0, ftaV: 0,
                    orebV: 0, drebV: 0, tovV: 0, astV: 0, stlV: 0, blkV: 0,
                    rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0,
                    rimAV: 0, rimMV: 0, midAV: 0, midMV: 0, threeAV: 0, threeMV: 0,
                    // Turnover types
                    passTo: 0, dribTo: 0, defTo: 0, miscTo: 0,
                    passToV: 0, dribToV: 0, defToV: 0, miscToV: 0,
                    fastBreak: 0, fastBreakV: 0, secChance: 0, secChanceV: 0, ptsOffTov: 0, ptsOffTovV: 0,
                    gamesIncluded: new Set(),
                    stintsCount: 0
                };
                
                stintsData.forEach(s => {
                    const gameId = s.game_id;
                    if (!selectedGameIds.has(gameId)) return;
                    
                    const isHome = s.home_team === gameRangeTeam;
                    const isAway = s.away_team === gameRangeTeam;
                    if (!isHome && !isAway) return;
                    
                    // Check player filter if specified
                    // V4.9.8.7.31 FIX: Use normalizePlayerName for consistent matching
                    if (selectedPlayers.length > 0) {
                        const lineupStr = isHome ? s.home_lineup : s.away_lineup;
                        if (!lineupStr) return;
                        const lineupPlayersNorm = lineupStr.split(',').map(p => normalizePlayerName(p.trim()));
                        // All selected players must be in the lineup
                        const allPlayersPresent = selectedPlayers.every(sp => lineupPlayersNorm.includes(sp));
                        if (!allPlayersPresent) return;
                    }
                    
                    // Parse stint stats
                    const poss = parseFloat(s.possessions) || 0;
                    if (poss <= 0) return;
                    
                    totals.gamesIncluded.add(gameId);
                    totals.stintsCount++;
                    
                    // Team offensive stats
                    const teamPrefix = isHome ? 'home_' : 'away_';
                    const oppPrefix = isHome ? 'away_' : 'home_';
                    
                    totals.poss += poss;
                    totals.possV += poss;
                    
                    totals.fga += parseFloat(s[teamPrefix + 'fga']) || 0;
                    totals.fgm += parseFloat(s[teamPrefix + 'fgm']) || 0;
                    totals.tpa += parseFloat(s[teamPrefix + 'fg3a']) || 0;
                    totals.tpm += parseFloat(s[teamPrefix + 'fg3m']) || 0;
                    totals.fta += parseFloat(s[teamPrefix + 'fta']) || 0;
                    totals.ftm += parseFloat(s[teamPrefix + 'ftm']) || 0;
                    totals.oreb += parseFloat(s[teamPrefix + 'oreb']) || 0;
                    totals.dreb += parseFloat(s[teamPrefix + 'dreb']) || 0;
                    totals.tov += parseFloat(s[teamPrefix + 'tov']) || 0;
                    totals.ast += parseFloat(s[teamPrefix + 'ast']) || 0;
                    totals.stl += parseFloat(s[teamPrefix + 'stl']) || 0;
                    totals.blk += parseFloat(s[teamPrefix + 'blk']) || 0;
                    
                    totals.fgaV += parseFloat(s[oppPrefix + 'fga']) || 0;
                    totals.fgmV += parseFloat(s[oppPrefix + 'fgm']) || 0;
                    totals.tpaV += parseFloat(s[oppPrefix + 'fg3a']) || 0;
                    totals.tpmV += parseFloat(s[oppPrefix + 'fg3m']) || 0;
                    totals.ftaV += parseFloat(s[oppPrefix + 'fta']) || 0;
                    totals.ftmV += parseFloat(s[oppPrefix + 'ftm']) || 0;
                    totals.orebV += parseFloat(s[oppPrefix + 'oreb']) || 0;
                    totals.drebV += parseFloat(s[oppPrefix + 'dreb']) || 0;
                    totals.tovV += parseFloat(s[oppPrefix + 'tov']) || 0;
                    totals.astV += parseFloat(s[oppPrefix + 'ast']) || 0;
                    totals.stlV += parseFloat(s[oppPrefix + 'stl']) || 0;
                    totals.blkV += parseFloat(s[oppPrefix + 'blk']) || 0;
                    
                    // Shot location
                    totals.rimA += parseFloat(s[teamPrefix + 'rim_att']) || 0;
                    totals.rimM += parseFloat(s[teamPrefix + 'rim_made']) || 0;
                    totals.midA += parseFloat(s[teamPrefix + 'otd_2pt_att']) || 0;
                    totals.midM += parseFloat(s[teamPrefix + 'otd_2pt_made']) || 0;
                    totals.threeA += parseFloat(s[teamPrefix + 'otd_3pt_att']) || 0;
                    totals.threeM += parseFloat(s[teamPrefix + 'otd_3pt_made']) || 0;
                    
                    totals.rimAV += parseFloat(s[oppPrefix + 'rim_att']) || 0;
                    totals.rimMV += parseFloat(s[oppPrefix + 'rim_made']) || 0;
                    totals.midAV += parseFloat(s[oppPrefix + 'otd_2pt_att']) || 0;
                    totals.midMV += parseFloat(s[oppPrefix + 'otd_2pt_made']) || 0;
                    totals.threeAV += parseFloat(s[oppPrefix + 'otd_3pt_att']) || 0;
                    totals.threeMV += parseFloat(s[oppPrefix + 'otd_3pt_made']) || 0;
                    
                    // Turnover types
                    totals.passTo += parseFloat(s[teamPrefix + 'pass_to']) || 0;
                    totals.dribTo += parseFloat(s[teamPrefix + 'dribble_to']) || 0;
                    totals.defTo += parseFloat(s[teamPrefix + 'defense_to']) || 0;
                    totals.miscTo += parseFloat(s[teamPrefix + 'misc_to']) || 0;
                    
                    totals.passToV += parseFloat(s[oppPrefix + 'pass_to']) || 0;
                    totals.dribToV += parseFloat(s[oppPrefix + 'dribble_to']) || 0;
                    totals.defToV += parseFloat(s[oppPrefix + 'defense_to']) || 0;
                    totals.miscToV += parseFloat(s[oppPrefix + 'misc_to']) || 0;
                    
                    // Transition
                    totals.fastBreak += parseFloat(s[teamPrefix + 'fast_break_pts']) || 0;
                    totals.fastBreakV += parseFloat(s[oppPrefix + 'fast_break_pts']) || 0;
                    totals.secChance += parseFloat(s[teamPrefix + 'second_chance_pts']) || 0;
                    totals.secChanceV += parseFloat(s[oppPrefix + 'second_chance_pts']) || 0;
                    totals.ptsOffTov += parseFloat(s[teamPrefix + 'pts_off_tov']) || 0;
                    totals.ptsOffTovV += parseFloat(s[oppPrefix + 'pts_off_tov']) || 0;
                });
                
                if (totals.stintsCount === 0) {
                    setGameRangeResults({ error: 'No stints found for this combination in selected games' });
                    return;
                }
                
                // Calculate Four Factors
                const t = totals;
                const offEfg = t.fga > 0 ? ((t.fgm + 0.5*t.tpm)/t.fga)*100 : 0;
                const offTovDenom = t.fga + 0.44 * t.fta + t.tov;
                const offTov = offTovDenom > 0 ? (t.tov/offTovDenom)*100 : 0;
                const offOreb = (t.oreb+t.drebV) > 0 ? (t.oreb/(t.oreb+t.drebV))*100 : 0;
                const offFtR = t.fga > 0 ? (t.fta/t.fga)*100 : 0;
                
                const defEfg = t.fgaV > 0 ? ((t.fgmV + 0.5*t.tpmV)/t.fgaV)*100 : 0;
                const defTovDenom = t.fgaV + 0.44 * t.ftaV + t.tovV;
                const defTov = defTovDenom > 0 ? (t.tovV/defTovDenom)*100 : 0;
                const defOreb = (t.orebV+t.dreb) > 0 ? (t.orebV/(t.orebV+t.dreb))*100 : 0;
                const defFtR = t.fgaV > 0 ? (t.ftaV/t.fgaV)*100 : 0;
                
                // Calculate ratings
                const pts = 2 * t.fgm + t.tpm + t.ftm;
                const ptsV = 2 * t.fgmV + t.tpmV + t.ftmV;
                const offRtg = t.poss > 0 ? (pts / t.poss) * 100 : 0;
                const defRtg = t.possV > 0 ? (ptsV / t.possV) * 100 : 0;
                const netRtg = offRtg - defRtg;
                
                // Shot distribution stats
                const ts = t.rimA + t.midA + t.threeA;
                const tsV = t.rimAV + t.midAV + t.threeAV;
                const rimPct = t.rimA > 0 ? (t.rimM/t.rimA)*100 : 0;
                const midPct = t.midA > 0 ? (t.midM/t.midA)*100 : 0;
                const threePct = t.threeA > 0 ? (t.threeM/t.threeA)*100 : 0;
                const rimPctV = t.rimAV > 0 ? (t.rimMV/t.rimAV)*100 : 0;
                const midPctV = t.midAV > 0 ? (t.midMV/t.midAV)*100 : 0;
                const threePctV = t.threeAV > 0 ? (t.threeMV/t.threeAV)*100 : 0;
                const rimRate = ts > 0 ? (t.rimA/ts)*100 : 0;
                const midRate = ts > 0 ? (t.midA/ts)*100 : 0;
                const threeRate = ts > 0 ? (t.threeA/ts)*100 : 0;
                const rimRateV = tsV > 0 ? (t.rimAV/tsV)*100 : 0;
                const midRateV = tsV > 0 ? (t.midAV/tsV)*100 : 0;
                const threeRateV = tsV > 0 ? (t.threeAV/tsV)*100 : 0;
                // Per 100 possessions
                const rimVol = t.poss > 0 ? (t.rimA / t.poss) * 100 : 0;
                const midVol = t.poss > 0 ? (t.midA / t.poss) * 100 : 0;
                const threeVol = t.poss > 0 ? (t.threeA / t.poss) * 100 : 0;
                const rimVolV = t.possV > 0 ? (t.rimAV / t.possV) * 100 : 0;
                const midVolV = t.possV > 0 ? (t.midAV / t.possV) * 100 : 0;
                const threeVolV = t.possV > 0 ? (t.threeAV / t.possV) * 100 : 0;
                
                // Turnover totals
                const tTo = t.passTo + t.dribTo + t.defTo + t.miscTo;
                const tToV = t.passToV + t.dribToV + t.defToV + t.miscToV;
                
                // Additional stats
                const astPct = t.fgm > 0 ? (t.ast/t.fgm)*100 : 0;
                const stlPct = t.possV > 0 ? (t.stl/t.possV)*100 : 0;
                const blkPct = (t.fgaV-t.tpaV) > 0 ? (t.blk/(t.fgaV-t.tpaV))*100 : 0;
                const oppAstPct = t.fgmV > 0 ? (t.astV/t.fgmV)*100 : 0;
                const oppStlPct = t.poss > 0 ? (t.stlV/t.poss)*100 : 0;
                const oppBlkPct = (t.fga-t.tpa) > 0 ? (t.blkV/(t.fga-t.tpa))*100 : 0;
                
                // MISC stats per 100 possessions
                const secChance100 = t.poss > 0 ? (t.secChance / t.poss) * 100 : 0;
                const ptsOffTov100 = t.poss > 0 ? (t.ptsOffTov / t.poss) * 100 : 0;
                const secChance100V = t.possV > 0 ? (t.secChanceV / t.possV) * 100 : 0;
                const ptsOffTov100V = t.possV > 0 ? (t.ptsOffTovV / t.possV) * 100 : 0;
                const fastBreak100 = t.poss > 0 ? (t.fastBreak / t.poss) * 100 : 0;
                const fastBreak100V = t.possV > 0 ? (t.fastBreakV / t.possV) * 100 : 0;
                
                setGameRangeResults({
                    team: gameRangeTeam,
                    players: selectedPlayers,
                    // V5.12: Include both game range and date range info
                    filterMode: gameRangeDateMode,
                    gameRange: gameRangeDateMode === 'games' ? { start: gameRangeStart, end: Math.min(gameRangeEnd, teamGames.length) } : null,
                    dateRange: gameRangeDateMode === 'dates' ? { start: gameRangeDateStart, end: gameRangeDateEnd } : null,
                    winFilter: gameRangeWinFilter,
                    gamesCount: t.gamesIncluded.size,
                    stintsCount: t.stintsCount,
                    possessions: t.poss,
                    fourFactors: {
                        off: { efg: offEfg, tov: offTov, oreb: offOreb, ftR: offFtR },
                        def: { efg: defEfg, tov: defTov, oreb: defOreb, ftR: defFtR }
                    },
                    ratings: { off: offRtg, def: defRtg, net: netRtg },
                    totals: t,
                    // Full fStats-like object for percentile calculations
                    stats: {
                        off: offRtg, def: defRtg, net: netRtg,
                        offEfg, offTov, offOreb, offFtR,
                        defEfg, defTov, defOreb, defFtR,
                        rimPct, midPct, threePct, rimPctV, midPctV, threePctV,
                        rimRate, midRate, threeRate, rimRateV, midRateV, threeRateV,
                        rimVol, midVol, threeVol, rimVolV, midVolV, threeVolV,
                        rimA: t.rimA, rimM: t.rimM, midA: t.midA, midM: t.midM, threeA: t.threeA, threeM: t.threeM,
                        rimAV: t.rimAV, rimMV: t.rimMV, midAV: t.midAV, midMV: t.midMV, threeAV: t.threeAV, threeMV: t.threeMV,
                        passTo: t.passTo, dribTo: t.dribTo, defTo: t.defTo, miscTo: t.miscTo, tTo,
                        passToV: t.passToV, dribToV: t.dribToV, defToV: t.defToV, miscToV: t.miscToV, tToV,
                        astPct, stlPct, blkPct, oppAstPct, oppStlPct, oppBlkPct,
                        secChance100, ptsOffTov100, secChance100V, ptsOffTov100V,
                        fastBreak100, fastBreak100V
                    },
                    playmaking: { astPct, stlPct, blkPct },
                    selectedGames
                });
            }, [stintsData, gameRangeTeam, gameRangePlayers, gameRangeStart, gameRangeEnd, gamesByTeam, gameRangeWinFilter, gameRangeDateMode, gameRangeDateStart, gameRangeDateEnd]);
            
            // Reset RAPM when filters change
            useEffect(() => {
                if (rapmStats && !rapmStats.error) {
                    setRapmStats(null);
                    setShowRAPM(false);
                }
            }, [team, selPlayers, exPlayers]);


            // Filtered lineup stats with Dean Oliver possessions
            const fStatsBase = useMemo(() => {
                if (!filtered.length) return null;
                const t = filtered.reduce((a, d) => {
                    const fgm = parseFloat(d.FGM)||0, fga = parseFloat(d.FGA)||0, tpm = parseFloat(d['3PM'])||0, tpa = parseFloat(d['3PA'])||0, fta = parseFloat(d.FTA)||0, oreb = parseFloat(d.OREB)||0, dreb = parseFloat(d.DREB)||0, tov = parseFloat(d.TOV)||0, ast = parseFloat(d.AST)||0, stl = parseFloat(d.STL)||0, blk = parseFloat(d.BLK)||0;
                    const fgmV = parseFloat(d.FGM_VS)||0, fgaV = parseFloat(d.FGA_VS)||0, tpmV = parseFloat(d['3PM_VS'])||0, tpaV = parseFloat(d['3PA_VS'])||0, ftaV = parseFloat(d.FTA_VS)||0, orebV = parseFloat(d.OREB_VS)||0, drebV = parseFloat(d.DREB_VS)||0, tovV = parseFloat(d.TOV_VS)||0;
                    const astV = parseFloat(d.AST_VS)||0, stlV = parseFloat(d.STL_VS)||0, blkV = parseFloat(d.BLK_VS)||0;
                    const rimA = parseFloat(d.RIM_ATT)||0, rimM = parseFloat(d.RIM_MADE)||0, midA = parseFloat(d.OTD_2PT_ATT)||0, midM = parseFloat(d.OTD_2PT_MADE)||0, threeA = parseFloat(d.OTD_3PT_ATT)||0, threeM = parseFloat(d.OTD_3PT_MADE)||0;
                    const rimAV = parseFloat(d.RIM_ATT_VS)||0, rimMV = parseFloat(d.RIM_MADE_VS)||0, midAV = parseFloat(d.OTD_2PT_ATT_VS)||0, midMV = parseFloat(d.OTD_2PT_MADE_VS)||0, threeAV = parseFloat(d.OTD_3PT_ATT_VS)||0, threeMV = parseFloat(d.OTD_3PT_MADE_VS)||0;
                    const passTo = parseFloat(d.PASS_TO)||0, dribTo = parseFloat(d.DRIBBLE_TO)||0, defTo = parseFloat(d.DEFENSE_TO)||0, miscTo = parseFloat(d.MISC_TO)||0;
                    const passToV = parseFloat(d.PASS_TO_VS)||0, dribToV = parseFloat(d.DRIBBLE_TO_VS)||0, defToV = parseFloat(d.DEFENSE_TO_VS)||0, miscToV = parseFloat(d.MISC_TO_VS)||0;
                    const secChance = parseFloat(d['2ND_CHANCE_PTS'])||0, fastBreak = parseFloat(d.FAST_BREAK_PTS)||0, ptsOffTov = parseFloat(d.PTS_OFF_TOV)||0;
                    const secChanceV = parseFloat(d['2ND_CHANCE_PTS_VS'])||0, fastBreakV = parseFloat(d.FAST_BREAK_PTS_VS)||0, ptsOffTovV = parseFloat(d.PTS_OFF_TOV_VS)||0;
                    const pts = parseFloat(d.PTS)||0, ptsV = parseFloat(d.PTS_VS)||0;
                    return { ...a, time: a.time + d.TIME, poss: a.poss + d.POSS, possV: a.possV + d.POSS_VS, combP: a.combP + d.COMB_POSS, fgm: a.fgm + fgm, fga: a.fga + fga, tpm: a.tpm + tpm, tpa: a.tpa + tpa, fta: a.fta + fta, oreb: a.oreb + oreb, dreb: a.dreb + dreb, tov: a.tov + tov, ast: a.ast + ast, stl: a.stl + stl, blk: a.blk + blk, fgmV: a.fgmV + fgmV, fgaV: a.fgaV + fgaV, tpmV: a.tpmV + tpmV, tpaV: a.tpaV + tpaV, ftaV: a.ftaV + ftaV, orebV: a.orebV + orebV, drebV: a.drebV + drebV, tovV: a.tovV + tovV, astV: a.astV + astV, stlV: a.stlV + stlV, blkV: a.blkV + blkV, rimA: a.rimA + rimA, rimM: a.rimM + rimM, midA: a.midA + midA, midM: a.midM + midM, threeA: a.threeA + threeA, threeM: a.threeM + threeM, rimAV: a.rimAV + rimAV, rimMV: a.rimMV + rimMV, midAV: a.midAV + midAV, midMV: a.midMV + midMV, threeAV: a.threeAV + threeAV, threeMV: a.threeMV + threeMV, passTo: a.passTo + passTo, dribTo: a.dribTo + dribTo, defTo: a.defTo + defTo, miscTo: a.miscTo + miscTo, passToV: a.passToV + passToV, dribToV: a.dribToV + dribToV, defToV: a.defToV + defToV, miscToV: a.miscToV + miscToV, secChance: a.secChance + secChance, fastBreak: a.fastBreak + fastBreak, ptsOffTov: a.ptsOffTov + ptsOffTov, secChanceV: a.secChanceV + secChanceV, fastBreakV: a.fastBreakV + fastBreakV, ptsOffTovV: a.ptsOffTovV + ptsOffTovV, pts: a.pts + pts, ptsV: a.ptsV + ptsV, wNet: a.wNet + d.NET * d.COMB_POSS, wOff: a.wOff + d.OFF * d.COMB_POSS, wDef: a.wDef + d.DEF * d.COMB_POSS, wPaceF: a.wPaceF + d.PACE_F * d.TIME, wPaceV: a.wPaceV + d.PACE_V * d.TIME };
                }, { time: 0, poss: 0, possV: 0, combP: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, fta: 0, oreb: 0, dreb: 0, tov: 0, ast: 0, stl: 0, blk: 0, fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftaV: 0, orebV: 0, drebV: 0, tovV: 0, astV: 0, stlV: 0, blkV: 0, rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0, rimAV: 0, rimMV: 0, midAV: 0, midMV: 0, threeAV: 0, threeMV: 0, passTo: 0, dribTo: 0, defTo: 0, miscTo: 0, passToV: 0, dribToV: 0, defToV: 0, miscToV: 0, secChance: 0, fastBreak: 0, ptsOffTov: 0, secChanceV: 0, fastBreakV: 0, ptsOffTovV: 0, pts: 0, ptsV: 0, wNet: 0, wOff: 0, wDef: 0, wPaceF: 0, wPaceV: 0 });
                const ts = t.rimA + t.midA + t.threeA, tsV = t.rimAV + t.midAV + t.threeAV, tTo = t.passTo + t.dribTo + t.defTo + t.miscTo, tToV = t.passToV + t.dribToV + t.defToV + t.miscToV;
                const offEfg = t.fga > 0 ? ((t.fgm + 0.5*t.tpm)/t.fga)*100 : 0;
                const offTovDenom = t.fga + 0.44 * t.fta + t.tov;
                const offTov = offTovDenom > 0 ? (t.tov/offTovDenom)*100 : 0;
                const offOreb = (t.oreb+t.drebV) > 0 ? (t.oreb/(t.oreb+t.drebV))*100 : 0;
                const offFtR = t.fga > 0 ? (t.fta/t.fga)*100 : 0;
                const defEfg = t.fgaV > 0 ? ((t.fgmV + 0.5*t.tpmV)/t.fgaV)*100 : 0;
                const defTovDenom = t.fgaV + 0.44 * t.ftaV + t.tovV;
                const defTov = defTovDenom > 0 ? (t.tovV/defTovDenom)*100 : 0;
                const defOreb = (t.orebV+t.dreb) > 0 ? (t.orebV/(t.orebV+t.dreb))*100 : 0;
                const defFtR = t.fgaV > 0 ? (t.ftaV/t.fgaV)*100 : 0;
                const rimPct = t.rimA > 0 ? (t.rimM/t.rimA)*100 : 0, midPct = t.midA > 0 ? (t.midM/t.midA)*100 : 0, threePct = t.threeA > 0 ? (t.threeM/t.threeA)*100 : 0;
                const rimPctV = t.rimAV > 0 ? (t.rimMV/t.rimAV)*100 : 0, midPctV = t.midAV > 0 ? (t.midMV/t.midAV)*100 : 0, threePctV = t.threeAV > 0 ? (t.threeMV/t.threeAV)*100 : 0;
                const astPct = t.fgm > 0 ? (t.ast/t.fgm)*100 : 0;
                const stlPct = t.possV > 0 ? (t.stl/t.possV)*100 : 0;
                const blkPct = (t.fgaV-t.tpaV) > 0 ? (t.blk/(t.fgaV-t.tpaV))*100 : 0;
                const oppAstPct = t.fgmV > 0 ? (t.astV/t.fgmV)*100 : 0;
                const oppStlPct = t.poss > 0 ? (t.stlV/t.poss)*100 : 0;
                const oppBlkPct = (t.fga-t.tpa) > 0 ? (t.blkV/(t.fga-t.tpa))*100 : 0;
                // Possession-normalized shot volumes (per 100 possessions)
                const rimVol = t.poss > 0 ? (t.rimA / t.poss) * 100 : 0;
                const midVol = t.poss > 0 ? (t.midA / t.poss) * 100 : 0;
                const threeVol = t.poss > 0 ? (t.threeA / t.poss) * 100 : 0;
                const rimVolV = t.possV > 0 ? (t.rimAV / t.possV) * 100 : 0;
                const midVolV = t.possV > 0 ? (t.midAV / t.possV) * 100 : 0;
                const threeVolV = t.possV > 0 ? (t.threeAV / t.possV) * 100 : 0;
                // MISC stats per 100 possessions
                const secChance100 = t.poss > 0 ? (t.secChance / t.poss) * 100 : 0;
                const ptsOffTov100 = t.poss > 0 ? (t.ptsOffTov / t.poss) * 100 : 0;
                const secChance100V = t.possV > 0 ? (t.secChanceV / t.possV) * 100 : 0;
                const ptsOffTov100V = t.possV > 0 ? (t.ptsOffTovV / t.possV) * 100 : 0;
                // Transition stats per 100 possessions and percentages
                const fastBreak100 = t.poss > 0 ? (t.fastBreak / t.poss) * 100 : 0;
                const fastBreak100V = t.possV > 0 ? (t.fastBreakV / t.possV) * 100 : 0;
                const transPct = t.pts > 0 ? (t.fastBreak / t.pts) * 100 : 0;
                const halfCourtPct = t.pts > 0 ? ((t.pts - t.fastBreak) / t.pts) * 100 : 0;
                const transPctV = t.ptsV > 0 ? (t.fastBreakV / t.ptsV) * 100 : 0;
                const halfCourtPctV = t.ptsV > 0 ? ((t.ptsV - t.fastBreakV) / t.ptsV) * 100 : 0;
                return { ...t, ts, tsV, tTo, tToV, net: t.combP > 0 ? t.wNet/t.combP : 0, off: t.combP > 0 ? t.wOff/t.combP : 0, def: t.combP > 0 ? t.wDef/t.combP : 0, paceF: t.time > 0 ? t.wPaceF/t.time : 0, paceV: t.time > 0 ? t.wPaceV/t.time : 0, offEfg, offTov, offOreb, offFtR, defEfg, defTov, defOreb, defFtR, rimPct, midPct, threePct, rimPctV, midPctV, threePctV, rimRate: ts > 0 ? (t.rimA/ts)*100 : 0, midRate: ts > 0 ? (t.midA/ts)*100 : 0, threeRate: ts > 0 ? (t.threeA/ts)*100 : 0, rimRateV: tsV > 0 ? (t.rimAV/tsV)*100 : 0, midRateV: tsV > 0 ? (t.midAV/tsV)*100 : 0, threeRateV: tsV > 0 ? (t.threeAV/tsV)*100 : 0, astPct, stlPct, blkPct, oppAstPct, oppStlPct, oppBlkPct, rimVol, midVol, threeVol, rimVolV, midVolV, threeVolV, secChance100, ptsOffTov100, secChance100V, ptsOffTov100V, fastBreak100, fastBreak100V, transPct, halfCourtPct, transPctV, halfCourtPctV };
            }, [filtered]);
            
            // V4.2.3: Calculate lineup stats from MATCHUP data with minMatchupPoss filter and Bayesian shrinkage
            // This allows filtering out low-possession matchups and applying shrinkage to lineup stats
            const fStatsFromMatchups = useMemo(() => {
                if (!filtered.length || !matchupData.length) return null;
                // Only use this path if minMatchupPoss > 0 or bayesianShrinkage is enabled
                if (minMatchupPoss === 0 && !bayesianShrinkage) return null;
                
                const filteredNormalized = new Set(filtered.map(d => d.normalizedLineup));
                
                // Aggregate stats from qualifying matchups
                const t = {
                    time: 0, poss: 0, possV: 0, combP: 0,
                    fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, tov: 0, ast: 0, stl: 0, blk: 0,
                    fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftmV: 0, ftaV: 0, orebV: 0, drebV: 0, tovV: 0, astV: 0, stlV: 0, blkV: 0,
                    wPaceF: 0, wPaceV: 0,
                    rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0,
                    rimAV: 0, rimMV: 0, midAV: 0, midMV: 0, threeAV: 0, threeMV: 0,
                    passTo: 0, dribTo: 0, defTo: 0, miscTo: 0,
                    passToV: 0, dribToV: 0, defToV: 0, miscToV: 0,
                    matchupCount: 0, excludedMatchups: 0
                };
                
                matchupData.forEach(m => {
                    const homeNorm = normalizeLineup(m.Home_Lineup);
                    const awayNorm = normalizeLineup(m.Away_Lineup);
                    
                    // Check if this matchup involves our filtered lineups
                    let isHome = false;
                    if (filteredNormalized.has(homeNorm) && m.Home_Team === team) {
                        isHome = true;
                    } else if (filteredNormalized.has(awayNorm) && m.Away_Team === team) {
                        isHome = false;
                    } else {
                        return; // Not our lineup
                    }
                    
                    // V4.2.3: Apply minimum possession threshold
                    const matchupPoss = parseFloat(m.Possessions) || 0;
                    if (matchupPoss < Math.max(1, minMatchupPoss)) {
                        t.excludedMatchups++;
                        return;
                    }
                    
                    // Our stats (we're either home or away)
                    const fgm = isHome ? parseFloat(m.Home_FGM)||0 : parseFloat(m.Away_FGM)||0;
                    const fga = isHome ? parseFloat(m.Home_FGA)||0 : parseFloat(m.Away_FGA)||0;
                    const tpm = isHome ? parseFloat(m['Home_3PM'])||0 : parseFloat(m['Away_3PM'])||0;
                    const tpa = isHome ? parseFloat(m['Home_3PA'])||0 : parseFloat(m['Away_3PA'])||0;
                    const ftm = isHome ? parseFloat(m.Home_FTM)||0 : parseFloat(m.Away_FTM)||0;
                    const fta = isHome ? parseFloat(m.Home_FTA)||0 : parseFloat(m.Away_FTA)||0;
                    const oreb = isHome ? parseFloat(m.Home_OREB)||0 : parseFloat(m.Away_OREB)||0;
                    const dreb = isHome ? parseFloat(m.Home_DREB)||0 : parseFloat(m.Away_DREB)||0;
                    const tov = isHome ? parseFloat(m.Home_TOV)||0 : parseFloat(m.Away_TOV)||0;
                    const ast = isHome ? parseFloat(m.Home_AST)||0 : parseFloat(m.Away_AST)||0;
                    const stl = isHome ? parseFloat(m.Home_STL)||0 : parseFloat(m.Away_STL)||0;
                    const blk = isHome ? parseFloat(m.Home_BLK)||0 : parseFloat(m.Away_BLK)||0;
                    
                    // Opponent stats (VS)
                    const fgmV = isHome ? parseFloat(m.Away_FGM)||0 : parseFloat(m.Home_FGM)||0;
                    const fgaV = isHome ? parseFloat(m.Away_FGA)||0 : parseFloat(m.Home_FGA)||0;
                    const tpmV = isHome ? parseFloat(m['Away_3PM'])||0 : parseFloat(m['Home_3PM'])||0;
                    const tpaV = isHome ? parseFloat(m['Away_3PA'])||0 : parseFloat(m['Home_3PA'])||0;
                    const ftmV = isHome ? parseFloat(m.Away_FTM)||0 : parseFloat(m.Home_FTM)||0;
                    const ftaV = isHome ? parseFloat(m.Away_FTA)||0 : parseFloat(m.Home_FTA)||0;
                    const orebV = isHome ? parseFloat(m.Away_OREB)||0 : parseFloat(m.Home_OREB)||0;
                    const drebV = isHome ? parseFloat(m.Away_DREB)||0 : parseFloat(m.Home_DREB)||0;
                    const tovV = isHome ? parseFloat(m.Away_TOV)||0 : parseFloat(m.Home_TOV)||0;
                    const astV = isHome ? parseFloat(m.Away_AST)||0 : parseFloat(m.Home_AST)||0;
                    const stlV = isHome ? parseFloat(m.Away_STL)||0 : parseFloat(m.Home_STL)||0;
                    const blkV = isHome ? parseFloat(m.Away_BLK)||0 : parseFloat(m.Home_BLK)||0;
                    
                    // Calculate possessions from raw stats
                    const poss = calcPoss(fga, oreb, tov, fta);
                    const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                    const combPoss = poss + possV;
                    
                    // Accumulate raw totals
                    t.poss += poss; t.possV += possV; t.combP += combPoss;
                    t.fgm += fgm; t.fga += fga; t.tpm += tpm; t.tpa += tpa; t.ftm += ftm; t.fta += fta;
                    t.oreb += oreb; t.dreb += dreb; t.tov += tov; t.ast += ast; t.stl += stl; t.blk += blk;
                    t.fgmV += fgmV; t.fgaV += fgaV; t.tpmV += tpmV; t.tpaV += tpaV; t.ftmV += ftmV; t.ftaV += ftaV;
                    t.orebV += orebV; t.drebV += drebV; t.tovV += tovV; t.astV += astV; t.stlV += stlV; t.blkV += blkV;
                    t.matchupCount++;
                });
                
                if (t.combP === 0) return null;
                
                // V4.2.3: Apply Bayesian shrinkage to totals BEFORE calculating rates
                let useT = { ...t };
                let shrinkageApplied = false;
                let shrinkageFactor = 1;
                
                if (bayesianShrinkage && leagueAverages && leagueAverages.perPoss) {
                    const k = shrinkagePriorWeight;
                    const pp = leagueAverages.perPoss;
                    
                    // Add prior counts (league rate * k possessions) to observed counts
                    // Offensive stats get prior based on offensive possessions
                    useT.fgm = t.fgm + pp.fgm * k;
                    useT.fga = t.fga + pp.fga * k;
                    useT.tpm = t.tpm + pp.tpm * k;
                    useT.tpa = t.tpa + pp.tpa * k;
                    useT.ftm = t.ftm + pp.ftm * k;
                    useT.fta = t.fta + pp.fta * k;
                    useT.oreb = t.oreb + pp.oreb * k;
                    useT.dreb = t.dreb + pp.dreb * k;
                    useT.tov = t.tov + pp.tov * k;
                    useT.ast = t.ast + pp.ast * k;
                    useT.stl = t.stl + pp.stl * k;
                    useT.blk = t.blk + pp.blk * k;
                    useT.poss = t.poss + k;
                    
                    // Defensive stats get prior based on defensive possessions
                    useT.fgmV = t.fgmV + pp.fgmV * k;
                    useT.fgaV = t.fgaV + pp.fgaV * k;
                    useT.tpmV = t.tpmV + pp.tpmV * k;
                    useT.tpaV = t.tpaV + pp.tpaV * k;
                    useT.ftmV = t.ftmV + pp.ftmV * k;
                    useT.ftaV = t.ftaV + pp.ftaV * k;
                    useT.orebV = t.orebV + pp.orebV * k;
                    useT.drebV = t.drebV + pp.drebV * k;
                    useT.tovV = t.tovV + pp.tovV * k;
                    useT.astV = t.astV + pp.astV * k;
                    useT.stlV = t.stlV + pp.stlV * k;
                    useT.blkV = t.blkV + pp.blkV * k;
                    useT.possV = t.possV + k;
                    useT.combP = useT.poss + useT.possV;
                    
                    shrinkageApplied = true;
                    shrinkageFactor = t.poss / (t.poss + k);
                }
                
                // Calculate ratings from (possibly shrunk) totals
                const pts = 2 * useT.fgm + useT.tpm + useT.ftm;
                const ptsV = 2 * useT.fgmV + useT.tpmV + useT.ftmV;
                const off = useT.poss > 0 ? (pts / useT.poss) * 100 : 0;
                const def = useT.possV > 0 ? (ptsV / useT.possV) * 100 : 0;
                const net = off - def;
                
                // Calculate Four Factors from (possibly shrunk) totals
                const ts = useT.rimA + useT.midA + useT.threeA, tsV = useT.rimAV + useT.midAV + useT.threeAV;
                const tTo = useT.passTo + useT.dribTo + useT.defTo + useT.miscTo;
                const tToV = useT.passToV + useT.dribToV + useT.defToV + useT.miscToV;
                const offEfg = useT.fga > 0 ? ((useT.fgm + 0.5*useT.tpm)/useT.fga)*100 : 0;
                const offTovDenom = useT.fga + 0.44 * useT.fta + useT.tov;
                const offTov = offTovDenom > 0 ? (useT.tov/offTovDenom)*100 : 0;
                const offOreb = (useT.oreb+useT.drebV) > 0 ? (useT.oreb/(useT.oreb+useT.drebV))*100 : 0;
                const offFtR = useT.fga > 0 ? (useT.fta/useT.fga)*100 : 0;
                const defEfg = useT.fgaV > 0 ? ((useT.fgmV + 0.5*useT.tpmV)/useT.fgaV)*100 : 0;
                const defTovDenom = useT.fgaV + 0.44 * useT.ftaV + useT.tovV;
                const defTov = defTovDenom > 0 ? (useT.tovV/defTovDenom)*100 : 0;
                const defOreb = (useT.orebV+useT.dreb) > 0 ? (useT.orebV/(useT.orebV+useT.dreb))*100 : 0;
                const defFtR = useT.fgaV > 0 ? (useT.ftaV/useT.fgaV)*100 : 0;
                const rimPct = useT.rimA > 0 ? (useT.rimM/useT.rimA)*100 : 0, midPct = useT.midA > 0 ? (useT.midM/useT.midA)*100 : 0, threePct = useT.threeA > 0 ? (useT.threeM/useT.threeA)*100 : 0;
                const rimPctV = useT.rimAV > 0 ? (useT.rimMV/useT.rimAV)*100 : 0, midPctV = useT.midAV > 0 ? (useT.midMV/useT.midAV)*100 : 0, threePctV = useT.threeAV > 0 ? (useT.threeMV/useT.threeAV)*100 : 0;
                const astPct = useT.fgm > 0 ? (useT.ast/useT.fgm)*100 : 0;
                const stlPct = useT.possV > 0 ? (useT.stl/useT.possV)*100 : 0;
                const blkPct = (useT.fgaV-useT.tpaV) > 0 ? (useT.blk/(useT.fgaV-useT.tpaV))*100 : 0;
                const oppAstPct = useT.fgmV > 0 ? (useT.astV/useT.fgmV)*100 : 0;
                const oppStlPct = useT.poss > 0 ? (useT.stlV/useT.poss)*100 : 0;
                const oppBlkPct = (useT.fga-useT.tpa) > 0 ? (useT.blkV/(useT.fga-useT.tpa))*100 : 0;
                const rimVol = useT.poss > 0 ? (useT.rimA / useT.poss) * 100 : 0;
                const midVol = useT.poss > 0 ? (useT.midA / useT.poss) * 100 : 0;
                const threeVol = useT.poss > 0 ? (useT.threeA / useT.poss) * 100 : 0;
                const rimVolV = useT.possV > 0 ? (useT.rimAV / useT.possV) * 100 : 0;
                const midVolV = useT.possV > 0 ? (useT.midAV / useT.possV) * 100 : 0;
                const threeVolV = useT.possV > 0 ? (useT.threeAV / useT.possV) * 100 : 0;
                
                return { 
                    ...useT, ts, tsV, tTo, tToV, 
                    net, off, def,
                    paceF: 0, paceV: 0, // Pace not available from matchup data
                    offEfg, offTov, offOreb, offFtR, defEfg, defTov, defOreb, defFtR, 
                    rimPct, midPct, threePct, rimPctV, midPctV, threePctV, 
                    rimRate: ts > 0 ? (useT.rimA/ts)*100 : 0, midRate: ts > 0 ? (useT.midA/ts)*100 : 0, threeRate: ts > 0 ? (useT.threeA/ts)*100 : 0, 
                    rimRateV: tsV > 0 ? (useT.rimAV/tsV)*100 : 0, midRateV: tsV > 0 ? (useT.midAV/tsV)*100 : 0, threeRateV: tsV > 0 ? (useT.threeAV/tsV)*100 : 0, 
                    astPct, stlPct, blkPct, oppAstPct, oppStlPct, oppBlkPct, 
                    rimVol, midVol, threeVol, rimVolV, midVolV, threeVolV,
                    // Metadata
                    isFromMatchups: true,
                    matchupCount: t.matchupCount,
                    excludedMatchups: t.excludedMatchups,
                    rawPoss: t.poss,
                    rawPossV: t.possV,
                    shrinkageApplied,
                    shrinkageFactor
                };
            }, [filtered, matchupData, team, minMatchupPoss, bayesianShrinkage, shrinkagePriorWeight, leagueAverages]);
            
            // V4.2.3: Use fStatsFromMatchups when minMatchupPoss or bayesianShrinkage is active
            // Use oppFilteredStats when opponent filters are active, otherwise use fStatsBase
            const fStats = useMemo(() => {
                if (oppFilters.length > 0 && oppFilteredStats) {
                    return oppFilteredStats;
                }
                // Use matchup-based calculation when minMatchupPoss or bayesianShrinkage is active
                if ((minMatchupPoss > 0 || bayesianShrinkage) && fStatsFromMatchups) {
                    return fStatsFromMatchups;
                }
                return fStatsBase;
            }, [oppFilters, oppFilteredStats, fStatsBase, fStatsFromMatchups, minMatchupPoss, bayesianShrinkage]);

            // V4.0: Luck-adjusted stats calculation
            // Uses player season 3PT% to regress lineup 3PT shooting toward expected values
            const luckAdjustedStats = useMemo(() => {
                if (!fStats) return null;
                
                // Calculate offensive luck adjustment using player data
                let offAdjDelta3pm = 0;
                let offTotalActual3pm = 0;
                let offTotalExpected3pm = 0;
                let offPlayersWithSeason = 0;
                let offPlayerDetails = [];
                
                if (playerData.length > 0 && seasonStatsMap.size > 0 && offLuckAdj > 0) {
                    const af = Object.values(selPlayers).filter(p => p !== '');
                    const ae = Object.values(exPlayers).filter(p => p !== '');
                    const playerTotals = new Map();
                    
                    // Aggregate player 3PT stats from filtered lineups
                    playerData.filter(pd => pd.Team === team).forEach(pd => {
                        const player = pd.Player ? pd.Player.trim() : '';
                        if (!player) return;
                        const tm = pd.Teammates ? pd.Teammates.split(',').map(t => t.trim()).filter(t => t) : [];
                        const fullLineup = [player, ...tm];
                        const fullLineupNorm = fullLineup.map(p => normalizePlayerName(p));
                        
                        // Apply same filters as main lineup filter
                        if (af.length >= 1 && !af.every(f => fullLineupNorm.some(p => p === normalizePlayerName(f)))) return;
                        if (ae.length > 0 && ae.some(x => fullLineupNorm.some(p => p === normalizePlayerName(x)))) return;
                        
                        const tpa = parseFloat(pd['3PA']) || 0;
                        const tpm = parseFloat(pd['3PM']) || 0;
                        
                        if (!playerTotals.has(player)) {
                            playerTotals.set(player, { tpa: 0, tpm: 0 });
                        }
                        const pt = playerTotals.get(player);
                        pt.tpa += tpa;
                        pt.tpm += tpm;
                    });
                    
                    // Calculate luck adjustment for each player
                    playerTotals.forEach((stats, playerName) => {
                        const pNorm = normalizePlayerName(playerName);
                        const seasonStats = seasonStatsMap.get(pNorm);
                        
                        if (seasonStats && stats.tpa > 0 && seasonStats.seasonThreePct > 0) {
                            const seasonPct = seasonStats.seasonThreePct / 100;
                            const expected3pm = stats.tpa * seasonPct;
                            const actual3pm = stats.tpm;
                            const luckDelta = actual3pm - expected3pm;
                            
                            offTotalActual3pm += actual3pm;
                            offTotalExpected3pm += expected3pm;
                            offPlayersWithSeason++;
                            
                            offPlayerDetails.push({
                                player: playerName,
                                tpa: stats.tpa,
                                actual3pm,
                                expected3pm,
                                seasonPct: seasonStats.seasonThreePct,
                                actualPct: stats.tpa > 0 ? (stats.tpm / stats.tpa) * 100 : 0,
                                luckDelta
                            });
                        }
                    });
                    
                    // Total luck delta (positive = shot better than expected)
                    const totalLuckDelta = offTotalActual3pm - offTotalExpected3pm;
                    // Amount to adjust = luck delta * adjustment percentage
                    offAdjDelta3pm = totalLuckDelta * (offLuckAdj / 100);
                }
                
                // =======================================================================
                // DEFENSIVE LUCK ADJUSTMENT
                // Regresses opponent 3PT% toward league average 3PT%
                // =======================================================================
                let defAdjDelta3pm = 0;
                let defExpected3pm = 0;
                let defActual3pm = fStats.tpmV;
                let defActual3Pct = fStats.tpaV > 0 ? (fStats.tpmV / fStats.tpaV) * 100 : 0;
                let leagueAvg3Pct = 0;
                
                if (defLuckAdj > 0 && fStats.tpaV > 0) {
                    // Calculate league average 3PT% from all teams
                    if (allTeamsAverages.length > 0) {
                        const totalTpm = allTeamsAverages.reduce((sum, t) => sum + (t.tpm || 0), 0);
                        const totalTpa = allTeamsAverages.reduce((sum, t) => sum + (t.tpa || 0), 0);
                        leagueAvg3Pct = totalTpa > 0 ? (totalTpm / totalTpa) * 100 : 35; // fallback to 35%
                    } else {
                        leagueAvg3Pct = 35; // fallback
                    }
                    
                    // Expected 3PM if opponents shot league average
                    defExpected3pm = fStats.tpaV * (leagueAvg3Pct / 100);
                    const defLuckDelta = defActual3pm - defExpected3pm;
                    defAdjDelta3pm = defLuckDelta * (defLuckAdj / 100);
                }
                
                // Calculate adjusted ratings using DELTA approach
                // Each 3PM adjustment = 3 points difference (made vs missed)
                // Rating change = (points change / possessions) * 100
                
                // Offensive: if we shot hot (offAdjDelta3pm > 0), reduce rating
                const offPtsDelta = -3 * offAdjDelta3pm;
                const adjOff = fStats.off + (fStats.poss > 0 ? (offPtsDelta / fStats.poss) * 100 : 0);
                
                // Defensive: if opponents shot hot (defAdjDelta3pm > 0), reduce their scoring (improve our defense)
                const defPtsDelta = -3 * defAdjDelta3pm;
                const adjDef = fStats.def + (fStats.possV > 0 ? (defPtsDelta / fStats.possV) * 100 : 0);
                
                const adjNet = adjOff - adjDef;
                
                // Adjusted 3PT percentages and eFG% (for display purposes)
                const adj3pm = Math.max(0, fStats.tpm - offAdjDelta3pm);
                const adj3pmV = Math.max(0, fStats.tpmV - defAdjDelta3pm);
                const adjFgm = Math.max(0, fStats.fgm - offAdjDelta3pm);
                const adjFgmV = Math.max(0, fStats.fgmV - defAdjDelta3pm);
                
                const adjOffEfg = fStats.fga > 0 ? ((adjFgm + 0.5 * adj3pm) / fStats.fga) * 100 : fStats.offEfg;
                const adjDefEfg = fStats.fgaV > 0 ? ((adjFgmV + 0.5 * adj3pmV) / fStats.fgaV) * 100 : fStats.defEfg;
                const adjThreePct = fStats.tpa > 0 ? (adj3pm / fStats.tpa) * 100 : fStats.threePct;
                const adjThreePctV = fStats.tpaV > 0 ? (adj3pmV / fStats.tpaV) * 100 : fStats.threePctV;
                
                return {
                    // Original values for reference
                    origOff: fStats.off,
                    origDef: fStats.def,
                    origNet: fStats.net,
                    origOffEfg: fStats.offEfg,
                    origDefEfg: fStats.defEfg,
                    origThreePct: fStats.threePct,
                    origThreePctV: fStats.threePctV,
                    
                    // Adjusted values
                    adjOff,
                    adjDef,
                    adjNet,
                    adjOffEfg,
                    adjDefEfg,
                    adjThreePct,
                    adjThreePctV,
                    
                    // Deltas for display
                    offDelta: adjOff - fStats.off,
                    defDelta: adjDef - fStats.def,
                    netDelta: adjNet - fStats.net,
                    offEfgDelta: adjOffEfg - fStats.offEfg,
                    defEfgDelta: adjDefEfg - fStats.defEfg,
                    
                    // Offensive adjustment info
                    off3pmAdj: offAdjDelta3pm,
                    offTotalActual3pm,
                    offTotalExpected3pm,
                    offPlayersWithSeason,
                    offPlayerDetails,
                    
                    // Defensive adjustment info (simplified - league avg based)
                    def3pmAdj: defAdjDelta3pm,
                    defActual3pm,
                    defExpected3pm,
                    defActual3Pct,
                    leagueAvg3Pct,
                    
                    // Whether any adjustment is active
                    hasOffAdj: offLuckAdj > 0 && offPlayersWithSeason > 0,
                    hasDefAdj: defLuckAdj > 0 && fStats.tpaV > 0,
                    isActive: (offLuckAdj > 0 && offPlayersWithSeason > 0) || (defLuckAdj > 0 && fStats.tpaV > 0)
                };
            }, [fStats, playerData, team, selPlayers, exPlayers, seasonStatsMap, offLuckAdj, defLuckAdj, allTeamsAverages]);

            // Percentiles calculated against TEAM AVERAGES - used for ALL color coding
            // V4.9.8.7.30: Now returns rank/total/pct objects for display as league rank
            const pcts = useMemo(() => {
                if (!fStats || !teamAvgArrays.net || !teamAvgArrays.net.length) return {};
                return {
                    net: calcTeamRankAndPct(fStats.net, teamAvgArrays.net, true),
                    off: calcTeamRankAndPct(fStats.off, teamAvgArrays.off, true),
                    def: calcTeamRankAndPct(fStats.def, teamAvgArrays.def, false),
                    paceF: calcTeamRankAndPct(fStats.paceF, teamAvgArrays.paceF, true),
                    paceV: calcTeamRankAndPct(fStats.paceV, teamAvgArrays.paceV, false),
                    offEfg: calcTeamRankAndPct(fStats.offEfg, teamAvgArrays.offEfg, true),
                    offTov: calcTeamRankAndPct(fStats.offTov, teamAvgArrays.offTov, false),
                    offOreb: calcTeamRankAndPct(fStats.offOreb, teamAvgArrays.offOreb, true),
                    offFtR: calcTeamRankAndPct(fStats.offFtR, teamAvgArrays.offFtR, true),
                    defEfg: calcTeamRankAndPct(fStats.defEfg, teamAvgArrays.defEfg, false),
                    defTov: calcTeamRankAndPct(fStats.defTov, teamAvgArrays.defTov, true),
                    defOreb: calcTeamRankAndPct(fStats.defOreb, teamAvgArrays.defOreb, false),
                    defFtR: calcTeamRankAndPct(fStats.defFtR, teamAvgArrays.defFtR, false),
                    rimPct: calcTeamRankAndPct(fStats.rimPct, teamAvgArrays.rimPct, true),
                    midPct: calcTeamRankAndPct(fStats.midPct, teamAvgArrays.midPct, true),
                    threePct: calcTeamRankAndPct(fStats.threePct, teamAvgArrays.threePct, true),
                    rimPctV: calcTeamRankAndPct(fStats.rimPctV, teamAvgArrays.rimPctV, false),
                    midPctV: calcTeamRankAndPct(fStats.midPctV, teamAvgArrays.midPctV, false),
                    threePctV: calcTeamRankAndPct(fStats.threePctV, teamAvgArrays.threePctV, false),
                    astPct: calcTeamRankAndPct(fStats.astPct, teamAvgArrays.astPct, true),
                    stlPct: calcTeamRankAndPct(fStats.stlPct, teamAvgArrays.stlPct, true),
                    blkPct: calcTeamRankAndPct(fStats.blkPct, teamAvgArrays.blkPct, true),
                    oppAstPct: calcTeamRankAndPct(fStats.oppAstPct, teamAvgArrays.oppAstPct, false),
                    oppStlPct: calcTeamRankAndPct(fStats.oppStlPct, teamAvgArrays.oppStlPct, false),
                    oppBlkPct: calcTeamRankAndPct(fStats.oppBlkPct, teamAvgArrays.oppBlkPct, false),
                    // MISC stats percentiles
                    secChance100: calcTeamRankAndPct(fStats.secChance100 || 0, teamAvgArrays.secChance100 || [], true),
                    ptsOffTov100: calcTeamRankAndPct(fStats.ptsOffTov100 || 0, teamAvgArrays.ptsOffTov100 || [], true),
                    secChance100V: calcTeamRankAndPct(fStats.secChance100V || 0, teamAvgArrays.secChance100V || [], false),
                    ptsOffTov100V: calcTeamRankAndPct(fStats.ptsOffTov100V || 0, teamAvgArrays.ptsOffTov100V || [], false),
                    // Transition stats percentiles
                    fastBreak100: calcTeamRankAndPct(fStats.fastBreak100 || 0, teamAvgArrays.fastBreak100 || [], true),
                    fastBreak100V: calcTeamRankAndPct(fStats.fastBreak100V || 0, teamAvgArrays.fastBreak100V || [], false),
                    transPct: calcTeamRankAndPct(fStats.transPct || 0, teamAvgArrays.transPct || [], true),
                    transPctV: calcTeamRankAndPct(fStats.transPctV || 0, teamAvgArrays.transPctV || [], false),
                };
            }, [fStats, teamAvgArrays]);


            // Player breakdown calculation with Dean Oliver possessions
            const playerBreakdown = useMemo(() => {
                if (!playerData.length || !team) return [];
                const af = Object.values(selPlayers).filter(p => p !== '');
                const ae = Object.values(exPlayers).filter(p => p !== '');
                // NEW: If no players selected, get all players for the team
                const pm = new Map();
                playerData.filter(pd => pd.Team === team).forEach(pd => {
                    const player = pd.Player ? pd.Player.trim() : '';
                    if (!player) return;
                    const tm = pd.Teammates ? pd.Teammates.split(',').map(t => t.trim()).filter(t => t) : [];
                    const fullLineup = [player, ...tm];
                    const fullLineupNorm = fullLineup.map(p => normalizePlayerName(p));
                    // If filters are set, check if they match (using normalized names)
                    if (af.length >= 1 && !af.every(f => fullLineupNorm.some(p => p === normalizePlayerName(f)))) return;
                    // Exclude lineups containing excluded players (using normalized names)
                    if (ae.length > 0 && ae.some(x => fullLineupNorm.some(p => p === normalizePlayerName(x)))) return;
                    const min = parseFloat(pd.Minutes) || 0;
                    const fga = parseFloat(pd.FGA) || 0;
                    const oreb = parseFloat(pd.OREB) || 0;
                    const tov = parseFloat(pd.TOV) || 0;
                    const fta = parseFloat(pd.FTA) || 0;
                    const pPoss = calcPoss(fga, oreb, tov, fta);
                    if (!pm.has(player)) pm.set(player, { player, minutes: 0, pts: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, reb: 0, ast: 0, stl: 0, blk: 0, tov: 0, pf: 0, rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0, passTo: 0, dribTo: 0, defTo: 0, miscTo: 0, pPoss: 0, tpc: 0, ptsAst: 0, secChancePts: 0, fastBreakPts: 0, clutchPts: 0, otd2ptAtt: 0, otd3ptAtt: 0 });
                    const x = pm.get(player);
                    x.minutes += min; x.pts += parseFloat(pd.PTS) || 0; x.fgm += parseFloat(pd.FGM) || 0; x.fga += fga; x.tpm += parseFloat(pd['3PM']) || 0; x.tpa += parseFloat(pd['3PA']) || 0; x.ftm += parseFloat(pd.FTM) || 0; x.fta += fta; x.oreb += oreb; x.dreb += parseFloat(pd.DREB) || 0; x.reb += parseFloat(pd.REB) || 0; x.ast += parseFloat(pd.AST) || 0; x.stl += parseFloat(pd.STL) || 0; x.blk += parseFloat(pd.BLK) || 0; x.tov += tov; x.rimA += parseFloat(pd.RIM_ATT) || 0; x.rimM += parseFloat(pd.RIM_MADE) || 0; x.midA += parseFloat(pd.OTD_2PT_ATT) || 0; x.midM += parseFloat(pd.OTD_2PT_MADE) || 0; x.threeA += parseFloat(pd.OTD_3PT_ATT) || 0; x.threeM += parseFloat(pd.OTD_3PT_MADE) || 0; x.passTo += parseFloat(pd.PASS_TO) || 0; x.dribTo += parseFloat(pd.DRIBBLE_TO) || 0; x.defTo += parseFloat(pd.DEFENSE_TO) || 0; x.miscTo += parseFloat(pd.MISC_TO) || 0; x.pPoss += pPoss; x.tpc += parseFloat(pd.TPC) || 0;
                    x.pf += parseFloat(pd.PF) || 0;
                    // V4.9.8.6: Additional stats from player_stats_enhanced.csv
                    x.ptsAst += parseFloat(pd.PTS_AST) || 0;
                    x.secChancePts += parseFloat(pd['2ND_CHANCE_PTS']) || 0;
                    x.fastBreakPts += parseFloat(pd.FAST_BREAK_PTS) || 0;
                    x.clutchPts += parseFloat(pd.Clutch_PTS || pd.CLUTCH_PTS) || 0;
                    x.otd2ptAtt += parseFloat(pd.OTD_2PT_ATT) || 0;
                    x.otd3ptAtt += parseFloat(pd.OTD_3PT_ATT) || 0;
                });
                return Array.from(pm.values()).map(p => {
                    const pNorm = normalizePlayerName(p.player);
                    const pLineups = filtered.filter(l => { const lp = l.Lineup ? l.Lineup.split(',').map(x => normalizePlayerName(x)) : []; return lp.some(x => x === pNorm); });
                    const lpTotal = pLineups.reduce((s, l) => s + (l.POSS || 0), 0);
                    // Calculate team totals for ONLY the lineups this player appears in
                    const lpTeamTotals = pLineups.reduce((acc, l) => ({
                        fgm: acc.fgm + (parseFloat(l.FGM) || 0),
                        ast: acc.ast + (parseFloat(l.AST) || 0),
                        oreb: acc.oreb + (parseFloat(l.OREB) || 0),
                        drebV: acc.drebV + (parseFloat(l.DREB_VS) || 0),
                        time: acc.time + (parseFloat(l.TIME) || 0)
                    }), { fgm: 0, ast: 0, oreb: 0, drebV: 0, time: 0 });
                    const per40 = p.minutes > 0 ? 40 / p.minutes : 0;
                    // V4.9.8: Per 75 possessions calculation using lineup possessions
                    const per75 = lpTotal > 0 ? 75 / lpTotal : 0;
                    const playerNorm = normalizePlayerName(p.player);
                    const seasonStats = seasonStatsMap.get(playerNorm) || null;
                    // Calculate player's OREB% within their specific lineups
                    const lpOrebAvail = lpTeamTotals.oreb + lpTeamTotals.drebV;
                    const playerOrebPct = lpOrebAvail > 0 ? (p.oreb / lpOrebAvail) * 100 : 0;
                    // AST% = 100 × AST / (Team_FGM - Player_FGM)
                    // Since we're already in player-specific lineups, player was on court for 100% of these
                    // So teammate FGM = Team FGM - Player FGM
                    const teammateFgm = lpTeamTotals.fgm - p.fgm;
                    // If teammateFgm <= 0, data mismatch (player FGM > lineup FGM, possibly name mismatch)
                    const playerAstPct = teammateFgm > 0 ? (100 * p.ast / teammateFgm) : 0;
                    const lpTeamMin = lpTeamTotals.time / 60; // Convert seconds to minutes
                    const numLineups = pLineups.length;
                    // V4.9.8.6: Calculate AST/USG ratio (playerAstPct / usage)
                    const usage = lpTotal > 0 ? (p.pPoss / lpTotal) * 100 : 0;
                    const astUsgRatio = usage > 0 ? playerAstPct / usage : 0;
                    return { player: p.player, minutes: p.minutes, 
                        // V4.9.8: Per 75 possessions stats (primary)
                        pts75: p.pts * per75, reb75: p.reb * per75, oreb75: p.oreb * per75, dreb75: p.dreb * per75, 
                        ast75: p.ast * per75, tov75: p.tov * per75, stl75: p.stl * per75, blk75: p.blk * per75, 
                        rimA75: p.rimA * per75, midA75: p.midA * per75, threeA75: p.threeA * per75,
                        // V4.9.8.6: New per 75 stats from player_stats_enhanced.csv
                        ptsAst75: p.ptsAst * per75, secChancePts75: p.secChancePts * per75, fastBreakPts75: p.fastBreakPts * per75,
                        clutchPts75: p.clutchPts * per75, otd2ptAtt75: p.otd2ptAtt * per75, otd3ptAtt75: p.otd3ptAtt * per75,
                        // Legacy per 40 (kept for backwards compat)
                        pts40: p.pts * per40, reb40: p.reb * per40, ast40: p.ast * per40, tov40: p.tov * per40, stl40: p.stl * per40, blk40: p.blk * per40, rimA40: p.rimA * per40, midA40: p.midA * per40, threeA40: p.threeA * per40,
                        // TS% = PTS / (2 * (FGA + 0.44 * FTA))
                        tsPct: (2 * (p.fga + 0.44 * p.fta)) > 0 ? (p.pts / (2 * (p.fga + 0.44 * p.fta))) * 100 : 0,
                        rimPct: p.rimA > 0 ? (p.rimM / p.rimA) * 100 : 0, midPct: p.midA > 0 ? (p.midM / p.midA) * 100 : 0, threePct: p.tpa > 0 ? (p.tpm / p.tpa) * 100 : 0, usage, passTo: p.passTo, dribTo: p.dribTo, defTo: p.defTo, miscTo: p.miscTo, tTo: p.passTo + p.dribTo + p.defTo + p.miscTo, lpPoss: lpTotal, seasonStats: seasonStats, hasSeason: !!seasonStats,
                        // Raw totals for breakdown
                        pts: p.pts, reb: p.reb, rimA: p.rimA, rimM: p.rimM, midA: p.midA, midM: p.midM, threeA: p.threeA, threeM: p.threeM,
                        tpa: p.tpa, tpm: p.tpm, fga: p.fga, fta: p.fta, ftm: p.ftm,
                        // V4.9.8.6: Raw totals for new stats
                        ptsAst: p.ptsAst, secChancePts: p.secChancePts, fastBreakPts: p.fastBreakPts, clutchPts: p.clutchPts,
                        // TPC stats
                        tpc: p.tpc, tpc75: p.tpc * per75, tpc40: p.tpc * per40, tpc100: lpTotal > 0 ? (p.tpc / lpTotal) * 100 : 0,
                        // Raw stats for OREB/AST modals
                        oreb: p.oreb, dreb: p.dreb, ast: p.ast, stl: p.stl, blk: p.blk, tov: p.tov, pf: p.pf, fgm: p.fgm,
                        // Lineup-specific team totals and calculated rates
                        lpTeamFgm: lpTeamTotals.fgm, lpTeamAst: lpTeamTotals.ast, lpTeamOreb: lpTeamTotals.oreb, lpOppDreb: lpTeamTotals.drebV, lpTeamMin, teammateFgm, numLineups,
                        playerOrebPct, playerAstPct, astUsgRatio };
                }).filter(p => p.minutes > 0).sort((a, b) => b.minutes - a.minutes);
            }, [playerData, team, selPlayers, exPlayers, filtered, seasonStatsMap]);

            // V4.9.8: Calculate league-wide player averages for percentile coloring
            // Uses lineup possessions (same as playerBreakdown) for consistency
            const leaguePlayerAverages = useMemo(() => {
                if (!playerData.length || !lineupData.length) return null;
                
                // First, build a map of all lineup possessions by team
                const lineupPossMap = new Map();
                lineupData.forEach(d => {
                    const lineupKey = d.Team + '|||' + normalizeLineup(d.Lineup);
                    const fga = parseFloat(d.FGA) || 0;
                    const oreb = parseFloat(d.OREB) || 0;
                    const tov = parseFloat(d.TOV) || 0;
                    const fta = parseFloat(d.FTA) || 0;
                    const poss = calcPoss(fga, oreb, tov, fta);
                    lineupPossMap.set(lineupKey, { ...d, POSS: poss });
                });
                
                // Aggregate all players across all teams using lineup possessions
                const allPlayersMap = new Map();
                playerData.forEach(pd => {
                    const player = pd.Player ? pd.Player.trim() : '';
                    const playerTeam = pd.Team || '';
                    if (!player) return;
                    const playerKey = player + '|||' + playerTeam;
                    
                    const min = parseFloat(pd.Minutes) || 0;
                    
                    if (!allPlayersMap.has(playerKey)) {
                        allPlayersMap.set(playerKey, { 
                            player, team: playerTeam, minutes: 0,
                            pts: 0, reb: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0,
                            rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0, tpa: 0, tpm: 0,
                            tpc: 0, fga: 0, fta: 0, fgm: 0,
                            // V4.9.8.6: New stats from player_stats_enhanced.csv
                            ptsAst: 0, secChancePts: 0, fastBreakPts: 0, clutchPts: 0,
                            passTo: 0, dribTo: 0,
                            lineupKeys: new Set()
                        });
                    }
                    const x = allPlayersMap.get(playerKey);
                    x.minutes += min;
                    x.pts += parseFloat(pd.PTS) || 0;
                    x.reb += parseFloat(pd.REB) || 0;
                    x.oreb += parseFloat(pd.OREB) || 0;
                    x.dreb += parseFloat(pd.DREB) || 0;
                    x.ast += parseFloat(pd.AST) || 0;
                    x.stl += parseFloat(pd.STL) || 0;
                    x.blk += parseFloat(pd.BLK) || 0;
                    x.tov += parseFloat(pd.TOV) || 0;
                    x.rimA += parseFloat(pd.RIM_ATT) || 0;
                    x.rimM += parseFloat(pd.RIM_MADE) || 0;
                    x.midA += parseFloat(pd.OTD_2PT_ATT) || 0;
                    x.midM += parseFloat(pd.OTD_2PT_MADE) || 0;
                    x.threeA += parseFloat(pd.OTD_3PT_ATT) || 0;
                    x.threeM += parseFloat(pd.OTD_3PT_MADE) || 0;
                    x.tpa += parseFloat(pd['3PA']) || 0;
                    x.tpm += parseFloat(pd['3PM']) || 0;
                    x.tpc += parseFloat(pd.TPC) || 0;
                    x.fga += parseFloat(pd.FGA) || 0;
                    x.fta += parseFloat(pd.FTA) || 0;
                    x.fgm += parseFloat(pd.FGM) || 0;
                    // V4.9.8.6: New stats from player_stats_enhanced.csv
                    x.ptsAst += parseFloat(pd.PTS_AST) || 0;
                    x.secChancePts += parseFloat(pd['2ND_CHANCE_PTS']) || 0;
                    x.fastBreakPts += parseFloat(pd.FAST_BREAK_PTS) || 0;
                    x.clutchPts += parseFloat(pd.Clutch_PTS || pd.CLUTCH_PTS) || 0;
                    x.passTo += parseFloat(pd.PASS_TO) || 0;
                    x.dribTo += parseFloat(pd.DRIBBLE_TO) || 0;
                    
                    // Track lineups this player appears in
                    const teammates = pd.Teammates ? pd.Teammates.split(',').map(t => t.trim()).filter(t => t) : [];
                    const fullLineup = [player, ...teammates];
                    const normalizedLineup = normalizeLineup(fullLineup.join(','));
                    x.lineupKeys.add(playerTeam + '|||' + normalizedLineup);
                });
                
                // Calculate lineup possessions for each player (sum of POSS for lineups they appear in)
                // This matches how playerBreakdown calculates lpTotal
                allPlayersMap.forEach((playerStats, key) => {
                    const playerNorm = normalizePlayerName(playerStats.player);
                    let lpTotal = 0;
                    
                    // Find all lineups this player appears in from lineupData
                    lineupData.filter(d => d.Team === playerStats.team).forEach(d => {
                        const lineupPlayers = d.Lineup ? d.Lineup.split(',').map(p => normalizePlayerName(p.trim())) : [];
                        if (lineupPlayers.some(lp => lp === playerNorm)) {
                            const fga = parseFloat(d.FGA) || 0;
                            const oreb = parseFloat(d.OREB) || 0;
                            const tov = parseFloat(d.TOV) || 0;
                            const fta = parseFloat(d.FTA) || 0;
                            lpTotal += calcPoss(fga, oreb, tov, fta);
                        }
                    });
                    
                    playerStats.lpPoss = lpTotal;
                });
                
                // Convert to per 75 possessions using lineup possessions
                // Filter players with minimum lineup possessions for meaningful stats
                const minPoss = 50;
                const playersWithPer75 = Array.from(allPlayersMap.values())
                    .filter(p => p.lpPoss >= minPoss)
                    .map(p => {
                        const per75 = p.lpPoss > 0 ? 75 / p.lpPoss : 0;
                        // TS% = PTS / (2 * (FGA + 0.44 * FTA))
                        const tsa = 2 * (p.fga + 0.44 * p.fta);
                        const tsPct = tsa > 0 ? (p.pts / tsa) * 100 : null;
                        // V4.9.8.6: Usage% = player possessions / lineup possessions * 100
                        const pPoss = p.fga - p.oreb + p.tov + 0.44 * p.fta;
                        const usage = p.lpPoss > 0 ? (pPoss / p.lpPoss) * 100 : 0;
                        // AST/USG ratio - need to estimate AST% from lineup data
                        // For league-wide, we'll use a simplified AST% calculation
                        const astUsgRatio = usage > 0 ? (p.ast * per75) / usage : 0;
                        // V4.9.8.6: Calculate playerAstPct (simplified - AST / teammate FGM estimate)
                        // Estimate teammate FGM as total team FGM in player's lineups minus player's FGM
                        // For league-wide, use a rough estimate based on average team FGM
                        const teammateFgmEstimate = Math.max(0, (p.lpPoss * 0.45) - p.fgm); // ~45 FGM per 100 poss average
                        const playerAstPct = teammateFgmEstimate > 0 ? (p.ast / teammateFgmEstimate) * 100 : 0;
                        return {
                            player: p.player,
                            team: p.team,
                            poss: p.lpPoss,
                            lpPoss: p.lpPoss,
                            minutes: p.minutes,
                            pts75: p.pts * per75,
                            reb75: p.reb * per75,
                            oreb75: p.oreb * per75,
                            dreb75: p.dreb * per75,
                            ast75: p.ast * per75,
                            stl75: p.stl * per75,
                            blk75: p.blk * per75,
                            tov75: p.tov * per75,
                            tpc75: p.tpc * per75,
                            tsPct: tsPct,
                            rimPct: p.rimA > 0 ? (p.rimM / p.rimA) * 100 : null,
                            midPct: p.midA > 0 ? (p.midM / p.midA) * 100 : null,
                            threePct: p.tpa > 0 ? (p.tpm / p.tpa) * 100 : null,
                            rimA75: p.rimA * per75,
                            midA75: p.midA * per75,
                            threeA75: p.threeA * per75,
                            usage: usage,
                            astUsgRatio: astUsgRatio,
                            playerAstPct: playerAstPct,
                            passTo: p.passTo,
                            dribTo: p.dribTo,
                            // V4.9.8.6: New per 75 stats
                            ptsAst75: p.ptsAst * per75,
                            secChancePts75: p.secChancePts * per75,
                            fastBreakPts75: p.fastBreakPts * per75,
                            clutchPts75: p.clutchPts * per75,
                            // V5.10: BPM stats from seasonStatsMap (will be populated after)
                            bpm: null, obpm: null, dbpm: null,
                            // V5.11: APM stats (will be populated after)
                            apm: null, oapm: null, dapm: null
                        };
                    });
                
                // V5.10: Enrich with BPM stats from seasonStatsMap
                playersWithPer75.forEach(p => {
                    // Use findPlayerWithTeam for consistent fuzzy matching with the leaderboard
                    const seasonStats = findPlayerWithTeam(p.player, p.team, seasonStatsMap);
                    if (seasonStats && seasonStats.bpm !== null && seasonStats.bpm !== undefined && !isNaN(seasonStats.bpm)) {
                        p.bpm = seasonStats.bpm;
                        p.obpm = seasonStats.obpm || 0;
                        p.dbpm = seasonStats.dbpm || 0;
                    }
                });

                // V6.4: Enrich with advanced percentage stats using teamSeasonTotals (same as leaderboard)
                // Uses the exact same Basketball Reference formulas as the leaderboard table
                let enrichDebug = { total: 0, noSeasonStats: 0, noTeamTotals: 0, noMinutes: 0, success: 0 };
                playersWithPer75.forEach(p => {
                    enrichDebug.total++;
                    // Use findPlayerWithTeam for consistent fuzzy matching with the leaderboard
                    const seasonStats = findPlayerWithTeam(p.player, p.team, seasonStatsMap);
                    if (!seasonStats) { enrichDebug.noSeasonStats++; return; }

                    // Use teamSeasonTotals - the same source as the leaderboard
                    const teamTotals = teamSeasonTotals.get(p.team);
                    if (!teamTotals) { enrichDebug.noTeamTotals++; return; }
                    if (!seasonStats.min || seasonStats.min <= 0) { enrichDebug.noMinutes++; return; }
                    enrichDebug.success++;

                    const playerMin = seasonStats.min;
                    // V6.9: Store total season minutes on player for percentile pool filtering
                    p.seasonMin = playerMin;
                    const teamMin = teamTotals.totalMinutes || (teamTotals.games * 40 * 5);
                    const tmMinPer5 = teamMin / 5;

                    // Player totals from seasonStats
                    const pOreb = seasonStats.oreb || 0;
                    const pDreb = seasonStats.dreb || 0;
                    const pReb = seasonStats.reb || (pOreb + pDreb);
                    const pAst = seasonStats.ast || 0;
                    const pTov = seasonStats.tov || 0;
                    const pFga = seasonStats.fga || 0;
                    const pFgm = seasonStats.fgm || 0;
                    const pFta = seasonStats.fta || 0;

                    // Team totals
                    const tmOreb = teamTotals.oreb || 0;
                    const tmDreb = teamTotals.dreb || 0;
                    const tmReb = teamTotals.reb || (tmOreb + tmDreb);
                    const tmFgm = teamTotals.fgm || 0;

                    // Opponent totals (from teamSeasonTotals which has proper opponent data)
                    const oppOreb = teamTotals.oppOreb || 0;
                    const oppDreb = teamTotals.oppDreb || 0;
                    const oppReb = teamTotals.oppReb || (oppOreb + oppDreb);
                    const oppFga = teamTotals.oppFga || 0;
                    const oppTpa = teamTotals.oppTpa || 0;
                    const oppPoss = teamTotals.oppPoss || teamTotals.totalPoss || 0;

                    // OREB% = 100 * (Player OREB * (Team MIN / 5)) / (Player MIN * (Team OREB + Opp DREB))
                    const orebDenom = playerMin * (tmOreb + oppDreb);
                    p.orebPct = orebDenom > 0 ? 100 * (pOreb * tmMinPer5) / orebDenom : null;

                    // DREB% = 100 * (Player DREB * (Team MIN / 5)) / (Player MIN * (Team DREB + Opp OREB))
                    const drebDenom = playerMin * (tmDreb + oppOreb);
                    p.drebPct = drebDenom > 0 ? 100 * (pDreb * tmMinPer5) / drebDenom : null;

                    // TRB% = 100 * (Player REB * (Team MIN / 5)) / (Player MIN * (Team REB + Opp REB))
                    const trbDenom = playerMin * (tmReb + oppReb);
                    p.trbPct = trbDenom > 0 ? 100 * (pReb * tmMinPer5) / trbDenom : null;

                    // AST% = 100 * Player AST / (((Player MIN / (Team MIN / 5)) * Team FGM) - Player FGM)
                    const astDenom = tmMinPer5 > 0 ? ((playerMin / tmMinPer5) * tmFgm) - pFgm : 0;
                    p.astPct = astDenom > 0 ? 100 * pAst / astDenom : null;

                    // TOV% = 100 * Player TOV / (Player FGA + 0.44 * Player FTA + Player TOV)
                    const tovDenom = pFga + 0.44 * pFta + pTov;
                    p.tovPct = tovDenom > 0 ? 100 * pTov / tovDenom : null;

                    // STL% = 100 * (Player STL * (Team MIN / 5)) / (Player MIN * Opp Poss)
                    const pStl = seasonStats.stl || 0;
                    const stlDenom = playerMin * oppPoss;
                    p.stlPct = stlDenom > 0 ? 100 * (pStl * tmMinPer5) / stlDenom : null;

                    // BLK% = 100 * (Player BLK * (Team MIN / 5)) / (Player MIN * (Opp FGA - Opp 3PA))
                    const pBlk = seasonStats.blk || 0;
                    const blkDenom = playerMin * (oppFga - oppTpa);
                    p.blkPct = blkDenom > 0 ? 100 * (pBlk * tmMinPer5) / blkDenom : null;

                    // V6.9: Add Indiv aliases for consistency with fullTableData property names
                    p.astPctIndiv = p.astPct;
                    p.stlPctIndiv = p.stlPct;
                    p.blkPctIndiv = p.blkPct;

                    // eFG% and FT% from season stats
                    p.efgPct = seasonStats.efg || null;
                    p.ftPct = seasonStats.ftPct || null;

                    // V6.6: Calculate position and offensive role using BPM methodology
                    const playerPer100ForPos = {
                        trb: pOreb + pDreb,
                        oreb: pOreb,
                        dreb: pDreb,
                        ast: pAst,
                        stl: seasonStats.stl || 0,
                        blk: pBlk,
                        pf: seasonStats.pf || 0,
                        pts: seasonStats.points || 0,
                        fga: pFga,
                        fta: pFta
                    };
                    const teamThresholdPtsVal = teamThresholdPts.get(p.team) || 30;
                    const teamPer100ForPos = {
                        trb: tmOreb + tmDreb,
                        stl: teamTotals.stl || 0,
                        pf: teamTotals.pf || 0,
                        ast: teamTotals.ast || 0,
                        blk: teamTotals.blk || 0,
                        totalThresholdPts: teamThresholdPtsVal
                    };
                    const positionVal = BPMPositionCalculator.estimatePosition(playerPer100ForPos, teamPer100ForPos, playerMin);
                    p.position = Math.round(positionVal * 10) / 10;
                    p.positionRange = BPMPositionCalculator.getPositionRange(positionVal);

                    // V6.7: Calculate offensive role
                    const teamAvgPtsPerTsa = teamTotals.avgPtsPerTsa || 1.0;
                    const roleVal = BPMPositionCalculator.estimateOffensiveRole(playerPer100ForPos, teamAvgPtsPerTsa, teamPer100ForPos, playerMin);
                    p.offensiveRole = Math.round(roleVal * 10) / 10;
                });

                // DEBUG: Log enrichment results
                console.log('[ENRICH DEBUG] Advanced stats enrichment:', {
                    ...enrichDebug,
                    seasonStatsMapSize: seasonStatsMap.size,
                    teamSeasonTotalsSize: teamSeasonTotals.size,
                    teamSeasonTotalsKeys: Array.from(teamSeasonTotals.keys()),
                    sampleTeamTotals: teamSeasonTotals.size > 0 ? (() => {
                        const firstKey = Array.from(teamSeasonTotals.keys())[0];
                        const t = teamSeasonTotals.get(firstKey);
                        return { team: firstKey, oreb: t?.oreb, dreb: t?.dreb, oppOreb: t?.oppOreb, oppDreb: t?.oppDreb };
                    })() : 'NONE'
                });

                // V5.11: Enrich with APM stats from playerApmStats
                if (playerApmStats && playerApmStats.players) {
                    playersWithPer75.forEach(p => {
                        const apmResult = PlayerRAPMEngine.getPlayerApmValue(playerApmStats, p.player);
                        if (apmResult) {
                            p.apm = apmResult.apm || 0;
                            p.oapm = apmResult.oapm || 0;
                            p.dapm = apmResult.dapm || 0;
                        }
                    });
                }
                
                if (playersWithPer75.length === 0) return null;

                // V6.9: Filter qualifying players for percentile calculations (100+ total minutes played)
                // Non-qualifying players will still display but won't be included in percentile pool
                const qualifiedPlayersForPercentiles = playersWithPer75.filter(p => {
                    // Use findPlayerWithTeam for consistent fuzzy matching with the leaderboard
                    const seasonStats = findPlayerWithTeam(p.player, p.team, seasonStatsMap);
                    if (!seasonStats) return false;
                    const totalMinutes = seasonStats.min || 0;
                    return totalMinutes >= 100;
                });

                // Use qualified players for percentile calculation if available, otherwise use all
                const playersForPercentiles = qualifiedPlayersForPercentiles.length >= 5 ? qualifiedPlayersForPercentiles : playersWithPer75;

                // Build arrays for percentile calculation (using qualified players only - 100+ total minutes)
                const statArrays = {
                    pts75: playersForPercentiles.map(p => p.pts75).sort((a, b) => a - b),
                    reb75: playersForPercentiles.map(p => p.reb75).sort((a, b) => a - b),
                    oreb75: playersForPercentiles.map(p => p.oreb75).sort((a, b) => a - b),
                    dreb75: playersForPercentiles.map(p => p.dreb75).sort((a, b) => a - b),
                    ast75: playersForPercentiles.map(p => p.ast75).sort((a, b) => a - b),
                    stl75: playersForPercentiles.map(p => p.stl75).sort((a, b) => a - b),
                    blk75: playersForPercentiles.map(p => p.blk75).sort((a, b) => a - b),
                    tov75: playersForPercentiles.map(p => p.tov75).sort((a, b) => a - b),
                    tpc75: playersForPercentiles.filter(p => p.tpc75 > 0).map(p => p.tpc75).sort((a, b) => a - b),
                    tsPct: playersForPercentiles.filter(p => p.tsPct !== null).map(p => p.tsPct).sort((a, b) => a - b),
                    rimPct: playersForPercentiles.filter(p => p.rimPct !== null).map(p => p.rimPct).sort((a, b) => a - b),
                    midPct: playersForPercentiles.filter(p => p.midPct !== null).map(p => p.midPct).sort((a, b) => a - b),
                    threePct: playersForPercentiles.filter(p => p.threePct !== null).map(p => p.threePct).sort((a, b) => a - b),
                    rimA75: playersForPercentiles.filter(p => p.rimA75 > 0).map(p => p.rimA75).sort((a, b) => a - b),
                    midA75: playersForPercentiles.filter(p => p.midA75 > 0).map(p => p.midA75).sort((a, b) => a - b),
                    threeA75: playersForPercentiles.filter(p => p.threeA75 > 0).map(p => p.threeA75).sort((a, b) => a - b),
                    usage: playersForPercentiles.filter(p => p.usage > 0).map(p => p.usage).sort((a, b) => a - b),
                    astUsgRatio: playersForPercentiles.filter(p => p.astUsgRatio > 0).map(p => p.astUsgRatio).sort((a, b) => a - b),
                    playerAstPct: playersForPercentiles.filter(p => p.playerAstPct > 0).map(p => p.playerAstPct).sort((a, b) => a - b),
                    passTo: playersForPercentiles.map(p => p.passTo).sort((a, b) => a - b),
                    dribTo: playersForPercentiles.map(p => p.dribTo).sort((a, b) => a - b),
                    // V4.9.8.6: New stats from player_stats_enhanced.csv
                    ptsAst75: playersForPercentiles.filter(p => p.ptsAst75 > 0).map(p => p.ptsAst75).sort((a, b) => a - b),
                    secChancePts75: playersForPercentiles.filter(p => p.secChancePts75 > 0).map(p => p.secChancePts75).sort((a, b) => a - b),
                    fastBreakPts75: playersForPercentiles.filter(p => p.fastBreakPts75 > 0).map(p => p.fastBreakPts75).sort((a, b) => a - b),
                    clutchPts75: playersForPercentiles.filter(p => p.clutchPts75 > 0).map(p => p.clutchPts75).sort((a, b) => a - b),
                    // V5.10: BPM stats from CSV
                    bpm: playersForPercentiles.filter(p => p.bpm !== null).map(p => p.bpm).sort((a, b) => a - b),
                    obpm: playersForPercentiles.filter(p => p.obpm !== null).map(p => p.obpm).sort((a, b) => a - b),
                    dbpm: playersForPercentiles.filter(p => p.dbpm !== null).map(p => p.dbpm).sort((a, b) => a - b),
                    // V5.11: APM stats from playerApmStats
                    apm: playersForPercentiles.filter(p => p.apm !== null).map(p => p.apm).sort((a, b) => a - b),
                    oapm: playersForPercentiles.filter(p => p.oapm !== null).map(p => p.oapm).sort((a, b) => a - b),
                    dapm: playersForPercentiles.filter(p => p.dapm !== null).map(p => p.dapm).sort((a, b) => a - b),
                    // V6.4: Advanced percentage stats for proper percentile comparisons
                    orebPct: playersForPercentiles.filter(p => p.orebPct !== null && p.orebPct > 0).map(p => p.orebPct).sort((a, b) => a - b),
                    drebPct: playersForPercentiles.filter(p => p.drebPct !== null && p.drebPct > 0).map(p => p.drebPct).sort((a, b) => a - b),
                    trbPct: playersForPercentiles.filter(p => p.trbPct !== null && p.trbPct > 0).map(p => p.trbPct).sort((a, b) => a - b),
                    astPct: playersForPercentiles.filter(p => p.astPct !== null && p.astPct > 0).map(p => p.astPct).sort((a, b) => a - b),
                    tovPct: playersForPercentiles.filter(p => p.tovPct !== null && p.tovPct > 0).map(p => p.tovPct).sort((a, b) => a - b),
                    stlPct: playersForPercentiles.filter(p => p.stlPct !== null && p.stlPct > 0).map(p => p.stlPct).sort((a, b) => a - b),
                    blkPct: playersForPercentiles.filter(p => p.blkPct !== null && p.blkPct > 0).map(p => p.blkPct).sort((a, b) => a - b),
                    efgPct: playersForPercentiles.filter(p => p.efgPct !== null && p.efgPct > 0).map(p => p.efgPct).sort((a, b) => a - b),
                    ftPct: playersForPercentiles.filter(p => p.ftPct !== null && p.ftPct > 0).map(p => p.ftPct).sort((a, b) => a - b),
                    // V6.9: Indiv aliases for modal consistency with fullTableData
                    astPctIndiv: playersForPercentiles.filter(p => p.astPctIndiv !== null && p.astPctIndiv > 0).map(p => p.astPctIndiv).sort((a, b) => a - b),
                    stlPctIndiv: playersForPercentiles.filter(p => p.stlPctIndiv !== null && p.stlPctIndiv > 0).map(p => p.stlPctIndiv).sort((a, b) => a - b),
                    blkPctIndiv: playersForPercentiles.filter(p => p.blkPctIndiv !== null && p.blkPctIndiv > 0).map(p => p.blkPctIndiv).sort((a, b) => a - b)
                };

                // V6.6: Build position-based percentile pools for position-filtered comparisons
                // Position ranges: Guards (1.0-1.6), Guard-Wings (1.7-2.5), Wings (2.6-3.5), Wing-Bigs (3.6-4.3), Bigs (4.4-5.0)
                const positionRanges = BPMPositionCalculator.POSITION_RANGES;
                const positionPools = {};

                // Build a pool for each position range
                positionRanges.forEach(range => {
                    const playersInRange = playersForPercentiles.filter(p =>
                        p.position !== null && p.position >= range.min && p.position <= range.max
                    );

                    const rangeKey = range.shortLabel;
                    positionPools[rangeKey] = {
                        players: playersInRange,
                        count: playersInRange.length,
                        range: range,
                        // Build stat arrays for this position range
                        usage: playersInRange.filter(p => p.usage > 0).map(p => p.usage).sort((a, b) => a - b),
                        astPct: playersInRange.filter(p => p.astPct !== null && p.astPct > 0).map(p => p.astPct).sort((a, b) => a - b),
                        tovPct: playersInRange.filter(p => p.tovPct !== null && p.tovPct > 0).map(p => p.tovPct).sort((a, b) => a - b),
                        tsPct: playersInRange.filter(p => p.tsPct !== null).map(p => p.tsPct).sort((a, b) => a - b),
                        efgPct: playersInRange.filter(p => p.efgPct !== null && p.efgPct > 0).map(p => p.efgPct).sort((a, b) => a - b),
                        ftPct: playersInRange.filter(p => p.ftPct !== null && p.ftPct > 0).map(p => p.ftPct).sort((a, b) => a - b),
                        orebPct: playersInRange.filter(p => p.orebPct !== null && p.orebPct > 0).map(p => p.orebPct).sort((a, b) => a - b),
                        drebPct: playersInRange.filter(p => p.drebPct !== null && p.drebPct > 0).map(p => p.drebPct).sort((a, b) => a - b),
                        stlPct: playersInRange.filter(p => p.stlPct !== null && p.stlPct > 0).map(p => p.stlPct).sort((a, b) => a - b),
                        blkPct: playersInRange.filter(p => p.blkPct !== null && p.blkPct > 0).map(p => p.blkPct).sort((a, b) => a - b),
                        threeA75: playersInRange.filter(p => p.threeA75 > 0).map(p => p.threeA75).sort((a, b) => a - b),
                        threePct: playersInRange.filter(p => p.threePct !== null).map(p => p.threePct).sort((a, b) => a - b),
                        rimA75: playersInRange.filter(p => p.rimA75 > 0).map(p => p.rimA75).sort((a, b) => a - b),
                        rimPct: playersInRange.filter(p => p.rimPct !== null).map(p => p.rimPct).sort((a, b) => a - b),
                        midA75: playersInRange.filter(p => p.midA75 > 0).map(p => p.midA75).sort((a, b) => a - b),
                        midPct: playersInRange.filter(p => p.midPct !== null).map(p => p.midPct).sort((a, b) => a - b),
                        fastBreakPts75: playersInRange.filter(p => p.fastBreakPts75 > 0).map(p => p.fastBreakPts75).sort((a, b) => a - b),
                        bpm: playersInRange.filter(p => p.bpm !== null).map(p => p.bpm).sort((a, b) => a - b)
                    };
                });

                console.log('[POSITION POOLS DEBUG] Built position pools:', {
                    ranges: positionRanges.map(r => r.shortLabel),
                    poolSizes: Object.entries(positionPools).map(([k, v]) => ({ pos: k, count: v.count }))
                });

                // Calculate averages
                const calcAvg = arr => arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
                const averages = {
                    pts75: calcAvg(statArrays.pts75),
                    reb75: calcAvg(statArrays.reb75),
                    oreb75: calcAvg(statArrays.oreb75),
                    dreb75: calcAvg(statArrays.dreb75),
                    ast75: calcAvg(statArrays.ast75),
                    stl75: calcAvg(statArrays.stl75),
                    blk75: calcAvg(statArrays.blk75),
                    tov75: calcAvg(statArrays.tov75),
                    tpc75: calcAvg(statArrays.tpc75),
                    tsPct: calcAvg(statArrays.tsPct),
                    rimPct: calcAvg(statArrays.rimPct),
                    midPct: calcAvg(statArrays.midPct),
                    threePct: calcAvg(statArrays.threePct),
                    rimA75: calcAvg(statArrays.rimA75),
                    midA75: calcAvg(statArrays.midA75),
                    threeA75: calcAvg(statArrays.threeA75),
                    usage: calcAvg(statArrays.usage),
                    astUsgRatio: calcAvg(statArrays.astUsgRatio),
                    playerAstPct: calcAvg(statArrays.playerAstPct),
                    passTo: calcAvg(statArrays.passTo),
                    dribTo: calcAvg(statArrays.dribTo),
                    // V4.9.8.6: New stats from player_stats_enhanced.csv
                    ptsAst75: calcAvg(statArrays.ptsAst75),
                    secChancePts75: calcAvg(statArrays.secChancePts75),
                    fastBreakPts75: calcAvg(statArrays.fastBreakPts75),
                    clutchPts75: calcAvg(statArrays.clutchPts75),
                    // V5.10: BPM stats from CSV
                    bpm: calcAvg(statArrays.bpm),
                    obpm: calcAvg(statArrays.obpm),
                    dbpm: calcAvg(statArrays.dbpm),
                    // V5.11: APM stats from playerApmStats
                    apm: calcAvg(statArrays.apm),
                    oapm: calcAvg(statArrays.oapm),
                    dapm: calcAvg(statArrays.dapm),
                    // V6.4: Advanced percentage stats
                    orebPct: calcAvg(statArrays.orebPct),
                    drebPct: calcAvg(statArrays.drebPct),
                    trbPct: calcAvg(statArrays.trbPct),
                    astPct: calcAvg(statArrays.astPct),
                    tovPct: calcAvg(statArrays.tovPct),
                    stlPct: calcAvg(statArrays.stlPct),
                    blkPct: calcAvg(statArrays.blkPct),
                    efgPct: calcAvg(statArrays.efgPct),
                    ftPct: calcAvg(statArrays.ftPct)
                };

                // DEBUG: Log pool building results
                console.log('[POOL BUILD DEBUG] leaguePlayerAverages built:', {
                    totalPlayers: playersWithPer75.length,
                    qualifiedPlayers: playersForPercentiles.length,
                    orebPctPoolSize: statArrays.orebPct?.length || 0,
                    drebPctPoolSize: statArrays.drebPct?.length || 0,
                    orebPctSample: statArrays.orebPct?.length > 0 ? {
                        min: statArrays.orebPct[0],
                        max: statArrays.orebPct[statArrays.orebPct.length - 1],
                        median: statArrays.orebPct[Math.floor(statArrays.orebPct.length / 2)]
                    } : 'EMPTY',
                    drebPctSample: statArrays.drebPct?.length > 0 ? {
                        min: statArrays.drebPct[0],
                        max: statArrays.drebPct[statArrays.drebPct.length - 1],
                        median: statArrays.drebPct[Math.floor(statArrays.drebPct.length / 2)]
                    } : 'EMPTY',
                    playersWithOrebPct: playersForPercentiles.filter(p => p.orebPct !== null && p.orebPct > 0).length,
                    playersWithDrebPct: playersForPercentiles.filter(p => p.drebPct !== null && p.drebPct > 0).length,
                    samplePlayerOrebPct: playersForPercentiles.slice(0, 3).map(p => ({ player: p.player, orebPct: p.orebPct, drebPct: p.drebPct }))
                });

                // V4.9.8.6: Return players array for Individual leaderboard (all teams)
                // V6.6: Include positionPools for position-based percentile comparisons
                return { statArrays, averages, playerCount: playersWithPer75.length, players: playersWithPer75, positionPools };
            }, [playerData, lineupData, playerApmStats, teamSeasonTotals]);

            // V4.9.8: Calculate percentile for a value against an array (higher = better except for TOV)
            const calcLeaguePercentile = (value, sortedArray, higherBetter = true) => {
                if (!sortedArray || sortedArray.length === 0) return 50;
                const rank = sortedArray.filter(v => v <= value).length;
                const pct = (rank / sortedArray.length) * 100;
                return higherBetter ? pct : 100 - pct;
            };

            // V4.9.8: Get performance class from league percentile
            const getLeaguePerfClass = (pct) => {
                if (pct >= 80) return 'perf-excellent';
                if (pct >= 60) return 'perf-good';
                if (pct >= 40) return 'perf-average';
                if (pct >= 20) return 'perf-below';
                return 'perf-poor';
            };

            // Upload screen
            if (!lineupCsv) {
                return e('div', { className: 'upload-screen' }, e('div', { className: 'upload-box' },
                    e('h1', { style: { fontSize: '32px', marginBottom: '16px' }}, 'Basketball Lineup Analyzer V4.9.8.7.17'),
                    e('p', { style: { marginBottom: '24px', opacity: 0.8 }}, 'Upload a folder with all CSVs, or upload individual files below.'),

                    // AUTO-LOAD STATUS INDICATOR
                    autoLoadStatus === 'loading' && e('div', { style: { marginBottom: '20px', padding: '16px', background: 'rgba(59, 130, 246, 0.15)', borderRadius: '12px', border: '1px solid rgba(59, 130, 246, 0.4)' }},
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', justifyContent: 'center' }},
                            e('div', { style: { width: '20px', height: '20px', border: '3px solid rgba(59, 130, 246, 0.3)', borderTop: '3px solid #60a5fa', borderRadius: '50%', animation: 'spin 1s linear infinite' }}),
                            e('span', { style: { color: '#93c5fd' }}, autoLoadMessage || 'Scanning for data folder...')
                        )
                    ),
                    autoLoadStatus === 'success' && e('div', { style: { marginBottom: '20px', padding: '16px', background: 'rgba(34, 197, 94, 0.15)', borderRadius: '12px', border: '1px solid rgba(34, 197, 94, 0.4)' }},
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', justifyContent: 'center', color: '#4ade80' }},
                            e('span', { style: { fontSize: '20px' }}, '✓'),
                            e('span', null, autoLoadMessage || 'Data loaded automatically!')
                        )
                    ),
                    autoLoadStatus === 'failed' && e('div', { style: { marginBottom: '20px', padding: '12px', background: 'rgba(251, 191, 36, 0.1)', borderRadius: '8px', border: '1px solid rgba(251, 191, 36, 0.3)' }},
                        e('div', { style: { fontSize: '12px', color: '#fbbf24', textAlign: 'center' }},
                            autoLoadMessage || 'Auto-load not available. Use folder upload below.')
                    ),

                    // TAURI UPDATE DATA SECTION (only shown in Tauri app)
                    isTauriApp && e('div', { style: { marginBottom: '24px', padding: '20px', background: 'linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.15))', borderRadius: '12px', border: '1px solid rgba(16, 185, 129, 0.4)' }},
                        e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: isScraperRunning ? '16px' : '0' }},
                            e('div', null,
                                e('div', { style: { fontSize: '16px', fontWeight: 600, color: '#4ade80', marginBottom: '4px' }}, '🔄 Auto-Update Data'),
                                e('div', { style: { fontSize: '12px', color: '#94a3b8' }}, 'Fetch latest game data from FIBA LiveStats')
                            ),
                            e('button', {
                                onClick: handleUpdateData,
                                disabled: isScraperRunning,
                                style: {
                                    padding: '12px 24px',
                                    background: isScraperRunning ? 'rgba(100, 116, 139, 0.5)' : 'linear-gradient(135deg, #10b981, #059669)',
                                    border: 'none',
                                    borderRadius: '8px',
                                    color: 'white',
                                    fontWeight: 600,
                                    fontSize: '14px',
                                    cursor: isScraperRunning ? 'not-allowed' : 'pointer',
                                    transition: 'all 0.2s ease'
                                }
                            }, isScraperRunning ? '⏳ Updating...' : '🚀 Update Now')
                        ),
                        // Progress bar (shown when scraper is running)
                        isScraperRunning && scraperProgress && e('div', null,
                            e('div', { style: { marginBottom: '8px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }},
                                e('span', { style: { fontSize: '13px', color: '#a5b4fc' }}, scraperProgress.message || 'Processing...'),
                                e('button', {
                                    onClick: handleCancelScraper,
                                    style: { padding: '4px 12px', background: 'rgba(239, 68, 68, 0.3)', border: '1px solid rgba(239, 68, 68, 0.5)', borderRadius: '4px', color: '#f87171', fontSize: '11px', cursor: 'pointer' }
                                }, 'Cancel')
                            ),
                            e('div', { style: { height: '8px', background: 'rgba(255,255,255,0.1)', borderRadius: '4px', overflow: 'hidden' }},
                                e('div', { style: {
                                    width: (scraperProgress.progress_percent || 0) + '%',
                                    height: '100%',
                                    background: 'linear-gradient(90deg, #10b981, #4ade80)',
                                    borderRadius: '4px',
                                    transition: 'width 0.3s ease'
                                }})
                            ),
                            e('div', { style: { marginTop: '6px', fontSize: '11px', color: '#64748b', display: 'flex', justifyContent: 'space-between' }},
                                e('span', null, scraperProgress.current_game ? 'Game: ' + scraperProgress.current_game : ''),
                                e('span', null, (scraperProgress.games_completed || 0) + ' / ' + (scraperProgress.games_total || '?') + ' games')
                            )
                        )
                    ),

                    // FOLDER UPLOAD - Primary option
                    e('div', { style: { marginBottom: '24px', padding: '20px', background: 'rgba(139, 92, 246, 0.15)', borderRadius: '12px', border: '2px dashed rgba(139, 92, 246, 0.5)' }},
                        e('input', { type: 'file', webkitdirectory: 'true', directory: 'true', multiple: true, onChange: handleFolder, style: { display: 'none' }, id: 'folder-upload' }),
                        e('label', { htmlFor: 'folder-upload', style: { cursor: 'pointer', display: 'block', textAlign: 'center' }},
                            e('div', { style: { fontSize: '48px', marginBottom: '8px' }}, '📁'),
                            e('div', { className: 'upload-btn', style: { background: 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)', fontSize: '18px', padding: '16px 32px' }}, '📂 Select Folder'),
                            e('div', { style: { fontSize: '12px', marginTop: '8px', opacity: 0.7 }}, 'Auto-detects: stints, team_totals, lineup_stats, player_stats, matchups, assists, clutch')
                        ),
                        folderLoaded && e('div', { style: { marginTop: '12px', textAlign: 'left', padding: '12px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }},
                            e('div', { style: { color: folderLoaded[0]?.startsWith('No ') ? '#f87171' : '#4ade80', fontWeight: 'bold', marginBottom: '8px' }}, 
                                folderLoaded[0]?.startsWith('No ') ? '⚠️ ' + folderLoaded[0] : '✓ Loaded ' + folderLoaded.length + ' file(s):'),
                            folderLoaded[0]?.startsWith('No ') 
                                ? folderLoaded.slice(1).map((f, i) => e('div', { key: i, style: { fontSize: '11px', color: '#94a3b8', padding: '2px 0' }}, f))
                                : folderLoaded.map((f, i) => e('div', { key: i, style: { fontSize: '11px', color: '#a5b4fc', padding: '2px 0' }}, '• ' + f))
                        )
                    ),
                    
                    // Divider
                    e('div', { style: { display: 'flex', alignItems: 'center', margin: '16px 0', opacity: 0.5 }},
                        e('div', { style: { flex: 1, height: '1px', background: 'rgba(255,255,255,0.3)' }}),
                        e('span', { style: { padding: '0 16px', fontSize: '12px' }}, 'OR upload individually'),
                        e('div', { style: { flex: 1, height: '1px', background: 'rgba(255,255,255,0.3)' }})
                    ),
                    
                    // Individual file uploads
                    e('div', { style: { marginBottom: '16px' }}, e('input', { type: 'file', accept: '.csv', onChange: handleLineup, style: { display: 'none' }, id: 'lu' }), e('label', { htmlFor: 'lu' }, e('div', { className: 'upload-btn' }, '📊 Upload Lineup CSV'))), 
                    e('div', { style: { marginBottom: '16px' }}, e('input', { type: 'file', accept: '.csv', onChange: handlePlayer, style: { display: 'none' }, id: 'pu' }), e('label', { htmlFor: 'pu' }, e('div', { className: 'upload-btn secondary' }, '👤 Upload Player CSV'))), 
                    e('div', { style: { marginBottom: '16px' }}, e('input', { type: 'file', accept: '.csv', onChange: handleMatchup, style: { display: 'none' }, id: 'mu' }), e('label', { htmlFor: 'mu' }, e('div', { className: 'upload-btn matchup' }, '⚔️ Upload Matchup CSV'))),
                    e('div', { style: { marginBottom: '16px' }}, e('input', { type: 'file', accept: '.csv', onChange: handleSeason, style: { display: 'none' }, id: 'su' }), e('label', { htmlFor: 'su' }, e('div', { className: 'upload-btn season' }, '📈 Upload Season Stats CSV'))),
                    e('div', null, e('input', { type: 'file', accept: '.csv', onChange: handleAssistCombo, style: { display: 'none' }, id: 'acu' }), e('label', { htmlFor: 'acu' }, e('div', { className: 'upload-btn', style: { background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)' }}, '🤝 Upload Assist Combos CSV'))),
                    e('div', { style: { marginTop: '16px' }}, e('input', { type: 'file', accept: '.csv', onChange: handleClutch, style: { display: 'none' }, id: 'clu' }), e('label', { htmlFor: 'clu' }, e('div', { className: 'upload-btn', style: { background: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)' }}, '⏱️ Upload Clutch Stats CSV'))),
                    e('div', { style: { marginTop: '16px' }}, e('input', { type: 'file', accept: '.csv', onChange: handleStints, style: { display: 'none' }, id: 'stu' }), e('label', { htmlFor: 'stu' }, e('div', { className: 'upload-btn', style: { background: 'linear-gradient(135deg, #06b6d4 0%, #0891b2 100%)' }}, '📊 Upload Stints CSV (Player RAPM)'))),
                    playerFile && e('p', { style: { marginTop: '12px', color: '#4ade80' }}, '✓ ' + playerFile),
                    matchupFile && e('p', { style: { marginTop: '8px', color: '#22d3ee' }}, '✓ ' + matchupFile),
                    seasonFile && e('p', { style: { marginTop: '8px', color: '#10b981' }}, '✓ ' + seasonFile),
                    assistComboFile && e('p', { style: { marginTop: '8px', color: '#f59e0b' }}, '✓ ' + assistComboFile),
                    clutchFile && e('p', { style: { marginTop: '8px', color: '#ef4444' }}, '✓ ' + clutchFile),
                    stintsFile && e('p', { style: { marginTop: '8px', color: '#06b6d4' }}, '✓ ' + stintsFile)));
            }

            const afc = Object.values(selPlayers).filter(p => p !== '').length;
            
            // Percentile display component - V4.9.8.7.30: Now shows rank instead of percentile
            // val can be: number (legacy percentile), or object { rank, total, pct }
            const Pct = ({ val, isOpp = false }) => {
                // Handle both old format (number) and new format (object with rank/total/pct)
                let displayText, pctForColor;
                if (typeof val === 'object' && val !== null && 'rank' in val) {
                    displayText = val.rank + '/' + val.total;
                    pctForColor = val.pct;
                } else {
                    // Legacy: val is just a percentile number
                    displayText = Math.round(val) + 'th';
                    pctForColor = val;
                }
                return e('span', { className: 'pct-box ' + getPctClass(pctForColor) + (isOpp ? ' pct-opp' : ' pct-yours') },
                    e('span', { className: 'pct-box-label', style: { color: isOpp ? '#a78bfa' : '#60a5fa' }}, isOpp ? 'OPP' : 'YOU'),
                    e('span', null, displayText)
                );
            };
            
            // V4.6: Helper function for relative mode color gradient based on distance from 0
            // Returns color with intensity proportional to the magnitude of the difference
            const getRelativeColor = (diff, higherBetter = true, maxDiff = 10) => {
                if (diff === 0 || isNaN(diff)) return '#94a3b8'; // Neutral gray
                const isPositive = diff > 0;
                const isGood = (isPositive && higherBetter) || (!isPositive && !higherBetter);
                const intensity = Math.min(1, Math.abs(diff) / maxDiff);
                
                if (isGood) {
                    // Green gradient: from #4ade80 (light) to #16a34a (dark/intense)
                    const r = Math.round(74 - (74 - 22) * intensity);
                    const g = Math.round(222 - (222 - 163) * intensity);
                    const b = Math.round(128 - (128 - 74) * intensity);
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    // Red gradient: from #f87171 (light) to #dc2626 (dark/intense)
                    const r = Math.round(248 - (248 - 220) * intensity);
                    const g = Math.round(113 - (113 - 38) * intensity);
                    const b = Math.round(113 - (113 - 38) * intensity);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            };
            
            // V4.6.2: MATHEMATICALLY CORRECT eFG% Contribution Formulas
            // 
            // FORMULA A - "eFG% Contribution" (Volume + Efficiency vs League):
            //   C_z = (f_z × e_z) - (league_f_z × league_e_z)
            //   Where: f_z = team frequency at zone, e_z = team eFG-equiv at zone
            //   This measures: "How much does this zone contribute to team eFG% being above/below league average?"
            //   Property: Sum of all zone contributions = Team eFG% - League eFG%
            //
            // FORMULA B - "Zone Skill" (Efficiency vs Zone-Specific League Avg):
            //   S_z = f_z × (e_z - league_e_z)
            //   This measures: "Given our volume at this zone, how much better/worse are we than league avg AT THAT ZONE?"
            //   Isolates shooting/defensive skill from shot selection
            //
            // Parameters:
            //   made, att = team's makes and attempts at this zone
            //   totalAtt = team's total FGA (all zones)
            //   leagueFreq = league's frequency at this zone (as decimal, e.g., 0.35)
            //   leagueEfgEquiv = league's eFG-equivalent at this zone (already multiplied for 3PT)
            //   isThree = whether this is a 3PT zone (for calculating team's eFG-equiv)
            //
            const calcShotContributionV2 = (made, att, totalAtt, isThree, leagueFreq, leagueEfgEquiv) => {
                if (totalAtt <= 0 || att <= 0) return { 
                    contribution: 0, // Formula A
                    zoneSkill: 0,    // Formula B
                    frequency: 0, 
                    efgEquiv: 0,
                    leagueContrib: 0
                };
                
                const frequency = att / totalAtt; // Team's frequency at this zone (decimal)
                const shotPct = (made / att) * 100; // Team's FG% at this zone
                const multiplier = isThree ? 1.5 : 1;
                const efgEquiv = shotPct * multiplier; // Team's eFG-equivalent at this zone
                
                // Formula A: Full contribution (volume + efficiency vs league)
                // How much this zone adds to team eFG% minus how much it adds for league avg team
                const teamContrib = frequency * efgEquiv;
                const leagueContrib = leagueFreq * leagueEfgEquiv;
                const contribution = teamContrib - leagueContrib;
                
                // Formula B: Zone skill (efficiency vs zone-specific league avg, weighted by team volume)
                // Positive = better than league at this zone, Negative = worse
                const zoneSkill = frequency * (efgEquiv - leagueEfgEquiv);
                
                return { 
                    contribution,  // Formula A result
                    zoneSkill,     // Formula B result
                    frequency: frequency * 100, // As percentage for display
                    efgEquiv,
                    leagueContrib
                };
            };
            
            // Stat with context - V4.6 ENHANCED with gradient relative colors
            // V4.6.2: Schedule adjustment now uses empirically estimated β from matchup data
            // For compositional consistency, we adjust ORTG/DRTG directly and derive implied factor changes
            // 
            // Mathematical Model:
            //   stat_adj = stat_obs - β × (opp_quality - league_avg)
            // Where β is estimated via weighted least squares from matchup data
            //
            // For individual factors, we use ORTG-derived adjustment to maintain compositional consistency
            const StatWithContext = ({ val, pct, oppVal, oppPct, fmt = 1, oppHigherHarder = true, teamAvgVal, higherBetter = true, showBar = false, leagueKey, schedAdjKey, leagueAvgSource }) => {
                const hasOpp = oppQuality && oppVal !== undefined && oppPct !== undefined;
                const hasTeamAvg = teamAvgVal !== undefined;
                
                // V4.6.1: Use provided leagueAvgSource or default to leagueAverages
                const effectiveLeagueAvg = leagueAvgSource || leagueAverages;
                
                // V4.6.2: Apply opponent-quality-based schedule adjustment using empirical β
                // Key insight: Adjust ORTG/DRTG directly, then derive implied factor adjustments
                // This maintains the compositional relationship: ORTG = f(eFG%, TOV%, OREB%, FTR)
                let adjVal = val;
                let adjSource = null; // Track adjustment source for display
                
                // V4.6.3: Combine master slider with individual slider (capped at 100)
                const individualAdj = schedAdjKey ? (mainScheduleAdj[schedAdjKey] || 0) : 0;
                const totalScheduleAdj = Math.min(100, mainMasterScheduleAdj + individualAdj);
                
                if (schedAdjKey && totalScheduleAdj > 0 && effectiveLeagueAvg && leagueKey && oppQuality) {
                    const adjFactor = totalScheduleAdj / 100;
                    const leagueAvg = effectiveLeagueAvg[leagueKey] || val;
                    
                    // Determine stat type
                    const isRating = ['off', 'def'].includes(leagueKey);
                    const isOffensiveStat = ['off', 'offEfg', 'offTov', 'offOreb', 'offFtR'].includes(leagueKey);
                    const isDefensiveStat = ['def', 'defEfg', 'defTov', 'defOreb', 'defFtR'].includes(leagueKey);
                    
                    // Get empirical β or use 0.5 as fallback
                    const getBeta = (key) => {
                        if (!empiricalBeta) return 0.5;
                        return empiricalBeta[key] || 0.5;
                    };
                    
                    if (isRating) {
                        // =================================================================
                        // DIRECT RATING ADJUSTMENT (Recommendation 1 from 3.4)
                        // Adjust ORTG/DRTG directly using empirical β
                        // =================================================================
                        if (leagueKey === 'off') {
                            // Our ORTG adjustment based on opponent DRTG
                            const oppDefRtg = oppQuality.oppDef || effectiveLeagueAvg.def || 100;
                            const leagueDefRtg = effectiveLeagueAvg.def || 100;
                            const beta = getBeta('ortg');
                            const oppDiff = oppDefRtg - leagueDefRtg;
                            // If opponents have weak D (oppDef > league), our ORTG is inflated → reduce
                            // Note: For DRTG perspective, higher = worse D = allows more pts
                            adjVal = val - oppDiff * beta * adjFactor;
                            adjSource = `β=${beta.toFixed(2)}, ΔoppD=${oppDiff.toFixed(1)}`;
                        } else if (leagueKey === 'def') {
                            // Our DRTG adjustment based on opponent ORTG
                            const oppOffRtg = oppQuality.oppOff || effectiveLeagueAvg.off || 100;
                            const leagueOffRtg = effectiveLeagueAvg.off || 100;
                            const beta = getBeta('drtg');
                            const oppDiff = oppOffRtg - leagueOffRtg;
                            // If opponents have strong O (oppOff > league), our DRTG looks worse → give credit
                            adjVal = val - oppDiff * beta * adjFactor;
                            adjSource = `β=${beta.toFixed(2)}, ΔoppO=${oppDiff.toFixed(1)}`;
                        }
                    } else if (isOffensiveStat) {
                        // =================================================================
                        // FACTOR ADJUSTMENT DERIVED FROM ORTG (Compositional Consistency)
                        // V4.6.2 FIX: Instead of adjusting factors independently, we:
                        // 1. Calculate what ORTG adjustment would be
                        // 2. Derive implied factor change using partial derivatives (sensitivities)
                        // 
                        // Sensitivities (∂ORTG/∂Factor) from Poropudas & Halme (2023):
                        //   ∂ORTG/∂eFG% ≈ 1.20 (1% eFG% → +1.2 ORTG)
                        //   ∂ORTG/∂TOV% ≈ -1.10 (1% TOV% → -1.1 ORTG, negative!)
                        //   ∂ORTG/∂OREB% ≈ 0.45 (1% OREB% → +0.45 ORTG)
                        //   ∂ORTG/∂FTR ≈ 0.25 (1% FTR → +0.25 ORTG)
                        // 
                        // Oliver's weights: eFG% (40%), TOV% (25%), OREB% (20%), FTR (15%)
                        // 
                        // Implied factor adjustment: Δ_factor = Δ_ORTG × weight / sensitivity
                        // =================================================================
                        
                        // First, calculate the ORTG adjustment
                        const oppDefRtg = oppQuality.oppDef || effectiveLeagueAvg.def || 100;
                        const leagueDefRtg = effectiveLeagueAvg.def || 100;
                        const betaOrtg = getBeta('ortg');
                        const ortgOppDiff = oppDefRtg - leagueDefRtg;
                        const deltaOrtg = ortgOppDiff * betaOrtg * adjFactor;
                        
                        // Oliver's weights and sensitivities for compositional decomposition
                        const oliverConfig = {
                            'offEfg':  { weight: 0.40, sensitivity: 1.20, sign: 1 },   // Higher eFG% → higher ORTG
                            'offTov':  { weight: 0.25, sensitivity: -1.10, sign: -1 }, // Higher TOV% → lower ORTG  
                            'offOreb': { weight: 0.20, sensitivity: 0.45, sign: 1 },   // Higher OREB% → higher ORTG
                            'offFtR':  { weight: 0.15, sensitivity: 0.25, sign: 1 }    // Higher FTR → higher ORTG
                        };
                        
                        const config = oliverConfig[leagueKey];
                        if (config) {
                            // Derive factor adjustment from ORTG adjustment
                            // Δ_factor = Δ_ORTG × (weight / |sensitivity|) × sign
                            // This ensures: Σ(Δ_factor × sensitivity) ≈ Δ_ORTG
                            const impliedDelta = deltaOrtg * (config.weight / Math.abs(config.sensitivity)) * config.sign;
                            adjVal = val - impliedDelta;
                            adjSource = `Δ_ORTG=${deltaOrtg.toFixed(1)}, w=${config.weight}`;
                        }
                    } else if (isDefensiveStat) {
                        // =================================================================
                        // DEFENSIVE FACTOR ADJUSTMENT (Same logic, opposite direction)
                        // Sensitivities are same magnitude but applied to DRTG
                        // =================================================================
                        
                        // First, calculate the DRTG adjustment
                        const oppOffRtg = oppQuality.oppOff || effectiveLeagueAvg.off || 100;
                        const leagueOffRtg = effectiveLeagueAvg.off || 100;
                        const betaDrtg = getBeta('drtg');
                        const drtgOppDiff = oppOffRtg - leagueOffRtg;
                        const deltaDrtg = drtgOppDiff * betaDrtg * adjFactor;
                        
                        // For defensive stats, lower is better (except defTov where higher = good)
                        // Sensitivities for DRTG: same magnitudes, different interpretation
                        const oliverConfig = {
                            'defEfg':  { weight: 0.40, sensitivity: 1.20, sign: 1 },   // Higher opp eFG% → higher DRTG (bad)
                            'defTov':  { weight: 0.25, sensitivity: -1.10, sign: -1 }, // Higher forced TOV% → lower DRTG (good)
                            'defOreb': { weight: 0.20, sensitivity: 0.45, sign: 1 },   // Higher opp OREB% → higher DRTG (bad)
                            'defFtR':  { weight: 0.15, sensitivity: 0.25, sign: 1 }    // Higher opp FTR → higher DRTG (bad)
                        };
                        
                        const config = oliverConfig[leagueKey];
                        if (config) {
                            // Derive factor adjustment from DRTG adjustment
                            const impliedDelta = deltaDrtg * (config.weight / Math.abs(config.sensitivity)) * config.sign;
                            adjVal = val - impliedDelta;
                            adjSource = `Δ_DRTG=${deltaDrtg.toFixed(1)}, w=${config.weight}`;
                        }
                    } else {
                        // Fallback for other stats - use old regression method
                        adjVal = val + (leagueAvg - val) * adjFactor;
                    }
                } else if (schedAdjKey && totalScheduleAdj > 0 && effectiveLeagueAvg && leagueKey) {
                    // No oppQuality available - fall back to league average regression
                    const leagueAvg = effectiveLeagueAvg[leagueKey] || val;
                    adjVal = val + (leagueAvg - val) * (totalScheduleAdj / 100);
                }
                
                const delta = hasTeamAvg ? adjVal - teamAvgVal : 0;
                const isGood = higherBetter ? delta > 0 : delta < 0;
                const deltaClass = Math.abs(delta) < 0.5 ? 'team-avg-same' : isGood ? 'team-avg-better' : 'team-avg-worse';
                const deltaColor = Math.abs(delta) < 0.5 ? '#94a3b8' : isGood ? '#4ade80' : '#f87171';
                const arrowIcon = Math.abs(delta) < 0.5 ? '―' : isGood ? '▲' : '▼';
                
                // Calculate display value (raw or relative to league) - V4.6: Use gradient colors
                let displayVal = adjVal.toFixed(fmt);
                let relativeVal = null;
                let relativeColor = '#94a3b8';
                if (showRelativeToLeague && effectiveLeagueAvg && leagueKey) {
                    const leagueAvg = effectiveLeagueAvg[leagueKey] || 0;
                    const relDiff = adjVal - leagueAvg;
                    relativeVal = (relDiff >= 0 ? '+' : '') + relDiff.toFixed(fmt);
                    // V4.6: Use gradient color based on distance from 0
                    relativeColor = getRelativeColor(relDiff, higherBetter, 8);
                }
                
                return e('div', { style: { display: 'flex', flexDirection: 'column' }},
                    e('div', { className: 'stat-row' },
                        showRelativeToLeague && relativeVal ? 
                            e('span', { style: { fontSize: '24px', fontWeight: 'bold', color: relativeColor }}, relativeVal) :
                            e('span', { style: { fontSize: '24px', fontWeight: 'bold' }}, displayVal),
                        e(Pct, { val: pct }),
                        hasOpp && e(Pct, { val: oppPct, isOpp: true }),
                        hasOpp && e('span', { className: 'opp-badge ' + getOppClass(oppHigherHarder ? oppPct : 100 - oppPct), style: { marginLeft: '4px' } },
                            'vs ', oppVal.toFixed(1)
                        )
                    ),
                    showRelativeToLeague && relativeVal && e('div', { style: { fontSize: '10px', color: '#64748b', marginTop: '2px' }}, 
                        'Raw: ' + adjVal.toFixed(fmt) + (schedAdjKey && totalScheduleAdj > 0 ? ' (adj)' : '')
                    ),
                    hasTeamAvg && e('div', { className: 'inline-team-avg' },
                        e('span', { className: 'inline-team-avg-label' }, '📊 Team:'),
                        e('span', { className: 'inline-team-avg-value' }, teamAvgVal.toFixed(1)),
                        e('span', { className: 'inline-team-avg-delta ' + deltaClass }, 
                            arrowIcon + ' ' + (delta >= 0 ? '+' : '') + delta.toFixed(1)
                        )
                    )
                );
            };

            // NEW: Shot Distribution Modal Component
            const ShotDistModal = () => {
                if (!showShotModal || !fStats) return null;
                const isOffense = shotModalType === 'offense';
                const title = isOffense ? '🎯 Offensive Shot Distribution Breakdown' : '🛡️ Defensive Shot Distribution (Allowed)';
                const subtitle = afc > 0 
                    ? 'Player combination: ' + Object.values(selPlayers).filter(p => p !== '').join(', ')
                    : 'Team-wide breakdown for ' + team;
                
                // Calculate totals
                const rimA = isOffense ? fStats.rimA : fStats.rimAV;
                const rimM = isOffense ? fStats.rimM : fStats.rimMV;
                const midA = isOffense ? fStats.midA : fStats.midAV;
                const midM = isOffense ? fStats.midM : fStats.midMV;
                const threeA = isOffense ? fStats.threeA : fStats.threeAV;
                const threeM = isOffense ? fStats.threeM : fStats.threeMV;
                const totalShots = rimA + midA + threeA;
                
                const rimRate = totalShots > 0 ? (rimA / totalShots) * 100 : 0;
                const midRate = totalShots > 0 ? (midA / totalShots) * 100 : 0;
                const threeRate = totalShots > 0 ? (threeA / totalShots) * 100 : 0;
                
                const rimPct = rimA > 0 ? (rimM / rimA) * 100 : 0;
                const midPct = midA > 0 ? (midM / midA) * 100 : 0;
                const threePct = threeA > 0 ? (threeM / threeA) * 100 : 0;
                
                // Expected points per shot
                const rimEPS = rimA > 0 ? (rimM * 2) / rimA : 0;
                const midEPS = midA > 0 ? (midM * 2) / midA : 0;
                const threeEPS = threeA > 0 ? (threeM * 3) / threeA : 0;
                
                // Player breakdown for shots (only if player data available)
                const hasPlayerData = playerBreakdown.length > 0;
                
                return e('div', { className: 'modal-overlay', onClick: () => setShowShotModal(false) },
                    e('div', { className: 'modal-content shot-modal', onClick: ev => ev.stopPropagation() },
                        e('div', { className: 'modal-header' },
                            e('div', null,
                                e('h2', { style: { fontSize: '24px', fontWeight: 'bold', color: isOffense ? '#4ade80' : '#f87171' }}, title),
                                e('p', { style: { marginTop: '8px', opacity: 0.8 }}, subtitle),
                                e('p', { style: { marginTop: '4px', fontSize: '12px', opacity: 0.6 }}, 'Total Shots: ' + Math.round(totalShots) + ' | Made: ' + Math.round(rimM + midM + threeM))
                            ),
                            e('button', { className: 'modal-close', onClick: () => setShowShotModal(false) }, '×')
                        ),
                        
                        // Shot distribution bar
                        e('div', { style: { marginBottom: '24px' }},
                            e('div', { className: 'shot-dist-bar', style: { height: '50px' }},
                                rimRate > 0 && e('div', { className: 'shot-segment shot-rim', style: { width: rimRate + '%' }}, rimRate >= 10 ? 'Rim ' + rimRate.toFixed(1) + '%' : ''),
                                midRate > 0 && e('div', { className: 'shot-segment shot-mid', style: { width: midRate + '%' }}, midRate >= 10 ? 'Mid ' + midRate.toFixed(1) + '%' : ''),
                                threeRate > 0 && e('div', { className: 'shot-segment shot-three', style: { width: threeRate + '%' }}, threeRate >= 10 ? '3PT ' + threeRate.toFixed(1) + '%' : '')
                            )
                        ),
                        
                        // Shot breakdown cards
                        e('div', { className: 'shot-breakdown-grid' },
                            e('div', { className: 'shot-breakdown-card', style: { background: 'linear-gradient(135deg, rgba(220,38,38,0.3), rgba(239,68,68,0.2))' }},
                                e('div', { className: 'shot-breakdown-title', style: { color: '#fca5a5' }}, '🏀 Rim Attempts'),
                                e('div', { className: 'shot-breakdown-pct', style: { color: '#ef4444' }}, rimPct.toFixed(1) + '%'),
                                e('div', { className: 'shot-breakdown-rate' }, rimRate.toFixed(1) + '% of shots'),
                                e('div', { className: 'shot-breakdown-attempts' }, Math.round(rimM) + ' / ' + Math.round(rimA) + ' made'),
                                e('div', { style: { marginTop: '8px', padding: '8px', background: 'rgba(0,0,0,0.2)', borderRadius: '6px' }},
                                    e('div', { style: { fontSize: '11px', opacity: 0.7 }}, 'Exp. Points/Shot'),
                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, rimEPS.toFixed(2))
                                )
                            ),
                            e('div', { className: 'shot-breakdown-card', style: { background: 'linear-gradient(135deg, rgba(234,88,12,0.3), rgba(249,115,22,0.2))' }},
                                e('div', { className: 'shot-breakdown-title', style: { color: '#fdba74' }}, '📍 Mid-Range'),
                                e('div', { className: 'shot-breakdown-pct', style: { color: '#f97316' }}, midPct.toFixed(1) + '%'),
                                e('div', { className: 'shot-breakdown-rate' }, midRate.toFixed(1) + '% of shots'),
                                e('div', { className: 'shot-breakdown-attempts' }, Math.round(midM) + ' / ' + Math.round(midA) + ' made'),
                                e('div', { style: { marginTop: '8px', padding: '8px', background: 'rgba(0,0,0,0.2)', borderRadius: '6px' }},
                                    e('div', { style: { fontSize: '11px', opacity: 0.7 }}, 'Exp. Points/Shot'),
                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, midEPS.toFixed(2))
                                )
                            ),
                            e('div', { className: 'shot-breakdown-card', style: { background: 'linear-gradient(135deg, rgba(37,99,235,0.3), rgba(59,130,246,0.2))' }},
                                e('div', { className: 'shot-breakdown-title', style: { color: '#93c5fd' }}, '🎯 Three-Point'),
                                e('div', { className: 'shot-breakdown-pct', style: { color: '#3b82f6' }}, threePct.toFixed(1) + '%'),
                                e('div', { className: 'shot-breakdown-rate' }, threeRate.toFixed(1) + '% of shots'),
                                e('div', { className: 'shot-breakdown-attempts' }, Math.round(threeM) + ' / ' + Math.round(threeA) + ' made'),
                                e('div', { style: { marginTop: '8px', padding: '8px', background: 'rgba(0,0,0,0.2)', borderRadius: '6px' }},
                                    e('div', { style: { fontSize: '11px', opacity: 0.7 }}, 'Exp. Points/Shot'),
                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, threeEPS.toFixed(2))
                                )
                            )
                        ),
                        
                        // Player breakdown table (only for offense and if player data exists)
                        isOffense && hasPlayerData && e('div', { className: 'player-shot-table', style: { marginTop: '24px' }},
                            e('h3', { style: { fontSize: '16px', fontWeight: 'bold', marginBottom: '12px' }}, '👤 Player Shot Breakdown'),
                            e('div', { style: { overflowX: 'auto' }},
                                e('table', null,
                                    e('thead', null,
                                        e('tr', null,
                                            e('th', null, 'Player'),
                                            e('th', { style: { textAlign: 'right' }}, 'Rim Att'),
                                            e('th', { style: { textAlign: 'right' }}, 'Rim %'),
                                            e('th', { style: { textAlign: 'right' }}, 'Mid Att'),
                                            e('th', { style: { textAlign: 'right' }}, 'Mid %'),
                                            e('th', { style: { textAlign: 'right' }}, '3PT Att'),
                                            e('th', { style: { textAlign: 'right' }}, '3PT %'),
                                            e('th', { style: { textAlign: 'right' }}, 'Total Shots')
                                        )
                                    ),
                                    e('tbody', null,
                                        playerBreakdown.slice(0, 15).map((p, i) => {
                                            const pTotal = p.rimA + p.midA + p.threeA;
                                            return e('tr', { key: i },
                                                e('td', { style: { color: '#60a5fa', fontWeight: '600' }}, p.player),
                                                e('td', { style: { textAlign: 'right' }}, Math.round(p.rimA)),
                                                e('td', { style: { textAlign: 'right', color: '#ef4444' }}, p.rimPct.toFixed(1) + '%'),
                                                e('td', { style: { textAlign: 'right' }}, Math.round(p.midA)),
                                                e('td', { style: { textAlign: 'right', color: '#f97316' }}, p.midPct.toFixed(1) + '%'),
                                                e('td', { style: { textAlign: 'right' }}, Math.round(p.threeA)),
                                                e('td', { style: { textAlign: 'right', color: '#3b82f6' }}, p.threePct.toFixed(1) + '%'),
                                                e('td', { style: { textAlign: 'right', fontWeight: 'bold' }}, Math.round(pTotal))
                                            );
                                        })
                                    )
                                )
                            )
                        )
                    )
                );
            };

            // NEW: Turnover Modal Component
            const TurnoverModal = () => {
                if (!showTOModal || !fStats) return null;
                const isCommitted = toModalType === 'committed';
                const title = isCommitted ? '🔄 Turnovers Committed Breakdown' : '💪 Turnovers Forced Breakdown';
                const subtitle = afc > 0 
                    ? 'Player combination: ' + Object.values(selPlayers).filter(p => p !== '').join(', ')
                    : 'Team-wide breakdown for ' + team;
                
                const passTo = isCommitted ? fStats.passTo : fStats.passToV;
                const dribTo = isCommitted ? fStats.dribTo : fStats.dribToV;
                const defTo = isCommitted ? fStats.defTo : fStats.defToV;
                const miscTo = isCommitted ? fStats.miscTo : fStats.miscToV;
                const totalTo = passTo + dribTo + defTo + miscTo;
                
                const passRate = totalTo > 0 ? (passTo / totalTo) * 100 : 0;
                const dribRate = totalTo > 0 ? (dribTo / totalTo) * 100 : 0;
                const defRate = totalTo > 0 ? (defTo / totalTo) * 100 : 0;
                const miscRate = totalTo > 0 ? (miscTo / totalTo) * 100 : 0;
                
                // Per possession rates
                const poss = isCommitted ? fStats.poss : fStats.possV;
                const passToPer100 = poss > 0 ? (passTo / poss) * 100 : 0;
                const dribToPer100 = poss > 0 ? (dribTo / poss) * 100 : 0;
                const defToPer100 = poss > 0 ? (defTo / poss) * 100 : 0;
                const miscToPer100 = poss > 0 ? (miscTo / poss) * 100 : 0;
                
                // Player breakdown
                const hasPlayerData = playerBreakdown.length > 0 && isCommitted;
                
                return e('div', { className: 'modal-overlay', onClick: () => setShowTOModal(false) },
                    e('div', { className: 'modal-content to-modal', onClick: ev => ev.stopPropagation() },
                        e('div', { className: 'modal-header' },
                            e('div', null,
                                e('h2', { style: { fontSize: '24px', fontWeight: 'bold', color: isCommitted ? '#f87171' : '#4ade80' }}, title),
                                e('p', { style: { marginTop: '8px', opacity: 0.8 }}, subtitle),
                                e('p', { style: { marginTop: '4px', fontSize: '12px', opacity: 0.6 }}, 'Total Turnovers: ' + Math.round(totalTo) + ' | Possessions: ' + Math.round(poss))
                            ),
                            e('button', { className: 'modal-close', onClick: () => setShowTOModal(false) }, '×')
                        ),
                        
                        // TO distribution bar
                        e('div', { style: { marginBottom: '24px' }},
                            e('div', { className: 'shot-dist-bar', style: { height: '50px' }},
                                passRate > 0 && e('div', { className: 'shot-segment', style: { width: passRate + '%', background: isCommitted ? '#ef4444' : '#22c55e' }}, passRate >= 10 ? 'Pass ' + passRate.toFixed(0) + '%' : ''),
                                dribRate > 0 && e('div', { className: 'shot-segment', style: { width: dribRate + '%', background: isCommitted ? '#f97316' : '#84cc16' }}, dribRate >= 10 ? 'Drib ' + dribRate.toFixed(0) + '%' : ''),
                                defRate > 0 && e('div', { className: 'shot-segment', style: { width: defRate + '%', background: isCommitted ? '#eab308' : '#facc15' }}, defRate >= 10 ? 'Def ' + defRate.toFixed(0) + '%' : ''),
                                miscRate > 0 && e('div', { className: 'shot-segment', style: { width: miscRate + '%', background: '#6b7280' }}, miscRate >= 10 ? 'Misc ' + miscRate.toFixed(0) + '%' : '')
                            )
                        ),
                        
                        // TO breakdown cards
                        e('div', { className: 'to-breakdown-grid' },
                            e('div', { className: 'to-breakdown-card', style: { background: isCommitted ? 'rgba(239,68,68,0.2)' : 'rgba(34,197,94,0.2)' }},
                                e('div', { className: 'to-breakdown-title' }, '📨 Pass TOs'),
                                e('div', { className: 'to-breakdown-count', style: { color: isCommitted ? '#ef4444' : '#22c55e' }}, Math.round(passTo)),
                                e('div', { className: 'to-breakdown-rate' }, passRate.toFixed(1) + '% of TOs'),
                                e('div', { style: { marginTop: '8px', fontSize: '11px', opacity: 0.7 }}, passToPer100.toFixed(2) + ' per 100 poss')
                            ),
                            e('div', { className: 'to-breakdown-card', style: { background: isCommitted ? 'rgba(249,115,22,0.2)' : 'rgba(132,204,22,0.2)' }},
                                e('div', { className: 'to-breakdown-title' }, '🏀 Dribble TOs'),
                                e('div', { className: 'to-breakdown-count', style: { color: isCommitted ? '#f97316' : '#84cc16' }}, Math.round(dribTo)),
                                e('div', { className: 'to-breakdown-rate' }, dribRate.toFixed(1) + '% of TOs'),
                                e('div', { style: { marginTop: '8px', fontSize: '11px', opacity: 0.7 }}, dribToPer100.toFixed(2) + ' per 100 poss')
                            ),
                            e('div', { className: 'to-breakdown-card', style: { background: isCommitted ? 'rgba(234,179,8,0.2)' : 'rgba(250,204,21,0.2)' }},
                                e('div', { className: 'to-breakdown-title' }, '🛡️ Defense TOs'),
                                e('div', { className: 'to-breakdown-count', style: { color: isCommitted ? '#eab308' : '#facc15' }}, Math.round(defTo)),
                                e('div', { className: 'to-breakdown-rate' }, defRate.toFixed(1) + '% of TOs'),
                                e('div', { style: { marginTop: '8px', fontSize: '11px', opacity: 0.7 }}, defToPer100.toFixed(2) + ' per 100 poss')
                            ),
                            e('div', { className: 'to-breakdown-card', style: { background: 'rgba(107,114,128,0.2)' }},
                                e('div', { className: 'to-breakdown-title' }, '❓ Misc TOs'),
                                e('div', { className: 'to-breakdown-count', style: { color: '#9ca3af' }}, Math.round(miscTo)),
                                e('div', { className: 'to-breakdown-rate' }, miscRate.toFixed(1) + '% of TOs'),
                                e('div', { style: { marginTop: '8px', fontSize: '11px', opacity: 0.7 }}, miscToPer100.toFixed(2) + ' per 100 poss')
                            )
                        ),
                        
                        // Summary stats
                        e('div', { style: { marginTop: '24px', padding: '16px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }},
                            e('h4', { style: { fontSize: '14px', marginBottom: '12px' }}, '📊 Summary'),
                            e('div', { className: 'grid-3' },
                                e('div', { style: { textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', opacity: 0.7 }}, 'TO Rate'),
                                    e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, ((totalTo / poss) * 100).toFixed(1) + '%')
                                ),
                                e('div', { style: { textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', opacity: 0.7 }}, 'TOs per 100 Poss'),
                                    e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, ((totalTo / poss) * 100).toFixed(1))
                                ),
                                e('div', { style: { textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', opacity: 0.7 }}, 'Live Ball %'),
                                    e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, (((passTo + dribTo) / totalTo) * 100).toFixed(1) + '%')
                                )
                            )
                        ),
                        
                        // Player breakdown table
                        hasPlayerData && e('div', { style: { marginTop: '24px' }},
                            e('h3', { style: { fontSize: '16px', fontWeight: 'bold', marginBottom: '12px' }}, '👤 Player Turnover Breakdown'),
                            e('div', { style: { overflowX: 'auto' }},
                                e('table', null,
                                    e('thead', null,
                                        e('tr', null,
                                            e('th', null, 'Player'),
                                            e('th', { style: { textAlign: 'right' }}, 'Pass'),
                                            e('th', { style: { textAlign: 'right' }}, 'Dribble'),
                                            e('th', { style: { textAlign: 'right' }}, 'Defense'),
                                            e('th', { style: { textAlign: 'right' }}, 'Misc'),
                                            e('th', { style: { textAlign: 'right' }}, 'Total')
                                        )
                                    ),
                                    e('tbody', null,
                                        playerBreakdown.filter(p => p.tTo > 0).slice(0, 15).map((p, i) => 
                                            e('tr', { key: i },
                                                e('td', { style: { color: '#60a5fa', fontWeight: '600' }}, p.player),
                                                e('td', { style: { textAlign: 'right', color: '#ef4444' }}, Math.round(p.passTo)),
                                                e('td', { style: { textAlign: 'right', color: '#f97316' }}, Math.round(p.dribTo)),
                                                e('td', { style: { textAlign: 'right', color: '#eab308' }}, Math.round(p.defTo)),
                                                e('td', { style: { textAlign: 'right', color: '#6b7280' }}, Math.round(p.miscTo)),
                                                e('td', { style: { textAlign: 'right', fontWeight: 'bold' }}, Math.round(p.tTo))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
            };

            // OREB% Breakdown Modal
            const OrebModal = () => {
                if (!showOrebModal || !fStats) return null;
                const hasPlayerData = playerBreakdown.length > 0;
                const subtitle = afc >= 1 
                    ? 'Player combination: ' + Object.values(selPlayers).filter(p => p !== '').join(', ')
                    : 'Team-wide breakdown for ' + team;
                
                // Team totals from fStats (for summary display)
                const teamOreb = fStats.oreb;
                const oppDreb = fStats.drebV;
                const teamOrebPct = fStats.offOreb;
                
                // Use pre-calculated lineup-specific OREB% from playerBreakdown
                const playerOrebData = playerBreakdown.map(p => {
                    // Share of team's OREBs (within player's specific lineups)
                    const orebShare = p.lpTeamOreb > 0 ? (p.oreb / p.lpTeamOreb) * 100 : 0;
                    return { ...p, orebShare };
                }).filter(p => p.oreb > 0 || p.minutes > 0).sort((a, b) => b.oreb - a.oreb);
                
                return e('div', { className: 'modal-overlay', onClick: () => setShowOrebModal(false) },
                    e('div', { className: 'modal-content', onClick: ev => ev.stopPropagation() },
                        e('div', { className: 'modal-header' },
                            e('div', null,
                                e('h2', { style: { fontSize: '24px', fontWeight: 'bold', color: '#4ade80' }}, '🏀 Offensive Rebound Breakdown'),
                                e('p', { style: { marginTop: '8px', opacity: 0.8 }}, subtitle),
                                e('p', { style: { marginTop: '4px', fontSize: '12px', opacity: 0.6 }}, 
                                    'Filtered Lineups - Team OREB: ' + Math.round(teamOreb) + ' | Opp DREB: ' + Math.round(oppDreb) + ' | Team OREB%: ' + teamOrebPct.toFixed(1) + '%')
                            ),
                            e('button', { className: 'modal-close', onClick: () => setShowOrebModal(false) }, '×')
                        ),
                        
                        // Summary cards
                        e('div', { className: 'grid-3', style: { marginBottom: '24px' }},
                            e('div', { style: { background: 'rgba(34, 197, 94, 0.2)', padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'Team OREB%'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#4ade80' }}, teamOrebPct.toFixed(1) + '%')
                            ),
                            e('div', { style: { background: 'rgba(59, 130, 246, 0.2)', padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'Total OREBs'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#60a5fa' }}, Math.round(teamOreb))
                            ),
                            e('div', { style: { background: 'rgba(239, 68, 68, 0.2)', padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'Opp DREBs (Missed)'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#f87171' }}, Math.round(oppDreb))
                            )
                        ),
                        
                        // Player breakdown table
                        hasPlayerData && e('div', { style: { marginTop: '16px' }},
                            e('h3', { style: { fontSize: '16px', fontWeight: 'bold', marginBottom: '12px' }}, '👤 Player OREB Breakdown (Lineup-Specific)'),
                            e('p', { style: { fontSize: '11px', opacity: 0.7, marginBottom: '12px' }}, 
                                'OREB% = Player OREBs ÷ (Lineup OREBs + Lineup Opp DREBs). Calculated only for lineups each player appears in.'),
                            e('div', { style: { overflowX: 'auto' }},
                                e('table', null,
                                    e('thead', null,
                                        e('tr', null,
                                            e('th', null, 'Player'),
                                            e('th', { style: { textAlign: 'right' }}, 'OREBs'),
                                            e('th', { style: { textAlign: 'right' }}, 'OREB%'),
                                            e('th', { style: { textAlign: 'right' }}, 'Lineup Share'),
                                            e('th', { style: { textAlign: 'right' }}, 'Lineups'),
                                            e('th', { style: { textAlign: 'right' }}, 'Minutes')
                                        )
                                    ),
                                    e('tbody', null,
                                        playerOrebData.slice(0, 15).map((p, i) => 
                                            e('tr', { key: i, style: p.numLineups === 0 ? { background: 'rgba(239, 68, 68, 0.2)' } : {} },
                                                e('td', { style: { color: '#60a5fa', fontWeight: '600' }}, p.player),
                                                e('td', { style: { textAlign: 'right', fontWeight: 'bold' }}, Math.round(p.oreb)),
                                                e('td', { style: { textAlign: 'right', color: '#4ade80', fontWeight: 'bold' }}, p.playerOrebPct.toFixed(1) + '%'),
                                                e('td', { style: { textAlign: 'right', color: '#fbbf24' }}, p.orebShare.toFixed(1) + '%'),
                                                e('td', { style: { textAlign: 'right', color: '#fbbf24' }}, p.numLineups),
                                                e('td', { style: { textAlign: 'right', opacity: 0.7 }}, p.minutes.toFixed(1))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
            };

            // AST% Breakdown Modal
            const AstModal = () => {
                if (!showAstModal || !fStats) return null;
                const hasPlayerData = playerBreakdown.length > 0;
                const subtitle = afc >= 1 
                    ? 'Player combination: ' + Object.values(selPlayers).filter(p => p !== '').join(', ')
                    : 'Team-wide breakdown for ' + team;
                
                // Team totals from fStats (for summary display)
                const teamAst = fStats.ast;
                const teamFgm = fStats.fgm;
                const teamAstPct = fStats.astPct;
                
                // playerBreakdown already has lineup-specific AST% and teammateFgm calculated
                const playerAstData = playerBreakdown.filter(p => p.ast > 0 || p.minutes > 0).sort((a, b) => b.ast - a.ast);
                
                return e('div', { className: 'modal-overlay', onClick: () => setShowAstModal(false) },
                    e('div', { className: 'modal-content', onClick: ev => ev.stopPropagation() },
                        e('div', { className: 'modal-header' },
                            e('div', null,
                                e('h2', { style: { fontSize: '24px', fontWeight: 'bold', color: '#a78bfa' }}, '🎯 Assist Breakdown'),
                                e('p', { style: { marginTop: '8px', opacity: 0.8 }}, subtitle),
                                e('p', { style: { marginTop: '4px', fontSize: '12px', opacity: 0.6 }}, 
                                    'Filtered Lineups - Team AST: ' + Math.round(teamAst) + ' | Team FGM: ' + Math.round(teamFgm) + ' | Team AST%: ' + teamAstPct.toFixed(1) + '%')
                            ),
                            e('button', { className: 'modal-close', onClick: () => setShowAstModal(false) }, '×')
                        ),
                        
                        // Summary cards
                        e('div', { className: 'grid-3', style: { marginBottom: '24px' }},
                            e('div', { style: { background: 'rgba(167, 139, 250, 0.2)', padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'Team AST%'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#a78bfa' }}, teamAstPct.toFixed(1) + '%')
                            ),
                            e('div', { style: { background: 'rgba(59, 130, 246, 0.2)', padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'Total Assists'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#60a5fa' }}, Math.round(teamAst))
                            ),
                            e('div', { style: { background: 'rgba(34, 197, 94, 0.2)', padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'Team FGM'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#4ade80' }}, Math.round(teamFgm))
                            )
                        ),
                        
                        // Player breakdown table
                        hasPlayerData && e('div', { style: { marginTop: '16px' }},
                            e('h3', { style: { fontSize: '16px', fontWeight: 'bold', marginBottom: '12px' }}, '👤 Player Assist Breakdown (Lineup-Specific)'),
                            e('p', { style: { fontSize: '11px', opacity: 0.7, marginBottom: '8px' }}, 
                                'AST% = 100 × AST ÷ (Lineup_Team_FGM - Player_FGM). Teammate FGM while player on court.'),
                            playerAstData.some(p => p.teammateFgm < 0 || p.numLineups === 0) && e('p', { style: { fontSize: '11px', color: '#f87171', marginBottom: '12px', padding: '8px', background: 'rgba(239,68,68,0.15)', borderRadius: '6px' }}, 
                                '⚠️ Red rows indicate data mismatch: Player FGM > Lineup FGM, or 0 matching lineups. Check for name differences between player/lineup CSVs.'),
                            e('div', { style: { overflowX: 'auto' }},
                                e('table', null,
                                    e('thead', null,
                                        e('tr', null,
                                            e('th', null, 'Player'),
                                            e('th', { style: { textAlign: 'right' }}, 'ASTs'),
                                            e('th', { style: { textAlign: 'right' }}, 'AST%'),
                                            e('th', { style: { textAlign: 'right' }}, 'Lineup FGM'),
                                            e('th', { style: { textAlign: 'right' }}, 'Player FGM'),
                                            e('th', { style: { textAlign: 'right' }}, 'Teammate FGM'),
                                            e('th', { style: { textAlign: 'right' }}, 'Lineups'),
                                            e('th', { style: { textAlign: 'right' }}, 'Minutes')
                                        )
                                    ),
                                    e('tbody', null,
                                        playerAstData.slice(0, 15).map((p, i) => 
                                            e('tr', { key: i, style: p.teammateFgm < 0 ? { background: 'rgba(239, 68, 68, 0.2)' } : {} },
                                                e('td', { style: { color: '#60a5fa', fontWeight: '600' }}, p.player),
                                                e('td', { style: { textAlign: 'right', fontWeight: 'bold' }}, Math.round(p.ast)),
                                                e('td', { style: { textAlign: 'right', color: p.teammateFgm > 0 ? '#a78bfa' : '#ef4444', fontWeight: 'bold' }}, p.playerAstPct.toFixed(1) + '%'),
                                                e('td', { style: { textAlign: 'right', color: '#4ade80' }}, Math.round(p.lpTeamFgm)),
                                                e('td', { style: { textAlign: 'right' }}, Math.round(p.fgm)),
                                                e('td', { style: { textAlign: 'right', color: p.teammateFgm >= 0 ? '#c4b5fd' : '#ef4444' }}, Math.round(p.teammateFgm)),
                                                e('td', { style: { textAlign: 'right', color: '#fbbf24' }}, p.numLineups),
                                                e('td', { style: { textAlign: 'right', opacity: 0.7 }}, p.minutes.toFixed(1))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
            };

            // Team Average Comparison Section
            // V4.9.8.7.27: Simplified Team Average Summary with compact stat cards
            const TeamAvgSummary = () => {
                if (!fStats || afc === 0) return null; // Only show when player combination selected
                
                // Compact stat card with single centered delta bar
                const StatCard = ({ label, lineupVal, teamVal, higherGood = true }) => {
                    const rawDelta = lineupVal - teamVal;
                    const delta = higherGood ? rawDelta : -rawDelta; // Normalize so positive = good
                    const displayDelta = rawDelta; // Show actual difference
                    const isGood = delta > 0.3;
                    const isBad = delta < -0.3;
                    const deltaColor = isGood ? '#4ade80' : isBad ? '#f87171' : '#94a3b8';
                    
                    // Bar calculation - grows from center left (bad) or right (good)
                    const maxDelta = 15; // Max expected delta for scaling
                    const barWidth = Math.min(45, (Math.abs(delta) / maxDelta) * 45);
                    
                    return e('div', { 
                        style: { 
                            background: 'rgba(30, 41, 59, 0.6)',
                            border: '1px solid rgba(71, 85, 105, 0.4)',
                            borderRadius: '8px',
                            padding: '10px 12px',
                            minWidth: '140px'
                        }
                    },
                        // Label and delta
                        e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' }},
                            e('span', { style: { fontSize: '10px', color: '#94a3b8', textTransform: 'uppercase', fontWeight: '600' }}, label),
                            e('span', { style: { 
                                fontSize: '11px', 
                                fontWeight: 'bold', 
                                color: deltaColor,
                                padding: '1px 5px',
                                background: isGood ? 'rgba(74, 222, 128, 0.15)' : isBad ? 'rgba(248, 113, 113, 0.15)' : 'transparent',
                                borderRadius: '4px'
                            }}, (displayDelta >= 0 ? '+' : '') + displayDelta.toFixed(1))
                        ),
                        // Values
                        e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }},
                            e('span', { style: { fontSize: '13px', fontWeight: 'bold', color: '#e2e8f0' }}, lineupVal.toFixed(1)),
                            e('span', { style: { fontSize: '11px', color: '#64748b' }}, 'vs ' + teamVal.toFixed(1))
                        ),
                        // Single centered delta bar
                        e('div', { style: { display: 'flex', height: '6px', background: 'rgba(15, 23, 42, 0.8)', borderRadius: '3px', overflow: 'hidden' }},
                            // Left half (negative/bad)
                            e('div', { style: { width: '50%', display: 'flex', justifyContent: 'flex-end' }},
                                isBad && e('div', { style: { 
                                    width: barWidth + '%', 
                                    background: 'linear-gradient(90deg, #ef4444, #f87171)',
                                    boxShadow: '0 0 8px rgba(239, 68, 68, 0.6)',
                                    borderRadius: '3px 0 0 3px'
                                }})
                            ),
                            // Right half (positive/good)
                            e('div', { style: { width: '50%', display: 'flex', justifyContent: 'flex-start' }},
                                isGood && e('div', { style: { 
                                    width: barWidth + '%', 
                                    background: 'linear-gradient(90deg, #4ade80, #22c55e)',
                                    boxShadow: '0 0 8px rgba(74, 222, 128, 0.6)',
                                    borderRadius: '0 3px 3px 0'
                                }})
                            )
                        )
                    );
                };
                
                // Section label
                const SectionLabel = ({ title }) => e('div', { 
                    style: { 
                        fontSize: '11px', 
                        color: '#64748b', 
                        textTransform: 'uppercase', 
                        letterSpacing: '1px',
                        marginTop: '12px',
                        marginBottom: '8px',
                        paddingBottom: '4px',
                        borderBottom: '1px solid rgba(71, 85, 105, 0.3)'
                    }
                }, title);
                
                return e('div', { 
                    style: { 
                        background: 'rgba(15, 23, 42, 0.4)',
                        border: '1px solid rgba(71, 85, 105, 0.5)',
                        borderRadius: '12px',
                        padding: '16px',
                        marginTop: '16px'
                    }
                },
                    // Header
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }},
                        e('span', { style: { fontSize: '14px', fontWeight: 'bold', color: '#f1f5f9' }}, '📊 Lineup vs ' + team + ' Team Average')
                    ),
                    
                    // Ratings
                    e(SectionLabel, { title: 'Ratings' }),
                    e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '8px' }},
                        e(StatCard, { label: 'OFF RTG', lineupVal: fStats.off, teamVal: teamAvg.off, higherGood: true }),
                        e(StatCard, { label: 'DEF RTG', lineupVal: fStats.def, teamVal: teamAvg.def, higherGood: false }),
                        e(StatCard, { label: 'NET RTG', lineupVal: fStats.net, teamVal: teamAvg.net, higherGood: true })
                    ),
                    
                    // Four Factors
                    e(SectionLabel, { title: 'Four Factors' }),
                    e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '8px' }},
                        e(StatCard, { label: 'eFG%', lineupVal: fStats.offEfg, teamVal: teamAvg.offEfg, higherGood: true }),
                        e(StatCard, { label: 'TOV%', lineupVal: fStats.offTov, teamVal: teamAvg.offTov, higherGood: false }),
                        e(StatCard, { label: 'OREB%', lineupVal: fStats.offOreb, teamVal: teamAvg.offOreb, higherGood: true }),
                        e(StatCard, { label: 'FT RATE', lineupVal: fStats.offFtR, teamVal: teamAvg.offFtR, higherGood: true }),
                        e(StatCard, { label: 'OPP eFG%', lineupVal: fStats.defEfg, teamVal: teamAvg.defEfg, higherGood: false }),
                        e(StatCard, { label: 'OPP TOV%', lineupVal: fStats.defTov, teamVal: teamAvg.defTov, higherGood: true }),
                        e(StatCard, { label: 'OPP OREB%', lineupVal: fStats.defOreb, teamVal: teamAvg.defOreb, higherGood: false }),
                        e(StatCard, { label: 'OPP FT RATE', lineupVal: fStats.defFtR, teamVal: teamAvg.defFtR, higherGood: false })
                    ),
                    
                    // Shot Distribution
                    e(SectionLabel, { title: 'Shot Distribution' }),
                    e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '8px' }},
                        e(StatCard, { label: 'RIM%', lineupVal: fStats.rimPct, teamVal: teamAvg.rimPct, higherGood: true }),
                        e(StatCard, { label: 'MID%', lineupVal: fStats.midPct, teamVal: teamAvg.midPct, higherGood: true }),
                        e(StatCard, { label: '3PT%', lineupVal: fStats.threePct, teamVal: teamAvg.threePct, higherGood: true }),
                        e(StatCard, { label: 'OPP RIM%', lineupVal: fStats.rimPctV, teamVal: teamAvg.rimPctV, higherGood: false }),
                        e(StatCard, { label: 'OPP MID%', lineupVal: fStats.midPctV, teamVal: teamAvg.midPctV, higherGood: false }),
                        e(StatCard, { label: 'OPP 3PT%', lineupVal: fStats.threePctV, teamVal: teamAvg.threePctV, higherGood: false })
                    )
                );
            };

            const TeamAvgSection = () => {
                if (!fStats || !showTeamAvg) return null;
                const stats = [
                    { name: 'Net Rtg', val: fStats.net, avg: teamAvg.net, pct: pcts.net, higherGood: true },
                    { name: 'Off Rtg', val: fStats.off, avg: teamAvg.off, pct: pcts.off, higherGood: true },
                    { name: 'Def Rtg', val: fStats.def, avg: teamAvg.def, pct: pcts.def, higherGood: false },
                    { name: 'Pace (Off)', val: fStats.paceF, avg: teamAvg.paceF, pct: pcts.paceF, higherGood: true },
                    { name: 'Pace (Def)', val: fStats.paceV, avg: teamAvg.paceV, pct: pcts.paceV, higherGood: false },
                    { name: 'eFG%', val: fStats.offEfg, avg: teamAvg.offEfg, pct: pcts.offEfg, higherGood: true },
                    { name: 'TOV%', val: fStats.offTov, avg: teamAvg.offTov, pct: pcts.offTov, higherGood: false },
                    { name: 'OREB%', val: fStats.offOreb, avg: teamAvg.offOreb, pct: pcts.offOreb, higherGood: true },
                    { name: 'FT Rate', val: fStats.offFtR, avg: teamAvg.offFtR, pct: pcts.offFtR, higherGood: true },
                    { name: 'Opp eFG%', val: fStats.defEfg, avg: teamAvg.defEfg, pct: pcts.defEfg, higherGood: false },
                    { name: 'Opp TOV%', val: fStats.defTov, avg: teamAvg.defTov, pct: pcts.defTov, higherGood: true },
                    { name: 'Opp OREB%', val: fStats.defOreb, avg: teamAvg.defOreb, pct: pcts.defOreb, higherGood: false },
                    { name: 'Opp FT Rate', val: fStats.defFtR, avg: teamAvg.defFtR, pct: pcts.defFtR, higherGood: false },
                    { name: 'AST%', val: fStats.astPct, avg: teamAvg.astPct, pct: pcts.astPct, higherGood: true },
                    { name: 'STL%', val: fStats.stlPct, avg: teamAvg.stlPct, pct: pcts.stlPct, higherGood: true },
                    { name: 'BLK%', val: fStats.blkPct, avg: teamAvg.blkPct, pct: pcts.blkPct, higherGood: true },
                    { name: 'Opp AST%', val: fStats.oppAstPct, avg: teamAvg.oppAstPct, pct: pcts.oppAstPct, higherGood: false },
                    { name: 'Opp STL%', val: fStats.oppStlPct, avg: teamAvg.oppStlPct, pct: pcts.oppStlPct, higherGood: false },
                    { name: 'Opp BLK%', val: fStats.oppBlkPct, avg: teamAvg.oppBlkPct, pct: pcts.oppBlkPct, higherGood: false },
                    { name: 'Rim%', val: fStats.rimPct, avg: teamAvg.rimPct, pct: pcts.rimPct, higherGood: true },
                    { name: 'Mid%', val: fStats.midPct, avg: teamAvg.midPct, pct: pcts.midPct, higherGood: true },
                    { name: '3PT%', val: fStats.threePct, avg: teamAvg.threePct, pct: pcts.threePct, higherGood: true },
                    { name: 'Opp Rim%', val: fStats.rimPctV, avg: teamAvg.rimPctV, pct: pcts.rimPctV, higherGood: false },
                    { name: 'Opp Mid%', val: fStats.midPctV, avg: teamAvg.midPctV, pct: pcts.midPctV, higherGood: false },
                    { name: 'Opp 3PT%', val: fStats.threePctV, avg: teamAvg.threePctV, pct: pcts.threePctV, higherGood: false },
                ];
                return e('div', { className: 'teamavg-section' },
                    e('h2', { className: 'section-title', style: { color: '#14b8a6' }}, '📊 ' + (afc > 0 ? 'Lineup' : 'Team') + ' vs Team Average (Full Details)'),
                    e('p', { style: { fontSize: '12px', opacity: 0.7, marginBottom: '16px' }}, 
                        afc > 0 ? 'How this player combination differs from the team-wide averages.' : 'Team-wide stats comparison. Colors based on league-wide team percentiles.'),
                    e('div', { className: 'teamavg-grid' },
                        stats.map((s, i) => {
                            const delta = s.val - s.avg;
                            const goodDelta = s.higherGood ? delta > 0 : delta < 0;
                            const deltaClass = Math.abs(delta) < 0.5 ? 'delta-neutral' : goodDelta ? 'delta-positive' : 'delta-negative';
                            const perfClass = getPerfFromPct(s.pct);
                            return e('div', { key: i, className: 'teamavg-card ' + perfClass },
                                e('div', { className: 'teamavg-stat-name' }, s.name),
                                e('div', { className: 'teamavg-lineup' }, s.val.toFixed(1)),
                                e('div', { className: 'teamavg-team' }, 'Team: ' + s.avg.toFixed(1)),
                                e('div', { className: 'teamavg-delta ' + deltaClass }, (delta >= 0 ? '+' : '') + delta.toFixed(1)),
                                e('div', { style: { fontSize: '9px', marginTop: '2px', opacity: 0.7 }}, Math.round(s.pct) + 'th pct')
                            );
                        })
                    )
                );
            };

            // Impact Section with Four Factors - NOW WORKS TEAMWIDE
            const ImpactSection = () => {
                if (!oppQuality || !showImpact || !fStats) return null;
                const offDelta = oppQuality.impact.offDelta;
                const defDelta = oppQuality.impact.defDelta;
                const ffImpact = {
                    offEfgDelta: fStats.offEfg - oppQuality.oppDefEfg,
                    offTovDelta: fStats.offTov - oppQuality.oppDefTov,
                    offOrebDelta: fStats.offOreb - oppQuality.oppDefOreb,
                    defEfgDelta: fStats.defEfg - oppQuality.oppOffEfg,
                    defTovDelta: fStats.defTov - oppQuality.oppOffTov,
                    defOrebDelta: fStats.defOreb - oppQuality.oppOffOreb,
                };
                const contextLabel = afc > 0 ? 'this player combination' : team;
                return e('div', { className: 'impact-section' },
                    e('h2', { className: 'section-title', style: { color: '#fca5a5' }}, '💥 Opponent Impact Analysis'),
                    e('p', { style: { fontSize: '12px', opacity: 0.7, marginBottom: '16px' }},
                        'How ' + contextLabel + ' affects opponent performance vs their typical stats (',
                        Math.round(oppQuality.totalPoss), ' poss, ', oppQuality.oppCount, ' matchups)'),
                    e('div', { className: 'grid-2' },
                        e('div', { className: 'impact-card' },
                            e('div', { className: 'impact-header' },
                                e('span', { className: 'impact-stat' }, '🛡️ Your Defense → Opp Offense'),
                                e('span', { className: 'impact-delta ' + getDeltaClass(offDelta, true) },
                                    (offDelta >= 0 ? '+' : '') + offDelta.toFixed(1) + ' pts/100'
                                )
                            ),
                            e('div', { className: 'impact-bar' },
                                e('span', { className: 'impact-label' }, 'Opp Typical:'),
                                e('span', { className: 'impact-value' }, oppQuality.oppOff.toFixed(1)),
                                e('span', { style: { opacity: 0.5 }}, '→'),
                                e('span', { className: 'impact-label' }, 'vs You:'),
                                e('span', { className: 'impact-value', style: { color: offDelta <= 0 ? '#86efac' : '#fca5a5' }}, oppQuality.actualOppOff.toFixed(1))
                            ),
                            e('p', { style: { fontSize: '11px', marginTop: '8px', opacity: 0.7 }},
                                offDelta < -3 ? '✅ You significantly suppress opponent offense' :
                                offDelta < 0 ? '👍 You reduce opponent offensive efficiency' :
                                offDelta < 3 ? '⚠️ Opponents perform near their average vs you' :
                                '❌ Opponents score better than usual vs you'
                            )
                        ),
                        e('div', { className: 'impact-card' },
                            e('div', { className: 'impact-header' },
                                e('span', { className: 'impact-stat' }, '⚔️ Your Offense → Opp Defense'),
                                e('span', { className: 'impact-delta ' + getDeltaClass(fStats.off - oppQuality.oppDef, false) },
                                    (fStats.off >= oppQuality.oppDef ? '+' : '') + (fStats.off - oppQuality.oppDef).toFixed(1) + ' vs expected'
                                )
                            ),
                            e('div', { className: 'impact-bar' },
                                e('span', { className: 'impact-label' }, 'Opp Allows:'),
                                e('span', { className: 'impact-value' }, oppQuality.oppDef.toFixed(1)),
                                e('span', { style: { opacity: 0.5 }}, '→'),
                                e('span', { className: 'impact-label' }, 'You Score:'),
                                e('span', { className: 'impact-value', style: { color: fStats.off > oppQuality.oppDef ? '#86efac' : '#fca5a5' }}, fStats.off.toFixed(1))
                            ),
                            e('p', { style: { fontSize: '11px', marginTop: '8px', opacity: 0.7 }},
                                fStats.off - oppQuality.oppDef > 5 ? '✅ You significantly outperform expected offense' :
                                fStats.off - oppQuality.oppDef > 0 ? '👍 You score better than opponents typically allow' :
                                fStats.off - oppQuality.oppDef > -5 ? '⚠️ Scoring near what opponents typically allow' :
                                '❌ Scoring worse than opponents typically allow'
                            )
                        )
                    ),
                    e('div', { className: 'ff-impact-grid' },
                        e('div', { className: 'ff-impact-card', style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)' }},
                            e('div', { className: 'ff-impact-title', style: { color: '#4ade80' }}, '⚔️ Your Offense vs Opp Typical Defense'),
                            e('div', { className: 'ff-impact-row' },
                                e('span', null, 'eFG%'),
                                e('span', null, fStats.offEfg.toFixed(1) + ' vs ' + oppQuality.oppDefEfg.toFixed(1)),
                                e('span', { className: 'impact-delta ' + getDeltaClassPct(ffImpact.offEfgDelta, true), style: { fontSize: '11px' }}, (ffImpact.offEfgDelta >= 0 ? '+' : '') + ffImpact.offEfgDelta.toFixed(1))
                            ),
                            e('div', { className: 'ff-impact-row' },
                                e('span', null, 'TOV%'),
                                e('span', null, fStats.offTov.toFixed(1) + ' vs ' + oppQuality.oppDefTov.toFixed(1)),
                                e('span', { className: 'impact-delta ' + getDeltaClassPct(-ffImpact.offTovDelta, true), style: { fontSize: '11px' }}, (ffImpact.offTovDelta >= 0 ? '+' : '') + ffImpact.offTovDelta.toFixed(1))
                            ),
                            e('div', { className: 'ff-impact-row' },
                                e('span', null, 'OREB%'),
                                e('span', null, fStats.offOreb.toFixed(1) + ' vs ' + oppQuality.oppDefOreb.toFixed(1)),
                                e('span', { className: 'impact-delta ' + getDeltaClassPct(ffImpact.offOrebDelta, true), style: { fontSize: '11px' }}, (ffImpact.offOrebDelta >= 0 ? '+' : '') + ffImpact.offOrebDelta.toFixed(1))
                            )
                        ),
                        e('div', { className: 'ff-impact-card', style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)' }},
                            e('div', { className: 'ff-impact-title', style: { color: '#f87171' }}, '🛡️ Your Defense vs Opp Typical Offense'),
                            e('div', { className: 'ff-impact-row' },
                                e('span', null, 'Opp eFG%'),
                                e('span', null, fStats.defEfg.toFixed(1) + ' vs ' + oppQuality.oppOffEfg.toFixed(1)),
                                e('span', { className: 'impact-delta ' + getDeltaClassPct(-ffImpact.defEfgDelta, true), style: { fontSize: '11px' }}, (ffImpact.defEfgDelta >= 0 ? '+' : '') + ffImpact.defEfgDelta.toFixed(1))
                            ),
                            e('div', { className: 'ff-impact-row' },
                                e('span', null, 'Opp TOV%'),
                                e('span', null, fStats.defTov.toFixed(1) + ' vs ' + oppQuality.oppOffTov.toFixed(1)),
                                e('span', { className: 'impact-delta ' + getDeltaClassPct(ffImpact.defTovDelta, true), style: { fontSize: '11px' }}, (ffImpact.defTovDelta >= 0 ? '+' : '') + ffImpact.defTovDelta.toFixed(1))
                            ),
                            e('div', { className: 'ff-impact-row' },
                                e('span', null, 'Opp OREB%'),
                                e('span', null, fStats.defOreb.toFixed(1) + ' vs ' + oppQuality.oppOffOreb.toFixed(1)),
                                e('span', { className: 'impact-delta ' + getDeltaClassPct(-ffImpact.defOrebDelta, true), style: { fontSize: '11px' }}, (ffImpact.defOrebDelta >= 0 ? '+' : '') + ffImpact.defOrebDelta.toFixed(1))
                            )
                        )
                    ),
                    e('div', { style: { marginTop: '16px', padding: '12px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }},
                        e('h4', { style: { fontSize: '13px', marginBottom: '8px' }}, '📊 Net Impact Summary'),
                        e('div', { style: { display: 'flex', gap: '24px', flexWrap: 'wrap' }},
                            e('div', null, e('span', { style: { fontSize: '11px', opacity: 0.7 }}, 'Opp typical Net: '), e('span', { style: { fontWeight: 'bold', color: getNetColor(oppQuality.oppNet) }}, (oppQuality.oppNet >= 0 ? '+' : '') + oppQuality.oppNet.toFixed(1))),
                            e('div', null, e('span', { style: { fontSize: '11px', opacity: 0.7 }}, 'Your Net vs them: '), e('span', { style: { fontWeight: 'bold', color: getNetColor(fStats.net) }}, (fStats.net >= 0 ? '+' : '') + fStats.net.toFixed(1))),
                            e('div', null, e('span', { style: { fontSize: '11px', opacity: 0.7 }}, 'Net differential: '), e('span', { style: { fontWeight: 'bold', color: fStats.net > oppQuality.oppNet ? '#86efac' : '#fca5a5' }}, (fStats.net - oppQuality.oppNet >= 0 ? '+' : '') + (fStats.net - oppQuality.oppNet).toFixed(1)))
                        )
                    )
                );
            };

            // Opponent Quality Section - NOW WORKS TEAMWIDE (no player filter required)
            const OppQualitySection = () => { 
                if (!oppQuality) return null; 
                const contextLabel = afc > 0 ? 'this player combination' : team;
                return e('div', { className: 'opp-section' }, 
                    e('div', { className: 'flex-between', style: { marginBottom: '16px' }},
                        e('h2', { className: 'section-title', style: { color: '#a78bfa', marginBottom: 0 }}, '⚔️ Opponent Quality (Poss-Weighted)'),
                        e('div', { style: { display: 'flex', gap: '8px' }},
                            e('button', { className: 'btn btn-impact', onClick: () => setShowImpact(!showImpact) },
                                showImpact ? 'Hide Impact' : '💥 Show Impact'
                            ),
                            e('button', { className: 'btn btn-teamavg', onClick: () => setShowTeamAvg(!showTeamAvg) },
                                showTeamAvg ? 'Hide vs Avg' : '📊 vs Team Avg'
                            )
                        )
                    ),
                    e('p', { style: { fontSize: '12px', opacity: 0.7, marginBottom: '16px' }}, 
                        'Typical stats of opponent lineups faced by ' + contextLabel + ' (', Math.round(oppQuality.totalPoss), ' poss, ', oppQuality.oppCount, ' matchups). ',
                        e('span', { style: { color: '#fbbf24' }}, '⚡ H2H excluded: ' + oppQuality.debugH2HPts + ' pts / ' + oppQuality.debugH2HPoss + ' poss removed from opponent baselines.'),
                        minMatchupPoss > 0 && e('span', { style: { color: '#a78bfa', marginLeft: '8px' }}, '📊 Min ' + minMatchupPoss + ' poss/matchup.'),
                        oppQuality.shrinkageApplied && e('span', { style: { color: '#86efac', marginLeft: '8px' }}, '🎯 Bayesian shrinkage: ' + (oppQuality.shrinkageFactor * 100).toFixed(0) + '% observed.')
                    ), 
                    e('div', { className: 'grid-4' }, 
                        e('div', null, 
                            e('h4', { style: { fontSize: '13px', marginBottom: '8px', color: '#fca5a5' }}, 'Opp Typical Offense'), 
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'Off Rtg'), e('span', { className: 'opp-stat-value' }, oppQuality.oppOff.toFixed(1), e(Pct, { val: oppQuality.pcts.oppOff, isOpp: true }))),
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'eFG%'), e('span', { className: 'opp-stat-value' }, oppQuality.oppOffEfg.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppOffEfg, isOpp: true }))),
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'TOV%'), e('span', { className: 'opp-stat-value' }, oppQuality.oppOffTov.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppOffTov, isOpp: true }))),
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'OREB%'), e('span', { className: 'opp-stat-value' }, oppQuality.oppOffOreb.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppOffOreb, isOpp: true })))
                        ),
                        e('div', null, 
                            e('h4', { style: { fontSize: '13px', marginBottom: '8px', color: '#86efac' }}, 'Opp Typical Defense'), 
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'Def Rtg'), e('span', { className: 'opp-stat-value' }, oppQuality.oppDef.toFixed(1), e(Pct, { val: oppQuality.pcts.oppDef, isOpp: true }))),
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'eFG% Allowed'), e('span', { className: 'opp-stat-value' }, oppQuality.oppDefEfg.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppDefEfg, isOpp: true }))),
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'TOV% Forced'), e('span', { className: 'opp-stat-value' }, oppQuality.oppDefTov.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppDefTov, isOpp: true }))),
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'OREB% Allowed'), e('span', { className: 'opp-stat-value' }, oppQuality.oppDefOreb.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppDefOreb, isOpp: true })))
                        ),
                        e('div', null, 
                            e('h4', { style: { fontSize: '13px', marginBottom: '8px', color: '#60a5fa' }}, 'Opp Playmaking (For)'), 
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'AST%'), e('span', { className: 'opp-stat-value' }, oppQuality.oppAstPct.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppAstPct, isOpp: true }))),
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'STL%'), e('span', { className: 'opp-stat-value' }, oppQuality.oppStlPct.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppStlPct, isOpp: true }))),
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'BLK%'), e('span', { className: 'opp-stat-value' }, oppQuality.oppBlkPct.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppBlkPct, isOpp: true })))
                        ),
                        e('div', null, 
                            e('h4', { style: { fontSize: '13px', marginBottom: '8px', color: '#f59e0b' }}, 'Opp Playmaking (Against)'), 
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'Opp AST%'), e('span', { className: 'opp-stat-value' }, oppQuality.oppOppAstPct.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppOppAstPct, isOpp: true }))),
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'Opp STL%'), e('span', { className: 'opp-stat-value' }, oppQuality.oppOppStlPct.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppOppStlPct, isOpp: true }))),
                            e('div', { className: 'opp-stat' }, e('span', { className: 'opp-stat-name' }, 'Opp BLK%'), e('span', { className: 'opp-stat-value' }, oppQuality.oppOppBlkPct.toFixed(1) + '%', e(Pct, { val: oppQuality.pcts.oppOppBlkPct, isOpp: true }))),
                            e('div', { className: 'opp-stat', style: { marginTop: '8px', background: 'rgba(124,58,237,0.2)' }}, e('span', { className: 'opp-stat-name' }, 'Net Rtg'), e('span', { className: 'opp-stat-value', style: { color: getNetColor(oppQuality.oppNet) }}, (oppQuality.oppNet >= 0 ? '+' : '') + oppQuality.oppNet.toFixed(1), e(Pct, { val: oppQuality.pcts.oppNet, isOpp: true })))
                        )
                    )
                ); 
            };

            // Shot Distribution Section - V4.6.2 ENHANCED with mathematically correct formulas
            const ShotDist = () => { 
                if (!fStats) return null;
                
                // V4.6.2: Get league shot stats for correct contribution calculations
                const la = leagueAvgShotStats || {};
                
                // Calculate shot contributions to eFG% for offense using V2 formula
                const totalAtt = fStats.rimA + fStats.midA + fStats.threeA;
                const rimContrib = calcShotContributionV2(fStats.rimM, fStats.rimA, totalAtt, false, la.rimFreq || 0.35, la.rimEfgEquiv || 60);
                const midContrib = calcShotContributionV2(fStats.midM, fStats.midA, totalAtt, false, la.midFreq || 0.18, la.midEfgEquiv || 40);
                const threeContrib = calcShotContributionV2(fStats.threeM, fStats.threeA, totalAtt, true, la.threeFreq || 0.47, la.threeEfgEquiv || 52.5);
                
                // Calculate shot contributions for defense using V2 formula
                const totalAttV = fStats.rimAV + fStats.midAV + fStats.threeAV;
                const rimContribV = calcShotContributionV2(fStats.rimMV, fStats.rimAV, totalAttV, false, la.rimFreqV || 0.35, la.rimEfgEquivV || 60);
                const midContribV = calcShotContributionV2(fStats.midMV, fStats.midAV, totalAttV, false, la.midFreqV || 0.18, la.midEfgEquivV || 40);
                const threeContribV = calcShotContributionV2(fStats.threeMV, fStats.threeAV, totalAttV, true, la.threeFreqV || 0.47, la.threeEfgEquivV || 52.5);
                
                // V4.6.2 Enhanced helper for shot stat with gradient relative colors and BOTH metrics
                const ShotStatWithAvg = ({ label, val, pct, made, att, vol, teamVal, higherGood = true, leagueKey, shotContrib, isThree = false }) => {
                    const delta = val - teamVal;
                    const isGood = higherGood ? delta > 0 : delta < 0;
                    const deltaClass = Math.abs(delta) < 0.5 ? 'team-avg-same' : isGood ? 'team-avg-better' : 'team-avg-worse';
                    const arrow = Math.abs(delta) < 0.5 ? '―' : isGood ? '▲' : '▼';
                    
                    // V4.6.1: Relative to league display with gradient colors - use leagueAvgShotStats
                    let relativeVal = null;
                    let relativeColor = '#94a3b8';
                    if (showRelativeToLeague && leagueAvgShotStats && leagueKey) {
                        const leagueAvg = leagueAvgShotStats[leagueKey] || 0;
                        const relDiff = val - leagueAvg;
                        relativeVal = (relDiff >= 0 ? '+' : '') + relDiff.toFixed(1);
                        relativeColor = getRelativeColor(relDiff, higherGood, 10);
                    }
                    
                    // V4.6: Calculate shot frequency relative to league
                    // V4.6.1: Use correct defensive volume keys when higherGood is false (defensive stats)
                    let freqRelative = null;
                    let freqRelativeColor = '#94a3b8';
                    let leagueVol = 0;
                    if (leagueAvgShotStats) {
                        if (higherGood) {
                            // Offensive: use rimVol, midVol, threeVol
                            leagueVol = isThree ? leagueAvgShotStats.threeVol : (label === 'Rim' ? leagueAvgShotStats.rimVol : leagueAvgShotStats.midVol);
                        } else {
                            // Defensive (allowed): use rimVolV, midVolV, threeVolV
                            leagueVol = isThree ? leagueAvgShotStats.threeVolV : (label === 'Rim' ? leagueAvgShotStats.rimVolV : leagueAvgShotStats.midVolV);
                        }
                    }
                    if (showRelativeToLeague && leagueVol > 0) {
                        const freqDiff = vol - leagueVol;
                        freqRelative = (freqDiff >= 0 ? '+' : '') + freqDiff.toFixed(1);
                        // For offense: higher rim/3PT freq is good, higher mid freq is bad
                        // For defense: lower rim/3PT freq allowed is good, lower mid freq is neutral
                        const freqHigherGood = higherGood ? (label === 'Mid' ? false : true) : (label === 'Mid' ? true : false);
                        freqRelativeColor = getRelativeColor(freqDiff, freqHigherGood, 5);
                    }
                    
                    // V4.6: Shot contribution color (positive = helping eFG%, negative = hurting it)
                    const contribColor = shotContrib ? getRelativeColor(shotContrib.contribution, higherGood, 3) : '#94a3b8';
                    
                    return e('div', { className: getPerfFromPct(pct), style: { padding: '12px', borderRadius: '8px', textAlign: 'center' }}, 
                        e('div', { style: { fontSize: '11px', opacity: 0.8 }}, label), 
                        showRelativeToLeague && relativeVal ? 
                            e('div', { style: { fontSize: '20px', fontWeight: 'bold', color: relativeColor }}, relativeVal + '%') :
                            e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, val.toFixed(1) + '%'), 
                        e(Pct, { val: pct }), 
                        showRelativeToLeague && e('div', { style: { fontSize: '10px', color: '#64748b' }}, 'Raw: ' + val.toFixed(1) + '%'),
                        e('div', { style: { fontSize: '11px', opacity: 0.7 }}, Math.round(made) + '/' + Math.round(att)),
                        // V4.6: Shot frequency with relative mode
                        showRelativeToLeague && freqRelative ? 
                            e('div', { style: { fontSize: '10px', color: freqRelativeColor, marginTop: '4px' }}, 'Freq: ' + freqRelative + '/100') :
                            e('div', { style: { fontSize: '10px', color: '#a78bfa', marginTop: '4px' }}, vol.toFixed(1) + '/100'),
                        // V4.6.2: Shot Contribution to eFG% - both metrics
                        shotContrib && e('div', { 
                            style: { 
                                fontSize: '9px', 
                                marginTop: '4px',
                                padding: '4px 6px',
                                background: 'rgba(0,0,0,0.3)',
                                borderRadius: '4px'
                            }
                        }, 
                            e('div', { style: { color: contribColor, marginBottom: '2px' }}, 
                                'eFG% Contrib: ' + (shotContrib.contribution >= 0 ? '+' : '') + shotContrib.contribution.toFixed(2)
                            ),
                            e('div', { style: { color: getRelativeColor(shotContrib.zoneSkill, higherGood, 2), fontSize: '8px' }}, 
                                'Zone Skill: ' + (shotContrib.zoneSkill >= 0 ? '+' : '') + shotContrib.zoneSkill.toFixed(2)
                            )
                        ),
                        e('div', { className: 'inline-team-avg', style: { marginTop: '6px', justifyContent: 'center' }},
                            e('span', { style: { fontSize: '9px', color: '#fbbf24' }}, 'Team: ' + teamVal.toFixed(1) + '%'),
                            e('span', { className: deltaClass, style: { fontSize: '9px', padding: '1px 4px', borderRadius: '3px', marginLeft: '4px' }}, arrow + (delta >= 0 ? '+' : '') + delta.toFixed(1))
                        )
                    );
                };
                return e('div', { className: 'section' }, 
                    e('h2', { className: 'section-title' }, '🎯 Shot Distribution', 
                        e('span', { className: 'click-hint' }, '(Click sections for detailed breakdown)'),
                        showRelativeToLeague && e('span', { style: { fontSize: '11px', marginLeft: '8px', padding: '2px 6px', background: 'rgba(34, 197, 94, 0.2)', borderRadius: '4px', color: '#4ade80' }}, 'vs League Avg')
                    ), 
                    e('div', { className: 'grid-2' }, 
                        e('div', { 
                            className: 'clickable-section',
                            style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '8px', padding: '16px', cursor: 'pointer' },
                            onClick: () => { setShotModalType('offense'); setShowShotModal(true); }
                        }, 
                            e('h3', { style: { color: '#4ade80', marginBottom: '16px' }}, 'Offensive', e('span', { style: { fontSize: '10px', marginLeft: '8px', opacity: 0.6 }}, '📊 Click for details')), 
                            e('div', { className: 'shot-dist-bar' }, 
                                fStats.rimRate > 0 && e('div', { className: 'shot-segment shot-rim', style: { width: fStats.rimRate + '%' }}, fStats.rimRate >= 15 ? 'Rim ' + fStats.rimRate.toFixed(0) + '%' : ''), 
                                fStats.midRate > 0 && e('div', { className: 'shot-segment shot-mid', style: { width: fStats.midRate + '%' }}, fStats.midRate >= 15 ? 'Mid ' + fStats.midRate.toFixed(0) + '%' : ''), 
                                fStats.threeRate > 0 && e('div', { className: 'shot-segment shot-three', style: { width: fStats.threeRate + '%' }}, fStats.threeRate >= 15 ? '3PT ' + fStats.threeRate.toFixed(0) + '%' : '')
                            ), 
                            e('div', { className: 'grid-3', style: { marginTop: '16px' }}, 
                                e(ShotStatWithAvg, { label: 'Rim', val: fStats.rimPct, pct: pcts.rimPct, made: fStats.rimM, att: fStats.rimA, vol: fStats.rimVol, teamVal: teamAvg.rimPct, higherGood: true, leagueKey: 'rimPct', shotContrib: rimContrib, isThree: false }),
                                e(ShotStatWithAvg, { label: 'Mid', val: fStats.midPct, pct: pcts.midPct, made: fStats.midM, att: fStats.midA, vol: fStats.midVol, teamVal: teamAvg.midPct, higherGood: true, leagueKey: 'midPct', shotContrib: midContrib, isThree: false }),
                                e(ShotStatWithAvg, { label: '3PT', val: fStats.threePct, pct: pcts.threePct, made: fStats.threeM, att: fStats.threeA, vol: fStats.threeVol, teamVal: teamAvg.threePct, higherGood: true, leagueKey: 'threePct', shotContrib: threeContrib, isThree: true })
                            ),
                            // V4.6.2: Summary totals for offensive shot contribution
                            e('div', { style: { marginTop: '12px', padding: '10px', background: 'rgba(34, 197, 94, 0.2)', borderRadius: '6px', display: 'flex', justifyContent: 'space-around', alignItems: 'center' }},
                                (() => {
                                    const totalContrib = rimContrib.contribution + midContrib.contribution + threeContrib.contribution;
                                    const totalSkill = rimContrib.zoneSkill + midContrib.zoneSkill + threeContrib.zoneSkill;
                                    return [
                                        e('div', { key: 'contrib', style: { textAlign: 'center' }},
                                            e('div', { style: { fontSize: '10px', color: '#86efac', marginBottom: '2px' }}, 'Total eFG% Contrib'),
                                            e('div', { style: { fontSize: '16px', fontWeight: 'bold', color: getRelativeColor(totalContrib, true, 5) }}, 
                                                (totalContrib >= 0 ? '+' : '') + totalContrib.toFixed(2)
                                            )
                                        ),
                                        e('div', { key: 'skill', style: { textAlign: 'center' }},
                                            e('div', { style: { fontSize: '10px', color: '#86efac', marginBottom: '2px' }}, 'Total Zone Skill'),
                                            e('div', { style: { fontSize: '16px', fontWeight: 'bold', color: getRelativeColor(totalSkill, true, 4) }}, 
                                                (totalSkill >= 0 ? '+' : '') + totalSkill.toFixed(2)
                                            )
                                        )
                                    ];
                                })()
                            ),
                            e('div', { style: { fontSize: '10px', opacity: 0.6, marginTop: '8px', textAlign: 'center' }}, 'Purple = attempts per 100 possessions')
                        ), 
                        e('div', { 
                            className: 'clickable-section',
                            style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '8px', padding: '16px', cursor: 'pointer' },
                            onClick: () => { setShotModalType('defense'); setShowShotModal(true); }
                        }, 
                            e('h3', { style: { color: '#f87171', marginBottom: '16px' }}, 'Opponent (Allowed)', e('span', { style: { fontSize: '10px', marginLeft: '8px', opacity: 0.6 }}, '📊 Click for details')), 
                            e('div', { className: 'shot-dist-bar' }, 
                                fStats.rimRateV > 0 && e('div', { className: 'shot-segment shot-rim', style: { width: fStats.rimRateV + '%' }}, fStats.rimRateV >= 15 ? 'Rim ' + fStats.rimRateV.toFixed(0) + '%' : ''), 
                                fStats.midRateV > 0 && e('div', { className: 'shot-segment shot-mid', style: { width: fStats.midRateV + '%' }}, fStats.midRateV >= 15 ? 'Mid ' + fStats.midRateV.toFixed(0) + '%' : ''), 
                                fStats.threeRateV > 0 && e('div', { className: 'shot-segment shot-three', style: { width: fStats.threeRateV + '%' }}, fStats.threeRateV >= 15 ? '3PT ' + fStats.threeRateV.toFixed(0) + '%' : '')
                            ), 
                            e('div', { className: 'grid-3', style: { marginTop: '16px' }}, 
                                e(ShotStatWithAvg, { label: 'Rim', val: fStats.rimPctV, pct: pcts.rimPctV, made: fStats.rimMV, att: fStats.rimAV, vol: fStats.rimVolV, teamVal: teamAvg.rimPctV, higherGood: false, leagueKey: 'rimPctV', shotContrib: rimContribV, isThree: false }),
                                e(ShotStatWithAvg, { label: 'Mid', val: fStats.midPctV, pct: pcts.midPctV, made: fStats.midMV, att: fStats.midAV, vol: fStats.midVolV, teamVal: teamAvg.midPctV, higherGood: false, leagueKey: 'midPctV', shotContrib: midContribV, isThree: false }),
                                e(ShotStatWithAvg, { label: '3PT', val: fStats.threePctV, pct: pcts.threePctV, made: fStats.threeMV, att: fStats.threeAV, vol: fStats.threeVolV, teamVal: teamAvg.threePctV, higherGood: false, leagueKey: 'threePctV', shotContrib: threeContribV, isThree: true })
                            ),
                            // V4.6.2: Summary totals for defensive shot contribution
                            e('div', { style: { marginTop: '12px', padding: '10px', background: 'rgba(239, 68, 68, 0.2)', borderRadius: '6px', display: 'flex', justifyContent: 'space-around', alignItems: 'center' }},
                                (() => {
                                    const totalContrib = rimContribV.contribution + midContribV.contribution + threeContribV.contribution;
                                    const totalSkill = rimContribV.zoneSkill + midContribV.zoneSkill + threeContribV.zoneSkill;
                                    return [
                                        e('div', { key: 'contrib', style: { textAlign: 'center' }},
                                            e('div', { style: { fontSize: '10px', color: '#fca5a5', marginBottom: '2px' }}, 'Total Opp eFG% Contrib'),
                                            e('div', { style: { fontSize: '16px', fontWeight: 'bold', color: getRelativeColor(totalContrib, false, 5) }}, 
                                                (totalContrib >= 0 ? '+' : '') + totalContrib.toFixed(2)
                                            )
                                        ),
                                        e('div', { key: 'skill', style: { textAlign: 'center' }},
                                            e('div', { style: { fontSize: '10px', color: '#fca5a5', marginBottom: '2px' }}, 'Total Zone Skill'),
                                            e('div', { style: { fontSize: '16px', fontWeight: 'bold', color: getRelativeColor(totalSkill, false, 4) }}, 
                                                (totalSkill >= 0 ? '+' : '') + totalSkill.toFixed(2)
                                            )
                                        )
                                    ];
                                })()
                            ),
                            e('div', { style: { fontSize: '10px', opacity: 0.6, marginTop: '8px', textAlign: 'center' }}, 'Purple = attempts per 100 possessions')
                        )
                    )
                ); 
            };

            // Pace Section
            const PaceSec = () => { 
                if (!fStats) return null; 
                const mx = 85, mn = 60, rg = mx - mn;
                const offDelta = fStats.paceF - teamAvg.paceF;
                const defDelta = fStats.paceV - teamAvg.paceV;
                const offGood = offDelta > 0;
                const defGood = defDelta < 0; // Lower opp pace is better (slower them down)
                const offDeltaClass = Math.abs(offDelta) < 0.5 ? 'team-avg-same' : offGood ? 'team-avg-better' : 'team-avg-worse';
                const defDeltaClass = Math.abs(defDelta) < 0.5 ? 'team-avg-same' : defGood ? 'team-avg-better' : 'team-avg-worse';
                return e('div', { className: 'section' }, 
                    e('h2', { className: 'section-title' }, '⚡ Pace'), 
                    e('div', { className: 'grid-2' }, 
                        e('div', { style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '8px', padding: '16px' }}, 
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}, 
                                e('span', { style: { color: '#4ade80', fontWeight: 'bold' }}, 'Offensive'), 
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' }}, 
                                    e('span', { className: getPerfFromPct(pcts.paceF), style: { padding: '4px 8px', borderRadius: '4px', fontWeight: 'bold' }}, fStats.paceF.toFixed(1)), 
                                    e(Pct, { val: pcts.paceF })
                                )
                            ), 
                            e('div', { className: 'pace-bar', style: { background: 'rgba(34, 197, 94, 0.2)' }}, 
                                e('div', { className: 'pace-fill', style: { width: Math.min(100, Math.max(0, ((fStats.paceF - mn) / rg) * 100)) + '%', background: 'linear-gradient(90deg, #22c55e, #4ade80)' }}), 
                                e('div', { className: 'pace-marker', style: { left: Math.min(98, Math.max(2, ((teamAvg.paceF - mn) / rg) * 100)) + '%' }})
                            ),
                            e('div', { className: 'inline-team-avg', style: { marginTop: '8px' }},
                                e('span', { className: 'inline-team-avg-label' }, '📊 Team:'),
                                e('span', { className: 'inline-team-avg-value' }, teamAvg.paceF.toFixed(1)),
                                e('span', { className: offDeltaClass, style: { fontSize: '11px', padding: '2px 6px', borderRadius: '4px' }}, 
                                    (Math.abs(offDelta) < 0.5 ? '―' : offGood ? '▲' : '▼') + ' ' + (offDelta >= 0 ? '+' : '') + offDelta.toFixed(1)
                                )
                            )
                        ), 
                        e('div', { style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '8px', padding: '16px' }}, 
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}, 
                                e('span', { style: { color: '#f87171', fontWeight: 'bold' }}, 'Opponent'), 
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' }}, 
                                    e('span', { className: getPerfFromPct(pcts.paceV), style: { padding: '4px 8px', borderRadius: '4px', fontWeight: 'bold' }}, fStats.paceV.toFixed(1)), 
                                    e(Pct, { val: pcts.paceV })
                                )
                            ), 
                            e('div', { className: 'pace-bar', style: { background: 'rgba(239, 68, 68, 0.2)' }}, 
                                e('div', { className: 'pace-fill', style: { width: Math.min(100, Math.max(0, ((fStats.paceV - mn) / rg) * 100)) + '%', background: 'linear-gradient(90deg, #ef4444, #f87171)' }}), 
                                e('div', { className: 'pace-marker', style: { left: Math.min(98, Math.max(2, ((teamAvg.paceV - mn) / rg) * 100)) + '%' }})
                            ),
                            e('div', { className: 'inline-team-avg', style: { marginTop: '8px' }},
                                e('span', { className: 'inline-team-avg-label' }, '📊 Team:'),
                                e('span', { className: 'inline-team-avg-value' }, teamAvg.paceV.toFixed(1)),
                                e('span', { className: defDeltaClass, style: { fontSize: '11px', padding: '2px 6px', borderRadius: '4px' }}, 
                                    (Math.abs(defDelta) < 0.5 ? '―' : defGood ? '▲' : '▼') + ' ' + (defDelta >= 0 ? '+' : '') + defDelta.toFixed(1)
                                )
                            )
                        )
                    )
                ); 
            };

            // Turnover Section - NOW CLICKABLE
            const TOSec = () => { 
                if (!fStats) return null; 
                const pR = fStats.tTo > 0 ? (fStats.passTo / fStats.tTo) * 100 : 0, dR = fStats.tTo > 0 ? (fStats.dribTo / fStats.tTo) * 100 : 0, dfR = fStats.tTo > 0 ? (fStats.defTo / fStats.tTo) * 100 : 0, mR = fStats.tTo > 0 ? (fStats.miscTo / fStats.tTo) * 100 : 0; 
                const pRV = fStats.tToV > 0 ? (fStats.passToV / fStats.tToV) * 100 : 0, dRV = fStats.tToV > 0 ? (fStats.dribToV / fStats.tToV) * 100 : 0, dfRV = fStats.tToV > 0 ? (fStats.defToV / fStats.tToV) * 100 : 0, mRV = fStats.tToV > 0 ? (fStats.miscToV / fStats.tToV) * 100 : 0; 
                return e('div', { className: 'section' }, 
                    e('h2', { className: 'section-title' }, '🔄 Turnovers', e('span', { className: 'click-hint' }, '(Click sections for detailed breakdown)')), 
                    e('div', { className: 'grid-2' }, 
                        e('div', { 
                            className: 'clickable-section',
                            style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '8px', padding: '16px', cursor: 'pointer' },
                            onClick: () => { setTOModalType('committed'); setShowTOModal(true); }
                        }, 
                            e('h3', { style: { color: '#f87171', marginBottom: '12px' }}, 'Committed (' + Math.round(fStats.tTo) + ')', e('span', { style: { fontSize: '10px', marginLeft: '8px', opacity: 0.6 }}, '📊 Click for details')), 
                            e('div', { className: 'shot-dist-bar', style: { height: '32px' }}, 
                                pR > 0 && e('div', { className: 'shot-segment', style: { width: pR + '%', background: '#ef4444' }}, pR >= 15 ? pR.toFixed(0) + '%' : ''), 
                                dR > 0 && e('div', { className: 'shot-segment', style: { width: dR + '%', background: '#f97316' }}, dR >= 15 ? dR.toFixed(0) + '%' : ''), 
                                dfR > 0 && e('div', { className: 'shot-segment', style: { width: dfR + '%', background: '#eab308' }}, dfR >= 15 ? dfR.toFixed(0) + '%' : ''), 
                                mR > 0 && e('div', { className: 'shot-segment', style: { width: mR + '%', background: '#6b7280' }}, mR >= 15 ? mR.toFixed(0) + '%' : '')
                            ), 
                            e('div', { className: 'to-breakdown' }, 
                                e('div', { className: 'to-segment', style: { background: 'rgba(239,68,68,0.3)', border: '1px solid rgba(239,68,68,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Pass'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(fStats.passTo))), 
                                e('div', { className: 'to-segment', style: { background: 'rgba(249,115,22,0.3)', border: '1px solid rgba(249,115,22,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Dribble'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(fStats.dribTo))), 
                                e('div', { className: 'to-segment', style: { background: 'rgba(234,179,8,0.3)', border: '1px solid rgba(234,179,8,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Defense'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(fStats.defTo))), 
                                e('div', { className: 'to-segment', style: { background: 'rgba(107,114,128,0.3)', border: '1px solid rgba(107,114,128,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Misc'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(fStats.miscTo)))
                            )
                        ), 
                        e('div', { 
                            className: 'clickable-section',
                            style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '8px', padding: '16px', cursor: 'pointer' },
                            onClick: () => { setTOModalType('forced'); setShowTOModal(true); }
                        }, 
                            e('h3', { style: { color: '#4ade80', marginBottom: '12px' }}, 'Forced (' + Math.round(fStats.tToV) + ')', e('span', { style: { fontSize: '10px', marginLeft: '8px', opacity: 0.6 }}, '📊 Click for details')), 
                            e('div', { className: 'shot-dist-bar', style: { height: '32px' }}, 
                                pRV > 0 && e('div', { className: 'shot-segment', style: { width: pRV + '%', background: '#22c55e' }}, pRV >= 15 ? pRV.toFixed(0) + '%' : ''), 
                                dRV > 0 && e('div', { className: 'shot-segment', style: { width: dRV + '%', background: '#84cc16' }}, dRV >= 15 ? dRV.toFixed(0) + '%' : ''), 
                                dfRV > 0 && e('div', { className: 'shot-segment', style: { width: dfRV + '%', background: '#facc15' }}, dfRV >= 15 ? dfRV.toFixed(0) + '%' : ''), 
                                mRV > 0 && e('div', { className: 'shot-segment', style: { width: mRV + '%', background: '#9ca3af' }}, mRV >= 15 ? mRV.toFixed(0) + '%' : '')
                            ), 
                            e('div', { className: 'to-breakdown' }, 
                                e('div', { className: 'to-segment', style: { background: 'rgba(34,197,94,0.3)', border: '1px solid rgba(34,197,94,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Pass'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(fStats.passToV))), 
                                e('div', { className: 'to-segment', style: { background: 'rgba(132,204,22,0.3)', border: '1px solid rgba(132,204,22,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Dribble'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(fStats.dribToV))), 
                                e('div', { className: 'to-segment', style: { background: 'rgba(250,204,21,0.3)', border: '1px solid rgba(250,204,21,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Defense'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(fStats.defToV))), 
                                e('div', { className: 'to-segment', style: { background: 'rgba(156,163,175,0.3)', border: '1px solid rgba(156,163,175,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Misc'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(fStats.miscToV)))
                            )
                        )
                    )
                ); 
            };

            // Four Factors Section
            const FourFactors = () => { 
                if (!fStats) return null; 
                
                // Schedule Strength Slider Component - V4.6.1: Now uses actual opponent quality
                const SchedSlider = ({ label, adjKey }) => e('div', { className: 'la-individual-sched-slider', style: { display: 'flex', alignItems: 'center', gap: '6px', marginTop: '4px' }},
                    e('span', { style: { fontSize: '9px', color: '#64748b', minWidth: '65px' }}, 'Opp Qual Adj:'),
                    e('input', { 
                        type: 'range', min: 0, max: 100, 
                        value: mainScheduleAdj[adjKey] || 0,
                        onChange: ev => setMainScheduleAdj(prev => ({ ...prev, [adjKey]: parseInt(ev.target.value) })),
                        style: { flex: 1, height: '3px', accentColor: '#fbbf24' }
                    }),
                    e('span', { style: { fontSize: '9px', color: mainScheduleAdj[adjKey] > 0 ? '#fbbf24' : '#475569', minWidth: '28px', textAlign: 'right' }}, 
                        (mainScheduleAdj[adjKey] || 0) + '%'
                    )
                );
                
                return e('div', { className: 'section' }, 
                    e('div', { className: 'flex-between' }, 
                        e('h2', { className: 'section-title' }, 'Four Factors',
                            showRelativeToLeague && e('span', { style: { fontSize: '11px', marginLeft: '8px', padding: '2px 6px', background: 'rgba(34, 197, 94, 0.2)', borderRadius: '4px', color: '#4ade80' }}, 'vs League Avg')
                        ), 
                        e('div', { style: { display: 'flex', gap: '8px' }},
                            e('button', { 
                                className: 'btn btn-secondary', 
                                style: { fontSize: '10px', padding: '4px 8px' },
                                onClick: () => { setMainScheduleAdj({ offEfg: 0, offTov: 0, offOreb: 0, offFtR: 0, defEfg: 0, defTov: 0, defOreb: 0, defFtR: 0 }); setMainMasterScheduleAdj(0); }
                            }, '↻ Reset Adj'),
                            e('button', { className: 'btn btn-toggle', onClick: () => setShowAdv(!showAdv) }, showAdv ? 'Hide Details' : 'Show Details')
                        )
                    ),
                    
                    // V4.6.3: Universal Master Opp Quality Adjustment Slider
                    e('div', { style: { 
                        marginBottom: '16px', 
                        padding: '12px 16px', 
                        background: 'linear-gradient(135deg, rgba(251, 191, 36, 0.12), rgba(249, 115, 22, 0.08))', 
                        border: '2px solid rgba(251, 191, 36, 0.35)', 
                        borderRadius: '8px' 
                    }},
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap' }},
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' }},
                                e('span', { style: { fontSize: '14px' }}, '🎯'),
                                e('span', { style: { fontSize: '12px', fontWeight: '700', color: '#fbbf24' }}, 'MASTER Opp Qual Adj')
                            ),
                            e('input', { 
                                type: 'range', 
                                min: 0, 
                                max: 100, 
                                value: mainMasterScheduleAdj,
                                onChange: ev => setMainMasterScheduleAdj(parseInt(ev.target.value)),
                                style: { flex: 1, minWidth: '150px', height: '6px', accentColor: '#f59e0b' }
                            }),
                            e('span', { style: { 
                                fontSize: '12px', 
                                fontWeight: 'bold', 
                                color: mainMasterScheduleAdj > 0 ? '#f59e0b' : '#64748b', 
                                minWidth: '40px',
                                textAlign: 'right',
                                padding: '3px 6px',
                                background: mainMasterScheduleAdj > 0 ? 'rgba(251, 191, 36, 0.2)' : 'transparent',
                                borderRadius: '4px'
                            }}, mainMasterScheduleAdj + '%')
                        ),
                        e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '6px' }},
                            mainMasterScheduleAdj > 0 ? 
                                '✓ Applies ' + mainMasterScheduleAdj + '% adjustment to ALL four factors (stacks with individual sliders)' :
                                'Slide to apply opponent quality adjustment to all four factors at once'
                        )
                    ),
                    
                    e('div', { className: 'la-four-factors-grid', style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '24px' }},
                        e('div', { style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '8px', padding: '16px' }},
                            e('h3', { style: { color: '#4ade80', marginBottom: '12px' }}, 'Offensive'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }},
                                e('div', { className: getPerfFromPct(pcts.offEfg), style: { padding: '8px', borderRadius: '6px' }},
                                    e('div', { className: 'text-xs' }, 'eFG%'),
                                    e(StatWithContext, { val: fStats.offEfg, pct: pcts.offEfg, oppVal: oppQuality?.oppDefEfg, oppPct: oppQuality?.pcts.oppDefEfg, oppHigherHarder: false, teamAvgVal: teamAvg.offEfg, higherBetter: true, leagueKey: 'offEfg', schedAdjKey: 'offEfg' }),
                                    e(SchedSlider, { label: 'eFG%', adjKey: 'offEfg' })
                                ), 
                                e('div', { className: getPerfFromPct(pcts.offTov), style: { padding: '8px', borderRadius: '6px' }}, 
                                    e('div', { className: 'text-xs' }, 'TOV%'), 
                                    e(StatWithContext, { val: fStats.offTov, pct: pcts.offTov, oppVal: oppQuality?.oppDefTov, oppPct: oppQuality?.pcts.oppDefTov, oppHigherHarder: true, teamAvgVal: teamAvg.offTov, higherBetter: false, leagueKey: 'offTov', schedAdjKey: 'offTov' }),
                                    e(SchedSlider, { label: 'TOV%', adjKey: 'offTov' })
                                ), 
                                e('div', { className: getPerfFromPct(pcts.offOreb), style: { padding: '8px', borderRadius: '6px', cursor: 'pointer' }, onClick: () => setShowOrebModal(true) }, 
                                    e('div', { className: 'text-xs' }, 'OREB%', e('span', { style: { marginLeft: '4px', fontSize: '9px', opacity: 0.6 }}, '📊')), 
                                    e(StatWithContext, { val: fStats.offOreb, pct: pcts.offOreb, oppVal: oppQuality?.oppDefOreb, oppPct: oppQuality?.pcts.oppDefOreb, oppHigherHarder: false, teamAvgVal: teamAvg.offOreb, higherBetter: true, leagueKey: 'offOreb', schedAdjKey: 'offOreb' }),
                                    e(SchedSlider, { label: 'OREB%', adjKey: 'offOreb' })
                                ), 
                                e('div', { className: getPerfFromPct(pcts.offFtR), style: { padding: '8px', borderRadius: '6px' }}, 
                                    e('div', { className: 'text-xs' }, 'FT Rate'), 
                                    e(StatWithContext, { val: fStats.offFtR, pct: pcts.offFtR, teamAvgVal: teamAvg.offFtR, higherBetter: true, leagueKey: 'offFtR', schedAdjKey: 'offFtR' }),
                                    e(SchedSlider, { label: 'FT Rate', adjKey: 'offFtR' })
                                )
                            )
                        ), 
                        e('div', { style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '8px', padding: '16px' }}, 
                            e('h3', { style: { color: '#f87171', marginBottom: '12px' }}, 'Defensive'), 
                            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}, 
                                e('div', { className: getPerfFromPct(pcts.defEfg), style: { padding: '8px', borderRadius: '6px' }}, 
                                    e('div', { className: 'text-xs' }, 'Opp eFG%'), 
                                    e(StatWithContext, { val: fStats.defEfg, pct: pcts.defEfg, oppVal: oppQuality?.oppOffEfg, oppPct: oppQuality?.pcts.oppOffEfg, oppHigherHarder: true, teamAvgVal: teamAvg.defEfg, higherBetter: false, leagueKey: 'defEfg', schedAdjKey: 'defEfg' }),
                                    e(SchedSlider, { label: 'Opp eFG%', adjKey: 'defEfg' })
                                ), 
                                e('div', { className: getPerfFromPct(pcts.defTov), style: { padding: '8px', borderRadius: '6px' }}, 
                                    e('div', { className: 'text-xs' }, 'Opp TOV%'), 
                                    e(StatWithContext, { val: fStats.defTov, pct: pcts.defTov, oppVal: oppQuality?.oppOffTov, oppPct: oppQuality?.pcts.oppOffTov, oppHigherHarder: false, teamAvgVal: teamAvg.defTov, higherBetter: true, leagueKey: 'defTov', schedAdjKey: 'defTov' }),
                                    e(SchedSlider, { label: 'Opp TOV%', adjKey: 'defTov' })
                                ), 
                                e('div', { className: getPerfFromPct(pcts.defOreb), style: { padding: '8px', borderRadius: '6px' }}, 
                                    e('div', { className: 'text-xs' }, 'Opp OREB%'), 
                                    e(StatWithContext, { val: fStats.defOreb, pct: pcts.defOreb, oppVal: oppQuality?.oppOffOreb, oppPct: oppQuality?.pcts.oppOffOreb, oppHigherHarder: true, teamAvgVal: teamAvg.defOreb, higherBetter: false, leagueKey: 'defOreb', schedAdjKey: 'defOreb' }),
                                    e(SchedSlider, { label: 'Opp OREB%', adjKey: 'defOreb' })
                                ), 
                                e('div', { className: getPerfFromPct(pcts.defFtR), style: { padding: '8px', borderRadius: '6px' }}, 
                                    e('div', { className: 'text-xs' }, 'Opp FT Rate'), 
                                    e(StatWithContext, { val: fStats.defFtR, pct: pcts.defFtR, teamAvgVal: teamAvg.defFtR, higherBetter: false, leagueKey: 'defFtR', schedAdjKey: 'defFtR' }),
                                    e(SchedSlider, { label: 'Opp FT Rate', adjKey: 'defFtR' })
                                )
                            )
                        )
                    ),
                    
                    // V4.6.3: Simulated Ratings Section
                    (() => {
                        if (!leagueAverages) return null;
                        
                        // Calculate adjusted four factors based on sliders
                        const getAdjustedFF = () => {
                            const adjusted = {
                                offEfg: fStats.offEfg,
                                offTov: fStats.offTov,
                                offOreb: fStats.offOreb,
                                offFtR: fStats.offFtR,
                                defEfg: fStats.defEfg,
                                defTov: fStats.defTov,
                                defOreb: fStats.defOreb,
                                defFtR: fStats.defFtR
                            };
                            
                            // Apply adjustments using same logic as StatWithContext
                            const statKeys = ['offEfg', 'offTov', 'offOreb', 'offFtR', 'defEfg', 'defTov', 'defOreb', 'defFtR'];
                            statKeys.forEach(key => {
                                const individualAdj = mainScheduleAdj[key] || 0;
                                const totalAdj = Math.min(100, mainMasterScheduleAdj + individualAdj);
                                if (totalAdj <= 0) return;
                                
                                const leagueAvg = leagueAverages[key] || adjusted[key];
                                const adjFactor = totalAdj / 100;
                                
                                // Simple regression to league average for simulation display
                                adjusted[key] = adjusted[key] + (leagueAvg - adjusted[key]) * adjFactor * 0.5;
                            });
                            
                            return adjusted;
                        };
                        
                        const adjustedFF = getAdjustedFF();
                        const simRatings = calcSimulatedRatings(adjustedFF, leagueAverages);
                        const rawSimRatings = calcSimulatedRatings(fStats, leagueAverages);
                        
                        if (!simRatings || !rawSimRatings) return null;
                        
                        const hasAnyAdj = mainMasterScheduleAdj > 0 || Object.values(mainScheduleAdj).some(v => v > 0);
                        const actualOrtg = fStats.off || 0;
                        const actualDrtg = fStats.def || 0;
                        const actualNet = fStats.net || 0;
                        
                        return e('div', { style: { 
                            marginTop: '20px', 
                            padding: '16px', 
                            background: 'linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.08))', 
                            border: '1px solid rgba(139, 92, 246, 0.3)', 
                            borderRadius: '10px' 
                        }},
                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '12px' }},
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                    e('span', { style: { fontSize: '16px' }}, '🧮'),
                                    e('span', { style: { fontSize: '14px', fontWeight: '700', color: '#a78bfa' }}, 'Simulated Ratings from Four Factors'),
                                    hasAnyAdj && e('span', { style: { 
                                        fontSize: '9px', 
                                        padding: '2px 6px', 
                                        background: 'rgba(251, 191, 36, 0.2)', 
                                        border: '1px solid rgba(251, 191, 36, 0.4)',
                                        borderRadius: '4px', 
                                        color: '#fbbf24' 
                                    }}, '⚙️ ADJUSTED')
                                ),
                                e('div', { style: { fontSize: '9px', color: '#64748b' }}, 'Dean Oliver coefficients')
                            ),
                            
                            // Ratings grid
                            e('div', { className: 'compare-sim-team-stats', style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '12px' }},
                                // Simulated ORTG
                                e('div', { style: { background: 'rgba(34, 197, 94, 0.12)', padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '10px', color: '#4ade80', marginBottom: '4px' }}, 'Sim ORTG'),
                                    e('div', { style: { fontSize: '22px', fontWeight: 'bold' }}, simRatings.ortg.toFixed(1)),
                                    e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '4px' }}, 
                                        'Actual: ' + actualOrtg.toFixed(1),
                                        hasAnyAdj && e('span', { style: { color: simRatings.ortg > actualOrtg ? '#4ade80' : simRatings.ortg < actualOrtg ? '#f87171' : '#94a3b8', marginLeft: '4px' }}, 
                                            '(' + (simRatings.ortg >= actualOrtg ? '+' : '') + (simRatings.ortg - actualOrtg).toFixed(1) + ')'
                                        )
                                    ),
                                    !hasAnyAdj && e('div', { style: { fontSize: '9px', color: '#64748b' }}, 
                                        'Raw Δ: ' + (rawSimRatings.ortg >= actualOrtg ? '+' : '') + (rawSimRatings.ortg - actualOrtg).toFixed(1)
                                    )
                                ),
                                // Simulated DRTG
                                e('div', { style: { background: 'rgba(239, 68, 68, 0.12)', padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '10px', color: '#f87171', marginBottom: '4px' }}, 'Sim DRTG'),
                                    e('div', { style: { fontSize: '22px', fontWeight: 'bold' }}, simRatings.drtg.toFixed(1)),
                                    e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '4px' }}, 
                                        'Actual: ' + actualDrtg.toFixed(1),
                                        hasAnyAdj && e('span', { style: { color: simRatings.drtg < actualDrtg ? '#4ade80' : simRatings.drtg > actualDrtg ? '#f87171' : '#94a3b8', marginLeft: '4px' }}, 
                                            '(' + (simRatings.drtg >= actualDrtg ? '+' : '') + (simRatings.drtg - actualDrtg).toFixed(1) + ')'
                                        )
                                    ),
                                    !hasAnyAdj && e('div', { style: { fontSize: '9px', color: '#64748b' }}, 
                                        'Raw Δ: ' + (rawSimRatings.drtg >= actualDrtg ? '+' : '') + (rawSimRatings.drtg - actualDrtg).toFixed(1)
                                    )
                                ),
                                // Simulated NET
                                e('div', { style: { background: 'rgba(59, 130, 246, 0.12)', padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '10px', color: '#60a5fa', marginBottom: '4px' }}, 'Sim NET'),
                                    e('div', { style: { fontSize: '22px', fontWeight: 'bold', color: simRatings.net >= 0 ? '#4ade80' : '#f87171' }}, 
                                        (simRatings.net >= 0 ? '+' : '') + simRatings.net.toFixed(1)
                                    ),
                                    e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '4px' }}, 
                                        'Actual: ' + (actualNet >= 0 ? '+' : '') + actualNet.toFixed(1),
                                        hasAnyAdj && e('span', { style: { color: simRatings.net > actualNet ? '#4ade80' : simRatings.net < actualNet ? '#f87171' : '#94a3b8', marginLeft: '4px' }}, 
                                            '(' + (simRatings.net >= actualNet ? '+' : '') + (simRatings.net - actualNet).toFixed(1) + ')'
                                        )
                                    ),
                                    !hasAnyAdj && e('div', { style: { fontSize: '9px', color: '#64748b' }}, 
                                        'Raw Δ: ' + (rawSimRatings.net >= actualNet ? '+' : '') + (rawSimRatings.net - actualNet).toFixed(1)
                                    )
                                )
                            ),
                            
                            // Methodology note
                            e('div', { style: { marginTop: '12px', padding: '8px', background: 'rgba(0,0,0,0.12)', borderRadius: '6px', fontSize: '9px', color: '#64748b' }},
                                e('strong', { style: { color: '#a78bfa' }}, '📖 '),
                                'Coefficients: eFG% ×1.85, TOV% ×-1.25, OREB% ×0.60, FT Rate ×0.45 pts/100 per 1%.',
                                hasAnyAdj && e('span', { style: { color: '#fbbf24', marginLeft: '6px' }}, 
                                    '⚙️ Adj applied: Master ' + mainMasterScheduleAdj + '% + individual sliders'
                                )
                            )
                        );
                    })(),
                    
                    showAdv && e('div', { className: 'advanced-stats-section' }, 
                        e('h3', { style: { fontSize: '16px', fontWeight: 'bold', marginBottom: '16px' }}, 'Advanced Stats'), 
                        e('div', { className: 'grid-2' }, 
                            e('div', { style: { background: 'rgba(34, 197, 94, 0.08)', border: '1px solid rgba(34, 197, 94, 0.25)', borderRadius: '8px', padding: '16px' }}, 
                                e('h4', { style: { color: '#4ade80', marginBottom: '12px', fontSize: '14px' }}, 'Playmaking & Pressure (For)'), 
                                e('div', { className: 'grid-3', style: { gap: '8px' }}, 
                                    (() => {
                                        const d = fStats.astPct - teamAvg.astPct;
                                        const cls = Math.abs(d) < 0.5 ? 'team-avg-same' : d > 0 ? 'team-avg-better' : 'team-avg-worse';
                                        const arr = Math.abs(d) < 0.5 ? '―' : d > 0 ? '▲' : '▼';
                                        return e('div', { className: getPerfFromPct(pcts.astPct), style: { padding: '10px', borderRadius: '6px', textAlign: 'center', cursor: 'pointer' }, onClick: () => setShowAstModal(true) }, 
                                            e('div', { style: { fontSize: '10px', opacity: 0.8 }}, 'AST%', e('span', { style: { marginLeft: '4px', fontSize: '8px', opacity: 0.6 }}, '📊')), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px' }}, 
                                                e('span', { style: { fontSize: '20px', fontWeight: 'bold' }}, fStats.astPct.toFixed(1) + '%'), 
                                                e(Pct, { val: pcts.astPct })
                                            ), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px', marginTop: '4px' }},
                                                e('span', { style: { fontSize: '9px', color: '#fbbf24' }}, 'Team: ' + teamAvg.astPct.toFixed(1) + '%'),
                                                e('span', { className: cls, style: { fontSize: '9px', padding: '1px 4px', borderRadius: '3px' }}, arr + (d >= 0 ? '+' : '') + d.toFixed(1))
                                            )
                                        );
                                    })(), 
                                    (() => {
                                        const d = fStats.stlPct - teamAvg.stlPct;
                                        const cls = Math.abs(d) < 0.5 ? 'team-avg-same' : d > 0 ? 'team-avg-better' : 'team-avg-worse';
                                        const arr = Math.abs(d) < 0.5 ? '―' : d > 0 ? '▲' : '▼';
                                        return e('div', { className: getPerfFromPct(pcts.stlPct), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }}, 
                                            e('div', { style: { fontSize: '10px', opacity: 0.8 }}, 'STL%'), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px' }}, 
                                                e('span', { style: { fontSize: '20px', fontWeight: 'bold' }}, fStats.stlPct.toFixed(1) + '%'), 
                                                e(Pct, { val: pcts.stlPct })
                                            ), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px', marginTop: '4px' }},
                                                e('span', { style: { fontSize: '9px', color: '#fbbf24' }}, 'Team: ' + teamAvg.stlPct.toFixed(1) + '%'),
                                                e('span', { className: cls, style: { fontSize: '9px', padding: '1px 4px', borderRadius: '3px' }}, arr + (d >= 0 ? '+' : '') + d.toFixed(1))
                                            )
                                        );
                                    })(), 
                                    (() => {
                                        const d = fStats.blkPct - teamAvg.blkPct;
                                        const cls = Math.abs(d) < 0.5 ? 'team-avg-same' : d > 0 ? 'team-avg-better' : 'team-avg-worse';
                                        const arr = Math.abs(d) < 0.5 ? '―' : d > 0 ? '▲' : '▼';
                                        return e('div', { className: getPerfFromPct(pcts.blkPct), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }}, 
                                            e('div', { style: { fontSize: '10px', opacity: 0.8 }}, 'BLK%'), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px' }}, 
                                                e('span', { style: { fontSize: '20px', fontWeight: 'bold' }}, fStats.blkPct.toFixed(1) + '%'), 
                                                e(Pct, { val: pcts.blkPct })
                                            ), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px', marginTop: '4px' }},
                                                e('span', { style: { fontSize: '9px', color: '#fbbf24' }}, 'Team: ' + teamAvg.blkPct.toFixed(1) + '%'),
                                                e('span', { className: cls, style: { fontSize: '9px', padding: '1px 4px', borderRadius: '3px' }}, arr + (d >= 0 ? '+' : '') + d.toFixed(1))
                                            )
                                        );
                                    })()
                                )
                            ), 
                            e('div', { style: { background: 'rgba(239, 68, 68, 0.08)', border: '1px solid rgba(239, 68, 68, 0.25)', borderRadius: '8px', padding: '16px' }}, 
                                e('h4', { style: { color: '#f87171', marginBottom: '12px', fontSize: '14px' }}, 'Opp Playmaking & Pressure (Against)'), 
                                e('div', { className: 'grid-3', style: { gap: '8px' }}, 
                                    (() => {
                                        const d = fStats.oppAstPct - teamAvg.oppAstPct;
                                        const cls = Math.abs(d) < 0.5 ? 'team-avg-same' : d < 0 ? 'team-avg-better' : 'team-avg-worse'; // lower is better
                                        const arr = Math.abs(d) < 0.5 ? '―' : d < 0 ? '▲' : '▼';
                                        return e('div', { className: getPerfFromPct(pcts.oppAstPct), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }}, 
                                            e('div', { style: { fontSize: '10px', opacity: 0.8 }}, 'Opp AST%'), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px' }}, 
                                                e('span', { style: { fontSize: '20px', fontWeight: 'bold' }}, fStats.oppAstPct.toFixed(1) + '%'), 
                                                e(Pct, { val: pcts.oppAstPct })
                                            ), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px', marginTop: '4px' }},
                                                e('span', { style: { fontSize: '9px', color: '#fbbf24' }}, 'Team: ' + teamAvg.oppAstPct.toFixed(1) + '%'),
                                                e('span', { className: cls, style: { fontSize: '9px', padding: '1px 4px', borderRadius: '3px' }}, arr + (d >= 0 ? '+' : '') + d.toFixed(1))
                                            )
                                        );
                                    })(), 
                                    (() => {
                                        const d = fStats.oppStlPct - teamAvg.oppStlPct;
                                        const cls = Math.abs(d) < 0.5 ? 'team-avg-same' : d < 0 ? 'team-avg-better' : 'team-avg-worse';
                                        const arr = Math.abs(d) < 0.5 ? '―' : d < 0 ? '▲' : '▼';
                                        return e('div', { className: getPerfFromPct(pcts.oppStlPct), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }}, 
                                            e('div', { style: { fontSize: '10px', opacity: 0.8 }}, 'Opp STL%'), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px' }}, 
                                                e('span', { style: { fontSize: '20px', fontWeight: 'bold' }}, fStats.oppStlPct.toFixed(1) + '%'), 
                                                e(Pct, { val: pcts.oppStlPct })
                                            ), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px', marginTop: '4px' }},
                                                e('span', { style: { fontSize: '9px', color: '#fbbf24' }}, 'Team: ' + teamAvg.oppStlPct.toFixed(1) + '%'),
                                                e('span', { className: cls, style: { fontSize: '9px', padding: '1px 4px', borderRadius: '3px' }}, arr + (d >= 0 ? '+' : '') + d.toFixed(1))
                                            )
                                        );
                                    })(), 
                                    (() => {
                                        const d = fStats.oppBlkPct - teamAvg.oppBlkPct;
                                        const cls = Math.abs(d) < 0.5 ? 'team-avg-same' : d < 0 ? 'team-avg-better' : 'team-avg-worse';
                                        const arr = Math.abs(d) < 0.5 ? '―' : d < 0 ? '▲' : '▼';
                                        return e('div', { className: getPerfFromPct(pcts.oppBlkPct), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }}, 
                                            e('div', { style: { fontSize: '10px', opacity: 0.8 }}, 'Opp BLK%'), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px' }}, 
                                                e('span', { style: { fontSize: '20px', fontWeight: 'bold' }}, fStats.oppBlkPct.toFixed(1) + '%'), 
                                                e(Pct, { val: pcts.oppBlkPct })
                                            ), 
                                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px', marginTop: '4px' }},
                                                e('span', { style: { fontSize: '9px', color: '#fbbf24' }}, 'Team: ' + teamAvg.oppBlkPct.toFixed(1) + '%'),
                                                e('span', { className: cls, style: { fontSize: '9px', padding: '1px 4px', borderRadius: '3px' }}, arr + (d >= 0 ? '+' : '') + d.toFixed(1))
                                            )
                                        );
                                    })()
                                )
                            )
                        )
                    ), 
                    showAdv && e('div', { style: { marginTop: '16px' }}, 
                        e('div', { className: 'grid-2' }, 
                            e('div', { style: { background: 'rgba(59, 130, 246, 0.08)', border: '1px solid rgba(59, 130, 246, 0.25)', borderRadius: '8px', padding: '16px' }}, 
                                e('h4', { style: { color: '#60a5fa', marginBottom: '12px', fontSize: '14px' }}, 'Possessions (Dean Oliver)'), 
                                e('div', { className: 'grid-3', style: { gap: '8px' }}, 
                                    e('div', { style: { background: 'rgba(59, 130, 246, 0.2)', padding: '10px', borderRadius: '6px', textAlign: 'center' }}, 
                                        e('div', { style: { fontSize: '10px', opacity: 0.8 }}, 'Off Poss'), 
                                        e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, Math.round(fStats.poss))
                                    ), 
                                    e('div', { style: { background: 'rgba(59, 130, 246, 0.2)', padding: '10px', borderRadius: '6px', textAlign: 'center' }}, 
                                        e('div', { style: { fontSize: '10px', opacity: 0.8 }}, 'Def Poss'), 
                                        e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, Math.round(fStats.possV))
                                    ), 
                                    e('div', { style: { background: 'rgba(59, 130, 246, 0.2)', padding: '10px', borderRadius: '6px', textAlign: 'center' }}, 
                                        e('div', { style: { fontSize: '10px', opacity: 0.8 }}, 'Minutes'), 
                                        e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, (fStats.time / 60).toFixed(1))
                                    )
                                )
                            )
                        )
                    ),
                    // MISC Stats Section - 2nd Chance and Points Off Turnovers with Percentiles
                    e('div', { style: { marginTop: '24px' }},
                        e('h3', { style: { fontSize: '18px', fontWeight: 'bold', marginBottom: '16px', color: '#f59e0b' }}, '🔄 MISC Stats (per 100 possessions)'),
                        e('div', { className: 'la-misc-stats-grid', style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '24px' }},
                            e('div', { style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '8px', padding: '16px' }},
                                e('h4', { style: { color: '#4ade80', marginBottom: '12px', fontSize: '14px' }}, 'Offensive'),
                                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }},
                                    e('div', { className: getPerfFromPct(pcts.secChance100 || 50), style: { padding: '8px', borderRadius: '6px' }},
                                        e('div', { className: 'text-xs' }, '2nd Chance Pts'),
                                        e(StatWithContext, { val: fStats.secChance100 || 0, pct: pcts.secChance100 || 50, teamAvgVal: teamAvg.secChance100 || 0, higherBetter: true })
                                    ),
                                    e('div', { className: getPerfFromPct(pcts.ptsOffTov100 || 50), style: { padding: '8px', borderRadius: '6px' }},
                                        e('div', { className: 'text-xs' }, 'Pts Off TOV'),
                                        e(StatWithContext, { val: fStats.ptsOffTov100 || 0, pct: pcts.ptsOffTov100 || 50, teamAvgVal: teamAvg.ptsOffTov100 || 0, higherBetter: true })
                                    )
                                )
                            ),
                            e('div', { style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '8px', padding: '16px' }},
                                e('h4', { style: { color: '#f87171', marginBottom: '12px', fontSize: '14px' }}, 'Defensive'),
                                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }},
                                    e('div', { className: getPerfFromPct(pcts.secChance100V || 50), style: { padding: '8px', borderRadius: '6px' }},
                                        e('div', { className: 'text-xs' }, 'Opp 2nd Chance'),
                                        e(StatWithContext, { val: fStats.secChance100V || 0, pct: pcts.secChance100V || 50, teamAvgVal: teamAvg.secChance100V || 0, higherBetter: false })
                                    ),
                                    e('div', { className: getPerfFromPct(pcts.ptsOffTov100V || 50), style: { padding: '8px', borderRadius: '6px' }},
                                        e('div', { className: 'text-xs' }, 'Opp Pts Off TOV'),
                                        e(StatWithContext, { val: fStats.ptsOffTov100V || 0, pct: pcts.ptsOffTov100V || 50, teamAvgVal: teamAvg.ptsOffTov100V || 0, higherBetter: false })
                                    )
                                )
                            )
                        )
                    )
                ); 
            };

            // =======================================================================
            // TRANSITION TAB - Fast break stats and play type percentages
            // =======================================================================
            const TransitionTab = () => {
                if (!fStats) return null;
                
                return e('div', { className: 'section' },
                    e('h2', { className: 'section-title', style: { color: '#f59e0b' }}, '⚡ Transition Stats',
                        showRelativeToLeague && e('span', { style: { fontSize: '11px', marginLeft: '8px', padding: '2px 6px', background: 'rgba(34, 197, 94, 0.2)', borderRadius: '4px', color: '#4ade80' }}, 'vs League Avg')
                    ),
                    e('div', { className: 'la-transition-grid', style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '24px', marginTop: '16px' }},
                        // Offensive
                        e('div', { style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '8px', padding: '16px' }},
                            e('h3', { style: { color: '#4ade80', marginBottom: '12px' }}, 'Offensive'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }},
                                e('div', { className: getPerfFromPct(pcts.fastBreak100 || 50), style: { padding: '8px', borderRadius: '6px' }},
                                    e('div', { className: 'text-xs' }, 'Fast Break Pts/100'),
                                    e(StatWithContext, { val: fStats.fastBreak100 || 0, pct: pcts.fastBreak100 || 50, teamAvgVal: teamAvg.fastBreak100 || 0, higherBetter: true, leagueKey: 'fastBreak100', leagueAvgSource: leagueAvgShotStats })
                                ),
                                e('div', { className: getPerfFromPct(pcts.transPct || 50), style: { padding: '8px', borderRadius: '6px' }},
                                    e('div', { className: 'text-xs' }, 'Transition %'),
                                    e(StatWithContext, { val: fStats.transPct || 0, pct: pcts.transPct || 50, teamAvgVal: teamAvg.transPct || 0, higherBetter: true, leagueKey: 'transPct', leagueAvgSource: leagueAvgShotStats })
                                )
                            ),
                            e('div', { style: { marginTop: '12px', padding: '8px', background: 'rgba(34, 197, 94, 0.08)', borderRadius: '6px', fontSize: '11px', opacity: 0.8 }},
                                'Raw: ', Math.round(fStats.fastBreak || 0), ' FB pts / ', Math.round(fStats.pts || 0), ' total pts'
                            )
                        ),
                        // Defensive
                        e('div', { style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '8px', padding: '16px' }},
                            e('h3', { style: { color: '#f87171', marginBottom: '12px' }}, 'Defensive'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }},
                                e('div', { className: getPerfFromPct(pcts.fastBreak100V || 50), style: { padding: '8px', borderRadius: '6px' }},
                                    e('div', { className: 'text-xs' }, 'Opp FB Pts/100'),
                                    e(StatWithContext, { val: fStats.fastBreak100V || 0, pct: pcts.fastBreak100V || 50, teamAvgVal: teamAvg.fastBreak100V || 0, higherBetter: false, leagueKey: 'fastBreak100V', leagueAvgSource: leagueAvgShotStats })
                                ),
                                e('div', { className: getPerfFromPct(pcts.transPctV || 50), style: { padding: '8px', borderRadius: '6px' }},
                                    e('div', { className: 'text-xs' }, 'Opp Transition %'),
                                    e(StatWithContext, { val: fStats.transPctV || 0, pct: pcts.transPctV || 50, teamAvgVal: teamAvg.transPctV || 0, higherBetter: false, leagueKey: 'transPctV', leagueAvgSource: leagueAvgShotStats })
                                )
                            ),
                            e('div', { style: { marginTop: '12px', padding: '8px', background: 'rgba(239, 68, 68, 0.08)', borderRadius: '6px', fontSize: '11px', opacity: 0.8 }},
                                'Raw: ', Math.round(fStats.fastBreakV || 0), ' opp FB pts / ', Math.round(fStats.ptsV || 0), ' opp total pts'
                            )
                        )
                    ),
                    // Differential section
                    e('div', { style: { marginTop: '24px', background: 'rgba(168, 85, 247, 0.1)', border: '1px solid rgba(168, 85, 247, 0.3)', borderRadius: '8px', padding: '20px' }},
                        e('h3', { style: { color: '#a78bfa', marginBottom: '16px', fontSize: '16px' }}, '📊 Transition Differential'),
                        e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '24px' }},
                            e('div', { style: { textAlign: 'center' }},
                                e('div', { style: { fontSize: '11px', opacity: 0.8 }}, 'Fast Break Pts Diff (per 100)'),
                                (() => {
                                    const diff = (fStats.fastBreak100 || 0) - (fStats.fastBreak100V || 0);
                                    const color = diff > 0 ? '#4ade80' : diff < 0 ? '#f87171' : '#a78bfa';
                                    return e('div', { style: { fontSize: '32px', fontWeight: 'bold', color }}, (diff > 0 ? '+' : '') + diff.toFixed(1));
                                })()
                            ),
                            e('div', { style: { textAlign: 'center' }},
                                e('div', { style: { fontSize: '11px', opacity: 0.8 }}, 'Transition % Diff'),
                                (() => {
                                    const diff = (fStats.transPct || 0) - (fStats.transPctV || 0);
                                    const color = diff > 0 ? '#4ade80' : diff < 0 ? '#f87171' : '#a78bfa';
                                    return e('div', { style: { fontSize: '32px', fontWeight: 'bold', color }}, (diff > 0 ? '+' : '') + diff.toFixed(1) + '%');
                                })()
                            )
                        )
                    )
                );
            };

            // =======================================================================
            // ASSIST COMBINATIONS TAB - V4.9.8.7: Redesigned Clean Relational Graph
            // =======================================================================
            const AssistCombosTab = () => {
                if (!assistComboData.length) {
                    return e('div', { className: 'section' },
                        e('h2', { className: 'section-title', style: { color: '#10b981' }}, '🤝 Assist Combinations'),
                        e('div', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }},
                            e('div', { style: { fontSize: '48px', marginBottom: '16px' }}, '📤'),
                            e('p', null, 'Upload Assist Combinations CSV to view assist network'),
                            e('p', { style: { fontSize: '12px', marginTop: '8px' }}, 'Required columns: Assister_Name, Scorer_Name, Assists, Points_Created')
                        )
                    );
                }

                // Filter assist data for current team
                const teamAssists = assistComboData.filter(d => d.Team === team);

                if (teamAssists.length === 0) {
                    return e('div', { className: 'section' },
                        e('h2', { className: 'section-title', style: { color: '#10b981' }}, '🤝 Assist Combinations'),
                        e('div', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }},
                            e('p', null, 'No assist data found for ' + team),
                            e('p', { style: { fontSize: '12px', marginTop: '8px' }}, 'Select a team with assist data')
                        )
                    );
                }

                // Aggregate assists across all lineups for the team
                const aggregatedCombos = {};
                teamAssists.forEach(d => {
                    const key = d.Assister_Name + '|||' + d.Scorer_Name;
                    if (!aggregatedCombos[key]) {
                        aggregatedCombos[key] = {
                            Assister_Name: d.Assister_Name,
                            Scorer_Name: d.Scorer_Name,
                            Assists: 0,
                            Points_Created: 0,
                            Threes_Assisted: 0,
                            Twos_Assisted: 0,
                            Games: new Set()
                        };
                    }
                    aggregatedCombos[key].Assists += parseFloat(d.Assists) || 0;
                    aggregatedCombos[key].Points_Created += parseFloat(d.Points_Created) || 0;
                    aggregatedCombos[key].Threes_Assisted += parseFloat(d.Threes_Assisted) || 0;
                    aggregatedCombos[key].Twos_Assisted += parseFloat(d.Twos_Assisted) || 0;
                    if (d.Lineup_Key) aggregatedCombos[key].Games.add(d.Lineup_Key);
                });

                const allAssistCombos = Object.values(aggregatedCombos).map(combo => ({
                    ...combo,
                    Games: combo.Games.size || 1,
                    'AST/G': combo.Games.size > 0 ? combo.Assists / combo.Games.size : combo.Assists
                }));

                // Get unique players and calculate their stats
                const players = [...new Set([...allAssistCombos.map(d => d.Assister_Name), ...allAssistCombos.map(d => d.Scorer_Name)])].filter(p => p);
                
                const playerStats = {};
                players.forEach(p => {
                    playerStats[p] = { assists: 0, pointsCreated: 0, pointsScored: 0, received: 0, totalInvolvement: 0 };
                });
                allAssistCombos.forEach(d => {
                    if (playerStats[d.Assister_Name]) {
                        playerStats[d.Assister_Name].assists += parseFloat(d.Assists) || 0;
                        playerStats[d.Assister_Name].pointsCreated += parseFloat(d.Points_Created) || 0;
                    }
                    if (playerStats[d.Scorer_Name]) {
                        playerStats[d.Scorer_Name].pointsScored += parseFloat(d.Points_Created) || 0;
                        playerStats[d.Scorer_Name].received += parseFloat(d.Assists) || 0;
                    }
                });
                // Calculate total involvement for node sizing
                players.forEach(p => {
                    playerStats[p].totalInvolvement = playerStats[p].assists + playerStats[p].received;
                });

                // Filter connections by threshold
                const filteredCombos = allAssistCombos.filter(d => (parseFloat(d.Assists) || 0) >= assistMinThreshold);
                const maxAssists = Math.max(...allAssistCombos.map(d => parseFloat(d.Assists) || 0), 1);
                const maxInvolvement = Math.max(...players.map(p => playerStats[p].totalInvolvement), 1);

                // SVG dimensions - optimized to fit on screen while maintaining clarity
                const svgWidth = 1200;
                const svgHeight = 750;
                const centerX = svgWidth / 2;
                const centerY = svgHeight / 2;

                // === FORCE-DIRECTED LAYOUT ===
                // Sort players by total assists given (top passers on left, top scorers on right)
                const sortedByPassing = [...players].sort((a, b) => playerStats[b].assists - playerStats[a].assists);
                const sortedByScoring = [...players].sort((a, b) => playerStats[b].received - playerStats[a].received);
                
                // Create a hybrid ranking - balance passing vs scoring tendencies
                const playerRoles = {};
                players.forEach(p => {
                    const passRank = sortedByPassing.indexOf(p);
                    const scoreRank = sortedByScoring.indexOf(p);
                    const passingRatio = playerStats[p].assists / Math.max(playerStats[p].assists + playerStats[p].received, 1);
                    playerRoles[p] = {
                        passRank,
                        scoreRank,
                        passingRatio,
                        isPrimaryPasser: passingRatio > 0.6,
                        isPrimaryScorer: passingRatio < 0.4,
                        isBalanced: passingRatio >= 0.4 && passingRatio <= 0.6
                    };
                });

                // Position players in a smart two-column layout with balanced players in center
                const passers = players.filter(p => playerRoles[p].isPrimaryPasser).sort((a, b) => playerStats[b].assists - playerStats[a].assists);
                const scorers = players.filter(p => playerRoles[p].isPrimaryScorer).sort((a, b) => playerStats[b].received - playerStats[a].received);
                const balanced = players.filter(p => playerRoles[p].isBalanced).sort((a, b) => playerStats[b].totalInvolvement - playerStats[a].totalInvolvement);

                const playerPositions = {};
                // Balanced horizontal spread
                const leftX = 100;
                const rightX = svgWidth - 100;
                const centerColumnX = centerX;
                const verticalPadding = 70;

                // Position passers on left with slight horizontal stagger for line separation
                const passerSpacing = passers.length > 1 ? (svgHeight - verticalPadding * 2) / (passers.length - 1 || 1) : 0;
                passers.forEach((p, i) => {
                    const stagger = (i % 2 === 0) ? 0 : 25;
                    playerPositions[p] = {
                        x: leftX + stagger,
                        y: passers.length === 1 ? centerY : verticalPadding + i * passerSpacing
                    };
                });

                // Position scorers on right with stagger
                const scorerSpacing = scorers.length > 1 ? (svgHeight - verticalPadding * 2) / (scorers.length - 1 || 1) : 0;
                scorers.forEach((p, i) => {
                    const stagger = (i % 2 === 0) ? 0 : -25;
                    playerPositions[p] = {
                        x: rightX + stagger,
                        y: scorers.length === 1 ? centerY : verticalPadding + i * scorerSpacing
                    };
                });

                // Position balanced players in center column with wider vertical spread
                const balancedSpacing = balanced.length > 1 ? (svgHeight - verticalPadding * 2) / (balanced.length - 1 || 1) : 0;
                balanced.forEach((p, i) => {
                    // Stagger balanced players horizontally too
                    const stagger = (i % 3 === 0) ? -40 : (i % 3 === 1) ? 0 : 40;
                    playerPositions[p] = {
                        x: centerColumnX + stagger,
                        y: balanced.length === 1 ? centerY : verticalPadding + i * balancedSpacing
                    };
                });

                // Color scale for connection strength (light blue to deep purple)
                const getConnectionColor = (assists) => {
                    const ratio = assists / maxAssists;
                    if (ratio >= 0.8) return '#8b5cf6'; // Purple - elite
                    if (ratio >= 0.6) return '#6366f1'; // Indigo - very strong
                    if (ratio >= 0.4) return '#3b82f6'; // Blue - strong
                    if (ratio >= 0.2) return '#06b6d4'; // Cyan - moderate
                    return '#67e8f9'; // Light cyan - low
                };

                // Node radius based on involvement (min 22, max 40) - compact for better fit
                // Defined early so it can be used by obstruction detection
                const getNodeRadius = (player) => {
                    const stats = playerStats[player];
                    if (!stats) return 22; // Default minimum radius if no stats
                    const involvement = stats.totalInvolvement || 0;
                    return 22 + (involvement / maxInvolvement) * 18;
                };

                // Build a map of connections per player pair for better curve separation
                const connectionsByPair = {};
                filteredCombos.forEach((d, i) => {
                    const pairKey = [d.Assister_Name, d.Scorer_Name].sort().join('|||');
                    if (!connectionsByPair[pairKey]) connectionsByPair[pairKey] = [];
                    connectionsByPair[pairKey].push({ ...d, originalIndex: i });
                });

                // Helper: Check if a point is near a line segment (for node collision detection)
                const pointToSegmentDistance = (px, py, x1, y1, x2, y2) => {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const lengthSq = dx * dx + dy * dy;
                    if (lengthSq === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
                    
                    let t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSq));
                    const projX = x1 + t * dx;
                    const projY = y1 + t * dy;
                    return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
                };

                // Helper: Find nodes that would be intersected by a straight line between two points
                const findObstructingNodes = (x1, y1, x2, y2, sourcePlayer, targetPlayer) => {
                    const obstructions = [];
                    const buffer = 50; // How close counts as "in the way"
                    
                    players.forEach(p => {
                        if (p === sourcePlayer || p === targetPlayer) return;
                        const pos = playerPositions[p];
                        if (!pos) return;
                        
                        const nodeRadius = getNodeRadius(p);
                        const dist = pointToSegmentDistance(pos.x, pos.y, x1, y1, x2, y2);
                        
                        if (dist < nodeRadius + buffer) {
                            // Calculate which side of the line the node is on
                            const crossProduct = (x2 - x1) * (pos.y - y1) - (y2 - y1) * (pos.x - x1);
                            obstructions.push({
                                player: p,
                                x: pos.x,
                                y: pos.y,
                                radius: nodeRadius,
                                dist: dist,
                                side: crossProduct > 0 ? 1 : -1 // positive = left, negative = right
                            });
                        }
                    });
                    
                    return obstructions;
                };

                // Create bezier curves that arc smoothly and AVOID nodes
                const createSmoothArc = (x1, y1, x2, y2, assists, index, pairIndex, totalInPair, sourcePlayer, targetPlayer) => {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Find any nodes in the way
                    const obstructions = findObstructingNodes(x1, y1, x2, y2, sourcePlayer, targetPlayer);
                    
                    let curveAmount;
                    let forcedDirection = 0;
                    
                    if (obstructions.length > 0) {
                        // There are nodes in the way - curve around them
                        // Determine which side has more/closer obstructions and curve the opposite way
                        const leftWeight = obstructions.filter(o => o.side > 0).reduce((sum, o) => sum + (1 / o.dist), 0);
                        const rightWeight = obstructions.filter(o => o.side < 0).reduce((sum, o) => sum + (1 / o.dist), 0);
                        
                        // Curve away from the heavier side
                        forcedDirection = leftWeight > rightWeight ? -1 : 1;
                        
                        // Calculate how much we need to curve to clear the obstruction
                        const maxObstruction = Math.max(...obstructions.map(o => o.radius + 40 - o.dist));
                        curveAmount = Math.max(dist * 0.3, maxObstruction + 60) * forcedDirection;
                    } else {
                        // No obstructions - use golden angle spreading
                        const baseOffset = (index * 137.5) % 360;
                        const curveDirection = Math.sin(baseOffset * Math.PI / 180);
                        const volumeFactor = 0.7 + (assists / maxAssists) * 0.3;
                        curveAmount = Math.min(dist * 0.25, 120) * curveDirection * volumeFactor;
                    }
                    
                    // If there are bidirectional connections, offset them
                    const bidirectionalOffset = totalInPair > 1 ? (pairIndex - (totalInPair - 1) / 2) * 25 : 0;
                    
                    // Perpendicular offset for curve control point
                    const perpX = -dy / dist * (curveAmount + bidirectionalOffset);
                    const perpY = dx / dist * (curveAmount + bidirectionalOffset);
                    
                    const ctrlX = (x1 + x2) / 2 + perpX;
                    const ctrlY = (y1 + y2) / 2 + perpY;
                    
                    return { path: 'M ' + x1 + ' ' + y1 + ' Q ' + ctrlX + ' ' + ctrlY + ' ' + x2 + ' ' + y2, ctrlX, ctrlY };
                };

                // Arrow markers with different colors
                const arrowDefs = e('defs', null,
                    e('marker', { id: 'arrow-purple', markerWidth: '10', markerHeight: '8', refX: '9', refY: '4', orient: 'auto' },
                        e('polygon', { points: '0 0, 10 4, 0 8', fill: '#8b5cf6' })
                    ),
                    e('marker', { id: 'arrow-indigo', markerWidth: '10', markerHeight: '8', refX: '9', refY: '4', orient: 'auto' },
                        e('polygon', { points: '0 0, 10 4, 0 8', fill: '#6366f1' })
                    ),
                    e('marker', { id: 'arrow-blue', markerWidth: '10', markerHeight: '8', refX: '9', refY: '4', orient: 'auto' },
                        e('polygon', { points: '0 0, 10 4, 0 8', fill: '#3b82f6' })
                    ),
                    e('marker', { id: 'arrow-cyan', markerWidth: '10', markerHeight: '8', refX: '9', refY: '4', orient: 'auto' },
                        e('polygon', { points: '0 0, 10 4, 0 8', fill: '#06b6d4' })
                    ),
                    e('marker', { id: 'arrow-lightcyan', markerWidth: '10', markerHeight: '8', refX: '9', refY: '4', orient: 'auto' },
                        e('polygon', { points: '0 0, 10 4, 0 8', fill: '#67e8f9' })
                    ),
                    e('marker', { id: 'arrow-highlight', markerWidth: '12', markerHeight: '10', refX: '11', refY: '5', orient: 'auto' },
                        e('polygon', { points: '0 0, 12 5, 0 10', fill: '#fbbf24' })
                    ),
                    // Gradient for highlighted connections
                    e('linearGradient', { id: 'highlight-gradient', x1: '0%', y1: '0%', x2: '100%', y2: '0%' },
                        e('stop', { offset: '0%', stopColor: '#f59e0b' }),
                        e('stop', { offset: '100%', stopColor: '#fbbf24' })
                    )
                );

                // Get arrow marker ID based on color
                const getArrowId = (assists) => {
                    const ratio = assists / maxAssists;
                    if (ratio >= 0.8) return 'url(#arrow-purple)';
                    if (ratio >= 0.6) return 'url(#arrow-indigo)';
                    if (ratio >= 0.4) return 'url(#arrow-blue)';
                    if (ratio >= 0.2) return 'url(#arrow-cyan)';
                    return 'url(#arrow-lightcyan)';
                };

                // Create connections with improved separation
                const connections = filteredCombos.map((d, i) => {
                    const from = playerPositions[d.Assister_Name];
                    const to = playerPositions[d.Scorer_Name];
                    if (!from || !to) return null;
                    
                    const assists = parseFloat(d.Assists) || 0;
                    const color = getConnectionColor(assists);
                    const strokeWidth = Math.max(1.5, (assists / maxAssists) * 8);
                    
                    // Find pair info for bidirectional offset
                    const pairKey = [d.Assister_Name, d.Scorer_Name].sort().join('|||');
                    const pairConnections = connectionsByPair[pairKey] || [];
                    const pairIndex = pairConnections.findIndex(c => c.originalIndex === i);
                    
                    // Calculate if this connection involves hovered player
                    const isHighlighted = assistHoveredPlayer && 
                        (d.Assister_Name === assistHoveredPlayer || d.Scorer_Name === assistHoveredPlayer);
                    const isDimmed = assistHoveredPlayer && !isHighlighted;
                    
                    // Adjust endpoints for node radius
                    const fromRadius = getNodeRadius(d.Assister_Name);
                    const toRadius = getNodeRadius(d.Scorer_Name);
                    const angle = Math.atan2(to.y - from.y, to.x - from.x);
                    const fromX = from.x + fromRadius * Math.cos(angle);
                    const fromY = from.y + fromRadius * Math.sin(angle);
                    const toX = to.x - (toRadius + 8) * Math.cos(angle);
                    const toY = to.y - (toRadius + 8) * Math.sin(angle);
                    
                    const { path, ctrlX, ctrlY } = createSmoothArc(fromX, fromY, toX, toY, assists, i, pairIndex, pairConnections.length, d.Assister_Name, d.Scorer_Name);
                    
                    return e('g', { key: 'conn-' + i, style: { transition: 'opacity 0.2s' }},
                        e('path', {
                            d: path,
                            fill: 'none',
                            stroke: isHighlighted ? '#fbbf24' : color,
                            strokeWidth: isHighlighted ? strokeWidth + 2 : strokeWidth,
                            opacity: isDimmed ? 0.1 : (isHighlighted ? 1 : 0.7),
                            markerEnd: isHighlighted ? 'url(#arrow-highlight)' : getArrowId(assists),
                            style: { transition: 'all 0.2s' }
                        })
                    );
                }).filter(Boolean);

                // Create player nodes
                const nodes = players.map((p, i) => {
                    const pos = playerPositions[p];
                    if (!pos) return null;
                    
                    const stats = playerStats[p];
                    const radius = getNodeRadius(p);
                    const isHovered = p === assistHoveredPlayer;
                    const isDimmed = assistHoveredPlayer && !isHovered && 
                        !filteredCombos.some(d => 
                            (d.Assister_Name === assistHoveredPlayer && d.Scorer_Name === p) ||
                            (d.Scorer_Name === assistHoveredPlayer && d.Assister_Name === p)
                        );
                    
                    // Determine node color based on role
                    const role = playerRoles[p];
                    let fillColor, strokeColor;
                    if (role.isPrimaryPasser) {
                        fillColor = 'rgba(59, 130, 246, 0.3)';
                        strokeColor = '#3b82f6';
                    } else if (role.isPrimaryScorer) {
                        fillColor = 'rgba(16, 185, 129, 0.3)';
                        strokeColor = '#10b981';
                    } else {
                        fillColor = 'rgba(168, 85, 247, 0.3)';
                        strokeColor = '#a855f7';
                    }
                    
                    // Truncate name intelligently
                    const nameParts = p.split(' ');
                    let displayName = p;
                    if (p.length > 15) {
                        if (nameParts.length >= 2) {
                            displayName = nameParts[0].charAt(0) + '. ' + nameParts.slice(1).join(' ');
                            if (displayName.length > 15) {
                                displayName = displayName.substring(0, 13) + '...';
                            }
                        } else {
                            displayName = p.substring(0, 13) + '...';
                        }
                    }
                    
                    return e('g', { 
                        key: 'node-' + i,
                        onMouseEnter: () => setAssistHoveredPlayer(p),
                        onMouseLeave: () => setAssistHoveredPlayer(null),
                        style: { cursor: 'pointer', transition: 'opacity 0.2s' }
                    },
                        // Glow effect when hovered
                        isHovered && e('circle', {
                            cx: pos.x,
                            cy: pos.y,
                            r: radius + 6,
                            fill: 'none',
                            stroke: '#fbbf24',
                            strokeWidth: 2,
                            opacity: 0.6
                        }),
                        e('circle', {
                            cx: pos.x,
                            cy: pos.y,
                            r: radius,
                            fill: isHovered ? 'rgba(251, 191, 36, 0.3)' : fillColor,
                            stroke: isHovered ? '#fbbf24' : strokeColor,
                            strokeWidth: isHovered ? 3 : 2,
                            opacity: isDimmed ? 0.3 : 1,
                            style: { transition: 'all 0.2s' }
                        }),
                        e('text', {
                            x: pos.x,
                            y: pos.y - 6,
                            textAnchor: 'middle',
                            dominantBaseline: 'middle',
                            fill: isDimmed ? 'rgba(255,255,255,0.3)' : '#fff',
                            fontSize: radius > 35 ? '11' : '10',
                            fontWeight: 'bold',
                            style: { transition: 'all 0.2s' }
                        }, displayName),
                        e('text', {
                            x: pos.x,
                            y: pos.y + 7,
                            textAnchor: 'middle',
                            dominantBaseline: 'middle',
                            fill: isDimmed ? 'rgba(74, 222, 128, 0.3)' : '#4ade80',
                            fontSize: '10',
                            fontWeight: 'bold',
                            style: { transition: 'all 0.2s' }
                        }, stats.assists.toFixed(0) + ' ast'),
                        e('text', {
                            x: pos.x,
                            y: pos.y + 18,
                            textAnchor: 'middle',
                            dominantBaseline: 'middle',
                            fill: isDimmed ? 'rgba(251, 191, 36, 0.3)' : '#fbbf24',
                            fontSize: '9',
                            style: { transition: 'all 0.2s' }
                        }, stats.pointsCreated.toFixed(0) + ' pts')
                    );
                }).filter(Boolean);

                // Calculate filtered vs total stats
                const totalConnections = allAssistCombos.length;
                const shownConnections = filteredCombos.length;
                const maxThreshold = Math.max(...allAssistCombos.map(d => parseFloat(d.Assists) || 0));

                return e('div', { className: 'section' },
                    e('h2', { className: 'section-title', style: { color: '#10b981' }}, '🤝 Assist Combinations'),
                    
                    // Controls row
                    e('div', { style: { 
                        display: 'flex', 
                        flexWrap: 'wrap',
                        gap: '16px', 
                        alignItems: 'center', 
                        marginBottom: '20px',
                        padding: '16px',
                        background: 'rgba(16, 185, 129, 0.1)',
                        borderRadius: '10px'
                    }},
                        // Team info
                        e('div', { style: { flex: '1', minWidth: '200px' }},
                            e('div', { style: { fontSize: '13px', fontWeight: 'bold', color: '#10b981' }}, team),
                            e('div', { style: { fontSize: '11px', opacity: 0.7 }}, 
                                'Showing ' + shownConnections + ' of ' + totalConnections + ' connections'
                            )
                        ),
                        
                        // Threshold slider
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' }},
                            e('label', { style: { fontSize: '12px', fontWeight: '600', color: '#94a3b8' }}, 'Min Assists:'),
                            e('input', {
                                type: 'range',
                                min: 1,
                                max: Math.max(maxThreshold, 10),
                                value: assistMinThreshold,
                                onChange: (ev) => setAssistMinThreshold(parseInt(ev.target.value)),
                                style: { width: '120px', accentColor: '#10b981' }
                            }),
                            e('span', { style: { 
                                fontSize: '14px', 
                                fontWeight: 'bold', 
                                color: '#10b981',
                                minWidth: '30px'
                            }}, assistMinThreshold)
                        ),
                        
                        // Legend
                        e('div', { style: { display: 'flex', gap: '12px', fontSize: '11px' }},
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                e('div', { style: { width: '12px', height: '12px', borderRadius: '50%', background: '#3b82f6', border: '2px solid #3b82f6' }}),
                                e('span', { style: { color: '#94a3b8' }}, 'Passer')
                            ),
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                e('div', { style: { width: '12px', height: '12px', borderRadius: '50%', background: '#10b981', border: '2px solid #10b981' }}),
                                e('span', { style: { color: '#94a3b8' }}, 'Scorer')
                            ),
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                e('div', { style: { width: '12px', height: '12px', borderRadius: '50%', background: '#a855f7', border: '2px solid #a855f7' }}),
                                e('span', { style: { color: '#94a3b8' }}, 'Balanced')
                            )
                        )
                    ),
                    
                    // Hover instruction
                    e('div', { style: { 
                        textAlign: 'center', 
                        fontSize: '12px', 
                        color: '#64748b', 
                        marginBottom: '12px',
                        fontStyle: 'italic'
                    }}, '💡 Hover over a player to highlight their assist connections'),
                    
                    // Network Chart
                    e('div', { style: { 
                        display: 'flex', 
                        justifyContent: 'center', 
                        marginBottom: '24px',
                        overflowX: 'auto'
                    }},
                        e('svg', { 
                            width: svgWidth, 
                            height: svgHeight, 
                            style: { 
                                background: 'linear-gradient(135deg, rgba(15,23,42,0.9) 0%, rgba(30,41,59,0.9) 100%)', 
                                borderRadius: '12px',
                                border: '1px solid rgba(71, 85, 105, 0.5)',
                                maxWidth: '100%'
                            }
                        },
                            arrowDefs,
                            // Column labels
                            e('text', { x: leftX + 12, y: 30, textAnchor: 'middle', fill: '#3b82f6', fontSize: '14', fontWeight: 'bold' }, '← PASSERS'),
                            e('text', { x: rightX - 12, y: 30, textAnchor: 'middle', fill: '#10b981', fontSize: '14', fontWeight: 'bold' }, 'SCORERS →'),
                            e('text', { x: centerX, y: 30, textAnchor: 'middle', fill: '#a855f7', fontSize: '14', fontWeight: 'bold' }, 'BALANCED'),
                            // Connections first (below nodes)
                            ...connections,
                            // Then nodes (on top)
                            ...nodes
                        )
                    ),
                    
                    // Connection strength legend
                    e('div', { style: { 
                        display: 'flex', 
                        justifyContent: 'center', 
                        gap: '16px', 
                        marginBottom: '24px', 
                        fontSize: '11px',
                        flexWrap: 'wrap'
                    }},
                        e('span', { style: { color: '#64748b' }}, 'Connection Strength:'),
                        e('span', { style: { color: '#67e8f9' }}, '● Low'),
                        e('span', { style: { color: '#06b6d4' }}, '● Moderate'),
                        e('span', { style: { color: '#3b82f6' }}, '● Strong'),
                        e('span', { style: { color: '#6366f1' }}, '● Very Strong'),
                        e('span', { style: { color: '#8b5cf6' }}, '● Elite')
                    ),
                    
                    // Hovered player details card
                    assistHoveredPlayer && e('div', { style: {
                        background: 'rgba(251, 191, 36, 0.1)',
                        border: '1px solid rgba(251, 191, 36, 0.3)',
                        borderRadius: '10px',
                        padding: '16px',
                        marginBottom: '20px'
                    }},
                        e('h4', { style: { color: '#fbbf24', marginBottom: '12px', fontSize: '14px' }}, 
                            '🎯 ' + assistHoveredPlayer + ' Connections'),
                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: '12px' }},
                            // Assists given by this player
                            e('div', null,
                                e('div', { style: { fontSize: '11px', color: '#4ade80', marginBottom: '6px', fontWeight: 'bold' }}, 
                                    '→ Assists Given (' + playerStats[assistHoveredPlayer].assists.toFixed(0) + ' total)'),
                                ...filteredCombos
                                    .filter(d => d.Assister_Name === assistHoveredPlayer)
                                    .sort((a, b) => b.Assists - a.Assists)
                                    .slice(0, 5)
                                    .map((d, i) => e('div', { 
                                        key: i, 
                                        style: { 
                                            fontSize: '11px', 
                                            padding: '4px 8px',
                                            background: 'rgba(74, 222, 128, 0.1)',
                                            borderRadius: '4px',
                                            marginBottom: '4px'
                                        }
                                    }, 'To ' + d.Scorer_Name + ': ' + d.Assists.toFixed(0) + ' ast → ' + d.Points_Created.toFixed(0) + ' pts'))
                            ),
                            // Assists received by this player
                            e('div', null,
                                e('div', { style: { fontSize: '11px', color: '#fbbf24', marginBottom: '6px', fontWeight: 'bold' }}, 
                                    '← Assists Received (' + playerStats[assistHoveredPlayer].received.toFixed(0) + ' total)'),
                                ...filteredCombos
                                    .filter(d => d.Scorer_Name === assistHoveredPlayer)
                                    .sort((a, b) => b.Assists - a.Assists)
                                    .slice(0, 5)
                                    .map((d, i) => e('div', { 
                                        key: i, 
                                        style: { 
                                            fontSize: '11px', 
                                            padding: '4px 8px',
                                            background: 'rgba(251, 191, 36, 0.1)',
                                            borderRadius: '4px',
                                            marginBottom: '4px'
                                        }
                                    }, 'From ' + d.Assister_Name + ': ' + d.Assists.toFixed(0) + ' ast → ' + d.Points_Created.toFixed(0) + ' pts'))
                            )
                        )
                    ),
                    
                    // Data Table
                    e('h3', { style: { marginTop: '24px', marginBottom: '12px', fontSize: '16px' }}, '📋 Assist Details'),
                    e('div', { style: { overflowX: 'auto' }},
                        e('table', { style: { width: '100%', borderCollapse: 'collapse', fontSize: '12px' }},
                            e('thead', null,
                                e('tr', { style: { background: 'rgba(16, 185, 129, 0.2)' }},
                                    e('th', { style: { padding: '10px', textAlign: 'left', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'Passer'),
                                    e('th', { style: { padding: '10px', textAlign: 'left', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'Scorer'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'AST'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'PTS Created'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, '3s'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, '2s'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'Lineups'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'AST/Lineup')
                                )
                            ),
                            e('tbody', null,
                                ...allAssistCombos.sort((a, b) => (parseFloat(b.Assists) || 0) - (parseFloat(a.Assists) || 0)).map((d, i) => {
                                    const isHighlighted = assistHoveredPlayer && 
                                        (d.Assister_Name === assistHoveredPlayer || d.Scorer_Name === assistHoveredPlayer);
                                    const meetsThreshold = (parseFloat(d.Assists) || 0) >= assistMinThreshold;
                                    
                                    return e('tr', { 
                                        key: i, 
                                        style: { 
                                            background: isHighlighted ? 'rgba(251, 191, 36, 0.2)' : (i % 2 === 0 ? 'rgba(0,0,0,0.1)' : 'transparent'),
                                            opacity: meetsThreshold ? 1 : 0.4,
                                            transition: 'all 0.2s'
                                        },
                                        onMouseEnter: () => setAssistHoveredPlayer(d.Assister_Name),
                                        onMouseLeave: () => setAssistHoveredPlayer(null)
                                    },
                                        e('td', { style: { padding: '8px 10px', borderBottom: '1px solid rgba(255,255,255,0.05)', color: '#3b82f6' }}, d.Assister_Name),
                                        e('td', { style: { padding: '8px 10px', borderBottom: '1px solid rgba(255,255,255,0.05)', color: '#10b981' }}, d.Scorer_Name),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)', fontWeight: 'bold', color: '#4ade80' }}, parseFloat(d.Assists || 0).toFixed(0)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)', fontWeight: 'bold', color: '#fbbf24' }}, parseFloat(d.Points_Created || 0).toFixed(0)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)' }}, parseFloat(d.Threes_Assisted || 0).toFixed(0)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)' }}, parseFloat(d.Twos_Assisted || 0).toFixed(0)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)' }}, parseFloat(d.Games || 0).toFixed(0)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)' }}, parseFloat(d['AST/G'] || 0).toFixed(2))
                                    );
                                })
                            )
                        )
                    )
                );
            };

            // =======================================================================
            // CLUTCH TAB - Clutch time performance with Four Factors
            // =======================================================================
            const ClutchTab = () => {
                if (!clutchData.length) {
                    return e('div', { className: 'section' },
                        e('h2', { className: 'section-title', style: { color: '#ef4444' }}, '⏱️ Clutch Performance'),
                        e('div', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }},
                            e('div', { style: { fontSize: '48px', marginBottom: '16px' }}, '📤'),
                            e('p', null, 'Upload Clutch Stats CSV to view clutch performance'),
                            e('p', { style: { fontSize: '12px', marginTop: '8px' }}, 'Required columns: Team, Lineup, Clutch_Minutes, PTS, POSS, OFF_RTG, DEF_RTG, NET_RTG, FG%, 3P%, FT%, TOV, OREB, DREB')
                        )
                    );
                }

                // Calculate LEAGUE-WIDE clutch averages for percentile comparisons
                const allTeamsClutch = {};
                clutchData.forEach(d => {
                    const teamName = d.Team;
                    if (!teamName) return;
                    if (!allTeamsClutch[teamName]) {
                        allTeamsClutch[teamName] = { minutes: 0, pts: 0, ptsAllowed: 0, poss: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, tov: 0 };
                    }
                    const t = allTeamsClutch[teamName];
                    t.minutes += parseFloat(d.Clutch_Minutes) || 0;
                    t.pts += parseFloat(d.PTS) || 0;
                    t.ptsAllowed += parseFloat(d.PTS_ALLOWED) || 0;
                    t.poss += parseFloat(d.POSS) || 0;
                    t.fgm += parseFloat(d.FGM) || 0;
                    t.fga += parseFloat(d.FGA) || 0;
                    t.tpm += parseFloat(d['3PM']) || 0;
                    t.tpa += parseFloat(d['3PA']) || 0;
                    t.ftm += parseFloat(d.FTM) || 0;
                    t.fta += parseFloat(d.FTA) || 0;
                    t.tov += parseFloat(d.TOV) || 0;
                });
                
                // Calculate per-team clutch ratings for percentiles
                // V4.9.8.7.31 FIX: Use Basketball Reference TOV% formula for consistency
                const leagueClutchStats = Object.entries(allTeamsClutch).map(([teamName, t]) => {
                    const tovDenom = t.fga + 0.44 * t.fta + t.tov;
                    return {
                        team: teamName,
                        offRtg: t.poss > 0 ? (t.pts / t.poss) * 100 : 0,
                        defRtg: t.poss > 0 ? (t.ptsAllowed / t.poss) * 100 : 0,
                        netRtg: t.poss > 0 ? ((t.pts - t.ptsAllowed) / t.poss) * 100 : 0,
                        efg: t.fga > 0 ? ((t.fgm + 0.5 * t.tpm) / t.fga) * 100 : 0,
                        tovPct: tovDenom > 0 ? (t.tov / tovDenom) * 100 : 0,
                        ftRate: t.fga > 0 ? (t.fta / t.fga) * 100 : 0,
                        fgPct: t.fga > 0 ? (t.fgm / t.fga) * 100 : 0,
                        tpPct: t.tpa > 0 ? (t.tpm / t.tpa) * 100 : 0,
                        ftPct: t.fta > 0 ? (t.ftm / t.fta) * 100 : 0
                    };
                });
                
                // Helper to calculate percentile for clutch stats
                const calcClutchPct = (val, arr, higherBetter) => {
                    if (!arr || arr.length === 0) return 50;
                    const sorted = [...arr].sort((a, b) => a - b);
                    let rank = sorted.filter(v => v < val).length;
                    const pct = (rank / sorted.length) * 100;
                    return higherBetter ? pct : 100 - pct;
                };
                
                // Get arrays for percentile calculations
                const clutchArrays = {
                    offRtg: leagueClutchStats.map(t => t.offRtg),
                    defRtg: leagueClutchStats.map(t => t.defRtg),
                    netRtg: leagueClutchStats.map(t => t.netRtg),
                    efg: leagueClutchStats.map(t => t.efg),
                    tovPct: leagueClutchStats.map(t => t.tovPct),
                    ftRate: leagueClutchStats.map(t => t.ftRate),
                    fgPct: leagueClutchStats.map(t => t.fgPct),
                    tpPct: leagueClutchStats.map(t => t.tpPct),
                    ftPct: leagueClutchStats.map(t => t.ftPct)
                };

                // Get current lineup key from selected players
                const selPlayerNames = Object.values(selPlayers).filter(p => p);
                
                // Filter clutch data for current team (or selected lineup if applicable)
                const teamClutchData = clutchData.filter(d => d.Team === team);
                
                if (teamClutchData.length === 0) {
                    return e('div', { className: 'section' },
                        e('h2', { className: 'section-title', style: { color: '#ef4444' }}, '⏱️ Clutch Performance'),
                        e('div', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }},
                            e('p', null, 'No clutch data found for ' + team)
                        )
                    );
                }

                // Calculate team-wide clutch aggregates
                const teamTotals = teamClutchData.reduce((acc, d) => {
                    acc.minutes += parseFloat(d.Clutch_Minutes) || 0;
                    acc.seconds += parseFloat(d.Clutch_Seconds) || 0;
                    acc.pts += parseFloat(d.PTS) || 0;
                    acc.ptsAllowed += parseFloat(d.PTS_ALLOWED) || 0;
                    acc.poss += parseFloat(d.POSS) || 0;
                    acc.fgm += parseFloat(d.FGM) || 0;
                    acc.fga += parseFloat(d.FGA) || 0;
                    acc.tpm += parseFloat(d['3PM']) || 0;
                    acc.tpa += parseFloat(d['3PA']) || 0;
                    acc.ftm += parseFloat(d.FTM) || 0;
                    acc.fta += parseFloat(d.FTA) || 0;
                    acc.oreb += parseFloat(d.OREB) || 0;
                    acc.dreb += parseFloat(d.DREB) || 0;
                    acc.ast += parseFloat(d.AST) || 0;
                    acc.stl += parseFloat(d.STL) || 0;
                    acc.blk += parseFloat(d.BLK) || 0;
                    acc.tov += parseFloat(d.TOV) || 0;
                    acc.games = Math.max(acc.games, parseFloat(d.Games) || 0);
                    return acc;
                }, { minutes: 0, seconds: 0, pts: 0, ptsAllowed: 0, poss: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, games: 0 });

                // Calculate team clutch ratings and four factors
                // V4.9.8.7.31 FIX: Use Basketball Reference TOV% formula for consistency
                const teamTovDenom = teamTotals.fga + 0.44 * teamTotals.fta + teamTotals.tov;
                const teamOffRtg = teamTotals.poss > 0 ? (teamTotals.pts / teamTotals.poss) * 100 : 0;
                const teamDefRtg = teamTotals.poss > 0 ? (teamTotals.ptsAllowed / teamTotals.poss) * 100 : 0;
                const teamNetRtg = teamOffRtg - teamDefRtg;
                const teamEfg = teamTotals.fga > 0 ? ((teamTotals.fgm + 0.5 * teamTotals.tpm) / teamTotals.fga) * 100 : 0;
                const teamTovPct = teamTovDenom > 0 ? (teamTotals.tov / teamTovDenom) * 100 : 0;
                const teamOrebPct = (teamTotals.oreb + teamTotals.dreb) > 0 ? (teamTotals.oreb / (teamTotals.oreb + teamTotals.dreb)) * 100 : 0;
                const teamFtRate = teamTotals.fga > 0 ? (teamTotals.fta / teamTotals.fga) * 100 : 0;
                const teamFgPct = teamTotals.fga > 0 ? (teamTotals.fgm / teamTotals.fga) * 100 : 0;
                const teamTpPct = teamTotals.tpa > 0 ? (teamTotals.tpm / teamTotals.tpa) * 100 : 0;
                const teamFtPct = teamTotals.fta > 0 ? (teamTotals.ftm / teamTotals.fta) * 100 : 0;
                
                // Calculate clutch percentiles for team
                const clutchPcts = {
                    offRtg: calcClutchPct(teamOffRtg, clutchArrays.offRtg, true),
                    defRtg: calcClutchPct(teamDefRtg, clutchArrays.defRtg, false),
                    netRtg: calcClutchPct(teamNetRtg, clutchArrays.netRtg, true),
                    efg: calcClutchPct(teamEfg, clutchArrays.efg, true),
                    tovPct: calcClutchPct(teamTovPct, clutchArrays.tovPct, false),
                    ftRate: calcClutchPct(teamFtRate, clutchArrays.ftRate, true),
                    fgPct: calcClutchPct(teamFgPct, clutchArrays.fgPct, true),
                    tpPct: calcClutchPct(teamTpPct, clutchArrays.tpPct, true),
                    ftPct: calcClutchPct(teamFtPct, clutchArrays.ftPct, true)
                };

                // If players are selected, find matching lineup
                let selectedLineupData = null;
                if (selPlayerNames.length > 0) {
                    selectedLineupData = teamClutchData.find(d => {
                        // V6.1: Apply merge rules for matching
                        const lineupPlayers = (d.Lineup || '').split(',').map(n => applyGlobalPlayerMerge(n.trim()).toLowerCase());
                        const selectedLower = selPlayerNames.map(n => applyGlobalPlayerMerge(n).toLowerCase());
                        return selectedLower.every(sp => lineupPlayers.some(lp => lp.includes(sp) || sp.includes(lp)));
                    });
                }

                // Use selected lineup if available, otherwise use team totals
                // V4.9.8.7.31 FIX: Use Basketball Reference TOV% formula for consistency
                const selectedLineupTovDenom = (parseFloat(selectedLineupData?.FGA) || 0) + 0.44 * (parseFloat(selectedLineupData?.FTA) || 0) + (parseFloat(selectedLineupData?.TOV) || 0);
                const displayData = selectedLineupData ? {
                    minutes: parseFloat(selectedLineupData.Clutch_Minutes) || 0,
                    poss: parseFloat(selectedLineupData.POSS) || 0,
                    offRtg: parseFloat(selectedLineupData.OFF_RTG) || 0,
                    defRtg: parseFloat(selectedLineupData.DEF_RTG) || 0,
                    netRtg: parseFloat(selectedLineupData.NET_RTG) || 0,
                    fgPct: parseFloat(selectedLineupData['FG%']) || 0,
                    tpPct: parseFloat(selectedLineupData['3P%']) || 0,
                    ftPct: parseFloat(selectedLineupData['FT%']) || 0,
                    efg: (parseFloat(selectedLineupData['FG%']) || 0) + 0.5 * (parseFloat(selectedLineupData['3P%']) || 0) * (parseFloat(selectedLineupData['3PA']) || 0) / Math.max(1, parseFloat(selectedLineupData.FGA) || 1),
                    tovPct: selectedLineupTovDenom > 0 ? (parseFloat(selectedLineupData.TOV) || 0) / selectedLineupTovDenom * 100 : 0,
                    orebPct: teamOrebPct, // Approximate
                    ftRate: (parseFloat(selectedLineupData.FGA) || 0) > 0 ? (parseFloat(selectedLineupData.FTA) || 0) / (parseFloat(selectedLineupData.FGA) || 1) * 100 : 0,
                    pts: parseFloat(selectedLineupData.PTS) || 0,
                    ptsAllowed: parseFloat(selectedLineupData.PTS_ALLOWED) || 0,
                    games: parseFloat(selectedLineupData.Games) || 0,
                    isLineup: true
                } : {
                    minutes: teamTotals.minutes,
                    poss: teamTotals.poss,
                    offRtg: teamOffRtg,
                    defRtg: teamDefRtg,
                    netRtg: teamNetRtg,
                    fgPct: teamTotals.fga > 0 ? (teamTotals.fgm / teamTotals.fga) * 100 : 0,
                    tpPct: teamTotals.tpa > 0 ? (teamTotals.tpm / teamTotals.tpa) * 100 : 0,
                    ftPct: teamTotals.fta > 0 ? (teamTotals.ftm / teamTotals.fta) * 100 : 0,
                    efg: teamEfg,
                    tovPct: teamTovPct,
                    orebPct: teamOrebPct,
                    ftRate: teamFtRate,
                    pts: teamTotals.pts,
                    ptsAllowed: teamTotals.ptsAllowed,
                    games: teamTotals.games,
                    isLineup: false
                };

                // Helper for color coding vs team average
                const getComparisonStyle = (val, teamVal, higherBetter = true) => {
                    const diff = val - teamVal;
                    const isGood = higherBetter ? diff > 0 : diff < 0;
                    const isBad = higherBetter ? diff < 0 : diff > 0;
                    if (Math.abs(diff) < 0.5) return { color: '#94a3b8', bg: 'rgba(148, 163, 184, 0.2)' };
                    if (isGood) return { color: '#4ade80', bg: 'rgba(34, 197, 94, 0.2)' };
                    return { color: '#f87171', bg: 'rgba(239, 68, 68, 0.2)' };
                };
                
                // Clutch percentile badge component
                const ClutchPct = ({ val }) => e('span', { className: 'pct-box ' + getPctClass(val) + ' pct-yours' },
                    e('span', { className: 'pct-box-label', style: { color: '#60a5fa' }}, 'YOU'),
                    Math.round(val) + 'th'
                );
                
                // Clutch stat with context (like StatWithContext but for clutch)
                const ClutchStatWithContext = ({ val, pct, teamAvgVal, higherBetter = true, suffix = '', leagueKey }) => {
                    const delta = val - teamAvgVal;
                    const isGood = higherBetter ? delta > 0 : delta < 0;
                    const deltaClass = Math.abs(delta) < 0.5 ? 'team-avg-same' : isGood ? 'team-avg-better' : 'team-avg-worse';
                    const arrowIcon = Math.abs(delta) < 0.5 ? '―' : isGood ? '▲' : '▼';
                    
                    // Relative to league display
                    let relativeVal = null;
                    if (showRelativeToLeague && leagueAverages && leagueKey) {
                        const leagueAvg = leagueAverages[leagueKey] || 0;
                        const relDiff = val - leagueAvg;
                        relativeVal = (relDiff >= 0 ? '+' : '') + relDiff.toFixed(1);
                    }
                    
                    return e('div', { style: { display: 'flex', flexDirection: 'column' }},
                        e('div', { className: 'stat-row' },
                            showRelativeToLeague && relativeVal ?
                                e('span', { style: { fontSize: '24px', fontWeight: 'bold', color: parseFloat(relativeVal) > 0 ? (higherBetter ? '#4ade80' : '#f87171') : parseFloat(relativeVal) < 0 ? (higherBetter ? '#f87171' : '#4ade80') : '#94a3b8' }}, relativeVal + suffix) :
                                e('span', { style: { fontSize: '24px', fontWeight: 'bold' }}, val.toFixed(1) + suffix),
                            e(ClutchPct, { val: pct })
                        ),
                        showRelativeToLeague && relativeVal && e('div', { style: { fontSize: '10px', color: '#64748b' }}, 'Raw: ' + val.toFixed(1) + suffix),
                        e('div', { className: 'inline-team-avg' },
                            e('span', { className: 'inline-team-avg-label' }, '📊 Team:'),
                            e('span', { className: 'inline-team-avg-value' }, teamAvgVal.toFixed(1) + suffix),
                            e('span', { className: 'inline-team-avg-delta ' + deltaClass }, 
                                arrowIcon + ' ' + (delta >= 0 ? '+' : '') + delta.toFixed(1)
                            )
                        )
                    );
                };

                return e('div', { className: 'section' },
                    e('h2', { className: 'section-title', style: { color: '#ef4444' }}, '⏱️ Clutch Performance',
                        showRelativeToLeague && e('span', { style: { fontSize: '11px', marginLeft: '8px', padding: '2px 6px', background: 'rgba(34, 197, 94, 0.2)', borderRadius: '4px', color: '#4ade80' }}, 'vs League Avg')
                    ),
                    displayData.isLineup && e('div', { style: { marginBottom: '16px', padding: '8px 12px', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '6px', fontSize: '12px' }},
                        'Showing: ', e('span', { style: { fontWeight: 'bold' }}, selPlayerNames.join(', '))
                    ),
                    !displayData.isLineup && e('div', { style: { marginBottom: '16px', padding: '8px 12px', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '6px', fontSize: '12px' }},
                        'Showing: ', e('span', { style: { fontWeight: 'bold' }}, team + ' (Team Totals)'),
                        ' | Percentiles compare to all ', leagueClutchStats.length, ' teams in clutch'
                    ),
                    
                    // Top Stats Row - with percentile styling
                    e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(5, 1fr)', gap: '12px', marginBottom: '24px' }},
                        e('div', { style: { background: 'rgba(168, 85, 247, 0.15)', padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                            e('div', { style: { fontSize: '11px', opacity: 0.8, marginBottom: '4px' }}, 'Minutes'),
                            e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#a78bfa' }}, displayData.minutes.toFixed(1))
                        ),
                        e('div', { style: { background: 'rgba(168, 85, 247, 0.15)', padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                            e('div', { style: { fontSize: '11px', opacity: 0.8, marginBottom: '4px' }}, 'Possessions'),
                            e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#a78bfa' }}, Math.round(displayData.poss))
                        ),
                        e('div', { className: getPerfFromPct(clutchPcts.offRtg), style: { padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                            e('div', { style: { fontSize: '11px', opacity: 0.8, marginBottom: '4px' }}, 'Off Rtg'),
                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px' }},
                                e('span', { style: { fontSize: '28px', fontWeight: 'bold' }}, displayData.offRtg.toFixed(1)),
                                e(ClutchPct, { val: clutchPcts.offRtg })
                            )
                        ),
                        e('div', { className: getPerfFromPct(clutchPcts.defRtg), style: { padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                            e('div', { style: { fontSize: '11px', opacity: 0.8, marginBottom: '4px' }}, 'Def Rtg'),
                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px' }},
                                e('span', { style: { fontSize: '28px', fontWeight: 'bold' }}, displayData.defRtg.toFixed(1)),
                                e(ClutchPct, { val: clutchPcts.defRtg })
                            )
                        ),
                        e('div', { className: getPerfFromPct(clutchPcts.netRtg), style: { padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                            e('div', { style: { fontSize: '11px', opacity: 0.8, marginBottom: '4px' }}, 'Net Rtg'),
                            e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px' }},
                                e('span', { style: { fontSize: '28px', fontWeight: 'bold' }}, (displayData.netRtg >= 0 ? '+' : '') + displayData.netRtg.toFixed(1)),
                                e(ClutchPct, { val: clutchPcts.netRtg })
                            )
                        )
                    ),
                    
                    // Four Factors Section with percentiles
                    e('div', { className: 'clutch-scroll-wrapper' },
                    e('div', { className: 'clutch-off-shoot-grid', style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '24px', marginTop: '16px' }},
                        // Offensive Four Factors
                        e('div', { style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '8px', padding: '16px' }},
                            e('h3', { style: { color: '#4ade80', marginBottom: '12px' }}, 'Offensive (Clutch)'),
                            e('div', { className: 'clutch-inner-stats-grid', style: { display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '12px' }},
                                e('div', { className: getPerfFromPct(clutchPcts.efg), style: { padding: '8px', borderRadius: '6px' }},
                                    e('div', { className: 'text-xs' }, 'eFG%'),
                                    e(ClutchStatWithContext, { val: displayData.efg, pct: clutchPcts.efg, teamAvgVal: teamEfg, higherBetter: true, suffix: '%', leagueKey: 'offEfg' })
                                ),
                                e('div', { className: getPerfFromPct(clutchPcts.tovPct), style: { padding: '8px', borderRadius: '6px' }},
                                    e('div', { className: 'text-xs' }, 'TOV%'),
                                    e(ClutchStatWithContext, { val: displayData.tovPct, pct: clutchPcts.tovPct, teamAvgVal: teamTovPct, higherBetter: false, suffix: '%', leagueKey: 'offTov' })
                                ),
                                e('div', { className: getPerfFromPct(clutchPcts.ftRate), style: { padding: '8px', borderRadius: '6px' }},
                                    e('div', { className: 'text-xs' }, 'FT Rate'),
                                    e(ClutchStatWithContext, { val: displayData.ftRate, pct: clutchPcts.ftRate, teamAvgVal: teamFtRate, higherBetter: true, suffix: '%', leagueKey: 'offFtR' })
                                )
                            )
                        ),
                        // Shooting Breakdown with percentiles
                        e('div', { style: { background: 'rgba(59, 130, 246, 0.1)', border: '1px solid rgba(59, 130, 246, 0.3)', borderRadius: '8px', padding: '16px' }},
                            e('h3', { style: { color: '#60a5fa', marginBottom: '12px' }}, 'Shooting (Clutch)'),
                            e('div', { className: 'clutch-inner-stats-grid', style: { display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '12px' }},
                                e('div', { className: getPerfFromPct(clutchPcts.fgPct), style: { padding: '8px', borderRadius: '6px' }},
                                    e('div', { className: 'text-xs' }, 'FG%'),
                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                        e('span', { style: { fontSize: '24px', fontWeight: 'bold' }}, displayData.fgPct.toFixed(1) + '%'),
                                        e(ClutchPct, { val: clutchPcts.fgPct })
                                    )
                                ),
                                e('div', { className: getPerfFromPct(clutchPcts.tpPct), style: { padding: '8px', borderRadius: '6px' }},
                                    e('div', { className: 'text-xs' }, '3P%'),
                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                        e('span', { style: { fontSize: '24px', fontWeight: 'bold' }}, displayData.tpPct.toFixed(1) + '%'),
                                        e(ClutchPct, { val: clutchPcts.tpPct })
                                    )
                                ),
                                e('div', { className: getPerfFromPct(clutchPcts.ftPct), style: { padding: '8px', borderRadius: '6px' }},
                                    e('div', { className: 'text-xs' }, 'FT%'),
                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                        e('span', { style: { fontSize: '24px', fontWeight: 'bold' }}, displayData.ftPct.toFixed(1) + '%'),
                                        e(ClutchPct, { val: clutchPcts.ftPct })
                                    )
                                )
                            )
                        )
                    )
                    ), // close clutch-scroll-wrapper

                    // Clutch Lineups Table
                    e('h3', { style: { marginTop: '24px', marginBottom: '12px', fontSize: '16px' }}, '📋 Clutch Lineup Details'),
                    e('div', { style: { overflowX: 'auto' }},
                        e('table', { style: { width: '100%', borderCollapse: 'collapse', fontSize: '11px' }},
                            e('thead', null,
                                e('tr', { style: { background: 'rgba(239, 68, 68, 0.2)' }},
                                    e('th', { style: { padding: '10px', textAlign: 'left', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'Lineup'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'G'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'MIN'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'POSS'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'OFF'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'DEF'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'NET'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, 'PTS'),
                                    e('th', { style: { padding: '10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.1)' }}, '+/-')
                                )
                            ),
                            e('tbody', null,
                                ...teamClutchData.sort((a, b) => (parseFloat(b.Clutch_Minutes) || 0) - (parseFloat(a.Clutch_Minutes) || 0)).slice(0, 20).map((d, i) => {
                                    const netRtg = parseFloat(d.NET_RTG) || 0;
                                    const diff = parseFloat(d.DIFF) || 0;
                                    return e('tr', { key: i, style: { background: i % 2 === 0 ? 'rgba(0,0,0,0.1)' : 'transparent' }},
                                        e('td', { style: { padding: '8px 10px', borderBottom: '1px solid rgba(255,255,255,0.05)', maxWidth: '300px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}, d.Lineup),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)' }}, parseFloat(d.Games || 0).toFixed(0)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)' }}, parseFloat(d.Clutch_Minutes || 0).toFixed(1)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)' }}, parseFloat(d.POSS || 0).toFixed(1)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)', fontWeight: 'bold', color: '#4ade80' }}, parseFloat(d.OFF_RTG || 0).toFixed(1)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)', fontWeight: 'bold', color: '#f87171' }}, parseFloat(d.DEF_RTG || 0).toFixed(1)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)', fontWeight: 'bold', color: netRtg >= 0 ? '#4ade80' : '#f87171' }}, (netRtg >= 0 ? '+' : '') + netRtg.toFixed(1)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)' }}, parseFloat(d.PTS || 0).toFixed(0)),
                                        e('td', { style: { padding: '8px 10px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)', fontWeight: 'bold', color: diff >= 0 ? '#4ade80' : '#f87171' }}, (diff >= 0 ? '+' : '') + diff.toFixed(0))
                                    );
                                })
                            )
                        )
                    )
                );
            };

            // =======================================================================
            // VS. STARTERS TAB - V6.7: Performance vs opponent's starting lineup
            // Dynamically identifies "regular starters" = players who started 3+ games
            // VS Starters = lineups with 4+ regular starters on court
            // Shows OFF RTG, DEF RTG, NET RTG and Four Factors for vs starters splits
            // =======================================================================
            const VsStartersTab = () => {
                // State for minimum games started threshold
                const [minGamesStarted, setMinGamesStarted] = React.useState(3);

                if (!stintsData.length) {
                    return e('div', { className: 'section' },
                        e('h2', { className: 'section-title', style: { color: '#06b6d4' }}, '🎯 VS. Starters Performance'),
                        e('div', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }},
                            e('div', { style: { fontSize: '48px', marginBottom: '16px' }}, '📤'),
                            e('p', null, 'Upload Stints CSV to view VS. Starters performance'),
                            e('p', { style: { fontSize: '12px', marginTop: '8px' }}, 'Required: stints.csv with game_id, period, start_time columns')
                        )
                    );
                }

                // ========================================================================
                // STEP 1: Identify regular starters AND per-game starters for each team
                // Regular starters = players who started 3+ games
                // Per-game starters = the 5 players who started THAT specific game
                // ========================================================================
                const starterAnalysis = useMemo(() => {
                    // Track games started per player per team
                    const playerGamesStarted = {}; // { teamName: { playerName: gamesStartedCount } }
                    // Track per-game starters: { gameId|teamName: Set of player names }
                    const gameStarters = {};

                    // Group stints by game_id and team
                    const gameTeamStints = {};
                    stintsData.forEach(s => {
                        const gameId = s.game_id;
                        if (!gameId) return;

                        ['home', 'away'].forEach(side => {
                            const teamName = s[side + '_team'];
                            if (!teamName) return;

                            const key = gameId + '|' + teamName;
                            if (!gameTeamStints[key]) {
                                gameTeamStints[key] = { team: teamName, gameId: gameId, stints: [] };
                            }
                            gameTeamStints[key].stints.push(s);
                        });
                    });

                    // For each game-team, find the opening lineup (period 1, earliest start_time)
                    Object.entries(gameTeamStints).forEach(([key, { team, gameId, stints }]) => {
                        // Filter to period 1 stints
                        const p1Stints = stints.filter(s => parseInt(s.period) === 1);
                        if (p1Stints.length === 0) return;

                        // Find the earliest start_time (should be 0 or close to it)
                        const minStartTime = Math.min(...p1Stints.map(s => parseFloat(s.start_time) || 0));
                        const openingStint = p1Stints.find(s => (parseFloat(s.start_time) || 0) === minStartTime);
                        if (!openingStint) return;

                        // Get the lineup for this team
                        const isHome = openingStint.home_team === team;
                        const lineupStr = isHome ? openingStint.home_lineup : openingStint.away_lineup;
                        if (!lineupStr) return;

                        const players = lineupStr.split(',').map(p => applyGlobalPlayerMerge(p.trim()));

                        // Store per-game starters (for game-by-game analysis)
                        gameStarters[key] = new Set(players.map(p => p.toLowerCase()));

                        // Count this as a game started for each player (for regular starters)
                        if (!playerGamesStarted[team]) {
                            playerGamesStarted[team] = {};
                        }
                        players.forEach(player => {
                            if (!player) return;
                            playerGamesStarted[team][player] = (playerGamesStarted[team][player] || 0) + 1;
                        });
                    });

                    // Now identify "regular starters" = players with minGamesStarted+ starts
                    const regularStarters = {};
                    Object.entries(playerGamesStarted).forEach(([teamName, players]) => {
                        regularStarters[teamName] = new Set(
                            Object.entries(players)
                                .filter(([_, count]) => count >= minGamesStarted)
                                .map(([player, _]) => player.toLowerCase())
                        );
                    });

                    return { regularStarters, playerGamesStarted, gameStarters };
                }, [stintsData, minGamesStarted, applyGlobalPlayerMerge]);

                const { regularStarters, playerGamesStarted, gameStarters } = starterAnalysis;

                // Get current lineup key from selected players
                const selPlayerNames = Object.values(selPlayers).filter(p => p);
                const isTeamWideMode = selPlayerNames.length === 0;

                // Filter stints for current team
                const teamStints = stintsData.filter(s => s.home_team === team || s.away_team === team);

                if (teamStints.length === 0) {
                    return e('div', { className: 'section' },
                        e('h2', { className: 'section-title', style: { color: '#06b6d4' }}, '🎯 VS. Starters Performance'),
                        e('div', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }},
                            e('p', null, 'No stints data found for ' + team)
                        )
                    );
                }

                // Show current team's regular starters
                const teamRegularStarters = regularStarters[team] || new Set();
                const teamStarterCounts = playerGamesStarted[team] || {};

                // ========================================================================
                // STEP 2: Helpers to check starter counts
                // ========================================================================

                // Count how many REGULAR starters (season-wide, 3+ games started) are in a lineup
                const countRegularStartersInLineup = (lineupStr, oppTeam) => {
                    if (!lineupStr || !oppTeam) return 0;
                    const oppStarters = regularStarters[oppTeam] || new Set();
                    if (oppStarters.size === 0) return 0;

                    const players = lineupStr.split(',').map(p => applyGlobalPlayerMerge(p.trim()).toLowerCase());
                    return players.filter(p => oppStarters.has(p)).length;
                };

                // Count how many GAME starters (that specific game's starting 5) are in a lineup
                const countGameStartersInLineup = (lineupStr, oppTeam, gameId) => {
                    if (!lineupStr || !oppTeam || !gameId) return 0;
                    const gameKey = gameId + '|' + oppTeam;
                    const gameStarterSet = gameStarters[gameKey];
                    if (!gameStarterSet || gameStarterSet.size === 0) return 0;

                    const players = lineupStr.split(',').map(p => applyGlobalPlayerMerge(p.trim()).toLowerCase());
                    return players.filter(p => gameStarterSet.has(p)).length;
                };

                // Aggregate stats for team (vs starters vs non-starters)
                const aggregateStintStats = (stints, filterFn) => {
                    const filtered = stints.filter(filterFn);
                    if (filtered.length === 0) return null;

                    const totals = filtered.reduce((acc, s) => {
                        const isHome = s.home_team === team;
                        const prefix = isHome ? 'home_' : 'away_';
                        const oppPrefix = isHome ? 'away_' : 'home_';

                        acc.duration += parseFloat(s.duration) || 0;
                        acc.possessions += parseFloat(s.possessions) || 0;
                        acc.pts += parseFloat(s[prefix + 'points']) || 0;
                        acc.ptsAllowed += parseFloat(s[oppPrefix + 'points']) || 0;
                        acc.fgm += parseFloat(s[prefix + 'fgm']) || 0;
                        acc.fga += parseFloat(s[prefix + 'fga']) || 0;
                        acc.fg3m += parseFloat(s[prefix + 'fg3m']) || 0;
                        acc.fg3a += parseFloat(s[prefix + 'fg3a']) || 0;
                        acc.ftm += parseFloat(s[prefix + 'ftm']) || 0;
                        acc.fta += parseFloat(s[prefix + 'fta']) || 0;
                        acc.oreb += parseFloat(s[prefix + 'oreb']) || 0;
                        acc.dreb += parseFloat(s[prefix + 'dreb']) || 0;
                        acc.ast += parseFloat(s[prefix + 'ast']) || 0;
                        acc.stl += parseFloat(s[prefix + 'stl']) || 0;
                        acc.blk += parseFloat(s[prefix + 'blk']) || 0;
                        acc.tov += parseFloat(s[prefix + 'tov']) || 0;
                        // Opponent stats for defensive four factors
                        acc.oppFgm += parseFloat(s[oppPrefix + 'fgm']) || 0;
                        acc.oppFga += parseFloat(s[oppPrefix + 'fga']) || 0;
                        acc.oppFg3m += parseFloat(s[oppPrefix + 'fg3m']) || 0;
                        acc.oppFg3a += parseFloat(s[oppPrefix + 'fg3a']) || 0;
                        acc.oppFtm += parseFloat(s[oppPrefix + 'ftm']) || 0;
                        acc.oppFta += parseFloat(s[oppPrefix + 'fta']) || 0;
                        acc.oppOreb += parseFloat(s[oppPrefix + 'oreb']) || 0;
                        acc.oppDreb += parseFloat(s[oppPrefix + 'dreb']) || 0;
                        acc.oppTov += parseFloat(s[oppPrefix + 'tov']) || 0;
                        acc.stintCount += 1;
                        return acc;
                    }, { duration: 0, possessions: 0, pts: 0, ptsAllowed: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, oppFgm: 0, oppFga: 0, oppFg3m: 0, oppFg3a: 0, oppFtm: 0, oppFta: 0, oppOreb: 0, oppDreb: 0, oppTov: 0, stintCount: 0 });

                    // Calculate derived stats
                    const minutes = totals.duration / 60;
                    const poss = Math.max(totals.possessions, 1);
                    const offRtg = (totals.pts / poss) * 100;
                    const defRtg = (totals.ptsAllowed / poss) * 100;
                    const netRtg = offRtg - defRtg;

                    // Offensive Four Factors
                    const offEfg = totals.fga > 0 ? ((totals.fgm + 0.5 * totals.fg3m) / totals.fga) * 100 : 0;
                    const offTovDenom = totals.fga + 0.44 * totals.fta + totals.tov;
                    const offTov = offTovDenom > 0 ? (totals.tov / offTovDenom) * 100 : 0;
                    const totalOffReb = totals.oreb + totals.oppDreb;
                    const offOreb = totalOffReb > 0 ? (totals.oreb / totalOffReb) * 100 : 0;
                    const offFtRate = totals.fga > 0 ? (totals.fta / totals.fga) * 100 : 0;

                    // Defensive Four Factors
                    const defEfg = totals.oppFga > 0 ? ((totals.oppFgm + 0.5 * totals.oppFg3m) / totals.oppFga) * 100 : 0;
                    const defTovDenom = totals.oppFga + 0.44 * totals.oppFta + totals.oppTov;
                    const defTov = defTovDenom > 0 ? (totals.oppTov / defTovDenom) * 100 : 0;
                    const totalDefReb = totals.oppOreb + totals.dreb;
                    const defOreb = totalDefReb > 0 ? (totals.oppOreb / totalDefReb) * 100 : 0;
                    const defFtRate = totals.oppFga > 0 ? (totals.oppFta / totals.oppFga) * 100 : 0;

                    return {
                        minutes, possessions: totals.possessions, stintCount: totals.stintCount,
                        offRtg, defRtg, netRtg,
                        offEfg, offTov, offOreb, offFtRate,
                        defEfg, defTov, defOreb, defFtRate,
                        pts: totals.pts, ptsAllowed: totals.ptsAllowed,
                        fgPct: totals.fga > 0 ? (totals.fgm / totals.fga) * 100 : 0,
                        fg3Pct: totals.fg3a > 0 ? (totals.fg3m / totals.fg3a) * 100 : 0,
                        ftPct: totals.fta > 0 ? (totals.ftm / totals.fta) * 100 : 0
                    };
                };

                // ========================================================================
                // COMBINED VS STARTERS FILTER - Includes EITHER:
                // 1. 4+ REGULAR starters (season-wide, players with minGamesStarted+ starts)
                // 2. 4+ GAME starters (that specific game's starting 5)
                // No double counting - stint qualifies if EITHER condition is met
                // ========================================================================
                const vsStartersFilter = (s) => {
                    const isHome = s.home_team === team;
                    const oppTeam = isHome ? s.away_team : s.home_team;
                    const oppLineup = isHome ? s.away_lineup : s.home_lineup;
                    const gameId = s.game_id;

                    // Check REGULAR starters (season-wide)
                    const regularStarterCount = countRegularStartersInLineup(oppLineup, oppTeam);
                    const isVsRegularStarters = regularStarterCount >= 4;

                    // Check GAME starters (that game's specific starting 5)
                    const gameStarterCount = countGameStartersInLineup(oppLineup, oppTeam, gameId);
                    const isVsGameStarters = gameStarterCount >= 4;

                    // Qualifies if EITHER condition is met (no double counting needed - same stint)
                    return isVsRegularStarters || isVsGameStarters;
                };

                const vsNonStartersFilter = (s) => {
                    const isHome = s.home_team === team;
                    const oppTeam = isHome ? s.away_team : s.home_team;
                    const oppLineup = isHome ? s.away_lineup : s.home_lineup;
                    const gameId = s.game_id;

                    // Check REGULAR starters (season-wide)
                    const regularStarterCount = countRegularStartersInLineup(oppLineup, oppTeam);
                    const isVsRegularStarters = regularStarterCount >= 4;

                    // Check GAME starters (that game's specific starting 5)
                    const gameStarterCount = countGameStartersInLineup(oppLineup, oppTeam, gameId);
                    const isVsGameStarters = gameStarterCount >= 4;

                    // Only qualifies as "bench" if NEITHER condition is met
                    return !isVsRegularStarters && !isVsGameStarters;
                };

                // If specific lineup selected, filter stints to only include those with that lineup
                const getLineupFilter = (baseFilter) => {
                    if (isTeamWideMode) return baseFilter;
                    return (s) => {
                        if (!baseFilter(s)) return false;
                        const isHome = s.home_team === team;
                        const lineup = isHome ? (s.home_lineup || '') : (s.away_lineup || '');
                        const lineupPlayers = lineup.split(',').map(n => applyGlobalPlayerMerge(n.trim()).toLowerCase());
                        const selectedLower = selPlayerNames.map(n => applyGlobalPlayerMerge(n).toLowerCase());
                        return selectedLower.every(sp => lineupPlayers.some(lp => lp.includes(sp) || sp.includes(lp)));
                    };
                };

                // Aggregate stats
                const vsStartersStats = aggregateStintStats(teamStints, getLineupFilter(vsStartersFilter));
                const vsNonStartersStats = aggregateStintStats(teamStints, getLineupFilter(vsNonStartersFilter));
                const allStats = aggregateStintStats(teamStints, getLineupFilter(() => true));

                // Calculate league-wide vs starters stats for percentile comparison
                // Uses combined logic: 4+ regular starters OR 4+ game starters (no double counting)
                const allTeamsVsStarters = {};
                stintsData.forEach(s => {
                    ['home_team', 'away_team'].forEach(teamKey => {
                        const teamName = s[teamKey];
                        if (!teamName) return;
                        const isHome = teamKey === 'home_team';
                        const oppTeam = isHome ? s.away_team : s.home_team;
                        const oppLineup = isHome ? s.away_lineup : s.home_lineup;
                        const gameId = s.game_id;

                        // Use combined starter detection: 4+ regular starters OR 4+ game starters
                        const regularStarterCount = countRegularStartersInLineup(oppLineup, oppTeam);
                        const gameStarterCount = countGameStartersInLineup(oppLineup, oppTeam, gameId);
                        const isVsStarters = regularStarterCount >= 4 || gameStarterCount >= 4;
                        if (!isVsStarters) return;

                        if (!allTeamsVsStarters[teamName]) {
                            allTeamsVsStarters[teamName] = { poss: 0, pts: 0, ptsAllowed: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0, tov: 0, fta: 0 };
                        }
                        const prefix = isHome ? 'home_' : 'away_';
                        const oppPrefix = isHome ? 'away_' : 'home_';
                        allTeamsVsStarters[teamName].poss += parseFloat(s.possessions) || 0;
                        allTeamsVsStarters[teamName].pts += parseFloat(s[prefix + 'points']) || 0;
                        allTeamsVsStarters[teamName].ptsAllowed += parseFloat(s[oppPrefix + 'points']) || 0;
                        allTeamsVsStarters[teamName].fgm += parseFloat(s[prefix + 'fgm']) || 0;
                        allTeamsVsStarters[teamName].fga += parseFloat(s[prefix + 'fga']) || 0;
                        allTeamsVsStarters[teamName].fg3m += parseFloat(s[prefix + 'fg3m']) || 0;
                        allTeamsVsStarters[teamName].tov += parseFloat(s[prefix + 'tov']) || 0;
                        allTeamsVsStarters[teamName].fta += parseFloat(s[prefix + 'fta']) || 0;
                    });
                });

                // Calculate league averages for vs starters
                const leagueVsStartersStats = Object.entries(allTeamsVsStarters).map(([tn, t]) => {
                    const tovDenom = t.fga + 0.44 * t.fta + t.tov;
                    return {
                        team: tn,
                        offRtg: t.poss > 0 ? (t.pts / t.poss) * 100 : 0,
                        defRtg: t.poss > 0 ? (t.ptsAllowed / t.poss) * 100 : 0,
                        netRtg: t.poss > 0 ? ((t.pts - t.ptsAllowed) / t.poss) * 100 : 0,
                        efg: t.fga > 0 ? ((t.fgm + 0.5 * t.fg3m) / t.fga) * 100 : 0,
                        tovPct: tovDenom > 0 ? (t.tov / tovDenom) * 100 : 0,
                        ftRate: t.fga > 0 ? (t.fta / t.fga) * 100 : 0
                    };
                });

                // Percentile calculation helper
                const calcVsPct = (val, arr, higherBetter) => {
                    if (!arr || arr.length < 3) return 50;
                    const sorted = [...arr].sort((a, b) => a - b);
                    let rank = sorted.filter(v => v < val).length;
                    const pct = (rank / sorted.length) * 100;
                    return higherBetter ? pct : 100 - pct;
                };

                // Arrays for percentiles
                const vsStartersArrays = {
                    offRtg: leagueVsStartersStats.map(t => t.offRtg),
                    defRtg: leagueVsStartersStats.map(t => t.defRtg),
                    netRtg: leagueVsStartersStats.map(t => t.netRtg),
                    efg: leagueVsStartersStats.map(t => t.efg),
                    tovPct: leagueVsStartersStats.map(t => t.tovPct),
                    ftRate: leagueVsStartersStats.map(t => t.ftRate)
                };

                // Helper for stat card styling
                const getStatCardStyle = (pct) => {
                    if (pct >= 80) return { bg: 'rgba(34, 197, 94, 0.25)', border: 'rgba(34, 197, 94, 0.5)', color: '#4ade80' };
                    if (pct >= 60) return { bg: 'rgba(34, 197, 94, 0.12)', border: 'rgba(34, 197, 94, 0.3)', color: '#86efac' };
                    if (pct >= 40) return { bg: 'rgba(148, 163, 184, 0.12)', border: 'rgba(148, 163, 184, 0.3)', color: '#94a3b8' };
                    if (pct >= 20) return { bg: 'rgba(239, 68, 68, 0.12)', border: 'rgba(239, 68, 68, 0.3)', color: '#fca5a5' };
                    return { bg: 'rgba(239, 68, 68, 0.25)', border: 'rgba(239, 68, 68, 0.5)', color: '#f87171' };
                };

                // Comparison badge helper
                const getDiffBadge = (vsVal, nonVal, higherBetter) => {
                    if (vsVal === null || nonVal === null) return null;
                    const diff = vsVal - nonVal;
                    const isGood = higherBetter ? diff > 0 : diff < 0;
                    const color = isGood ? '#4ade80' : '#f87171';
                    const prefix = diff >= 0 ? '+' : '';
                    return e('span', {
                        style: { fontSize: '9px', padding: '2px 4px', borderRadius: '4px', background: isGood ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)', color, marginLeft: '4px' }
                    }, prefix + diff.toFixed(1) + ' vs bench');
                };

                // Stat card component
                const StatCard = ({ label, value, pct, vsVal, nonVal, higherBetter = true, format = 1 }) => {
                    const style = getStatCardStyle(pct);
                    return e('div', { style: { background: style.bg, border: '1px solid ' + style.border, borderRadius: '8px', padding: '12px', textAlign: 'center' }},
                        e('div', { style: { fontSize: '10px', color: '#94a3b8', marginBottom: '4px' }}, label),
                        e('div', { style: { fontSize: '20px', fontWeight: 'bold', color: style.color }},
                            value !== null ? value.toFixed(format) : '-',
                            nonVal !== null && getDiffBadge(vsVal, nonVal, higherBetter)
                        ),
                        e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '4px' }}, Math.round(pct) + ' pctl')
                    );
                };

                // Four factors card component
                const FourFactorCard = ({ label, offVal, defVal, offPct, defPct, offHigher = true, defHigher = false }) => {
                    const offStyle = getStatCardStyle(offPct);
                    const defStyle = getStatCardStyle(defPct);
                    return e('div', { style: { background: 'rgba(30, 41, 59, 0.5)', borderRadius: '8px', padding: '12px' }},
                        e('div', { style: { fontSize: '11px', color: '#e2e8f0', fontWeight: '600', marginBottom: '8px', textAlign: 'center' }}, label),
                        e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }},
                            e('div', { style: { background: offStyle.bg, border: '1px solid ' + offStyle.border, borderRadius: '6px', padding: '8px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '9px', color: '#4ade80' }}, 'OFF'),
                                e('div', { style: { fontSize: '16px', fontWeight: 'bold', color: offStyle.color }}, offVal !== null ? offVal.toFixed(1) : '-'),
                                e('div', { style: { fontSize: '8px', color: '#64748b' }}, Math.round(offPct) + ' pctl')
                            ),
                            e('div', { style: { background: defStyle.bg, border: '1px solid ' + defStyle.border, borderRadius: '6px', padding: '8px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '9px', color: '#f87171' }}, 'DEF'),
                                e('div', { style: { fontSize: '16px', fontWeight: 'bold', color: defStyle.color }}, defVal !== null ? defVal.toFixed(1) : '-'),
                                e('div', { style: { fontSize: '8px', color: '#64748b' }}, Math.round(defPct) + ' pctl')
                            )
                        )
                    );
                };

                return e('div', { className: 'section' },
                    e('h2', { className: 'section-title', style: { color: '#06b6d4' }}, '🎯 VS. Starters Performance',
                        !isTeamWideMode && e('span', { style: { fontSize: '12px', marginLeft: '8px', color: '#94a3b8' }}, '(' + selPlayerNames.length + ' players selected)')
                    ),

                    // Configuration: Min games started threshold
                    e('div', { style: { marginBottom: '16px', padding: '12px 16px', background: 'rgba(6, 182, 212, 0.1)', border: '1px solid rgba(6, 182, 212, 0.3)', borderRadius: '8px' }},
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap' }},
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' }},
                                e('span', { style: { fontSize: '14px' }}, '⚙️'),
                                e('span', { style: { fontSize: '12px', fontWeight: '600', color: '#06b6d4' }}, 'Min Games Started:')
                            ),
                            e('input', {
                                type: 'range',
                                min: 1,
                                max: 10,
                                value: minGamesStarted,
                                onChange: ev => setMinGamesStarted(parseInt(ev.target.value)),
                                style: { width: '100px', accentColor: '#06b6d4' }
                            }),
                            e('span', { style: { fontSize: '12px', fontWeight: 'bold', color: '#06b6d4', minWidth: '20px' }}, minGamesStarted),
                            e('span', { style: { fontSize: '10px', color: '#64748b' }}, '(Regular starters = players with ' + minGamesStarted + '+ game starts)')
                        ),
                        // Show explanation of combined logic
                        e('div', { style: { marginTop: '10px', fontSize: '10px', color: '#94a3b8' }},
                            '💡 VS. Starters = facing lineups with 4+ regular starters OR 4+ of that game\'s starting 5 (no double counting)'
                        ),
                        e('div', { style: { marginTop: '4px', fontSize: '9px', color: '#64748b' }},
                            '📊 Regular Starter = ' + minGamesStarted + '+ game starts | Game Starter = in opening lineup of that specific game'
                        )
                    ),

                    // Show current team's regular starters
                    teamRegularStarters.size > 0 && e('div', { style: { marginBottom: '16px', padding: '12px', background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '8px' }},
                        e('div', { style: { fontSize: '11px', fontWeight: '600', color: '#4ade80', marginBottom: '8px' }},
                            '📋 ' + team + ' Regular Starters (' + teamRegularStarters.size + ' players with ' + minGamesStarted + '+ games started)'
                        ),
                        e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '6px' }},
                            ...Object.entries(teamStarterCounts)
                                .filter(([_, count]) => count >= minGamesStarted)
                                .sort((a, b) => b[1] - a[1])
                                .map(([player, count]) =>
                                    e('span', {
                                        key: player,
                                        style: { fontSize: '10px', padding: '3px 8px', background: 'rgba(34, 197, 94, 0.2)', borderRadius: '4px', color: '#86efac' }
                                    }, player + ' (' + count + ')')
                                )
                        )
                    ),

                    // Sample size info
                    e('div', { style: { display: 'flex', gap: '16px', marginBottom: '16px', flexWrap: 'wrap' }},
                        vsStartersStats && e('div', { style: { background: 'rgba(6, 182, 212, 0.15)', border: '1px solid rgba(6, 182, 212, 0.4)', borderRadius: '8px', padding: '10px 14px', display: 'flex', alignItems: 'center', gap: '8px' }},
                            e('span', { style: { fontSize: '16px' }}, '🎯'),
                            e('div', null,
                                e('div', { style: { fontSize: '11px', color: '#06b6d4', fontWeight: '600' }}, 'VS. STARTERS'),
                                e('div', { style: { fontSize: '10px', color: '#94a3b8' }},
                                    vsStartersStats.minutes.toFixed(1) + ' min | ' + vsStartersStats.stintCount + ' stints | ' + vsStartersStats.possessions.toFixed(0) + ' poss'
                                )
                            )
                        ),
                        vsNonStartersStats && e('div', { style: { background: 'rgba(148, 163, 184, 0.15)', border: '1px solid rgba(148, 163, 184, 0.4)', borderRadius: '8px', padding: '10px 14px', display: 'flex', alignItems: 'center', gap: '8px' }},
                            e('span', { style: { fontSize: '16px' }}, '🪑'),
                            e('div', null,
                                e('div', { style: { fontSize: '11px', color: '#94a3b8', fontWeight: '600' }}, 'VS. BENCH'),
                                e('div', { style: { fontSize: '10px', color: '#64748b' }},
                                    vsNonStartersStats.minutes.toFixed(1) + ' min | ' + vsNonStartersStats.stintCount + ' stints | ' + vsNonStartersStats.possessions.toFixed(0) + ' poss'
                                )
                            )
                        )
                    ),

                    // Main ratings cards
                    vsStartersStats && e('div', { style: { marginBottom: '20px' }},
                        e('h3', { style: { fontSize: '13px', color: '#e2e8f0', marginBottom: '12px' }}, '📊 Ratings vs Opponent Starters'),
                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '12px' }},
                            e(StatCard, {
                                label: 'OFF RTG',
                                value: vsStartersStats.offRtg,
                                pct: calcVsPct(vsStartersStats.offRtg, vsStartersArrays.offRtg, true),
                                vsVal: vsStartersStats.offRtg,
                                nonVal: vsNonStartersStats?.offRtg,
                                higherBetter: true
                            }),
                            e(StatCard, {
                                label: 'DEF RTG',
                                value: vsStartersStats.defRtg,
                                pct: calcVsPct(vsStartersStats.defRtg, vsStartersArrays.defRtg, false),
                                vsVal: vsStartersStats.defRtg,
                                nonVal: vsNonStartersStats?.defRtg,
                                higherBetter: false
                            }),
                            e(StatCard, {
                                label: 'NET RTG',
                                value: vsStartersStats.netRtg,
                                pct: calcVsPct(vsStartersStats.netRtg, vsStartersArrays.netRtg, true),
                                vsVal: vsStartersStats.netRtg,
                                nonVal: vsNonStartersStats?.netRtg,
                                higherBetter: true
                            })
                        )
                    ),

                    // Four Factors section
                    vsStartersStats && e('div', { style: { marginBottom: '20px' }},
                        e('h3', { style: { fontSize: '13px', color: '#e2e8f0', marginBottom: '12px' }}, '📈 Four Factors vs Starters'),
                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '16px' }},
                            // Offensive Four Factors Card
                            e('div', { style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '10px', padding: '16px' }},
                                e('h4', { style: { color: '#4ade80', fontSize: '12px', marginBottom: '12px', display: 'flex', alignItems: 'center', gap: '6px' }}, '🎯 Offensive'),
                                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px' }},
                                    e('div', { className: getPerfFromPct(calcVsPct(vsStartersStats.offEfg, vsStartersArrays.efg, true)), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }},
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'eFG%'),
                                        e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, vsStartersStats.offEfg.toFixed(1)),
                                        vsNonStartersStats && e('div', { style: { fontSize: '9px', color: vsStartersStats.offEfg > vsNonStartersStats.offEfg ? '#4ade80' : '#f87171' }},
                                            (vsStartersStats.offEfg > vsNonStartersStats.offEfg ? '+' : '') + (vsStartersStats.offEfg - vsNonStartersStats.offEfg).toFixed(1) + ' vs bench'
                                        )
                                    ),
                                    e('div', { className: getPerfFromPct(calcVsPct(vsStartersStats.offTov, vsStartersArrays.tovPct, false)), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }},
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'TOV%'),
                                        e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, vsStartersStats.offTov.toFixed(1)),
                                        vsNonStartersStats && e('div', { style: { fontSize: '9px', color: vsStartersStats.offTov < vsNonStartersStats.offTov ? '#4ade80' : '#f87171' }},
                                            (vsStartersStats.offTov < vsNonStartersStats.offTov ? '' : '+') + (vsStartersStats.offTov - vsNonStartersStats.offTov).toFixed(1) + ' vs bench'
                                        )
                                    ),
                                    e('div', { className: getPerfFromPct(calcVsPct(vsStartersStats.offOreb, [30, 35, 40], true)), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }},
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'OREB%'),
                                        e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, vsStartersStats.offOreb.toFixed(1)),
                                        vsNonStartersStats && e('div', { style: { fontSize: '9px', color: vsStartersStats.offOreb > vsNonStartersStats.offOreb ? '#4ade80' : '#f87171' }},
                                            (vsStartersStats.offOreb > vsNonStartersStats.offOreb ? '+' : '') + (vsStartersStats.offOreb - vsNonStartersStats.offOreb).toFixed(1) + ' vs bench'
                                        )
                                    ),
                                    e('div', { className: getPerfFromPct(calcVsPct(vsStartersStats.offFtRate, vsStartersArrays.ftRate, true)), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }},
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'FT Rate'),
                                        e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, vsStartersStats.offFtRate.toFixed(1)),
                                        vsNonStartersStats && e('div', { style: { fontSize: '9px', color: vsStartersStats.offFtRate > vsNonStartersStats.offFtRate ? '#4ade80' : '#f87171' }},
                                            (vsStartersStats.offFtRate > vsNonStartersStats.offFtRate ? '+' : '') + (vsStartersStats.offFtRate - vsNonStartersStats.offFtRate).toFixed(1) + ' vs bench'
                                        )
                                    )
                                )
                            ),
                            // Defensive Four Factors Card
                            e('div', { style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '10px', padding: '16px' }},
                                e('h4', { style: { color: '#f87171', fontSize: '12px', marginBottom: '12px', display: 'flex', alignItems: 'center', gap: '6px' }}, '🛡️ Defensive'),
                                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px' }},
                                    e('div', { className: getPerfFromPct(100 - calcVsPct(vsStartersStats.defEfg, vsStartersArrays.efg, true)), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }},
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Opp eFG%'),
                                        e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, vsStartersStats.defEfg.toFixed(1)),
                                        vsNonStartersStats && e('div', { style: { fontSize: '9px', color: vsStartersStats.defEfg < vsNonStartersStats.defEfg ? '#4ade80' : '#f87171' }},
                                            (vsStartersStats.defEfg < vsNonStartersStats.defEfg ? '' : '+') + (vsStartersStats.defEfg - vsNonStartersStats.defEfg).toFixed(1) + ' vs bench'
                                        )
                                    ),
                                    e('div', { className: getPerfFromPct(calcVsPct(vsStartersStats.defTov, vsStartersArrays.tovPct, true)), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }},
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Opp TOV%'),
                                        e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, vsStartersStats.defTov.toFixed(1)),
                                        vsNonStartersStats && e('div', { style: { fontSize: '9px', color: vsStartersStats.defTov > vsNonStartersStats.defTov ? '#4ade80' : '#f87171' }},
                                            (vsStartersStats.defTov > vsNonStartersStats.defTov ? '+' : '') + (vsStartersStats.defTov - vsNonStartersStats.defTov).toFixed(1) + ' vs bench'
                                        )
                                    ),
                                    e('div', { className: getPerfFromPct(100 - calcVsPct(vsStartersStats.defOreb, [30, 35, 40], true)), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }},
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Opp OREB%'),
                                        e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, vsStartersStats.defOreb.toFixed(1)),
                                        vsNonStartersStats && e('div', { style: { fontSize: '9px', color: vsStartersStats.defOreb < vsNonStartersStats.defOreb ? '#4ade80' : '#f87171' }},
                                            (vsStartersStats.defOreb < vsNonStartersStats.defOreb ? '' : '+') + (vsStartersStats.defOreb - vsNonStartersStats.defOreb).toFixed(1) + ' vs bench'
                                        )
                                    ),
                                    e('div', { className: getPerfFromPct(100 - calcVsPct(vsStartersStats.defFtRate, vsStartersArrays.ftRate, true)), style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }},
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Opp FT Rate'),
                                        e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, vsStartersStats.defFtRate.toFixed(1)),
                                        vsNonStartersStats && e('div', { style: { fontSize: '9px', color: vsStartersStats.defFtRate < vsNonStartersStats.defFtRate ? '#4ade80' : '#f87171' }},
                                            (vsStartersStats.defFtRate < vsNonStartersStats.defFtRate ? '' : '+') + (vsStartersStats.defFtRate - vsNonStartersStats.defFtRate).toFixed(1) + ' vs bench'
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    // Comparison table
                    vsStartersStats && vsNonStartersStats && e('div', { style: { marginTop: '20px' }},
                        e('h3', { style: { fontSize: '13px', color: '#e2e8f0', marginBottom: '12px' }}, '📋 Split Comparison'),
                        e('div', { style: { overflowX: 'auto' }},
                            e('table', { style: { width: '100%', borderCollapse: 'collapse', fontSize: '11px' }},
                                e('thead', null,
                                    e('tr', { style: { borderBottom: '1px solid #334155' }},
                                        e('th', { style: { padding: '8px', textAlign: 'left', color: '#94a3b8' }}, 'Split'),
                                        e('th', { style: { padding: '8px', textAlign: 'center', color: '#94a3b8' }}, 'MIN'),
                                        e('th', { style: { padding: '8px', textAlign: 'center', color: '#94a3b8' }}, 'POSS'),
                                        e('th', { style: { padding: '8px', textAlign: 'center', color: '#4ade80' }}, 'ORTG'),
                                        e('th', { style: { padding: '8px', textAlign: 'center', color: '#f87171' }}, 'DRTG'),
                                        e('th', { style: { padding: '8px', textAlign: 'center', color: '#a78bfa' }}, 'NET'),
                                        e('th', { style: { padding: '8px', textAlign: 'center', color: '#94a3b8' }}, 'eFG%'),
                                        e('th', { style: { padding: '8px', textAlign: 'center', color: '#94a3b8' }}, 'TOV%'),
                                        e('th', { style: { padding: '8px', textAlign: 'center', color: '#94a3b8' }}, 'OREB%'),
                                        e('th', { style: { padding: '8px', textAlign: 'center', color: '#94a3b8' }}, 'FT Rate')
                                    )
                                ),
                                e('tbody', null,
                                    e('tr', { style: { borderBottom: '1px solid #1e293b', background: 'rgba(6, 182, 212, 0.1)' }},
                                        e('td', { style: { padding: '8px', fontWeight: '600', color: '#06b6d4' }}, '🎯 vs Starters'),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsStartersStats.minutes.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsStartersStats.possessions.toFixed(0)),
                                        e('td', { style: { padding: '8px', textAlign: 'center', color: '#4ade80', fontWeight: 'bold' }}, vsStartersStats.offRtg.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center', color: '#f87171', fontWeight: 'bold' }}, vsStartersStats.defRtg.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center', color: vsStartersStats.netRtg >= 0 ? '#4ade80' : '#f87171', fontWeight: 'bold' }}, (vsStartersStats.netRtg >= 0 ? '+' : '') + vsStartersStats.netRtg.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsStartersStats.offEfg.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsStartersStats.offTov.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsStartersStats.offOreb.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsStartersStats.offFtRate.toFixed(1))
                                    ),
                                    e('tr', { style: { borderBottom: '1px solid #1e293b' }},
                                        e('td', { style: { padding: '8px', fontWeight: '600', color: '#94a3b8' }}, '🪑 vs Bench'),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsNonStartersStats.minutes.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsNonStartersStats.possessions.toFixed(0)),
                                        e('td', { style: { padding: '8px', textAlign: 'center', color: '#4ade80' }}, vsNonStartersStats.offRtg.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center', color: '#f87171' }}, vsNonStartersStats.defRtg.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center', color: vsNonStartersStats.netRtg >= 0 ? '#4ade80' : '#f87171' }}, (vsNonStartersStats.netRtg >= 0 ? '+' : '') + vsNonStartersStats.netRtg.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsNonStartersStats.offEfg.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsNonStartersStats.offTov.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsNonStartersStats.offOreb.toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, vsNonStartersStats.offFtRate.toFixed(1))
                                    ),
                                    e('tr', { style: { background: 'rgba(139, 92, 246, 0.1)' }},
                                        e('td', { style: { padding: '8px', fontWeight: '600', color: '#a78bfa' }}, '📊 Difference'),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, (vsStartersStats.minutes - vsNonStartersStats.minutes).toFixed(1)),
                                        e('td', { style: { padding: '8px', textAlign: 'center' }}, (vsStartersStats.possessions - vsNonStartersStats.possessions).toFixed(0)),
                                        e('td', { style: { padding: '8px', textAlign: 'center', fontWeight: 'bold', color: (vsStartersStats.offRtg - vsNonStartersStats.offRtg) >= 0 ? '#4ade80' : '#f87171' }},
                                            ((vsStartersStats.offRtg - vsNonStartersStats.offRtg) >= 0 ? '+' : '') + (vsStartersStats.offRtg - vsNonStartersStats.offRtg).toFixed(1)
                                        ),
                                        e('td', { style: { padding: '8px', textAlign: 'center', fontWeight: 'bold', color: (vsStartersStats.defRtg - vsNonStartersStats.defRtg) <= 0 ? '#4ade80' : '#f87171' }},
                                            ((vsStartersStats.defRtg - vsNonStartersStats.defRtg) >= 0 ? '+' : '') + (vsStartersStats.defRtg - vsNonStartersStats.defRtg).toFixed(1)
                                        ),
                                        e('td', { style: { padding: '8px', textAlign: 'center', fontWeight: 'bold', color: (vsStartersStats.netRtg - vsNonStartersStats.netRtg) >= 0 ? '#4ade80' : '#f87171' }},
                                            ((vsStartersStats.netRtg - vsNonStartersStats.netRtg) >= 0 ? '+' : '') + (vsStartersStats.netRtg - vsNonStartersStats.netRtg).toFixed(1)
                                        ),
                                        e('td', { style: { padding: '8px', textAlign: 'center', color: (vsStartersStats.offEfg - vsNonStartersStats.offEfg) >= 0 ? '#4ade80' : '#f87171' }},
                                            ((vsStartersStats.offEfg - vsNonStartersStats.offEfg) >= 0 ? '+' : '') + (vsStartersStats.offEfg - vsNonStartersStats.offEfg).toFixed(1)
                                        ),
                                        e('td', { style: { padding: '8px', textAlign: 'center', color: (vsStartersStats.offTov - vsNonStartersStats.offTov) <= 0 ? '#4ade80' : '#f87171' }},
                                            ((vsStartersStats.offTov - vsNonStartersStats.offTov) >= 0 ? '+' : '') + (vsStartersStats.offTov - vsNonStartersStats.offTov).toFixed(1)
                                        ),
                                        e('td', { style: { padding: '8px', textAlign: 'center', color: (vsStartersStats.offOreb - vsNonStartersStats.offOreb) >= 0 ? '#4ade80' : '#f87171' }},
                                            ((vsStartersStats.offOreb - vsNonStartersStats.offOreb) >= 0 ? '+' : '') + (vsStartersStats.offOreb - vsNonStartersStats.offOreb).toFixed(1)
                                        ),
                                        e('td', { style: { padding: '8px', textAlign: 'center', color: (vsStartersStats.offFtRate - vsNonStartersStats.offFtRate) >= 0 ? '#4ade80' : '#f87171' }},
                                            ((vsStartersStats.offFtRate - vsNonStartersStats.offFtRate) >= 0 ? '+' : '') + (vsStartersStats.offFtRate - vsNonStartersStats.offFtRate).toFixed(1)
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    // Info note
                    e('div', { style: { marginTop: '16px', padding: '12px', background: 'rgba(148, 163, 184, 0.1)', borderRadius: '8px', fontSize: '10px', color: '#64748b' }},
                        e('div', { style: { marginBottom: '4px' }}, '💡 VS. Starters = facing 4+ regular starters (' + minGamesStarted + '+ games) OR 4+ of that game\'s starting 5'),
                        e('div', { style: { marginBottom: '4px' }}, '🔄 Combined analysis captures both season-long rotation starters AND per-game starters (no double counting)'),
                        e('div', null, '📊 Color coding: Green = good percentile (60+), Red = poor percentile (40-), compared to league-wide vs starters performance')
                    )
                );
            };

            // =======================================================================
            // ROTATIONS TAB - V4.9.8.7: Player rotation visualization by quarter
            // Shows average playing time in aggregate, supports lineup combination filtering
            // =======================================================================
            const RotationsTab = () => {
                // State for selected game
                const [selectedGame, setSelectedGame] = React.useState('aggregate');
                
                if (!stintsData.length) {
                    return e('div', { className: 'section' },
                        e('h2', { className: 'section-title', style: { color: '#f59e0b' }}, '🔄 Player Rotations'),
                        e('div', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }},
                            e('div', { style: { fontSize: '48px', marginBottom: '16px' }}, '📤'),
                            e('p', null, 'Upload Stints CSV to view player rotations'),
                            e('p', { style: { fontSize: '12px', marginTop: '8px' }}, 'Required: stints.csv with game_id, period, home_team, away_team, home_lineup, away_lineup, start_time, end_time')
                        )
                    );
                }

                // Get selected players from filter (for lineup combination view)
                const selectedPlayerNames = Object.values(selPlayers).filter(p => p && p.trim() !== '');
                const isLineupMode = selectedPlayerNames.length > 0;

                // Filter stints for selected team
                const teamStints = stintsData.filter(s => s.home_team === team || s.away_team === team);
                
                if (teamStints.length === 0) {
                    return e('div', { className: 'section' },
                        e('h2', { className: 'section-title', style: { color: '#f59e0b' }}, '🔄 Player Rotations'),
                        e('div', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }},
                            e('p', null, 'No stint data found for ' + team),
                            e('p', { style: { fontSize: '12px', marginTop: '8px' }}, 'Select a team with stint data')
                        )
                    );
                }

                // Get unique games for dropdown
                const games = [...new Set(teamStints.map(s => s.game_id))].sort();
                const numGames = games.length;
                
                // Filter by selected game or use all
                const baseStints = selectedGame === 'aggregate' 
                    ? teamStints 
                    : teamStints.filter(s => s.game_id === selectedGame);

                // If lineup mode, further filter to stints where ALL selected players are on court
                const displayStints = isLineupMode 
                    ? baseStints.filter(stint => {
                        const isHome = stint.home_team === team;
                        const lineup = isHome ? stint.home_lineup : stint.away_lineup;
                        if (!lineup) return false;
                        // V6.1: Apply merge rules for matching
                        const stintPlayers = lineup.split(',').map(p => applyPlayerMerge(p.trim()));
                        const selectedMerged = selectedPlayerNames.map(p => applyPlayerMerge(p));
                        return selectedMerged.every(selP => stintPlayers.includes(selP));
                    })
                    : baseStints;
                
                // Get game info for selected game
                const gameInfo = selectedGame !== 'aggregate' && baseStints.length > 0 
                    ? { 
                        home: baseStints[0].home_team, 
                        away: baseStints[0].away_team,
                        isHome: baseStints[0].home_team === team
                      }
                    : null;

                // Calculate quarter duration (600 seconds = 10 minutes)
                const quarterDuration = 600;
                const timeSlotSize = 30; // 30-second slots for heat map
                const slotsPerQuarter = quarterDuration / timeSlotSize;

                // Process stints to get player time data with frequency tracking
                const processStints = (stints, allStints) => {
                    const playerMinutes = {};
                    const playerSegments = {};
                    // For aggregate view: track frequency per time slot
                    const playerTimeSlotCounts = {}; // player -> period -> slot -> count
                    const gamesPerPeriod = {}; // period -> Set of game_ids
                    
                    // First pass: count games per period for normalization
                    allStints.forEach(stint => {
                        const period = parseInt(stint.period) || 1;
                        if (!gamesPerPeriod[period]) gamesPerPeriod[period] = new Set();
                        gamesPerPeriod[period].add(stint.game_id);
                    });
                    
                    stints.forEach(stint => {
                        const isHome = stint.home_team === team;
                        const lineup = isHome ? stint.home_lineup : stint.away_lineup;
                        if (!lineup) return;
                        
                        // V6.1: Apply merge rules for rotation processing
                        const players = lineup.split(',').map(p => applyPlayerMerge(p.trim()));
                        const startTime = parseFloat(stint.start_time) || 0;
                        const endTime = parseFloat(stint.end_time) || 0;
                        const duration = endTime - startTime;
                        const period = parseInt(stint.period) || 1;
                        const gameId = stint.game_id;

                        players.forEach(player => {
                            if (!player) return;
                            if (!playerMinutes[player]) playerMinutes[player] = 0;
                            if (!playerSegments[player]) playerSegments[player] = [];
                            if (!playerTimeSlotCounts[player]) playerTimeSlotCounts[player] = {};
                            if (!playerTimeSlotCounts[player][period]) {
                                playerTimeSlotCounts[player][period] = {};
                                // Initialize game tracking per slot
                                for (let s = 0; s < slotsPerQuarter; s++) {
                                    playerTimeSlotCounts[player][period][s] = new Set();
                                }
                            }
                            
                            playerMinutes[player] += duration;
                            playerSegments[player].push({
                                start: startTime,
                                end: endTime,
                                period: period,
                                gameId: gameId
                            });
                            
                            // Track which time slots this stint covers (for aggregate frequency)
                            const periodStart = (period - 1) * quarterDuration;
                            const clampedStart = Math.max(startTime, periodStart);
                            const clampedEnd = Math.min(endTime, period * quarterDuration);
                            
                            for (let t = clampedStart; t < clampedEnd; t += timeSlotSize) {
                                const slotIndex = Math.floor((t - periodStart) / timeSlotSize);
                                if (slotIndex >= 0 && slotIndex < slotsPerQuarter) {
                                    playerTimeSlotCounts[player][period][slotIndex].add(gameId);
                                }
                            }
                        });
                    });
                    
                    return { playerMinutes, playerSegments, playerTimeSlotCounts, gamesPerPeriod };
                };

                const { playerMinutes, playerSegments, playerTimeSlotCounts, gamesPerPeriod } = processStints(displayStints, baseStints);
                
                // Sort players by total minutes
                const sortedPlayers = Object.entries(playerMinutes)
                    .sort((a, b) => b[1] - a[1])
                    .map(([name, mins]) => ({ name, minutes: mins }));

                // Get max periods (usually 4, but could have OT)
                const maxPeriod = Math.max(...baseStints.map(s => parseInt(s.period) || 1), 4);
                const periods = Array.from({ length: maxPeriod }, (_, i) => i + 1);
                
                // Generate colors for players
                const playerColors = {};
                const colorPalette = [
                    '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16',
                    '#22c55e', '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9',
                    '#3b82f6', '#6366f1', '#8b5cf6', '#a855f7', '#d946ef',
                    '#ec4899', '#f43f5e'
                ];
                sortedPlayers.forEach((p, i) => {
                    playerColors[p.name] = colorPalette[i % colorPalette.length];
                });

                // SVG dimensions
                const svgWidth = 280;
                const svgHeight = 30;
                const rowHeight = 36;
                
                // Format time as MM:SS
                const formatTime = (seconds) => {
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    return mins + ':' + (secs < 10 ? '0' : '') + secs;
                };

                // Render a single quarter timeline - with heat map for aggregate
                const QuarterTimeline = ({ period, player }) => {
                    const isAggregate = selectedGame === 'aggregate';
                    const segments = playerSegments[player] || [];
                    const periodStart = (period - 1) * quarterDuration;
                    const periodEnd = period * quarterDuration;
                    const gamesInPeriod = gamesPerPeriod[period]?.size || numGames;
                    
                    if (isAggregate) {
                        // HEAT MAP VIEW: Show frequency/average with intensity
                        // Works for both team-wide and lineup combination mode
                        const slotData = playerTimeSlotCounts[player]?.[period] || {};
                        const slotWidth = svgWidth / slotsPerQuarter;
                        
                        // Calculate max frequency for this player across all slots for normalization
                        let maxFreq = 0;
                        for (let s = 0; s < slotsPerQuarter; s++) {
                            const freq = (slotData[s]?.size || 0) / gamesInPeriod;
                            if (freq > maxFreq) maxFreq = freq;
                        }
                        
                        return e('svg', { 
                            width: svgWidth, 
                            height: svgHeight,
                            style: { background: 'rgba(0,0,0,0.3)', borderRadius: '4px' }
                        },
                            // Time grid lines
                            ...Array.from({ length: 11 }, (_, i) => {
                                const x = (i / 10) * svgWidth;
                                return e('line', {
                                    key: 'grid-' + i,
                                    x1: x, y1: 0, x2: x, y2: svgHeight,
                                    stroke: 'rgba(255,255,255,0.08)',
                                    strokeWidth: i === 0 || i === 10 ? 2 : 1
                                });
                            }),
                            // Heat map slots with dramatic intensity variation
                            ...Array.from({ length: slotsPerQuarter }, (_, slotIdx) => {
                                const gamesOnCourt = slotData[slotIdx]?.size || 0;
                                const frequency = gamesOnCourt / gamesInPeriod;
                                if (frequency === 0) return null;
                                
                                // Harsh falloff curve that rewards consistency
                                // Above 75% frequency: stays bright (0.6-1.0)
                                // Below 75%: drops off sharply with cubic curve
                                const threshold = 0.75;
                                let opacity;
                                if (frequency >= threshold) {
                                    // Linear from 0.6 to 1.0 for the top 25%
                                    opacity = 0.6 + (frequency - threshold) / (1 - threshold) * 0.4;
                                } else {
                                    // Harsh cubic falloff below threshold
                                    const ratio = frequency / threshold;
                                    opacity = 0.6 * Math.pow(ratio, 2.5);
                                }
                                opacity = Math.max(0.02, opacity); // Minimum visibility
                                // Also vary the color brightness - dimmer for less frequent
                                const baseColor = playerColors[player];
                                
                                return e('rect', {
                                    key: 'slot-' + slotIdx,
                                    x: slotIdx * slotWidth,
                                    y: 1,
                                    width: slotWidth + 0.5,
                                    height: svgHeight - 2,
                                    fill: baseColor,
                                    opacity: opacity
                                });
                            }).filter(Boolean)
                        );
                    } else {
                        // SEGMENT VIEW: Show actual on-court times (single game only)
                        const periodSegments = segments.filter(seg => {
                            return seg.start < periodEnd && seg.end > periodStart;
                        }).map(seg => ({
                            start: Math.max(seg.start, periodStart),
                            end: Math.min(seg.end, periodEnd),
                            gameId: seg.gameId
                        }));

                        // Merge overlapping segments
                        const mergedSegments = [];
                        periodSegments.sort((a, b) => a.start - b.start).forEach(seg => {
                            if (mergedSegments.length === 0 || seg.start > mergedSegments[mergedSegments.length - 1].end) {
                                mergedSegments.push({ ...seg });
                            } else {
                                mergedSegments[mergedSegments.length - 1].end = Math.max(mergedSegments[mergedSegments.length - 1].end, seg.end);
                            }
                        });

                        return e('svg', { 
                            width: svgWidth, 
                            height: svgHeight,
                            style: { background: 'rgba(0,0,0,0.2)', borderRadius: '4px' }
                        },
                            // Time grid lines
                            ...Array.from({ length: 11 }, (_, i) => {
                                const x = (i / 10) * svgWidth;
                                return e('line', {
                                    key: 'grid-' + i,
                                    x1: x, y1: 0, x2: x, y2: svgHeight,
                                    stroke: 'rgba(255,255,255,0.1)',
                                    strokeWidth: i === 0 || i === 10 ? 2 : 1
                                });
                            }),
                            // Player segments
                            ...mergedSegments.map((seg, i) => {
                                const startX = ((seg.start - periodStart) / quarterDuration) * svgWidth;
                                const endX = ((seg.end - periodStart) / quarterDuration) * svgWidth;
                                const width = Math.max(endX - startX, 2);
                                
                                return e('rect', {
                                    key: 'seg-' + i,
                                    x: startX, y: 4,
                                    width: width,
                                    height: svgHeight - 8,
                                    fill: playerColors[player],
                                    rx: 3,
                                    opacity: 0.85
                                });
                            })
                        );
                    }
                };

                // Calculate stats for display
                const totalGameMinutes = selectedGame === 'aggregate' 
                    ? numGames * maxPeriod * 10 
                    : maxPeriod * 10;

                // Calculate lineup time together if in lineup mode
                const lineupTotalTime = isLineupMode ? displayStints.reduce((sum, s) => {
                    return sum + (parseFloat(s.end_time) - parseFloat(s.start_time));
                }, 0) : 0;

                return e('div', { className: 'section' },
                    e('h2', { className: 'section-title', style: { color: '#f59e0b' }}, '🔄 Player Rotations'),
                    
                    // Lineup mode banner
                    isLineupMode && e('div', { style: {
                        background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(168, 85, 247, 0.1))',
                        border: '2px solid rgba(139, 92, 246, 0.4)',
                        borderRadius: '10px',
                        padding: '14px 18px',
                        marginBottom: '16px'
                    }},
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap' }},
                            e('span', { style: { fontSize: '18px' }}, '👥'),
                            e('div', null,
                                e('div', { style: { color: '#c4b5fd', fontWeight: 'bold', fontSize: '14px' }}, 
                                    'Lineup Combination Mode'),
                                e('div', { style: { color: '#a78bfa', fontSize: '12px' }}, 
                                    selectedGame === 'aggregate' 
                                        ? 'Showing average playing patterns when together: '
                                        : 'Showing when on court together: ',
                                    e('strong', null, selectedPlayerNames.join(', '))
                                )
                            ),
                            e('div', { style: { 
                                marginLeft: 'auto', 
                                background: 'rgba(139, 92, 246, 0.3)',
                                padding: '6px 12px',
                                borderRadius: '6px'
                            }},
                                e('span', { style: { fontSize: '12px', color: '#e9d5ff' }}, 
                                    selectedGame === 'aggregate' ? 'Avg/game: ' : 'Together: ',
                                    e('strong', null, formatTime(selectedGame === 'aggregate' ? lineupTotalTime / numGames : lineupTotalTime)),
                                    selectedGame === 'aggregate' 
                                        ? ' (' + numGames + ' games)'
                                        : ' across ' + displayStints.length + ' stints'
                                )
                            )
                        )
                    ),
                    
                    // Controls
                    e('div', { style: { 
                        display: 'flex', 
                        gap: '16px', 
                        alignItems: 'center', 
                        marginBottom: '20px',
                        padding: '16px',
                        background: 'rgba(245, 158, 11, 0.1)',
                        borderRadius: '10px',
                        flexWrap: 'wrap'
                    }},
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                            e('label', { style: { fontSize: '13px', fontWeight: '600' }}, 'Game:'),
                            e('select', {
                                value: selectedGame,
                                onChange: (ev) => setSelectedGame(ev.target.value),
                                style: { 
                                    padding: '8px 12px', 
                                    background: '#1e293b', 
                                    border: '1px solid #475569', 
                                    borderRadius: '6px', 
                                    color: 'white',
                                    minWidth: '200px'
                                }
                            },
                                e('option', { value: 'aggregate' }, '📊 Average Across Games (' + numGames + ' games)'),
                                ...games.map(g => {
                                    const gameStints = teamStints.filter(s => s.game_id === g);
                                    const home = gameStints[0]?.home_team || '';
                                    const away = gameStints[0]?.away_team || '';
                                    return e('option', { key: g, value: g }, home + ' vs ' + away);
                                })
                            )
                        ),
                        e('div', { style: { fontSize: '12px', color: '#94a3b8' }},
                            'Showing: ', e('strong', { style: { color: '#f59e0b' }}, team),
                            isLineupMode 
                                ? ' • ' + selectedPlayerNames.length + '-player combination'
                                : ' • ' + sortedPlayers.length + ' players',
                            ' • ', maxPeriod > 4 ? maxPeriod + ' periods (incl. OT)' : '4 quarters'
                        )
                    ),

                    // Game info banner (single game mode)
                    gameInfo && e('div', { style: {
                        background: gameInfo.isHome ? 'rgba(59, 130, 246, 0.15)' : 'rgba(239, 68, 68, 0.15)',
                        border: '1px solid ' + (gameInfo.isHome ? 'rgba(59, 130, 246, 0.3)' : 'rgba(239, 68, 68, 0.3)'),
                        borderRadius: '8px',
                        padding: '12px 16px',
                        marginBottom: '16px',
                        display: 'flex',
                        justifyContent: 'center',
                        gap: '24px',
                        fontSize: '14px'
                    }},
                        e('span', { style: { fontWeight: 'bold', color: gameInfo.isHome ? '#3b82f6' : '#94a3b8' }}, 
                            gameInfo.home + (gameInfo.isHome ? ' (HOME)' : '')),
                        e('span', { style: { color: '#64748b' }}, 'vs'),
                        e('span', { style: { fontWeight: 'bold', color: !gameInfo.isHome ? '#ef4444' : '#94a3b8' }}, 
                            gameInfo.away + (!gameInfo.isHome ? ' (AWAY)' : ''))
                    ),

                    // Aggregate mode explanation - shows for both team-wide and lineup mode
                    selectedGame === 'aggregate' && e('div', { style: {
                        background: isLineupMode ? 'rgba(139, 92, 246, 0.1)' : 'rgba(6, 182, 212, 0.1)',
                        border: '1px solid ' + (isLineupMode ? 'rgba(139, 92, 246, 0.3)' : 'rgba(6, 182, 212, 0.3)'),
                        borderRadius: '8px',
                        padding: '10px 14px',
                        marginBottom: '16px',
                        fontSize: '12px',
                        color: isLineupMode ? '#c4b5fd' : '#67e8f9'
                    }},
                        e('strong', null, '📊 Average View: '),
                        isLineupMode 
                            ? 'Bar intensity shows how consistently this combination plays together at each time. '
                            : 'Bar intensity shows rotation consistency - bright = regular part of rotation. ',
                        'Based on ', numGames, ' games. ',
                        'Only times where player is on court 75%+ of games show bright.'
                    ),

                    // Rotation chart
                    sortedPlayers.length > 0 ? e('div', { style: { overflowX: 'auto' }},
                        e('table', { style: { width: '100%', borderCollapse: 'collapse', fontSize: '12px' }},
                            // Header with quarter labels
                            e('thead', null,
                                e('tr', { style: { background: 'rgba(245, 158, 11, 0.2)' }},
                                    e('th', { style: { 
                                        padding: '10px', 
                                        textAlign: 'left', 
                                        width: '160px',
                                        borderBottom: '1px solid rgba(255,255,255,0.1)' 
                                    }}, 'Player'),
                                    ...periods.map(p => 
                                        e('th', { 
                                            key: p, 
                                            style: { 
                                                padding: '10px', 
                                                textAlign: 'center',
                                                borderBottom: '1px solid rgba(255,255,255,0.1)',
                                                minWidth: svgWidth + 'px'
                                            }
                                        }, 
                                            p <= 4 ? 'Q' + p : 'OT' + (p - 4),
                                            e('div', { style: { 
                                                display: 'flex', 
                                                justifyContent: 'space-between', 
                                                fontSize: '9px', 
                                                color: '#64748b',
                                                marginTop: '4px'
                                            }},
                                                e('span', null, '10:00'),
                                                e('span', null, '5:00'),
                                                e('span', null, '0:00')
                                            )
                                        )
                                    ),
                                    e('th', { style: { 
                                        padding: '10px', 
                                        textAlign: 'right', 
                                        width: '80px',
                                        borderBottom: '1px solid rgba(255,255,255,0.1)'
                                    }}, selectedGame === 'aggregate' ? 'Avg Min' : 'Minutes')
                                )
                            ),
                            // Player rows
                            e('tbody', null,
                                ...sortedPlayers.map((player, i) => {
                                    const isSelected = selectedPlayerNames.includes(player.name);
                                    const avgMinutes = selectedGame === 'aggregate' 
                                        ? player.minutes / numGames 
                                        : player.minutes;
                                    
                                    return e('tr', { 
                                        key: player.name, 
                                        style: { 
                                            background: isSelected 
                                                ? 'rgba(139, 92, 246, 0.2)' 
                                                : (i % 2 === 0 ? 'rgba(0,0,0,0.1)' : 'transparent'),
                                            height: rowHeight + 'px'
                                        }
                                    },
                                        e('td', { style: { 
                                            padding: '6px 10px', 
                                            borderBottom: '1px solid rgba(255,255,255,0.05)',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '8px'
                                        }},
                                            e('div', { style: {
                                                width: '12px',
                                                height: '12px',
                                                borderRadius: '3px',
                                                background: playerColors[player.name],
                                                border: isSelected ? '2px solid #a855f7' : 'none'
                                            }}),
                                            e('span', { style: { 
                                                fontWeight: isSelected || i < 5 ? 'bold' : 'normal',
                                                color: isSelected ? '#c4b5fd' : (i < 5 ? '#fff' : '#94a3b8'),
                                                fontSize: '11px',
                                                whiteSpace: 'nowrap',
                                                overflow: 'hidden',
                                                textOverflow: 'ellipsis',
                                                maxWidth: '120px'
                                            }}, player.name)
                                        ),
                                        ...periods.map(p => 
                                            e('td', { 
                                                key: p, 
                                                style: { 
                                                    padding: '3px',
                                                    borderBottom: '1px solid rgba(255,255,255,0.05)'
                                                }
                                            }, e(QuarterTimeline, { period: p, player: player.name }))
                                        ),
                                        e('td', { style: { 
                                            padding: '6px 10px', 
                                            textAlign: 'right',
                                            fontWeight: 'bold',
                                            color: avgMinutes / 60 > 30 ? '#22c55e' : '#f59e0b',
                                            borderBottom: '1px solid rgba(255,255,255,0.05)'
                                        }}, formatTime(avgMinutes))
                                    );
                                })
                            )
                        )
                    ) : e('div', { style: { 
                        textAlign: 'center', 
                        padding: '40px', 
                        color: '#64748b' 
                    }}, 
                        isLineupMode 
                            ? 'No stints found with all selected players on court together'
                            : 'No rotation data available'
                    ),

                    // Legend
                    e('div', { style: { 
                        marginTop: '20px', 
                        padding: '12px', 
                        background: 'rgba(245, 158, 11, 0.1)', 
                        borderRadius: '8px',
                        fontSize: '11px',
                        color: '#94a3b8'
                    }},
                        e('strong', { style: { color: '#f59e0b' }}, '📖 How to read: '),
                        selectedGame === 'aggregate'
                            ? 'Bright bars = consistent rotation spot (75%+ of games). Faint = inconsistent/situational. '
                            : 'Solid bars show actual on-court time for this game. ',
                        'Time runs left to right (10:00 → 0:00). ',
                        isLineupMode 
                            ? 'Showing average patterns for when this player combination plays together. '
                            : 'Select players at the top of the page to see when specific combinations play together. ',
                        'Players sorted by ', selectedGame === 'aggregate' ? 'average' : 'total', ' minutes.'
                    ),

                    // Player summary cards (only in non-lineup mode)
                    !isLineupMode && e('h3', { style: { marginTop: '24px', marginBottom: '12px', fontSize: '16px' }}, 
                        '📋 ' + (selectedGame === 'aggregate' ? 'Average ' : '') + 'Minutes Summary'
                    ),
                    !isLineupMode && e('div', { style: { 
                        display: 'grid', 
                        gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))', 
                        gap: '12px' 
                    }},
                        ...sortedPlayers.slice(0, 12).map((player, i) => {
                            const avgMinutes = selectedGame === 'aggregate' 
                                ? player.minutes / numGames 
                                : player.minutes;
                            const pct = (avgMinutes / 60) / (maxPeriod * 10) * 100;
                            
                            return e('div', { 
                                key: player.name,
                                style: {
                                    background: 'rgba(30, 41, 59, 0.8)',
                                    border: '1px solid ' + playerColors[player.name],
                                    borderRadius: '8px',
                                    padding: '12px'
                                }
                            },
                                e('div', { style: { 
                                    display: 'flex', 
                                    justifyContent: 'space-between', 
                                    alignItems: 'center',
                                    marginBottom: '8px'
                                }},
                                    e('span', { style: { 
                                        fontWeight: 'bold', 
                                        fontSize: '12px',
                                        color: playerColors[player.name],
                                        whiteSpace: 'nowrap',
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        maxWidth: '100px'
                                    }}, player.name),
                                    e('span', { style: { 
                                        fontSize: '14px', 
                                        fontWeight: 'bold',
                                        color: '#fff'
                                    }}, formatTime(avgMinutes))
                                ),
                                e('div', { style: { 
                                    height: '6px', 
                                    background: 'rgba(0,0,0,0.3)', 
                                    borderRadius: '3px',
                                    overflow: 'hidden'
                                }},
                                    e('div', { style: {
                                        width: Math.min(pct, 100) + '%',
                                        height: '100%',
                                        background: playerColors[player.name],
                                        borderRadius: '3px'
                                    }})
                                ),
                                e('div', { style: { 
                                    fontSize: '10px', 
                                    color: '#64748b', 
                                    marginTop: '4px',
                                    textAlign: 'right'
                                }}, pct.toFixed(1) + '% of game')
                            );
                        })
                    )
                );
            };

            // =======================================================================
            // V4.9.8: PLAYER BREAKDOWN TAB
            // Per 75 possessions stats with league percentiles and color coding
            // =======================================================================
            const PlayerBreakdownTab = () => {
                // Hollinger PER: Build league-wide totals from all teams for league constants
                // Must be before any early returns to satisfy React hooks rules
                const lgTotals = useMemo(() => {
                    const lg = { pts: 0, fga: 0, fgm: 0, fta: 0, ftm: 0, ast: 0, oreb: 0, dreb: 0, trb: 0, tov: 0, pf: 0, stl: 0, blk: 0, min: 0, tpm: 0 };
                    // Build league totals from season player data (player_stats_enhanced.csv)
                    // This is more reliable than team_totals.csv which has column name mismatches
                    // Use a Set to avoid double-counting (seasonStatsMap may have multiple keys per player)
                    const counted = new Set();
                    seasonStatsMap.forEach((ss, key) => {
                        // Deduplicate by using the player name+team combo
                        const uid = (ss.name || key) + '|||' + (ss.team || '');
                        if (counted.has(uid)) return;
                        counted.add(uid);
                        lg.pts += ss.pts || 0; lg.fga += ss.fga || 0; lg.fgm += ss.fgm || 0;
                        lg.fta += ss.fta || 0; lg.ftm += ss.ftm || 0; lg.ast += ss.ast || 0;
                        lg.oreb += ss.oreb || 0; lg.dreb += ss.dreb || 0;
                        lg.trb += (ss.oreb || 0) + (ss.dreb || 0);
                        lg.tov += ss.tov || 0; lg.pf += ss.pf || 0;
                        lg.stl += ss.stl || 0; lg.blk += ss.blk || 0;
                        lg.min += ss.min || 0;
                        lg.tpm += ss.tpm || 0;
                    });
                    // Fallback: use team totals if no season player data
                    if (lg.min === 0 && teamSeasonTotals.size > 0) {
                        teamSeasonTotals.forEach(t => {
                            lg.pts += t.pts || 0; lg.fga += t.fga || 0; lg.fgm += t.fgm || 0;
                            lg.fta += t.fta || 0; lg.ftm += t.ftm || 0; lg.ast += t.ast || 0;
                            lg.oreb += t.oreb || 0; lg.dreb += t.dreb || 0;
                            lg.trb += (t.oreb || 0) + (t.dreb || 0);
                            lg.tov += t.tov || 0; lg.pf += t.pf || 0;
                            lg.stl += t.stl || 0; lg.blk += t.blk || 0;
                            lg.min += t.totalMinutes || 0;
                            lg.tpm += t.tpm || 0;
                        });
                        // Derive pts if still 0 (column name mismatch)
                        if (lg.pts === 0 && lg.fgm > 0) lg.pts = lg.fgm * 2 + lg.tpm + lg.ftm;
                    }
                    return lg;
                }, [seasonStatsMap, teamSeasonTotals]);

                // Hollinger normalization factor: 15 / league_average_uPER
                // Must be before early return (React hooks rule). Inlines the Hollinger formula.
                const lgNormFactor = useMemo(() => {
                    const lg = lgTotals;
                    if (lg.min < 1 || lg.fga < 1 || lg.fgm < 1) return 1;
                    // League constants
                    const lg_FT = lg.ftm || 1, lg_PF = lg.pf || 1;
                    const lg_FG = lg.fgm || 1, lg_FGA = lg.fga || 1;
                    const lg_AST = lg.ast || 1, lg_FTA = lg.fta || 1;
                    const lg_PTS = lg.pts || 1, lg_ORB = lg.oreb || 1;
                    const lg_TRB = lg.trb || 1, lg_TOV = lg.tov || 1;

                    const factor = (2 / 3) - (0.5 * (lg_AST / lg_FG)) / (2 * (lg_FG / lg_FT));
                    const VOP = lg_PTS / (lg_FGA - lg_ORB + lg_TOV + 0.44 * lg_FTA);
                    const DRBP = (lg_TRB - lg_ORB) / lg_TRB;

                    // For the league average, team_AST/team_FG = league averages
                    const tm_AST = lg_AST;
                    const tm_FG = lg_FG;

                    // League average uPER: feed all league totals as if one "average" player
                    const lgUPER = (1 / lg.min) * (
                        (lg.tpm || 0)
                        + (2 / 3) * lg_AST
                        + (2 - factor * (tm_AST / tm_FG)) * lg_FG
                        + (lg_FT * 0.5 * (1 + (1 - (tm_AST / tm_FG)) + (2 / 3) * (tm_AST / tm_FG)))
                        - VOP * lg_TOV
                        - VOP * DRBP * (lg_FGA - lg_FG)
                        - VOP * 0.44 * (0.44 + (0.56 * DRBP)) * (lg_FTA - lg_FT)
                        + VOP * (1 - DRBP) * (lg.dreb || 0)
                        + VOP * DRBP * lg_ORB
                        + VOP * (lg.stl || 0)
                        + VOP * DRBP * (lg.blk || 0)
                        - lg_PF * ((lg_FT / lg_PF) - 0.44 * (lg_FTA / lg_PF) * VOP)
                    );
                    if (!lgUPER || lgUPER <= 0 || !isFinite(lgUPER)) return 1;
                    return 15 / lgUPER;
                }, [lgTotals]);

                if (!playerBreakdown.length) return e('div', { className: 'section' },
                    e('h2', { className: 'section-title' }, '👤 Player Breakdown'),
                    e('p', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }}, 'No player data available. Upload player_stats.csv')
                );

                const hasSeasonData = seasonData.length > 0;
                const hasLeagueData = leaguePlayerAverages !== null;
                const afc = Object.values(selPlayers).filter(p => p !== '').length;
                
                // V4.9.8: Check for team-wide mode (no player filters) and RAPM availability
                const isTeamWideMode = afc === 0;
                const hasRapmData = playerRapmStats && playerRapmStats.stats && !playerRapmStats.error;
                const hasStintsData = stintsData.length > 0;
                const showRapmSection = isTeamWideMode && hasStintsData && hasRapmData;
                
                // State for expanded RAPM dropdowns (track by player name)
                const [expandedRapmPlayers, setExpandedRapmPlayers] = useState({});
                const toggleRapmExpand = (playerName) => {
                    setExpandedRapmPlayers(prev => ({
                        ...prev,
                        [playerName]: !prev[playerName]
                    }));
                };
                
                // Helper to get RAPM value and percentile for a stat
                const getPlayerRapmStat = (playerName, statKey) => {
                    if (!hasRapmData) return null;
                    // Try both normalized and lowercase versions
                    const normalizedName = normalizePlayerName(playerName);
                    const lowercaseName = playerName.toLowerCase().trim();
                    
                    // Try normalized first, then lowercase
                    let result = PlayerRAPMEngine.getPlayerRapmValue(playerRapmStats, normalizedName, statKey);
                    if (!result) {
                        result = PlayerRAPMEngine.getPlayerRapmValue(playerRapmStats, lowercaseName, statKey);
                    }
                    return result;
                };
                
                // Build RAPM percentile arrays for color coding
                const rapmPercentileArrays = useMemo(() => {
                    if (!hasRapmData || !playerRapmStats.stats) return null;
                    const arrays = {};
                    // For each stat, collect all player values using correct stat keys
                    const statsToTrack = ['net', 'off', 'def', 'offEfg', 'offTov', 'offOreb', 'offFtR', 'defEfg', 'defTov', 'defOreb', 'defFtR'];
                    statsToTrack.forEach(statKey => {
                        const statData = PlayerRAPMEngine.leaderboardStatMapping ? PlayerRAPMEngine.leaderboardStatMapping[statKey] : null;
                        if (!statData || !statData.useRapm) return;
                        const rapmStatName = statData.rapmStatName;
                        const statResults = playerRapmStats.stats[rapmStatName];
                        if (!statResults) return;
                        
                        const values = [];
                        Object.keys(statResults).forEach(player => {
                            const playerData = statResults[player];
                            if (!playerData) return;
                            let val;
                            if (statKey === 'net') {
                                // Net = oRAPM + dRAPM (dRAPM is negative for good defense)
                                const off = playerData.oRAPM || 0;
                                const def = playerData.dRAPM || 0;
                                val = off + def;
                            } else if (statData.useDefCoef) {
                                val = statData.flipSign ? -(playerData.dRAPM || 0) : (playerData.dRAPM || 0);
                            } else {
                                val = playerData.oRAPM || 0;
                            }
                            if (typeof val === 'number' && !isNaN(val)) values.push(val);
                        });
                        arrays[statKey] = values.sort((a, b) => a - b);
                    });
                    return arrays;
                }, [hasRapmData, playerRapmStats]);
                
                const calcRapmPercentile = (value, statKey, higherBetter = true) => {
                    if (!rapmPercentileArrays || !rapmPercentileArrays[statKey]) return 50;
                    const arr = rapmPercentileArrays[statKey];
                    const rank = arr.filter(v => v <= value).length;
                    const pct = (rank / arr.length) * 100;
                    return higherBetter ? pct : 100 - pct;
                };
                
                // Get comparison class for season comparison delta text
                const getCompClass = (diff, higherBetter = true) => {
                    if (Math.abs(diff) < 0.5) return 'scv-same';
                    const isGood = higherBetter ? diff > 0 : diff < 0;
                    return isGood ? 'scv-better' : 'scv-worse';
                };
                // Get card-level color class (positive/negative/neutral border & bg)
                const getCardClass = (diff, higherBetter = true) => {
                    if (Math.abs(diff) < 0.5) return 'sci-neutral';
                    const isGood = higherBetter ? diff > 0 : diff < 0;
                    return isGood ? 'sci-positive' : 'sci-negative';
                };
                
                // Stat with percentile badge
                const StatWithPct = ({ value, pct, label, higherBetter = true, suffix = '', showRaw = false, rawValue = null }) => {
                    const perfClass = getLeaguePerfClass(pct);
                    return e('div', { className: 'player-stat ' + perfClass, style: { position: 'relative' }},
                        e('div', { className: 'player-stat-label' }, label),
                        e('div', { className: 'player-stat-value' }, value.toFixed(1) + suffix),
                        e('div', { style: { fontSize: '9px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px', marginTop: '2px' }},
                            e('span', { style: {
                                padding: '1px 4px',
                                borderRadius: '3px',
                                background: pct >= 80 ? 'rgba(34,197,94,0.3)' : pct >= 60 ? 'rgba(132,204,22,0.3)' : pct >= 40 ? 'rgba(234,179,8,0.3)' : pct >= 20 ? 'rgba(249,115,22,0.3)' : 'rgba(239,68,68,0.3)',
                                fontWeight: '600'
                            }}, Math.round(pct) + 'th'),
                            hasLeagueData && e('span', { style: { opacity: 0.7 }}, 'pct')
                        ),
                        showRaw && rawValue !== null && e('div', { style: { fontSize: '8px', opacity: 0.6, marginTop: '1px' }}, 'Raw: ' + rawValue.toFixed(1))
                    );
                };

                // V5.22: BPM 2.0 coefficients for player BPM calculation
                const BPM_COEFFS = {
                    a: 0.123391, b: 0.119597, c: -0.151287, d: 1.255644,
                    e: 0.531838, f: -0.305868, g: 0.921292, h: 0.711217,
                    i: 0.017022, j: 0.297639, k: 0.213485, l: 0.725930
                };
                const OBPM_COEFFS = {
                    a: 0.064448, b: 0.211125, c: -0.107545, d: 0.346513,
                    e: -0.052476, f: -0.041787, g: 0.932965, h: 0.687359,
                    i: 0.007952, j: 0.374706, k: -0.181891, l: 0.239862
                };
                const lgAvg3PAr = 0.40;

                // V5.22: Helper to get BPM color based on value
                const getBpmColor = (bpm) => {
                    if (bpm === null || bpm === undefined) return '#64748b';
                    if (bpm >= 5) return '#22c55e';
                    if (bpm >= 2) return '#4ade80';
                    if (bpm >= 0) return '#86efac';
                    if (bpm >= -2) return '#fca5a5';
                    if (bpm >= -5) return '#f87171';
                    return '#ef4444';
                };

                // V5.22: Helper to get BPM background based on value
                const getBpmBackground = (bpm) => {
                    if (bpm === null || bpm === undefined) return 'rgba(100, 116, 139, 0.2)';
                    if (bpm >= 5) return 'rgba(34, 197, 94, 0.25)';
                    if (bpm >= 2) return 'rgba(74, 222, 128, 0.2)';
                    if (bpm >= 0) return 'rgba(134, 239, 172, 0.15)';
                    if (bpm >= -2) return 'rgba(252, 165, 165, 0.15)';
                    if (bpm >= -5) return 'rgba(248, 113, 113, 0.2)';
                    return 'rgba(239, 68, 68, 0.25)';
                };

                // Hollinger PER helper: compute uPER given player totals and context
                const hollingerUPER = (MP, TP, AST, FG, FGA, FT, FTA, ORB, DRB, STL, BLK, TOV, PF,
                    tm_AST, tm_FG, lg) => {
                    if (MP < 0.1 || lg.min < 1 || lg.fga < 1) return null;
                    // League constants
                    const lg_FT = lg.ftm || 1; const lg_PF = lg.pf || 1;
                    const lg_FG = lg.fgm || 1; const lg_FGA = lg.fga || 1;
                    const lg_AST = lg.ast || 1; const lg_FTA = lg.fta || 1;
                    const lg_PTS = lg.pts || 1; const lg_ORB = lg.oreb || 1;
                    const lg_TRB = lg.trb || 1; const lg_TOV = lg.tov || 1;

                    const factor = (2 / 3) - (0.5 * (lg_AST / lg_FG)) / (2 * (lg_FG / lg_FT));
                    const VOP = lg_PTS / (lg_FGA - lg_ORB + lg_TOV + 0.44 * lg_FTA);
                    const DRBP = (lg_TRB - lg_ORB) / lg_TRB;

                    const team_AST = tm_AST || 1;
                    const team_FG = tm_FG || 1;

                    const uPER = (1 / MP) * (
                        TP
                        + (2 / 3) * AST
                        + (2 - factor * (team_AST / team_FG)) * FG
                        + (FT * 0.5 * (1 + (1 - (team_AST / team_FG)) + (2 / 3) * (team_AST / team_FG)))
                        - VOP * TOV
                        - VOP * DRBP * (FGA - FG)
                        - VOP * 0.44 * (0.44 + (0.56 * DRBP)) * (FTA - FT)
                        + VOP * (1 - DRBP) * DRB  // (TRB - ORB) = DRB
                        + VOP * DRBP * ORB
                        + VOP * STL
                        + VOP * DRBP * BLK
                        - PF * ((lg_FT / lg_PF) - 0.44 * (lg_FTA / lg_PF) * VOP)
                    );
                    return uPER;
                };

                // Hollinger PER for lineup-level stats (from playerBreakdown)
                const calcPlayerPER = (p) => {
                    if (!p || p.lpPoss < 1 || p.minutes < 0.1) return null;
                    if (lgTotals.min < 1 || lgTotals.fga < 1) {
                        // Fallback: simplified PER when no league data
                        const pts = p.pts || 0, reb = (p.oreb || 0) + (p.dreb || 0);
                        const missedFg = (p.fga || 0) - (p.fgm || 0), missedFt = (p.fta || 0) - (p.ftm || 0);
                        return ((pts + reb + (p.ast || 0) * 1.5 + (p.stl || 0) * 2 + (p.blk || 0) * 2 - missedFg - missedFt * 0.5 - (p.tov || 0) * 1.5) / p.minutes) * 15;
                    }
                    // Team context from lineup data
                    const tm_AST = p.lpTeamAst || 0;
                    const tm_FG = p.lpTeamFgm || 0;
                    const uPER = hollingerUPER(
                        p.minutes, p.tpm || 0, p.ast || 0, p.fgm || 0, p.fga || 0,
                        p.ftm || 0, p.fta || 0, p.oreb || 0, p.dreb || 0,
                        p.stl || 0, p.blk || 0, p.tov || 0, p.pf || 0,
                        tm_AST, tm_FG, lgTotals
                    );
                    if (uPER === null) return null;
                    // Normalize so league average = 15
                    return uPER * lgNormFactor;
                };

                // Hollinger PER for season-level stats
                const calcSeasonPER = (ss) => {
                    if (!ss || ss.min < 1) return null;
                    if (lgTotals.min < 1 || lgTotals.fga < 1) {
                        // Fallback: simplified PER when no league data
                        const pts = ss.pts || 0, reb = (ss.oreb || 0) + (ss.dreb || 0);
                        const missedFg = (ss.fga || 0) - (ss.fgm || 0), missedFt = (ss.fta || 0) - (ss.ftm || 0);
                        return ((pts + reb + (ss.ast || 0) * 1.5 + (ss.stl || 0) * 2 + (ss.blk || 0) * 2 - missedFg - missedFt * 0.5 - (ss.tov || 0) * 1.5) / ss.min) * 15;
                    }
                    // Get team totals for this player's team
                    const tmTotals = teamSeasonTotals.get(ss.team);
                    const tm_AST = tmTotals ? tmTotals.ast : lgTotals.ast;
                    const tm_FG = tmTotals ? tmTotals.fgm : lgTotals.fgm;
                    const uPER = hollingerUPER(
                        ss.min, ss.tpm || 0, ss.ast || 0, ss.fgm || 0, ss.fga || 0,
                        ss.ftm || 0, ss.fta || 0, ss.oreb || 0, ss.dreb || 0,
                        ss.stl || 0, ss.blk || 0, ss.tov || 0, ss.pf || 0,
                        tm_AST, tm_FG, lgTotals
                    );
                    if (uPER === null) return null;
                    // Normalize so league average = 15
                    return uPER * lgNormFactor;
                };

                // Helper to get PER color based on value
                const getPerColor = (per) => {
                    if (per === null || per === undefined) return '#64748b';
                    if (per >= 25) return '#22c55e';
                    if (per >= 20) return '#4ade80';
                    if (per >= 15) return '#a78bfa';
                    if (per >= 10) return '#fbbf24';
                    if (per >= 5) return '#fb923c';
                    return '#ef4444';
                };

                // Helper to get PER background based on value
                const getPerBackground = (per) => {
                    if (per === null || per === undefined) return 'rgba(100, 116, 139, 0.2)';
                    if (per >= 25) return 'rgba(34, 197, 94, 0.2)';
                    if (per >= 20) return 'rgba(74, 222, 128, 0.15)';
                    if (per >= 15) return 'rgba(139, 92, 246, 0.15)';
                    if (per >= 10) return 'rgba(251, 191, 36, 0.15)';
                    if (per >= 5) return 'rgba(251, 146, 60, 0.15)';
                    return 'rgba(239, 68, 68, 0.2)';
                };

                // Helper to get delta color for PER +/- vs season
                const getPerDeltaColor = (delta) => {
                    if (delta === null || delta === undefined) return '#64748b';
                    if (delta >= 5) return '#22c55e';
                    if (delta >= 2) return '#4ade80';
                    if (delta >= 0) return '#86efac';
                    if (delta >= -2) return '#fca5a5';
                    if (delta >= -5) return '#f87171';
                    return '#ef4444';
                };

                // V5.22: Calculate BPM for a player using their aggregated stats
                const calcPlayerBpm = (p) => {
                    if (!p || p.lpPoss < 1 || p.minutes < 0.1) return null;

                    // Use aggregated stats from playerBreakdown
                    const reMpg = p.minutes / 3; // Rough estimate (assume ~3 games worth of data)
                    const orebOpps = p.oreb + (p.drebV || p.dreb * 0.8); // Estimate opp dreb
                    const orbPct = orebOpps > 0 ? (p.oreb / orebOpps) * 100 : 0;
                    const drebOpps = p.dreb + (p.orebV || p.oreb * 0.3); // Estimate opp oreb
                    const drbPct = drebOpps > 0 ? (p.dreb / drebOpps) * 100 : 0;
                    const trbPct = (orebOpps + drebOpps) > 0 ? ((p.oreb + p.dreb) / (orebOpps + drebOpps)) * 100 : 0;
                    const stlPct = p.lpPoss > 0 ? (p.stl / p.lpPoss) * 100 : 0;
                    const opp2pa = p.lpPoss * 0.6; // Estimate opponent 2PA from possessions
                    const blkPct = opp2pa > 0 ? (p.blk / opp2pa) * 100 : 0;
                    const tmFgm = p.lpPoss * 0.45; // Estimate team FGM
                    const astPct = tmFgm > 0 ? (p.ast / tmFgm) * 100 : 0;
                    const playerPossUsed = (p.fga || p.pts75 * 0.8) + 0.44 * (p.fta || p.pts75 * 0.3) + p.tov;
                    const usgPct = p.usage || 20;
                    const tovPct = playerPossUsed > 0 ? (p.tov / playerPossUsed) * 100 : 0;
                    const tsPct = p.tsPct || 55;
                    const teamTsPct = 55; // League average
                    const threePAr = (p.threeA75 || 0) / Math.max(1, (p.rimA75 || 0) + (p.midA75 || 0) + (p.threeA75 || 0));

                    // BPM formula
                    const term1 = BPM_COEFFS.a * reMpg;
                    const term2 = BPM_COEFFS.b * orbPct;
                    const term3 = BPM_COEFFS.c * drbPct;
                    const term4 = BPM_COEFFS.d * stlPct;
                    const term5 = BPM_COEFFS.e * blkPct;
                    const term6 = BPM_COEFFS.f * astPct;
                    const term7 = -BPM_COEFFS.g * (usgPct / 100) * tovPct;
                    const scoringTerm = BPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                        (2 * (tsPct - teamTsPct) / 100 + BPM_COEFFS.i * astPct / 100 + BPM_COEFFS.j * (threePAr - lgAvg3PAr) - BPM_COEFFS.k);
                    const term9 = BPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;
                    const bpm = term1 + term2 + term3 + term4 + term5 + term6 + term7 + scoringTerm + term9;

                    // OBPM formula
                    const oTerm1 = OBPM_COEFFS.a * reMpg;
                    const oTerm2 = OBPM_COEFFS.b * orbPct;
                    const oTerm3 = OBPM_COEFFS.c * drbPct;
                    const oTerm4 = OBPM_COEFFS.d * stlPct;
                    const oTerm5 = OBPM_COEFFS.e * blkPct;
                    const oTerm6 = OBPM_COEFFS.f * astPct;
                    const oTerm7 = -OBPM_COEFFS.g * (usgPct / 100) * tovPct;
                    const oScoringTerm = OBPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                        (2 * (tsPct - teamTsPct) / 100 + OBPM_COEFFS.i * astPct / 100 + OBPM_COEFFS.j * (threePAr - lgAvg3PAr) - OBPM_COEFFS.k);
                    const oTerm9 = OBPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;
                    const obpm = oTerm1 + oTerm2 + oTerm3 + oTerm4 + oTerm5 + oTerm6 + oTerm7 + oScoringTerm + oTerm9;

                    return { bpm, obpm, dbpm: bpm - obpm };
                };
                
                return e('div', { className: 'section' },
                    e('div', { className: 'flex-between' },
                        e('h2', { className: 'section-title', style: { color: '#a78bfa' }}, '👤 Player Breakdown (Per 75 Possessions)'),
                        e('div', { style: { display: 'flex', gap: '8px', alignItems: 'center' }},
                            hasLeagueData && e('span', { style: { fontSize: '11px', color: '#94a3b8' }}, 
                                '📊 League: ' + leaguePlayerAverages.playerCount + ' players'
                            )
                        )
                    ),
                    
                    // Description and context
                    e('div', { style: { marginBottom: '20px', padding: '12px', background: 'rgba(139, 92, 246, 0.1)', borderRadius: '8px', fontSize: '12px' }},
                        afc >= 1 
                            ? e('span', null, 'Players in lineups with: ', e('strong', { style: { color: '#a78bfa' }}, Object.values(selPlayers).filter(p => p !== '').join(', ')))
                            : e('span', null, 'All players for ', e('strong', { style: { color: '#a78bfa' }}, team)),
                        hasSeasonData && e('span', { style: { marginLeft: '12px', color: '#fbbf24' }}, '📈 Season comparison enabled'),
                        e('div', { style: { marginTop: '8px', opacity: 0.8 }}, 
                            '💡 Stats calculated per 75 lineup possessions (Dean Oliver formula). ',
                            hasLeagueData && 'Color coding shows league-wide percentile rankings.'
                        )
                    ),
                    
                    // Color legend
                    hasLeagueData && e('div', { className: 'color-legend', style: { marginBottom: '20px' }},
                        e('span', { style: { fontSize: '11px', color: '#94a3b8', marginRight: '8px' }}, 'League Rank:'),
                        e('span', { className: 'legend-item legend-excellent' }, '80+ Elite'),
                        e('span', { className: 'legend-item legend-good' }, '60-79 Good'),
                        e('span', { className: 'legend-item legend-average' }, '40-59 Average'),
                        e('span', { className: 'legend-item legend-below' }, '20-39 Below'),
                        e('span', { className: 'legend-item legend-poor' }, '<20 Poor')
                    ),
                    
                    // V4.9.8: RAPM status and calculate button (team-wide mode only)
                    isTeamWideMode && e('div', { style: { marginBottom: '20px', padding: '12px', background: 'rgba(99, 102, 241, 0.1)', borderRadius: '8px', display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '8px' }},
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                            e('span', { style: { fontSize: '12px', fontWeight: 'bold', color: '#a78bfa' }}, '📊 On-Offs / RAPM'),
                            hasRapmData && e('span', { style: { 
                                fontSize: '11px', 
                                padding: '4px 10px', 
                                borderRadius: '12px', 
                                background: 'rgba(34, 197, 94, 0.2)', 
                                color: '#22c55e',
                                border: '1px solid rgba(34, 197, 94, 0.4)'
                            }}, 
                                '✓ RAPM Ready (' + (playerRapmStats?.playerCount || 0) + ' players)'
                            ),
                            isCalculatingPlayerRAPM && e('span', { style: { 
                                fontSize: '11px', 
                                padding: '4px 10px', 
                                borderRadius: '12px', 
                                background: 'rgba(251, 191, 36, 0.2)', 
                                color: '#fbbf24',
                                border: '1px solid rgba(251, 191, 36, 0.4)'
                            }}, 
                                '⏳ Computing RAPM... ' + playerRapmProgress + '%'
                            )
                        ),
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                            !hasRapmData && !isCalculatingPlayerRAPM && hasStintsData && e('button', { 
                                style: { 
                                    fontSize: '11px', 
                                    padding: '6px 12px', 
                                    borderRadius: '12px', 
                                    background: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)', 
                                    color: 'white',
                                    border: 'none',
                                    cursor: 'pointer',
                                    fontWeight: '600'
                                },
                                onClick: triggerPlayerRAPMCalculation
                            }, 
                                '📊 Calculate RAPM (' + stintsData.length + ' stints)'
                            ),
                            // V6.0: Bayesian Box APM calculation button (Intraocular methodology)
                            !hasRapmData && !isCalculatingAPM && hasStintsData && seasonStatsMap.size > 0 && e('button', {
                                style: { 
                                    fontSize: '11px', 
                                    padding: '6px 12px', 
                                    borderRadius: '12px', 
                                    background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', 
                                    color: 'white',
                                    border: 'none',
                                    cursor: 'pointer',
                                    fontWeight: '600'
                                },
                                onClick: triggerAPMCalculation
                            }, 
                                '🔮 Bayesian Box APM'
                            ),
                            hasRapmData && !playerApmStats && !isCalculatingAPM && seasonStatsMap.size > 0 && e('button', {
                                style: { 
                                    fontSize: '11px', 
                                    padding: '6px 12px', 
                                    borderRadius: '12px', 
                                    background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', 
                                    color: 'white',
                                    border: 'none',
                                    cursor: 'pointer',
                                    fontWeight: '600'
                                },
                                onClick: triggerAPMCalculation
                            }, 
                                '🔮 Bayesian Box APM'
                            ),
                            isCalculatingAPM && e('span', { style: { fontSize: '11px', color: '#f59e0b' }},
                                '🔮 Computing Bayesian Box APM... ' + apmProgress + '%'
                            ),
                            playerApmStats && playerApmStats.players && e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' }},
                                e('span', { style: { 
                                    fontSize: '11px', 
                                    padding: '4px 10px', 
                                    borderRadius: '12px', 
                                    background: 'rgba(245, 158, 11, 0.2)', 
                                    color: '#fbbf24',
                                    border: '1px solid rgba(245, 158, 11, 0.4)'
                                }}, 
                                    '🔮 Bayesian Box APM (λ=' + (playerApmStats.lambda || rapmLambda) + ', ' + (playerApmStats?.playerCount || 0) + ' players)'
                                ),
                                e('button', {
                                    style: { padding: '4px 8px', fontSize: '10px', background: rapmLambda !== playerApmStats.lambda ? '#f59e0b' : '#1e293b', border: '1px solid #d97706', borderRadius: '4px', color: rapmLambda !== playerApmStats.lambda ? 'white' : '#fbbf24', cursor: 'pointer' },
                                    onClick: triggerAPMCalculation
                                }, rapmLambda !== playerApmStats.lambda ? '⚡ Recalc' : '↻ Recalc')
                            ),
                            !hasRapmData && !isCalculatingPlayerRAPM && !hasStintsData && e('span', { style: { 
                                fontSize: '11px', 
                                padding: '4px 10px', 
                                borderRadius: '12px', 
                                background: 'rgba(100, 116, 139, 0.2)', 
                                color: '#94a3b8',
                                border: '1px solid rgba(100, 116, 139, 0.4)'
                            }}, 
                                '⚠️ Upload stints.csv for RAPM'
                            ),
                            hasRapmData && e('span', { style: { fontSize: '10px', color: '#94a3b8' }}, 
                                'Expand player cards to view RAPM breakdown'
                            )
                        )
                    ),
                    
                    // Player cards
                    playerBreakdown.slice(0, 25).map((p, i) => {
                        const ss = p.seasonStats;
                        const hasS = p.hasSeason;
                        
                        // Calculate percentiles for each stat
                        const pcts = hasLeagueData ? {
                            pts75: calcLeaguePercentile(p.pts75, leaguePlayerAverages.statArrays.pts75, true),
                            reb75: calcLeaguePercentile(p.reb75, leaguePlayerAverages.statArrays.reb75, true),
                            oreb75: calcLeaguePercentile(p.oreb75, leaguePlayerAverages.statArrays.oreb75, true),
                            dreb75: calcLeaguePercentile(p.dreb75, leaguePlayerAverages.statArrays.dreb75, true),
                            ast75: calcLeaguePercentile(p.ast75, leaguePlayerAverages.statArrays.ast75, true),
                            stl75: calcLeaguePercentile(p.stl75, leaguePlayerAverages.statArrays.stl75, true),
                            blk75: calcLeaguePercentile(p.blk75, leaguePlayerAverages.statArrays.blk75, true),
                            tov75: calcLeaguePercentile(p.tov75, leaguePlayerAverages.statArrays.tov75, false), // Lower is better for TOV
                            tpc75: calcLeaguePercentile(p.tpc75 || 0, leaguePlayerAverages.statArrays.tpc75, true),
                            tsPct: calcLeaguePercentile(p.tsPct || 0, leaguePlayerAverages.statArrays.tsPct, true),
                            rimPct: calcLeaguePercentile(p.rimPct, leaguePlayerAverages.statArrays.rimPct, true),
                            midPct: calcLeaguePercentile(p.midPct, leaguePlayerAverages.statArrays.midPct, true),
                            threePct: calcLeaguePercentile(p.threePct, leaguePlayerAverages.statArrays.threePct, true),
                            rimA75: calcLeaguePercentile(p.rimA75, leaguePlayerAverages.statArrays.rimA75, true),
                            midA75: calcLeaguePercentile(p.midA75, leaguePlayerAverages.statArrays.midA75, true),
                            threeA75: calcLeaguePercentile(p.threeA75, leaguePlayerAverages.statArrays.threeA75, true),
                            astUsgRatio: calcLeaguePercentile(p.astUsgRatio || 0, leaguePlayerAverages.statArrays.astUsgRatio, true)
                        } : {};
                        
                        // Calculate TS% relative to league average
                        const leagueTsAvg = hasLeagueData ? leaguePlayerAverages.averages.tsPct : 55;
                        const tsDiff = (p.tsPct || 0) - leagueTsAvg;
                        
                        // Get assist breakdown for this player from assistComboData
                        const playerAssistBreakdown = (() => {
                            if (!assistComboData.length) return null;
                            const playerNorm = normalizePlayerName(p.player);
                            const playerAssists = assistComboData.filter(d => 
                                d.Team === team && normalizePlayerName(d.Assister_Name || '') === playerNorm
                            );
                            if (playerAssists.length === 0) return null;
                            
                            let twos = 0, threes = 0;
                            playerAssists.forEach(d => {
                                twos += parseFloat(d.Twos_Assisted) || 0;
                                threes += parseFloat(d.Threes_Assisted) || 0;
                            });
                            const total = twos + threes;
                            if (total === 0) return null;
                            
                            return {
                                twos,
                                threes,
                                total,
                                twosPct: (twos / total) * 100,
                                threesPct: (threes / total) * 100
                            };
                        })();
                        
                        // Calculate PER for this player in these lineups
                        const playerPer = calcPlayerPER(p);
                        // Calculate season average PER for comparison
                        const seasonPer = hasS ? calcSeasonPER(ss) : null;
                        const perDelta = (playerPer !== null && seasonPer !== null) ? playerPer - seasonPer : null;

                        return e('div', { key: i, className: 'player-card', style: { border: '1px solid rgba(139, 92, 246, 0.3)' }},
                            // Header with player photo, name and PER badge
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '8px' }},
                                e('div', { className: 'player-card-header', style: { marginBottom: 0, flex: 1 }},
                                    e(PlayerPhoto, { playerName: p.player, teamName: team || '', size: 40 }),
                                    e('div', { className: 'player-name', style: { marginBottom: 0 }},
                                        p.player,
                                        hasS && e('span', { style: { marginLeft: '8px', fontSize: '12px', color: '#10b981' }}, '✓ Season data')
                                    )
                                ),
                                // PER badge with +/- vs season visualizer
                                playerPer !== null && e('div', {
                                    style: {
                                        display: 'flex',
                                        gap: '8px',
                                        alignItems: 'center'
                                    }
                                },
                                    // Main PER value
                                    e('div', {
                                        style: {
                                            padding: '6px 12px',
                                            borderRadius: '8px',
                                            background: getPerBackground(playerPer),
                                            border: '1px solid ' + getPerColor(playerPer) + '44',
                                            textAlign: 'center',
                                            minWidth: '56px'
                                        }
                                    },
                                        e('div', { style: { fontSize: '9px', color: '#94a3b8', marginBottom: '2px' }}, 'PER'),
                                        e('div', { style: { fontSize: '16px', fontWeight: '700', color: getPerColor(playerPer) }},
                                            playerPer.toFixed(1)
                                        )
                                    ),
                                    // +/- vs Season Average PER visualizer
                                    perDelta !== null && e('div', {
                                        style: {
                                            padding: '6px 10px',
                                            borderRadius: '8px',
                                            background: perDelta >= 0
                                                ? 'rgba(74, 222, 128, 0.1)'
                                                : 'rgba(248, 113, 113, 0.1)',
                                            border: '1px solid ' + (perDelta >= 0
                                                ? 'rgba(74, 222, 128, 0.3)'
                                                : 'rgba(248, 113, 113, 0.3)'),
                                            textAlign: 'center',
                                            minWidth: '80px'
                                        }
                                    },
                                        e('div', { style: { fontSize: '8px', color: '#94a3b8', marginBottom: '3px' }}, 'vs Season'),
                                        e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px' }},
                                            // Delta arrow + value
                                            e('div', { style: {
                                                fontSize: '14px', fontWeight: '700',
                                                color: getPerDeltaColor(perDelta)
                                            }},
                                                (perDelta >= 0 ? '+' : '') + perDelta.toFixed(1)
                                            )
                                        ),
                                        // Visual bar showing direction/magnitude
                                        e('div', { style: {
                                            marginTop: '3px',
                                            height: '4px',
                                            borderRadius: '2px',
                                            background: 'rgba(255,255,255,0.1)',
                                            overflow: 'hidden',
                                            position: 'relative'
                                        }},
                                            e('div', { style: {
                                                position: 'absolute',
                                                top: 0,
                                                height: '100%',
                                                borderRadius: '2px',
                                                left: perDelta >= 0 ? '50%' : (50 - Math.min(Math.abs(perDelta) * 3, 50)) + '%',
                                                width: Math.min(Math.abs(perDelta) * 3, 50) + '%',
                                                background: perDelta >= 0
                                                    ? 'linear-gradient(90deg, #4ade80, #22c55e)'
                                                    : 'linear-gradient(90deg, #ef4444, #f87171)',
                                                transition: 'all 0.3s ease'
                                            }})
                                        ),
                                        // Season avg label
                                        e('div', { style: { fontSize: '8px', color: '#64748b', marginTop: '2px' }},
                                            'Szn: ' + seasonPer.toFixed(1)
                                        )
                                    )
                                )
                            ),
                            e('div', { style: { display: 'flex', gap: '16px', marginBottom: '12px', fontSize: '13px', flexWrap: 'wrap' }},
                                e('span', null, '⏱️ ' + p.minutes.toFixed(1) + ' min'),
                                e('span', { style: { color: '#06b6d4' }}, '🎯 ' + Math.round(p.lpPoss) + ' poss'),
                                hasS && e('span', { style: { color: '#94a3b8' }}, '(Season: ' + ss.min.toFixed(0) + ' total / ' + ss.mpg.toFixed(1) + ' MPG)'),
                                e('span', { style: { color: '#f59e0b' }}, '📊 Usage: ' + p.usage.toFixed(1) + '%'),
                                hasS && e('span', { style: { color: '#94a3b8' }}, '(Season USG: ' + ss.usg.toFixed(1) + '%)')
                            ), 
                            
                            // Main stats grid - Per 75 possessions
                            e('div', { style: { marginBottom: '12px' }},
                                e('div', { style: { fontSize: '12px', fontWeight: 'bold', marginBottom: '8px', color: '#a78bfa' }}, 'Box Score (Per 75 Possessions)'),
                                e('div', { className: 'player-per75-wrapper' },
                                e('div', { className: 'player-stats-grid', style: { gridTemplateColumns: 'repeat(9, 1fr)' }},
                                    e(StatWithPct, { value: p.pts75, pct: hasLeagueData ? pcts.pts75 : 50, label: 'PTS', higherBetter: true }),
                                    e(StatWithPct, { value: p.reb75, pct: hasLeagueData ? pcts.reb75 : 50, label: 'REB', higherBetter: true }),
                                    e(StatWithPct, { value: p.oreb75, pct: hasLeagueData ? pcts.oreb75 : 50, label: 'OREB', higherBetter: true }),
                                    e(StatWithPct, { value: p.dreb75, pct: hasLeagueData ? pcts.dreb75 : 50, label: 'DREB', higherBetter: true }),
                                    e(StatWithPct, { value: p.ast75, pct: hasLeagueData ? pcts.ast75 : 50, label: 'AST', higherBetter: true }),
                                    e(StatWithPct, { value: p.astUsgRatio || 0, pct: hasLeagueData ? pcts.astUsgRatio : 50, label: 'AST/USG', higherBetter: true }),
                                    e(StatWithPct, { value: p.stl75, pct: hasLeagueData ? pcts.stl75 : 50, label: 'STL', higherBetter: true }),
                                    e(StatWithPct, { value: p.blk75, pct: hasLeagueData ? pcts.blk75 : 50, label: 'BLK', higherBetter: true }),
                                    e(StatWithPct, { value: p.tov75, pct: hasLeagueData ? pcts.tov75 : 50, label: 'TOV', higherBetter: false })
                                )
                            ) // close player-per75-wrapper
                            ),

                            // Raw totals row
                            e('div', { style: { marginBottom: '12px', padding: '8px', background: 'rgba(0,0,0,0.2)', borderRadius: '6px' }},
                                e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '6px' }}, 'Raw Totals (in filtered lineups)'),
                                e('div', { style: { display: 'flex', gap: '16px', fontSize: '12px', flexWrap: 'wrap' }},
                                    e('span', null, 'PTS: ', e('strong', null, p.pts.toFixed(0))),
                                    e('span', null, 'REB: ', e('strong', null, p.reb.toFixed(0)), ' (', e('span', { style: { color: '#4ade80' }}, 'O:', p.oreb.toFixed(0)), ' + ', e('span', { style: { color: '#60a5fa' }}, 'D:', p.dreb.toFixed(0)), ')'),
                                    e('span', null, 'AST: ', e('strong', null, p.ast.toFixed(0))),
                                    e('span', null, 'STL: ', e('strong', null, p.stl.toFixed(0))),
                                    e('span', null, 'BLK: ', e('strong', null, p.blk.toFixed(0))),
                                    e('span', null, 'TOV: ', e('strong', null, p.tov.toFixed(0)))
                                )
                            ),
                            
                            // Shot profile with enhanced att/75 display
                            e('div', { style: { marginTop: '12px' }}, 
                                e('div', { style: { fontSize: '12px', fontWeight: 'bold', marginBottom: '8px' }}, 
                                    'Shot Profile', 
                                    hasS && e('span', { style: { fontWeight: 'normal', color: '#94a3b8', marginLeft: '8px' }}, '| vs Season')
                                ), 
                                e('div', { className: 'grid-3', style: { gap: '8px' }}, 
                                    e('div', { className: hasLeagueData ? getLeaguePerfClass(pcts.rimPct) : '', style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }}, 
                                        e('div', { style: { fontSize: '10px', marginBottom: '2px' }}, 'Rim'), 
                                        e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, p.rimPct.toFixed(0) + '%'), 
                                        hasLeagueData && e('div', { style: { fontSize: '9px', marginBottom: '4px' }}, e('span', { style: { padding: '1px 4px', borderRadius: '3px', background: 'rgba(255,255,255,0.1)' }}, Math.round(pcts.rimPct) + 'th')),
                                        // Enhanced att/75 with color coding
                                        e('div', { className: hasLeagueData ? getLeaguePerfClass(pcts.rimA75) : '', style: { marginTop: '6px', padding: '4px 6px', borderRadius: '4px', display: 'inline-block' }},
                                            e('div', { style: { fontSize: '13px', fontWeight: 'bold' }}, p.rimA75.toFixed(1) + ' att/75'),
                                            hasLeagueData && e('div', { style: { fontSize: '8px', opacity: 0.8 }}, Math.round(pcts.rimA75) + 'th pct')
                                        ),
                                        hasS && e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '4px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '4px' }}, 
                                            'Szn: ' + ss.seasonRimPct.toFixed(0) + '%',
                                            e('span', { className: 'scv-delta ' + getCompClass(p.rimPct - ss.seasonRimPct, true), style: { marginLeft: '4px' }}, (p.rimPct - ss.seasonRimPct >= 0 ? '+' : '') + (p.rimPct - ss.seasonRimPct).toFixed(0))
                                        )
                                    ), 
                                    e('div', { className: hasLeagueData ? getLeaguePerfClass(pcts.midPct) : '', style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }}, 
                                        e('div', { style: { fontSize: '10px', marginBottom: '2px' }}, 'Mid'), 
                                        e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, p.midPct.toFixed(0) + '%'), 
                                        hasLeagueData && e('div', { style: { fontSize: '9px', marginBottom: '4px' }}, e('span', { style: { padding: '1px 4px', borderRadius: '3px', background: 'rgba(255,255,255,0.1)' }}, Math.round(pcts.midPct) + 'th')),
                                        // Enhanced att/75 with color coding
                                        e('div', { className: hasLeagueData ? getLeaguePerfClass(pcts.midA75) : '', style: { marginTop: '6px', padding: '4px 6px', borderRadius: '4px', display: 'inline-block' }},
                                            e('div', { style: { fontSize: '13px', fontWeight: 'bold' }}, p.midA75.toFixed(1) + ' att/75'),
                                            hasLeagueData && e('div', { style: { fontSize: '8px', opacity: 0.8 }}, Math.round(pcts.midA75) + 'th pct')
                                        ),
                                        hasS && e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '4px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '4px' }}, 
                                            'Szn: ' + ss.seasonMidPct.toFixed(0) + '%',
                                            e('span', { className: 'scv-delta ' + getCompClass(p.midPct - ss.seasonMidPct, true), style: { marginLeft: '4px' }}, (p.midPct - ss.seasonMidPct >= 0 ? '+' : '') + (p.midPct - ss.seasonMidPct).toFixed(0))
                                        )
                                    ), 
                                    e('div', { className: hasLeagueData ? getLeaguePerfClass(pcts.threePct) : '', style: { padding: '10px', borderRadius: '6px', textAlign: 'center' }}, 
                                        e('div', { style: { fontSize: '10px', marginBottom: '2px' }}, '3PT'), 
                                        e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, p.threePct.toFixed(0) + '%'), 
                                        hasLeagueData && e('div', { style: { fontSize: '9px', marginBottom: '4px' }}, e('span', { style: { padding: '1px 4px', borderRadius: '3px', background: 'rgba(255,255,255,0.1)' }}, Math.round(pcts.threePct) + 'th')),
                                        // Enhanced att/75 with color coding
                                        e('div', { className: hasLeagueData ? getLeaguePerfClass(pcts.threeA75) : '', style: { marginTop: '6px', padding: '4px 6px', borderRadius: '4px', display: 'inline-block' }},
                                            e('div', { style: { fontSize: '13px', fontWeight: 'bold' }}, p.threeA75.toFixed(1) + ' att/75'),
                                            hasLeagueData && e('div', { style: { fontSize: '8px', opacity: 0.8 }}, Math.round(pcts.threeA75) + 'th pct')
                                        ),
                                        hasS && e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '4px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '4px' }}, 
                                            'Szn: ' + ss.seasonThreePct.toFixed(0) + '%',
                                            e('span', { className: 'scv-delta ' + getCompClass(p.threePct - ss.seasonThreePct, true), style: { marginLeft: '4px' }}, (p.threePct - ss.seasonThreePct >= 0 ? '+' : '') + (p.threePct - ss.seasonThreePct).toFixed(0))
                                        )
                                    )
                                )
                            ),
                            
                            // TS% relative to league average
                            e('div', { style: { marginTop: '12px' }},
                                e('div', { className: hasLeagueData ? getLeaguePerfClass(pcts.tsPct) : '', style: { padding: '12px', borderRadius: '8px', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }},
                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' }},
                                        e('div', { style: { fontSize: '11px', fontWeight: 'bold' }}, '🎯 True Shooting %'),
                                        e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, (p.tsPct || 0).toFixed(1) + '%')
                                    ),
                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' }},
                                        e('div', { style: { textAlign: 'center' }},
                                            e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: tsDiff >= 0 ? '#22c55e' : '#ef4444' }}, (tsDiff >= 0 ? '+' : '') + tsDiff.toFixed(1)),
                                            e('div', { style: { fontSize: '9px', opacity: 0.7 }}, 'vs Lg Avg (' + leagueTsAvg.toFixed(1) + '%)')
                                        ),
                                        hasLeagueData && e('div', { style: { 
                                            padding: '4px 8px', 
                                            borderRadius: '4px', 
                                            background: pcts.tsPct >= 80 ? 'rgba(34,197,94,0.3)' : pcts.tsPct >= 60 ? 'rgba(132,204,22,0.3)' : pcts.tsPct >= 40 ? 'rgba(234,179,8,0.3)' : pcts.tsPct >= 20 ? 'rgba(249,115,22,0.3)' : 'rgba(239,68,68,0.3)',
                                            fontSize: '11px',
                                            fontWeight: '600'
                                        }}, Math.round(pcts.tsPct) + 'th pct')
                                    )
                                )
                            ),
                            
                            // TPC and Assist Breakdown row
                            e('div', { style: { marginTop: '12px', display: 'grid', gridTemplateColumns: (p.tpc > 0 && playerAssistBreakdown) ? '1fr 1fr' : '1fr', gap: '12px' }},
                                // TPC card with percentile
                                (p.tpc > 0) && e('div', { className: hasLeagueData && pcts.tpc75 ? getLeaguePerfClass(pcts.tpc75) : '', style: { padding: '12px', borderRadius: '8px', background: hasLeagueData && pcts.tpc75 ? undefined : 'rgba(245, 158, 11, 0.15)', border: hasLeagueData && pcts.tpc75 ? undefined : '1px solid rgba(245, 158, 11, 0.3)' }},
                                    e('div', { style: { fontSize: '11px', color: '#f59e0b', marginBottom: '6px', fontWeight: 'bold' }}, '⚡ Total Points Created'),
                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' }},
                                        e('div', { style: { textAlign: 'center' }},
                                            e('div', { style: { fontSize: '24px', fontWeight: 'bold', color: '#f59e0b' }}, (p.tpc75 || 0).toFixed(1)),
                                            e('div', { style: { fontSize: '10px', opacity: 0.8 }}, 'TPC/75')
                                        ),
                                        hasLeagueData && pcts.tpc75 !== undefined && e('div', { style: { 
                                            padding: '2px 6px', 
                                            borderRadius: '4px', 
                                            background: pcts.tpc75 >= 80 ? 'rgba(34,197,94,0.3)' : pcts.tpc75 >= 60 ? 'rgba(132,204,22,0.3)' : pcts.tpc75 >= 40 ? 'rgba(234,179,8,0.3)' : pcts.tpc75 >= 20 ? 'rgba(249,115,22,0.3)' : 'rgba(239,68,68,0.3)',
                                            fontSize: '10px',
                                            fontWeight: '600'
                                        }}, Math.round(pcts.tpc75) + 'th pct'),
                                        e('div', { style: { fontSize: '11px', opacity: 0.7 }},
                                            e('div', null, 'Raw: ' + (p.tpc || 0).toFixed(0)),
                                            e('div', null, '/100: ' + (p.tpc100 || 0).toFixed(1))
                                        )
                                    )
                                ),
                                
                                // Assist breakdown (2PT vs 3PT)
                                playerAssistBreakdown && e('div', { style: { padding: '12px', borderRadius: '8px', background: 'rgba(16, 185, 129, 0.1)', border: '1px solid rgba(16, 185, 129, 0.3)' }},
                                    e('div', { style: { fontSize: '11px', color: '#10b981', marginBottom: '6px', fontWeight: 'bold' }}, '🎯 Assist Breakdown'),
                                    e('div', { style: { marginBottom: '8px' }},
                                        // Visual bar
                                        e('div', { style: { display: 'flex', height: '20px', borderRadius: '4px', overflow: 'hidden' }},
                                            playerAssistBreakdown.twosPct > 0 && e('div', { style: { 
                                                width: playerAssistBreakdown.twosPct + '%', 
                                                background: 'linear-gradient(135deg, #f97316, #ea580c)',
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                fontSize: '10px',
                                                fontWeight: 'bold',
                                                color: 'white',
                                                textShadow: '1px 1px 2px rgba(0,0,0,0.5)'
                                            }}, playerAssistBreakdown.twosPct >= 15 ? playerAssistBreakdown.twosPct.toFixed(0) + '%' : ''),
                                            playerAssistBreakdown.threesPct > 0 && e('div', { style: { 
                                                width: playerAssistBreakdown.threesPct + '%', 
                                                background: 'linear-gradient(135deg, #3b82f6, #2563eb)',
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                fontSize: '10px',
                                                fontWeight: 'bold',
                                                color: 'white',
                                                textShadow: '1px 1px 2px rgba(0,0,0,0.5)'
                                            }}, playerAssistBreakdown.threesPct >= 15 ? playerAssistBreakdown.threesPct.toFixed(0) + '%' : '')
                                        )
                                    ),
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '11px' }},
                                        e('span', { style: { color: '#f97316' }}, '2PT: ', e('strong', null, playerAssistBreakdown.twos.toFixed(0)), ' (', playerAssistBreakdown.twosPct.toFixed(1), '%)'),
                                        e('span', { style: { color: '#3b82f6' }}, '3PT: ', e('strong', null, playerAssistBreakdown.threes.toFixed(0)), ' (', playerAssistBreakdown.threesPct.toFixed(1), '%)'),
                                        e('span', { style: { opacity: 0.7 }}, 'Total: ', e('strong', null, playerAssistBreakdown.total.toFixed(0)))
                                    )
                                )
                            ),
                            
                            // V4.9.8: RAPM dropdown (only in team-wide mode with stints.csv)
                            showRapmSection && e('div', { style: { marginTop: '12px' }},
                                e('button', { 
                                    onClick: () => toggleRapmExpand(p.player),
                                    style: { 
                                        width: '100%',
                                        padding: '10px 12px',
                                        background: expandedRapmPlayers[p.player] ? 'linear-gradient(135deg, #6366f1, #8b5cf6)' : 'rgba(99, 102, 241, 0.15)',
                                        border: '1px solid rgba(99, 102, 241, 0.4)',
                                        borderRadius: '8px',
                                        color: 'white',
                                        cursor: 'pointer',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'space-between',
                                        fontSize: '12px',
                                        fontWeight: 'bold'
                                    }
                                },
                                    e('span', null, '📊 On-Offs / RAPM'),
                                    e('span', { style: { fontSize: '14px' }}, expandedRapmPlayers[p.player] ? '▲' : '▼')
                                ),
                                
                                expandedRapmPlayers[p.player] && (() => {
                                    // Get RAPM stats for this player
                                    const netRapm = getPlayerRapmStat(p.player, 'net');
                                    const offRapm = getPlayerRapmStat(p.player, 'off');
                                    const defRapm = getPlayerRapmStat(p.player, 'def');
                                    
                                    // Four Factors Offense
                                    const efgOff = getPlayerRapmStat(p.player, 'offEfg');
                                    const tovOff = getPlayerRapmStat(p.player, 'offTov');
                                    const orebOff = getPlayerRapmStat(p.player, 'offOreb');
                                    const ftrOff = getPlayerRapmStat(p.player, 'offFtR');
                                    
                                    // Four Factors Defense
                                    const efgDef = getPlayerRapmStat(p.player, 'defEfg');
                                    const tovDef = getPlayerRapmStat(p.player, 'defTov');
                                    const drebDef = getPlayerRapmStat(p.player, 'defOreb');
                                    const ftrDef = getPlayerRapmStat(p.player, 'defFtR');
                                    
                                    // RAPM stat card component
                                    const RapmStatCard = ({ label, value, pct, higherBetter = true, isMain = false }) => {
                                        if (value === null || value === undefined) return null;
                                        const perfClass = getLeaguePerfClass(pct);
                                        return e('div', { 
                                            className: perfClass, 
                                            style: { 
                                                padding: isMain ? '12px' : '8px', 
                                                borderRadius: '6px', 
                                                textAlign: 'center',
                                                minWidth: isMain ? '80px' : '60px'
                                            }
                                        },
                                            e('div', { style: { fontSize: isMain ? '10px' : '9px', marginBottom: '2px', opacity: 0.9 }}, label),
                                            e('div', { style: { fontSize: isMain ? '18px' : '14px', fontWeight: 'bold' }}, 
                                                (value >= 0 ? '+' : '') + value.toFixed(2)
                                            ),
                                            e('div', { style: { 
                                                fontSize: '8px', 
                                                marginTop: '2px',
                                                padding: '1px 4px',
                                                borderRadius: '3px',
                                                background: 'rgba(255,255,255,0.1)',
                                                display: 'inline-block'
                                            }}, Math.round(pct) + 'th')
                                        );
                                    };
                                    
                                    return e('div', { style: { 
                                        marginTop: '8px', 
                                        padding: '12px', 
                                        background: 'rgba(99, 102, 241, 0.1)', 
                                        borderRadius: '8px',
                                        border: '1px solid rgba(99, 102, 241, 0.3)'
                                    }},
                                        // Main RAPM ratings
                                        e('div', { style: { marginBottom: '12px' }},
                                            e('div', { style: { fontSize: '11px', fontWeight: 'bold', marginBottom: '8px', color: '#a78bfa' }}, 'RAPM Ratings'),
                                            e('div', { style: { display: 'flex', gap: '8px', justifyContent: 'center' }},
                                                netRapm && e(RapmStatCard, { 
                                                    label: 'NET', 
                                                    value: netRapm.rapm, 
                                                    pct: calcRapmPercentile(netRapm.rapm, 'net', true),
                                                    isMain: true 
                                                }),
                                                offRapm && e(RapmStatCard, { 
                                                    label: 'OFF', 
                                                    value: offRapm.rapm, 
                                                    pct: calcRapmPercentile(offRapm.rapm, 'off', true),
                                                    isMain: true 
                                                }),
                                                defRapm && e(RapmStatCard, { 
                                                    label: 'DEF', 
                                                    value: defRapm.rapm, 
                                                    pct: calcRapmPercentile(defRapm.rapm, 'def', false),
                                                    isMain: true 
                                                })
                                            )
                                        ),
                                        
                                        // Four Factors - Offense
                                        e('div', { style: { marginBottom: '12px' }},
                                            e('div', { style: { fontSize: '10px', fontWeight: 'bold', marginBottom: '6px', color: '#22c55e' }}, '⬆️ Four Factors (Offense)'),
                                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '6px' }},
                                                efgOff && e(RapmStatCard, { 
                                                    label: 'eFG%', 
                                                    value: efgOff.rapm, 
                                                    pct: calcRapmPercentile(efgOff.rapm, 'offEfg', true)
                                                }),
                                                tovOff && e(RapmStatCard, { 
                                                    label: 'TOV%', 
                                                    value: tovOff.rapm, 
                                                    pct: calcRapmPercentile(tovOff.rapm, 'offTov', false),
                                                    higherBetter: false
                                                }),
                                                orebOff && e(RapmStatCard, { 
                                                    label: 'OREB%', 
                                                    value: orebOff.rapm, 
                                                    pct: calcRapmPercentile(orebOff.rapm, 'offOreb', true)
                                                }),
                                                ftrOff && e(RapmStatCard, { 
                                                    label: 'FTR', 
                                                    value: ftrOff.rapm, 
                                                    pct: calcRapmPercentile(ftrOff.rapm, 'offFtR', true)
                                                })
                                            )
                                        ),
                                        
                                        // Four Factors - Defense
                                        e('div', null,
                                            e('div', { style: { fontSize: '10px', fontWeight: 'bold', marginBottom: '6px', color: '#ef4444' }}, '⬇️ Four Factors (Defense)'),
                                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '6px' }},
                                                efgDef && e(RapmStatCard, { 
                                                    label: 'eFG%', 
                                                    value: efgDef.rapm, 
                                                    pct: calcRapmPercentile(efgDef.rapm, 'defEfg', false),
                                                    higherBetter: false
                                                }),
                                                tovDef && e(RapmStatCard, { 
                                                    label: 'TOV%', 
                                                    value: tovDef.rapm, 
                                                    pct: calcRapmPercentile(tovDef.rapm, 'defTov', true)
                                                }),
                                                drebDef && e(RapmStatCard, { 
                                                    label: 'DREB%', 
                                                    value: drebDef.rapm, 
                                                    pct: calcRapmPercentile(drebDef.rapm, 'defOreb', true)
                                                }),
                                                ftrDef && e(RapmStatCard, { 
                                                    label: 'FTR', 
                                                    value: ftrDef.rapm, 
                                                    pct: calcRapmPercentile(ftrDef.rapm, 'defFtR', false),
                                                    higherBetter: false
                                                })
                                            )
                                        ),
                                        
                                        // Note about interpretation
                                        e('div', { style: { marginTop: '10px', fontSize: '9px', opacity: 0.7, textAlign: 'center' }},
                                            'RAPM: Points per 100 possessions added/saved vs league average. Lower DEF = better.'
                                        )
                                    );
                                })()
                            ),
                            
                            // Season comparison summary with color-coded cards
                            hasS && (() => {
                                const dPts = p.pts75 - ss.pts40, dAst = p.ast75 - ss.ast40;
                                const dTov = p.tov75 - ss.tov40, dThree = p.threePct - ss.seasonThreePct;
                                return e('div', { className: 'season-compare-section', style: { marginTop: '12px' }},
                                    e('div', { className: 'season-compare-title' }, '📈 Lineup vs Season Average Summary'),
                                    e('div', { className: 'season-compare-grid' },
                                        e('div', { className: 'season-compare-item ' + getCardClass(dPts, true) },
                                            e('div', { className: 'season-compare-label' }, 'PTS/75'),
                                            e('div', { className: 'season-compare-values' },
                                                e('span', { className: 'scv-lineup' }, p.pts75.toFixed(1)),
                                                e('span', { className: 'scv-season' }, '(' + ss.pts40.toFixed(1) + '/40)')
                                            ),
                                            e('div', { className: 'scv-delta ' + getCompClass(dPts, true), style: { marginTop: '3px', fontSize: '11px' } },
                                                (dPts >= 0 ? '▲ +' : '▼ ') + Math.abs(dPts).toFixed(1))
                                        ),
                                        e('div', { className: 'season-compare-item ' + getCardClass(dAst, true) },
                                            e('div', { className: 'season-compare-label' }, 'AST/75'),
                                            e('div', { className: 'season-compare-values' },
                                                e('span', { className: 'scv-lineup' }, p.ast75.toFixed(1)),
                                                e('span', { className: 'scv-season' }, '(' + ss.ast40.toFixed(1) + '/40)')
                                            ),
                                            e('div', { className: 'scv-delta ' + getCompClass(dAst, true), style: { marginTop: '3px', fontSize: '11px' } },
                                                (dAst >= 0 ? '▲ +' : '▼ ') + Math.abs(dAst).toFixed(1))
                                        ),
                                        e('div', { className: 'season-compare-item ' + getCardClass(dTov, false) },
                                            e('div', { className: 'season-compare-label' }, 'TOV/75'),
                                            e('div', { className: 'season-compare-values' },
                                                e('span', { className: 'scv-lineup' }, p.tov75.toFixed(1)),
                                                e('span', { className: 'scv-season' }, '(' + ss.tov40.toFixed(1) + '/40)')
                                            ),
                                            e('div', { className: 'scv-delta ' + getCompClass(dTov, false), style: { marginTop: '3px', fontSize: '11px' } },
                                                (dTov <= 0 ? '▼ ' : '▲ +') + Math.abs(dTov).toFixed(1))
                                        ),
                                        e('div', { className: 'season-compare-item ' + getCardClass(dThree, true) },
                                            e('div', { className: 'season-compare-label' }, '3PT%'),
                                            e('div', { className: 'season-compare-values' },
                                                e('span', { className: 'scv-lineup' }, p.threePct.toFixed(0) + '%'),
                                                e('span', { className: 'scv-season' }, '(' + ss.seasonThreePct.toFixed(0) + '%)')
                                            ),
                                            e('div', { className: 'scv-delta ' + getCompClass(dThree, true), style: { marginTop: '3px', fontSize: '11px' } },
                                                (dThree >= 0 ? '▲ +' : '▼ ') + Math.abs(dThree).toFixed(0) + '%')
                                        )
                                    )
                                );
                            })()
                        );
                    }),
                    
                    playerBreakdown.length > 25 && e('p', { style: { textAlign: 'center', marginTop: '16px', fontSize: '12px', color: '#94a3b8' }}, 
                        'Showing top 25 of ' + playerBreakdown.length + ' players by minutes'
                    ),
                    
                    // Methodology note
                    e('div', { 
                        style: { 
                            marginTop: '20px', 
                            padding: '12px', 
                            background: 'rgba(139, 92, 246, 0.1)', 
                            border: '1px solid rgba(139, 92, 246, 0.3)', 
                            borderRadius: '8px',
                            fontSize: '11px',
                            color: '#c4b5fd'
                        }
                    },
                        e('strong', { style: { color: '#a78bfa' }}, '📖 V4.9.8 Methodology: '),
                        'Stats normalized to per 75 lineup possessions using Dean Oliver formula (POSS = FGA - OREB + TOV + 0.44×FTA). ',
                        'Percentiles calculated against all ', leaguePlayerAverages?.playerCount || 0, ' players in dataset with 50+ lineup possessions. ',
                        'REB = OREB + DREB. Usage% = player possessions ÷ lineup possessions. ',
                        e('strong', null, 'Note: '), 'Season comparisons use per-40 minute baseline which differs from per-75 possession normalization.'
                    )
                );
            };

            // =======================================================================
            // V4.7: RAPM-ADJUSTED STATS SECTION (V2.0 with Uncertainty)
            // Displays opponent-adjusted statistics using ridge regression with confidence intervals
            // Off/Def/Net ratings derived from adjusted Four Factors via calcSimulatedRatings
            // =======================================================================
            const RAPMSection = () => {
                if (!fStats || !showRAPM) return null;
                
                // Handle error state
                if (rapmStats && rapmStats.error) {
                    return e('div', { className: 'section', style: { background: 'rgba(239, 68, 68, 0.1)', border: '2px solid rgba(239, 68, 68, 0.3)' }},
                        e('h2', { className: 'section-title', style: { color: '#f87171' }}, '⚠️ RAPM Calculation Error'),
                        e('p', { style: { color: '#fca5a5' }}, rapmStats.error)
                    );
                }
                
                if (!rapmStats || !rapmStats.stats || !leagueAverages) return null;
                
                const stats = rapmStats.stats;
                const isV2 = rapmStats.version === '2.0';
                
                // Helper to get RAPM adjustment and calculate adjusted value
                // V2.0: Uses pre-computed league averages with separate off/def values
                const getRAPMAdjusted = (statName, rawValue, isOffense = true) => {
                    const rapmData = stats[statName];
                    if (!rapmData) return { adj: rawValue, delta: 0, coverage: 0, oRAPM: 0, dRAPM: 0, leagueAvg: 0, se: 0, ci95: [0,0], significant: false };
                    
                    const oAdj = rapmData.oRAPM || 0;
                    const dAdj = rapmData.dRAPM || 0;
                    // Use correct league average based on offensive/defensive context
                    const leagueAvgOff = rapmData.leagueAvgOff || 0;
                    const leagueAvgDef = rapmData.leagueAvgDef || 0;
                    const isDefStat = rapmData.isDefStat || false;
                    const isDirect = rapmData.isDirect || false;
                    
                    // V2.0 uncertainty data
                    const oSE = rapmData.oSE || 0;
                    const dSE = rapmData.dSE || 0;
                    const oCI95 = rapmData.oCI95 || [0, 0];
                    const dCI95 = rapmData.dCI95 || [0, 0];
                    const oSignificant = rapmData.oSignificant || false;
                    const dSignificant = rapmData.dSignificant || false;
                    
                    let adjusted, rapmToShow, seToShow, ciToShow, isSignificant, leagueAvgToShow;
                    
                    if (isDirect) {
                        // Direct defensive model (STL%, BLK%): only defensive coefficient
                        adjusted = leagueAvgDef + dAdj;
                        rapmToShow = dAdj;
                        seToShow = dSE;
                        ciToShow = dCI95;
                        isSignificant = dSignificant;
                        leagueAvgToShow = leagueAvgDef;
                    } else if (isOffense) {
                        // Offensive stat: what we'd produce vs average opponent
                        adjusted = leagueAvgOff + oAdj;
                        rapmToShow = oAdj;
                        seToShow = oSE;
                        ciToShow = oCI95;
                        isSignificant = oSignificant;
                        leagueAvgToShow = leagueAvgOff;
                    } else {
                        // Defensive stat (what opponents produce against us)
                        // Positive dRAPM = good defense = opponents produce LESS than avg
                        adjusted = leagueAvgDef - dAdj;
                        rapmToShow = dAdj;
                        seToShow = dSE;
                        ciToShow = dCI95;
                        isSignificant = dSignificant;
                        leagueAvgToShow = leagueAvgDef;
                    }
                    
                    const delta = adjusted - rawValue;
                    
                    return { 
                        adj: adjusted, 
                        delta: delta,
                        coverage: rapmData.coverage || 0,
                        oRAPM: oAdj,
                        dRAPM: dAdj,
                        leagueAvg: leagueAvgToShow,
                        leagueAvgOff: leagueAvgOff,
                        leagueAvgDef: leagueAvgDef,
                        rapmValue: rapmToShow,
                        isDefStat: isDefStat,
                        isDirect: isDirect,
                        // V2.0 uncertainty
                        se: seToShow,
                        ci95: ciToShow,
                        significant: isSignificant,
                        oSE: oSE,
                        dSE: dSE
                    };
                };
                
                // Build adjusted Four Factors stats
                const adjStats = {
                    offEfg: getRAPMAdjusted('eFG%', fStats.offEfg, true),
                    defEfg: getRAPMAdjusted('eFG%', fStats.defEfg, false),
                    offTov: getRAPMAdjusted('TOV%', fStats.offTov, true),
                    defTov: getRAPMAdjusted('TOV%', fStats.defTov, false),
                    offOreb: getRAPMAdjusted('OREB%', fStats.offOreb, true),
                    defOreb: getRAPMAdjusted('OREB%', fStats.defOreb, false),
                    offFtR: getRAPMAdjusted('FTRate', fStats.offFtR, true),
                    defFtR: getRAPMAdjusted('FTRate', fStats.defFtR, false),
                    astPct: getRAPMAdjusted('AST%', fStats.astPct, true),
                    stlPct: getRAPMAdjusted('STL%', fStats.stlPct, false),
                    blkPct: getRAPMAdjusted('BLK%', fStats.blkPct, false),
                };
                
                // V4.7: Derive Off/Def/Net ratings from RAPM-adjusted Four Factors 
                // using the same formula as Simulated Ratings
                const rapmAdjustedFF = {
                    offEfg: adjStats.offEfg.adj,
                    offTov: adjStats.offTov.adj,
                    offOreb: adjStats.offOreb.adj,
                    offFtR: adjStats.offFtR.adj,
                    defEfg: adjStats.defEfg.adj,
                    defTov: adjStats.defTov.adj,
                    defOreb: adjStats.defOreb.adj,
                    defFtR: adjStats.defFtR.adj
                };
                
                // Calculate simulated ratings from RAPM-adjusted Four Factors
                const simRatings = calcSimulatedRatings(rapmAdjustedFF, leagueAverages);
                const rawSimRatings = calcSimulatedRatings(fStats, leagueAverages);
                
                // Use simulated ratings for display
                const adjOffRtg = simRatings ? simRatings.ortg : fStats.off;
                const adjDefRtg = simRatings ? simRatings.drtg : fStats.def;
                const adjNetRtg = simRatings ? simRatings.net : (fStats.off - fStats.def);
                
                const rawOffRtg = rawSimRatings ? rawSimRatings.ortg : fStats.off;
                const rawDefRtg = rawSimRatings ? rawSimRatings.drtg : fStats.def;
                const rawNetRtg = rawSimRatings ? rawSimRatings.net : (fStats.off - fStats.def);
                
                const offDelta = adjOffRtg - rawOffRtg;
                const defDelta = adjDefRtg - rawDefRtg;
                const netDelta = adjNetRtg - rawNetRtg;
                
                // Get coverage from any Four Factor stat
                const coverage = adjStats.offEfg.coverage || 0;
                
                // Helper component for displaying adjusted stat with uncertainty
                const AdjStatCard = ({ label, raw, adjData, higherBetter = true, isDefense = false, suffix = '' }) => {
                    const delta = adjData.delta;
                    const adj = adjData.adj;
                    const rapm = adjData.rapmValue !== undefined ? adjData.rapmValue : (isDefense ? adjData.dRAPM : adjData.oRAPM);
                    const leagueAvg = adjData.leagueAvg || 0;
                    const se = adjData.se || 0;
                    const significant = adjData.significant || false;
                    const isDirect = adjData.isDirect || false;
                    
                    // For RAPM coloring: use significance for emphasis
                    const rapmGood = rapm > 0.3;
                    const rapmBad = rapm < -0.3;
                    const rapmColor = significant ? (rapmGood ? '#4ade80' : rapmBad ? '#f87171' : '#94a3b8') : '#64748b';
                    
                    return e('div', { 
                        style: { 
                            background: isDefense ? 'rgba(239, 68, 68, 0.1)' : 'rgba(34, 197, 94, 0.1)', 
                            border: `1px solid ${isDefense ? 'rgba(239, 68, 68, 0.3)' : 'rgba(34, 197, 94, 0.3)'}`, 
                            borderRadius: '8px', 
                            padding: '12px',
                            textAlign: 'center'
                        }
                    },
                        e('div', { style: { fontSize: '11px', opacity: 0.8, marginBottom: '4px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px' }}, 
                            label,
                            isDirect && e('span', { 
                                style: { fontSize: '9px', background: 'rgba(139, 92, 246, 0.3)', padding: '1px 4px', borderRadius: '3px', color: '#a78bfa' }
                            }, 'Direct')
                        ),
                        e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px' }},
                            e('div', { style: { textAlign: 'right', minWidth: '50px' }},
                                e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Raw'),
                                e('div', { style: { fontSize: '16px', fontWeight: 'bold' }}, raw.toFixed(1) + suffix)
                            ),
                            e('div', { style: { fontSize: '18px', color: '#475569' }}, '→'),
                            e('div', { style: { textAlign: 'left', minWidth: '50px' }},
                                e('div', { style: { fontSize: '10px', color: '#60a5fa' }}, 'Adj'),
                                e('div', { style: { fontSize: '16px', fontWeight: 'bold', color: '#60a5fa' }}, adj.toFixed(1) + suffix)
                            )
                        ),
                        // RAPM value with significance indicator
                        e('div', { style: { marginTop: '8px', padding: '4px', background: 'rgba(0,0,0,0.15)', borderRadius: '4px' }},
                            e('div', { style: { fontSize: '10px', color: '#64748b' }}, isDirect ? 'RAPM (Direct)' : (isDefense ? 'dRAPM' : 'oRAPM')),
                            e('div', { style: { fontSize: '14px', fontWeight: 'bold', color: rapmColor, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px' }}, 
                                (rapm >= 0 ? '+' : '') + rapm.toFixed(2),
                                significant && e('span', { style: { fontSize: '10px', color: '#fbbf24' }}, '✱')
                            ),
                            // Standard error and 95% CI
                            isV2 && se > 0 && e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '2px' }}, 
                                '±' + (1.96 * se).toFixed(2) + ' (95% CI)'
                            )
                        ),
                        // League average reference
                        e('div', { style: { fontSize: '9px', color: '#475569', marginTop: '4px' }}, 
                            'Lg: ' + leagueAvg.toFixed(1) + suffix
                        )
                    );
                };
                
                return e('div', { className: 'rapm-section' },
                    // Header with version badge
                    e('div', { className: 'rapm-header' },
                        e('div', null,
                            e('h2', { className: 'section-title', style: { color: '#60a5fa', marginBottom: '8px' }}, 
                                '📊 RAPM-Adjusted Statistics',
                                isV2 && e('span', { style: { fontSize: '11px', marginLeft: '8px', background: 'rgba(34, 197, 94, 0.2)', padding: '2px 6px', borderRadius: '4px', color: '#4ade80' }}, 'V2.0')
                            ),
                            e('p', { style: { fontSize: '12px', color: '#94a3b8' }}, 
                                'Opponent-adjusted metrics via ridge regression',
                                isV2 && ' with uncertainty quantification'
                            )
                        ),
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                            e('span', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Base λ:'),
                            e('input', { 
                                type: 'number', 
                                value: rapmLambda, 
                                min: 100,
                                max: 5000,
                                step: 100,
                                style: { width: '70px', padding: '4px', fontSize: '12px', background: '#1e293b', border: '1px solid #475569', borderRadius: '4px', color: 'white' },
                                onChange: (ev) => setRapmLambda(parseInt(ev.target.value) || 800)
                            }),
                            rapmLambda !== rapmStats.baseLambda && e('button', {
                                className: 'btn',
                                style: { 
                                    fontSize: '10px', 
                                    padding: '4px 8px', 
                                    background: '#8b5cf6',
                                    marginLeft: '8px'
                                },
                                onClick: triggerRAPMCalculation
                            }, '🔄 Recalculate'),
                            e('button', { 
                                className: 'btn btn-secondary',
                                onClick: () => setShowRAPM(false),
                                style: { fontSize: '12px' }
                            }, '✕ Hide')
                        )
                    ),
                    
                    // Adaptive lambda info (V2.0)
                    isV2 && rapmStats.adaptiveInfo && e('div', { 
                        style: { 
                            marginTop: '12px', 
                            padding: '8px 12px', 
                            background: 'rgba(96, 165, 250, 0.1)', 
                            border: '1px solid rgba(96, 165, 250, 0.3)',
                            borderRadius: '6px',
                            fontSize: '11px',
                            color: '#94a3b8',
                            display: 'flex',
                            gap: '16px',
                            flexWrap: 'wrap'
                        }
                    }, 
                        e('span', null, '🎯 Effective λ: ', e('strong', { style: { color: '#60a5fa' }}, rapmStats.lambda.toFixed(1))),
                        e('span', null, '📊 Median Poss: ', e('strong', null, (rapmStats.adaptiveInfo.medianPoss || rapmStats.adaptiveInfo.avgPoss).toFixed(1))),
                        e('span', null, '📉 Min: ', e('strong', null, rapmStats.adaptiveInfo.minPoss.toFixed(0))),
                        e('span', null, '📈 Max: ', e('strong', null, rapmStats.adaptiveInfo.maxPoss.toFixed(0))),
                        rapmStats.adaptiveInfo.sparsityFactor > 1.01 && e('span', null, '⚖️ Sparsity Adj: ', e('strong', null, rapmStats.adaptiveInfo.sparsityFactor.toFixed(2) + 'x'))
                    ),
                    
                    // Lambda mismatch warning
                    rapmLambda !== rapmStats.baseLambda && e('div', { 
                        style: { 
                            marginTop: '12px', 
                            padding: '8px 12px', 
                            background: 'rgba(251, 191, 36, 0.15)', 
                            border: '1px solid rgba(251, 191, 36, 0.4)',
                            borderRadius: '6px',
                            fontSize: '11px',
                            color: '#fbbf24'
                        }
                    }, '⚠️ Base λ changed from ' + rapmStats.baseLambda + ' to ' + rapmLambda + '. Click "Recalculate" to update results.'),
                    
                    // Main adjusted ratings - derived from Four Factors via calcSimulatedRatings
                    e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '12px', marginTop: '16px', marginBottom: '16px' }},
                        e('div', { style: { background: 'rgba(0,0,0,0.2)', borderRadius: '10px', padding: '16px', textAlign: 'center' }},
                            e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '4px' }}, 
                                'Simulated Net',
                                e('span', { style: { fontSize: '9px', marginLeft: '4px', color: '#a78bfa' }}, '(from 4F)')
                            ),
                            e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: getNetColor(adjNetRtg) }}, 
                                (adjNetRtg >= 0 ? '+' : '') + adjNetRtg.toFixed(1)
                            ),
                            e('div', { style: { fontSize: '10px', color: netDelta >= 0 ? '#4ade80' : '#f87171', marginTop: '4px' }},
                                'vs raw sim: ' + (netDelta >= 0 ? '+' : '') + netDelta.toFixed(1)
                            ),
                            e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '2px' }},
                                'Raw: ' + rawNetRtg.toFixed(1) + ' → Adj: ' + adjNetRtg.toFixed(1)
                            )
                        ),
                        e('div', { style: { background: 'rgba(34, 197, 94, 0.15)', borderRadius: '10px', padding: '16px', textAlign: 'center' }},
                            e('div', { style: { fontSize: '11px', color: '#4ade80', marginBottom: '4px' }}, 
                                'Sim Off Rtg',
                                e('span', { style: { fontSize: '9px', marginLeft: '4px', color: '#a78bfa' }}, '(from 4F)')
                            ),
                            e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, 
                                adjOffRtg.toFixed(1)
                            ),
                            e('div', { style: { fontSize: '10px', color: offDelta >= 0 ? '#4ade80' : '#f87171', marginTop: '4px' }},
                                (offDelta >= 0 ? '+' : '') + offDelta.toFixed(1) + ' vs ' + rawOffRtg.toFixed(1)
                            )
                        ),
                        e('div', { style: { background: 'rgba(239, 68, 68, 0.15)', borderRadius: '10px', padding: '16px', textAlign: 'center' }},
                            e('div', { style: { fontSize: '11px', color: '#f87171', marginBottom: '4px' }}, 
                                'Sim Def Rtg',
                                e('span', { style: { fontSize: '9px', marginLeft: '4px', color: '#a78bfa' }}, '(from 4F)')
                            ),
                            e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, 
                                adjDefRtg.toFixed(1)
                            ),
                            e('div', { style: { fontSize: '10px', color: defDelta <= 0 ? '#4ade80' : '#f87171', marginTop: '4px' }},
                                (defDelta >= 0 ? '+' : '') + defDelta.toFixed(1) + ' vs ' + rawDefRtg.toFixed(1)
                            )
                        ),
                        e('div', { style: { background: 'rgba(59, 130, 246, 0.15)', borderRadius: '10px', padding: '16px', textAlign: 'center' }},
                            e('div', { style: { fontSize: '11px', color: '#60a5fa', marginBottom: '4px' }}, 'Coverage'),
                            e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, 
                                (coverage * 100).toFixed(0) + '%'
                            ),
                            e('div', { style: { fontSize: '10px', color: '#94a3b8', marginTop: '4px' }},
                                'lineups matched'
                            ),
                            e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '2px' }},
                                rapmStats.stintCount + ' stints, ' + rapmStats.lineupCount + ' lineups'
                            )
                        )
                    ),
                    
                    // Significance legend
                    isV2 && e('div', { style: { marginBottom: '12px', padding: '8px', background: 'rgba(0,0,0,0.1)', borderRadius: '6px', fontSize: '10px', color: '#94a3b8', display: 'flex', gap: '16px', alignItems: 'center' }},
                        e('span', null, e('span', { style: { color: '#fbbf24' }}, '✱'), ' = Statistically significant (p < 0.05)'),
                        e('span', null, '95% CI = 95% Confidence Interval'),
                        e('span', null, 'Direct = Single-factor model (no off/def split)')
                    ),
                    
                    // Four Factors adjusted
                    e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px' }},
                        // Offensive adjustments
                        e('div', null,
                            e('h4', { style: { color: '#4ade80', marginBottom: '10px', fontSize: '13px' }}, 'Offensive (Adjusted)'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }},
                                e(AdjStatCard, { label: 'eFG%', raw: fStats.offEfg, adjData: adjStats.offEfg, higherBetter: true, suffix: '%' }),
                                e(AdjStatCard, { label: 'TOV%', raw: fStats.offTov, adjData: adjStats.offTov, higherBetter: false, suffix: '%' }),
                                e(AdjStatCard, { label: 'OREB%', raw: fStats.offOreb, adjData: adjStats.offOreb, higherBetter: true, suffix: '%' }),
                                e(AdjStatCard, { label: 'FT Rate', raw: fStats.offFtR, adjData: adjStats.offFtR, higherBetter: true, suffix: '%' })
                            )
                        ),
                        // Defensive adjustments
                        e('div', null,
                            e('h4', { style: { color: '#f87171', marginBottom: '10px', fontSize: '13px' }}, 'Defensive (Adjusted)'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }},
                                e(AdjStatCard, { label: 'Opp eFG%', raw: fStats.defEfg, adjData: adjStats.defEfg, higherBetter: false, isDefense: true, suffix: '%' }),
                                e(AdjStatCard, { label: 'Opp TOV%', raw: fStats.defTov, adjData: adjStats.defTov, higherBetter: true, isDefense: true, suffix: '%' }),
                                e(AdjStatCard, { label: 'Opp OREB%', raw: fStats.defOreb, adjData: adjStats.defOreb, higherBetter: false, isDefense: true, suffix: '%' }),
                                e(AdjStatCard, { label: 'Opp FT Rate', raw: fStats.defFtR, adjData: adjStats.defFtR, higherBetter: false, isDefense: true, suffix: '%' }),
                                e(AdjStatCard, { label: 'STL%', raw: fStats.stlPct, adjData: adjStats.stlPct, higherBetter: true, isDefense: true, suffix: '%' }),
                                e(AdjStatCard, { label: 'BLK%', raw: fStats.blkPct, adjData: adjStats.blkPct, higherBetter: true, isDefense: true, suffix: '%' })
                            )
                        )
                    ),
                    
                    // Playmaking adjusted
                    e('div', { style: { marginTop: '16px', padding: '12px', background: 'rgba(0,0,0,0.15)', borderRadius: '8px' }},
                        e('h4', { style: { color: '#a78bfa', marginBottom: '10px', fontSize: '13px' }}, 'Playmaking (Adjusted)'),
                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }},
                            e(AdjStatCard, { label: 'AST%', raw: fStats.astPct, adjData: adjStats.astPct, higherBetter: true, suffix: '%' })
                        )
                    ),
                    
                    // Methodology note (V2.0)
                    e('div', { style: { marginTop: '16px', padding: '10px', background: 'rgba(0,0,0,0.1)', borderRadius: '6px', fontSize: '10px', color: '#64748b' }},
                        e('strong', null, 'V2.0 Methodology: '),
                        e('br'),
                        e('span', { style: { color: '#a78bfa' }}, '• Simulated Ratings'),
                        ': Off/Def/Net derived from RAPM-adjusted Four Factors via Dean Oliver coefficients. ',
                        e('br'),
                        e('span', { style: { color: '#60a5fa' }}, '• Response Centering'),
                        ': Stats centered around weighted mean for proper identification. ',
                        e('br'),
                        e('span', { style: { color: '#4ade80' }}, '• Gentle Regularization'),
                        ': Default λ=25 preserves signal while stabilizing sparse lineups. Adjust λ to tune shrinkage. ',
                        e('br'),
                        e('span', { style: { color: '#fbbf24' }}, '• Direct Defensive Model'),
                        ': STL%/BLK% use single-factor model for cleaner interpretation. '
                    )
                );
            };

            // Leaderboard - On/Off stats for all players
            const Leaderboard = () => {
                // V4.9.8.7.30: Chart hover state - MUST be at top to follow React Rules of Hooks
                const [hoveredPlayer, setHoveredPlayer] = useState(null);

                // V4.9.8.7.31 FIX: Calculate league averages from lineupData (not onOffData) to avoid double-counting
                // Each lineup is counted once, instead of once per player (5x inflation)
                const leagueAverages = (() => {
                    if (!lineupData.length) return {};
                    
                    // Aggregate raw stats from each lineup ONCE
                    const t = lineupData.reduce((acc, d) => {
                        const fgm = parseFloat(d.FGM) || 0, fga = parseFloat(d.FGA) || 0;
                        const tpm = parseFloat(d['3PM']) || 0, tpa = parseFloat(d['3PA']) || 0;
                        const ftm = parseFloat(d.FTM) || 0, fta = parseFloat(d.FTA) || 0;
                        const oreb = parseFloat(d.OREB) || 0, dreb = parseFloat(d.DREB) || 0;
                        const tov = parseFloat(d.TOV) || 0, ast = parseFloat(d.AST) || 0;
                        const stl = parseFloat(d.STL) || 0, blk = parseFloat(d.BLK) || 0;
                        
                        const fgmV = parseFloat(d.FGM_VS) || 0, fgaV = parseFloat(d.FGA_VS) || 0;
                        const tpmV = parseFloat(d['3PM_VS']) || 0, tpaV = parseFloat(d['3PA_VS']) || 0;
                        const ftmV = parseFloat(d.FTM_VS) || 0, ftaV = parseFloat(d.FTA_VS) || 0;
                        const orebV = parseFloat(d.OREB_VS) || 0, drebV = parseFloat(d.DREB_VS) || 0;
                        const tovV = parseFloat(d.TOV_VS) || 0;
                        
                        const rimA = parseFloat(d.RIM_ATT) || 0, rimM = parseFloat(d.RIM_MADE) || 0;
                        const midA = parseFloat(d.OTD_2PT_ATT) || 0, midM = parseFloat(d.OTD_2PT_MADE) || 0;
                        const threeA = parseFloat(d.OTD_3PT_ATT) || 0, threeM = parseFloat(d.OTD_3PT_MADE) || 0;
                        const rimAV = parseFloat(d.RIM_ATT_VS) || 0, rimMV = parseFloat(d.RIM_MADE_VS) || 0;
                        const midAV = parseFloat(d.OTD_2PT_ATT_VS) || 0, midMV = parseFloat(d.OTD_2PT_MADE_VS) || 0;
                        const threeAV = parseFloat(d.OTD_3PT_ATT_VS) || 0, threeMV = parseFloat(d.OTD_3PT_MADE_VS) || 0;
                        
                        const secChance = parseFloat(d['2ND_CHANCE_PTS']) || 0;
                        const fastBreak = parseFloat(d.FAST_BREAK_PTS) || 0;
                        const ptsOffTov = parseFloat(d.PTS_OFF_TOV) || 0;
                        const secChanceV = parseFloat(d['2ND_CHANCE_PTS_VS']) || 0;
                        const fastBreakV = parseFloat(d.FAST_BREAK_PTS_VS) || 0;
                        const ptsOffTovV = parseFloat(d.PTS_OFF_TOV_VS) || 0;
                        
                        const time = parseFloat(d.TOTAL_TIME) || 0;
                        const poss = calcPoss(fga, oreb, tov, fta);
                        const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                        const paceF = time > 0 ? (poss / time) * 2400 : 0;
                        const paceV = time > 0 ? (possV / time) * 2400 : 0;
                        
                        return {
                            fgm: acc.fgm + fgm, fga: acc.fga + fga, tpm: acc.tpm + tpm, tpa: acc.tpa + tpa,
                            ftm: acc.ftm + ftm, fta: acc.fta + fta, oreb: acc.oreb + oreb, dreb: acc.dreb + dreb,
                            tov: acc.tov + tov, ast: acc.ast + ast, stl: acc.stl + stl, blk: acc.blk + blk,
                            fgmV: acc.fgmV + fgmV, fgaV: acc.fgaV + fgaV, tpmV: acc.tpmV + tpmV, tpaV: acc.tpaV + tpaV,
                            ftmV: acc.ftmV + ftmV, ftaV: acc.ftaV + ftaV, orebV: acc.orebV + orebV, drebV: acc.drebV + drebV,
                            tovV: acc.tovV + tovV,
                            rimA: acc.rimA + rimA, rimM: acc.rimM + rimM, midA: acc.midA + midA, midM: acc.midM + midM,
                            threeA: acc.threeA + threeA, threeM: acc.threeM + threeM,
                            rimAV: acc.rimAV + rimAV, rimMV: acc.rimMV + rimMV, midAV: acc.midAV + midAV, midMV: acc.midMV + midMV,
                            threeAV: acc.threeAV + threeAV, threeMV: acc.threeMV + threeMV,
                            secChance: acc.secChance + secChance, fastBreak: acc.fastBreak + fastBreak, ptsOffTov: acc.ptsOffTov + ptsOffTov,
                            secChanceV: acc.secChanceV + secChanceV, fastBreakV: acc.fastBreakV + fastBreakV, ptsOffTovV: acc.ptsOffTovV + ptsOffTovV,
                            poss: acc.poss + poss, possV: acc.possV + possV, time: acc.time + time,
                            wPaceF: acc.wPaceF + paceF * time, wPaceV: acc.wPaceV + paceV * time
                        };
                    }, {
                        fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, tov: 0, ast: 0, stl: 0, blk: 0,
                        fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftmV: 0, ftaV: 0, orebV: 0, drebV: 0, tovV: 0,
                        rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0,
                        rimAV: 0, rimMV: 0, midAV: 0, midMV: 0, threeAV: 0, threeMV: 0,
                        secChance: 0, fastBreak: 0, ptsOffTov: 0, secChanceV: 0, fastBreakV: 0, ptsOffTovV: 0,
                        poss: 0, possV: 0, time: 0, wPaceF: 0, wPaceV: 0
                    });
                    
                    // Calculate rates from totals
                    const pts = t.fgm * 2 + t.tpm + t.ftm;
                    const ptsV = t.fgmV * 2 + t.tpmV + t.ftmV;
                    const combPoss = t.poss + t.possV;
                    
                    const off = t.poss > 0 ? (pts / t.poss) * 100 : 0;
                    const def = t.possV > 0 ? (ptsV / t.possV) * 100 : 0;
                    const net = off - def;
                    
                    // Four Factors - using Basketball Reference TOV% formula
                    const offTovDenom = t.fga + 0.44 * t.fta + t.tov;
                    const defTovDenom = t.fgaV + 0.44 * t.ftaV + t.tovV;
                    const offEfg = t.fga > 0 ? ((t.fgm + 0.5 * t.tpm) / t.fga) * 100 : 0;
                    const offTov = offTovDenom > 0 ? (t.tov / offTovDenom) * 100 : 0;
                    const offOreb = (t.oreb + t.drebV) > 0 ? (t.oreb / (t.oreb + t.drebV)) * 100 : 0;
                    const offFtR = t.fga > 0 ? (t.fta / t.fga) * 100 : 0;
                    const defEfg = t.fgaV > 0 ? ((t.fgmV + 0.5 * t.tpmV) / t.fgaV) * 100 : 0;
                    const defTov = defTovDenom > 0 ? (t.tovV / defTovDenom) * 100 : 0;
                    const defOreb = (t.orebV + t.dreb) > 0 ? (t.orebV / (t.orebV + t.dreb)) * 100 : 0;
                    const defFtR = t.fgaV > 0 ? (t.ftaV / t.fgaV) * 100 : 0;
                    
                    // Shot stats
                    const rimPct = t.rimA > 0 ? (t.rimM / t.rimA) * 100 : 0;
                    const midPct = t.midA > 0 ? (t.midM / t.midA) * 100 : 0;
                    const threePct = t.threeA > 0 ? (t.threeM / t.threeA) * 100 : 0;
                    const rimPctV = t.rimAV > 0 ? (t.rimMV / t.rimAV) * 100 : 0;
                    const midPctV = t.midAV > 0 ? (t.midMV / t.midAV) * 100 : 0;
                    const threePctV = t.threeAV > 0 ? (t.threeMV / t.threeAV) * 100 : 0;
                    
                    // Volume stats
                    const rimVol = t.poss > 0 ? (t.rimA / t.poss) * 100 : 0;
                    const midVol = t.poss > 0 ? (t.midA / t.poss) * 100 : 0;
                    const threeVol = t.poss > 0 ? (t.threeA / t.poss) * 100 : 0;
                    const rimVolV = t.possV > 0 ? (t.rimAV / t.possV) * 100 : 0;
                    const midVolV = t.possV > 0 ? (t.midAV / t.possV) * 100 : 0;
                    const threeVolV = t.possV > 0 ? (t.threeAV / t.possV) * 100 : 0;
                    
                    // Other stats
                    const astPct = t.fgm > 0 ? (t.ast / t.fgm) * 100 : 0;
                    const stlPct = t.possV > 0 ? (t.stl / t.possV) * 100 : 0;
                    const blkPct = (t.fgaV - t.tpaV) > 0 ? (t.blk / (t.fgaV - t.tpaV)) * 100 : 0;
                    const paceF = t.time > 0 ? t.wPaceF / t.time : 0;
                    const paceV = t.time > 0 ? t.wPaceV / t.time : 0;
                    
                    // Transition stats
                    const secChance100 = t.poss > 0 ? (t.secChance / t.poss) * 100 : 0;
                    const ptsOffTov100 = t.poss > 0 ? (t.ptsOffTov / t.poss) * 100 : 0;
                    const fastBreak100 = t.poss > 0 ? (t.fastBreak / t.poss) * 100 : 0;
                    const secChance100V = t.possV > 0 ? (t.secChanceV / t.possV) * 100 : 0;
                    const ptsOffTov100V = t.possV > 0 ? (t.ptsOffTovV / t.possV) * 100 : 0;
                    const fastBreak100V = t.possV > 0 ? (t.fastBreakV / t.possV) * 100 : 0;
                    
                    // Shot shares
                    const totalShots = t.rimA + t.midA + t.threeA;
                    const totalShotsV = t.rimAV + t.midAV + t.threeAV;
                    const rimShare = totalShots > 0 ? (t.rimA / totalShots) * 100 : 0;
                    const midShare = totalShots > 0 ? (t.midA / totalShots) * 100 : 0;
                    const threeShare = totalShots > 0 ? (t.threeA / totalShots) * 100 : 0;
                    const rimShareV = totalShotsV > 0 ? (t.rimAV / totalShotsV) * 100 : 0;
                    const midShareV = totalShotsV > 0 ? (t.midAV / totalShotsV) * 100 : 0;
                    const threeShareV = totalShotsV > 0 ? (t.threeAV / totalShotsV) * 100 : 0;
                    
                    // Luck-adjusted values (using correctly calculated totals)
                    const adjOff = off;  // Already correct now
                    const adjDef = def;
                    const adjNet = net;
                    const adjOffEfg = offEfg;
                    const adjDefEfg = defEfg;
                    
                    return {
                        net, off, def, offEfg, offTov, offOreb, offFtR, defEfg, defTov, defOreb, defFtR,
                        rimPct, midPct, threePct, rimPctV, midPctV, threePctV,
                        rimVol, midVol, threeVol, rimVolV, midVolV, threeVolV,
                        astPct, stlPct, blkPct, paceF, paceV,
                        secChance100, ptsOffTov100, fastBreak100, secChance100V, ptsOffTov100V, fastBreak100V,
                        rimShare, midShare, threeShare, rimShareV, midShareV, threeShareV,
                        adjOff, adjDef, adjNet, adjOffEfg, adjDefEfg
                    };
                })();

                // V5.12: Support both modal and tab modes
                const isTabMode = activeTab === 'leaderboard';
                if (!isTabMode && !showLeaderboard) {
                    return null;
                }
                if (!lineupData.length) {
                    return null;
                }
                
                // League average 3PT% for regression
                const leagueAvg3Pct = 36.0;
                
                // Stat options for dropdown - now includes luck-adjusted versions
                const statOptions = [
                    // Core ratings
                    { value: 'net', label: 'Net Rating', higherBetter: true, group: 'Ratings' },
                    { value: 'off', label: 'Offensive Rating', higherBetter: true, group: 'Ratings' },
                    { value: 'def', label: 'Defensive Rating', higherBetter: false, group: 'Ratings' },
                    // V4.9.8.7.30: Combined Impact Stats
                    { value: 'fourFactorsImpact', label: '⚡ Four Factors Impact', higherBetter: true, group: 'Combined Impact', isCombinedStat: true },
                    { value: 'scoringBattle', label: '🎯 Scoring Battle Impact', higherBetter: true, group: 'Combined Impact', isCombinedStat: true },
                    { value: 'possBattle', label: '🏀 Possession Battle Impact', higherBetter: true, group: 'Combined Impact', isCombinedStat: true },
                    // Luck-adjusted ratings
                    { value: 'adjNet', label: '🎲 Luck-Adj Net Rating', higherBetter: true, group: 'Luck-Adjusted', isLuckStat: true },
                    { value: 'adjOff', label: '🎲 Luck-Adj Off Rating', higherBetter: true, group: 'Luck-Adjusted', isLuckStat: true },
                    { value: 'adjDef', label: '🎲 Luck-Adj Def Rating', higherBetter: false, group: 'Luck-Adjusted', isLuckStat: true },
                    { value: 'adjOffEfg', label: '🎲 Luck-Adj eFG%', higherBetter: true, group: 'Luck-Adjusted', isLuckStat: true },
                    { value: 'adjDefEfg', label: '🎲 Luck-Adj Opp eFG%', higherBetter: false, group: 'Luck-Adjusted', isLuckStat: true },
                    // Four Factors - Offense
                    { value: 'offEfg', label: 'Off eFG%', higherBetter: true, group: 'Four Factors (Off)' },
                    { value: 'offTov', label: 'Off TOV%', higherBetter: false, group: 'Four Factors (Off)' },
                    { value: 'offOreb', label: 'Off OREB%', higherBetter: true, group: 'Four Factors (Off)' },
                    { value: 'offFtR', label: 'Off FT Rate', higherBetter: true, group: 'Four Factors (Off)' },
                    // Four Factors - Defense
                    { value: 'defEfg', label: 'Def eFG% (Allowed)', higherBetter: false, group: 'Four Factors (Def)' },
                    { value: 'defTov', label: 'Def TOV% (Forced)', higherBetter: true, group: 'Four Factors (Def)' },
                    { value: 'defOreb', label: 'Def OREB% (Allowed)', higherBetter: false, group: 'Four Factors (Def)' },
                    { value: 'defFtR', label: 'Def FT Rate (Allowed)', higherBetter: false, group: 'Four Factors (Def)' },
                    // Shot Making - Offense
                    { value: 'rimPct', label: 'Rim %', higherBetter: true, group: 'Shot Making (Off)' },
                    { value: 'midPct', label: 'Mid %', higherBetter: true, group: 'Shot Making (Off)' },
                    { value: 'threePct', label: '3PT %', higherBetter: true, group: 'Shot Making (Off)' },
                    // Shot Volume - Offense
                    { value: 'rimVol', label: 'Rim Vol/100', higherBetter: true, group: 'Shot Volume (Off)' },
                    { value: 'midVol', label: 'Mid Vol/100', higherBetter: false, group: 'Shot Volume (Off)' },
                    { value: 'threeVol', label: '3PT Vol/100', higherBetter: true, group: 'Shot Volume (Off)' },
                    // Shot Allowed - Defense
                    { value: 'rimPctV', label: 'Opp Rim % (Allowed)', higherBetter: false, group: 'Shot Allowed (Def)' },
                    { value: 'midPctV', label: 'Opp Mid % (Allowed)', higherBetter: false, group: 'Shot Allowed (Def)' },
                    { value: 'threePctV', label: 'Opp 3PT % (Allowed)', higherBetter: false, group: 'Shot Allowed (Def)' },
                    // Shot Volume Allowed - Defense
                    { value: 'rimVolV', label: 'Opp Rim Vol/100', higherBetter: false, group: 'Shot Vol Allowed (Def)' },
                    { value: 'midVolV', label: 'Opp Mid Vol/100', higherBetter: false, group: 'Shot Vol Allowed (Def)' },
                    { value: 'threeVolV', label: 'Opp 3PT Vol/100', higherBetter: false, group: 'Shot Vol Allowed (Def)' },
                    // Playmaking & Defense
                    { value: 'astPct', label: 'AST%', higherBetter: true, group: 'Playmaking' },
                    { value: 'stlPct', label: 'STL%', higherBetter: true, group: 'Defense' },
                    { value: 'blkPct', label: 'BLK%', higherBetter: true, group: 'Defense' },
                    // Clutch
                    { value: 'clutchNet', label: '⏱️ Clutch Net Rating', higherBetter: true, group: 'Clutch', isClutchStat: true },
                    // Pace
                    { value: 'paceF', label: 'Off Pace', higherBetter: true, group: 'Pace' },
                    { value: 'paceV', label: 'Def Pace', higherBetter: false, group: 'Pace' },
                    // Transition
                    { value: 'fastBreak100', label: 'Fast Break Pts/100', higherBetter: true, group: 'Transition' },
                    { value: 'fastBreak100V', label: 'Opp Fast Break Pts/100', higherBetter: false, group: 'Transition' },
                    // MISC Stats
                    { value: 'secChance100', label: '2nd Chance Pts/100', higherBetter: true, group: 'MISC (Off)' },
                    { value: 'ptsOffTov100', label: 'Pts Off TOV/100', higherBetter: true, group: 'MISC (Off)' },
                    { value: 'secChance100V', label: 'Opp 2nd Chance Pts/100', higherBetter: false, group: 'MISC (Def)' },
                    { value: 'ptsOffTov100V', label: 'Opp Pts Off TOV/100', higherBetter: false, group: 'MISC (Def)' },
                    // V5.10: Box Plus/Minus (from CSV or calculated)
                    { value: 'bpm', label: 'BPM', higherBetter: true, group: 'Box Plus/Minus' },
                    { value: 'obpm', label: 'OBPM', higherBetter: true, group: 'Box Plus/Minus' },
                    { value: 'dbpm', label: 'DBPM', higherBetter: true, group: 'Box Plus/Minus' },
                    // V5.11: Bayesian Box APM (RAPM + Bayesian Box)
                    { value: 'apm', label: '🔮 APM (Bayesian Box)', higherBetter: true, group: 'Bayesian Box APM', isApmStat: true },
                    { value: 'oapm', label: '🔮 OAPM', higherBetter: true, group: 'Bayesian Box APM', isApmStat: true },
                    { value: 'dapm', label: '🔮 DAPM', higherBetter: true, group: 'Bayesian Box APM', isApmStat: true },
                    // V5.14: BPM Impact Combos (Teammate Impact Analysis)
                    { value: 'bpmImpactCombos', label: '👥 BPM Impact Combos', higherBetter: true, group: 'Teammate Impact', isComboStat: true },
                    { value: 'bpmImpactZScore', label: '📉 BPM Impact Z-Score', higherBetter: false, group: 'Teammate Impact', isComboStat: true },
                    // V5.22: PER Impact Combos (Teammate Impact Analysis using PER)
                    { value: 'perImpactCombos', label: '📊 PER Impact Combos', higherBetter: true, group: 'Teammate Impact', isComboStat: true },
                    { value: 'perImpactZScore', label: '📉 PER Impact Z-Score', higherBetter: false, group: 'Teammate Impact', isComboStat: true },
                ];
                
                // Define contextual columns for each stat
                const getContextColumns = (stat) => {
                    const contextMap = {
                        // Core ratings
                        'net': [
                            { key: 'ctx1', stat: 'off', label: 'Off Rtg', higherBetter: true },
                            { key: 'ctx2', stat: 'def', label: 'Def Rtg', higherBetter: false }
                        ],
                        'off': [
                            { key: 'ctx1', stat: 'offEfg', label: 'eFG%', higherBetter: true },
                            { key: 'ctx2', stat: 'offTov', label: 'TOV%', higherBetter: false }
                        ],
                        'def': [
                            { key: 'ctx1', stat: 'defEfg', label: 'Opp eFG%', higherBetter: false },
                            { key: 'ctx2', stat: 'defTov', label: 'Forced TO%', higherBetter: true }
                        ],
                        // Luck-adjusted
                        'adjNet': [
                            { key: 'ctx1', stat: 'adjOff', label: 'Luck Off', higherBetter: true },
                            { key: 'ctx2', stat: 'adjDef', label: 'Luck Def', higherBetter: false }
                        ],
                        'adjOff': [
                            { key: 'ctx1', stat: 'adjOffEfg', label: 'Luck eFG%', higherBetter: true },
                            { key: 'ctx2', stat: 'offTov', label: 'TOV%', higherBetter: false }
                        ],
                        'adjDef': [
                            { key: 'ctx1', stat: 'adjDefEfg', label: 'Luck Opp eFG%', higherBetter: false },
                            { key: 'ctx2', stat: 'defTov', label: 'Forced TO%', higherBetter: true }
                        ],
                        'adjOffEfg': [
                            { key: 'ctx1', stat: 'offEfg', label: 'Raw eFG%', higherBetter: true },
                            { key: 'ctx2', stat: 'threePct', label: '3PT%', higherBetter: true }
                        ],
                        'adjDefEfg': [
                            { key: 'ctx1', stat: 'defEfg', label: 'Raw Opp eFG%', higherBetter: false },
                            { key: 'ctx2', stat: 'threePctV', label: 'Opp 3PT%', higherBetter: false }
                        ],
                        // Four Factors - Offense
                        'offEfg': [
                            { key: 'ctx1', stat: 'rimPct', label: 'Rim%', higherBetter: true },
                            { key: 'ctx2', stat: 'threePct', label: '3PT%', higherBetter: true }
                        ],
                        'offTov': [
                            { key: 'ctx1', stat: 'astPct', label: 'AST%', higherBetter: true },
                            { key: 'ctx2', stat: 'paceF', label: 'Pace', higherBetter: true }
                        ],
                        'offOreb': [
                            { key: 'ctx1', stat: 'offEfg', label: 'eFG%', higherBetter: true },
                            { key: 'ctx2', stat: 'rimVol', label: 'Rim Vol', higherBetter: true }
                        ],
                        'offFtR': [
                            { key: 'ctx1', stat: 'rimVol', label: 'Rim Vol', higherBetter: true },
                            { key: 'ctx2', stat: 'offEfg', label: 'eFG%', higherBetter: true }
                        ],
                        // Four Factors - Defense
                        'defEfg': [
                            { key: 'ctx1', stat: 'rimPctV', label: 'Opp Rim%', higherBetter: false },
                            { key: 'ctx2', stat: 'threePctV', label: 'Opp 3PT%', higherBetter: false }
                        ],
                        'defTov': [
                            { key: 'ctx1', stat: 'stlPct', label: 'STL%', higherBetter: true },
                            { key: 'ctx2', stat: 'blkPct', label: 'BLK%', higherBetter: true }
                        ],
                        'defOreb': [
                            { key: 'ctx1', stat: 'defEfg', label: 'Opp eFG%', higherBetter: false },
                            { key: 'ctx2', stat: 'blkPct', label: 'BLK%', higherBetter: true }
                        ],
                        'defFtR': [
                            { key: 'ctx1', stat: 'rimVolV', label: 'Opp Rim Vol', higherBetter: false },
                            { key: 'ctx2', stat: 'defEfg', label: 'Opp eFG%', higherBetter: false }
                        ],
                        // Shot Making - Offense
                        'rimPct': [
                            { key: 'ctx1', stat: 'rimVol', label: 'Rim Vol', higherBetter: true },
                            { key: 'ctx2', stat: 'rimShare', label: 'Rim %Shots', higherBetter: true },
                            { key: 'ctx3', stat: 'midPct', label: 'Mid%', higherBetter: true }
                        ],
                        'midPct': [
                            { key: 'ctx1', stat: 'midVol', label: 'Mid Vol', higherBetter: false },
                            { key: 'ctx2', stat: 'midShare', label: 'Mid %Shots', higherBetter: false },
                            { key: 'ctx3', stat: 'threePct', label: '3PT%', higherBetter: true }
                        ],
                        'threePct': [
                            { key: 'ctx1', stat: 'threeVol', label: '3PT Vol', higherBetter: true },
                            { key: 'ctx2', stat: 'threeShare', label: '3PT %Shots', higherBetter: true },
                            { key: 'ctx3', stat: 'rimPct', label: 'Rim%', higherBetter: true }
                        ],
                        // Shot Volume - Offense
                        'rimVol': [
                            { key: 'ctx1', stat: 'rimPct', label: 'Rim%', higherBetter: true },
                            { key: 'ctx2', stat: 'rimShare', label: 'Rim %Shots', higherBetter: true },
                            { key: 'ctx3', stat: 'threeVol', label: '3PT Vol', higherBetter: true }
                        ],
                        'midVol': [
                            { key: 'ctx1', stat: 'midPct', label: 'Mid%', higherBetter: true },
                            { key: 'ctx2', stat: 'midShare', label: 'Mid %Shots', higherBetter: false },
                            { key: 'ctx3', stat: 'rimVol', label: 'Rim Vol', higherBetter: true }
                        ],
                        'threeVol': [
                            { key: 'ctx1', stat: 'threePct', label: '3PT%', higherBetter: true },
                            { key: 'ctx2', stat: 'threeShare', label: '3PT %Shots', higherBetter: true },
                            { key: 'ctx3', stat: 'rimVol', label: 'Rim Vol', higherBetter: true }
                        ],
                        // Shot Allowed - Defense
                        'rimPctV': [
                            { key: 'ctx1', stat: 'rimVolV', label: 'Opp Rim Vol', higherBetter: false },
                            { key: 'ctx2', stat: 'rimShareV', label: 'Opp Rim %Shots', higherBetter: false },
                            { key: 'ctx3', stat: 'blkPct', label: 'BLK%', higherBetter: true }
                        ],
                        'midPctV': [
                            { key: 'ctx1', stat: 'midVolV', label: 'Opp Mid Vol', higherBetter: false },
                            { key: 'ctx2', stat: 'midShareV', label: 'Opp Mid %Shots', higherBetter: false },
                            { key: 'ctx3', stat: 'threePctV', label: 'Opp 3PT%', higherBetter: false }
                        ],
                        'threePctV': [
                            { key: 'ctx1', stat: 'threeVolV', label: 'Opp 3PT Vol', higherBetter: false },
                            { key: 'ctx2', stat: 'threeShareV', label: 'Opp 3PT %Shots', higherBetter: false },
                            { key: 'ctx3', stat: 'rimPctV', label: 'Opp Rim%', higherBetter: false }
                        ],
                        // Shot Volume Allowed - Defense
                        'rimVolV': [
                            { key: 'ctx1', stat: 'rimPctV', label: 'Opp Rim%', higherBetter: false },
                            { key: 'ctx2', stat: 'rimShareV', label: 'Opp Rim %Shots', higherBetter: false },
                            { key: 'ctx3', stat: 'threeVolV', label: 'Opp 3PT Vol', higherBetter: false }
                        ],
                        'midVolV': [
                            { key: 'ctx1', stat: 'midPctV', label: 'Opp Mid%', higherBetter: false },
                            { key: 'ctx2', stat: 'midShareV', label: 'Opp Mid %Shots', higherBetter: false },
                            { key: 'ctx3', stat: 'rimVolV', label: 'Opp Rim Vol', higherBetter: false }
                        ],
                        'threeVolV': [
                            { key: 'ctx1', stat: 'threePctV', label: 'Opp 3PT%', higherBetter: false },
                            { key: 'ctx2', stat: 'threeShareV', label: 'Opp 3PT %Shots', higherBetter: false },
                            { key: 'ctx3', stat: 'rimVolV', label: 'Opp Rim Vol', higherBetter: false }
                        ],
                        // Playmaking & Defense
                        'astPct': [
                            { key: 'ctx1', stat: 'offTov', label: 'TOV%', higherBetter: false },
                            { key: 'ctx2', stat: 'offEfg', label: 'eFG%', higherBetter: true }
                        ],
                        'stlPct': [
                            { key: 'ctx1', stat: 'blkPct', label: 'BLK%', higherBetter: true },
                            { key: 'ctx2', stat: 'defTov', label: 'Forced TO%', higherBetter: true }
                        ],
                        'blkPct': [
                            { key: 'ctx1', stat: 'stlPct', label: 'STL%', higherBetter: true },
                            { key: 'ctx2', stat: 'rimPctV', label: 'Opp Rim%', higherBetter: false }
                        ],
                        // Pace
                        'paceF': [
                            { key: 'ctx1', stat: 'paceV', label: 'Def Pace', higherBetter: false },
                            { key: 'ctx2', stat: 'offTov', label: 'TOV%', higherBetter: false }
                        ],
                        'paceV': [
                            { key: 'ctx1', stat: 'paceF', label: 'Off Pace', higherBetter: true },
                            { key: 'ctx2', stat: 'defTov', label: 'Forced TO%', higherBetter: true }
                        ],
                        // Transition
                        'fastBreak100': [
                            { key: 'ctx1', stat: 'paceF', label: 'Off Pace', higherBetter: true },
                            { key: 'ctx2', stat: 'stlPct', label: 'STL%', higherBetter: true }
                        ],
                        'fastBreak100V': [
                            { key: 'ctx1', stat: 'defTov', label: 'Forced TO%', higherBetter: true },
                            { key: 'ctx2', stat: 'paceV', label: 'Def Pace', higherBetter: false }
                        ],
                        // MISC
                        'secChance100': [
                            { key: 'ctx1', stat: 'offOreb', label: 'OREB%', higherBetter: true },
                            { key: 'ctx2', stat: 'offEfg', label: 'eFG%', higherBetter: true }
                        ],
                        'ptsOffTov100': [
                            { key: 'ctx1', stat: 'stlPct', label: 'STL%', higherBetter: true },
                            { key: 'ctx2', stat: 'fastBreak100', label: 'FB Pts/100', higherBetter: true }
                        ],
                        'secChance100V': [
                            { key: 'ctx1', stat: 'defOreb', label: 'Opp OREB%', higherBetter: false },
                            { key: 'ctx2', stat: 'blkPct', label: 'BLK%', higherBetter: true }
                        ],
                        'ptsOffTov100V': [
                            { key: 'ctx1', stat: 'offTov', label: 'TOV%', higherBetter: false },
                            { key: 'ctx2', stat: 'fastBreak100V', label: 'Opp FB/100', higherBetter: false }
                        ],
                        // Clutch
                        'clutchNet': [
                            { key: 'ctx1', stat: 'net', label: 'Reg Net', higherBetter: true },
                            { key: 'ctx2', stat: 'off', label: 'Off Rtg', higherBetter: true }
                        ],
                        // V4.9.8.7.30: Combined Impact Stats
                        'possBattle': [
                            { key: 'ctx1', stat: 'offOreb', label: 'Off OREB%', higherBetter: true },
                            { key: 'ctx2', stat: 'offTov', label: 'Off TOV%', higherBetter: false },
                            { key: 'ctx3', stat: 'defOreb', label: 'Def OREB%', higherBetter: false },
                            { key: 'ctx4', stat: 'defTov', label: 'Def TOV%', higherBetter: true }
                        ],
                        'scoringBattle': [
                            { key: 'ctx1', stat: 'offEfg', label: 'Off eFG%', higherBetter: true },
                            { key: 'ctx2', stat: 'offFtR', label: 'Off FTR', higherBetter: true },
                            { key: 'ctx3', stat: 'defEfg', label: 'Def eFG%', higherBetter: false },
                            { key: 'ctx4', stat: 'defFtR', label: 'Def FTR', higherBetter: false }
                        ],
                        'fourFactorsImpact': [
                            { key: 'ctx1', stat: 'scoringBattle', label: 'Scoring', higherBetter: true, isCombined: true },
                            { key: 'ctx2', stat: 'possBattle', label: 'Poss', higherBetter: true, isCombined: true }
                        ],
                        // V5.10: Box Plus/Minus context
                        'bpm': [
                            { key: 'ctx1', stat: 'obpm', label: 'OBPM', higherBetter: true },
                            { key: 'ctx2', stat: 'dbpm', label: 'DBPM', higherBetter: true }
                        ],
                        'obpm': [
                            { key: 'ctx1', stat: 'bpm', label: 'BPM', higherBetter: true },
                            { key: 'ctx2', stat: 'net', label: 'Net Rtg', higherBetter: true }
                        ],
                        'dbpm': [
                            { key: 'ctx1', stat: 'bpm', label: 'BPM', higherBetter: true },
                            { key: 'ctx2', stat: 'def', label: 'Def Rtg', higherBetter: false }
                        ],
                        // V5.11: Bayesian Box APM context
                        'apm': [
                            { key: 'ctx1', stat: 'oapm', label: 'OAPM', higherBetter: true },
                            { key: 'ctx2', stat: 'dapm', label: 'DAPM', higherBetter: true }
                        ],
                        'oapm': [
                            { key: 'ctx1', stat: 'apm', label: 'APM', higherBetter: true },
                            { key: 'ctx2', stat: 'bpm', label: 'BPM', higherBetter: true }
                        ],
                        'dapm': [
                            { key: 'ctx1', stat: 'apm', label: 'APM', higherBetter: true },
                            { key: 'ctx2', stat: 'dbpm', label: 'DBPM', higherBetter: true }
                        ],
                        // V5.14: BPM Impact Combos context
                        'bpmImpactCombos': [
                            { key: 'ctx1', stat: 'bpm', label: 'BPM', higherBetter: true },
                            { key: 'ctx2', stat: 'net', label: 'Net Rtg', higherBetter: true }
                        ],
                        'bpmImpactZScore': [
                            { key: 'ctx1', stat: 'bpmImpact', label: 'BPM Δ', higherBetter: false },
                            { key: 'ctx2', stat: 'zScore', label: 'Z-Score', higherBetter: false }
                        ],
                        // V5.22: PER Impact Combos context
                        'perImpactCombos': [
                            { key: 'ctx1', stat: 'per', label: 'PER', higherBetter: true },
                            { key: 'ctx2', stat: 'net', label: 'Net Rtg', higherBetter: true }
                        ],
                        'perImpactZScore': [
                            { key: 'ctx1', stat: 'perImpact', label: 'PER Δ', higherBetter: false },
                            { key: 'ctx2', stat: 'zScore', label: 'Z-Score', higherBetter: false }
                        ]
                    };
                    return contextMap[stat] || [];
                };
                
                const currentStat = statOptions.find(s => s.value === lbStat) || statOptions[0];
                const baseContextCols = getContextColumns(lbStat);
                
                // Helper function to calculate luck-adjusted stats for a stats object
                const calcLuckAdjusted = (stats, adjPct) => {
                    if (!stats || adjPct === 0) return stats;
                    
                    // Offensive luck adjustment: regress 3PT% toward league average
                    const expected3pm = stats.tpa * (leagueAvg3Pct / 100);
                    const offLuckDelta = stats.tpm - expected3pm;
                    const offAdj3pm = offLuckDelta * (adjPct / 100);
                    
                    // Defensive luck adjustment: regress opponent 3PT% toward league average
                    const expectedOpp3pm = stats.tpaV * (leagueAvg3Pct / 100);
                    const defLuckDelta = stats.tpmV - expectedOpp3pm;
                    const defAdj3pm = defLuckDelta * (adjPct / 100);
                    
                    // Adjusted 3PM values
                    const adj3pm = Math.max(0, stats.tpm - offAdj3pm);
                    const adj3pmV = Math.max(0, stats.tpmV - defAdj3pm);
                    
                    // Adjusted points
                    const origPts = stats.fgm * 2 + stats.tpm + stats.ftm;
                    const origPtsV = stats.fgmV * 2 + stats.tpmV + stats.ftmV;
                    const adjPts = origPts - offAdj3pm * 3;
                    const adjPtsV = origPtsV - defAdj3pm * 3;
                    
                    // Adjusted ratings
                    const adjOff = stats.offPoss > 0 ? (adjPts / stats.offPoss) * 100 : stats.off;
                    const adjDef = stats.defPoss > 0 ? (adjPtsV / stats.defPoss) * 100 : stats.def;
                    const adjNet = adjOff - adjDef;
                    
                    // Adjusted eFG%
                    const adjFgm = Math.max(0, stats.fgm - offAdj3pm);
                    const adjFgmV = Math.max(0, stats.fgmV - defAdj3pm);
                    const adjOffEfg = stats.fga > 0 ? ((adjFgm + 0.5 * adj3pm) / stats.fga) * 100 : stats.offEfg;
                    const adjDefEfg = stats.fgaV > 0 ? ((adjFgmV + 0.5 * adj3pmV) / stats.fgaV) * 100 : stats.defEfg;
                    
                    return {
                        ...stats,
                        adjOff,
                        adjDef,
                        adjNet,
                        adjOffEfg,
                        adjDefEfg
                    };
                };
                
                // Helper to get stat value including calculated ones
                const getStatValue = (stats, statKey, adjStats) => {
                    // Shot share calculations
                    const totalShots = (stats.rimA || 0) + (stats.midA || 0) + (stats.threeA || 0);
                    const totalShotsV = (stats.rimAV || 0) + (stats.midAV || 0) + (stats.threeAV || 0);
                    
                    if (statKey === 'rimShare') return totalShots > 0 ? ((stats.rimA || 0) / totalShots) * 100 : 0;
                    if (statKey === 'midShare') return totalShots > 0 ? ((stats.midA || 0) / totalShots) * 100 : 0;
                    if (statKey === 'threeShare') return totalShots > 0 ? ((stats.threeA || 0) / totalShots) * 100 : 0;
                    if (statKey === 'rimShareV') return totalShotsV > 0 ? ((stats.rimAV || 0) / totalShotsV) * 100 : 0;
                    if (statKey === 'midShareV') return totalShotsV > 0 ? ((stats.midAV || 0) / totalShotsV) * 100 : 0;
                    if (statKey === 'threeShareV') return totalShotsV > 0 ? ((stats.threeAV || 0) / totalShotsV) * 100 : 0;
                    
                    // Luck-adjusted stats
                    if (statKey === 'adjNet') return adjStats?.adjNet ?? stats.net;
                    if (statKey === 'adjOff') return adjStats?.adjOff ?? stats.off;
                    if (statKey === 'adjDef') return adjStats?.adjDef ?? stats.def;
                    if (statKey === 'adjOffEfg') return adjStats?.adjOffEfg ?? stats.offEfg;
                    if (statKey === 'adjDefEfg') return adjStats?.adjDefEfg ?? stats.defEfg;
                    
                    return stats[statKey] || 0;
                };
                
                // V4.9.8.7.31 FIX: Use same filter as display (lbMinMins) for z-score calculation
                // Use minimum of 20 to ensure statistical validity even if lbMinMins is lower
                const zScoreMinMinutes = Math.max(20, lbMinMins);
                const allOnOffDiffs = onOffData.filter(d => d.onMinutes >= zScoreMinMinutes).map(d => {
                    const on = d.onStats, off = d.offStats;
                    return {
                        offEfg: on.offEfg - off.offEfg,
                        offTov: on.offTov - off.offTov,
                        offOreb: on.offOreb - off.offOreb,
                        offFtR: on.offFtR - off.offFtR,
                        defEfg: on.defEfg - off.defEfg,
                        defTov: on.defTov - off.defTov,
                        defOreb: on.defOreb - off.defOreb,
                        defFtR: on.defFtR - off.defFtR
                    };
                });
                
                // Calculate mean and stddev for each stat's on-off diff
                const calcMeanStd = (arr, key) => {
                    const vals = arr.map(d => d[key]).filter(v => !isNaN(v) && isFinite(v));
                    if (!vals.length) return { mean: 0, std: 1 };
                    const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                    const variance = vals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / vals.length;
                    const std = Math.sqrt(variance) || 1;
                    return { mean, std };
                };
                
                const statDistributions = {
                    offEfg: calcMeanStd(allOnOffDiffs, 'offEfg'),
                    offTov: calcMeanStd(allOnOffDiffs, 'offTov'),
                    offOreb: calcMeanStd(allOnOffDiffs, 'offOreb'),
                    offFtR: calcMeanStd(allOnOffDiffs, 'offFtR'),
                    defEfg: calcMeanStd(allOnOffDiffs, 'defEfg'),
                    defTov: calcMeanStd(allOnOffDiffs, 'defTov'),
                    defOreb: calcMeanStd(allOnOffDiffs, 'defOreb'),
                    defFtR: calcMeanStd(allOnOffDiffs, 'defFtR')
                };
                
                // Z-score calculation with direction (higher is better or lower is better)
                const calcZScore = (val, dist, higherBetter) => {
                    const z = (val - dist.mean) / dist.std;
                    return higherBetter ? z : -z; // Flip sign for "lower is better" stats
                };
                
                // Combined impact stats calculator
                const calcCombinedImpacts = (onStats, offStats) => {
                    const diffs = {
                        offEfg: onStats.offEfg - offStats.offEfg,
                        offTov: onStats.offTov - offStats.offTov, // Lower is better
                        offOreb: onStats.offOreb - offStats.offOreb,
                        offFtR: onStats.offFtR - offStats.offFtR,
                        defEfg: onStats.defEfg - offStats.defEfg, // Lower is better (allowed)
                        defTov: onStats.defTov - offStats.defTov, // Higher is better (forced)
                        defOreb: onStats.defOreb - offStats.defOreb, // Lower is better (allowed)
                        defFtR: onStats.defFtR - offStats.defFtR // Lower is better (allowed)
                    };
                    
                    // Calculate z-scores with proper direction
                    const zScores = {
                        offEfg: calcZScore(diffs.offEfg, statDistributions.offEfg, true),
                        offTov: calcZScore(diffs.offTov, statDistributions.offTov, false), // Lower TOV% is better
                        offOreb: calcZScore(diffs.offOreb, statDistributions.offOreb, true),
                        offFtR: calcZScore(diffs.offFtR, statDistributions.offFtR, true),
                        defEfg: calcZScore(diffs.defEfg, statDistributions.defEfg, false), // Lower eFG% allowed is better
                        defTov: calcZScore(diffs.defTov, statDistributions.defTov, true), // Higher TOV% forced is better
                        defOreb: calcZScore(diffs.defOreb, statDistributions.defOreb, false), // Lower OREB% allowed is better
                        defFtR: calcZScore(diffs.defFtR, statDistributions.defFtR, false) // Lower FT rate allowed is better
                    };
                    
                    // Possession Battle: Off OREB%, Off TOV%, Def OREB%, Def TOV%
                    const possBattle = zScores.offOreb + zScores.offTov + zScores.defOreb + zScores.defTov;
                    
                    // Scoring Battle: Off eFG%, Off FT Rate, Def eFG%, Def FT Rate
                    const scoringBattle = zScores.offEfg + zScores.offFtR + zScores.defEfg + zScores.defFtR;
                    
                    // Four Factors Impact: All 8 factors
                    const fourFactorsImpact = possBattle + scoringBattle;
                    
                    return {
                        possBattle,
                        scoringBattle,
                        fourFactorsImpact,
                        zScores,
                        diffs
                    };
                };
                
                // Handle header click for sorting
                const handleSort = (colKey) => {
                    if (lbSortCol === colKey) {
                        setLbSortDir(lbSortDir === 'desc' ? 'asc' : 'desc');
                    } else {
                        setLbSortCol(colKey);
                        setLbSortDir('desc');
                    }
                };
                
                // Filter and calculate data
                // First, create a lookup map for clutch data
                const clutchLookup = {};
                clutchOnOffData.forEach(d => {
                    clutchLookup[d.player + '|' + d.team] = d;
                });
                
                // V4.7.2: Check if RAPM is available and should be used for current stat
                // RAPM stat mapping - V3.0 Multi-stat RAPM calculates all Four Factors
                // PlayerRAPMEngine V3.0 supports: ORtg, eFG%, TOV%, OREB%, FTRate, AST%, STL%, BLK% 
                // Rim%, Mid%, 3PT%, RimVol, MidVol, 3PTVol, FastBreak, SecChance, PtsOffTov
                const rapmStatMapping = PlayerRAPMEngine.leaderboardStatMapping;
                
                // V4.9.7: Use playerRapmStats from PlayerRAPMEngine V3.0 (calculated from stints.csv)
                const playerRAPMStats = playerRapmStats && playerRapmStats.stats && !playerRapmStats.error ? playerRapmStats : null;
                const rapmAvailable = playerRAPMStats !== null;
                
                // V4.9.7: Helper to get player-level RAPM value using PlayerRAPMEngine V3.0
                const getPlayerRAPMValue = (playerName, statKey, mapping) => {
                    if (!playerRAPMStats) return null;
                    return PlayerRAPMEngine.getPlayerRapmValue(playerRAPMStats, playerName, statKey);
                };
                
                const rapmMapping = rapmStatMapping[lbStat];
                const useRapmForStat = rapmMapping?.useRapm && rapmAvailable && lbUseRapm;

                // Helper: compute vsTeam diff (ON value minus Team Average, no sign flipping)
                const calcVsTeamDiff = (onVal, statKey, teamAvgObj) => {
                    const ta = teamAvgObj || {};
                    const teamVal = ta[statKey] || 0;
                    return onVal - teamVal;
                };
                
                // V4.9.8.7.17: Override context columns to show ORAPM/DRAPM when using RAPM for net rating
                const contextCols = (useRapmForStat && lbStat === 'net') ? [
                    { key: 'ctx1', stat: 'off', label: 'ORAPM', higherBetter: true, useRapm: true },
                    { key: 'ctx2', stat: 'def', label: 'DRAPM', higherBetter: true, useRapm: true }
                ] : baseContextCols;
                
                const filteredData = onOffData
                    .filter(d => lbTeam === '' || d.team === lbTeam)
                    .filter(d => d.onMinutes >= lbMinMins)
                    .map(d => {
                        const adjOnStats = calcLuckAdjusted(d.onStats, lbLuckAdj);
                        const adjOffStats = calcLuckAdjusted(d.offStats, lbLuckAdj);
                        
                        // Merge clutch stats if available
                        const clutchPlayer = clutchLookup[d.player + '|' + d.team];
                        const onStatsWithClutch = clutchPlayer ? { ...d.onStats, clutchNet: clutchPlayer.onStats.clutchNet, clutchOff: clutchPlayer.onStats.clutchOff, clutchDef: clutchPlayer.onStats.clutchDef } : d.onStats;
                        const offStatsWithClutch = clutchPlayer ? { ...d.offStats, clutchNet: clutchPlayer.offStats.clutchNet, clutchOff: clutchPlayer.offStats.clutchOff, clutchDef: clutchPlayer.offStats.clutchDef } : d.offStats;
                        
                        // V4.8: Get values - use RAPM when available, otherwise fall back to On/Off
                        let onVal, offVal, diff, rapmVal, rawRapmVal, luckAdj;
                        
                        // Check if this stat should use RAPM via PlayerRAPMEngine
                        const shouldUseRapm = PlayerRAPMEngine.shouldUseRapm(lbStat);
                        
                        if (shouldUseRapm && rapmAvailable) {
                            // Get RAPM coefficient for this player from PlayerRAPMEngine
                            const playerRapmResult = getPlayerRAPMValue(d.player, lbStat, rapmMapping);
                            
                            if (playerRapmResult && playerRapmResult.rapm !== undefined) {
                                // PlayerRAPMEngine already handles scaling, flipping, and net calculations
                                rawRapmVal = playerRapmResult.rapm;
                                rapmVal = rawRapmVal;
                                
                                // V4.9.8.8: Apply player-level luck adjustment for rating stats
                                if (playerLuckAdjustments && (lbStat === 'net' || lbStat === 'off' || lbStat === 'def')) {
                                    const playerKey = d.player.toLowerCase().trim();
                                    // Try exact match first
                                    let playerLuck = playerLuckAdjustments.adjustments[playerKey];
                                    
                                    // Try fuzzy match if exact fails (remove apostrophes, periods)
                                    if (!playerLuck) {
                                        const normalizedKey = playerKey.replace(/[''`´.]/g, '').replace(/\s+/g, ' ');
                                        playerLuck = playerLuckAdjustments.adjustments[normalizedKey];
                                    }
                                    
                                    // Try matching by last name + first initial
                                    if (!playerLuck) {
                                        const nameParts = playerKey.split(' ');
                                        if (nameParts.length >= 2) {
                                            const lastName = nameParts[nameParts.length - 1];
                                            const firstInitial = nameParts[0][0];
                                            for (const [key, val] of Object.entries(playerLuckAdjustments.adjustments)) {
                                                const keyParts = key.split(' ');
                                                if (keyParts.length >= 2) {
                                                    const keyLast = keyParts[keyParts.length - 1];
                                                    const keyFirst = keyParts[0][0];
                                                    if (keyLast === lastName && keyFirst === firstInitial) {
                                                        playerLuck = val;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Debug logging for first few players
                                    if (!window._rapmLuckDebugDone) {
                                        window._rapmLuckDebugDone = true;
                                        console.log('[RAPM Luck] playerLuckAdjustments available:', !!playerLuckAdjustments);
                                        console.log('[RAPM Luck] Adjustment count:', Object.keys(playerLuckAdjustments?.adjustments || {}).length);
                                        console.log('[RAPM Luck] Sample adjustment keys:', Object.keys(playerLuckAdjustments?.adjustments || {}).slice(0, 5));
                                        console.log('[RAPM Luck Match]', d.player, '->', playerKey, '-> found:', !!playerLuck, playerLuck ? 'offAdj:' + playerLuck.offAdj.toFixed(2) : '');
                                    }
                                    
                                    if (playerLuck) {
                                        if (lbStat === 'off') {
                                            luckAdj = playerLuck.offAdj;
                                            rapmVal = rawRapmVal + luckAdj;
                                        } else if (lbStat === 'def') {
                                            luckAdj = playerLuck.defAdj;
                                            rapmVal = rawRapmVal + luckAdj;
                                        } else if (lbStat === 'net') {
                                            // Net = Off - Def, so luck adj = offAdj - defAdj
                                            luckAdj = playerLuck.offAdj - playerLuck.defAdj;
                                            rapmVal = rawRapmVal + luckAdj;
                                        }
                                    }
                                } else if (rapmLuckAdj > 0 && !window._rapmLuckDebugDone2) {
                                    window._rapmLuckDebugDone2 = true;
                                    console.log('[RAPM Luck] Adjustment NOT applied:', {
                                        playerLuckAdjustments: !!playerLuckAdjustments,
                                        lbStat,
                                        rapmLuckAdj
                                    });
                                }
                                
                                diff = rapmVal;
                                
                                // For On/Off columns, still show traditional values for reference
                                onVal = getStatValue(onStatsWithClutch, lbStat, adjOnStats);
                                offVal = getStatValue(offStatsWithClutch, lbStat, adjOffStats);
                            } else {
                                // RAPM not available for this player, fall back to On/Off
                                onVal = getStatValue(onStatsWithClutch, lbStat, adjOnStats);
                                offVal = getStatValue(offStatsWithClutch, lbStat, adjOffStats);
                                if (lbOnOffMethod === 'vsTeam') {
                                    diff = calcVsTeamDiff(onVal, lbStat, teamAvgMap[d.team]);
                                } else {
                                    diff = onVal - offVal;
                                }
                                rapmVal = null;
                                rawRapmVal = null;
                            }
                        } else {
                            // Use traditional On/Off calculation
                            onVal = getStatValue(onStatsWithClutch, lbStat, adjOnStats);
                            offVal = getStatValue(offStatsWithClutch, lbStat, adjOffStats);
                            if (lbOnOffMethod === 'vsTeam') {
                                diff = calcVsTeamDiff(onVal, lbStat, teamAvgMap[d.team]);
                            } else {
                                diff = onVal - offVal;
                            }
                            rapmVal = null;
                            rawRapmVal = null;
                        }
                        
                        const lgAvg = leagueAverages[lbStat] || 0;
                        
                        // Calculate context column values
                        const ctxVals = {};
                        contextCols.forEach(ctx => {
                            if (ctx.useRapm && playerRAPMStats) {
                                // Use RAPM values for ORAPM/DRAPM columns
                                const rapmResult = getPlayerRAPMValue(d.player, ctx.stat, rapmStatMapping[ctx.stat]);
                                let rapmValue = rapmResult && rapmResult.rapm !== undefined ? rapmResult.rapm : null;
                                // V8.1: Negate DRAPM display so positive = good defense
                                if (ctx.stat === 'def' && rapmValue !== null) rapmValue = -rapmValue;
                                ctxVals[ctx.key + 'Diff'] = rapmValue !== null ? rapmValue : 0;
                                ctxVals[ctx.key + 'On'] = null; // Not applicable for RAPM
                                ctxVals[ctx.key + 'Off'] = null;
                            } else {
                                ctxVals[ctx.key + 'On'] = getStatValue(onStatsWithClutch, ctx.stat, adjOnStats);
                                ctxVals[ctx.key + 'Off'] = getStatValue(offStatsWithClutch, ctx.stat, adjOffStats);
                                if (lbOnOffMethod === 'vsTeam') {
                                    ctxVals[ctx.key + 'Diff'] = calcVsTeamDiff(ctxVals[ctx.key + 'On'], ctx.stat, teamAvgMap[d.team]);
                                } else {
                                    ctxVals[ctx.key + 'Diff'] = ctxVals[ctx.key + 'On'] - ctxVals[ctx.key + 'Off'];
                                }
                            }
                        });
                        
                        // V4.9.8.7.30: Calculate combined impact stats
                        const combinedImpacts = calcCombinedImpacts(d.onStats, d.offStats);
                        
                        // V5.10: Get BPM from seasonStatsMap (from CSV or calculated)
                        const playerSeasonStats = seasonStatsMap.get(normalizePlayerName(d.player));
                        let bpm = 0, obpm = 0, dbpm = 0;
                        if (playerSeasonStats) {
                            if (playerSeasonStats.bpm !== null && playerSeasonStats.bpm !== undefined && !isNaN(playerSeasonStats.bpm)) {
                                bpm = playerSeasonStats.bpm;
                                obpm = playerSeasonStats.obpm || 0;
                                dbpm = playerSeasonStats.dbpm || 0;
                            } else {
                                // Calculate from box score stats
                                const games = playerSeasonStats.games || 1;
                                const usg = (playerSeasonStats.usg || 20) / 100;
                                const ast = (playerSeasonStats.ast / games) || 0;
                                const reb = (playerSeasonStats.reb / games) || 0;
                                const stl = (playerSeasonStats.stl / games) || 0;
                                const blk = (playerSeasonStats.blk / games) || 0;
                                const tov = (playerSeasonStats.tov / games) || 0;
                                const tsPct = playerSeasonStats.fga > 0 ? (playerSeasonStats.pts / (2 * (playerSeasonStats.fga + 0.44 * playerSeasonStats.fta))) : 0.5;
                                const scoringImpact = (tsPct - 0.55) * 100 * usg;
                                obpm = scoringImpact + ast * 0.5 + reb * 0.3 * 0.3 + tov * -0.5;
                                dbpm = stl * 1.5 + blk * 0.8 + reb * 0.3 * 0.7;
                                bpm = obpm + dbpm;
                            }
                        }
                        
                        // For combined stats, use the combined value as 'diff'
                        let finalDiff = diff;
                        if (lbStat === 'possBattle') finalDiff = combinedImpacts.possBattle;
                        else if (lbStat === 'scoringBattle') finalDiff = combinedImpacts.scoringBattle;
                        else if (lbStat === 'fourFactorsImpact') finalDiff = combinedImpacts.fourFactorsImpact;
                        // V5.10: BPM stats use raw value as diff (already +/- league average)
                        else if (lbStat === 'bpm') finalDiff = bpm;
                        else if (lbStat === 'obpm') finalDiff = obpm;
                        else if (lbStat === 'dbpm') finalDiff = dbpm;
                        
                        // V5.11: Get APM values if available
                        let apm = 0, oapm = 0, dapm = 0;
                        if (playerApmStats && playerApmStats.players) {
                            const apmResult = PlayerRAPMEngine.getPlayerApmValue(playerApmStats, d.player);
                            if (apmResult) {
                                apm = apmResult.apm || 0;
                                oapm = apmResult.oapm || 0;
                                dapm = apmResult.dapm || 0;
                            }
                        }
                        
                        // V5.11: APM stats use raw value as diff
                        if (lbStat === 'apm') finalDiff = apm;
                        else if (lbStat === 'oapm') finalDiff = oapm;
                        else if (lbStat === 'dapm') finalDiff = dapm;
                        
                        return {
                            ...d,
                            onVal,
                            offVal,
                            onVsLg: onVal - lgAvg,
                            offVsLg: offVal - lgAvg,
                            diff: finalDiff,
                            rapmVal,
                            rawRapmVal,
                            luckAdj,
                            hasRapm: rapmVal !== null,
                            clutchPoss: clutchPlayer?.onPoss || 0,
                            // V4.9.8.7.30: Add combined impact stats for chart view
                            possBattle: combinedImpacts.possBattle,
                            scoringBattle: combinedImpacts.scoringBattle,
                            fourFactorsImpact: combinedImpacts.fourFactorsImpact,
                            impactZScores: combinedImpacts.zScores,
                            impactDiffs: combinedImpacts.diffs,
                            // V5.10: Add BPM stats
                            bpm, obpm, dbpm,
                            // V5.11: Add APM stats
                            apm, oapm, dapm,
                            hasApm: apm !== 0 || oapm !== 0 || dapm !== 0,
                            ...ctxVals
                        };
                    });
                
                // Sort data
                const sortedDataAll = [...filteredData].sort((a, b) => {
                    let aVal, bVal;
                    
                    if (lbSortCol === 'player') {
                        aVal = a.player.toLowerCase();
                        bVal = b.player.toLowerCase();
                        return lbSortDir === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    } else if (lbSortCol === 'team') {
                        aVal = a.team.toLowerCase();
                        bVal = b.team.toLowerCase();
                        return lbSortDir === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    } else {
                        aVal = a[lbSortCol] || 0;
                        bVal = b[lbSortCol] || 0;
                        return lbSortDir === 'asc' ? aVal - bVal : bVal - aVal;
                    }
                });
                
                const totalFilteredCount = sortedDataAll.length;
                const sortedData = lbShowAll ? sortedDataAll : sortedDataAll.slice(0, 50);
                
                // Sort indicator
                const SortIndicator = ({ colKey }) => {
                    if (lbSortCol !== colKey) return null;
                    return e('span', { style: { marginLeft: '4px', fontSize: '10px' }}, lbSortDir === 'asc' ? '▲' : '▼');
                };
                
                // Get color for diff value
                const getDiffColor = (val, higherBetter) => {
                    if (higherBetter) return val > 0 ? '#4ade80' : val === 0 ? '#94a3b8' : '#f87171';
                    return val < 0 ? '#4ade80' : val === 0 ? '#94a3b8' : '#f87171';
                };
                
                // V5.12: Filter APM options based on whether APM is calculated
                const apmAvailable = playerApmStats && playerApmStats.players;
                const filteredStatOptions = statOptions.filter(opt => {
                    if (opt.isApmStat) return apmAvailable;
                    return true;
                });
                
                // Group stat options for dropdown
                const groupedOptions = filteredStatOptions.reduce((acc, opt) => {
                    if (!acc[opt.group]) acc[opt.group] = [];
                    acc[opt.group].push(opt);
                    return acc;
                }, {});
                
                // V5.12: Inner content shared between modal and tab modes
                const leaderboardContent = e('div', { style: isTabMode ? { padding: '0' } : {} },
                        e('div', { className: isTabMode ? '' : 'modal-header' },
                            e('div', null,
                                e('h2', { style: { fontSize: '24px', fontWeight: 'bold', color: '#fbbf24' }}, 
                                    useRapmForStat ? '🏆 RAPM Leaderboard' : '🏆 On/Off Leaderboard'
                                ),
                                e('p', { style: { marginTop: '8px', opacity: 0.8 }}, 
                                    useRapmForStat 
                                        ? 'Player impact: Regularized Adjusted Plus-Minus (isolates individual contribution). Click headers to sort.'
                                        : 'Player impact: team performance with player ON vs OFF court. Click headers to sort.'
                                ),
                                // RAPM Status indicator
                                e('div', { style: { marginTop: '8px', display: 'flex', gap: '12px', flexWrap: 'wrap', alignItems: 'center' }},
                                    rapmAvailable && e('span', { style: { 
                                        fontSize: '11px', 
                                        padding: '4px 10px', 
                                        borderRadius: '12px', 
                                        background: 'rgba(34, 197, 94, 0.2)', 
                                        color: '#4ade80',
                                        border: '1px solid rgba(34, 197, 94, 0.4)'
                                    }}, 
                                        '✓ Multi-Stat RAPM V3.1 (' + (playerRAPMStats?.calculatedStats?.length || 1) + ' stats, ' + (playerRAPMStats?.playerCount || 0) + ' players, λ=' + (playerRAPMStats?.lambda || 800) + ')'
                                    ),
                                    // Toggle RAPM on/off
                                    rapmAvailable && rapmMapping?.useRapm && e('button', { 
                                        style: { 
                                            fontSize: '11px', 
                                            padding: '6px 12px', 
                                            borderRadius: '12px', 
                                            background: lbUseRapm ? 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)' : 'rgba(100, 116, 139, 0.3)', 
                                            color: 'white',
                                            border: 'none',
                                            cursor: 'pointer',
                                            fontWeight: '600'
                                        },
                                        onClick: () => setLbUseRapm(!lbUseRapm)
                                    }, 
                                        lbUseRapm ? '📊 RAPM: ON' : '📋 RAPM: OFF'
                                    ),
                                    // Recalculate RAPM button
                                    rapmAvailable && !isCalculatingPlayerRAPM && e('button', { 
                                        style: { 
                                            fontSize: '11px', 
                                            padding: '6px 12px', 
                                            borderRadius: '12px', 
                                            background: 'rgba(100, 116, 139, 0.3)', 
                                            color: 'white',
                                            border: 'none',
                                            cursor: 'pointer',
                                            fontWeight: '500'
                                        },
                                        onClick: triggerPlayerRAPMCalculation
                                    }, 
                                        '🔄 Recalculate'
                                    ),
                                    isCalculatingPlayerRAPM && e('span', { style: { 
                                        fontSize: '11px', 
                                        padding: '4px 10px', 
                                        borderRadius: '12px', 
                                        background: 'rgba(251, 191, 36, 0.2)', 
                                        color: '#fbbf24',
                                        border: '1px solid rgba(251, 191, 36, 0.4)'
                                    }}, 
                                        '⏳ Computing Player RAPM... ' + playerRapmProgress + '% - ' + playerRapmMessage
                                    ),
                                    !rapmAvailable && !isCalculatingPlayerRAPM && stintsData.length > 0 && e('button', { 
                                        style: { 
                                            fontSize: '11px', 
                                            padding: '6px 12px', 
                                            borderRadius: '12px', 
                                            background: 'linear-gradient(135deg, #06b6d4 0%, #0891b2 100%)', 
                                            color: 'white',
                                            border: 'none',
                                            cursor: 'pointer',
                                            fontWeight: '600'
                                        },
                                        onClick: triggerPlayerRAPMCalculation
                                    }, 
                                        '📊 Calculate Player RAPM (' + stintsData.length + ' stints)'
                                    ),
                                    !rapmAvailable && !isCalculatingPlayerRAPM && stintsData.length === 0 && e('span', { style: { 
                                        fontSize: '11px', 
                                        padding: '4px 10px', 
                                        borderRadius: '12px', 
                                        background: 'rgba(100, 116, 139, 0.2)', 
                                        color: '#94a3b8',
                                        border: '1px solid rgba(100, 116, 139, 0.4)'
                                    }}, 
                                        '⚠️ Upload stints.csv for Player RAPM'
                                    ),
                                    useRapmForStat && e('span', { style: { 
                                        fontSize: '11px', 
                                        padding: '4px 10px', 
                                        borderRadius: '12px', 
                                        background: 'rgba(139, 92, 246, 0.2)', 
                                        color: '#a78bfa',
                                        border: '1px solid rgba(139, 92, 246, 0.4)'
                                    }}, 
                                        '📊 Using RAPM for this stat'
                                    ),
                                    !useRapmForStat && rapmMapping && !rapmMapping.useRapm && e('span', { style: { 
                                        fontSize: '11px', 
                                        padding: '4px 10px', 
                                        borderRadius: '12px', 
                                        background: 'rgba(100, 116, 139, 0.2)', 
                                        color: '#94a3b8',
                                        border: '1px solid rgba(100, 116, 139, 0.4)'
                                    }}, 
                                        '📋 On/Off only (RAPM N/A)'
                                    ),
                                    // V5.12: APM calculation section (requires RAPM to be calculated first)
                                    rapmAvailable && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg && e('span', { 
                                        style: { borderLeft: '1px solid #475569', height: '20px', margin: '0 4px' }
                                    }),
                                    rapmAvailable && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg && (
                                        playerApmStats && playerApmStats.players 
                                            ? e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' }},
                                                e('span', { style: { 
                                                    fontSize: '11px', 
                                                    padding: '4px 10px', 
                                                    borderRadius: '12px', 
                                                    background: 'rgba(139, 92, 246, 0.2)', 
                                                    color: '#a78bfa',
                                                    border: '1px solid rgba(139, 92, 246, 0.4)'
                                                }}, 
                                                    '✓ 🔮 Bayesian Box APM (λ=' + (playerApmStats.lambda || rapmLambda) + ', ' + (playerApmStats?.playerCount || 0) + ' players)'
                                                ),
                                                e('button', {
                                                    style: { 
                                                        fontSize: '11px', 
                                                        padding: '6px 12px', 
                                                        borderRadius: '12px', 
                                                        background: rapmLambda !== playerApmStats.lambda ? 'linear-gradient(135deg, #8b5cf6, #7c3aed)' : 'rgba(100, 116, 139, 0.3)', 
                                                        color: 'white',
                                                        border: 'none',
                                                        cursor: 'pointer',
                                                        fontWeight: rapmLambda !== playerApmStats.lambda ? '600' : '500'
                                                    },
                                                    onClick: triggerAPMCalculation
                                                }, rapmLambda !== playerApmStats.lambda ? '⚡ Recalc APM' : '🔄 Recalc APM')
                                            )
                                            : isCalculatingAPM 
                                                ? e('span', { style: { 
                                                    fontSize: '11px', 
                                                    padding: '4px 10px', 
                                                    borderRadius: '12px', 
                                                    background: 'rgba(139, 92, 246, 0.2)', 
                                                    color: '#a78bfa',
                                                    border: '1px solid rgba(139, 92, 246, 0.4)'
                                                }}, 
                                                    '🔮 Computing Bayesian Box APM... ' + apmProgress + '%'
                                                )
                                                : seasonStatsMap.size > 0 
                                                    ? e('button', { 
                                                        style: { 
                                                            fontSize: '11px', 
                                                            padding: '6px 12px', 
                                                            borderRadius: '12px', 
                                                            background: 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)', 
                                                            color: 'white',
                                                            border: 'none',
                                                            cursor: 'pointer',
                                                            fontWeight: '600'
                                                        },
                                                        onClick: triggerAPMCalculation
                                                    }, 
                                                        '🔮 Calculate APM (' + seasonStatsMap.size + ' players)'
                                                    )
                                                    : e('span', { style: { 
                                                        fontSize: '11px', 
                                                        padding: '4px 10px', 
                                                        borderRadius: '12px', 
                                                        background: 'rgba(100, 116, 139, 0.2)', 
                                                        color: '#94a3b8',
                                                        border: '1px solid rgba(100, 116, 139, 0.4)'
                                                    }}, 
                                                        '⚠️ Upload season stats for APM'
                                                    )
                                    )
                                )
                            ),
                            !isTabMode && e('button', { className: 'modal-close', onClick: () => setShowLeaderboard(false) }, '×')
                        ),
                        
                        // V4.9.8.6: Tab buttons for Full Table, On/Off, Individual
                        e('div', { style: { display: 'flex', gap: '8px', marginBottom: '16px', borderBottom: '1px solid #475569', paddingBottom: '12px' }},
                            e('button', { 
                                className: 'btn',
                                style: { 
                                    background: lbSubtab === 'fullTable' ? 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)' : '#475569',
                                    color: 'white',
                                    fontWeight: lbSubtab === 'fullTable' ? '600' : '400',
                                    border: lbSubtab === 'fullTable' ? '2px solid #fbbf24' : 'none'
                                },
                                onClick: () => setLbSubtab('fullTable')
                            }, '📊 Full Table'),
                            e('button', { 
                                className: 'btn',
                                style: { 
                                    background: lbSubtab === 'onoff' ? 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)' : '#475569',
                                    color: 'white',
                                    fontWeight: lbSubtab === 'onoff' ? '600' : '400'
                                },
                                onClick: () => setLbSubtab('onoff')
                            }, '📈 On/Off Stats'),
                            e('button', {
                                className: 'btn',
                                style: {
                                    background: lbSubtab === 'individual' ? 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)' : '#475569',
                                    color: 'white',
                                    fontWeight: lbSubtab === 'individual' ? '600' : '400'
                                },
                                onClick: () => setLbSubtab('individual')
                            }, '👤 Individual Stats'),
                            e('button', {
                                className: 'btn',
                                style: {
                                    background: lbSubtab === 'teams' ? 'linear-gradient(135deg, #10b981 0%, #059669 100%)' : '#475569',
                                    color: 'white',
                                    fontWeight: lbSubtab === 'teams' ? '600' : '400',
                                    border: lbSubtab === 'teams' ? '2px solid #34d399' : 'none'
                                },
                                onClick: () => setLbSubtab('teams')
                            }, '🏀 Teams')
                        ),
                        
                        // V6.1: Full Table Tab (PRIMARY - BartTorvik style)
                        lbSubtab === 'fullTable' && (() => {
                            // Build player-game participation from stints data (at least 1 minute = 60 seconds to count as played)
                            const playerGamesFromStints = new Map(); // normalized player name -> { games: Set, totalMinutes: number }
                            if (stintsData.length > 0) {
                                // First pass: accumulate minutes per player per game
                                const playerGameMinutes = new Map(); // "playerNorm|||gameId" -> minutes
                                stintsData.forEach(s => {
                                    const gameId = s.game_id;
                                    if (!gameId) return;
                                    const startTime = parseFloat(s.start_time) || 0;
                                    const endTime = parseFloat(s.end_time) || 0;
                                    const durationSec = endTime - startTime;
                                    if (durationSec <= 0) return;
                                    
                                    // Process home lineup
                                    const homeLineup = s.home_lineup || '';
                                    homeLineup.split(',').forEach(p => {
                                        const pNorm = normalizePlayerName(p.trim());
                                        if (!pNorm) return;
                                        const key = pNorm + '|||' + gameId;
                                        playerGameMinutes.set(key, (playerGameMinutes.get(key) || 0) + durationSec);
                                    });
                                    
                                    // Process away lineup
                                    const awayLineup = s.away_lineup || '';
                                    awayLineup.split(',').forEach(p => {
                                        const pNorm = normalizePlayerName(p.trim());
                                        if (!pNorm) return;
                                        const key = pNorm + '|||' + gameId;
                                        playerGameMinutes.set(key, (playerGameMinutes.get(key) || 0) + durationSec);
                                    });
                                });
                                
                                // Second pass: count games where player had at least 60 seconds (1 minute)
                                playerGameMinutes.forEach((totalSec, key) => {
                                    const [pNorm, gameId] = key.split('|||');
                                    if (totalSec >= 60) { // At least 1 minute
                                        if (!playerGamesFromStints.has(pNorm)) {
                                            playerGamesFromStints.set(pNorm, { games: new Set(), totalMinutes: 0 });
                                        }
                                        const data = playerGamesFromStints.get(pNorm);
                                        data.games.add(gameId);
                                        data.totalMinutes += totalSec / 60; // Convert to minutes
                                    }
                                });
                            }
                            
                            // Build global individual stats lookup from playerData (not filtered by team)
                            const globalIndivStats = {};
                            if (playerData.length && lineupData.length) {
                                // Group playerData by player+team
                                const pm = new Map();
                                playerData.forEach(pd => {
                                    // Support both Player and Player_Name columns
                                    const player = pd.Player ? pd.Player.trim() : (pd.Player_Name ? pd.Player_Name.trim() : '');
                                    const teamName = pd.Team || '';
                                    if (!player) return;
                                    const key = player + '|||' + teamName;
                                    const min = parseFloat(pd.Minutes) || parseFloat(pd.MIN) || 0;
                                    const fga = parseFloat(pd.FGA) || 0;
                                    const oreb = parseFloat(pd.OREB) || 0;
                                    const tov = parseFloat(pd.TOV) || 0;
                                    const fta = parseFloat(pd.FTA) || 0;
                                    const pPoss = calcPoss(fga, oreb, tov, fta);
                                    if (!pm.has(key)) pm.set(key, { player, team: teamName, minutes: 0, pts: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, reb: 0, ast: 0, stl: 0, blk: 0, tov: 0, pPoss: 0, games: new Set() });
                                    const x = pm.get(key);
                                    x.minutes += min;
                                    x.pts += parseFloat(pd.PTS) || 0;
                                    x.fgm += parseFloat(pd.FGM) || 0;
                                    x.fga += fga;
                                    x.tpm += parseFloat(pd['3PM']) || 0;
                                    x.tpa += parseFloat(pd['3PA']) || 0;
                                    x.ftm += parseFloat(pd.FTM) || 0;
                                    x.fta += fta;
                                    x.oreb += oreb;
                                    x.dreb += parseFloat(pd.DREB) || 0;
                                    x.reb += parseFloat(pd.REB) || 0;
                                    x.ast += parseFloat(pd.AST) || 0;
                                    x.stl += parseFloat(pd.STL) || 0;
                                    x.blk += parseFloat(pd.BLK) || 0;
                                    x.tov += tov;
                                    x.pPoss += pPoss;
                                    // Track games for MPG calculation
                                    if (pd.Game_ID) x.games.add(pd.Game_ID);
                                });
                                
                                // Calculate all stats for each player
                                pm.forEach((p, key) => {
                                    // Get lineup possessions for this player
                                    const pNorm = normalizePlayerName(p.player);
                                    const pLineups = lineupData.filter(l => {
                                        if (l.Team !== p.team) return false;
                                        const lp = l.Lineup ? l.Lineup.split(',').map(x => normalizePlayerName(x)) : [];
                                        return lp.some(x => x === pNorm);
                                    });
                                    const lpTotal = pLineups.reduce((s, l) => s + (l.POSS || 0), 0);
                                    const lpTotalV = pLineups.reduce((s, l) => s + (parseFloat(l.POSS_VS) || 0), 0);
                                    
                                    // Team totals for this player's lineups
                                    const lpTeam = pLineups.reduce((acc, l) => ({
                                        fgm: acc.fgm + (parseFloat(l.FGM) || 0),
                                        fga: acc.fga + (parseFloat(l.FGA) || 0),
                                        fgaV: acc.fgaV + (parseFloat(l.FGA_VS) || 0),
                                        tpaV: acc.tpaV + (parseFloat(l['3PA_VS']) || 0),
                                        oreb: acc.oreb + (parseFloat(l.OREB) || 0),
                                        dreb: acc.dreb + (parseFloat(l.DREB) || 0),
                                        drebV: acc.drebV + (parseFloat(l.DREB_VS) || 0),
                                        orebV: acc.orebV + (parseFloat(l.OREB_VS) || 0)
                                    }), { fgm: 0, fga: 0, fgaV: 0, tpaV: 0, oreb: 0, dreb: 0, drebV: 0, orebV: 0 });
                                    
                                    // Get games/minutes from stints data if available, otherwise from seasonStatsMap
                                    // Use fuzzy matching to handle name variations (e.g., Aaryn Rai vs Aaryndeep Rai)
                                    const seasonStats = findPlayerInMap(p.player, seasonStatsMap) || seasonStatsMap.get(pNorm) || null;
                                    
                                    // Also try fuzzy match for stints data
                                    let stintsPlayerData = playerGamesFromStints.get(pNorm);
                                    if (!stintsPlayerData) {
                                        // Try fuzzy match in stints map
                                        for (const [key, value] of playerGamesFromStints.entries()) {
                                            if (fuzzyMatchPlayerName(p.player, key)) {
                                                stintsPlayerData = value;
                                                break;
                                            }
                                        }
                                    }
                                    let games, mpg, totalMinutes;
                                    
                                    if (stintsPlayerData && stintsPlayerData.games.size > 0) {
                                        // Use stints data for games and minutes
                                        games = stintsPlayerData.games.size;
                                        totalMinutes = stintsPlayerData.totalMinutes;
                                        mpg = games > 0 ? totalMinutes / games : 0;
                                    } else if (seasonStats) {
                                        // Fallback to season stats
                                        games = seasonStats.games || 0;
                                        mpg = seasonStats.mpg || 0;
                                        totalMinutes = seasonStats.min || p.minutes;
                                    } else {
                                        // Fallback to playerData
                                        games = p.games.size || 1;
                                        totalMinutes = p.minutes;
                                        mpg = games > 0 ? p.minutes / games : 0;
                                    }
                                    
                                    // Use raw totals from seasonStatsMap if available (more complete)
                                    const pts = seasonStats ? seasonStats.pts : p.pts;
                                    const reb = seasonStats ? seasonStats.reb : p.reb;
                                    const oreb = seasonStats ? seasonStats.oreb : p.oreb;
                                    const dreb = seasonStats ? seasonStats.dreb : p.dreb;
                                    const ast = seasonStats ? seasonStats.ast : p.ast;
                                    const stl = seasonStats ? seasonStats.stl : p.stl;
                                    const blk = seasonStats ? seasonStats.blk : p.blk;
                                    const tov = seasonStats ? seasonStats.tov : p.tov;
                                    const tpa = seasonStats ? seasonStats.tpa : p.tpa;
                                    const fgm = seasonStats ? seasonStats.fgm : p.fgm;
                                    const fga = seasonStats ? seasonStats.fga : p.fga;
                                    const tpm = seasonStats ? seasonStats.tpm : p.tpm;
                                    const ftm = seasonStats ? seasonStats.ftm : p.ftm;
                                    const fta = seasonStats ? seasonStats.fta : p.fta;
                                    
                                    // Calculate individual player possessions using Dean Oliver formula
                                    const playerPoss = fga - oreb + tov + 0.44 * fta;
                                    
                                    // Get team season totals from team_totals.csv
                                    const teamTotals = teamSeasonTotals.get(p.team);
                                    const teamTotalPoss = teamTotals ? teamTotals.totalPoss : 0;
                                    const teamTotalMinutes = teamTotals ? teamTotals.totalMinutes : 0;
                                    
                                    // Per 75/100 team possessions formula:
                                    // EstimatedTeamPossWhileOnCourt = TeamTotalPoss * (PlayerMinutes / TeamTotalMinutes)
                                    // Per75 = Stat * 75 / EstimatedTeamPossWhileOnCourt
                                    //       = Stat * 75 * TeamTotalMinutes / (TeamTotalPoss * PlayerMinutes)
                                    let per75 = 0, per100 = 0;
                                    if (teamTotalPoss > 0 && totalMinutes > 0 && teamTotalMinutes > 0) {
                                        const estimatedTeamPossOnCourt = teamTotalPoss * (totalMinutes / teamTotalMinutes);
                                        per75 = 75 / estimatedTeamPossOnCourt;
                                        per100 = 100 / estimatedTeamPossOnCourt;
                                    }
                                    
                                    // USG% = 100 * (PlayerPoss / EstimatedTeamPossWhileOnCourt)
                                    // Use seasonStatsMap USG% if available, otherwise calculate
                                    let usgPct = 0;
                                    if (seasonStats && seasonStats.usg > 0) {
                                        usgPct = seasonStats.usg;
                                    } else if (teamTotalPoss > 0 && totalMinutes > 0 && teamTotalMinutes > 0) {
                                        const estimatedTeamPossOnCourt = teamTotalPoss * (totalMinutes / teamTotalMinutes);
                                        usgPct = estimatedTeamPossOnCourt > 0 ? (playerPoss / estimatedTeamPossOnCourt) * 100 : 0;
                                    }
                                    
                                    // Shooting percentages
                                    const fgPct = fga > 0 ? (fgm / fga) * 100 : 0;
                                    const threePct = tpa > 0 ? (tpm / tpa) * 100 : 0;
                                    const ftPct = fta > 0 ? (ftm / fta) * 100 : 0;
                                    const efgPct = fga > 0 ? ((fgm + 0.5 * tpm) / fga) * 100 : 0;
                                    const tsPct = (2 * (fga + 0.44 * fta)) > 0 ? (pts / (2 * (fga + 0.44 * fta))) * 100 : 0;
                                    const ftr = fga > 0 ? (fta / fga) * 100 : 0;
                                    
                                    // Rebounding percentages (individual)
                                    const orebAvail = lpTeam.oreb + lpTeam.drebV;
                                    const drebAvail = lpTeam.dreb + lpTeam.orebV;
                                    const orebPct = orebAvail > 0 ? (oreb / orebAvail) * 100 : 0;
                                    const drebPct = drebAvail > 0 ? (dreb / drebAvail) * 100 : 0;
                                    const trbPct = (orebAvail + drebAvail) > 0 ? (reb / (orebAvail + drebAvail)) * 100 : 0;
                                    
                                    // Playmaking (AST% = AST / teammate FGM)
                                    const teammateFgm = lpTeam.fgm - fgm;
                                    const astPct = teammateFgm > 0 ? (ast / teammateFgm) * 100 : 0;
                                    const tovPct = playerPoss > 0 ? (tov / playerPoss) * 100 : 0;
                                    
                                    // Defense (STL% and BLK% use opponent possessions)
                                    const stlPct = lpTotalV > 0 ? (stl / lpTotalV) * 100 : 0;
                                    const blkPct = (lpTeam.fgaV - lpTeam.tpaV) > 0 ? (blk / (lpTeam.fgaV - lpTeam.tpaV)) * 100 : 0;
                                    
                                    // BPM from seasonStatsMap (lowercase property names)
                                    const bpm = seasonStats && seasonStats.bpm !== null ? seasonStats.bpm : 0;
                                    const obpm = seasonStats && seasonStats.obpm !== null ? seasonStats.obpm : 0;
                                    const dbpm = seasonStats && seasonStats.dbpm !== null ? seasonStats.dbpm : 0;
                                    
                                    globalIndivStats[key] = {
                                        // Games/Minutes
                                        totalMinutes: totalMinutes,
                                        games: games,
                                        mpg: mpg,
                                        // Per 75
                                        pts75: pts * per75,
                                        reb75: reb * per75,
                                        oreb75: oreb * per75,
                                        dreb75: dreb * per75,
                                        ast75: ast * per75,
                                        stl75: stl * per75,
                                        blk75: blk * per75,
                                        tov75: tov * per75,
                                        // Per 100
                                        pts100: pts * per100,
                                        reb100: reb * per100,
                                        ast100: ast * per100,
                                        tpa100: tpa * per100,
                                        // Shooting
                                        fgPct: fgPct,
                                        threePct: threePct,
                                        ftPct: ftPct,
                                        efgPct: efgPct,
                                        tsPct: tsPct,
                                        ftr: ftr,
                                        // Usage
                                        usgPct: usgPct,
                                        // Rebounding
                                        orebPct: orebPct,
                                        drebPct: drebPct,
                                        trbPct: trbPct,
                                        // Playmaking/Turnovers
                                        astPct: astPct,
                                        tovPct: tovPct,
                                        // Defense
                                        stlPct: stlPct,
                                        blkPct: blkPct,
                                        // BPM
                                        bpm: bpm,
                                        obpm: obpm,
                                        dbpm: dbpm
                                    };
                                });
                            }
                            
                            // Calculate team averages for +/- from team avg display
                            const teamAverages = {};
                            teams.forEach(teamName => {
                                const teamLineups = lineupData.filter(l => l.Team === teamName);
                                if (teamLineups.length === 0) return;
                                
                                const t = teamLineups.reduce((acc, l) => {
                                    const fga = parseFloat(l.FGA)||0, fgm = parseFloat(l.FGM)||0;
                                    const tpm = parseFloat(l['3PM'])||0, tpa = parseFloat(l['3PA'])||0;
                                    const ftm = parseFloat(l.FTM)||0, fta = parseFloat(l.FTA)||0;
                                    const oreb = parseFloat(l.OREB)||0, dreb = parseFloat(l.DREB)||0;
                                    const tov = parseFloat(l.TOV)||0, ast = parseFloat(l.AST)||0;
                                    const stl = parseFloat(l.STL)||0, blk = parseFloat(l.BLK)||0;
                                    const fgaV = parseFloat(l.FGA_VS)||0, fgmV = parseFloat(l.FGM_VS)||0;
                                    const tpmV = parseFloat(l['3PM_VS'])||0, tpaV = parseFloat(l['3PA_VS'])||0;
                                    const ftmV = parseFloat(l.FTM_VS)||0, ftaV = parseFloat(l.FTA_VS)||0;
                                    const orebV = parseFloat(l.OREB_VS)||0, drebV = parseFloat(l.DREB_VS)||0;
                                    const tovV = parseFloat(l.TOV_VS)||0;
                                    const rimA = parseFloat(l.RIM_ATT)||0, rimM = parseFloat(l.RIM_MADE)||0;
                                    const midA = parseFloat(l.OTD_2PT_ATT)||0, midM = parseFloat(l.OTD_2PT_MADE)||0;
                                    const threeA = parseFloat(l.OTD_3PT_ATT)||0, threeM = parseFloat(l.OTD_3PT_MADE)||0;
                                    const rimAV = parseFloat(l.RIM_ATT_VS)||0, rimMV = parseFloat(l.RIM_MADE_VS)||0;
                                    const midAV = parseFloat(l.OTD_2PT_ATT_VS)||0, midMV = parseFloat(l.OTD_2PT_MADE_VS)||0;
                                    const threeAV = parseFloat(l.OTD_3PT_ATT_VS)||0, threeMV = parseFloat(l.OTD_3PT_MADE_VS)||0;
                                    const poss = calcPoss(fga, oreb, tov, fta);
                                    const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                                    const pts = fgm * 2 + tpm + ftm;
                                    const ptsV = fgmV * 2 + tpmV + ftmV;
                                    const time = parseFloat(l.TIME)||0;
                                    const secChance = parseFloat(l['2ND_CHANCE_PTS'])||0;
                                    const ptsOffTov = parseFloat(l.PTS_OFF_TOV)||0;
                                    const fastBreak = parseFloat(l.FAST_BREAK_PTS)||0;
                                    const secChanceV = parseFloat(l['2ND_CHANCE_PTS_VS'])||0;
                                    const ptsOffTovV = parseFloat(l.PTS_OFF_TOV_VS)||0;
                                    const fastBreakV = parseFloat(l.FAST_BREAK_PTS_VS)||0;
                                    return {
                                        fga: acc.fga + fga, fgm: acc.fgm + fgm, tpm: acc.tpm + tpm, tpa: acc.tpa + tpa,
                                        ftm: acc.ftm + ftm, fta: acc.fta + fta, oreb: acc.oreb + oreb, dreb: acc.dreb + dreb,
                                        tov: acc.tov + tov, ast: acc.ast + ast, stl: acc.stl + stl, blk: acc.blk + blk,
                                        fgaV: acc.fgaV + fgaV, fgmV: acc.fgmV + fgmV, tpmV: acc.tpmV + tpmV, tpaV: acc.tpaV + tpaV,
                                        ftmV: acc.ftmV + ftmV, ftaV: acc.ftaV + ftaV, orebV: acc.orebV + orebV,
                                        drebV: acc.drebV + drebV, tovV: acc.tovV + tovV,
                                        rimA: acc.rimA + rimA, rimM: acc.rimM + rimM,
                                        midA: acc.midA + midA, midM: acc.midM + midM,
                                        threeA: acc.threeA + threeA, threeM: acc.threeM + threeM,
                                        rimAV: acc.rimAV + rimAV, rimMV: acc.rimMV + rimMV,
                                        midAV: acc.midAV + midAV, midMV: acc.midMV + midMV,
                                        threeAV: acc.threeAV + threeAV, threeMV: acc.threeMV + threeMV,
                                        poss: acc.poss + poss, possV: acc.possV + possV,
                                        pts: acc.pts + pts, ptsV: acc.ptsV + ptsV,
                                        time: acc.time + time, secChance: acc.secChance + secChance,
                                        ptsOffTov: acc.ptsOffTov + ptsOffTov, fastBreak: acc.fastBreak + fastBreak,
                                        secChanceV: acc.secChanceV + secChanceV, ptsOffTovV: acc.ptsOffTovV + ptsOffTovV,
                                        fastBreakV: acc.fastBreakV + fastBreakV
                                    };
                                }, { fga:0, fgm:0, tpm:0, tpa:0, ftm:0, fta:0, oreb:0, dreb:0, tov:0, ast:0, stl:0, blk:0,
                                     fgaV:0, fgmV:0, tpmV:0, tpaV:0, ftmV:0, ftaV:0, orebV:0, drebV:0, tovV:0,
                                     rimA:0, rimM:0, midA:0, midM:0, threeA:0, threeM:0,
                                     rimAV:0, rimMV:0, midAV:0, midMV:0, threeAV:0, threeMV:0,
                                     poss:0, possV:0, pts:0, ptsV:0, time:0, secChance:0, ptsOffTov:0, fastBreak:0,
                                     secChanceV:0, ptsOffTovV:0, fastBreakV:0 });
                                
                                const offRtg = t.poss > 0 ? (t.pts / t.poss) * 100 : 0;
                                const defRtg = t.possV > 0 ? (t.ptsV / t.possV) * 100 : 0;
                                const offTovDenom = t.fga + 0.44 * t.fta + t.tov;
                                const defTovDenom = t.fgaV + 0.44 * t.ftaV + t.tovV;
                                
                                teamAverages[teamName] = {
                                    off: offRtg,
                                    def: defRtg,
                                    net: offRtg - defRtg,
                                    offEfg: t.fga > 0 ? ((t.fgm + 0.5*t.tpm)/t.fga)*100 : 0,
                                    offTov: offTovDenom > 0 ? (t.tov/offTovDenom)*100 : 0,
                                    offOreb: (t.oreb+t.drebV) > 0 ? (t.oreb/(t.oreb+t.drebV))*100 : 0,
                                    offFtR: t.fga > 0 ? (t.fta/t.fga)*100 : 0,
                                    defEfg: t.fgaV > 0 ? ((t.fgmV + 0.5*t.tpmV)/t.fgaV)*100 : 0,
                                    defTov: defTovDenom > 0 ? (t.tovV/defTovDenom)*100 : 0,
                                    defOreb: (t.orebV+t.dreb) > 0 ? (t.orebV/(t.orebV+t.dreb))*100 : 0,
                                    defFtR: t.fgaV > 0 ? (t.ftaV/t.fgaV)*100 : 0,
                                    rimPct: t.rimA > 0 ? (t.rimM/t.rimA)*100 : 0,
                                    midPct: t.midA > 0 ? (t.midM/t.midA)*100 : 0,
                                    threePct: t.threeA > 0 ? (t.threeM/t.threeA)*100 : 0,
                                    rimPctV: t.rimAV > 0 ? (t.rimMV/t.rimAV)*100 : 0,
                                    midPctV: t.midAV > 0 ? (t.midMV/t.midAV)*100 : 0,
                                    threePctV: t.threeAV > 0 ? (t.threeMV/t.threeAV)*100 : 0,
                                    rimVol: t.poss > 0 ? (t.rimA / t.poss) * 100 : 0,
                                    midVol: t.poss > 0 ? (t.midA / t.poss) * 100 : 0,
                                    threeVol: t.poss > 0 ? (t.threeA / t.poss) * 100 : 0,
                                    rimVolV: t.possV > 0 ? (t.rimAV / t.possV) * 100 : 0,
                                    midVolV: t.possV > 0 ? (t.midAV / t.possV) * 100 : 0,
                                    threeVolV: t.possV > 0 ? (t.threeAV / t.possV) * 100 : 0,
                                    astPct: t.fgm > 0 ? (t.ast/t.fgm)*100 : 0,
                                    stlPct: t.possV > 0 ? (t.stl/t.possV)*100 : 0,
                                    blkPct: (t.fgaV-t.tpaV) > 0 ? (t.blk/(t.fgaV-t.tpaV))*100 : 0,
                                    paceF: t.time > 0 ? (t.poss / t.time) * 2400 : 0,
                                    paceV: t.time > 0 ? (t.possV / t.time) * 2400 : 0,
                                    secChance100: t.poss > 0 ? (t.secChance / t.poss) * 100 : 0,
                                    ptsOffTov100: t.poss > 0 ? (t.ptsOffTov / t.poss) * 100 : 0,
                                    fastBreak100: t.poss > 0 ? (t.fastBreak / t.poss) * 100 : 0,
                                    secChance100V: t.possV > 0 ? (t.secChanceV / t.possV) * 100 : 0,
                                    ptsOffTov100V: t.possV > 0 ? (t.ptsOffTovV / t.possV) * 100 : 0,
                                    fastBreak100V: t.possV > 0 ? (t.fastBreakV / t.possV) * 100 : 0,
                                    tpm: t.tpm, tpa: t.tpa, tpmV: t.tpmV, tpaV: t.tpaV, poss: t.poss, possV: t.possV
                                };
                            });
                            
                            // Check if RAPM is available - use playerRapmStats directly
                            const hasRapm = playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg && !playerRapmStats.error;
                            const hasApm = playerApmStats && playerApmStats.players;

                            // ====================================================================
                            // VS. STARTERS MODE: Compute individual player stats from player_stints.csv
                            // V8.0: Uses player_stints.csv with smart matching against regular starters (3+ game starts)
                            //       and game starters (4+ of that game's starting 5), avoiding double counting
                            // ====================================================================
                            const vsStartersAnalysis = (() => {
                                if (!leaderboardTableVsStarters || !playerStintsData.length) {
                                    return { vsStartersPlayerStats: {}, hasVsStartersData: false };
                                }

                                // Step 1: Identify regular starters (players with 3+ game starts) per team
                                // Group player stints by game_id and team to find opening lineups
                                const gameTeamOpeningLineups = {}; // { gameId|team: { startTime, players (Set), playersOriginal } }
                                const playerGamesStarted = {}; // { team: { player: count } }

                                playerStintsData.forEach(stint => {
                                    const gameId = stint.game_id;
                                    const period = parseInt(stint.period);
                                    const startTime = parseFloat(stint.start_time) || 0;
                                    if (!gameId || period !== 1) return;

                                    const teamName = stint.team || '';
                                    const isHome = stint.is_home_team === 'True' || stint.is_home_team === 'true' || stint.is_home_team === '1' || stint.is_home_team === true;
                                    const myLineup = isHome ? stint.home_lineup : stint.away_lineup;
                                    if (!teamName || !myLineup) return;

                                    const gameTeamKey = gameId + '|' + teamName;

                                    // Track earliest start_time for this game-team combo
                                    if (!gameTeamOpeningLineups[gameTeamKey] || startTime < gameTeamOpeningLineups[gameTeamKey].startTime) {
                                        const players = myLineup.split(',').map(p => applyGlobalPlayerMerge(p.trim()));
                                        gameTeamOpeningLineups[gameTeamKey] = {
                                            startTime,
                                            players: new Set(players.map(p => p.toLowerCase())),
                                            playersOriginal: players
                                        };
                                    }
                                });

                                // Count games started per player per team
                                Object.entries(gameTeamOpeningLineups).forEach(([key, data]) => {
                                    const teamName = key.split('|')[1];
                                    if (!playerGamesStarted[teamName]) playerGamesStarted[teamName] = {};
                                    data.playersOriginal.forEach(player => {
                                        if (!player) return;
                                        playerGamesStarted[teamName][player] = (playerGamesStarted[teamName][player] || 0) + 1;
                                    });
                                });

                                // Regular starters = players with N+ starts (configurable via settings)
                                const minGamesStartedForStarter = leaderboardTableVsStartersMinGames;
                                const regularStarters = {}; // { team: Set of lowercase player names }
                                Object.entries(playerGamesStarted).forEach(([teamName, players]) => {
                                    regularStarters[teamName] = new Set(
                                        Object.entries(players)
                                            .filter(([_, count]) => count >= minGamesStartedForStarter)
                                            .map(([player, _]) => player.toLowerCase())
                                    );
                                });

                                // Step 2: Helper functions to count starters in opponent lineup
                                const countRegularStartersInLineup = (lineupStr, oppTeam) => {
                                    if (!lineupStr || !oppTeam) return 0;
                                    const oppStarters = regularStarters[oppTeam] || new Set();
                                    if (oppStarters.size === 0) return 0;
                                    const players = lineupStr.split(',').map(p => applyGlobalPlayerMerge(p.trim()).toLowerCase());
                                    return players.filter(p => oppStarters.has(p)).length;
                                };

                                const countGameStartersInLineup = (lineupStr, oppTeam, gameId) => {
                                    if (!lineupStr || !oppTeam || !gameId) return 0;
                                    const gameTeamKey = gameId + '|' + oppTeam;
                                    const gameStarterData = gameTeamOpeningLineups[gameTeamKey];
                                    if (!gameStarterData || gameStarterData.players.size === 0) return 0;
                                    const players = lineupStr.split(',').map(p => applyGlobalPlayerMerge(p.trim()).toLowerCase());
                                    return players.filter(p => gameStarterData.players.has(p)).length;
                                };

                                // Step 3: Process each player stint and aggregate stats for vs starters
                                const vsStartersPlayerStats = {}; // key: "player|||team" => aggregated stats
                                const processedStints = new Set(); // Track processed stints to avoid double counting

                                playerStintsData.forEach(stint => {
                                    const gameId = stint.game_id;
                                    const playerName = applyGlobalPlayerMerge((stint.player_name || '').trim());
                                    const teamName = stint.team || '';
                                    const oppTeam = stint.opponent || '';
                                    const isHome = stint.is_home_team === 'True' || stint.is_home_team === 'true' || stint.is_home_team === '1' || stint.is_home_team === true;
                                    const oppLineup = isHome ? stint.away_lineup : stint.home_lineup;
                                    const startTime = stint.start_time;
                                    const period = stint.period;

                                    if (!gameId || !playerName || !teamName || !oppTeam || !oppLineup) return;

                                    // Create unique stint identifier to avoid double counting
                                    const stintKey = `${gameId}|${playerName}|${period}|${startTime}`;
                                    if (processedStints.has(stintKey)) return;

                                    // Check if this stint qualifies as vs starters
                                    const regularStarterCount = countRegularStartersInLineup(oppLineup, oppTeam);
                                    const gameStarterCount = countGameStartersInLineup(oppLineup, oppTeam, gameId);

                                    // Qualify if 4+ regular starters OR 4+ game starters (no double counting needed
                                    // since we're just checking if the stint qualifies, not counting it twice)
                                    const isVsStarters = regularStarterCount >= 4 || gameStarterCount >= 4;
                                    if (!isVsStarters) return;

                                    processedStints.add(stintKey);

                                    const key = playerName + '|||' + teamName;

                                    if (!vsStartersPlayerStats[key]) {
                                        vsStartersPlayerStats[key] = {
                                            player: playerName, team: teamName,
                                            minutes: 0, pts: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0,
                                            oreb: 0, dreb: 0, reb: 0, ast: 0, stl: 0, blk: 0, tov: 0,
                                            lineupPoss: 0, games: new Set(), stintCount: 0,
                                            // Lineup-level stats for +/- calculation
                                            teamPts: 0, oppPts: 0, lineupDuration: 0
                                        };
                                    }
                                    const x = vsStartersPlayerStats[key];

                                    // Get individual player stats from this stint row
                                    const duration = parseFloat(stint.duration) || 0;
                                    const possessions = parseFloat(stint.possessions) || 0;

                                    // Add stint time and possessions
                                    x.minutes += duration / 60;
                                    x.lineupPoss += possessions;
                                    x.stintCount += 1;
                                    if (gameId) x.games.add(gameId);

                                    // Individual player box score stats from the stint
                                    x.pts += parseFloat(stint.pts) || 0;
                                    x.fgm += parseFloat(stint.fgm) || 0;
                                    x.fga += parseFloat(stint.fga) || 0;
                                    x.tpm += parseFloat(stint.fg3m) || 0;
                                    x.tpa += parseFloat(stint.fg3a) || 0;
                                    x.ftm += parseFloat(stint.ftm) || 0;
                                    x.fta += parseFloat(stint.fta) || 0;
                                    x.oreb += parseFloat(stint.oreb) || 0;
                                    x.dreb += parseFloat(stint.dreb) || 0;
                                    x.reb += (parseFloat(stint.oreb) || 0) + (parseFloat(stint.dreb) || 0);
                                    x.ast += parseFloat(stint.ast) || 0;
                                    x.stl += parseFloat(stint.stl) || 0;
                                    x.blk += parseFloat(stint.blk) || 0;
                                    x.tov += parseFloat(stint.tov) || 0;
                                });

                                // Calculate player possessions for each player (using their accumulated stats)
                                Object.values(vsStartersPlayerStats).forEach(x => {
                                    x.pPoss = calcPoss(x.fga, x.oreb, x.tov, x.fta);
                                });

                                // Step 4: Process stintsData (lineup-level) to calculate on-off +/- vs starters
                                // This uses the same logic as VS. Starters tab in Lineup Analyzer
                                if (stintsData && stintsData.length > 0) {
                                    const processedLineupStints = new Set();

                                    stintsData.forEach(stint => {
                                        const gameId = stint.game_id;
                                        const possessions = parseFloat(stint.possessions) || 0;
                                        if (!gameId || possessions < 0.5) return;

                                        // Process both home and away teams
                                        ['home', 'away'].forEach(side => {
                                            const isHome = side === 'home';
                                            const teamName = isHome ? stint.home_team : stint.away_team;
                                            const oppTeam = isHome ? stint.away_team : stint.home_team;
                                            const myLineup = isHome ? stint.home_lineup : stint.away_lineup;
                                            const oppLineup = isHome ? stint.away_lineup : stint.home_lineup;

                                            if (!teamName || !myLineup || !oppLineup) return;

                                            // Check if vs starters
                                            const regularStarterCount = countRegularStartersInLineup(oppLineup, oppTeam);
                                            const gameStarterCount = countGameStartersInLineup(oppLineup, oppTeam, gameId);
                                            const isVsStarters = regularStarterCount >= 4 || gameStarterCount >= 4;
                                            if (!isVsStarters) return;

                                            // Get lineup points
                                            const prefix = isHome ? 'home_' : 'away_';
                                            const oppPrefix = isHome ? 'away_' : 'home_';
                                            const teamPts = parseFloat(stint[prefix + 'points']) || 0;
                                            const oppPts = parseFloat(stint[oppPrefix + 'points']) || 0;
                                            const duration = parseFloat(stint.duration) || 0;

                                            // Credit each player in the lineup
                                            const players = myLineup.split(',').map(p => applyGlobalPlayerMerge(p.trim()));
                                            players.forEach(playerName => {
                                                if (!playerName) return;
                                                const key = playerName + '|||' + teamName;

                                                // Create unique stint identifier per player
                                                const stintKey = `${gameId}|${playerName}|${stint.period || ''}|${stint.start_time || ''}`;
                                                if (processedLineupStints.has(stintKey)) return;
                                                processedLineupStints.add(stintKey);

                                                if (!vsStartersPlayerStats[key]) {
                                                    vsStartersPlayerStats[key] = {
                                                        player: playerName, team: teamName,
                                                        minutes: 0, pts: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0,
                                                        oreb: 0, dreb: 0, reb: 0, ast: 0, stl: 0, blk: 0, tov: 0,
                                                        lineupPoss: 0, games: new Set(), stintCount: 0,
                                                        teamPts: 0, oppPts: 0, lineupDuration: 0
                                                    };
                                                }
                                                const x = vsStartersPlayerStats[key];
                                                x.teamPts += teamPts;
                                                x.oppPts += oppPts;
                                                x.lineupDuration += duration;
                                                // Also add lineup possessions if not already tracked
                                                if (!x.lineupPossFromStints) x.lineupPossFromStints = 0;
                                                x.lineupPossFromStints += possessions;
                                            });
                                        });
                                    });

                                    // Calculate net rating for each player
                                    Object.values(vsStartersPlayerStats).forEach(x => {
                                        const poss = x.lineupPossFromStints || x.lineupPoss || 1;
                                        x.vsNetRtg = poss > 0 ? ((x.teamPts - x.oppPts) / poss) * 100 : 0;
                                    });
                                }

                                return { vsStartersPlayerStats, hasVsStartersData: Object.keys(vsStartersPlayerStats).length > 0 };
                            })();

                            const { vsStartersPlayerStats, hasVsStartersData } = vsStartersAnalysis;

                            // Define all stat columns with proper grouping
                            const allStatColumns = [
                                // RAPM/APM (if available)
                                ...(hasRapm ? [
                                    { key: 'rapmNet', label: 'RAPM', group: 'RAPM', higherBetter: true, isRapm: true, section: 'rapm', desc: 'Regularized Adjusted Plus-Minus - Net rating impact controlling for teammates/opponents using ridge regression' },
                                    { key: 'rapmOff', label: 'O-RAPM', group: 'RAPM', higherBetter: true, isRapm: true, section: 'rapm', desc: 'Offensive RAPM - Offensive rating impact controlling for teammates/opponents' },
                                    { key: 'rapmDef', label: 'D-RAPM', group: 'RAPM', higherBetter: true, isRapm: true, section: 'rapm', desc: 'Defensive RAPM - Defensive rating impact controlling for teammates/opponents' }
                                ] : []),
                                ...(hasApm ? [
                                    { key: 'apmNet', label: 'APM', group: 'APM', higherBetter: true, isApm: true, section: 'apm', desc: 'Adjusted Plus-Minus - Net rating impact controlling for teammates/opponents' },
                                    { key: 'apmOff', label: 'O-APM', group: 'APM', higherBetter: true, isApm: true, section: 'apm', desc: 'Offensive APM - Offensive rating impact controlling for teammates/opponents' },
                                    { key: 'apmDef', label: 'D-APM', group: 'APM', higherBetter: true, isApm: true, section: 'apm', desc: 'Defensive APM - Defensive rating impact controlling for teammates/opponents' }
                                ] : []),
                                // Ratings (On/Off)
                                { key: 'net', label: 'Net±', group: 'Ratings', higherBetter: true, isOnOff: true, section: 'ratings', desc: 'Net Rating On vs Team Average - How much better/worse the team is with player on court' },
                                { key: 'off', label: 'ORtg±', group: 'Ratings', higherBetter: true, isOnOff: true, section: 'ratings', desc: 'Offensive Rating On vs Team Average - Offensive efficiency with player on court' },
                                { key: 'def', label: 'DRtg±', group: 'Ratings', higherBetter: true, isOnOff: true, section: 'ratings', desc: 'Defensive Rating On vs Team Average - Defensive efficiency with player on court (inverted: positive = better defense)' },
                                // Four Factors - Offense
                                { key: 'offEfg', label: 'eFG%±', group: 'FF (Off)', higherBetter: true, isOnOff: true, section: 'ff_off', desc: 'Effective FG% On vs Team Average - Team shooting efficiency with player on court' },
                                { key: 'offTov', label: 'TOV%±', group: 'FF (Off)', higherBetter: true, isOnOff: true, section: 'ff_off', desc: 'Turnover% On vs Team Average - Ball security with player on court (inverted: positive = fewer turnovers)' },
                                { key: 'offOreb', label: 'OREB%±', group: 'FF (Off)', higherBetter: true, isOnOff: true, section: 'ff_off', desc: 'Offensive Rebound% On vs Team Average - Second chance creation with player on court' },
                                { key: 'offFtR', label: 'FTR±', group: 'FF (Off)', higherBetter: true, isOnOff: true, section: 'ff_off', desc: 'Free Throw Rate On vs Team Average - Getting to the line with player on court' },
                                // Four Factors - Defense
                                { key: 'defEfg', label: 'Opp eFG%±', group: 'FF (Def)', higherBetter: true, isOnOff: true, section: 'ff_def', desc: 'Opponent eFG% On vs Team Average - Shot suppression with player on court (inverted: positive = lower opp eFG%)' },
                                { key: 'defTov', label: 'Frc TOV%±', group: 'FF (Def)', higherBetter: true, isOnOff: true, section: 'ff_def', desc: 'Forced Turnover% On vs Team Average - Turnover creation with player on court' },
                                { key: 'defOreb', label: 'Opp OREB%±', group: 'FF (Def)', higherBetter: true, isOnOff: true, section: 'ff_def', desc: 'Opponent OREB% On vs Team Average - Defensive rebounding with player on court (inverted: positive = fewer opp OREBs)' },
                                { key: 'defFtR', label: 'Opp FTR±', group: 'FF (Def)', higherBetter: true, isOnOff: true, section: 'ff_def', desc: 'Opponent FT Rate On vs Team Average - Preventing fouls with player on court (inverted: positive = fewer opp FTs)' },
                                // Shot Making - Offense
                                { key: 'rimPct', label: 'RIM%±', group: 'Shot% (Off)', higherBetter: true, isOnOff: true, section: 'shot_off', desc: 'Rim FG% On vs Team Average - Team rim finishing with player on court' },
                                { key: 'midPct', label: 'MID%±', group: 'Shot% (Off)', higherBetter: true, isOnOff: true, section: 'shot_off', desc: 'Mid-Range FG% On vs Team Average - Team mid-range shooting with player on court' },
                                { key: 'threePct', label: '3PT%±', group: 'Shot% (Off)', higherBetter: true, isOnOff: true, section: 'shot_off', desc: 'Three-Point% On vs Team Average - Team 3PT shooting with player on court' },
                                // Shot Making - Defense
                                { key: 'rimPctV', label: 'Opp RIM%±', group: 'Shot% (Def)', higherBetter: true, isOnOff: true, section: 'shot_def', desc: 'Opponent Rim FG% On vs Team Average - Rim protection with player on court (inverted: positive = lower opp Rim%)' },
                                { key: 'midPctV', label: 'Opp MID%±', group: 'Shot% (Def)', higherBetter: true, isOnOff: true, section: 'shot_def', desc: 'Opponent Mid% On vs Team Average - Mid-range defense with player on court (inverted)' },
                                { key: 'threePctV', label: 'Opp 3PT%±', group: 'Shot% (Def)', higherBetter: true, isOnOff: true, section: 'shot_def', desc: 'Opponent 3PT% On vs Team Average - Perimeter defense with player on court (inverted)' },
                                // Shot Volume - Offense
                                { key: 'rimVol', label: 'RIM Vol±', group: 'Vol (Off)', higherBetter: true, isOnOff: true, section: 'vol_off', desc: 'Rim Volume On vs Team Average - Team rim attempt rate with player on court' },
                                { key: 'midVol', label: 'MID Vol±', group: 'Vol (Off)', higherBetter: false, isOnOff: true, section: 'vol_off', desc: 'Mid-Range Volume On vs Team Average - Team mid-range attempt rate (negative = better shot selection)' },
                                { key: 'threeVol', label: '3PT Vol±', group: 'Vol (Off)', higherBetter: true, isOnOff: true, section: 'vol_off', desc: 'Three-Point Volume On vs Team Average - Team 3PT attempt rate with player on court' },
                                // Shot Volume - Defense
                                { key: 'rimVolV', label: 'Opp RIM Vol±', group: 'Vol (Def)', higherBetter: true, isOnOff: true, section: 'vol_def', desc: 'Opponent Rim Volume On vs Team Average - Preventing rim attempts (inverted: positive = fewer opp rim attempts)' },
                                { key: 'midVolV', label: 'Opp MID Vol±', group: 'Vol (Def)', higherBetter: true, isOnOff: true, section: 'vol_def', desc: 'Opponent Mid Volume On vs Team Average - Forcing mid-range shots (positive = more low-value shots)' },
                                { key: 'threeVolV', label: 'Opp 3PT Vol±', group: 'Vol (Def)', higherBetter: true, isOnOff: true, section: 'vol_def', desc: 'Opponent 3PT Volume On vs Team Average - Preventing 3PT attempts (inverted: positive = fewer opp 3PA)' },
                                // Playmaking/Defense
                                { key: 'astPct', label: 'AST%±', group: 'Playmaking', higherBetter: true, isOnOff: true, section: 'play', desc: 'Assist% On vs Team Average - Team passing/playmaking with player on court' },
                                { key: 'stlPct', label: 'STL%±', group: 'Defense', higherBetter: true, isOnOff: true, section: 'def', desc: 'Steal% On vs Team Average - Defensive disruption with player on court' },
                                { key: 'blkPct', label: 'BLK%±', group: 'Defense', higherBetter: true, isOnOff: true, section: 'def', desc: 'Block% On vs Team Average - Shot blocking with player on court' },
                                // Transition/MISC
                                { key: 'fastBreak100', label: 'FB/100±', group: 'Trans', higherBetter: true, isOnOff: true, section: 'trans', desc: 'Fast Break Points/100 On vs Team Average - Transition offense with player on court' },
                                { key: 'fastBreak100V', label: 'Opp FB/100±', group: 'Trans', higherBetter: true, isOnOff: true, section: 'trans', desc: 'Opponent Fast Break/100 On vs Team Average - Transition defense (inverted: positive = fewer opp FB points)' },
                                { key: 'secChance100', label: '2nd/100±', group: 'MISC', higherBetter: true, isOnOff: true, section: 'misc', desc: 'Second Chance Points/100 On vs Team Average - Points after offensive rebounds' },
                                { key: 'ptsOffTov100', label: 'TOV Pts±', group: 'MISC', higherBetter: true, isOnOff: true, section: 'misc', desc: 'Points Off Turnovers/100 On vs Team Average - Points scored after forcing turnovers' },
                                // Individual Stats - Games/Minutes (no color coding)
                                ...(leaderboardTableVsStarters ? [
                                    { key: 'vsStartersMins', label: 'VS★ Min', group: 'VS Starters', higherBetter: true, section: 'vsStarters', noColor: true, desc: 'Minutes played vs lineups with 4+ regular starters', isVsStarters: true },
                                    { key: 'vsStartersPlusMinus', label: 'VS★ +/-', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Net rating (ORtg - DRtg) per 100 possessions vs starters - same as VS. Starters tab in Lineup Analyzer', isVsStarters: true },
                                    { key: 'vsPts75', label: 'VS★ PTS/75', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Points per 75 lineup possessions vs starters', isVsStarters: true },
                                    { key: 'vsReb75', label: 'VS★ REB/75', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Rebounds per 75 lineup possessions vs starters', isVsStarters: true },
                                    { key: 'vsOreb75', label: 'VS★ OREB/75', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Offensive rebounds per 75 lineup possessions vs starters', isVsStarters: true },
                                    { key: 'vsDreb75', label: 'VS★ DREB/75', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Defensive rebounds per 75 lineup possessions vs starters', isVsStarters: true },
                                    { key: 'vsAst75', label: 'VS★ AST/75', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Assists per 75 lineup possessions vs starters', isVsStarters: true },
                                    { key: 'vsStl75', label: 'VS★ STL/75', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Steals per 75 lineup possessions vs starters', isVsStarters: true },
                                    { key: 'vsBlk75', label: 'VS★ BLK/75', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Blocks per 75 lineup possessions vs starters', isVsStarters: true },
                                    { key: 'vsTov75', label: 'VS★ TOV/75', group: 'VS Starters', higherBetter: false, section: 'vsStarters', desc: 'Turnovers per 75 lineup possessions vs starters (lower is better)', isVsStarters: true },
                                    { key: 'vsUsg', label: 'VS★ USG%', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Usage rate vs starters - % of lineup possessions used by player', isVsStarters: true },
                                    { key: 'vsTsPct', label: 'VS★ TS%', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'True Shooting% vs starters', isVsStarters: true },
                                    { key: 'vsEfgPct', label: 'VS★ eFG%', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Effective FG% vs starters', isVsStarters: true },
                                    { key: 'vsFgPct', label: 'VS★ FG%', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Field Goal% vs starters', isVsStarters: true },
                                    { key: 'vs3Pct', label: 'VS★ 3P%', group: 'VS Starters', higherBetter: true, section: 'vsStarters', desc: 'Three-Point% vs starters', isVsStarters: true }
                                ] : []),
                                { key: 'games', label: 'G', group: 'Basic', higherBetter: true, section: 'basic', noColor: true, desc: 'Games - Number of games played' },
                                { key: 'mpg', label: 'MPG', group: 'Basic', higherBetter: true, section: 'basic', noColor: true, desc: 'Minutes Per Game - Average minutes played per game' },
                                // V6.6: Position estimated from BPM methodology (rendered as fixed column, not in activeColumns)
                                // V6.7: Offensive Role estimated from BPM methodology (rendered as fixed column, not in activeColumns)
                                // Individual Stats - Per 75
                                { key: 'pts75', label: 'PTS/75', group: 'Per75', higherBetter: true, section: 'per75', desc: 'Points per 75 Possessions - Scoring output normalized to 75 possessions (Dean Oliver standard)' },
                                { key: 'reb75', label: 'REB/75', group: 'Per75', higherBetter: true, section: 'per75', desc: 'Rebounds per 75 Possessions - Total rebounding normalized to 75 possessions' },
                                { key: 'oreb75', label: 'OREB/75', group: 'Per75', higherBetter: true, section: 'per75', desc: 'Offensive Rebounds per 75 Possessions - Second chance creation' },
                                { key: 'dreb75', label: 'DREB/75', group: 'Per75', higherBetter: true, section: 'per75', desc: 'Defensive Rebounds per 75 Possessions - Defensive rebounding' },
                                { key: 'ast75', label: 'AST/75', group: 'Per75', higherBetter: true, section: 'per75', desc: 'Assists per 75 Possessions - Playmaking output' },
                                { key: 'stl75', label: 'STL/75', group: 'Per75', higherBetter: true, section: 'per75', desc: 'Steals per 75 Possessions - Ball-hawking ability' },
                                { key: 'blk75', label: 'BLK/75', group: 'Per75', higherBetter: true, section: 'per75', desc: 'Blocks per 75 Possessions - Shot blocking ability' },
                                { key: 'tov75', label: 'TOV/75', group: 'Per75', higherBetter: false, section: 'per75', desc: 'Turnovers per 75 Possessions - Ball security (lower is better)' },
                                // Shooting Percentages
                                { key: 'fgPct', label: 'FG%', group: 'Shooting', higherBetter: true, section: 'shooting', desc: 'Field Goal Percentage - Overall shooting accuracy' },
                                { key: 'ftPct', label: 'FT%', group: 'Shooting', higherBetter: true, section: 'shooting', desc: 'Free Throw Percentage - Accuracy from the free throw line' },
                                { key: 'rima100', label: 'RIMA/100', group: 'Shooting', higherBetter: true, section: 'shooting', desc: 'Rim Attempts per 100 team possessions' },
                                { key: 'rimfgPct', label: 'RIMFG%', group: 'Shooting', higherBetter: true, section: 'shooting', desc: 'Rim Field Goal Percentage - Accuracy at the rim' },
                                { key: 'rimPressureZ', label: 'Rim Pressure', group: 'Shooting', higherBetter: true, section: 'shooting', desc: 'Rim Pressure Z-Score - Combined Z-scores of RIMA/100 (volume) + RIMFG% (finishing). Higher = elite rim attacker with both volume and efficiency' },
                                { key: 'mida100', label: 'MIDA/100', group: 'Shooting', higherBetter: true, section: 'shooting', desc: 'Mid-Range Attempts per 100 team possessions' },
                                { key: 'midfgPct', label: 'MIDFG%', group: 'Shooting', higherBetter: true, section: 'shooting', desc: 'Mid-Range Field Goal Percentage - Accuracy from mid-range' },
                                // Efficiency
                                { key: 'tpa100', label: '3PA/100', group: 'Efficiency', higherBetter: true, section: 'efficiency', desc: 'Three-Point Attempts per 100 Possessions - Volume of 3PT shooting' },
                                { key: 'threePctIndiv', label: '3P%', group: 'Efficiency', higherBetter: true, section: 'efficiency', desc: 'Three-Point Percentage - Accuracy from beyond the arc' },
                                { key: 'spacingZ', label: 'Spacing', group: 'Efficiency', higherBetter: true, section: 'efficiency', desc: 'Spacing Z-Score - Combined Z-scores of 3PA/100 (volume) + 3P% (accuracy). Higher = elite floor spacer with both volume and efficiency' },
                                { key: 'efgPct', label: 'eFG%', group: 'Efficiency', higherBetter: true, section: 'efficiency', desc: 'Effective Field Goal% - Shooting efficiency accounting for 3-pointers: (FGM + 0.5×3PM) / FGA' },
                                { key: 'tsPct', label: 'TS%', group: 'Efficiency', higherBetter: true, section: 'efficiency', desc: 'True Shooting% - Overall scoring efficiency including free throws: PTS / (2 × (FGA + 0.44×FTA))' },
                                // Usage
                                { key: 'usgPct', label: 'USG%', group: 'Usage', higherBetter: true, section: 'usage', desc: 'Usage Rate - Percentage of team possessions used by player while on court' },
                                { key: 'ftr', label: 'FTr', group: 'Usage', higherBetter: true, section: 'usage', desc: 'Free Throw Rate - Free throw attempts per field goal attempt (FTA/FGA)' },
                                // Rebounding
                                { key: 'orebPct', label: 'OREB%', group: 'Rebounding', higherBetter: true, section: 'rebounding', desc: 'Offensive Rebound% - Percentage of available offensive rebounds grabbed while on court' },
                                { key: 'drebPct', label: 'DREB%', group: 'Rebounding', higherBetter: true, section: 'rebounding', desc: 'Defensive Rebound% - Percentage of available defensive rebounds grabbed while on court' },
                                { key: 'trbPct', label: 'TRB%', group: 'Rebounding', higherBetter: true, section: 'rebounding', desc: 'Total Rebound% - Percentage of all available rebounds grabbed while on court' },
                                // Rates
                                { key: 'astPctIndiv', label: 'AST%', group: 'Rates', higherBetter: true, section: 'rates', desc: 'Assist% - Percentage of teammate FGs assisted while on court' },
                                { key: 'tovPct', label: 'TOV%', group: 'Rates', higherBetter: false, section: 'rates', desc: 'Turnover% - Turnovers per 100 plays (lower is better)' },
                                { key: 'stlPctIndiv', label: 'STL%', group: 'Rates', higherBetter: true, section: 'rates', desc: 'Steal% - Percentage of opponent possessions ending in steal while on court' },
                                { key: 'blkPctIndiv', label: 'BLK%', group: 'Rates', higherBetter: true, section: 'rates', desc: 'Block% - Percentage of opponent 2PA blocked while on court' },
                                // BPM
                                { key: 'bpm', label: 'BPM', group: 'BPM', higherBetter: true, section: 'bpm', desc: 'Box Plus-Minus - Estimated net rating impact from box score stats' },
                                { key: 'obpm', label: 'OBPM', group: 'BPM', higherBetter: true, section: 'bpm', desc: 'Offensive Box Plus-Minus - Estimated offensive impact from box score stats' },
                                { key: 'dbpm', label: 'DBPM', group: 'BPM', higherBetter: true, section: 'bpm', desc: 'Defensive Box Plus-Minus - Estimated defensive impact from box score stats' },
                                // Turnover Breakdown
                                { key: 'passToG', label: 'PASS TO/G', group: 'TO Breakdown', higherBetter: false, section: 'tobd', desc: 'Pass Turnovers per Game - Turnovers from bad passes' },
                                { key: 'dribToG', label: 'DRIB TO/G', group: 'TO Breakdown', higherBetter: false, section: 'tobd', desc: 'Dribble Turnovers per Game - Turnovers from ball handling' },
                                // Transition Individual
                                { key: 'fbp40', label: 'FBP/40', group: 'Transition', higherBetter: true, section: 'transIndiv', desc: 'Fast Break Points per 40 Minutes - Transition scoring ability' }
                            ];

                            // Section color mapping for visual distinction - vibrant header gradients with matching borders
                            const sectionColors = {
                                rapm: { header: 'linear-gradient(135deg, rgba(139, 92, 246, 0.5) 0%, rgba(109, 40, 217, 0.5) 100%)', border: '#8b5cf6' },
                                apm: { header: 'linear-gradient(135deg, rgba(59, 130, 246, 0.5) 0%, rgba(37, 99, 235, 0.5) 100%)', border: '#3b82f6' },
                                ratings: { header: 'linear-gradient(135deg, rgba(245, 158, 11, 0.5) 0%, rgba(217, 119, 6, 0.5) 100%)', border: '#f59e0b' },
                                ff_off: { header: 'linear-gradient(135deg, rgba(34, 197, 94, 0.45) 0%, rgba(22, 163, 74, 0.45) 100%)', border: '#22c55e' },
                                ff_def: { header: 'linear-gradient(135deg, rgba(239, 68, 68, 0.45) 0%, rgba(220, 38, 38, 0.45) 100%)', border: '#ef4444' },
                                shot_off: { header: 'linear-gradient(135deg, rgba(59, 130, 246, 0.4) 0%, rgba(37, 99, 235, 0.4) 100%)', border: '#3b82f6' },
                                shot_def: { header: 'linear-gradient(135deg, rgba(244, 63, 94, 0.4) 0%, rgba(225, 29, 72, 0.4) 100%)', border: '#f43f5e' },
                                vol_off: { header: 'linear-gradient(135deg, rgba(34, 211, 238, 0.4) 0%, rgba(6, 182, 212, 0.4) 100%)', border: '#22d3ee' },
                                vol_def: { header: 'linear-gradient(135deg, rgba(251, 146, 60, 0.4) 0%, rgba(234, 88, 12, 0.4) 100%)', border: '#fb923c' },
                                play: { header: 'linear-gradient(135deg, rgba(168, 85, 247, 0.45) 0%, rgba(139, 92, 246, 0.45) 100%)', border: '#a855f7' },
                                def: { header: 'linear-gradient(135deg, rgba(239, 68, 68, 0.4) 0%, rgba(185, 28, 28, 0.4) 100%)', border: '#ef4444' },
                                trans: { header: 'linear-gradient(135deg, rgba(132, 204, 22, 0.45) 0%, rgba(101, 163, 13, 0.45) 100%)', border: '#84cc16' },
                                misc: { header: 'linear-gradient(135deg, rgba(100, 116, 139, 0.4) 0%, rgba(71, 85, 105, 0.4) 100%)', border: '#64748b' },
                                basic: { header: 'linear-gradient(135deg, rgba(100, 116, 139, 0.35) 0%, rgba(71, 85, 105, 0.35) 100%)', border: '#64748b' },
                                per75: { header: 'linear-gradient(135deg, rgba(34, 211, 238, 0.45) 0%, rgba(6, 182, 212, 0.45) 100%)', border: '#22d3ee' },
                                shooting: { header: 'linear-gradient(135deg, rgba(16, 185, 129, 0.45) 0%, rgba(5, 150, 105, 0.45) 100%)', border: '#10b981' },
                                efficiency: { header: 'linear-gradient(135deg, rgba(129, 140, 248, 0.45) 0%, rgba(99, 102, 241, 0.45) 100%)', border: '#818cf8' },
                                usage: { header: 'linear-gradient(135deg, rgba(251, 146, 60, 0.45) 0%, rgba(234, 88, 12, 0.45) 100%)', border: '#fb923c' },
                                rebounding: { header: 'linear-gradient(135deg, rgba(163, 230, 53, 0.45) 0%, rgba(132, 204, 22, 0.45) 100%)', border: '#a3e635' },
                                rates: { header: 'linear-gradient(135deg, rgba(232, 121, 249, 0.45) 0%, rgba(192, 38, 211, 0.45) 100%)', border: '#e879f9' },
                                bpm: { header: 'linear-gradient(135deg, rgba(56, 189, 248, 0.5) 0%, rgba(14, 165, 233, 0.5) 100%)', border: '#38bdf8' },
                                tobd: { header: 'linear-gradient(135deg, rgba(239, 68, 68, 0.45) 0%, rgba(185, 28, 28, 0.45) 100%)', border: '#ef4444' },
                                transIndiv: { header: 'linear-gradient(135deg, rgba(34, 197, 94, 0.45) 0%, rgba(22, 163, 74, 0.45) 100%)', border: '#22c55e' },
                                vsStarters: { header: 'linear-gradient(135deg, rgba(6, 182, 212, 0.5) 0%, rgba(8, 145, 178, 0.5) 100%)', border: '#06b6d4' }
                            };

                            // Get percentile for a value within a dataset (OPTIMIZED: expects pre-sorted array)
                            const getPercentile = (value, sortedValues, higherBetter) => {
                                if (!sortedValues || !sortedValues.length) return 50;
                                // Binary search for rank (O(log n) instead of O(n))
                                let low = 0, high = sortedValues.length;
                                while (low < high) {
                                    const mid = (low + high) >>> 1;
                                    if (sortedValues[mid] < value) low = mid + 1;
                                    else high = mid;
                                }
                                const pct = (low / sortedValues.length) * 100;
                                return higherBetter ? pct : 100 - pct;
                            };
                            
                            // Get color based on percentile
                            const getPercentileColor = (pct) => {
                                if (pct >= 90) return { bg: 'rgba(34, 197, 94, 0.4)', text: '#4ade80' };
                                if (pct >= 75) return { bg: 'rgba(34, 197, 94, 0.25)', text: '#86efac' };
                                if (pct >= 60) return { bg: 'rgba(234, 179, 8, 0.25)', text: '#fde047' };
                                if (pct >= 40) return { bg: 'rgba(100, 116, 139, 0.2)', text: '#94a3b8' };
                                if (pct >= 25) return { bg: 'rgba(249, 115, 22, 0.25)', text: '#fb923c' };
                                if (pct >= 10) return { bg: 'rgba(239, 68, 68, 0.25)', text: '#f87171' };
                                return { bg: 'rgba(239, 68, 68, 0.4)', text: '#ef4444' };
                            };
                            
                            // Build player data with all stats
                            const fullTableDataRaw = onOffData
                                .filter(d => leaderboardTableTeamFilter === '' || d.team === leaderboardTableTeamFilter)
                                .filter(d => (d.onMinutes || 0) >= leaderboardTableMinMins)
                                .map(d => {
                                    const onStats = d.onStats || {};
                                    const offStats = d.offStats || {};
                                    const teamAvg = teamAverages[d.team] || {};
                                    
                                    // Apply luck adjustment to ON stats
                                    let adjOnOff = onStats.off || 0;
                                    let adjOnDef = onStats.def || 0;
                                    let adjOnEfg = onStats.offEfg || 0;
                                    let adjDefEfg = onStats.defEfg || 0;
                                    
                                    // Offensive luck adjustment
                                    if (leaderboardTableOffLuck > 0 && onStats.tpa > 0) {
                                        const expected3pm = onStats.tpa * 0.36;
                                        const actual3pm = onStats.tpm || 0;
                                        const delta = actual3pm - expected3pm;
                                        const adj3pm = delta * (leaderboardTableOffLuck / 100);
                                        const adjPts = ((onStats.fgm || 0) * 2 + (onStats.tpm || 0) + (onStats.ftm || 0)) - adj3pm * 3;
                                        const poss = onStats.offPoss || onStats.poss || 1;
                                        adjOnOff = poss > 0 ? (adjPts / poss) * 100 : adjOnOff;
                                        adjOnEfg = onStats.fga > 0 ? (((onStats.fgm || 0) - adj3pm + 0.5 * ((onStats.tpm || 0) - adj3pm)) / onStats.fga) * 100 : adjOnEfg;
                                    }
                                    
                                    // Defensive luck adjustment
                                    if (leaderboardTableDefLuck > 0 && onStats.tpaV > 0) {
                                        const expected3pmV = onStats.tpaV * 0.36;
                                        const actual3pmV = onStats.tpmV || 0;
                                        const deltaV = actual3pmV - expected3pmV;
                                        const adj3pmV = deltaV * (leaderboardTableDefLuck / 100);
                                        const adjPtsV = ((onStats.fgmV || 0) * 2 + (onStats.tpmV || 0) + (onStats.ftmV || 0)) - adj3pmV * 3;
                                        const possV = onStats.defPoss || onStats.possV || 1;
                                        adjOnDef = possV > 0 ? (adjPtsV / possV) * 100 : adjOnDef;
                                        adjDefEfg = onStats.fgaV > 0 ? (((onStats.fgmV || 0) - adj3pmV + 0.5 * ((onStats.tpmV || 0) - adj3pmV)) / onStats.fgaV) * 100 : adjDefEfg;
                                    }
                                    
                                    const onNet = adjOnOff - adjOnDef;

                                    // Apply luck adjustment to OFF stats (for ON-OFF mode)
                                    let adjOffOff = offStats.off || 0;
                                    let adjOffDef = offStats.def || 0;
                                    let adjOffEfg = offStats.offEfg || 0;
                                    let adjOffDefEfg = offStats.defEfg || 0;

                                    if (leaderboardTableOffLuck > 0 && offStats.tpa > 0) {
                                        const expected3pm = offStats.tpa * 0.36;
                                        const actual3pm = offStats.tpm || 0;
                                        const delta = actual3pm - expected3pm;
                                        const adj3pm = delta * (leaderboardTableOffLuck / 100);
                                        const adjPts = ((offStats.fgm || 0) * 2 + (offStats.tpm || 0) + (offStats.ftm || 0)) - adj3pm * 3;
                                        const poss = offStats.offPoss || offStats.poss || 1;
                                        adjOffOff = poss > 0 ? (adjPts / poss) * 100 : adjOffOff;
                                        adjOffEfg = offStats.fga > 0 ? (((offStats.fgm || 0) - adj3pm + 0.5 * ((offStats.tpm || 0) - adj3pm)) / offStats.fga) * 100 : adjOffEfg;
                                    }

                                    if (leaderboardTableDefLuck > 0 && offStats.tpaV > 0) {
                                        const expected3pmV = offStats.tpaV * 0.36;
                                        const actual3pmV = offStats.tpmV || 0;
                                        const deltaV = actual3pmV - expected3pmV;
                                        const adj3pmV = deltaV * (leaderboardTableDefLuck / 100);
                                        const adjPtsV = ((offStats.fgmV || 0) * 2 + (offStats.tpmV || 0) + (offStats.ftmV || 0)) - adj3pmV * 3;
                                        const possV = offStats.defPoss || offStats.possV || 1;
                                        adjOffDef = possV > 0 ? (adjPtsV / possV) * 100 : adjOffDef;
                                        adjOffDefEfg = offStats.fgaV > 0 ? (((offStats.fgmV || 0) - adj3pmV + 0.5 * ((offStats.tpmV || 0) - adj3pmV)) / offStats.fgaV) * 100 : adjOffDefEfg;
                                    }

                                    // Choose comparison: ON vs Team Avg or strict ON - OFF
                                    const useOnOff = ftOnOffMethod === 'onOff';
                                    const cmp = useOnOff ? offStats : teamAvg;

                                    // Both modes: positive = better performance
                                    // d_off: offensive stats where higher ON = better → ON - comparison
                                    // d_def: defensive stats where lower ON = better → comparison - ON (flipped in BOTH modes)
                                    const d_off = (onV, cmpK) => (onV || 0) - (cmp[cmpK] || 0);
                                    const d_def = (onV, cmpK) => (cmp[cmpK] || 0) - (onV || 0);

                                    const result = {
                                        player: d.player,
                                        team: d.team,
                                        onMins: d.onMinutes || 0,
                                        offMins: d.offMinutes || 0,
                                        // Ratings
                                        net: useOnOff ? (onNet - (adjOffOff - adjOffDef)) : (onNet - (teamAvg.net || 0)),
                                        off: useOnOff ? (adjOnOff - adjOffOff) : (adjOnOff - (teamAvg.off || 0)),
                                        def: useOnOff ? (adjOffDef - adjOnDef) : ((teamAvg.def || 0) - adjOnDef),
                                        // Four Factors - Offense
                                        offEfg: useOnOff ? (adjOnEfg - adjOffEfg) : (adjOnEfg - (teamAvg.offEfg || 0)),
                                        offTov: useOnOff ? ((offStats.offTov || 0) - (onStats.offTov || 0)) : ((teamAvg.offTov || 0) - (onStats.offTov || 0)),
                                        offOreb: d_off(onStats.offOreb, 'offOreb'),
                                        offFtR: d_off(onStats.offFtR, 'offFtR'),
                                        // Four Factors - Defense
                                        defEfg: useOnOff ? (adjOffDefEfg - adjDefEfg) : ((teamAvg.defEfg || 0) - adjDefEfg),
                                        defTov: d_off(onStats.defTov, 'defTov'),
                                        defOreb: useOnOff ? ((offStats.defOreb || 0) - (onStats.defOreb || 0)) : ((teamAvg.defOreb || 0) - (onStats.defOreb || 0)),
                                        defFtR: useOnOff ? ((offStats.defFtR || 0) - (onStats.defFtR || 0)) : ((teamAvg.defFtR || 0) - (onStats.defFtR || 0)),
                                        // Shot Making - Offense
                                        rimPct: d_off(onStats.rimPct, 'rimPct'),
                                        midPct: d_off(onStats.midPct, 'midPct'),
                                        threePct: d_off(onStats.threePct, 'threePct'),
                                        // Shot Making - Defense
                                        rimPctV: d_def(onStats.rimPctV, 'rimPctV'),
                                        midPctV: d_def(onStats.midPctV, 'midPctV'),
                                        threePctV: d_def(onStats.threePctV, 'threePctV'),
                                        // Shot Volume
                                        rimVol: d_off(onStats.rimVol, 'rimVol'),
                                        midVol: d_off(onStats.midVol, 'midVol'),
                                        threeVol: d_off(onStats.threeVol, 'threeVol'),
                                        rimVolV: d_def(onStats.rimVolV, 'rimVolV'),
                                        midVolV: d_def(onStats.midVolV, 'midVolV'),
                                        threeVolV: d_def(onStats.threeVolV, 'threeVolV'),
                                        // Playmaking/Defense
                                        astPct: d_off(onStats.astPct, 'astPct'),
                                        stlPct: d_off(onStats.stlPct, 'stlPct'),
                                        blkPct: d_off(onStats.blkPct, 'blkPct'),
                                        // Pace
                                        paceF: d_off(onStats.paceF, 'paceF'),
                                        paceV: d_def(onStats.paceV, 'paceV'),
                                        // Transition/MISC
                                        fastBreak100: d_off(onStats.fastBreak100, 'fastBreak100'),
                                        fastBreak100V: d_def(onStats.fastBreak100V, 'fastBreak100V'),
                                        secChance100: d_off(onStats.secChance100, 'secChance100'),
                                        ptsOffTov100: d_off(onStats.ptsOffTov100, 'ptsOffTov100')
                                    };
                                    
                                    // PRIORITY: Always use seasonStatsMap (player_stats_enhanced.csv)
                                    // Advanced stats calculated using teamSeasonTotals + Basketball Reference formulas
                                    const seasonStats = findPlayerWithTeam(d.player, d.team, seasonStatsMap);
                                    
                                    if (seasonStats) {
                                        // Use seasonStatsMap (player_stats_enhanced.csv) - PRIMARY SOURCE
                                        result.totalMinutes = seasonStats.min || 0;

                                        // V8.1: Games from stintsData takes priority (counts games where player actually played minutes)
                                        const pNorm = normalizePlayerName(d.player);
                                        const stintsPlayerData = playerGamesFromStints.get(pNorm);
                                        if (stintsPlayerData && stintsPlayerData.games.size > 0) {
                                            result.games = stintsPlayerData.games.size;
                                        } else {
                                            result.games = seasonStats.games || 0;
                                        }

                                        result.mpg = seasonStats.mpg || 0;
                                        
                                        // Calculate per 75 poss stats from season totals
                                        const totalPoss = seasonStats.games > 0 ? (seasonStats.min / seasonStats.games) * 2.4 * seasonStats.games : seasonStats.min * 2.4;
                                        const p75Factor = totalPoss > 0 && seasonStats.games > 0 ? 75 / (totalPoss / seasonStats.games) : 0;
                                        
                                        result.pts75 = seasonStats.ppg ? seasonStats.ppg * p75Factor : 0;
                                        result.reb75 = seasonStats.games > 0 ? (seasonStats.reb / seasonStats.games) * p75Factor : 0;
                                        result.oreb75 = seasonStats.games > 0 ? (seasonStats.oreb / seasonStats.games) * p75Factor : 0;
                                        result.dreb75 = seasonStats.games > 0 ? (seasonStats.dreb / seasonStats.games) * p75Factor : 0;
                                        result.ast75 = seasonStats.games > 0 ? (seasonStats.ast / seasonStats.games) * p75Factor : 0;
                                        result.stl75 = seasonStats.games > 0 ? (seasonStats.stl / seasonStats.games) * p75Factor : 0;
                                        result.blk75 = seasonStats.games > 0 ? (seasonStats.blk / seasonStats.games) * p75Factor : 0;
                                        result.tov75 = seasonStats.games > 0 ? (seasonStats.tov / seasonStats.games) * p75Factor : 0;
                                        
                                        // Per 100 possessions
                                        result.pts100 = totalPoss > 0 ? (seasonStats.pts / totalPoss) * 100 : 0;
                                        result.tpa100 = totalPoss > 0 ? (seasonStats.tpa / totalPoss) * 100 : 0;
                                        
                                        // Shooting percentages
                                        result.fgPct = seasonStats.fgPct || (seasonStats.fga > 0 ? (seasonStats.fgm / seasonStats.fga) * 100 : 0);
                                        result.threePctIndiv = seasonStats.tpPct || (seasonStats.tpa > 0 ? (seasonStats.tpm / seasonStats.tpa) * 100 : 0);
                                        result.ftPct = seasonStats.ftPct || (seasonStats.fta > 0 ? (seasonStats.ftm / seasonStats.fta) * 100 : 0);
                                        const efg = seasonStats.fga > 0 ? ((seasonStats.fgm + 0.5 * seasonStats.tpm) / seasonStats.fga) * 100 : 0;
                                        result.efgPct = efg;
                                        const pts = seasonStats.pts || (seasonStats.fgm * 2 + seasonStats.tpm + seasonStats.ftm);
                                        const tsa = seasonStats.fga + 0.44 * seasonStats.fta;
                                        result.tsPct = tsa > 0 ? (pts / (2 * tsa)) * 100 : 0;
                                        
                                        // Usage - direct from CSV
                                        result.usgPct = seasonStats.usg || 0;
                                        result.ftr = seasonStats.fga > 0 ? (seasonStats.fta / seasonStats.fga) * 100 : 0;
                                        
                                        // Shot zone percentages from season
                                        result.rimPctIndiv = seasonStats.seasonRimPct || seasonStats.rimPct || 0;
                                        result.midPctIndiv = seasonStats.seasonMidPct || seasonStats.midPct || 0;
                                        result.threePctIndiv = seasonStats.seasonThreePct || result.threePctIndiv;
                                        
                                        // BPM from season stats (if available)
                                        result.bpm = seasonStats.bpm || 0;
                                        result.obpm = seasonStats.obpm || 0;
                                        result.dbpm = seasonStats.dbpm || 0;

                                        // NEW: Rim and Mid-range stats per 100 possessions
                                        result.rima100 = totalPoss > 0 ? (seasonStats.rimAtt / totalPoss) * 100 : 0;
                                        result.rimfgPct = seasonStats.rimAtt > 0 ? (seasonStats.rimMade / seasonStats.rimAtt) * 100 : 0;
                                        // Mid-range attempts = FGA - 3PA - Rim attempts
                                        const midAttempts = (seasonStats.fga - seasonStats.tpa - seasonStats.rimAtt);
                                        const midMade = (seasonStats.fgm - seasonStats.tpm - seasonStats.rimMade);
                                        result.mida100 = totalPoss > 0 && midAttempts > 0 ? (midAttempts / totalPoss) * 100 : 0;
                                        result.midfgPct = midAttempts > 0 && midMade >= 0 ? (midMade / midAttempts) * 100 : 0;

                                        // NEW: Turnover breakdown per game
                                        result.passToG = seasonStats.games > 0 ? seasonStats.passTo / seasonStats.games : 0;
                                        result.dribToG = seasonStats.games > 0 ? seasonStats.dribTo / seasonStats.games : 0;

                                        // NEW: Fast break points per 40 minutes
                                        const per40Factor = seasonStats.min > 0 ? 40 / seasonStats.min : 0;
                                        result.fbp40 = (seasonStats.fastBreakPts || 0) * per40Factor;

                                        // Calculate advanced percentage stats using Basketball Reference formulas
                                        // Get team totals for this player's team
                                        const teamTotals = teamSeasonTotals.get(d.team);
                                        if (teamTotals && seasonStats.min > 0) {
                                            const playerMin = seasonStats.min;
                                            const teamMin = teamTotals.totalMinutes || (teamTotals.games * 40 * 5); // 5 players * 40 min per game
                                            const tmMinPer5 = teamMin / 5;
                                            
                                            // Player totals from seasonStats
                                            const pOreb = seasonStats.oreb || 0;
                                            const pDreb = seasonStats.dreb || 0;
                                            const pReb = seasonStats.reb || (pOreb + pDreb);
                                            const pAst = seasonStats.ast || 0;
                                            const pStl = seasonStats.stl || 0;
                                            const pBlk = seasonStats.blk || 0;
                                            const pTov = seasonStats.tov || 0;
                                            const pFga = seasonStats.fga || 0;
                                            const pFgm = seasonStats.fgm || 0;
                                            const pFta = seasonStats.fta || 0;
                                            
                                            // Team totals
                                            const tmOreb = teamTotals.oreb || 0;
                                            const tmDreb = teamTotals.dreb || 0;
                                            const tmReb = teamTotals.reb || (tmOreb + tmDreb);
                                            const tmFgm = teamTotals.fgm || 0;
                                            
                                            // Opponent totals
                                            const oppOreb = teamTotals.oppOreb || 0;
                                            const oppDreb = teamTotals.oppDreb || 0;
                                            const oppReb = teamTotals.oppReb || (oppOreb + oppDreb);
                                            const oppFga = teamTotals.oppFga || 0;
                                            const oppTpa = teamTotals.oppTpa || 0;
                                            const oppPoss = teamTotals.oppPoss || teamTotals.totalPoss || 0;

                                            // OREB% = 100 * (Player OREB * (Team MIN / 5)) / (Player MIN * (Team OREB + Opp DREB))
                                            const orebDenom = playerMin * (tmOreb + oppDreb);
                                            result.orebPct = orebDenom > 0 ? 100 * (pOreb * tmMinPer5) / orebDenom : 0;

                                            // DREB% = 100 * (Player DREB * (Team MIN / 5)) / (Player MIN * (Team DREB + Opp OREB))
                                            const drebDenom = playerMin * (tmDreb + oppOreb);
                                            result.drebPct = drebDenom > 0 ? 100 * (pDreb * tmMinPer5) / drebDenom : 0;
                                            
                                            // TRB% = 100 * (Player REB * (Team MIN / 5)) / (Player MIN * (Team REB + Opp REB))
                                            const trbDenom = playerMin * (tmReb + oppReb);
                                            result.trbPct = trbDenom > 0 ? 100 * (pReb * tmMinPer5) / trbDenom : 0;
                                            
                                            // AST% = 100 * Player AST / (((Player MIN / (Team MIN / 5)) * Team FGM) - Player FGM)
                                            const astDenom = ((playerMin / tmMinPer5) * tmFgm) - pFgm;
                                            result.astPctIndiv = astDenom > 0 ? 100 * pAst / astDenom : 0;
                                            
                                            // TOV% = 100 * Player TOV / (Player FGA + 0.44 * Player FTA + Player TOV)
                                            const tovDenom = pFga + 0.44 * pFta + pTov;
                                            result.tovPct = tovDenom > 0 ? 100 * pTov / tovDenom : 0;
                                            
                                            // STL% = 100 * (Player STL * (Team MIN / 5)) / (Player MIN * Opp Poss)
                                            const stlDenom = playerMin * oppPoss;
                                            result.stlPctIndiv = stlDenom > 0 ? 100 * (pStl * tmMinPer5) / stlDenom : 0;
                                            
                                            // BLK% = 100 * (Player BLK * (Team MIN / 5)) / (Player MIN * (Opp FGA - Opp 3PA))
                                            const blkDenom = playerMin * (oppFga - oppTpa);
                                            result.blkPctIndiv = blkDenom > 0 ? 100 * (pBlk * tmMinPer5) / blkDenom : 0;

                                            // V6.6: Calculate player position using BPM methodology
                                            // Build player per-100 stats for position estimation
                                            const playerPer100 = {
                                                trb: pOreb + pDreb,
                                                oreb: pOreb,
                                                dreb: pDreb,
                                                ast: pAst,
                                                stl: pStl,
                                                blk: pBlk,
                                                pf: seasonStats.pf || 0,
                                                pts: seasonStats.points || 0,
                                                fga: pFga,
                                                fta: pFta
                                            };

                                            // Build team per-100 stats (use team totals with threshold pts)
                                            const teamThresholdPtsVal = teamThresholdPts.get(d.team) || 30;
                                            const teamPer100 = {
                                                trb: tmOreb + tmDreb,
                                                stl: teamTotals.stl || 0,
                                                pf: teamTotals.pf || 0,
                                                ast: teamTotals.ast || 0,
                                                blk: teamTotals.blk || 0,
                                                totalThresholdPts: teamThresholdPtsVal
                                            };

                                            // Calculate position
                                            const positionData = BPMPositionCalculator.estimatePosition(playerPer100, teamPer100, playerMin);
                                            result.position = Math.round(positionData * 10) / 10;
                                            result.positionLabel = BPMPositionCalculator.getPositionLabel(positionData);
                                            result.positionRange = BPMPositionCalculator.getPositionRange(positionData);

                                            // V6.7: Calculate offensive role
                                            const teamAvgPtsPerTsa = teamTotals.avgPtsPerTsa || 1.0;
                                            const roleData = BPMPositionCalculator.estimateOffensiveRole(playerPer100, teamAvgPtsPerTsa, teamPer100, playerMin);
                                            result.offensiveRole = Math.round(roleData * 10) / 10;
                                            result.roleLabel = roleData <= 2.0 ? 'Creator' : roleData <= 3.0 ? 'Combo' : roleData <= 4.0 ? 'Balanced' : 'Finisher';
                                        }
                                    }
                                    // else: No seasonStats available - player won't have individual stats
                                    
                                    // Add RAPM if available - use PlayerRAPMEngine
                                    if (hasRapm) {
                                        const rapmResult = PlayerRAPMEngine.getPlayerRapmValue(playerRapmStats, d.player, 'net');
                                        if (rapmResult && rapmResult.rapm !== undefined) {
                                            result.rapmNet = rapmResult.rapm;
                                        }
                                        const rapmOff = PlayerRAPMEngine.getPlayerRapmValue(playerRapmStats, d.player, 'off');
                                        if (rapmOff && rapmOff.rapm !== undefined) {
                                            result.rapmOff = rapmOff.rapm;
                                        }
                                        const rapmDef = PlayerRAPMEngine.getPlayerRapmValue(playerRapmStats, d.player, 'def');
                                        if (rapmDef && rapmDef.rapm !== undefined) {
                                            // V8.1: Negate DRAPM display so positive = good defense (prevents opponent scoring)
                                            result.rapmDef = -rapmDef.rapm;
                                        }
                                    }
                                    
                                    // Add APM if available
                                    if (hasApm) {
                                        const apmResult = PlayerRAPMEngine.getPlayerApmValue(playerApmStats, d.player);
                                        if (apmResult) {
                                            result.apmNet = apmResult.apm || 0;
                                            result.apmOff = apmResult.oapm || 0;
                                            result.apmDef = apmResult.dapm || 0; // Already positive for good defenders
                                        }
                                    }

                                    // Add VS. Starters stats if mode is active
                                    if (leaderboardTableVsStarters && hasVsStartersData) {
                                        const vsKey = d.player + '|||' + d.team;
                                        const vsData = vsStartersPlayerStats[vsKey];
                                        if (vsData && vsData.minutes > 0) {
                                            result.vsStartersMins = vsData.minutes || 0;

                                            // VS★ +/- (on-off net rating vs starters from lineup data)
                                            result.vsStartersPlusMinus = vsData.vsNetRtg || 0;

                                            // Per-75 stats using lineup possessions
                                            const lineupPoss = vsData.lineupPoss || 1;
                                            const p75Factor = lineupPoss > 0 ? 75 / lineupPoss : 0;

                                            result.vsPts75 = vsData.pts * p75Factor;
                                            result.vsReb75 = vsData.reb * p75Factor;
                                            result.vsOreb75 = vsData.oreb * p75Factor;
                                            result.vsDreb75 = vsData.dreb * p75Factor;
                                            result.vsAst75 = vsData.ast * p75Factor;
                                            result.vsStl75 = vsData.stl * p75Factor;
                                            result.vsBlk75 = vsData.blk * p75Factor;
                                            result.vsTov75 = vsData.tov * p75Factor;

                                            // Usage% = player possessions / lineup possessions * 100
                                            // Using individual possession formula (FGA + 0.44*FTA + TOV - OREB)
                                            result.vsUsg = lineupPoss > 0 ? (vsData.pPoss / lineupPoss) * 100 : 0;

                                            // Shooting percentages
                                            result.vsFgPct = vsData.fga > 0 ? (vsData.fgm / vsData.fga) * 100 : 0;
                                            result.vs3Pct = vsData.tpa > 0 ? (vsData.tpm / vsData.tpa) * 100 : 0;

                                            // Efficiency metrics
                                            result.vsEfgPct = vsData.fga > 0 ? ((vsData.fgm + 0.5 * vsData.tpm) / vsData.fga) * 100 : 0;
                                            const tsa = vsData.fga + 0.44 * vsData.fta;
                                            result.vsTsPct = tsa > 0 ? (vsData.pts / (2 * tsa)) * 100 : 0;
                                        } else {
                                            result.vsStartersMins = 0;
                                            result.vsStartersPlusMinus = 0;
                                        }
                                    }

                                    return result;
                                });

                            // Z-Score Composite Metrics: Spacing (3PA/100 + 3P%) and Rim Pressure (RIMA/100 + RIMFG%)
                            // Calculate distributions from all raw data first
                            const _zCalcDist = (arr) => {
                                const valid = arr.filter(v => v !== null && v !== undefined && !isNaN(v) && v !== 0);
                                if (valid.length < 2) return { mean: 0, stdDev: 1 };
                                const mean = valid.reduce((a, b) => a + b, 0) / valid.length;
                                const variance = valid.reduce((a, b) => a + (b - mean) ** 2, 0) / valid.length;
                                return { mean, stdDev: Math.sqrt(variance) || 1 };
                            };
                            // Only include players who meet minimum thresholds in distribution calculations
                            const _spacingEligible = fullTableDataRaw.filter(d => !(d.tpa100 < 1 || d.threePctIndiv < 10));
                            const _spacingDists = {
                                tpa100: _zCalcDist(_spacingEligible.map(d => d.tpa100)),
                                threePct: _zCalcDist(_spacingEligible.map(d => d.threePctIndiv))
                            };
                            const _rimPressureEligible = fullTableDataRaw.filter(d => !(d.rima100 < 1 || d.rimfgPct < 10));
                            const _rimPressureDists = {
                                rima100: _zCalcDist(_rimPressureEligible.map(d => d.rima100)),
                                rimfgPct: _zCalcDist(_rimPressureEligible.map(d => d.rimfgPct))
                            };
                            fullTableDataRaw.forEach(d => {
                                // Spacing = Z(3PA/100) + Z(3P%) — higher means better combination of volume + accuracy from 3
                                // Discount players with <1 3PA/100 OR <10% 3P% → default -10
                                if (d.tpa100 < 1 || d.threePctIndiv < 10) {
                                    d.spacingZ = -10;
                                } else {
                                    const zTpa = (d.tpa100 - _spacingDists.tpa100.mean) / _spacingDists.tpa100.stdDev;
                                    const zTpPct = (d.threePctIndiv - _spacingDists.threePct.mean) / _spacingDists.threePct.stdDev;
                                    d.spacingZ = (d.tpa100 > 0 && d.threePctIndiv > 0) ? zTpa + zTpPct : 0;
                                }
                                // Rim Pressure = Z(RIMA/100) + Z(RIMFG%) — higher means better at getting to rim AND finishing
                                // Discount players with <1 RIMA/100 OR <10% RIMFG% → default -10
                                if (d.rima100 < 1 || d.rimfgPct < 10) {
                                    d.rimPressureZ = -10;
                                } else {
                                    const zRima = (d.rima100 - _rimPressureDists.rima100.mean) / _rimPressureDists.rima100.stdDev;
                                    const zRimPct = (d.rimfgPct - _rimPressureDists.rimfgPct.mean) / _rimPressureDists.rimfgPct.stdDev;
                                    d.rimPressureZ = (d.rima100 > 0 && d.rimfgPct > 0) ? zRima + zRimPct : 0;
                                }
                            });

                            // Apply stat filters
                            const fullTableData = fullTableDataRaw.filter(d => {
                                for (const [statKey, filter] of Object.entries(leaderboardTableStatFilters)) {
                                    const value = d[statKey];
                                    if (value === undefined || value === null) continue;
                                    if (filter.min !== null && filter.min !== '' && value < parseFloat(filter.min)) return false;
                                    if (filter.max !== null && filter.max !== '' && value > parseFloat(filter.max)) return false;
                                }
                                return true;
                            });
                            
                            // Calculate percentile distributions for each stat (PRE-SORTED for performance)
                            const percentileData = {};
                            allStatColumns.forEach(col => {
                                const values = fullTableData.map(d => d[col.key]).filter(v => v !== null && v !== undefined && !isNaN(v));
                                // Pre-sort once instead of sorting every time getPercentile is called
                                percentileData[col.key] = values.sort((a, b) => a - b);
                            });

                            // V6.9: Store full table data and percentile pools for modal consistency
                            fullTableDataRef.current = { data: fullTableData, percentileData: percentileData };

                            // Sort data
                            const sortedFullTableData = [...fullTableData].sort((a, b) => {
                                if (leaderboardTableSortBy === 'player') {
                                    return leaderboardTableSortAsc ? a.player.localeCompare(b.player) : b.player.localeCompare(a.player);
                                }
                                const aVal = a[leaderboardTableSortBy] || 0;
                                const bVal = b[leaderboardTableSortBy] || 0;
                                const col = allStatColumns.find(c => c.key === leaderboardTableSortBy);
                                const higherBetter = col ? col.higherBetter : true;
                                return leaderboardTableSortAsc
                                    ? (higherBetter ? aVal - bVal : bVal - aVal)
                                    : (higherBetter ? bVal - aVal : aVal - bVal);
                            });

                            // Active columns
                            const activeColumns = allStatColumns.filter(col => leaderboardTableColumns.includes(col.key));
                            
                            // Section boundaries for visual separators
                            const getSectionBoundaries = () => {
                                const boundaries = [];
                                let lastSection = null;
                                activeColumns.forEach((col, idx) => {
                                    if (lastSection && col.section !== lastSection) boundaries.push(idx);
                                    lastSection = col.section;
                                });
                                return boundaries;
                            };
                            const sectionBoundaries = getSectionBoundaries();

                            // Toggle preset helper
                            const togglePreset = (presetKeys) => {
                                const allActive = presetKeys.every(k => leaderboardTableColumns.includes(k));
                                if (allActive) {
                                    setLeaderboardTableColumns(leaderboardTableColumns.filter(k => !presetKeys.includes(k)));
                                } else {
                                    setLeaderboardTableColumns([...new Set([...leaderboardTableColumns, ...presetKeys])]);
                                }
                            };
                            
                            // Container style based on fullscreen mode
                            const containerStyle = leaderboardTableFullscreen 
                                ? { position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 1000, background: '#0f172a', padding: '16px', overflow: 'auto' }
                                : {};
                            
                            // Track loading state for heavy computations
                            const isComputingData = fullTableLoading;
                            const loadingMessage = leaderboardTableVsStarters ? 'Computing VS★ stats...' : 'Calculating...';

                            return e('div', {
                                className: 'leaderboard-v2-container' + (leaderboardTableFullscreen ? ' leaderboard-v2-fullscreen' : ''),
                                style: containerStyle
                            },
                                // Loading indicator
                                isComputingData && e('div', { className: 'leaderboard-v2-loading' },
                                    e('div', { className: 'leaderboard-v2-loading-spinner' }),
                                    e('span', { className: 'leaderboard-v2-loading-text' }, loadingMessage)
                                ),

                                // Header Bar - Google Style
                                e('div', { className: 'leaderboard-v2-header' },
                                    e('div', { className: 'leaderboard-v2-title-group' },
                                        e('h3', { className: 'leaderboard-v2-title' },
                                            e('span', { className: 'leaderboard-v2-title-icon' }, '📊'),
                                            'Player Leaderboard'
                                        ),
                                        e('span', { className: 'leaderboard-v2-badge leaderboard-v2-badge-primary' },
                                            Math.min(leaderboardTableDisplayLimit, sortedFullTableData.length) + ' of ' + sortedFullTableData.length + ' players'
                                        ),
                                        hasRapm && e('span', { className: 'leaderboard-v2-badge leaderboard-v2-badge-purple' }, '✓ RAPM'),
                                        hasApm && e('span', { className: 'leaderboard-v2-badge leaderboard-v2-badge-primary' }, '✓ APM'),
                                        (leaderboardTableOffLuck > 0 || leaderboardTableDefLuck > 0) && e('span', { className: 'leaderboard-v2-badge leaderboard-v2-badge-amber' }, '🎲 Luck Adj'),
                                        leaderboardTableVsStarters && hasVsStartersData && e('span', { className: 'leaderboard-v2-badge leaderboard-v2-badge-cyan' }, '🎯 VS★ Mode')
                                    ),
                                    e('div', { className: 'leaderboard-v2-actions' },
                                        e('button', {
                                            className: 'leaderboard-v2-btn ' + (leaderboardTableShowSettings ? 'leaderboard-v2-btn-primary' : 'leaderboard-v2-btn-default'),
                                            onClick: () => setLeaderboardTableShowSettings(!leaderboardTableShowSettings)
                                        }, leaderboardTableShowSettings ? '▼ Settings' : '▶ Settings'),
                                        e('button', {
                                            className: 'leaderboard-v2-btn ' + (leaderboardTableFullscreen ? 'leaderboard-v2-btn-danger' : 'leaderboard-v2-btn-default'),
                                            onClick: () => setLeaderboardTableFullscreen(!leaderboardTableFullscreen)
                                        }, leaderboardTableFullscreen ? '✕ Exit' : '⛶ Expand')
                                    )
                                ),
                                
                                // Settings Panel - Enhanced Google-Style
                                leaderboardTableShowSettings && e('div', { className: 'leaderboard-v2-settings' + (mobileFiltersCollapsed ? ' mobile-filters-collapsed' : '') },
                                    // Mobile collapse toggle
                                    e('div', {
                                        className: 'mobile-filters-toggle',
                                        onClick: () => setMobileFiltersCollapsed(!mobileFiltersCollapsed)
                                    },
                                        e('span', null, mobileFiltersCollapsed ? '▶ Choose Stats & Settings' : '▼ Choose Stats & Settings'),
                                        e('span', { className: 'toggle-arrow' }, mobileFiltersCollapsed ? '▶' : '▼')
                                    ),
                                    // Row 1: Filters + Luck + Lambda
                                    e('div', { className: 'leaderboard-v2-filters-row' },
                                        e('div', { className: 'leaderboard-v2-filter-group' },
                                            e('span', { className: 'leaderboard-v2-filter-label' }, 'Team Filter'),
                                            e('select', {
                                                className: 'leaderboard-v2-select',
                                                value: leaderboardTableTeamFilter,
                                                onChange: ev => setLeaderboardTableTeamFilter(ev.target.value)
                                            }, e('option', { value: '' }, 'All Teams'), teams.map(t => e('option', { key: t, value: t }, t)))
                                        ),
                                        e('div', { className: 'leaderboard-v2-filter-group' },
                                            e('span', { className: 'leaderboard-v2-filter-label' }, 'Min Minutes'),
                                            e('input', {
                                                className: 'leaderboard-v2-input',
                                                style: { width: '70px' },
                                                type: 'number',
                                                value: leaderboardTableMinMins,
                                                onChange: ev => setLeaderboardTableMinMins(parseInt(ev.target.value) || 0)
                                            })
                                        ),
                                        // On-Off Method Toggle
                                        e('div', { className: 'leaderboard-v2-filter-group' },
                                            e('span', { className: 'leaderboard-v2-filter-label' }, '± Method'),
                                            e('div', { style: { display: 'flex', gap: '2px' }},
                                                e('button', {
                                                    style: {
                                                        fontSize: '10px',
                                                        padding: '5px 8px',
                                                        background: ftOnOffMethod === 'vsTeam' ? '#f59e0b' : '#374151',
                                                        border: 'none',
                                                        borderRadius: '4px 0 0 4px',
                                                        color: 'white',
                                                        cursor: 'pointer',
                                                        fontWeight: ftOnOffMethod === 'vsTeam' ? '600' : '400'
                                                    },
                                                    onClick: () => setFtOnOffMethod('vsTeam')
                                                }, 'vs Team'),
                                                e('button', {
                                                    style: {
                                                        fontSize: '10px',
                                                        padding: '5px 8px',
                                                        background: ftOnOffMethod === 'onOff' ? '#3b82f6' : '#374151',
                                                        border: 'none',
                                                        borderRadius: '0 4px 4px 0',
                                                        color: 'white',
                                                        cursor: 'pointer',
                                                        fontWeight: ftOnOffMethod === 'onOff' ? '600' : '400'
                                                    },
                                                    onClick: () => setFtOnOffMethod('onOff')
                                                }, 'ON - OFF')
                                            )
                                        ),
                                        // Luck Adjustment - Redesigned
                                        e('div', { className: 'leaderboard-v2-luck-group' },
                                            e('div', { className: 'leaderboard-v2-luck-slider' },
                                                e('div', { className: 'leaderboard-v2-luck-header' },
                                                    e('span', { className: 'leaderboard-v2-luck-label' }, '🎲 Off Luck'),
                                                    e('span', { className: 'leaderboard-v2-luck-value leaderboard-v2-luck-value-off' }, leaderboardTableOffLuck + '%')
                                                ),
                                                e('input', {
                                                    className: 'leaderboard-v2-range',
                                                    type: 'range',
                                                    min: 0,
                                                    max: 100,
                                                    value: leaderboardTableOffLuck,
                                                    onChange: ev => setLeaderboardTableOffLuck(parseInt(ev.target.value))
                                                })
                                            ),
                                            e('div', { className: 'leaderboard-v2-luck-slider' },
                                                e('div', { className: 'leaderboard-v2-luck-header' },
                                                    e('span', { className: 'leaderboard-v2-luck-label' }, '🛡️ Def Luck'),
                                                    e('span', { className: 'leaderboard-v2-luck-value leaderboard-v2-luck-value-def' }, leaderboardTableDefLuck + '%')
                                                ),
                                                e('input', {
                                                    className: 'leaderboard-v2-range',
                                                    type: 'range',
                                                    min: 0,
                                                    max: 100,
                                                    value: leaderboardTableDefLuck,
                                                    onChange: ev => setLeaderboardTableDefLuck(parseInt(ev.target.value))
                                                })
                                            ),
                                            (leaderboardTableOffLuck > 0 || leaderboardTableDefLuck > 0) && e('button', {
                                                className: 'leaderboard-v2-btn leaderboard-v2-btn-default',
                                                style: { padding: '4px 10px', fontSize: '10px' },
                                                onClick: () => { setLeaderboardTableOffLuck(0); setLeaderboardTableDefLuck(0); }
                                            }, '↺ Reset')
                                        ),
                                        // RAPM Lambda Control
                                        stintsData && stintsData.length > 0 && e('div', { className: 'leaderboard-v2-filter-group' },
                                            e('span', { className: 'leaderboard-v2-filter-label', style: { color: '#a78bfa' } }, 'RAPM λ'),
                                            e('input', {
                                                className: 'leaderboard-v2-input',
                                                style: { width: '70px', borderColor: 'rgba(139, 92, 246, 0.5)' },
                                                type: 'number',
                                                value: leaderboardTableLambda,
                                                onChange: ev => setLeaderboardTableLambda(parseInt(ev.target.value) || 800)
                                            }),
                                            e('div', { style: { display: 'flex', gap: '3px', marginTop: '4px' } },
                                                [100, 400, 800, 1500, 2500].map(val =>
                                                    e('button', {
                                                        key: val,
                                                        className: 'leaderboard-v2-chip ' + (rapmLambda === val ? 'leaderboard-v2-chip-purple' : 'leaderboard-v2-chip-inactive'),
                                                        style: { padding: '2px 6px', fontSize: '9px' },
                                                        onClick: () => setRapmLambda(val)
                                                    }, val >= 1000 ? (val/1000) + 'k' : val)
                                                )
                                            ),
                                            rapmLambda !== leaderboardTableLambda && e('button', {
                                                className: 'leaderboard-v2-chip leaderboard-v2-chip-amber',
                                                style: { marginTop: '4px', fontSize: '10px' },
                                                onClick: () => setRapmLambda(leaderboardTableLambda)
                                            }, 'Apply λ=' + leaderboardTableLambda)
                                        )
                                    ),
                                    // Row 2: Main Mode Buttons + Toggleable Presets - Enhanced
                                    e('div', { className: 'leaderboard-v2-mode-row', style: { marginBottom: '12px' } },
                                        // Main mode buttons
                                        e('button', {
                                            className: 'leaderboard-v2-mode-btn leaderboard-v2-mode-btn-green',
                                            onClick: () => {
                                                const indivCols = ['totalMinutes', 'games', 'mpg', 'pts75', 'reb75', 'oreb75', 'dreb75', 'ast75', 'stl75', 'blk75', 'tov75', 'fgPct', 'ftPct', 'rima100', 'rimfgPct', 'rimPressureZ', 'mida100', 'midfgPct', 'tpa100', 'threePctIndiv', 'spacingZ', 'efgPct', 'tsPct', 'usgPct', 'ftr', 'orebPct', 'drebPct', 'trbPct', 'astPctIndiv', 'tovPct', 'stlPctIndiv', 'blkPctIndiv', 'bpm', 'obpm', 'dbpm', 'fbp40'];
                                                if (hasRapm) indivCols.unshift('rapmNet', 'rapmOff', 'rapmDef');
                                                if (hasApm) indivCols.unshift('apmNet', 'apmOff', 'apmDef');
                                                setLeaderboardTableColumns(indivCols);
                                            }
                                        }, '📈 Individual'),
                                        e('button', {
                                            className: 'leaderboard-v2-mode-btn leaderboard-v2-mode-btn-blue',
                                            onClick: () => {
                                                const onOffCols = ['net', 'off', 'def', 'offEfg', 'defEfg', 'offTov', 'defTov', 'offOreb', 'defOreb', 'offFtR', 'defFtR', 'rimPct', 'midPct', 'threePct', 'rimPctV', 'midPctV', 'threePctV', 'rimVol', 'midVol', 'threeVol', 'rimVolV', 'midVolV', 'threeVolV', 'astPct', 'stlPct', 'blkPct', 'fastBreak100', 'fastBreak100V', 'secChance100', 'ptsOffTov100'];
                                                if (hasRapm) onOffCols.push('rapmNet', 'rapmOff', 'rapmDef');
                                                if (hasApm) onOffCols.push('apmNet', 'apmOff', 'apmDef');
                                                setLeaderboardTableColumns(onOffCols);
                                            }
                                        }, '⚡ On-Off'),
                                        // VS. Starters toggle button
                                        playerStintsData.length > 0 && playerData.length > 0 && e('button', {
                                            className: 'leaderboard-v2-mode-btn ' + (leaderboardTableVsStarters ? 'leaderboard-v2-mode-btn-cyan' : 'leaderboard-v2-mode-btn-gray'),
                                            onClick: () => {
                                                const newVsStartersState = !leaderboardTableVsStarters;
                                                setLeaderboardTableVsStarters(newVsStartersState);
                                                if (newVsStartersState) {
                                                    setLeaderboardTableColumns(['vsStartersMins', 'vsStartersPlusMinus', 'vsPts75', 'vsReb75', 'vsOreb75', 'vsDreb75', 'vsAst75', 'vsStl75', 'vsBlk75', 'vsTov75', 'vsUsg', 'vsTsPct', 'vsEfgPct', 'vsFgPct', 'vs3Pct']);
                                                }
                                            }
                                        }, leaderboardTableVsStarters ? '🎯 VS★ On' : '🎯 VS★'),
                                        e('div', { className: 'leaderboard-v2-divider' }),
                                        // Toggle preset chips - Compact Pills
                                        e('div', { className: 'leaderboard-v2-presets' },
                                            e('button', { className: 'leaderboard-v2-chip ' + (['net', 'off', 'def'].every(k => leaderboardTableColumns.includes(k)) ? 'leaderboard-v2-chip-active' : 'leaderboard-v2-chip-inactive'), onClick: () => togglePreset(['net', 'off', 'def']) }, 'Ratings'),
                                            e('button', { className: 'leaderboard-v2-chip ' + (['offEfg', 'defEfg', 'offTov', 'defTov', 'offOreb', 'defOreb', 'offFtR', 'defFtR'].every(k => leaderboardTableColumns.includes(k)) ? 'leaderboard-v2-chip-active' : 'leaderboard-v2-chip-inactive'), onClick: () => togglePreset(['offEfg', 'defEfg', 'offTov', 'defTov', 'offOreb', 'defOreb', 'offFtR', 'defFtR']) }, '4 Factors'),
                                            hasRapm && e('button', { className: 'leaderboard-v2-chip ' + (['rapmNet', 'rapmOff', 'rapmDef'].every(k => leaderboardTableColumns.includes(k)) ? 'leaderboard-v2-chip-purple' : 'leaderboard-v2-chip-inactive'), onClick: () => togglePreset(['rapmNet', 'rapmOff', 'rapmDef']) }, 'RAPM'),
                                            hasApm && e('button', { className: 'leaderboard-v2-chip ' + (['apmNet', 'apmOff', 'apmDef'].every(k => leaderboardTableColumns.includes(k)) ? 'leaderboard-v2-chip-active' : 'leaderboard-v2-chip-inactive'), onClick: () => togglePreset(['apmNet', 'apmOff', 'apmDef']) }, 'APM'),
                                            e('button', { className: 'leaderboard-v2-chip ' + (['rimPct', 'midPct', 'threePct', 'rimPctV', 'midPctV', 'threePctV'].every(k => leaderboardTableColumns.includes(k)) ? 'leaderboard-v2-chip-active' : 'leaderboard-v2-chip-inactive'), onClick: () => togglePreset(['rimPct', 'midPct', 'threePct', 'rimPctV', 'midPctV', 'threePctV']) }, 'Shot%'),
                                            e('button', { className: 'leaderboard-v2-chip ' + (['rimVol', 'midVol', 'threeVol', 'rimVolV', 'midVolV', 'threeVolV'].every(k => leaderboardTableColumns.includes(k)) ? 'leaderboard-v2-chip-active' : 'leaderboard-v2-chip-inactive'), onClick: () => togglePreset(['rimVol', 'midVol', 'threeVol', 'rimVolV', 'midVolV', 'threeVolV']) }, 'Volume'),
                                            e('div', { className: 'leaderboard-v2-divider' }),
                                            e('button', { className: 'leaderboard-v2-chip ' + (['totalMinutes', 'games', 'mpg'].every(k => leaderboardTableColumns.includes(k)) ? 'leaderboard-v2-chip-active' : 'leaderboard-v2-chip-inactive'), onClick: () => togglePreset(['totalMinutes', 'games', 'mpg']) }, 'Basic'),
                                            e('button', { className: 'leaderboard-v2-chip ' + (['pts75', 'reb75', 'oreb75', 'dreb75', 'ast75', 'stl75', 'blk75', 'tov75'].every(k => leaderboardTableColumns.includes(k)) ? 'leaderboard-v2-chip-active' : 'leaderboard-v2-chip-inactive'), onClick: () => togglePreset(['pts75', 'reb75', 'oreb75', 'dreb75', 'ast75', 'stl75', 'blk75', 'tov75']) }, 'Per75'),
                                            e('button', { className: 'leaderboard-v2-chip ' + (['fgPct', 'threePctIndiv', 'ftPct'].every(k => leaderboardTableColumns.includes(k)) ? 'leaderboard-v2-chip-active' : 'leaderboard-v2-chip-inactive'), onClick: () => togglePreset(['fgPct', 'threePctIndiv', 'ftPct']) }, 'Shoot%'),
                                            e('button', { className: 'leaderboard-v2-chip ' + (['tpa100', 'efgPct', 'tsPct'].every(k => leaderboardTableColumns.includes(k)) ? 'leaderboard-v2-chip-active' : 'leaderboard-v2-chip-inactive'), onClick: () => togglePreset(['tpa100', 'efgPct', 'tsPct']) }, 'Efficiency'),
                                            e('button', { className: 'leaderboard-v2-chip ' + (['bpm', 'obpm', 'dbpm'].every(k => leaderboardTableColumns.includes(k)) ? 'leaderboard-v2-chip-active' : 'leaderboard-v2-chip-inactive'), onClick: () => togglePreset(['bpm', 'obpm', 'dbpm']) }, 'BPM'),
                                            e('div', { className: 'leaderboard-v2-divider' }),
                                            e('button', { className: 'leaderboard-v2-chip leaderboard-v2-chip-amber', onClick: () => setLeaderboardTableColumns(allStatColumns.map(c => c.key)) }, '✓ All'),
                                            e('button', { className: 'leaderboard-v2-chip leaderboard-v2-chip-red', onClick: () => setLeaderboardTableColumns([]) }, '✕ Clear')
                                        )
                                    ),
                                    // Row 3: Column Toggles by Group - Compact Grid
                                    e('div', { className: 'leaderboard-v2-columns-panel' },
                                        [...new Set(allStatColumns.map(c => c.group))].map(group =>
                                            e('div', { key: group, className: 'leaderboard-v2-column-group' },
                                                e('span', { className: 'leaderboard-v2-column-group-label' }, group + ':'),
                                                allStatColumns.filter(col => col.group === group).map(col =>
                                                    e('button', {
                                                        key: col.key,
                                                        className: 'leaderboard-v2-column-btn ' + (
                                                            leaderboardTableColumns.includes(col.key)
                                                                ? col.isRapm ? 'leaderboard-v2-column-btn-rapm' : col.isApm ? 'leaderboard-v2-column-btn-apm' : 'leaderboard-v2-column-btn-on'
                                                                : 'leaderboard-v2-column-btn-off'
                                                        ),
                                                        onClick: () => {
                                                            if (leaderboardTableColumns.includes(col.key)) setLeaderboardTableColumns(leaderboardTableColumns.filter(k => k !== col.key));
                                                            else setLeaderboardTableColumns([...leaderboardTableColumns, col.key]);
                                                        }
                                                    }, col.label.replace('±', '').replace('/75', '').replace('/100', ''))
                                                )
                                            )
                                        )
                                    ),
                                    // RAPM/APM Calculate Buttons
                                    (!hasRapm || !hasApm) && stintsData && stintsData.length > 0 && e('div', { style: { marginTop: '10px', paddingTop: '10px', borderTop: '1px solid #334155', display: 'flex', gap: '8px', flexWrap: 'wrap' }},
                                        !hasRapm && e('button', {
                                            style: { fontSize: '10px', padding: '5px 12px', background: 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' },
                                            onClick: triggerPlayerRAPMCalculation
                                        }, '🔮 Calculate RAPM (λ=' + rapmLambda + ')'),
                                        !hasApm && seasonStatsMap && seasonStatsMap.size > 0 && e('button', {
                                            style: { fontSize: '10px', padding: '5px 12px', background: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' },
                                            onClick: triggerAPMCalculation
                                        }, '🔮 Calculate APM')
                                    )
                                ),
                                
                                // Collapsible Stat Filters
                                e('div', { style: { marginBottom: '12px' } },
                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' } },
                                        e('button', {
                                            style: { padding: '4px 10px', fontSize: '11px', background: leaderboardTableShowFilters ? '#3b82f6' : '#334155', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' },
                                            onClick: () => setLeaderboardTableShowFilters(!leaderboardTableShowFilters)
                                        },
                                            leaderboardTableShowFilters ? '▼ Stat Filters' : '▶ Stat Filters'
                                        ),
                                        Object.values(leaderboardTableStatFilters).filter(f => f.min || f.max).length > 0 && e('span', { style: { fontSize: '10px', padding: '2px 6px', background: 'rgba(59, 130, 246, 0.2)', borderRadius: '4px', color: '#60a5fa' } }, Object.values(leaderboardTableStatFilters).filter(f => f.min || f.max).length + ' active'),
                                        Object.values(leaderboardTableStatFilters).filter(f => f.min || f.max).length > 0 && e('button', {
                                            style: { padding: '3px 8px', fontSize: '10px', background: '#ef4444', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' },
                                            onClick: () => setLeaderboardTableStatFilters({})
                                        }, '✕ Clear All')
                                    ),
                                    leaderboardTableShowFilters && e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(140px, 1fr))', gap: '6px', padding: '8px', background: 'rgba(30, 41, 59, 0.3)', borderRadius: '4px' } },
                                        activeColumns.map(col => {
                                            const hasFilter = leaderboardTableStatFilters[col.key]?.min || leaderboardTableStatFilters[col.key]?.max;
                                            return e('div', {
                                                key: col.key,
                                                style: { display: 'flex', flexDirection: 'column', gap: '2px', padding: '4px', background: hasFilter ? 'rgba(59, 130, 246, 0.1)' : 'transparent', borderRadius: '4px' }
                                            },
                                                e('span', { style: { fontSize: '9px', color: '#94a3b8' } }, col.label.replace('±', '')),
                                                e('div', { style: { display: 'flex', gap: '2px', alignItems: 'center' } },
                                                    e('input', {
                                                        style: { width: '45px', padding: '2px 4px', fontSize: '10px', background: '#1e293b', color: 'white', border: '1px solid #334155', borderRadius: '2px' },
                                                        type: 'number',
                                                        placeholder: 'Min',
                                                        step: '0.1',
                                                        value: (leaderboardTableStatFilters[col.key]?.min) || '',
                                                        onChange: ev => setLeaderboardTableStatFilters({ ...leaderboardTableStatFilters, [col.key]: { ...(leaderboardTableStatFilters[col.key] || {}), min: ev.target.value } })
                                                    }),
                                                    e('span', { style: { fontSize: '10px', color: '#64748b' } }, '—'),
                                                    e('input', {
                                                        style: { width: '45px', padding: '2px 4px', fontSize: '10px', background: '#1e293b', color: 'white', border: '1px solid #334155', borderRadius: '2px' },
                                                        type: 'number',
                                                        placeholder: 'Max',
                                                        step: '0.1',
                                                        value: (leaderboardTableStatFilters[col.key]?.max) || '',
                                                        onChange: ev => setLeaderboardTableStatFilters({ ...leaderboardTableStatFilters, [col.key]: { ...(leaderboardTableStatFilters[col.key] || {}), max: ev.target.value } })
                                                    })
                                                )
                                            );
                                        })
                                    )
                                ),

                                // Full Table - Modern Data Grid
                                e('div', {
                                    className: 'leaderboard-v2-table-scroll' + (leaderboardTableFullscreen ? ' fullscreen' : '')
                                },
                                    e('table', { className: 'leaderboard-v2-table' + (mobilePlayerColExpanded ? ' player-col-expanded' : '') },
                                        e('thead', null,
                                            e('tr', null,
                                                e('th', {
                                                    key: 'r',
                                                    className: 'sticky-rank'
                                                }, '#'),
                                                e('th', {
                                                    key: 'p',
                                                    className: 'sticky-player ' + (leaderboardTableSortBy === 'player' ? 'sorted' : ''),
                                                    onClick: () => { setLeaderboardTableSortBy('player'); setLeaderboardTableSortAsc(!leaderboardTableSortAsc); }
                                                },
                                                    'Player',
                                                    e('span', {
                                                        className: 'mobile-col-expand-btn',
                                                        onClick: (ev) => { ev.stopPropagation(); setMobilePlayerColExpanded(!mobilePlayerColExpanded); }
                                                    }, mobilePlayerColExpanded ? ' ◂' : ' ▸'),
                                                    leaderboardTableSortBy === 'player' && e('span', { className: 'leaderboard-v2-sort-icon' }, leaderboardTableSortAsc ? '▲' : '▼')
                                                ),
                                                e('th', {
                                                    key: 't',
                                                    className: 'sticky-team ' + (leaderboardTableSortBy === 'team' ? 'sorted' : ''),
                                                    onClick: () => { setLeaderboardTableSortBy('team'); setLeaderboardTableSortAsc(!leaderboardTableSortAsc); }
                                                },
                                                    'Team',
                                                    leaderboardTableSortBy === 'team' && e('span', { className: 'leaderboard-v2-sort-icon' }, leaderboardTableSortAsc ? '▲' : '▼')
                                                ),
                                                e('th', {
                                                    key: 'm',
                                                    className: 'sticky-mins ' + (leaderboardTableSortBy === 'onMins' ? 'sorted' : ''),
                                                    onClick: () => { setLeaderboardTableSortBy('onMins'); setLeaderboardTableSortAsc(!leaderboardTableSortAsc); }
                                                },
                                                    'Min',
                                                    leaderboardTableSortBy === 'onMins' && e('span', { className: 'leaderboard-v2-sort-icon' }, leaderboardTableSortAsc ? '▲' : '▼')
                                                ),
                                                activeColumns.map((col, idx) => {
                                                    const isSorted = leaderboardTableSortBy === col.key;
                                                    const isBoundary = sectionBoundaries.includes(idx);
                                                    const sectionClass = col.section ? 'section-' + col.section : '';
                                                    return e('th', {
                                                        key: col.key,
                                                        className: (isSorted ? 'sorted ' : '') + sectionClass + (isBoundary ? ' section-start' : ''),
                                                        onClick: () => { setLeaderboardTableSortBy(col.key); setLeaderboardTableSortAsc(!leaderboardTableSortAsc); },
                                                        title: col.desc || col.description || col.label
                                                    },
                                                        col.label,
                                                        !col.higherBetter && e('span', { className: 'leaderboard-v2-lower-better' }, '↓'),
                                                        isSorted && e('span', { className: 'leaderboard-v2-sort-icon' }, leaderboardTableSortAsc ? '▲' : '▼')
                                                    );
                                                })
                                            )
                                        ),
                                        e('tbody', null,
                                            sortedFullTableData.slice(0, leaderboardTableDisplayLimit).map((d, i) => {
                                                const rankClass = i < 3 ? 'leaderboard-v2-rank leaderboard-v2-rank-top3' : i < 10 ? 'leaderboard-v2-rank leaderboard-v2-rank-top10' : 'leaderboard-v2-rank';
                                                return e('tr', {
                                                    key: d.player + '-' + i
                                                },
                                                    e('td', { className: 'sticky-rank' },
                                                        e('span', { className: rankClass }, i + 1)
                                                    ),
                                                    e('td', {
                                                        className: 'sticky-player',
                                                        onClick: () => { setRadarPlayer({ player: d.player, team: d.team, allStats: d }); setShowRadarModal(true); },
                                                        title: 'Click to view player percentiles'
                                                    },
                                                        e('span', { className: 'leaderboard-v2-player-name' }, d.player)
                                                    ),
                                                    e('td', { className: 'sticky-team' },
                                                        e('span', { className: 'leaderboard-v2-team' }, d.team)
                                                    ),
                                                    e('td', { className: 'sticky-mins' },
                                                        e('span', { className: 'leaderboard-v2-mins' }, Math.round(d.onMins || 0))
                                                    ),
                                                    activeColumns.map((col, idx) => {
                                                        const val = d[col.key];
                                                        const pctPool = percentileData[col.key] || [];
                                                        const pct = pctPool.length > 0 && val != null ? getPercentile(val, pctPool, col.higherBetter !== false) : 50;
                                                        // Skip color coding if noColor flag is set
                                                        const pctClass = col.noColor ? '' : (pct >= 90 ? 'leaderboard-v2-pct-elite' : pct >= 75 ? 'leaderboard-v2-pct-great' : pct >= 60 ? 'leaderboard-v2-pct-good' : pct >= 40 ? 'leaderboard-v2-pct-avg' : pct >= 25 ? 'leaderboard-v2-pct-below' : pct >= 10 ? 'leaderboard-v2-pct-poor' : 'leaderboard-v2-pct-bad');
                                                        const isBoundary = sectionBoundaries.includes(idx);
                                                        const sectionClass = col.section ? 'section-' + col.section : '';
                                                        return e('td', {
                                                            key: col.key,
                                                            className: sectionClass + (isBoundary ? ' section-start' : '')
                                                        },
                                                            e('span', { className: 'leaderboard-v2-stat ' + pctClass },
                                                                val != null ? (typeof val === 'number' ? val.toFixed(1) : val) : '-'
                                                            )
                                                        );
                                                    })
                                                );
                                            })
                                        )
                                    )
                                ),

                                // Load More Button
                                sortedFullTableData.length > leaderboardTableDisplayLimit && e('div', {
                                    style: {
                                        display: 'flex',
                                        justifyContent: 'center',
                                        alignItems: 'center',
                                        gap: '12px',
                                        padding: '16px 20px',
                                        background: 'rgba(30, 41, 59, 0.5)',
                                        borderTop: '1px solid rgba(71, 85, 105, 0.3)'
                                    }
                                },
                                    e('button', {
                                        className: 'leaderboard-v2-btn leaderboard-v2-btn-primary',
                                        style: { padding: '10px 24px', fontSize: '13px', fontWeight: '600' },
                                        onClick: () => setLeaderboardTableDisplayLimit(prev => Math.min(prev + 50, sortedFullTableData.length))
                                    },
                                        '📥 Load Next 50 Players'
                                    ),
                                    e('span', { style: { fontSize: '12px', color: '#94a3b8' } },
                                        'Showing ' + Math.min(leaderboardTableDisplayLimit, sortedFullTableData.length) + ' of ' + sortedFullTableData.length + ' players'
                                    )
                                ),

                                // Legend - Modern Footer
                                e('div', { className: 'leaderboard-v2-legend' },
                                    e('span', { className: 'leaderboard-v2-legend-title' }, 'Percentile:'),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #16a34a, #15803d)' } }),
                                        '90th+'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #22c55e, #16a34a)' } }),
                                        '75-89'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #4ade80, #22c55e)' } }),
                                        '60-74'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #64748b, #475569)' } }),
                                        '40-59'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #f59e0b, #d97706)' } }),
                                        '25-39'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #f97316, #ea580c)' } }),
                                        '10-24'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #dc2626, #b91c1c)' } }),
                                        '<10th'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-sep' }, '|'),
                                    e('span', { style: { color: ftOnOffMethod === 'onOff' ? '#3b82f6' : '#f59e0b' } }, ftOnOffMethod === 'onOff' ? '± = ON - OFF' : '± = ON vs Team Avg'),
                                    e('span', { className: 'leaderboard-v2-legend-sep' }, '|'),
                                    e('span', null, '↓ = lower is better'),
                                    (leaderboardTableOffLuck > 0 || leaderboardTableDefLuck > 0) && e('span', { style: { color: '#fbbf24' } }, '| 🎲 Luck: Off ' + leaderboardTableOffLuck + '% | Def ' + leaderboardTableDefLuck + '%')
                                )
                            );
                        })(),
                        
                        // On/Off Leaderboard Tab
                        lbSubtab === 'onoff' && e('div', null,
                            // View mode toggle for On/Off tab
                            e('div', { style: { display: 'flex', gap: '8px', marginBottom: '12px', flexWrap: 'wrap' }},
                                e('button', { 
                                    className: 'btn',
                                    style: { 
                                        background: lbViewMode === 'table' ? '#3b82f6' : '#475569',
                                        color: 'white',
                                        padding: '6px 12px',
                                        fontSize: '12px'
                                    },
                                    onClick: () => setLbViewMode('table')
                                }, '📋 Table'),
                                e('button', { 
                                    className: 'btn',
                                    style: { 
                                        background: lbViewMode === 'chart' ? '#3b82f6' : '#475569',
                                        color: 'white',
                                        padding: '6px 12px',
                                        fontSize: '12px'
                                    },
                                    onClick: () => setLbViewMode('chart')
                                }, '📈 Chart')
                            ),
                            e('div', { style: { flex: '1', minWidth: '250px' }},
                                e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8 }}, 'Stat'),
                                e('select', { 
                                    value: lbStat, 
                                    onChange: ev => { setLbStat(ev.target.value); setLbSortCol('diff'); },
                                    style: { width: '100%', padding: '8px', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: 'white' }
                                },
                                    Object.entries(groupedOptions).map(([group, opts]) => 
                                        e('optgroup', { key: group, label: group },
                                            opts.map(s => e('option', { key: s.value, value: s.value }, s.label))
                                        )
                                    )
                                )
                            ),
                            e('div', { style: { minWidth: '150px' }},
                                e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8 }}, 'Team'),
                                e('select', { 
                                    value: lbTeam, 
                                    onChange: ev => setLbTeam(ev.target.value),
                                    style: { width: '100%', padding: '8px', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: 'white' }
                                },
                                    e('option', { value: '' }, 'All Teams'),
                                    teams.map(t => e('option', { key: t, value: t }, t))
                                )
                            ),
                            e('div', { style: { minWidth: '100px' }},
                                e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8 }}, 'Min ON Mins'),
                                e('input', {
                                    type: 'number',
                                    value: lbMinMins,
                                    onChange: ev => setLbMinMins(parseInt(ev.target.value) || 0),
                                    style: { width: '100%', padding: '8px', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: 'white' }
                                })
                            ),
                            // V5.14.2: Sort direction toggle for on-off leaderboard
                            e('div', { style: { minWidth: '80px' }},
                                e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8 }}, 'Sort'),
                                e('button', {
                                    onClick: () => setLbSortDir(lbSortDir === 'desc' ? 'asc' : 'desc'),
                                    style: {
                                        width: '100%',
                                        padding: '8px 12px',
                                        background: lbSortDir === 'asc' ? 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)' : 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)',
                                        border: 'none',
                                        borderRadius: '6px',
                                        color: 'white',
                                        cursor: 'pointer',
                                        fontWeight: '600',
                                        fontSize: '12px'
                                    }
                                }, lbSortDir === 'asc' ? '↑ Asc' : '↓ Desc')
                            ),
                            // RAPM Lambda control with presets
                            stintsData.length > 0 && e('div', { style: { minWidth: '180px' }},
                                e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8, color: '#a78bfa' }}, 
                                    'RAPM λ',
                                    e('span', { style: { fontSize: '9px', marginLeft: '4px', opacity: 0.7 }}, '(regularization)')
                                ),
                                e('div', { style: { display: 'flex', gap: '4px' }},
                                    e('input', { 
                                        type: 'number', 
                                        value: rapmLambda, 
                                        onChange: ev => setRapmLambda(Math.max(1, parseInt(ev.target.value) || 800)),
                                        min: 1,
                                        max: 10000,
                                        step: 100,
                                        style: { width: '70px', padding: '8px', background: '#1e293b', border: '1px solid rgba(139, 92, 246, 0.4)', borderRadius: '6px', color: '#a78bfa' }
                                    }),
                                    e('div', { style: { display: 'flex', flexDirection: 'column', gap: '2px' }},
                                        e('div', { style: { display: 'flex', gap: '2px' }},
                                            [100, 400, 800].map(val => 
                                                e('button', { 
                                                    key: val,
                                                    style: { 
                                                        fontSize: '9px', 
                                                        padding: '2px 5px', 
                                                        background: rapmLambda === val ? '#8b5cf6' : '#374151',
                                                        border: 'none',
                                                        borderRadius: '3px',
                                                        color: 'white',
                                                        cursor: 'pointer'
                                                    },
                                                    onClick: () => setRapmLambda(val)
                                                }, val)
                                            )
                                        ),
                                        e('div', { style: { display: 'flex', gap: '2px' }},
                                            [1500, 2500, 5000].map(val => 
                                                e('button', { 
                                                    key: val,
                                                    style: { 
                                                        fontSize: '9px', 
                                                        padding: '2px 5px', 
                                                        background: rapmLambda === val ? '#8b5cf6' : '#374151',
                                                        border: 'none',
                                                        borderRadius: '3px',
                                                        color: 'white',
                                                        cursor: 'pointer'
                                                    },
                                                    onClick: () => setRapmLambda(val)
                                                }, val >= 1000 ? (val/1000) + 'k' : val)
                                            )
                                        )
                                    )
                                )
                            ),
                            // ON-OFF vs ON vs Team Avg method toggle
                            e('div', { style: { minWidth: '140px' }},
                                e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8 }}, 'Method'),
                                e('div', { style: { display: 'flex', gap: '2px' }},
                                    e('button', {
                                        style: {
                                            fontSize: '10px',
                                            padding: '6px 8px',
                                            background: lbOnOffMethod === 'onOff' ? '#3b82f6' : '#374151',
                                            border: 'none',
                                            borderRadius: '4px 0 0 4px',
                                            color: 'white',
                                            cursor: 'pointer',
                                            fontWeight: lbOnOffMethod === 'onOff' ? '600' : '400'
                                        },
                                        onClick: () => setLbOnOffMethod('onOff')
                                    }, 'ON - OFF'),
                                    e('button', {
                                        style: {
                                            fontSize: '10px',
                                            padding: '6px 8px',
                                            background: lbOnOffMethod === 'vsTeam' ? '#f59e0b' : '#374151',
                                            border: 'none',
                                            borderRadius: '0 4px 4px 0',
                                            color: 'white',
                                            cursor: 'pointer',
                                            fontWeight: lbOnOffMethod === 'vsTeam' ? '600' : '400'
                                        },
                                        onClick: () => setLbOnOffMethod('vsTeam')
                                    }, 'ON - Team')
                                )
                            ),

                        // Luck Adjustment Slider (only show for luck-adjusted stats)
                        lbSubtab === 'onoff' && currentStat.isLuckStat && e('div', { style: { background: 'rgba(251, 191, 36, 0.1)', border: '1px solid rgba(251, 191, 36, 0.3)', borderRadius: '8px', padding: '12px', marginBottom: '16px' }},
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap' }},
                                e('label', { style: { fontSize: '13px', fontWeight: '600', color: '#fbbf24' }}, '🎲 3PT Luck Adjustment'),
                                e('div', { style: { 
                                    padding: '4px 12px', 
                                    borderRadius: '12px', 
                                    fontSize: '14px', 
                                    fontWeight: 'bold',
                                    background: lbLuckAdj > 0 ? 'rgba(34, 197, 94, 0.3)' : 'rgba(100, 116, 139, 0.3)', 
                                    color: lbLuckAdj > 0 ? '#4ade80' : '#94a3b8'
                                }}, lbLuckAdj + '%'),
                                e('input', { 
                                    type: 'range', 
                                    min: 0, 
                                    max: 100, 
                                    value: lbLuckAdj, 
                                    onChange: ev => setLbLuckAdj(parseInt(ev.target.value)),
                                    style: { flex: '1', minWidth: '150px', cursor: 'pointer' }
                                }),
                                e('button', { 
                                    className: 'btn btn-secondary', 
                                    style: { fontSize: '11px', padding: '4px 10px' },
                                    onClick: () => setLbLuckAdj(100)
                                }, 'Reset to 100%'),
                                e('span', { style: { fontSize: '11px', opacity: 0.7 }}, 'Regresses 3PT% toward league avg (36%)')
                            )
                        ),
                        
                        // Lambda mismatch warning for Player RAPM
                        lbSubtab === 'onoff' && rapmAvailable && playerRAPMStats?.lambda && rapmLambda !== playerRAPMStats.lambda && e('div', { 
                            style: { 
                                background: 'rgba(251, 191, 36, 0.15)', 
                                border: '1px solid rgba(251, 191, 36, 0.4)',
                                borderRadius: '8px',
                                padding: '12px', 
                                marginBottom: '16px',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '12px',
                                flexWrap: 'wrap'
                            }
                        },
                            e('span', { style: { fontSize: '12px', color: '#fbbf24' }}, 
                                '⚠️ RAPM λ changed from ' + playerRAPMStats.lambda + ' to ' + rapmLambda
                            ),
                            e('button', {
                                className: 'btn',
                                style: { 
                                    fontSize: '11px', 
                                    padding: '6px 12px', 
                                    background: 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)',
                                    border: 'none',
                                    color: 'white',
                                    cursor: 'pointer',
                                    fontWeight: '600'
                                },
                                onClick: triggerPlayerRAPMCalculation,
                                disabled: isCalculatingPlayerRAPM
                            }, isCalculatingPlayerRAPM ? '⏳ Computing...' : '🔄 Recalculate RAPM'),
                            e('span', { style: { fontSize: '10px', opacity: 0.7 }}, 
                                'Higher λ = more regularization (shrinks toward 0). Lower λ = more variance.'
                            )
                        ),
                        
                        lbSubtab === 'onoff' && lbStat !== 'bpmImpactCombos' && lbStat !== 'bpmImpactZScore' && e('p', { style: { fontSize: '11px', opacity: 0.7, marginBottom: '12px' }},
                            'Showing ' + sortedData.length + ' of ' + totalFilteredCount + ' players. ',
                            currentStat.higherBetter ? 'Higher is better.' : 'Lower is better.',
                            ' ON/OFF show ± vs league avg (', (leagueAverages[lbStat] || 0).toFixed(1), '). ',
                            lbOnOffMethod === 'vsTeam'
                                ? e('span', { style: { color: '#f59e0b' } }, 'DIFF = ON value minus Team Average. ')
                                : '',
                            lbOnOffMethod === 'onOff'
                                ? 'DIFF = ON value minus OFF value. '
                                : '',
                            useRapmForStat ? 'RAPM shows isolated player impact.' : ('Context columns show ' + (lbOnOffMethod === 'vsTeam' ? 'ON - Team Avg diff.' : 'ON-OFF diff.')),
                            // V4.9.8.7.30: Add explanation for combined stats
                            currentStat.isCombinedStat && e('span', { style: { color: '#a78bfa' }},
                                lbStat === 'possBattle' ? ' Combines: Off OREB% ↑, Off TOV% ↓, Def OREB% ↓, Def TOV% ↑' :
                                lbStat === 'scoringBattle' ? ' Combines: Off eFG% ↑, Off FTR ↑, Def eFG% ↓, Def FTR ↓' :
                                lbStat === 'fourFactorsImpact' ? ' Combines all 8 four factors (z-score normalized)' : ''
                            )),
                        
                        // V5.14: BPM Impact Combos chart not available - show message
                        lbSubtab === 'onoff' && lbViewMode === 'chart' && (lbStat === 'bpmImpactCombos' || lbStat === 'bpmImpactZScore') && e('div', { style: { textAlign: 'center', padding: '40px', background: 'rgba(15, 23, 42, 0.5)', borderRadius: '12px', border: '1px solid #334155' }},
                            e('div', { style: { fontSize: '48px', marginBottom: '16px' }}, '👥'),
                            e('div', { style: { fontSize: '16px', fontWeight: '600', color: '#94a3b8' }}, lbStat === 'bpmImpactZScore' ? 'BPM Impact Z-Score' : 'BPM Impact Combos'),
                            e('div', { style: { fontSize: '12px', color: '#64748b', marginTop: '8px' }}, 'Chart view is not available for two-player combinations.'),
                            e('div', { style: { fontSize: '12px', color: '#60a5fa', marginTop: '8px' }}, 'Switch to Table view to see BPM Impact analysis.')
                        ),

                        // V4.9.8.7.30: Chart View
                        lbSubtab === 'onoff' && lbViewMode === 'chart' && lbStat !== 'bpmImpactCombos' && lbStat !== 'bpmImpactZScore' && e('div', { style: { marginBottom: '20px' }},
                            // Chart axis selectors
                            e('div', { style: { display: 'flex', gap: '16px', marginBottom: '16px', flexWrap: 'wrap' }},
                                e('div', { style: { minWidth: '200px' }},
                                    e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8 }}, 'X-Axis'),
                                    e('select', { 
                                        value: lbChartX, 
                                        onChange: ev => setLbChartX(ev.target.value),
                                        style: { width: '100%', padding: '8px', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: 'white' }
                                    },
                                        Object.entries(groupedOptions).map(([group, opts]) => 
                                            e('optgroup', { key: group, label: group },
                                                opts.map(s => e('option', { key: s.value, value: s.value }, s.label))
                                            )
                                        )
                                    )
                                ),
                                e('div', { style: { minWidth: '200px' }},
                                    e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8 }}, 'Y-Axis'),
                                    e('select', { 
                                        value: lbChartY, 
                                        onChange: ev => setLbChartY(ev.target.value),
                                        style: { width: '100%', padding: '8px', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: 'white' }
                                    },
                                        Object.entries(groupedOptions).map(([group, opts]) => 
                                            e('optgroup', { key: group, label: group },
                                                opts.map(s => e('option', { key: s.value, value: s.value }, s.label))
                                            )
                                        )
                                    )
                                )
                            ),
                            // Legend for direction indicators
                            e('div', { style: { 
                                fontSize: '11px', 
                                color: '#94a3b8', 
                                marginBottom: '12px',
                                display: 'flex',
                                gap: '16px',
                                flexWrap: 'wrap'
                            }},
                                e('span', null, 
                                    e('span', { style: { color: '#4ade80' }}, '↑'),
                                    ' = Higher diff is better'
                                ),
                                e('span', null,
                                    e('span', { style: { color: '#f87171' }}, '↓'),
                                    ' = Lower diff is better (e.g., Off TOV%, Def eFG%)'
                                ),
                                e('span', null,
                                    e('span', { style: { color: '#4ade80' }}, '●'),
                                    ' Positive impact ',
                                    e('span', { style: { color: '#f87171' }}, '●'),
                                    ' Negative impact'
                                )
                            ),
                            // SVG Chart
                            (() => {
                                const chartWidth = 800;
                                const chartHeight = 600;
                                const padding = { top: 40, right: 40, bottom: 60, left: 70 };
                                const plotWidth = chartWidth - padding.left - padding.right;
                                const plotHeight = chartHeight - padding.top - padding.bottom;
                                
                                // Get stat options for axes
                                const xStatOpt = statOptions.find(s => s.value === lbChartX) || statOptions[0];
                                const yStatOpt = statOptions.find(s => s.value === lbChartY) || statOptions[0];
                                
                                // Calculate values for each player
                                const getPlayerStatDiff = (player, statKey) => {
                                    if (statKey === 'possBattle') return player.possBattle || 0;
                                    if (statKey === 'scoringBattle') return player.scoringBattle || 0;
                                    if (statKey === 'fourFactorsImpact') return player.fourFactorsImpact || 0;
                                    const on = player.onStats[statKey] || 0;
                                    const off = player.offStats[statKey] || 0;
                                    return on - off;
                                };
                                
                                const chartData = filteredData.map(d => ({
                                    player: d.player,
                                    team: d.team,
                                    minutes: d.onMinutes,
                                    x: getPlayerStatDiff(d, lbChartX),
                                    y: getPlayerStatDiff(d, lbChartY),
                                    // Store raw values for tooltip
                                    rawX: getPlayerStatDiff(d, lbChartX),
                                    rawY: getPlayerStatDiff(d, lbChartY)
                                })).filter(d => !isNaN(d.x) && !isNaN(d.y) && isFinite(d.x) && isFinite(d.y));
                                
                                if (chartData.length === 0) {
                                    return e('p', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }}, 'No data available for chart');
                                }
                                
                                // V4.9.8.7.30: Calculate direction-adjusted values for coloring
                                // For "lower is better" stats, we flip the sign so positive = good
                                const getAdjustedValue = (val, statKey) => {
                                    const statOpt = statOptions.find(s => s.value === statKey);
                                    if (!statOpt) return val;
                                    return statOpt.higherBetter ? val : -val;
                                };
                                
                                // Calculate ranges
                                const xVals = chartData.map(d => d.x);
                                const yVals = chartData.map(d => d.y);
                                const xMin = Math.min(...xVals), xMax = Math.max(...xVals);
                                const yMin = Math.min(...yVals), yMax = Math.max(...yVals);
                                
                                // Add padding to ranges and ensure 0 is included
                                const xPad = Math.max((xMax - xMin) * 0.1, 0.5);
                                const yPad = Math.max((yMax - yMin) * 0.1, 0.5);
                                const xRange = [Math.min(xMin - xPad, 0), Math.max(xMax + xPad, 0)];
                                const yRange = [Math.min(yMin - yPad, 0), Math.max(yMax + yPad, 0)];
                                
                                // Scale functions
                                const scaleX = (val) => padding.left + ((val - xRange[0]) / (xRange[1] - xRange[0])) * plotWidth;
                                const scaleY = (val) => padding.top + plotHeight - ((val - yRange[0]) / (yRange[1] - yRange[0])) * plotHeight;
                                
                                // Zero lines
                                const zeroX = scaleX(0);
                                const zeroY = scaleY(0);
                                
                                // Diagonal line (for combined stats)
                                const showDiagonal = ['possBattle', 'scoringBattle', 'fourFactorsImpact'].includes(lbChartX) || 
                                                     ['possBattle', 'scoringBattle', 'fourFactorsImpact'].includes(lbChartY);
                                
                                return e('div', { className: 'export-chart-scroll-wrapper', style: { position: 'relative', display: 'flex', justifyContent: 'center' }},
                                    e('svg', {
                                        width: chartWidth,
                                        height: chartHeight,
                                        style: { background: '#0f172a', borderRadius: '8px', border: '1px solid #334155' }
                                    },
                                        // Grid lines
                                        ...[...Array(9)].map((_, i) => {
                                            const xVal = xRange[0] + (xRange[1] - xRange[0]) * (i / 8);
                                            const yVal = yRange[0] + (yRange[1] - yRange[0]) * (i / 8);
                                            return [
                                                e('line', { 
                                                    key: 'gx' + i, 
                                                    x1: scaleX(xVal), y1: padding.top, 
                                                    x2: scaleX(xVal), y2: chartHeight - padding.bottom,
                                                    stroke: '#334155', strokeWidth: 0.5
                                                }),
                                                e('line', { 
                                                    key: 'gy' + i, 
                                                    x1: padding.left, y1: scaleY(yVal), 
                                                    x2: chartWidth - padding.right, y2: scaleY(yVal),
                                                    stroke: '#334155', strokeWidth: 0.5
                                                })
                                            ];
                                        }).flat(),
                                        
                                        // Zero lines (bolder)
                                        zeroX >= padding.left && zeroX <= chartWidth - padding.right && e('line', {
                                            x1: zeroX, y1: padding.top, x2: zeroX, y2: chartHeight - padding.bottom,
                                            stroke: '#64748b', strokeWidth: 1.5
                                        }),
                                        zeroY >= padding.top && zeroY <= chartHeight - padding.bottom && e('line', {
                                            x1: padding.left, y1: zeroY, x2: chartWidth - padding.right, y2: zeroY,
                                            stroke: '#64748b', strokeWidth: 1.5
                                        }),
                                        
                                        // Diagonal line for combined stats (shows positive/negative players)
                                        showDiagonal && e('line', {
                                            x1: padding.left, y1: chartHeight - padding.bottom,
                                            x2: chartWidth - padding.right, y2: padding.top,
                                            stroke: '#475569', strokeWidth: 1.5, strokeDasharray: '8,4'
                                        }),
                                        
                                        // Labels for quadrants (if showing combined stats)
                                        showDiagonal && e('text', {
                                            x: padding.left + 10, y: padding.top + 20,
                                            fill: '#4ade80', fontSize: 11, fontStyle: 'italic', opacity: 0.7
                                        }, 'Positive Players'),
                                        showDiagonal && e('text', {
                                            x: chartWidth - padding.right - 90, y: chartHeight - padding.bottom - 10,
                                            fill: '#f87171', fontSize: 11, fontStyle: 'italic', opacity: 0.7
                                        }, 'Negative Players'),
                                        
                                        // Data points
                                        ...chartData.map((d, i) => {
                                            const cx = scaleX(d.x);
                                            const cy = scaleY(d.y);
                                            const isHovered = hoveredPlayer === i;
                                            // V4.9.8.7.30: Color based on direction-adjusted values
                                            // For "lower is better" stats, negative raw diff = good
                                            const adjX = getAdjustedValue(d.x, lbChartX);
                                            const adjY = getAdjustedValue(d.y, lbChartY);
                                            const impact = (adjX + adjY) / 2;
                                            const color = impact > 0.5 ? '#4ade80' : impact < -0.5 ? '#f87171' : '#94a3b8';
                                            
                                            return e('g', { key: i },
                                                e('circle', {
                                                    cx, cy,
                                                    r: isHovered ? 8 : 5,
                                                    fill: color,
                                                    fillOpacity: isHovered ? 1 : 0.7,
                                                    stroke: isHovered ? 'white' : 'none',
                                                    strokeWidth: 2,
                                                    style: { cursor: 'pointer', transition: 'r 0.1s' },
                                                    onMouseEnter: () => setHoveredPlayer(i),
                                                    onMouseLeave: () => setHoveredPlayer(null)
                                                }),
                                                isHovered && e('text', {
                                                    x: cx, y: cy - 12,
                                                    fill: 'white', fontSize: 11, textAnchor: 'middle', fontWeight: 'bold'
                                                }, d.player)
                                            );
                                        }),
                                        
                                        // Axis labels
                                        e('text', {
                                            x: chartWidth / 2, y: chartHeight - 15,
                                            fill: '#94a3b8', fontSize: 13, textAnchor: 'middle', fontWeight: '600'
                                        }, xStatOpt.label + (xStatOpt.higherBetter ? ' ↑' : ' ↓')),
                                        e('text', {
                                            x: 20, y: chartHeight / 2,
                                            fill: '#94a3b8', fontSize: 13, textAnchor: 'middle', fontWeight: '600',
                                            transform: 'rotate(-90, 20, ' + (chartHeight / 2) + ')'
                                        }, yStatOpt.label + (yStatOpt.higherBetter ? ' ↑' : ' ↓')),
                                        
                                        // Title
                                        e('text', {
                                            x: chartWidth / 2, y: 20,
                                            fill: '#f1f5f9', fontSize: 16, textAnchor: 'middle', fontWeight: 'bold'
                                        }, 'Four Factors Influence Distribution'),
                                        
                                        // X-axis ticks
                                        ...[0, 0.25, 0.5, 0.75, 1].map(pct => {
                                            const val = xRange[0] + (xRange[1] - xRange[0]) * pct;
                                            return e('text', {
                                                key: 'xt' + pct,
                                                x: scaleX(val), y: chartHeight - padding.bottom + 18,
                                                fill: '#64748b', fontSize: 10, textAnchor: 'middle'
                                            }, val.toFixed(1));
                                        }),
                                        
                                        // Y-axis ticks
                                        ...[0, 0.25, 0.5, 0.75, 1].map(pct => {
                                            const val = yRange[0] + (yRange[1] - yRange[0]) * pct;
                                            return e('text', {
                                                key: 'yt' + pct,
                                                x: padding.left - 8, y: scaleY(val) + 3,
                                                fill: '#64748b', fontSize: 10, textAnchor: 'end'
                                            }, val.toFixed(1));
                                        })
                                    ),
                                    // Tooltip
                                    hoveredPlayer !== null && (() => {
                                        const pd = chartData[hoveredPlayer];
                                        // V4.9.8.7.30: Color based on direction - for "lower is better", negative = good
                                        const xIsGood = xStatOpt.higherBetter ? pd.x > 0 : pd.x < 0;
                                        const yIsGood = yStatOpt.higherBetter ? pd.y > 0 : pd.y < 0;
                                        const xColor = pd.x === 0 ? '#94a3b8' : xIsGood ? '#4ade80' : '#f87171';
                                        const yColor = pd.y === 0 ? '#94a3b8' : yIsGood ? '#4ade80' : '#f87171';
                                        
                                        return e('div', {
                                            style: {
                                                position: 'absolute',
                                                left: scaleX(pd.x) + 15,
                                                top: scaleY(pd.y) - 30,
                                                background: '#1e293b',
                                                border: '1px solid #475569',
                                                borderRadius: '6px',
                                                padding: '8px 12px',
                                                fontSize: '12px',
                                                pointerEvents: 'none',
                                                zIndex: 100,
                                                minWidth: '180px'
                                            }
                                        },
                                            e('div', { style: { fontWeight: 'bold', marginBottom: '4px' }}, pd.player),
                                            e('div', { style: { color: '#94a3b8', fontSize: '11px' }}, pd.team),
                                            e('div', { style: { marginTop: '6px', fontSize: '11px' }},
                                                e('span', { style: { color: '#60a5fa' }}, xStatOpt.label),
                                                !xStatOpt.higherBetter && e('span', { style: { color: '#f87171', fontSize: '9px' }}, ' ↓'),
                                                e('span', { style: { color: '#60a5fa' }}, ': '),
                                                e('span', { style: { color: xColor }}, 
                                                    (pd.x >= 0 ? '+' : '') + pd.x.toFixed(2)
                                                )
                                            ),
                                            e('div', { style: { fontSize: '11px' }},
                                                e('span', { style: { color: '#a78bfa' }}, yStatOpt.label),
                                                !yStatOpt.higherBetter && e('span', { style: { color: '#f87171', fontSize: '9px' }}, ' ↓'),
                                                e('span', { style: { color: '#a78bfa' }}, ': '),
                                                e('span', { style: { color: yColor }}, 
                                                    (pd.y >= 0 ? '+' : '') + pd.y.toFixed(2)
                                                )
                                            ),
                                            e('div', { style: { fontSize: '10px', color: '#64748b', marginTop: '4px' }}, 
                                                '⏱️ ' + pd.minutes.toFixed(1) + ' min'
                                            )
                                        );
                                    })()
                                );
                            })()
                        ),
                        
                        // V5.14: BPM Impact Combos View - Special rendering for two-player combinations
                        lbSubtab === 'onoff' && lbViewMode === 'table' && (lbStat === 'bpmImpactCombos' || lbStat === 'bpmImpactZScore') && (() => {
                            // Helper to get surname with suffix (e.g., "Mitchell Jr." not just "Jr.")
                            const suffixes = ['Jr', 'Jr.', 'III', 'IV', 'V', 'II', 'Sr', 'Sr.', 'Iii', 'Ii', 'Iv'];
                            const getSurnameOnly = (name) => {
                                const cleanName = (name || '').split(',')[0].trim();
                                const parts = cleanName.split(' ').filter(p => p.length > 0);
                                if (parts.length === 0) return name;
                                if (parts.length === 1) return parts[0];
                                const lastWord = parts[parts.length - 1];
                                if (suffixes.some(s => s.toLowerCase() === lastWord.toLowerCase())) {
                                    return parts.length >= 2 ? parts.slice(-2).join(' ') : lastWord;
                                }
                                return lastWord;
                            };

                            // Build map of players per team to detect duplicate surnames
                            const teamPlayersMap = {};
                            lineupData.forEach(l => {
                                const team = l.Team || '';
                                const players = (l.Lineup || '').split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                                if (!teamPlayersMap[team]) teamPlayersMap[team] = new Set();
                                players.forEach(p => teamPlayersMap[team].add(p));
                            });

                            // Check if surname is duplicated within team
                            // Get players with same surname on team
                            const getPlayersWithSameSurname = (name, team) => {
                                const surname = getSurnameOnly(name).toLowerCase();
                                const teamPlayers = teamPlayersMap[team] || new Set();
                                const matches = [];
                                teamPlayers.forEach(p => {
                                    if (getSurnameOnly(p).toLowerCase() === surname) matches.push(p);
                                });
                                return matches;
                            };

                            // Get display name with minimum prefix to disambiguate
                            const getDisplayName = (name, team) => {
                                const cleanName = (name || '').split(',')[0].trim();
                                const parts = cleanName.split(' ').filter(p => p.length > 0);
                                const surname = getSurnameOnly(name);
                                if (parts.length <= 1) return surname;

                                const sameNamePlayers = getPlayersWithSameSurname(name, team);
                                if (sameNamePlayers.length <= 1) return surname;

                                // Get first names of all players with same surname
                                const firstName = parts[0];
                                const otherFirstNames = sameNamePlayers
                                    .filter(p => p !== name)
                                    .map(p => (p.split(',')[0].trim().split(' ').filter(x => x.length > 0)[0] || '').toLowerCase());

                                // Find minimum prefix length to disambiguate
                                let prefixLen = 1;
                                const firstNameLower = firstName.toLowerCase();
                                while (prefixLen < firstName.length) {
                                    const prefix = firstNameLower.slice(0, prefixLen);
                                    const hasConflict = otherFirstNames.some(fn => fn.slice(0, prefixLen) === prefix);
                                    if (!hasConflict) break;
                                    prefixLen++;
                                }

                                return firstName.slice(0, prefixLen) + '. ' + surname;
                            };

                            // V5.21: BPM 2.0 coefficients from hackastat.eu using percentage-based stats
                            const BPM_COEFFS = {
                                a: 0.123391, b: 0.119597, c: -0.151287, d: 1.255644,
                                e: 0.531838, f: -0.305868, g: 0.921292, h: 0.711217,
                                i: 0.017022, j: 0.297639, k: 0.213485, l: 0.725930
                            };
                            const OBPM_COEFFS = {
                                a: 0.064448, b: 0.211125, c: -0.107545, d: 0.346513,
                                e: -0.052476, f: -0.041787, g: 0.932965, h: 0.687359,
                                i: 0.007952, j: 0.374706, k: -0.181891, l: 0.239862
                            };
                            const lgAvg3PAr = 0.40;

                            // Calculate BPM for all two-player combinations from lineup data
                            const calcPoss = (fga, oreb, tov, fta) => fga - oreb + tov + 0.44 * fta;
                            const teamCombos = {};

                            // Get lineups for selected team (or all teams)
                            const relevantLineups = lineupData.filter(l => lbTeam === '' || l.Team === lbTeam);

                            // Process each lineup to extract two-player combinations and track lineups
                            relevantLineups.forEach(l => {
                                const players = (l.Lineup || '').split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                                const team = l.Team || '';
                                const mins = (parseFloat(l.MIN) || (parseFloat(l.TOTAL_TIME) || 0) / 60);
                                const fga = parseFloat(l.FGA) || 0, oreb = parseFloat(l.OREB) || 0, tov = parseFloat(l.TOV) || 0, fta = parseFloat(l.FTA) || 0;
                                const fgaV = parseFloat(l.FGA_VS) || 0, orebV = parseFloat(l.OREB_VS) || 0, tovV = parseFloat(l.TOV_VS) || 0, ftaV = parseFloat(l.FTA_VS) || 0;
                                const poss = calcPoss(fga, oreb, tov, fta);
                                const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                                const fgm = parseFloat(l.FGM) || 0, tpm = parseFloat(l['3PM']) || 0, ftm = parseFloat(l.FTM) || 0;
                                const fgmV = parseFloat(l.FGM_VS) || 0, tpmV = parseFloat(l['3PM_VS']) || 0, ftmV = parseFloat(l.FTM_VS) || 0;
                                const pts = fgm * 2 + tpm + ftm;
                                const ptsV = fgmV * 2 + tpmV + ftmV;
                                const dreb = parseFloat(l.DREB) || 0, drebV = parseFloat(l.DREB_VS) || 0;

                                // For each pair of players
                                for (let i = 0; i < players.length; i++) {
                                    for (let j = i + 1; j < players.length; j++) {
                                        const p1 = players[i], p2 = players[j];
                                        const comboKey = [p1, p2].sort().join('|||');
                                        if (!teamCombos[team]) teamCombos[team] = {};
                                        if (!teamCombos[team][comboKey]) {
                                            teamCombos[team][comboKey] = { p1, p2, team, mins: 0, poss: 0, possV: 0, pts: 0, ptsV: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, tov: 0, stl: 0, blk: 0, ast: 0, fgmV: 0, fgaV: 0, tpmV: 0, orebV: 0, drebV: 0, tovV: 0, lineups: [] };
                                        }
                                        const c = teamCombos[team][comboKey];
                                        c.mins += mins;
                                        c.poss += poss; c.possV += possV;
                                        c.pts += pts; c.ptsV += ptsV;
                                        c.fgm += fgm; c.fga += fga;
                                        c.tpm += tpm; c.tpa += parseFloat(l['3PA']) || 0;
                                        c.ftm += ftm; c.fta += fta;
                                        c.oreb += oreb; c.dreb += dreb; c.tov += tov;
                                        c.stl += parseFloat(l.STL) || 0; c.blk += parseFloat(l.BLK) || 0; c.ast += parseFloat(l.AST) || 0;
                                        c.fgmV += fgmV; c.fgaV += fgaV; c.tpmV += tpmV;
                                        c.orebV += orebV; c.drebV += drebV; c.tovV += tovV;
                                        c.lineups.push(l.Lineup); // Track lineups for player stats lookup
                                    }
                                }
                            });

                            // V5.19: Helper to normalize lineup string for matching
                            const normalizeLineupStr = (lineup) => {
                                if (!lineup) return '';
                                return lineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',');
                            };

                            // V5.19: Helper to construct full lineup from Player + Teammates columns
                            const getFullLineupFromPd = (pd) => {
                                const player = pd.Player || '';
                                const teammates = pd.Teammates || '';
                                if (!player || !teammates) return '';
                                return player + ',' + teammates;
                            };

                            // V5.21: Helper to get individual player box stats with lineup context for BPM 2.0
                            const getPlayerComboStats = (player, team, lineupStrings, comboData) => {
                                if (!playerData.length) return null;
                                const playerNorm = normalizePlayerName(player);
                                const uniqueLineups = [...new Set(lineupStrings)];
                                const normalizedLineupSet = new Set(uniqueLineups.map(l => normalizeLineupStr(l)));

                                // Find rows matching player, team, and lineup
                                const relevantPlayerRows = playerData.filter(pd => {
                                    if (!pd.Player) return false;
                                    const pdNorm = normalizePlayerName(pd.Player);
                                    if (pdNorm !== playerNorm) return false;
                                    if (pd.Team !== team) return false;
                                    const fullLineup = getFullLineupFromPd(pd);
                                    const pdLineupNorm = normalizeLineupStr(fullLineup);
                                    return normalizedLineupSet.has(pdLineupNorm);
                                });

                                if (!relevantPlayerRows.length) return null;

                                // V5.21: Get ALL players' stats for matching lineups (for team context)
                                const allPlayersInLineups = playerData.filter(pd => {
                                    if (!pd.Player || pd.Team !== team) return false;
                                    const fullLineup = getFullLineupFromPd(pd);
                                    const pdLineupNorm = normalizeLineupStr(fullLineup);
                                    return normalizedLineupSet.has(pdLineupNorm);
                                });
                                const teamFgm = allPlayersInLineups.reduce((sum, pd) => sum + (parseFloat(pd.FGM) || 0), 0);

                                // V5.21: Build lineup totals from combo data for BPM 2.0 percentage denominators
                                const lineupTotals = {
                                    fga: comboData.fga, fgm: comboData.fgm, oreb: comboData.oreb, dreb: comboData.dreb,
                                    tov: comboData.tov, fta: comboData.fta, poss: comboData.poss, possV: comboData.possV,
                                    orebV: comboData.orebV, drebV: comboData.drebV, fgaV: comboData.fgaV, mins: comboData.mins
                                };

                                const playerStats = relevantPlayerRows.reduce((acc, pd) => ({
                                    pts: acc.pts + (parseFloat(pd.PTS) || 0),
                                    fga: acc.fga + (parseFloat(pd.FGA) || 0),
                                    fgm: acc.fgm + (parseFloat(pd.FGM) || 0),
                                    tpa: acc.tpa + (parseFloat(pd['3PA']) || 0),
                                    tpm: acc.tpm + (parseFloat(pd['3PM']) || 0),
                                    fta: acc.fta + (parseFloat(pd.FTA) || 0),
                                    ftm: acc.ftm + (parseFloat(pd.FTM) || 0),
                                    oreb: acc.oreb + (parseFloat(pd.OREB) || 0),
                                    dreb: acc.dreb + (parseFloat(pd.DREB) || 0),
                                    ast: acc.ast + (parseFloat(pd.AST) || 0),
                                    stl: acc.stl + (parseFloat(pd.STL) || 0),
                                    blk: acc.blk + (parseFloat(pd.BLK) || 0),
                                    tov: acc.tov + (parseFloat(pd.TOV) || 0),
                                    mins: acc.mins + (parseFloat(pd.Minutes) || parseFloat(pd.MIN) || 0),
                                    gp: acc.gp + 1
                                }), { pts: 0, fga: 0, fgm: 0, tpa: 0, tpm: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, mins: 0, gp: 0 });

                                return { ...playerStats, lineupTotals, teamFgm };
                            };

                            // V5.21: Calculate BPM 2.0 using percentage-based stats from hackastat.eu
                            const calcMyersBpm = (pStats) => {
                                if (!pStats || !pStats.lineupTotals) return null;
                                const lt = pStats.lineupTotals;
                                if (lt.poss < 1 || lt.mins < 0.1) return null;

                                const reMpg = pStats.mins / (pStats.gp + 2);
                                const orebOpps = lt.oreb + lt.drebV;
                                const orbPct = orebOpps > 0 ? (pStats.oreb / orebOpps) * 100 : 0;
                                const drebOpps = lt.dreb + lt.orebV;
                                const drbPct = drebOpps > 0 ? (pStats.dreb / drebOpps) * 100 : 0;
                                const trbPct = (orebOpps + drebOpps) > 0 ? ((pStats.oreb + pStats.dreb) / (orebOpps + drebOpps)) * 100 : 0;
                                const stlPct = lt.possV > 0 ? (pStats.stl / lt.possV) * 100 : 0;
                                const opp2pa = lt.fgaV * 0.6;
                                const blkPct = opp2pa > 0 ? (pStats.blk / opp2pa) * 100 : 0;
                                const tmFgmExcludingSelf = pStats.teamFgm - pStats.fgm;
                                const astPct = tmFgmExcludingSelf > 0 ? (pStats.ast / tmFgmExcludingSelf) * 100 : 0;
                                const playerPossUsed = pStats.fga + 0.44 * pStats.fta + pStats.tov;
                                const usgPct = lt.poss > 0 ? (playerPossUsed / lt.poss) * 100 : 0;
                                const tovPct = playerPossUsed > 0 ? (pStats.tov / playerPossUsed) * 100 : 0;
                                const tsa = 2 * (pStats.fga + 0.44 * pStats.fta);
                                const tsPct = tsa > 0 ? (pStats.pts / tsa) * 100 : 0;
                                const teamTsa = 2 * (lt.fga + 0.44 * lt.fta);
                                const teamTsPct = teamTsa > 0 ? ((lt.fgm * 2 + (lt.fga > 0 ? (lt.fgm / lt.fga) * lt.fga * 0.5 : 0)) / teamTsa) * 100 : 50;
                                const threePAr = pStats.fga > 0 ? pStats.tpa / pStats.fga : 0;

                                const term1 = BPM_COEFFS.a * reMpg;
                                const term2 = BPM_COEFFS.b * orbPct;
                                const term3 = BPM_COEFFS.c * drbPct;
                                const term4 = BPM_COEFFS.d * stlPct;
                                const term5 = BPM_COEFFS.e * blkPct;
                                const term6 = BPM_COEFFS.f * astPct;
                                const term7 = -BPM_COEFFS.g * (usgPct / 100) * tovPct;
                                const scoringTerm = BPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                                    (2 * (tsPct - teamTsPct) / 100 + BPM_COEFFS.i * astPct / 100 + BPM_COEFFS.j * (threePAr - lgAvg3PAr) - BPM_COEFFS.k);
                                const term9 = BPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;
                                const rawBpm = term1 + term2 + term3 + term4 + term5 + term6 + term7 + scoringTerm + term9;

                                const oTerm1 = OBPM_COEFFS.a * reMpg;
                                const oTerm2 = OBPM_COEFFS.b * orbPct;
                                const oTerm3 = OBPM_COEFFS.c * drbPct;
                                const oTerm4 = OBPM_COEFFS.d * stlPct;
                                const oTerm5 = OBPM_COEFFS.e * blkPct;
                                const oTerm6 = OBPM_COEFFS.f * astPct;
                                const oTerm7 = -OBPM_COEFFS.g * (usgPct / 100) * tovPct;
                                const oScoringTerm = OBPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                                    (2 * (tsPct - teamTsPct) / 100 + OBPM_COEFFS.i * astPct / 100 + OBPM_COEFFS.j * (threePAr - lgAvg3PAr) - OBPM_COEFFS.k);
                                const oTerm9 = OBPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;
                                const rawObpm = oTerm1 + oTerm2 + oTerm3 + oTerm4 + oTerm5 + oTerm6 + oTerm7 + oScoringTerm + oTerm9;

                                return { bpm: rawBpm, obpm: rawObpm, dbpm: rawBpm - rawObpm };
                            };

                            // V5.21: Helper to get player stats when NOT playing with a specific teammate with lineup context
                            const getPlayerSoloStats = (player, team, excludeTeammate) => {
                                if (!playerData.length) return null;
                                const playerNorm = normalizePlayerName(player);
                                const teammateNorm = normalizePlayerName(excludeTeammate);

                                // Find all lineups where player is ON but teammate is OFF
                                const soloLineups = relevantLineups.filter(l => {
                                    if (l.Team !== team) return false;
                                    const lineupPlayers = (l.Lineup || '').split(',').map(p => p.trim());
                                    const lineupNorm = lineupPlayers.map(p => normalizePlayerName(p));
                                    return lineupNorm.includes(playerNorm) && !lineupNorm.includes(teammateNorm);
                                });

                                if (!soloLineups.length) return null;

                                // V5.21: Calculate lineup totals for BPM 2.0 percentage denominators
                                const lineupTotals = soloLineups.reduce((acc, l) => {
                                    const fga = parseFloat(l.FGA) || 0, oreb = parseFloat(l.OREB) || 0;
                                    const dreb = parseFloat(l.DREB) || 0, tov = parseFloat(l.TOV) || 0, fta = parseFloat(l.FTA) || 0;
                                    const fgm = parseFloat(l.FGM) || 0;
                                    const fgaV = parseFloat(l.FGA_VS) || 0, orebV = parseFloat(l.OREB_VS) || 0;
                                    const drebV = parseFloat(l.DREB_VS) || 0;
                                    const poss = parseFloat(l.POSS) || calcPoss(fga, oreb, tov, fta);
                                    const possV = parseFloat(l.POSS_VS) || calcPoss(fgaV, orebV, parseFloat(l.TOV_VS) || 0, parseFloat(l.FTA_VS) || 0);
                                    return {
                                        fga: acc.fga + fga, fgm: acc.fgm + fgm, oreb: acc.oreb + oreb, dreb: acc.dreb + dreb,
                                        tov: acc.tov + tov, fta: acc.fta + fta, poss: acc.poss + poss, possV: acc.possV + possV,
                                        orebV: acc.orebV + orebV, drebV: acc.drebV + drebV, fgaV: acc.fgaV + fgaV,
                                        mins: acc.mins + (parseFloat(l.TOTAL_TIME) || 0) / 60
                                    };
                                }, { fga: 0, fgm: 0, oreb: 0, dreb: 0, tov: 0, fta: 0, poss: 0, possV: 0, orebV: 0, drebV: 0, fgaV: 0, mins: 0 });

                                const normalizedSoloLineupSet = new Set(soloLineups.map(l => normalizeLineupStr(l.Lineup)));

                                // V5.21: Get ALL players' stats for these lineups (for team FGM)
                                const allPlayersInLineups = playerData.filter(pd => {
                                    if (!pd.Player || pd.Team !== team) return false;
                                    const fullLineup = getFullLineupFromPd(pd);
                                    return normalizedSoloLineupSet.has(normalizeLineupStr(fullLineup));
                                });
                                const teamFgm = allPlayersInLineups.reduce((sum, pd) => sum + (parseFloat(pd.FGM) || 0), 0);

                                const relevantPlayerRows = playerData.filter(pd => {
                                    if (!pd.Player) return false;
                                    const pdNorm = normalizePlayerName(pd.Player);
                                    if (pdNorm !== playerNorm || pd.Team !== team) return false;
                                    const fullLineup = getFullLineupFromPd(pd);
                                    return normalizedSoloLineupSet.has(normalizeLineupStr(fullLineup));
                                });

                                if (!relevantPlayerRows.length) return null;

                                const playerStats = relevantPlayerRows.reduce((acc, pd) => ({
                                    pts: acc.pts + (parseFloat(pd.PTS) || 0),
                                    fga: acc.fga + (parseFloat(pd.FGA) || 0),
                                    fgm: acc.fgm + (parseFloat(pd.FGM) || 0),
                                    tpa: acc.tpa + (parseFloat(pd['3PA']) || 0),
                                    tpm: acc.tpm + (parseFloat(pd['3PM']) || 0),
                                    fta: acc.fta + (parseFloat(pd.FTA) || 0),
                                    ftm: acc.ftm + (parseFloat(pd.FTM) || 0),
                                    oreb: acc.oreb + (parseFloat(pd.OREB) || 0),
                                    dreb: acc.dreb + (parseFloat(pd.DREB) || 0),
                                    ast: acc.ast + (parseFloat(pd.AST) || 0),
                                    stl: acc.stl + (parseFloat(pd.STL) || 0),
                                    blk: acc.blk + (parseFloat(pd.BLK) || 0),
                                    tov: acc.tov + (parseFloat(pd.TOV) || 0),
                                    mins: acc.mins + (parseFloat(pd.Minutes) || parseFloat(pd.MIN) || 0),
                                    gp: acc.gp + 1
                                }), { pts: 0, fga: 0, fgm: 0, tpa: 0, tpm: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, mins: 0, gp: 0 });

                                return { ...playerStats, lineupTotals, teamFgm };
                            };

                            // Convert to array and calculate BPM DELTA (together - apart)
                            const allCombos = [];
                            Object.entries(teamCombos).forEach(([team, combos]) => {
                                Object.values(combos).forEach(c => {
                                    if (c.mins < lbMinMins) return; // Filter by minimum minutes together
                                    const avgPoss = (c.poss + c.possV) / 2;
                                    if (avgPoss < 1) return;

                                    // Calculate ratings for context
                                    const offRtg = c.poss > 0 ? (c.pts / c.poss) * 100 : 100;
                                    const defRtg = c.possV > 0 ? (c.ptsV / c.possV) * 100 : 100;
                                    const netRtg = offRtg - defRtg;

                                    // V5.21: Get individual player stats when TOGETHER with lineup context for BPM 2.0
                                    const p1StatsTogether = getPlayerComboStats(c.p1, team, c.lineups, c);
                                    const p2StatsTogether = getPlayerComboStats(c.p2, team, c.lineups, c);

                                    // Get individual player stats when APART (playing without each other)
                                    const p1StatsApart = getPlayerSoloStats(c.p1, team, c.p2);
                                    const p2StatsApart = getPlayerSoloStats(c.p2, team, c.p1);

                                    // V5.17: Calculate BPM delta for P1 specifically (P1's BPM with P2 - P1's BPM without P2)
                                    // This measures the impact of P2 on P1's production
                                    // NO FALLBACK - returns null if player_lineup_stats_enhanced not available
                                    let bpm = null, obpm = null, dbpm = null;

                                    if (p1StatsTogether) {
                                        // Calculate P1's BPM when playing WITH P2
                                        const p1BpmTogether = calcMyersBpm(p1StatsTogether);

                                        if (p1BpmTogether) {
                                            // Calculate P1's BPM when playing WITHOUT P2
                                            const p1BpmApart = p1StatsApart ? calcMyersBpm(p1StatsApart) : null;

                                            if (p1BpmApart) {
                                                // BPM DELTA = P1's BPM with P2 - P1's BPM without P2
                                                bpm = p1BpmTogether.bpm - p1BpmApart.bpm;
                                                obpm = p1BpmTogether.obpm - p1BpmApart.obpm;
                                                dbpm = p1BpmTogether.dbpm - p1BpmApart.dbpm;
                                            }
                                            // V5.17: If no apart data, BPM stays null (no fallback)
                                        }
                                    }
                                    // V5.17: No Four Factors fallback - BPM will be null if Myers method fails

                                    allCombos.push({
                                        p1: c.p1, p2: c.p2, team,
                                        mins: c.mins, poss: avgPoss,
                                        offRtg, defRtg, netRtg,
                                        bpm, obpm, dbpm
                                    });
                                });
                            });

                            // Calculate Z-Score for BPM Impact
                            const validBpmDeltas = allCombos.filter(c => c.bpm !== null).map(c => c.bpm);
                            const meanDelta = validBpmDeltas.length > 0 ? validBpmDeltas.reduce((a, b) => a + b, 0) / validBpmDeltas.length : 0;
                            const variance = validBpmDeltas.length > 0 ? validBpmDeltas.reduce((sum, v) => sum + Math.pow(v - meanDelta, 2), 0) / validBpmDeltas.length : 0;
                            const stdDevDelta = Math.sqrt(variance);

                            // Add Z-Score to each combo
                            allCombos.forEach(c => {
                                c.zScore = c.bpm !== null && stdDevDelta > 0.01 ? (c.bpm - meanDelta) / stdDevDelta : null;
                            });

                            // Sort based on view mode
                            if (lbStat === 'bpmImpactZScore') {
                                // Sort by Z-Score ascending (most negative first)
                                allCombos.sort((a, b) => {
                                    if (a.zScore !== null && b.zScore !== null) return a.zScore - b.zScore;
                                    if (a.zScore !== null) return -1;
                                    if (b.zScore !== null) return 1;
                                    return b.netRtg - a.netRtg;
                                });
                            } else {
                                // V5.18: Sort by BPM (descending), fall back to netRtg when BPM is null
                                allCombos.sort((a, b) => {
                                    if (a.bpm !== null && b.bpm !== null) return b.bpm - a.bpm;
                                    if (a.bpm !== null && b.bpm === null) return -1;
                                    if (a.bpm === null && b.bpm !== null) return 1;
                                    return b.netRtg - a.netRtg;
                                });
                            }
                            const displayCombos = lbShowAll ? allCombos : allCombos.slice(0, 50);

                            const getBpmColor = (bpm) => {
                                if (bpm === null) return '#64748b';
                                if (bpm >= 3) return '#22c55e';
                                if (bpm >= 1) return '#4ade80';
                                if (bpm >= -1) return '#94a3b8';
                                if (bpm >= -3) return '#fb923c';
                                return '#ef4444';
                            };

                            const getZScoreColor = (z) => {
                                if (z === null) return '#64748b';
                                if (z <= -2) return '#ef4444';  // Very negative impact
                                if (z <= -1) return '#fb923c';
                                if (z <= 1) return '#94a3b8';
                                if (z <= 2) return '#4ade80';
                                return '#22c55e';  // Very positive impact
                            };

                            return e('div', null,
                                e('p', { style: { fontSize: '11px', opacity: 0.7, marginBottom: '12px' }},
                                    lbStat === 'bpmImpactZScore'
                                        ? 'Showing ' + displayCombos.length + ' combinations sorted by Z-Score (most negative impact first). Negative Z-Score = teammate HURTS player\'s BPM.'
                                        : 'Showing ' + displayCombos.length + ' of ' + allCombos.length + ' two-player combinations with ' + lbMinMins + '+ minutes together. ',
                                    lbStat !== 'bpmImpactZScore' && 'BPM shows P1\'s delta (with teammate - without teammate). Format: Player A w/ Player B'
                                ),
                                e('div', { style: { overflowX: 'auto', maxHeight: lbShowAll ? '800px' : '500px', overflowY: 'auto' }},
                                    e('table', null,
                                        e('thead', { style: { position: 'sticky', top: 0, background: '#1e293b', zIndex: 1 }},
                                            e('tr', null,
                                                e('th', null, '#'),
                                                e('th', { style: { minWidth: '200px' }}, 'Combination'),
                                                e('th', null, 'Team'),
                                                e('th', { style: { textAlign: 'right', color: '#60a5fa' }}, 'BPM Δ'),
                                                lbStat === 'bpmImpactZScore' && e('th', { style: { textAlign: 'right', color: '#f59e0b' }}, 'Z-Score'),
                                                e('th', { style: { textAlign: 'right', color: '#4ade80' }}, 'OBPM'),
                                                e('th', { style: { textAlign: 'right', color: '#f87171' }}, 'DBPM'),
                                                e('th', { style: { textAlign: 'right' }}, 'Net Rtg'),
                                                e('th', { style: { textAlign: 'right' }}, 'Mins')
                                            )
                                        ),
                                        e('tbody', null,
                                            displayCombos.map((c, i) => {
                                                return e('tr', { key: i, style: lbStat === 'bpmImpactZScore' && c.zScore !== null && c.zScore <= -1.5 ? { background: 'rgba(239, 68, 68, 0.15)' } : {} },
                                                    e('td', { style: { opacity: 0.6 }}, i + 1),
                                                    e('td', { style: { fontWeight: '600' }},
                                                        e('span', { style: { color: '#60a5fa' }}, getDisplayName(c.p1, c.team)),
                                                        e('span', { style: { color: '#94a3b8', margin: '0 4px' }}, 'w/'),
                                                        e('span', { style: { color: '#a78bfa' }}, getDisplayName(c.p2, c.team))
                                                    ),
                                                    e('td', { style: { fontSize: '11px', opacity: 0.8 }}, c.team.length > 10 ? c.team.slice(0, 8) + '..' : c.team),
                                                    e('td', { style: { textAlign: 'right', fontWeight: 'bold', color: getBpmColor(c.bpm) }}, c.bpm === null ? 'N/A' : (c.bpm >= 0 ? '+' : '') + c.bpm.toFixed(1)),
                                                    lbStat === 'bpmImpactZScore' && e('td', { style: { textAlign: 'right', fontWeight: 'bold', color: getZScoreColor(c.zScore) }},
                                                        c.zScore === null ? 'N/A' : (c.zScore >= 0 ? '+' : '') + c.zScore.toFixed(2)),
                                                    e('td', { style: { textAlign: 'right', color: c.obpm === null ? '#64748b' : c.obpm >= 0 ? '#4ade80' : '#f87171' }}, c.obpm === null ? 'N/A' : (c.obpm >= 0 ? '+' : '') + c.obpm.toFixed(1)),
                                                    e('td', { style: { textAlign: 'right', color: c.dbpm === null ? '#64748b' : c.dbpm >= 0 ? '#4ade80' : '#f87171' }}, c.dbpm === null ? 'N/A' : (c.dbpm >= 0 ? '+' : '') + c.dbpm.toFixed(1)),
                                                    e('td', { style: { textAlign: 'right', color: c.netRtg >= 0 ? '#4ade80' : '#f87171' }}, (c.netRtg >= 0 ? '+' : '') + c.netRtg.toFixed(1)),
                                                    e('td', { style: { textAlign: 'right', fontSize: '11px', opacity: 0.7 }}, c.mins.toFixed(1))
                                                );
                                            })
                                        )
                                    )
                                ),
                                allCombos.length > 50 && e('div', { style: { textAlign: 'center', marginTop: '16px' }},
                                    e('button', {
                                        className: 'btn',
                                        style: {
                                            background: lbShowAll ? 'rgba(100, 116, 139, 0.3)' : 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                                            padding: '10px 24px',
                                            fontSize: '13px',
                                            fontWeight: '600'
                                        },
                                        onClick: () => setLbShowAll(!lbShowAll)
                                    }, lbShowAll ? 'Show Top 50 Only' : 'Show All ' + allCombos.length + ' Combinations')
                                )
                            );
                        })(),

                        // V5.22: PER Impact Combos View - Special rendering for two-player combinations using PER
                        lbSubtab === 'onoff' && lbViewMode === 'table' && (lbStat === 'perImpactCombos' || lbStat === 'perImpactZScore') && (() => {
                            // Helper to get surname with suffix
                            const suffixes = ['Jr', 'Jr.', 'III', 'IV', 'V', 'II', 'Sr', 'Sr.', 'Iii', 'Ii', 'Iv'];
                            const getSurnameOnly = (name) => {
                                const cleanName = (name || '').split(',')[0].trim();
                                const parts = cleanName.split(' ').filter(p => p.length > 0);
                                if (parts.length === 0) return name;
                                if (parts.length === 1) return parts[0];
                                const lastWord = parts[parts.length - 1];
                                if (suffixes.some(s => s.toLowerCase() === lastWord.toLowerCase())) {
                                    return parts.length >= 2 ? parts.slice(-2).join(' ') : lastWord;
                                }
                                return lastWord;
                            };

                            // Build map of players per team
                            const teamPlayersMap = {};
                            lineupData.forEach(l => {
                                const team = l.Team || '';
                                const players = (l.Lineup || '').split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                                if (!teamPlayersMap[team]) teamPlayersMap[team] = new Set();
                                players.forEach(p => teamPlayersMap[team].add(p));
                            });

                            const getPlayersWithSameSurname = (name, team) => {
                                const surname = getSurnameOnly(name).toLowerCase();
                                const teamPlayers = teamPlayersMap[team] || new Set();
                                const matches = [];
                                teamPlayers.forEach(p => {
                                    if (getSurnameOnly(p).toLowerCase() === surname) matches.push(p);
                                });
                                return matches;
                            };

                            const getDisplayName = (name, team) => {
                                const cleanName = (name || '').split(',')[0].trim();
                                const parts = cleanName.split(' ').filter(p => p.length > 0);
                                const surname = getSurnameOnly(name);
                                if (parts.length <= 1) return surname;
                                const sameNamePlayers = getPlayersWithSameSurname(name, team);
                                if (sameNamePlayers.length <= 1) return surname;
                                const firstName = parts[0];
                                const otherFirstNames = sameNamePlayers
                                    .filter(p => p !== name)
                                    .map(p => (p.split(',')[0].trim().split(' ').filter(x => x.length > 0)[0] || '').toLowerCase());
                                let prefixLen = 1;
                                const firstNameLower = firstName.toLowerCase();
                                while (prefixLen < firstName.length) {
                                    const prefix = firstNameLower.slice(0, prefixLen);
                                    const hasConflict = otherFirstNames.some(fn => fn.slice(0, prefixLen) === prefix);
                                    if (!hasConflict) break;
                                    prefixLen++;
                                }
                                return firstName.slice(0, prefixLen) + '. ' + surname;
                            };

                            // V5.22: PER calculation function using Hollinger's formula
                            // Simplified PER = (PTS + REB + AST + STL + BLK - Missed FG - Missed FT - TOV) / Mins * PACE_FACTOR
                            const calcPER = (pStats, lineupTotals) => {
                                if (!pStats || pStats.mins < 0.1) return null;
                                const lt = lineupTotals || {};

                                // Calculate team pace factor (possessions per 48 mins)
                                const teamPace = lt.mins > 0 ? ((lt.poss || 0) / lt.mins) * 48 : 100;
                                const leagueAvgPace = 100;
                                const paceFactor = leagueAvgPace / Math.max(teamPace, 50);

                                // PER components
                                const pts = pStats.pts || 0;
                                const reb = (pStats.oreb || 0) + (pStats.dreb || 0);
                                const ast = pStats.ast || 0;
                                const stl = pStats.stl || 0;
                                const blk = pStats.blk || 0;
                                const missedFg = (pStats.fga || 0) - (pStats.fgm || 0);
                                const missedFt = (pStats.fta || 0) - (pStats.ftm || 0);
                                const tov = pStats.tov || 0;

                                // Simplified PER formula
                                const rawPER = pStats.mins > 0 ?
                                    ((pts + reb + ast * 1.5 + stl * 2 + blk * 2 - missedFg - missedFt * 0.5 - tov * 1.5) / pStats.mins) * 15 * paceFactor : 0;

                                return rawPER;
                            };

                            // Calculate PER for all two-player combinations
                            const calcPoss = (fga, oreb, tov, fta) => fga - oreb + tov + 0.44 * fta;
                            const teamCombos = {};
                            const relevantLineups = lineupData.filter(l => lbTeam === '' || l.Team === lbTeam);

                            // Process each lineup to extract two-player combinations
                            relevantLineups.forEach(l => {
                                const players = (l.Lineup || '').split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                                const team = l.Team || '';
                                const mins = (parseFloat(l.MIN) || (parseFloat(l.TOTAL_TIME) || 0) / 60);
                                const fga = parseFloat(l.FGA) || 0, oreb = parseFloat(l.OREB) || 0, tov = parseFloat(l.TOV) || 0, fta = parseFloat(l.FTA) || 0;
                                const fgaV = parseFloat(l.FGA_VS) || 0, orebV = parseFloat(l.OREB_VS) || 0, tovV = parseFloat(l.TOV_VS) || 0, ftaV = parseFloat(l.FTA_VS) || 0;
                                const poss = calcPoss(fga, oreb, tov, fta);
                                const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                                const fgm = parseFloat(l.FGM) || 0, tpm = parseFloat(l['3PM']) || 0, ftm = parseFloat(l.FTM) || 0;
                                const fgmV = parseFloat(l.FGM_VS) || 0, tpmV = parseFloat(l['3PM_VS']) || 0, ftmV = parseFloat(l.FTM_VS) || 0;
                                const pts = fgm * 2 + tpm + ftm;
                                const ptsV = fgmV * 2 + tpmV + ftmV;
                                const dreb = parseFloat(l.DREB) || 0;

                                for (let i = 0; i < players.length; i++) {
                                    for (let j = i + 1; j < players.length; j++) {
                                        const p1 = players[i], p2 = players[j];
                                        const comboKey = [p1, p2].sort().join('|||');
                                        if (!teamCombos[team]) teamCombos[team] = {};
                                        if (!teamCombos[team][comboKey]) {
                                            teamCombos[team][comboKey] = { p1, p2, team, mins: 0, poss: 0, possV: 0, pts: 0, ptsV: 0, lineups: [] };
                                        }
                                        const c = teamCombos[team][comboKey];
                                        c.mins += mins;
                                        c.poss += poss; c.possV += possV;
                                        c.pts += pts; c.ptsV += ptsV;
                                        c.lineups.push(l.Lineup);
                                    }
                                }
                            });

                            // Helper to normalize lineup string
                            const normalizeLineupStr = (lineup) => {
                                if (!lineup) return '';
                                return lineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',');
                            };

                            const getFullLineupFromPd = (pd) => {
                                const player = pd.Player || '';
                                const teammates = pd.Teammates || '';
                                if (!player || !teammates) return '';
                                return player + ',' + teammates;
                            };

                            // Get player stats for combo
                            const getPlayerComboStatsForPER = (player, team, lineupStrings) => {
                                if (!playerData.length) return null;
                                const playerNorm = normalizePlayerName(player);
                                const uniqueLineups = [...new Set(lineupStrings)];
                                const normalizedLineupSet = new Set(uniqueLineups.map(l => normalizeLineupStr(l)));

                                const relevantPlayerRows = playerData.filter(pd => {
                                    if (!pd.Player) return false;
                                    const pdNorm = normalizePlayerName(pd.Player);
                                    if (pdNorm !== playerNorm) return false;
                                    if (pd.Team !== team) return false;
                                    const fullLineup = getFullLineupFromPd(pd);
                                    const pdLineupNorm = normalizeLineupStr(fullLineup);
                                    return normalizedLineupSet.has(pdLineupNorm);
                                });

                                if (!relevantPlayerRows.length) return null;

                                return relevantPlayerRows.reduce((acc, pd) => ({
                                    pts: acc.pts + (parseFloat(pd.PTS) || 0),
                                    fga: acc.fga + (parseFloat(pd.FGA) || 0),
                                    fgm: acc.fgm + (parseFloat(pd.FGM) || 0),
                                    fta: acc.fta + (parseFloat(pd.FTA) || 0),
                                    ftm: acc.ftm + (parseFloat(pd.FTM) || 0),
                                    oreb: acc.oreb + (parseFloat(pd.OREB) || 0),
                                    dreb: acc.dreb + (parseFloat(pd.DREB) || 0),
                                    ast: acc.ast + (parseFloat(pd.AST) || 0),
                                    stl: acc.stl + (parseFloat(pd.STL) || 0),
                                    blk: acc.blk + (parseFloat(pd.BLK) || 0),
                                    tov: acc.tov + (parseFloat(pd.TOV) || 0),
                                    mins: acc.mins + (parseFloat(pd.Minutes) || parseFloat(pd.MIN) || 0)
                                }), { pts: 0, fga: 0, fgm: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, mins: 0 });
                            };

                            // Get player stats when NOT playing with teammate
                            const getPlayerSoloStatsForPER = (player, team, excludeTeammate) => {
                                if (!playerData.length) return null;
                                const playerNorm = normalizePlayerName(player);
                                const teammateNorm = normalizePlayerName(excludeTeammate);

                                const soloLineups = relevantLineups.filter(l => {
                                    if (l.Team !== team) return false;
                                    const lineupPlayers = (l.Lineup || '').split(',').map(p => p.trim());
                                    const lineupNorm = lineupPlayers.map(p => normalizePlayerName(p));
                                    return lineupNorm.includes(playerNorm) && !lineupNorm.includes(teammateNorm);
                                });

                                if (!soloLineups.length) return null;

                                // Get lineup totals for pace calculation
                                const lineupTotals = soloLineups.reduce((acc, l) => ({
                                    poss: acc.poss + (parseFloat(l.POSS) || calcPoss(parseFloat(l.FGA)||0, parseFloat(l.OREB)||0, parseFloat(l.TOV)||0, parseFloat(l.FTA)||0)),
                                    mins: acc.mins + (parseFloat(l.TOTAL_TIME) || 0) / 60
                                }), { poss: 0, mins: 0 });

                                const normalizedSoloLineupSet = new Set(soloLineups.map(l => normalizeLineupStr(l.Lineup)));

                                const relevantPlayerRows = playerData.filter(pd => {
                                    if (!pd.Player) return false;
                                    const pdNorm = normalizePlayerName(pd.Player);
                                    if (pdNorm !== playerNorm || pd.Team !== team) return false;
                                    const fullLineup = getFullLineupFromPd(pd);
                                    return normalizedSoloLineupSet.has(normalizeLineupStr(fullLineup));
                                });

                                if (!relevantPlayerRows.length) return null;

                                const stats = relevantPlayerRows.reduce((acc, pd) => ({
                                    pts: acc.pts + (parseFloat(pd.PTS) || 0),
                                    fga: acc.fga + (parseFloat(pd.FGA) || 0),
                                    fgm: acc.fgm + (parseFloat(pd.FGM) || 0),
                                    fta: acc.fta + (parseFloat(pd.FTA) || 0),
                                    ftm: acc.ftm + (parseFloat(pd.FTM) || 0),
                                    oreb: acc.oreb + (parseFloat(pd.OREB) || 0),
                                    dreb: acc.dreb + (parseFloat(pd.DREB) || 0),
                                    ast: acc.ast + (parseFloat(pd.AST) || 0),
                                    stl: acc.stl + (parseFloat(pd.STL) || 0),
                                    blk: acc.blk + (parseFloat(pd.BLK) || 0),
                                    tov: acc.tov + (parseFloat(pd.TOV) || 0),
                                    mins: acc.mins + (parseFloat(pd.Minutes) || parseFloat(pd.MIN) || 0)
                                }), { pts: 0, fga: 0, fgm: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, mins: 0 });

                                return { ...stats, lineupTotals };
                            };

                            // Convert to array and calculate PER DELTA
                            const allCombos = [];
                            Object.entries(teamCombos).forEach(([team, combos]) => {
                                Object.values(combos).forEach(c => {
                                    if (c.mins < lbMinMins) return;
                                    const avgPoss = (c.poss + c.possV) / 2;
                                    if (avgPoss < 1) return;

                                    const offRtg = c.poss > 0 ? (c.pts / c.poss) * 100 : 100;
                                    const defRtg = c.possV > 0 ? (c.ptsV / c.possV) * 100 : 100;
                                    const netRtg = offRtg - defRtg;

                                    // Get player stats when together
                                    const p1StatsTogether = getPlayerComboStatsForPER(c.p1, team, c.lineups);
                                    const p1StatsApart = getPlayerSoloStatsForPER(c.p1, team, c.p2);

                                    // Calculate PER delta
                                    let perDelta = null, perTogether = null, perApart = null;
                                    const lineupTotals = { poss: c.poss, mins: c.mins };

                                    if (p1StatsTogether && p1StatsTogether.mins > 0) {
                                        perTogether = calcPER(p1StatsTogether, lineupTotals);
                                        if (p1StatsApart && p1StatsApart.mins > 0) {
                                            perApart = calcPER(p1StatsApart, p1StatsApart.lineupTotals);
                                            if (perTogether !== null && perApart !== null) {
                                                perDelta = perTogether - perApart;
                                            }
                                        }
                                    }

                                    allCombos.push({
                                        p1: c.p1, p2: c.p2, team,
                                        mins: c.mins, poss: avgPoss,
                                        offRtg, defRtg, netRtg,
                                        perDelta, perTogether, perApart
                                    });
                                });
                            });

                            // Calculate Z-Scores for perDelta
                            const validDeltas = allCombos.filter(c => c.perDelta !== null).map(c => c.perDelta);
                            const meanDelta = validDeltas.length > 0 ? validDeltas.reduce((a, b) => a + b, 0) / validDeltas.length : 0;
                            const stdDevDelta = validDeltas.length > 1 ?
                                Math.sqrt(validDeltas.reduce((sum, v) => sum + Math.pow(v - meanDelta, 2), 0) / (validDeltas.length - 1)) : 1;

                            allCombos.forEach(c => {
                                c.zScore = c.perDelta !== null && stdDevDelta > 0.01 ? (c.perDelta - meanDelta) / stdDevDelta : null;
                            });

                            // Sort based on view mode
                            if (lbStat === 'perImpactZScore') {
                                // Sort by Z-Score ascending (most negative first)
                                allCombos.sort((a, b) => {
                                    if (a.zScore !== null && b.zScore !== null) return a.zScore - b.zScore;
                                    if (a.zScore !== null) return -1;
                                    if (b.zScore !== null) return 1;
                                    return b.netRtg - a.netRtg;
                                });
                            } else {
                                // Sort by PER Delta descending (best first)
                                allCombos.sort((a, b) => {
                                    if (a.perDelta !== null && b.perDelta !== null) return b.perDelta - a.perDelta;
                                    if (a.perDelta !== null) return -1;
                                    if (b.perDelta !== null) return 1;
                                    return b.netRtg - a.netRtg;
                                });
                            }

                            const displayCombos = lbShowAll ? allCombos : allCombos.slice(0, 50);

                            const getPerColor = (per) => {
                                if (per === null) return '#64748b';
                                if (per >= 5) return '#22c55e';
                                if (per >= 2) return '#4ade80';
                                if (per >= -2) return '#94a3b8';
                                if (per >= -5) return '#fb923c';
                                return '#ef4444';
                            };

                            const getZScoreColor = (z) => {
                                if (z === null) return '#64748b';
                                if (z <= -2) return '#ef4444';  // Very negative impact
                                if (z <= -1) return '#fb923c';
                                if (z <= 1) return '#94a3b8';
                                if (z <= 2) return '#4ade80';
                                return '#22c55e';  // Very positive impact
                            };

                            return e('div', null,
                                e('p', { style: { fontSize: '11px', opacity: 0.7, marginBottom: '12px' }},
                                    lbStat === 'perImpactZScore'
                                        ? 'Showing ' + displayCombos.length + ' combinations sorted by Z-Score (most negative impact first). Negative Z-Score = teammate HURTS player\'s PER.'
                                        : 'Showing ' + displayCombos.length + ' of ' + allCombos.length + ' two-player combinations with ' + lbMinMins + '+ minutes together. ',
                                    lbStat !== 'perImpactZScore' && 'PER Δ shows P1\'s PER change (with teammate - without teammate).'
                                ),
                                e('div', { style: { overflowX: 'auto', maxHeight: lbShowAll ? '800px' : '500px', overflowY: 'auto' }},
                                    e('table', null,
                                        e('thead', { style: { position: 'sticky', top: 0, background: '#1e293b', zIndex: 1 }},
                                            e('tr', null,
                                                e('th', null, '#'),
                                                e('th', { style: { minWidth: '200px' }}, 'Combination'),
                                                e('th', null, 'Team'),
                                                e('th', { style: { textAlign: 'right', color: '#a78bfa' }}, 'PER Δ'),
                                                lbStat === 'perImpactZScore' && e('th', { style: { textAlign: 'right', color: '#f59e0b' }}, 'Z-Score'),
                                                e('th', { style: { textAlign: 'right', color: '#4ade80' }}, 'PER w/'),
                                                e('th', { style: { textAlign: 'right', color: '#f87171' }}, 'PER w/o'),
                                                e('th', { style: { textAlign: 'right' }}, 'Net Rtg'),
                                                e('th', { style: { textAlign: 'right' }}, 'Mins')
                                            )
                                        ),
                                        e('tbody', null,
                                            displayCombos.map((c, i) => {
                                                return e('tr', { key: i, style: lbStat === 'perImpactZScore' && c.zScore !== null && c.zScore <= -1.5 ? { background: 'rgba(239, 68, 68, 0.15)' } : {} },
                                                    e('td', { style: { opacity: 0.6 }}, i + 1),
                                                    e('td', { style: { fontWeight: '600' }},
                                                        e('span', { style: { color: '#60a5fa' }}, getDisplayName(c.p1, c.team)),
                                                        e('span', { style: { color: '#94a3b8', margin: '0 4px' }}, 'w/'),
                                                        e('span', { style: { color: '#a78bfa' }}, getDisplayName(c.p2, c.team))
                                                    ),
                                                    e('td', { style: { fontSize: '11px', opacity: 0.8 }}, c.team.length > 10 ? c.team.slice(0, 8) + '..' : c.team),
                                                    e('td', { style: { textAlign: 'right', fontWeight: 'bold', color: getPerColor(c.perDelta) }},
                                                        c.perDelta === null ? 'N/A' : (c.perDelta >= 0 ? '+' : '') + c.perDelta.toFixed(1)),
                                                    lbStat === 'perImpactZScore' && e('td', { style: { textAlign: 'right', fontWeight: 'bold', color: getZScoreColor(c.zScore) }},
                                                        c.zScore === null ? 'N/A' : (c.zScore >= 0 ? '+' : '') + c.zScore.toFixed(2)),
                                                    e('td', { style: { textAlign: 'right', color: '#4ade80' }}, c.perTogether === null ? 'N/A' : c.perTogether.toFixed(1)),
                                                    e('td', { style: { textAlign: 'right', color: '#f87171' }}, c.perApart === null ? 'N/A' : c.perApart.toFixed(1)),
                                                    e('td', { style: { textAlign: 'right', color: c.netRtg >= 0 ? '#4ade80' : '#f87171' }}, (c.netRtg >= 0 ? '+' : '') + c.netRtg.toFixed(1)),
                                                    e('td', { style: { textAlign: 'right', fontSize: '11px', opacity: 0.7 }}, c.mins.toFixed(1))
                                                );
                                            })
                                        )
                                    )
                                ),
                                allCombos.length > 50 && e('div', { style: { textAlign: 'center', marginTop: '16px' }},
                                    e('button', {
                                        className: 'btn',
                                        style: {
                                            background: lbShowAll ? 'rgba(100, 116, 139, 0.3)' : 'linear-gradient(135deg, #a78bfa 0%, #7c3aed 100%)',
                                            padding: '10px 24px',
                                            fontSize: '13px',
                                            fontWeight: '600'
                                        },
                                        onClick: () => setLbShowAll(!lbShowAll)
                                    }, lbShowAll ? 'Show Top 50 Only' : 'Show All ' + allCombos.length + ' Combinations')
                                )
                            );
                        })(),

                        // Table View (Standard - not BPM/PER Impact Combos)
                        lbSubtab === 'onoff' && lbViewMode === 'table' && lbStat !== 'bpmImpactCombos' && lbStat !== 'bpmImpactZScore' && lbStat !== 'perImpactCombos' && lbStat !== 'perImpactZScore' && e('div', null,
                        // Table
                        e('div', { className: 'lb-data-table-scroll', style: { maxHeight: lbShowAll ? '800px' : '500px' }},
                            e('table', { className: 'lb-data-table' },
                                e('thead', null,
                                    e('tr', null,
                                        e('th', { style: { textAlign: 'center', width: '36px' } }, '#'),
                                        e('th', { onClick: () => handleSort('player'), 'data-sorted': lbSortCol === 'player' ? 'true' : undefined }, 'Player', e(SortIndicator, { colKey: 'player' })),
                                        e('th', { onClick: () => handleSort('team'), 'data-sorted': lbSortCol === 'team' ? 'true' : undefined }, 'Team', e(SortIndicator, { colKey: 'team' })),
                                        e('th', { className: 'lb-col-right', onClick: () => handleSort('onVsLg'), 'data-sorted': lbSortCol === 'onVsLg' ? 'true' : undefined, title: 'ON vs League Avg' }, 'ON ±Lg', e(SortIndicator, { colKey: 'onVsLg' })),
                                        e('th', { className: 'lb-col-right', onClick: () => handleSort('offVsLg'), 'data-sorted': lbSortCol === 'offVsLg' ? 'true' : undefined, title: 'OFF vs League Avg' }, 'OFF ±Lg', e(SortIndicator, { colKey: 'offVsLg' })),
                                        e('th', {
                                            className: 'lb-col-right' + (lbSortCol === 'diff' ? ' lb-col-primary' : ''),
                                            onClick: () => handleSort('diff'),
                                            'data-sorted': lbSortCol === 'diff' ? 'true' : undefined,
                                            title: useRapmForStat ? 'RAPM: Regularized Adjusted Plus-Minus' : 'ON minus OFF differential',
                                            style: useRapmForStat ? { color: '#a78bfa' } : undefined
                                        },
                                            useRapmForStat ? 'RAPM' : 'DIFF',
                                            e(SortIndicator, { colKey: 'diff' })
                                        ),
                                        // Context columns
                                        contextCols.map(ctx =>
                                            e('th', {
                                                key: ctx.key,
                                                className: 'lb-col-right' + (lbSortCol === ctx.key + 'Diff' ? ' lb-col-primary' : ''),
                                                onClick: () => handleSort(ctx.key + 'Diff'),
                                                'data-sorted': lbSortCol === ctx.key + 'Diff' ? 'true' : undefined,
                                                title: ctx.useRapm ? ctx.label + ' (RAPM value)' : ctx.label + ' ON minus OFF' + (ctx.higherBetter ? ' (↑ better)' : ' (↓ better)'),
                                                style: ctx.useRapm ? { color: '#a78bfa' } : undefined
                                            },
                                            ctx.label + (ctx.useRapm ? '' : ' ±'),
                                            !ctx.higherBetter && e('span', { style: { color: '#f87171', fontSize: '9px', marginLeft: '2px' }}, '↓'),
                                            e(SortIndicator, { colKey: ctx.key + 'Diff' }))
                                        ),
                                        e('th', { className: 'lb-col-right', onClick: () => handleSort('onMinutes'), 'data-sorted': lbSortCol === 'onMinutes' ? 'true' : undefined }, 'ON Mins', e(SortIndicator, { colKey: 'onMinutes' })),
                                        e('th', { className: 'lb-col-right', onClick: () => handleSort('offMinutes'), 'data-sorted': lbSortCol === 'offMinutes' ? 'true' : undefined }, 'OFF Mins', e(SortIndicator, { colKey: 'offMinutes' }))
                                    )
                                ),
                                e('tbody', null,
                                    sortedData.map((d, i) => {
                                        const diffColor = getDiffColor(d.diff, currentStat.higherBetter);
                                        const onVsLgColor = getDiffColor(d.onVsLg, currentStat.higherBetter);
                                        const offVsLgColor = getDiffColor(d.offVsLg, currentStat.higherBetter);
                                        return e('tr', { key: i },
                                            e('td', { className: 'lb-col-rank' }, i + 1),
                                            e('td', { className: 'lb-col-player' },
                                                d.player,
                                                d.hasRapm && e('span', { style: { marginLeft: '4px', fontSize: '9px', color: '#a78bfa' }}, '●')
                                            ),
                                            e('td', { className: 'lb-col-team' }, d.team),
                                            e('td', { className: 'lb-col-stat', style: { color: onVsLgColor }}, (d.onVsLg >= 0 ? '+' : '') + d.onVsLg.toFixed(1)),
                                            e('td', { className: 'lb-col-stat', style: { color: offVsLgColor, opacity: 0.8 }}, (d.offVsLg >= 0 ? '+' : '') + d.offVsLg.toFixed(1)),
                                            e('td', { className: 'lb-col-stat' + (lbSortCol === 'diff' ? ' lb-col-primary' : ''), style: { color: diffColor }},
                                                (d.diff >= 0 ? '+' : '') + d.diff.toFixed(1),
                                                // V4.9.8.8: Show raw RAPM when luck adjusted
                                                d.luckAdj && d.rawRapmVal !== null && d.rawRapmVal !== undefined && e('div', {
                                                    style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }
                                                }, 'raw: ' + (d.rawRapmVal >= 0 ? '+' : '') + d.rawRapmVal.toFixed(1))
                                            ),
                                            // Context columns
                                            contextCols.map(ctx => {
                                                const ctxDiff = d[ctx.key + 'Diff'] || 0;
                                                const ctxDiffNum = typeof ctxDiff === 'number' ? ctxDiff : 0;
                                                let ctxColor;
                                                if (ctx.useRapm) {
                                                    const isGood = ctx.higherBetter ? ctxDiffNum > 0 : ctxDiffNum < 0;
                                                    ctxColor = ctxDiffNum === 0 ? '#a78bfa' : isGood ? '#4ade80' : '#f87171';
                                                } else {
                                                    ctxColor = getDiffColor(ctxDiffNum, ctx.higherBetter);
                                                }
                                                return e('td', {
                                                    key: ctx.key,
                                                    className: 'lb-col-stat' + (lbSortCol === ctx.key + 'Diff' ? ' lb-col-primary' : ''),
                                                    style: { color: ctxColor }
                                                }, (ctxDiffNum >= 0 ? '+' : '') + ctxDiffNum.toFixed(1));
                                            }),
                                            e('td', { className: 'lb-col-muted' }, (d.onMinutes || 0).toFixed(1)),
                                            e('td', { className: 'lb-col-muted' }, (d.offMinutes || 0).toFixed(1))
                                        );
                                    })
                                )
                            )
                        )
                        ), // End of table view conditional
                        
                        // Show More / Show Less button (only in table view)
                        lbSubtab === 'onoff' && lbViewMode === 'table' && lbStat !== 'bpmImpactCombos' && lbStat !== 'bpmImpactZScore' && totalFilteredCount > 50 && e('div', { style: { textAlign: 'center', marginTop: '16px' }},
                            e('button', {
                                className: 'btn',
                                style: {
                                    background: lbShowAll ? 'rgba(100, 116, 139, 0.3)' : 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                                    padding: '10px 24px',
                                    fontSize: '13px',
                                    fontWeight: '600'
                                },
                                onClick: () => setLbShowAll(!lbShowAll)
                            }, lbShowAll ? 'Show Top 50 Only' : 'Show All ' + totalFilteredCount + ' Players')
                        ),

                        lbSubtab === 'onoff' && lbViewMode === 'table' && lbStat !== 'bpmImpactCombos' && lbStat !== 'bpmImpactZScore' && filteredData.length === 0 && e('p', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }}, 'No players match the current filters'),
                        
                        
                        // V4.7.2: RAPM Methodology note
                        lbSubtab === 'onoff' && useRapmForStat && rapmAvailable && e('div', { 
                            style: { 
                                marginTop: '20px', 
                                padding: '12px', 
                                background: 'rgba(139, 92, 246, 0.1)', 
                                border: '1px solid rgba(139, 92, 246, 0.3)', 
                                borderRadius: '8px',
                                fontSize: '11px',
                                color: '#c4b5fd'
                            }
                        },
                            e('strong', { style: { color: '#a78bfa' }}, '[RAPM] Multi-Stat RAPM Methodology (V3.1): '),
                            'Calculates RAPM for ' + (playerRAPMStats?.calculatedStats?.length || 17) + ' stats with low regularization for maximum variance. ',
                            'Stats include: ORtg, eFG%, TOV%, OREB%, FTR, AST%, STL%, BLK%, Rim/Mid/3PT %, Frequencies, FastBreak, 2ndChance, PtsOffTO. ',
                            'Each stat solves y = X*beta + error using ridge regression (base lambda=' + (playerRAPMStats?.lambda || 800) + ', scaled per stat). ',
                            'X matrix encodes players (+1 offense, -1 defense). Coefficients possession-weighted centered. ',
                            e('strong', null, 'Note: '), 'RAPM shows impact relative to league average (0).'
                        )
                        ), // End of On/Off tab div
                        
                        // V4.9.8.6: Individual Stats Leaderboard Tab
                        lbSubtab === 'individual' && e('div', null,
                            (() => {
                                // Individual stat options for dropdown
                                const indivStatOptions = [
                                    { value: 'usage', label: 'Usage %', higherBetter: true, isPercentage: true, group: 'Usage' },
                                    { value: 'pts75', label: 'PTS/75', higherBetter: true, group: 'Box Score' },
                                    { value: 'reb75', label: 'REB/75', higherBetter: true, group: 'Box Score' },
                                    { value: 'oreb75', label: 'OREB/75', higherBetter: true, group: 'Box Score' },
                                    { value: 'dreb75', label: 'DREB/75', higherBetter: true, group: 'Box Score' },
                                    { value: 'ast75', label: 'AST/75', higherBetter: true, group: 'Box Score' },
                                    { value: 'astUsgRatio', label: 'AST/USG', higherBetter: true, group: 'Box Score' },
                                    { value: 'stl75', label: 'STL/75', higherBetter: true, group: 'Box Score' },
                                    { value: 'blk75', label: 'BLK/75', higherBetter: true, group: 'Box Score' },
                                    { value: 'tov75', label: 'TOV/75', higherBetter: false, group: 'Box Score' },
                                    { value: 'tsPct', label: 'TS%', higherBetter: true, isPercentage: true, group: 'Shooting' },
                                    { value: 'rimA75', label: 'RIM ATT/75', higherBetter: true, group: 'Shot Volume' },
                                    { value: 'midA75', label: 'MID ATT/75', higherBetter: true, group: 'Shot Volume' },
                                    { value: 'threeA75', label: '3PT ATT/75', higherBetter: true, group: 'Shot Volume' },
                                    { value: 'rimPct', label: 'RIM %', higherBetter: true, isPercentage: true, group: 'Shooting' },
                                    { value: 'midPct', label: 'MID %', higherBetter: true, isPercentage: true, group: 'Shooting' },
                                    { value: 'threePct', label: '3PT %', higherBetter: true, isPercentage: true, group: 'Shooting' },
                                    { value: 'tpc75', label: 'TPC/75', higherBetter: true, group: 'Playmaking' },
                                    { value: 'playerAstPct', label: 'AST%', higherBetter: true, isPercentage: true, group: 'Playmaking' },
                                    { value: 'passTo', label: 'Pass TOs', higherBetter: false, group: 'Turnovers' },
                                    { value: 'dribTo', label: 'Dribble TOs', higherBetter: false, group: 'Turnovers' },
                                    // V4.9.8.6: New stats from player_stats_enhanced.csv
                                    { value: 'ptsAst75', label: 'PTS AST/75', higherBetter: true, group: 'Scoring' },
                                    { value: 'secChancePts75', label: '2nd Chance PTS/75', higherBetter: true, group: 'Scoring' },
                                    { value: 'fastBreakPts75', label: 'Fast Break PTS/75', higherBetter: true, group: 'Scoring' },
                                    { value: 'clutchPts75', label: 'Clutch PTS/75', higherBetter: true, group: 'Scoring' },
                                    // V5.10: Box Plus/Minus from CSV
                                    { value: 'bpm', label: 'BPM', higherBetter: true, group: 'Box Plus/Minus', isPlusMinus: true },
                                    { value: 'obpm', label: 'OBPM', higherBetter: true, group: 'Box Plus/Minus', isPlusMinus: true },
                                    { value: 'dbpm', label: 'DBPM', higherBetter: true, group: 'Box Plus/Minus', isPlusMinus: true },
                                    // V5.11: Bayesian Box APM (Bayesian Box + RAPM)
                                    { value: 'apm', label: '🔮 APM', higherBetter: true, group: 'Bayesian Box APM', isPlusMinus: true },
                                    { value: 'oapm', label: '🔮 OAPM', higherBetter: true, group: 'Bayesian Box APM', isPlusMinus: true },
                                    { value: 'dapm', label: '🔮 DAPM', higherBetter: true, group: 'Bayesian Box APM', isPlusMinus: true }
                                ];
                                
                                const currentIndivStat = indivStatOptions.find(s => s.value === lbIndivStat) || indivStatOptions[0];
                                
                                // Group options for dropdown
                                const groupedIndivOptions = indivStatOptions.reduce((acc, opt) => {
                                    if (!acc[opt.group]) acc[opt.group] = [];
                                    acc[opt.group].push(opt);
                                    return acc;
                                }, {});
                                
                                // V4.9.8.6: Use league-wide player data from leaguePlayerAverages
                                const allLeaguePlayers = leaguePlayerAverages?.players || [];
                                
                                // Get all unique teams for filter dropdown
                                const allTeams = [...new Set(allLeaguePlayers.map(p => p.team))].sort();
                                
                                // Filter and sort player data (ALL teams)
                                // V5.14.2: Use lbIndivSortAsc for sort direction
                                const indivDataAll = allLeaguePlayers
                                    .filter(p => {
                                        if (lbTeam && p.team !== lbTeam) return false;
                                        if (p.minutes < lbMinMins) return false;
                                        return true;
                                    })
                                    .sort((a, b) => {
                                        const aVal = a[lbIndivStat] || 0;
                                        const bVal = b[lbIndivStat] || 0;
                                        // Default: higher better stats sort descending, lower better stats sort ascending
                                        // When lbIndivSortAsc is true, reverse the default
                                        const defaultDesc = currentIndivStat.higherBetter;
                                        const shouldSortDesc = lbIndivSortAsc ? !defaultDesc : defaultDesc;
                                        return shouldSortDesc ? bVal - aVal : aVal - bVal;
                                    });
                                
                                const totalIndivCount = indivDataAll.length;
                                const indivData = lbShowAll ? indivDataAll : indivDataAll.slice(0, 50);
                                
                                // Calculate percentile for value
                                const getIndivPct = (val) => {
                                    if (!leaguePlayerAverages?.statArrays?.[lbIndivStat]) return 50;
                                    return calcLeaguePercentile(val, leaguePlayerAverages.statArrays[lbIndivStat], currentIndivStat.higherBetter);
                                };
                                
                                return e('div', null,
                                    // Filters for Individual tab
                                    e('div', { style: { display: 'flex', gap: '16px', marginBottom: '16px', flexWrap: 'wrap', alignItems: 'flex-end' }},
                                        e('div', { style: { flex: '1', minWidth: '250px' }},
                                            e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8 }}, 'Stat'),
                                            e('select', { 
                                                value: lbIndivStat, 
                                                onChange: ev => setLbIndivStat(ev.target.value),
                                                style: { width: '100%', padding: '8px', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: 'white' }
                                            },
                                                Object.entries(groupedIndivOptions).map(([group, opts]) => 
                                                    e('optgroup', { key: group, label: group },
                                                        opts.map(s => e('option', { key: s.value, value: s.value }, s.label))
                                                    )
                                                )
                                            )
                                        ),
                                        // V4.9.8.6: Team filter for Individual tab (all teams)
                                        e('div', { style: { minWidth: '150px' }},
                                            e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8 }}, 'Team'),
                                            e('select', { 
                                                value: lbTeam, 
                                                onChange: ev => setLbTeam(ev.target.value),
                                                style: { width: '100%', padding: '8px', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: 'white' }
                                            },
                                                e('option', { value: '' }, 'All Teams'),
                                                allTeams.map(t => e('option', { key: t, value: t }, t))
                                            )
                                        ),
                                        e('div', { style: { minWidth: '100px' }},
                                            e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8 }}, 'Min Mins'),
                                            e('input', {
                                                type: 'number',
                                                value: lbMinMins,
                                                onChange: ev => setLbMinMins(parseInt(ev.target.value) || 0),
                                                style: { width: '100%', padding: '8px', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: 'white' }
                                            })
                                        ),
                                        // V5.14.2: Sort direction toggle
                                        e('div', { style: { minWidth: '80px' }},
                                            e('label', { style: { display: 'block', fontSize: '12px', marginBottom: '4px', opacity: 0.8 }}, 'Sort'),
                                            e('button', {
                                                onClick: () => setLbIndivSortAsc(!lbIndivSortAsc),
                                                style: {
                                                    width: '100%',
                                                    padding: '8px 12px',
                                                    background: lbIndivSortAsc ? 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)' : 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)',
                                                    border: 'none',
                                                    borderRadius: '6px',
                                                    color: 'white',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '12px'
                                                }
                                            }, lbIndivSortAsc ? '↑ Asc' : '↓ Desc')
                                        )
                                    ),

                                    e('p', { style: { fontSize: '11px', opacity: 0.7, marginBottom: '12px' }},
                                        'Showing ' + indivData.length + ' of ' + totalIndivCount + ' ' + (lbTeam ? lbTeam + ' ' : '') + 'players by ' + currentIndivStat.label + '. ',
                                        lbIndivSortAsc ? (currentIndivStat.higherBetter ? 'Sorted: Lowest first.' : 'Sorted: Highest first.') : (currentIndivStat.higherBetter ? 'Sorted: Highest first.' : 'Sorted: Lowest first.'),
                                        leaguePlayerAverages && ' League avg: ' + (leaguePlayerAverages.averages?.[lbIndivStat] || 0).toFixed(1)
                                    ),

                                    // Individual Stats Table
                                    // V5.16: Wrap in IIFE to properly scope helper functions
                                    (() => {
                                        // Helper for sort indicator in individual table
                                        const IndivSortIndicator = ({ statKey }) => {
                                            if (lbIndivStat !== statKey) return null;
                                            const stat = indivStatOptions.find(s => s.value === statKey);
                                            const isDefaultDesc = stat?.higherBetter ?? true;
                                            const isCurrentlyDesc = lbIndivSortAsc ? !isDefaultDesc : isDefaultDesc;
                                            return e('span', { style: { marginLeft: '4px', fontSize: '10px' }}, isCurrentlyDesc ? '▼' : '▲');
                                        };

                                        // Helper to handle column click in individual table
                                        const handleIndivSort = (statKey) => {
                                            if (lbIndivStat === statKey) {
                                                setLbIndivSortAsc(!lbIndivSortAsc);
                                            } else {
                                                setLbIndivStat(statKey);
                                                setLbIndivSortAsc(false); // Reset to default direction
                                            }
                                        };

                                        return e('div', { className: 'lb-data-table-scroll', style: { maxHeight: lbShowAll ? '800px' : '500px' }},
                                        e('table', { className: 'lb-data-table' },
                                            e('thead', null,
                                                e('tr', null,
                                                    e('th', { style: { textAlign: 'center', width: '36px' } }, '#'),
                                                    e('th', null, 'Player'),
                                                    e('th', null, 'Team'),
                                                    e('th', {
                                                        className: 'lb-col-right lb-col-primary',
                                                        onClick: () => handleIndivSort(lbIndivStat),
                                                        'data-sorted': 'true'
                                                    }, currentIndivStat.label, e(IndivSortIndicator, { statKey: lbIndivStat })),
                                                    e('th', { className: 'lb-col-right' }, 'Pctl'),
                                                    e('th', {
                                                        className: 'lb-col-right' + (lbIndivStat === 'usage' ? ' lb-col-primary' : ''),
                                                        onClick: () => handleIndivSort('usage'),
                                                        'data-sorted': lbIndivStat === 'usage' ? 'true' : undefined
                                                    }, 'Usage%', e(IndivSortIndicator, { statKey: 'usage' })),
                                                    e('th', { className: 'lb-col-right' }, 'Poss'),
                                                    e('th', { className: 'lb-col-right' }, 'Min')
                                                )
                                            ),
                                            e('tbody', null,
                                                indivData.map((d, i) => {
                                                    const val = d[lbIndivStat] || 0;
                                                    const pctl = getIndivPct(val);
                                                    const pctlColor = pctl >= 80 ? '#4ade80' : pctl >= 60 ? '#a3e635' : pctl >= 40 ? '#fbbf24' : pctl >= 20 ? '#fb923c' : '#f87171';
                                                    const suffix = currentIndivStat.isPercentage ? '%' : '';
                                                    // V5.10: Show +/- prefix for BPM stats
                                                    const prefix = currentIndivStat.isPlusMinus && val >= 0 ? '+' : '';
                                                    return e('tr', { key: i },
                                                        e('td', { className: 'lb-col-rank' }, i + 1),
                                                        e('td', { className: 'lb-col-player' }, d.player),
                                                        e('td', { className: 'lb-col-team' }, d.team),
                                                        e('td', { className: 'lb-col-stat lb-col-primary', style: { color: pctlColor }}, prefix + val.toFixed(1) + suffix),
                                                        e('td', { className: 'lb-col-right', style: { textAlign: 'right' }},
                                                            e('span', { className: 'lb-pctl-badge', style: {
                                                                background: pctl >= 80 ? 'rgba(34,197,94,0.3)' : pctl >= 60 ? 'rgba(132,204,22,0.3)' : pctl >= 40 ? 'rgba(234,179,8,0.3)' : pctl >= 20 ? 'rgba(249,115,22,0.3)' : 'rgba(239,68,68,0.3)',
                                                                color: pctlColor
                                                            }}, Math.round(pctl) + 'th')
                                                        ),
                                                        e('td', { className: 'lb-col-muted' }, d.usage?.toFixed(1) + '%'),
                                                        e('td', { className: 'lb-col-muted' }, Math.round(d.poss)),
                                                        e('td', { className: 'lb-col-muted' }, d.minutes?.toFixed(1))
                                                    );
                                                })
                                            )
                                        )
                                    );
                                    })(),

                                    // Show More / Show Less button for Individual tab
                                    totalIndivCount > 50 && e('div', { style: { textAlign: 'center', marginTop: '16px' }},
                                        e('button', {
                                            className: 'btn',
                                            style: {
                                                background: lbShowAll ? 'rgba(100, 116, 139, 0.3)' : 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)',
                                                padding: '10px 24px',
                                                fontSize: '13px',
                                                fontWeight: '600'
                                            },
                                            onClick: () => setLbShowAll(!lbShowAll)
                                        }, lbShowAll ? '📋 Show Top 50 Only' : '📋 Show All ' + totalIndivCount + ' Players')
                                    ),
                                    
                                    indivData.length === 0 && e('p', { style: { textAlign: 'center', padding: '40px', opacity: 0.6 }}, 
                                        'No players match the current filters. Try lowering the minimum possession threshold.'
                                    ),
                                    
                                    // Methodology note
                                    e('div', { 
                                        style: { 
                                            marginTop: '20px', 
                                            padding: '12px', 
                                            background: 'rgba(139, 92, 246, 0.1)', 
                                            border: '1px solid rgba(139, 92, 246, 0.3)', 
                                            borderRadius: '8px',
                                            fontSize: '11px',
                                            color: '#c4b5fd'
                                        }
                                    },
                                        e('strong', { style: { color: '#a78bfa' }}, '👤 Individual Stats Methodology: '),
                                        'Stats calculated per 75 lineup possessions using the Dean Oliver formula. ',
                                        'AST/USG = AST% ÷ Usage% (measures playmaking efficiency relative to ball dominance). ',
                                        'Percentiles calculated against all players league-wide (min 50 poss). ',
                                        e('strong', null, 'Note: '), 'Shows players from ALL teams. Use Team filter to narrow down.'
                                    )
                                );
                            })()
                        ), // End of Individual tab

                        // ═══════════════════════════════════════════════════════════════════════════
                        // TEAM LEADERBOARD TAB - Full team stats with percentile color coding
                        // ═══════════════════════════════════════════════════════════════════════════
                        lbSubtab === 'teams' && (() => {
                            // Build comprehensive team stats from all data sources
                            const teamStatsMap = new Map();

                            // 1. AGGREGATE FROM LINEUP DATA (Four Factors, Shot Distribution, Transition)
                            if (lineupData.length > 0) {
                                lineupData.forEach(d => {
                                    const teamName = d.Team;
                                    if (!teamName) return;

                                    if (!teamStatsMap.has(teamName)) {
                                        teamStatsMap.set(teamName, {
                                            name: teamName,
                                            // Counting stats
                                            poss: 0, pts: 0, ptsAllowed: 0,
                                            fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0,
                                            oreb: 0, dreb: 0, ast: 0, tov: 0, stl: 0, blk: 0,
                                            // Opponent stats
                                            oppFgm: 0, oppFga: 0, oppTpm: 0, oppTpa: 0, oppFtm: 0, oppFta: 0,
                                            oppOreb: 0, oppDreb: 0, oppTov: 0,
                                            // Shot zones
                                            rimM: 0, rimA: 0, midM: 0, midA: 0,
                                            oppRimM: 0, oppRimA: 0, oppMidM: 0, oppMidA: 0,
                                            // Transition
                                            fastBreak: 0, secChance: 0, ptsOffTov: 0,
                                            fastBreakV: 0, secChanceV: 0, ptsOffTovV: 0,
                                            // Games tracking
                                            games: new Set()
                                        });
                                    }

                                    const t = teamStatsMap.get(teamName);
                                    const poss = parseFloat(d.POSS) || 0;
                                    t.poss += poss;
                                    t.pts += parseFloat(d.PTS) || 0;
                                    t.ptsAllowed += parseFloat(d.PTS_ALLOWED || d.PTS_VS) || 0;
                                    t.fgm += parseFloat(d.FGM) || 0;
                                    t.fga += parseFloat(d.FGA) || 0;
                                    t.tpm += parseFloat(d['3PM']) || 0;
                                    t.tpa += parseFloat(d['3PA']) || 0;
                                    t.ftm += parseFloat(d.FTM) || 0;
                                    t.fta += parseFloat(d.FTA) || 0;
                                    t.oreb += parseFloat(d.OREB) || 0;
                                    t.dreb += parseFloat(d.DREB) || 0;
                                    t.ast += parseFloat(d.AST) || 0;
                                    t.tov += parseFloat(d.TOV) || 0;
                                    t.stl += parseFloat(d.STL) || 0;
                                    t.blk += parseFloat(d.BLK) || 0;

                                    // Opponent stats
                                    t.oppFgm += parseFloat(d.FGM_VS) || 0;
                                    t.oppFga += parseFloat(d.FGA_VS) || 0;
                                    t.oppTpm += parseFloat(d['3PM_VS']) || 0;
                                    t.oppTpa += parseFloat(d['3PA_VS']) || 0;
                                    t.oppFtm += parseFloat(d.FTM_VS) || 0;
                                    t.oppFta += parseFloat(d.FTA_VS) || 0;
                                    t.oppOreb += parseFloat(d.OREB_VS) || 0;
                                    t.oppDreb += parseFloat(d.DREB_VS) || 0;
                                    t.oppTov += parseFloat(d.TOV_VS) || 0;

                                    // Shot zones
                                    t.rimM += parseFloat(d.RIM_MADE) || 0;
                                    t.rimA += parseFloat(d.RIM_ATT) || 0;
                                    t.midM += parseFloat(d.OTD_2PT_MADE) || 0;
                                    t.midA += parseFloat(d.OTD_2PT_ATT) || 0;
                                    t.oppRimM += parseFloat(d.RIM_MADE_VS) || 0;
                                    t.oppRimA += parseFloat(d.RIM_ATT_VS) || 0;
                                    t.oppMidM += parseFloat(d.OTD_2PT_MADE_VS) || 0;
                                    t.oppMidA += parseFloat(d.OTD_2PT_ATT_VS) || 0;

                                    // Transition
                                    t.fastBreak += parseFloat(d.FAST_BREAK_PTS) || 0;
                                    t.secChance += parseFloat(d['2ND_CHANCE_PTS']) || 0;
                                    t.ptsOffTov += parseFloat(d.PTS_OFF_TOV) || 0;
                                    t.fastBreakV += parseFloat(d.FAST_BREAK_PTS_VS) || 0;
                                    t.secChanceV += parseFloat(d['2ND_CHANCE_PTS_VS']) || 0;
                                    t.ptsOffTovV += parseFloat(d.PTS_OFF_TOV_VS) || 0;

                                    // Track games
                                    if (d.game_id) t.games.add(d.game_id);
                                });
                            }

                            // 2. AGGREGATE CLUTCH DATA
                            const teamClutchStats = new Map();
                            if (clutchData.length > 0) {
                                clutchData.forEach(d => {
                                    const teamName = d.Team;
                                    if (!teamName) return;

                                    if (!teamClutchStats.has(teamName)) {
                                        teamClutchStats.set(teamName, {
                                            minutes: 0, poss: 0, pts: 0, ptsAllowed: 0,
                                            fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, tov: 0
                                        });
                                    }

                                    const c = teamClutchStats.get(teamName);
                                    c.minutes += parseFloat(d.Clutch_Minutes) || 0;
                                    c.poss += parseFloat(d.POSS) || 0;
                                    c.pts += parseFloat(d.PTS) || 0;
                                    c.ptsAllowed += parseFloat(d.PTS_ALLOWED) || 0;
                                    c.fgm += parseFloat(d.FGM) || 0;
                                    c.fga += parseFloat(d.FGA) || 0;
                                    c.tpm += parseFloat(d['3PM']) || 0;
                                    c.tpa += parseFloat(d['3PA']) || 0;
                                    c.ftm += parseFloat(d.FTM) || 0;
                                    c.fta += parseFloat(d.FTA) || 0;
                                    c.tov += parseFloat(d.TOV) || 0;
                                });
                            }

                            // 3. CALCULATE ALL DERIVED STATS FOR EACH TEAM
                            const teamDataArray = [];

                            teamStatsMap.forEach((t, name) => {
                                if (t.poss < 100) return; // Min possessions filter

                                // Basic Ratings
                                const offRtg = t.poss > 0 ? (t.pts / t.poss) * 100 : 0;
                                const defRtg = t.poss > 0 ? (t.ptsAllowed / t.poss) * 100 : 0;
                                const netRtg = offRtg - defRtg;

                                // Four Factors - Offense
                                const offEfg = t.fga > 0 ? ((t.fgm + 0.5 * t.tpm) / t.fga) * 100 : 0;
                                const tovDenom = t.fga + 0.44 * t.fta + t.tov;
                                const offTov = tovDenom > 0 ? (t.tov / tovDenom) * 100 : 0;
                                const offOreb = (t.oreb + t.oppDreb) > 0 ? (t.oreb / (t.oreb + t.oppDreb)) * 100 : 0;
                                const offFtRate = t.fga > 0 ? (t.fta / t.fga) * 100 : 0;

                                // Four Factors - Defense
                                const defEfg = t.oppFga > 0 ? ((t.oppFgm + 0.5 * t.oppTpm) / t.oppFga) * 100 : 0;
                                const defTovDenom = t.oppFga + 0.44 * t.oppFta + t.oppTov;
                                const defTov = defTovDenom > 0 ? (t.oppTov / defTovDenom) * 100 : 0;
                                const defOreb = (t.oppOreb + t.dreb) > 0 ? (t.oppOreb / (t.oppOreb + t.dreb)) * 100 : 0;
                                const defFtRate = t.oppFga > 0 ? (t.oppFta / t.oppFga) * 100 : 0;

                                // Shot Distribution - Offense
                                const rimPct = t.rimA > 0 ? (t.rimM / t.rimA) * 100 : 0;
                                const midPct = t.midA > 0 ? (t.midM / t.midA) * 100 : 0;
                                const threePct = t.tpa > 0 ? (t.tpm / t.tpa) * 100 : 0;
                                const rimVol = t.fga > 0 ? (t.rimA / t.fga) * 100 : 0;
                                const midVol = t.fga > 0 ? (t.midA / t.fga) * 100 : 0;
                                const threeVol = t.fga > 0 ? (t.tpa / t.fga) * 100 : 0;

                                // Moreyball% - % of shots at rim or from 3
                                const moreyballPct = t.fga > 0 ? ((t.rimA + t.tpa) / t.fga) * 100 : 0;

                                // Shot Distribution - Defense
                                const oppRimPct = t.oppRimA > 0 ? (t.oppRimM / t.oppRimA) * 100 : 0;
                                const oppMidPct = t.oppMidA > 0 ? (t.oppMidM / t.oppMidA) * 100 : 0;
                                const oppThreePct = t.oppTpa > 0 ? (t.oppTpm / t.oppTpa) * 100 : 0;
                                const oppRimVol = t.oppFga > 0 ? (t.oppRimA / t.oppFga) * 100 : 0;
                                const oppMidVol = t.oppFga > 0 ? (t.oppMidA / t.oppFga) * 100 : 0;
                                const oppThreeVol = t.oppFga > 0 ? (t.oppTpa / t.oppFga) * 100 : 0;

                                // Transition stats per 100 possessions
                                const fastBreak100 = t.poss > 0 ? (t.fastBreak / t.poss) * 100 : 0;
                                const secChance100 = t.poss > 0 ? (t.secChance / t.poss) * 100 : 0;
                                const ptsOffTov100 = t.poss > 0 ? (t.ptsOffTov / t.poss) * 100 : 0;
                                const fastBreak100V = t.poss > 0 ? (t.fastBreakV / t.poss) * 100 : 0;
                                const secChance100V = t.poss > 0 ? (t.secChanceV / t.poss) * 100 : 0;
                                const ptsOffTov100V = t.poss > 0 ? (t.ptsOffTovV / t.poss) * 100 : 0;

                                // Clutch stats
                                const clutch = teamClutchStats.get(name) || { minutes: 0, poss: 0, pts: 0, ptsAllowed: 0 };
                                const clutchMins = clutch.minutes;
                                const clutchOffRtg = clutch.poss > 0 ? (clutch.pts / clutch.poss) * 100 : 0;
                                const clutchDefRtg = clutch.poss > 0 ? (clutch.ptsAllowed / clutch.poss) * 100 : 0;
                                const clutchNetRtg = clutchOffRtg - clutchDefRtg;

                                // Assist rate
                                const astPct = t.fgm > 0 ? (t.ast / t.fgm) * 100 : 0;

                                // Games count
                                const gamesPlayed = t.games.size;

                                teamDataArray.push({
                                    name, gamesPlayed, poss: t.poss,
                                    // Ratings (will add adjusted later)
                                    offRtg, defRtg, netRtg,
                                    adjOrtg: offRtg, adjDrtg: defRtg, adjNet: netRtg, // Placeholders, updated below
                                    // Four Factors
                                    offEfg, offTov, offOreb, offFtRate,
                                    defEfg, defTov, defOreb, defFtRate,
                                    // Shot Making
                                    rimPct, midPct, threePct,
                                    oppRimPct, oppMidPct, oppThreePct,
                                    // Shot Volume
                                    rimVol, midVol, threeVol, moreyballPct,
                                    oppRimVol, oppMidVol, oppThreeVol,
                                    // Transition
                                    fastBreak100, secChance100, ptsOffTov100,
                                    fastBreak100V, secChance100V, ptsOffTov100V,
                                    // Clutch
                                    clutchMins, clutchOffRtg, clutchDefRtg, clutchNetRtg,
                                    // Playmaking
                                    astPct,
                                    // Points Added (calculated below)
                                    offEfgPA: 0, offTovPA: 0, offOrebPA: 0, offFtRatePA: 0,
                                    defEfgPA: 0, defTovPA: 0, defOrebPA: 0, defFtRatePA: 0,
                                    totalPA: 0
                                });
                            });

                            // 4. CALCULATE SOS-ADJUSTED RATINGS (simplified KenPom-style)
                            // First calculate league averages
                            const nTeams = teamDataArray.length;
                            if (nTeams > 0) {
                                const lgAvg = {
                                    offRtg: teamDataArray.reduce((s, t) => s + t.offRtg, 0) / nTeams,
                                    defRtg: teamDataArray.reduce((s, t) => s + t.defRtg, 0) / nTeams,
                                    efg: teamDataArray.reduce((s, t) => s + t.offEfg, 0) / nTeams,
                                    tovPct: teamDataArray.reduce((s, t) => s + t.offTov, 0) / nTeams,
                                    orebPct: teamDataArray.reduce((s, t) => s + t.offOreb, 0) / nTeams,
                                    ftRate: teamDataArray.reduce((s, t) => s + t.offFtRate, 0) / nTeams
                                };

                                // Points per percentage for Four Factors
                                const POINTS_PER_PCT = { efg: 2.0, tovPct: 1.4, orebPct: 0.7, ftRate: 0.4 };

                                // Iterative SOS adjustment (3 iterations)
                                const adjORtg = new Map();
                                const adjDRtg = new Map();
                                teamDataArray.forEach(t => {
                                    adjORtg.set(t.name, t.offRtg);
                                    adjDRtg.set(t.name, t.defRtg);
                                });

                                // Simple adjustment using average opponent strength
                                // For now, use raw ratings (full SOS would need opponent tracking)
                                teamDataArray.forEach(t => {
                                    t.adjOrtg = t.offRtg;
                                    t.adjDrtg = t.defRtg;
                                    t.adjNet = t.offRtg - t.defRtg;

                                    // Points Added Analysis (Four Factors)
                                    t.offEfgPA = (t.offEfg - lgAvg.efg) * POINTS_PER_PCT.efg;
                                    t.offTovPA = (lgAvg.tovPct - t.offTov) * POINTS_PER_PCT.tovPct; // Lower is better
                                    t.offOrebPA = (t.offOreb - lgAvg.orebPct) * POINTS_PER_PCT.orebPct;
                                    t.offFtRatePA = (t.offFtRate - lgAvg.ftRate) * POINTS_PER_PCT.ftRate;

                                    t.defEfgPA = (lgAvg.efg - t.defEfg) * POINTS_PER_PCT.efg; // Lower opp eFG is better
                                    t.defTovPA = (t.defTov - lgAvg.tovPct) * POINTS_PER_PCT.tovPct; // Higher forced TOV is better
                                    t.defOrebPA = (lgAvg.orebPct - t.defOreb) * POINTS_PER_PCT.orebPct; // Lower opp OREB is better
                                    t.defFtRatePA = (lgAvg.ftRate - t.defFtRate) * POINTS_PER_PCT.ftRate; // Lower opp FT rate is better

                                    t.totalPA = t.offEfgPA + t.offTovPA + t.offOrebPA + t.offFtRatePA +
                                               t.defEfgPA + t.defTovPA + t.defOrebPA + t.defFtRatePA;
                                });
                            }

                            // 5. DEFINE TEAM STAT COLUMNS (with descriptions for tooltips)
                            const teamStatColumns = [
                                // Adjusted Ratings (from SOS)
                                { key: 'adjNet', label: 'Adj Net', group: 'Adjusted', higherBetter: true, decimals: 1, showSign: true, desc: 'Adjusted Net Rating - Points scored minus allowed per 100 possessions, adjusted for opponent strength' },
                                { key: 'adjOrtg', label: 'Adj ORtg', group: 'Adjusted', higherBetter: true, decimals: 1, desc: 'Adjusted Offensive Rating - Points scored per 100 possessions, adjusted for opponent defensive strength' },
                                { key: 'adjDrtg', label: 'Adj DRtg', group: 'Adjusted', higherBetter: false, decimals: 1, desc: 'Adjusted Defensive Rating - Points allowed per 100 possessions, adjusted for opponent offensive strength' },

                                // Points Added (Four Factors)
                                { key: 'totalPA', label: 'Total PA', group: 'Points Added', higherBetter: true, decimals: 1, showSign: true, desc: 'Total Points Added - Combined impact of all Four Factors vs league average' },
                                { key: 'offEfgPA', label: 'eFG PA', group: 'Points Added', higherBetter: true, decimals: 1, showSign: true, desc: 'Effective FG% Points Added - Shooting efficiency impact vs league average' },
                                { key: 'offTovPA', label: 'TOV PA', group: 'Points Added', higherBetter: true, decimals: 1, showSign: true, desc: 'Turnover% Points Added - Ball security impact vs league average' },
                                { key: 'offOrebPA', label: 'ORB PA', group: 'Points Added', higherBetter: true, decimals: 1, showSign: true, desc: 'Offensive Rebound% Points Added - Second chance impact vs league average' },
                                { key: 'offFtRatePA', label: 'FTR PA', group: 'Points Added', higherBetter: true, decimals: 1, showSign: true, desc: 'Free Throw Rate Points Added - Getting to the line impact vs league average' },
                                { key: 'defEfgPA', label: 'Def eFG PA', group: 'Points Added', higherBetter: true, decimals: 1, showSign: true, desc: 'Defensive eFG% Points Added - Opponent shooting suppression vs league average' },
                                { key: 'defTovPA', label: 'Frc TOV PA', group: 'Points Added', higherBetter: true, decimals: 1, showSign: true, desc: 'Forced Turnover Points Added - Turnover creation impact vs league average' },
                                { key: 'defOrebPA', label: 'Def ORB PA', group: 'Points Added', higherBetter: true, decimals: 1, showSign: true, desc: 'Defensive OREB% Points Added - Preventing second chances vs league average' },
                                { key: 'defFtRatePA', label: 'Def FTR PA', group: 'Points Added', higherBetter: true, decimals: 1, showSign: true, desc: 'Defensive FT Rate Points Added - Preventing free throws vs league average' },

                                // Raw Ratings
                                { key: 'netRtg', label: 'Net Rtg', group: 'Ratings', higherBetter: true, decimals: 1, showSign: true, desc: 'Net Rating - Raw points scored minus allowed per 100 possessions' },
                                { key: 'offRtg', label: 'Off Rtg', group: 'Ratings', higherBetter: true, decimals: 1, desc: 'Offensive Rating - Raw points scored per 100 possessions' },
                                { key: 'defRtg', label: 'Def Rtg', group: 'Ratings', higherBetter: false, decimals: 1, desc: 'Defensive Rating - Raw points allowed per 100 possessions' },

                                // Four Factors - Offense
                                { key: 'offEfg', label: 'eFG%', group: 'Off 4 Factors', higherBetter: true, decimals: 1, desc: 'Effective Field Goal% - Shooting efficiency accounting for 3-pointers (FGM + 0.5×3PM) / FGA' },
                                { key: 'offTov', label: 'TOV%', group: 'Off 4 Factors', higherBetter: false, decimals: 1, desc: 'Turnover% - Percentage of possessions ending in a turnover' },
                                { key: 'offOreb', label: 'OREB%', group: 'Off 4 Factors', higherBetter: true, decimals: 1, desc: 'Offensive Rebound% - Percentage of available offensive rebounds secured' },
                                { key: 'offFtRate', label: 'FT Rate', group: 'Off 4 Factors', higherBetter: true, decimals: 1, desc: 'Free Throw Rate - Free throw attempts per field goal attempt (FTA/FGA)' },

                                // Four Factors - Defense
                                { key: 'defEfg', label: 'Opp eFG%', group: 'Def 4 Factors', higherBetter: false, decimals: 1, desc: 'Opponent eFG% - Shooting efficiency allowed to opponents' },
                                { key: 'defTov', label: 'Frc TOV%', group: 'Def 4 Factors', higherBetter: true, decimals: 1, desc: 'Forced Turnover% - Percentage of opponent possessions ending in turnover' },
                                { key: 'defOreb', label: 'Opp OREB%', group: 'Def 4 Factors', higherBetter: false, decimals: 1, desc: 'Opponent OREB% - Offensive rebounds allowed to opponents' },
                                { key: 'defFtRate', label: 'Opp FT Rate', group: 'Def 4 Factors', higherBetter: false, decimals: 1, desc: 'Opponent FT Rate - Free throw attempts allowed per opponent FGA' },

                                // Shot Making - Offense
                                { key: 'rimPct', label: 'Rim%', group: 'Off Shot%', higherBetter: true, decimals: 1, desc: 'Rim FG% - Shooting percentage on attempts at the rim' },
                                { key: 'midPct', label: 'Mid%', group: 'Off Shot%', higherBetter: true, decimals: 1, desc: 'Mid-Range FG% - Shooting percentage on 2-point jumpers' },
                                { key: 'threePct', label: '3PT%', group: 'Off Shot%', higherBetter: true, decimals: 1, desc: 'Three-Point% - Shooting percentage from beyond the arc' },

                                // Shot Making - Defense
                                { key: 'oppRimPct', label: 'Opp Rim%', group: 'Def Shot%', higherBetter: false, decimals: 1, desc: 'Opponent Rim FG% - Rim percentage allowed to opponents' },
                                { key: 'oppMidPct', label: 'Opp Mid%', group: 'Def Shot%', higherBetter: false, decimals: 1, desc: 'Opponent Mid-Range FG% - Mid-range percentage allowed' },
                                { key: 'oppThreePct', label: 'Opp 3PT%', group: 'Def Shot%', higherBetter: false, decimals: 1, desc: 'Opponent 3PT% - Three-point percentage allowed' },

                                // Shot Volume - Offense
                                { key: 'rimVol', label: 'Rim Vol', group: 'Off Vol', higherBetter: true, decimals: 1, desc: 'Rim Volume - Percentage of shots taken at the rim' },
                                { key: 'threeVol', label: '3PT Vol', group: 'Off Vol', higherBetter: true, decimals: 1, desc: '3PT Volume - Percentage of shots from three-point range' },
                                { key: 'moreyballPct', label: 'Morey%', group: 'Off Vol', higherBetter: true, decimals: 1, desc: 'Moreyball% - Percentage of shots at rim OR from 3 (high-value shots)' },
                                { key: 'midVol', label: 'Mid Vol', group: 'Off Vol', higherBetter: false, decimals: 1, desc: 'Mid-Range Volume - Percentage of shots from mid-range (lower value)' },

                                // Shot Volume - Defense
                                { key: 'oppRimVol', label: 'Opp Rim Vol', group: 'Def Vol', higherBetter: false, decimals: 1, desc: 'Opponent Rim Volume - Rim attempts allowed as % of opponent shots' },
                                { key: 'oppThreeVol', label: 'Opp 3PT Vol', group: 'Def Vol', higherBetter: false, decimals: 1, desc: 'Opponent 3PT Volume - Three-point attempts allowed as % of shots' },
                                { key: 'oppMidVol', label: 'Opp Mid Vol', group: 'Def Vol', higherBetter: true, decimals: 1, desc: 'Opponent Mid-Range Volume - Mid-range attempts forced (lower value shots)' },

                                // Transition - Offense
                                { key: 'fastBreak100', label: 'FB/100', group: 'Trans Off', higherBetter: true, decimals: 1, desc: 'Fast Break Points per 100 possessions - Points scored in transition' },
                                { key: 'secChance100', label: '2nd/100', group: 'Trans Off', higherBetter: true, decimals: 1, desc: 'Second Chance Points per 100 possessions - Points after offensive rebounds' },
                                { key: 'ptsOffTov100', label: 'TOV Pts/100', group: 'Trans Off', higherBetter: true, decimals: 1, desc: 'Points Off Turnovers per 100 possessions - Points scored after forcing turnovers' },

                                // Transition - Defense
                                { key: 'fastBreak100V', label: 'Opp FB/100', group: 'Trans Def', higherBetter: false, decimals: 1, desc: 'Opponent Fast Break Points per 100 - Transition points allowed' },
                                { key: 'secChance100V', label: 'Opp 2nd/100', group: 'Trans Def', higherBetter: false, decimals: 1, desc: 'Opponent Second Chance Points per 100 - Points allowed after offensive rebounds' },
                                { key: 'ptsOffTov100V', label: 'Opp TOV Pts', group: 'Trans Def', higherBetter: false, decimals: 1, desc: 'Opponent Points Off Turnovers per 100 - Points allowed after turnovers' },

                                // Clutch
                                { key: 'clutchMins', label: 'Clutch Min', group: 'Clutch', higherBetter: null, decimals: 1, desc: 'Clutch Minutes - Total minutes in clutch situations (close games, late)' },
                                { key: 'clutchNetRtg', label: 'Clutch Net', group: 'Clutch', higherBetter: true, decimals: 1, showSign: true, desc: 'Clutch Net Rating - Net rating in clutch situations' },
                                { key: 'clutchOffRtg', label: 'Clutch ORtg', group: 'Clutch', higherBetter: true, decimals: 1, desc: 'Clutch Offensive Rating - Points per 100 in clutch situations' },
                                { key: 'clutchDefRtg', label: 'Clutch DRtg', group: 'Clutch', higherBetter: false, decimals: 1, desc: 'Clutch Defensive Rating - Points allowed per 100 in clutch situations' },

                                // Playmaking
                                { key: 'astPct', label: 'AST%', group: 'Misc', higherBetter: true, decimals: 1, desc: 'Assist% - Percentage of made field goals that were assisted' }
                            ];

                            // Header colors for each group (distinct color coding)
                            const groupHeaderColors = {
                                'Adjusted': 'linear-gradient(135deg, rgba(16, 185, 129, 0.6) 0%, rgba(5, 150, 105, 0.6) 100%)',
                                'Points Added': 'linear-gradient(135deg, rgba(139, 92, 246, 0.6) 0%, rgba(109, 40, 217, 0.6) 100%)',
                                'Ratings': 'linear-gradient(135deg, rgba(245, 158, 11, 0.6) 0%, rgba(217, 119, 6, 0.6) 100%)',
                                'Off 4 Factors': 'linear-gradient(135deg, rgba(34, 197, 94, 0.5) 0%, rgba(22, 163, 74, 0.5) 100%)',
                                'Def 4 Factors': 'linear-gradient(135deg, rgba(239, 68, 68, 0.5) 0%, rgba(220, 38, 38, 0.5) 100%)',
                                'Off Shot%': 'linear-gradient(135deg, rgba(59, 130, 246, 0.5) 0%, rgba(37, 99, 235, 0.5) 100%)',
                                'Def Shot%': 'linear-gradient(135deg, rgba(244, 63, 94, 0.5) 0%, rgba(225, 29, 72, 0.5) 100%)',
                                'Off Vol': 'linear-gradient(135deg, rgba(34, 211, 238, 0.5) 0%, rgba(6, 182, 212, 0.5) 100%)',
                                'Def Vol': 'linear-gradient(135deg, rgba(251, 146, 60, 0.5) 0%, rgba(234, 88, 12, 0.5) 100%)',
                                'Trans Off': 'linear-gradient(135deg, rgba(132, 204, 22, 0.5) 0%, rgba(101, 163, 13, 0.5) 100%)',
                                'Trans Def': 'linear-gradient(135deg, rgba(249, 115, 22, 0.5) 0%, rgba(194, 65, 12, 0.5) 100%)',
                                'Clutch': 'linear-gradient(135deg, rgba(236, 72, 153, 0.6) 0%, rgba(219, 39, 119, 0.6) 100%)',
                                'Misc': 'linear-gradient(135deg, rgba(100, 116, 139, 0.5) 0%, rgba(71, 85, 105, 0.5) 100%)'
                            };

                            // 6. BUILD PERCENTILE ARRAYS FOR COLOR CODING
                            const teamStatArrays = {};
                            teamStatColumns.forEach(col => {
                                teamStatArrays[col.key] = teamDataArray.map(t => t[col.key] || 0);
                            });

                            // Percentile calculation function
                            const getTeamPercentile = (value, statKey) => {
                                const arr = teamStatArrays[statKey];
                                if (!arr || arr.length === 0) return 50;
                                const sorted = [...arr].sort((a, b) => a - b);
                                const rank = sorted.filter(v => v < value).length;
                                return (rank / sorted.length) * 100;
                            };

                            // Color function (same as player leaderboard)
                            const getTeamPctColor = (pct, higherBetter) => {
                                if (higherBetter === null) return 'transparent';
                                const effectivePct = higherBetter ? pct : 100 - pct;
                                if (effectivePct >= 90) return 'rgba(34, 197, 94, 0.4)';
                                if (effectivePct >= 75) return 'rgba(34, 197, 94, 0.25)';
                                if (effectivePct >= 60) return 'rgba(234, 179, 8, 0.25)';
                                if (effectivePct >= 40) return 'rgba(100, 116, 139, 0.2)';
                                if (effectivePct >= 25) return 'rgba(249, 115, 22, 0.25)';
                                if (effectivePct >= 10) return 'rgba(239, 68, 68, 0.25)';
                                return 'rgba(239, 68, 68, 0.4)';
                            };

                            // 7. SORTING (uses component-level state: teamLbSortBy, teamLbSortAsc)

                            // Sort teams
                            const sortedTeams = [...teamDataArray].sort((a, b) => {
                                const col = teamStatColumns.find(c => c.key === teamLbSortBy);
                                const higherBetter = col ? col.higherBetter !== false : true;
                                const mult = teamLbSortAsc ? 1 : -1;
                                const aVal = a[teamLbSortBy] || 0;
                                const bVal = b[teamLbSortBy] || 0;
                                return higherBetter ? mult * (bVal - aVal) : mult * (aVal - bVal);
                            });

                            // Group columns by category for visual separation
                            const groupColors = {
                                'Adjusted': 'rgba(16, 185, 129, 0.08)',
                                'Points Added': 'rgba(139, 92, 246, 0.08)',
                                'Ratings': 'rgba(245, 158, 11, 0.08)',
                                'Off 4 Factors': 'rgba(34, 197, 94, 0.06)',
                                'Def 4 Factors': 'rgba(239, 68, 68, 0.06)',
                                'Off Shot%': 'rgba(59, 130, 246, 0.06)',
                                'Def Shot%': 'rgba(239, 68, 68, 0.06)',
                                'Off Vol': 'rgba(59, 130, 246, 0.04)',
                                'Def Vol': 'rgba(239, 68, 68, 0.04)',
                                'Trans Off': 'rgba(34, 211, 238, 0.06)',
                                'Trans Def': 'rgba(249, 115, 22, 0.06)',
                                'Clutch': 'rgba(236, 72, 153, 0.08)',
                                'Misc': 'rgba(100, 116, 139, 0.06)'
                            };

                            // 8. Filter columns by visible groups
                            const visibleColumns = teamStatColumns.filter(col => teamLbShowGroups[col.group]);

                            // Calculate section boundaries for category dividers
                            const teamSectionBoundaries = [];
                            let lastTeamGroup = null;
                            visibleColumns.forEach((col, idx) => {
                                if (col.group !== lastTeamGroup) {
                                    teamSectionBoundaries.push(idx);
                                    lastTeamGroup = col.group;
                                }
                            });

                            // Group to CSS class mapping for colored dividers
                            const groupToSectionClass = {
                                'Adjusted': 'section-adjusted',
                                'Points Added': 'section-pointsadded',
                                'Ratings': 'section-ratings',
                                'Off 4 Factors': 'section-ff_off',
                                'Def 4 Factors': 'section-ff_def',
                                'Off Shot%': 'section-shot_off',
                                'Def Shot%': 'section-shot_def',
                                'Off Vol': 'section-vol_off',
                                'Def Vol': 'section-vol_def',
                                'Trans Off': 'section-trans',
                                'Trans Def': 'section-transdef',
                                'Clutch': 'section-clutch',
                                'Misc': 'section-misc'
                            };

                            // Fullscreen container style
                            const teamLbContainerStyle = teamLbFullscreen
                                ? { position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 1000, background: '#0f172a', padding: '16px', overflow: 'auto' }
                                : {};

                            // All group names for toggles
                            const allTeamGroups = ['Adjusted', 'Points Added', 'Ratings', 'Off 4 Factors', 'Def 4 Factors', 'Off Shot%', 'Def Shot%', 'Off Vol', 'Def Vol', 'Trans Off', 'Trans Def', 'Clutch'];

                            // 9. RENDER TABLE - Modern Google-Style Design
                            return e('div', {
                                className: 'leaderboard-v2-container' + (teamLbFullscreen ? ' leaderboard-v2-fullscreen' : ''),
                                style: teamLbContainerStyle
                            },
                                // Header Bar - Google Style
                                e('div', { className: 'leaderboard-v2-header' },
                                    e('div', { className: 'leaderboard-v2-title-group' },
                                        e('h3', { className: 'leaderboard-v2-title' },
                                            e('span', { className: 'leaderboard-v2-title-icon' }, '🏀'),
                                            'Team Leaderboard'
                                        ),
                                        e('span', { className: 'leaderboard-v2-badge leaderboard-v2-badge-primary' }, nTeams + ' teams'),
                                        e('span', { style: { fontSize: '11px', color: '#64748b' } }, '• Click headers to sort')
                                    ),
                                    e('div', { className: 'leaderboard-v2-actions' },
                                        e('button', {
                                            className: 'leaderboard-v2-btn ' + (teamLbFullscreen ? 'leaderboard-v2-btn-danger' : 'leaderboard-v2-btn-default'),
                                            onClick: () => setTeamLbFullscreen(!teamLbFullscreen)
                                        }, teamLbFullscreen ? '✕ Exit' : '⛶ Expand')
                                    )
                                ),

                                // Section toggle buttons - Enhanced Preset Chips
                                e('div', { className: 'leaderboard-v2-settings', style: { padding: '12px 20px' } },
                                    e('div', { className: 'leaderboard-v2-presets' },
                                        e('span', { style: { fontSize: '10px', color: '#94a3b8', marginRight: '8px', fontWeight: '600' } }, 'SECTIONS:'),
                                        allTeamGroups.map(group => {
                                            const isActive = teamLbShowGroups[group];
                                            const chipClass = isActive
                                                ? (group.includes('Off') ? 'leaderboard-v2-mode-btn-green' : group.includes('Def') ? 'leaderboard-v2-btn-danger' : group === 'Clutch' ? 'leaderboard-v2-chip-amber' : group === 'Points Added' ? 'leaderboard-v2-chip-purple' : 'leaderboard-v2-chip-active')
                                                : 'leaderboard-v2-chip-inactive';
                                            return e('button', {
                                                key: group,
                                                className: 'leaderboard-v2-chip ' + chipClass,
                                                style: isActive ? {} : { opacity: 0.6 },
                                                onClick: () => setTeamLbShowGroups(prev => ({ ...prev, [group]: !prev[group] }))
                                            }, group);
                                        }),
                                        e('div', { className: 'leaderboard-v2-divider' }),
                                        e('button', {
                                            className: 'leaderboard-v2-chip leaderboard-v2-chip-amber',
                                            onClick: () => setTeamLbShowGroups(Object.fromEntries(allTeamGroups.map(g => [g, true])))
                                        }, '✓ All'),
                                        e('button', {
                                            className: 'leaderboard-v2-chip leaderboard-v2-chip-red',
                                            onClick: () => setTeamLbShowGroups(Object.fromEntries(allTeamGroups.map(g => [g, false])))
                                        }, '✕ Clear')
                                    )
                                ),

                                // Teams Table - Modern Data Grid
                                e('div', {
                                    id: 'team-leaderboard-table-wrapper',
                                    className: 'leaderboard-v2-table-scroll' + (teamLbFullscreen ? ' fullscreen' : '')
                                },
                                    e('table', { className: 'leaderboard-v2-table' + (mobileTeamColExpanded ? ' player-col-expanded' : '') },
                                        e('thead', null,
                                            e('tr', null,
                                                e('th', { className: 'sticky-rank' }, '#'),
                                                e('th', { className: 'sticky-player', style: { minWidth: '100px' } },
                                                    'Team',
                                                    e('span', {
                                                        className: 'mobile-col-expand-btn',
                                                        onClick: (ev) => { ev.stopPropagation(); setMobileTeamColExpanded(!mobileTeamColExpanded); }
                                                    }, mobileTeamColExpanded ? ' ◂' : ' ▸')
                                                ),
                                                e('th', null, 'G'),
                                                visibleColumns.map((col, idx) => {
                                                    const isSorted = teamLbSortBy === col.key;
                                                    const isBoundary = teamSectionBoundaries.includes(idx);
                                                    const sectionClass = groupToSectionClass[col.group] || '';
                                                    return e('th', {
                                                        key: col.key,
                                                        className: (isSorted ? 'sorted ' : '') + sectionClass + (isBoundary ? ' section-start' : ''),
                                                        onClick: () => {
                                                            if (teamLbSortBy === col.key) setTeamLbSortAsc(!teamLbSortAsc);
                                                            else { setTeamLbSortBy(col.key); setTeamLbSortAsc(false); }
                                                        },
                                                        title: col.desc || col.label
                                                    },
                                                        col.label,
                                                        !col.higherBetter && e('span', { className: 'leaderboard-v2-lower-better' }, '↓'),
                                                        isSorted && e('span', { className: 'leaderboard-v2-sort-icon' }, teamLbSortAsc ? '▲' : '▼')
                                                    );
                                                })
                                            )
                                        ),
                                        e('tbody', null,
                                            sortedTeams.map((team, idx) => {
                                                const rankClass = idx < 3 ? 'leaderboard-v2-rank leaderboard-v2-rank-top3' : idx < 10 ? 'leaderboard-v2-rank leaderboard-v2-rank-top10' : 'leaderboard-v2-rank';
                                                return e('tr', { key: team.name },
                                                    e('td', { className: 'sticky-rank' },
                                                        e('span', { className: rankClass }, idx + 1)
                                                    ),
                                                    e('td', { className: 'sticky-player' },
                                                        e('span', { className: 'leaderboard-v2-player-name' }, team.name)
                                                    ),
                                                    e('td', null, e('span', { className: 'leaderboard-v2-mins' }, team.gamesPlayed)),
                                                    visibleColumns.map((col, idx) => {
                                                        const val = team[col.key] || 0;
                                                        const pct = getTeamPercentile(val, col.key);
                                                        const effectivePct = col.higherBetter !== false ? pct : 100 - pct;
                                                        const pctClass = effectivePct >= 90 ? 'leaderboard-v2-pct-elite' : effectivePct >= 75 ? 'leaderboard-v2-pct-great' : effectivePct >= 60 ? 'leaderboard-v2-pct-good' : effectivePct >= 40 ? 'leaderboard-v2-pct-avg' : effectivePct >= 25 ? 'leaderboard-v2-pct-below' : effectivePct >= 10 ? 'leaderboard-v2-pct-poor' : 'leaderboard-v2-pct-bad';
                                                        const isBoundary = teamSectionBoundaries.includes(idx);
                                                        const sectionClass = groupToSectionClass[col.group] || '';
                                                        return e('td', {
                                                            key: col.key,
                                                            className: sectionClass + (isBoundary ? ' section-start' : '')
                                                        },
                                                            e('span', { className: 'leaderboard-v2-stat ' + pctClass }, val.toFixed(col.decimals || 1))
                                                        );
                                                    })
                                                );
                                            })
                                        )
                                    )
                                ),

                                // Legend - Modern Footer
                                e('div', { className: 'leaderboard-v2-legend' },
                                    e('span', { className: 'leaderboard-v2-legend-title' }, 'Percentile:'),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #16a34a, #15803d)' } }),
                                        '90th+'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #22c55e, #16a34a)' } }),
                                        '75-89'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #4ade80, #22c55e)' } }),
                                        '60-74'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #64748b, #475569)' } }),
                                        '40-59'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #f59e0b, #d97706)' } }),
                                        '25-39'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #f97316, #ea580c)' } }),
                                        '10-24'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-item' },
                                        e('span', { className: 'leaderboard-v2-legend-color', style: { background: 'linear-gradient(135deg, #dc2626, #b91c1c)' } }),
                                        '<10th'
                                    ),
                                    e('span', { className: 'leaderboard-v2-legend-sep' }, '|'),
                                    e('span', null, '↓ = lower is better'),
                                    e('span', { className: 'leaderboard-v2-legend-sep' }, '|'),
                                    e('span', null, 'Morey% = rim + 3'),
                                    e('span', { className: 'leaderboard-v2-legend-sep' }, '|'),
                                    e('span', null, 'PA = Points Added')
                                )
                            );
                        })() // End of Teams tab
                    ); // End of leaderboardContent
                
                // V5.12: Return either modal wrapper or direct content based on mode
                if (isTabMode) {
                    return e('div', { className: 'section', style: { padding: '24px' }}, leaderboardContent);
                }
                
                return e('div', { className: 'modal-overlay', onClick: () => setShowLeaderboard(false) },
                    e('div', { className: 'modal-content', style: { maxWidth: '1200px' }, onClick: ev => ev.stopPropagation() },
                        leaderboardContent
                    )
                );
            };


            // Player Modal
            const PlayerModal = () => { 
                if (!showModal || !playerBreakdown.length) return null; 
                const hasSeasonData = seasonData.length > 0;
                return e('div', { className: 'modal-overlay', onClick: () => setShowModal(false) }, 
                    e('div', { className: 'modal-content', onClick: ev => ev.stopPropagation() }, 
                        e('div', { className: 'modal-header' }, 
                            e('div', null, 
                                e('h2', { style: { fontSize: '24px', fontWeight: 'bold' }}, '👤 Player Breakdown (Per 75 Poss)'), 
                                e('p', { style: { marginTop: '8px', opacity: 0.8 }}, afc >= 1 ? 'Players in lineups with: ' + Object.values(selPlayers).filter(p => p !== '').join(', ') : 'All players for ' + team),
                                hasSeasonData && e('p', { style: { marginTop: '4px', fontSize: '12px', color: '#fbbf24' }}, '📈 Season comparison enabled'),
                                e('p', { style: { marginTop: '4px', fontSize: '11px', color: '#a78bfa' }}, '💡 Tip: See Player Breakdown tab for league percentiles')
                            ), 
                            e('button', { className: 'modal-close', onClick: () => setShowModal(false) }, '×')
                        ), 
                        oppQuality && e('div', { style: { background: 'rgba(124,58,237,0.15)', border: '1px solid rgba(124,58,237,0.4)', borderRadius: '8px', padding: '12px', marginBottom: '20px' }}, 
                            e('span', { style: { fontWeight: 'bold', color: '#c4b5fd' }}, '⚔️ Opp Quality: '), 
                            e('span', null, 'ORtg ' + oppQuality.oppOff.toFixed(1) + ' (', e(Pct, { val: oppQuality.pcts.oppOff, isOpp: true }), ') | DRtg ' + oppQuality.oppDef.toFixed(1) + ' (', e(Pct, { val: oppQuality.pcts.oppDef, isOpp: true }), ') | Net ' + (oppQuality.oppNet >= 0 ? '+' : '') + oppQuality.oppNet.toFixed(1))
                        ), 
                        e('p', { style: { marginBottom: '16px', fontSize: '12px', color: '#94a3b8' }}, '💡 Stats per 75 lineup possessions (Dean Oliver)', hasSeasonData && ' | 📈 Blue = lineup stats, Gray = season avg'), 
                        playerBreakdown.slice(0, 20).map((p, i) => {
                            const ss = p.seasonStats;
                            const hasS = p.hasSeason;
                            return e('div', { key: i, className: 'player-card' },
                                e('div', { className: 'player-card-header' },
                                    e(PlayerPhoto, { playerName: p.player, teamName: team || '', size: 40 }),
                                    e('div', { className: 'player-name', style: { marginBottom: 0 } }, p.player, hasS && e('span', { style: { marginLeft: '8px', fontSize: '12px', color: '#10b981' }}, '✓ Season data'))
                                ), 
                                e('div', { style: { display: 'flex', gap: '16px', marginBottom: '12px', fontSize: '13px', flexWrap: 'wrap' }}, 
                                    e('span', null, '⏱️ ' + p.minutes.toFixed(1) + ' min'),
                                    e('span', { style: { color: '#06b6d4' }}, '🎯 ' + Math.round(p.lpPoss) + ' poss'),
                                    hasS && e('span', { style: { color: '#94a3b8' }}, '(Season: ' + ss.min.toFixed(0) + ' total / ' + ss.mpg.toFixed(1) + ' MPG)'),
                                    e('span', { style: { color: '#f59e0b' }}, '📊 Usage: ' + p.usage.toFixed(1) + '%'),
                                    hasS && e('span', { style: { color: '#94a3b8' }}, '(Season USG: ' + ss.usg.toFixed(1) + '%)')
                                ), 
                                e('div', { className: 'player-stats-grid', style: { gridTemplateColumns: 'repeat(8, 1fr)' }}, 
                                    e('div', { className: 'player-stat' }, e('div', { className: 'player-stat-label' }, 'PTS/75'), e('div', { className: 'player-stat-value', style: { color: '#60a5fa' }}, p.pts75.toFixed(1)), hasS && e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Szn/40: ' + ss.pts40.toFixed(1)), hasS && e('div', { className: 'scv-delta ' + getCompClass(p.pts75 - ss.pts40, true), style: { fontSize: '9px', marginTop: '2px' }}, (p.pts75 - ss.pts40 >= 0 ? '+' : '') + (p.pts75 - ss.pts40).toFixed(1))), 
                                    e('div', { className: 'player-stat' }, e('div', { className: 'player-stat-label' }, 'REB/75'), e('div', { className: 'player-stat-value' }, p.reb75.toFixed(1)), hasS && e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Szn/40: ' + ss.reb40.toFixed(1)), hasS && e('div', { className: 'scv-delta ' + getCompClass(p.reb75 - ss.reb40, true), style: { fontSize: '9px', marginTop: '2px' }}, (p.reb75 - ss.reb40 >= 0 ? '+' : '') + (p.reb75 - ss.reb40).toFixed(1))), 
                                    e('div', { className: 'player-stat' }, e('div', { className: 'player-stat-label' }, 'OREB/75'), e('div', { className: 'player-stat-value', style: { color: '#4ade80' }}, p.oreb75.toFixed(1))), 
                                    e('div', { className: 'player-stat' }, e('div', { className: 'player-stat-label' }, 'DREB/75'), e('div', { className: 'player-stat-value', style: { color: '#60a5fa' }}, p.dreb75.toFixed(1))), 
                                    e('div', { className: 'player-stat' }, e('div', { className: 'player-stat-label' }, 'AST/75'), e('div', { className: 'player-stat-value', style: { color: '#4ade80' }}, p.ast75.toFixed(1)), hasS && e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Szn/40: ' + ss.ast40.toFixed(1)), hasS && e('div', { className: 'scv-delta ' + getCompClass(p.ast75 - ss.ast40, true), style: { fontSize: '9px', marginTop: '2px' }}, (p.ast75 - ss.ast40 >= 0 ? '+' : '') + (p.ast75 - ss.ast40).toFixed(1))), 
                                    e('div', { className: 'player-stat' }, e('div', { className: 'player-stat-label' }, 'TOV/75'), e('div', { className: 'player-stat-value', style: { color: '#f87171' }}, p.tov75.toFixed(1)), hasS && e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Szn/40: ' + ss.tov40.toFixed(1)), hasS && e('div', { className: 'scv-delta ' + getCompClass(p.tov75 - ss.tov40, false), style: { fontSize: '9px', marginTop: '2px' }}, (p.tov75 - ss.tov40 >= 0 ? '+' : '') + (p.tov75 - ss.tov40).toFixed(1))), 
                                    e('div', { className: 'player-stat' }, e('div', { className: 'player-stat-label' }, 'STL/75'), e('div', { className: 'player-stat-value' }, p.stl75.toFixed(1)), hasS && e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Szn/40: ' + ss.stl40.toFixed(1)), hasS && e('div', { className: 'scv-delta ' + getCompClass(p.stl75 - ss.stl40, true), style: { fontSize: '9px', marginTop: '2px' }}, (p.stl75 - ss.stl40 >= 0 ? '+' : '') + (p.stl75 - ss.stl40).toFixed(1))), 
                                    e('div', { className: 'player-stat' }, e('div', { className: 'player-stat-label' }, 'BLK/75'), e('div', { className: 'player-stat-value' }, p.blk75.toFixed(1)), hasS && e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Szn/40: ' + ss.blk40.toFixed(1)), hasS && e('div', { className: 'scv-delta ' + getCompClass(p.blk75 - ss.blk40, true), style: { fontSize: '9px', marginTop: '2px' }}, (p.blk75 - ss.blk40 >= 0 ? '+' : '') + (p.blk75 - ss.blk40).toFixed(1)))
                                ),
                                e('div', { style: { marginTop: '8px', padding: '6px 8px', background: 'rgba(245, 158, 11, 0.1)', borderRadius: '6px', display: 'inline-block' }},
                                    e('span', { style: { fontSize: '11px', color: '#f59e0b' }}, 'TPC/75: ', e('strong', null, (p.tpc75 || 0).toFixed(1)), ' | Raw: ' + (p.tpc || 0).toFixed(0) + ' | /100: ' + (p.tpc100 || 0).toFixed(1))
                                ),
                                e('div', { style: { marginTop: '12px' }}, 
                                    e('div', { style: { fontSize: '12px', fontWeight: 'bold', marginBottom: '8px' }}, 'Shot Profile', hasS && e('span', { style: { fontWeight: 'normal', color: '#94a3b8', marginLeft: '8px' }}, '| vs Season')), 
                                    e('div', { className: 'grid-3', style: { gap: '8px' }}, 
                                        e('div', { className: getPerfFromPct(calcTeamAvgPercentile(p.rimPct, teamAvgArrays.rimPct, true)), style: { padding: '8px', borderRadius: '6px', textAlign: 'center' }}, e('div', { style: { fontSize: '10px' }}, 'Rim'), e('div', { style: { fontSize: '16px', fontWeight: 'bold' }}, p.rimPct.toFixed(0) + '%'), e('div', { style: { fontSize: '10px', opacity: 0.7 }}, p.rimA75.toFixed(1) + ' att/75'), hasS && e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '4px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '4px' }}, 'Szn: ' + ss.seasonRimPct.toFixed(0) + '%', e('span', { className: 'scv-delta ' + getCompClass(p.rimPct - ss.seasonRimPct, true), style: { marginLeft: '4px' }}, (p.rimPct - ss.seasonRimPct >= 0 ? '+' : '') + (p.rimPct - ss.seasonRimPct).toFixed(0)))), 
                                        e('div', { className: getPerfFromPct(calcTeamAvgPercentile(p.midPct, teamAvgArrays.midPct, true)), style: { padding: '8px', borderRadius: '6px', textAlign: 'center' }}, e('div', { style: { fontSize: '10px' }}, 'Mid'), e('div', { style: { fontSize: '16px', fontWeight: 'bold' }}, p.midPct.toFixed(0) + '%'), e('div', { style: { fontSize: '10px', opacity: 0.7 }}, p.midA75.toFixed(1) + ' att/75'), hasS && e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '4px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '4px' }}, 'Szn: ' + ss.seasonMidPct.toFixed(0) + '%', e('span', { className: 'scv-delta ' + getCompClass(p.midPct - ss.seasonMidPct, true), style: { marginLeft: '4px' }}, (p.midPct - ss.seasonMidPct >= 0 ? '+' : '') + (p.midPct - ss.seasonMidPct).toFixed(0)))), 
                                        e('div', { className: getPerfFromPct(calcTeamAvgPercentile(p.threePct, teamAvgArrays.threePct, true)), style: { padding: '8px', borderRadius: '6px', textAlign: 'center' }}, e('div', { style: { fontSize: '10px' }}, '3PT'), e('div', { style: { fontSize: '16px', fontWeight: 'bold' }}, p.threePct.toFixed(0) + '%'), e('div', { style: { fontSize: '10px', opacity: 0.7 }}, p.threeA75.toFixed(1) + ' att/75'), hasS && e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '4px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '4px' }}, 'Szn: ' + ss.seasonThreePct.toFixed(0) + '%', e('span', { className: 'scv-delta ' + getCompClass(p.threePct - ss.seasonThreePct, true), style: { marginLeft: '4px' }}, (p.threePct - ss.seasonThreePct >= 0 ? '+' : '') + (p.threePct - ss.seasonThreePct).toFixed(0))))
                                    )
                                ),
                                hasS && (() => {
                                    const dPts = p.pts75 - ss.pts40, dAst = p.ast75 - ss.ast40;
                                    const dTov = p.tov75 - ss.tov40, dThree = p.threePct - ss.seasonThreePct;
                                    return e('div', { className: 'season-compare-section' },
                                        e('div', { className: 'season-compare-title' }, '📈 Lineup vs Season Average Summary'),
                                        e('div', { className: 'season-compare-grid' },
                                            e('div', { className: 'season-compare-item ' + getCardClass(dPts, true) },
                                                e('div', { className: 'season-compare-label' }, 'PTS/75'),
                                                e('div', { className: 'season-compare-values' }, e('span', { className: 'scv-lineup' }, p.pts75.toFixed(1)), e('span', { className: 'scv-season' }, '(' + ss.pts40.toFixed(1) + '/40)')),
                                                e('div', { className: 'scv-delta ' + getCompClass(dPts, true), style: { marginTop: '3px', fontSize: '11px' } }, (dPts >= 0 ? '▲ +' : '▼ ') + Math.abs(dPts).toFixed(1))
                                            ),
                                            e('div', { className: 'season-compare-item ' + getCardClass(dAst, true) },
                                                e('div', { className: 'season-compare-label' }, 'AST/75'),
                                                e('div', { className: 'season-compare-values' }, e('span', { className: 'scv-lineup' }, p.ast75.toFixed(1)), e('span', { className: 'scv-season' }, '(' + ss.ast40.toFixed(1) + '/40)')),
                                                e('div', { className: 'scv-delta ' + getCompClass(dAst, true), style: { marginTop: '3px', fontSize: '11px' } }, (dAst >= 0 ? '▲ +' : '▼ ') + Math.abs(dAst).toFixed(1))
                                            ),
                                            e('div', { className: 'season-compare-item ' + getCardClass(dTov, false) },
                                                e('div', { className: 'season-compare-label' }, 'TOV/75'),
                                                e('div', { className: 'season-compare-values' }, e('span', { className: 'scv-lineup' }, p.tov75.toFixed(1)), e('span', { className: 'scv-season' }, '(' + ss.tov40.toFixed(1) + '/40)')),
                                                e('div', { className: 'scv-delta ' + getCompClass(dTov, false), style: { marginTop: '3px', fontSize: '11px' } }, (dTov <= 0 ? '▼ ' : '▲ +') + Math.abs(dTov).toFixed(1))
                                            ),
                                            e('div', { className: 'season-compare-item ' + getCardClass(dThree, true) },
                                                e('div', { className: 'season-compare-label' }, '3PT%'),
                                                e('div', { className: 'season-compare-values' }, e('span', { className: 'scv-lineup' }, p.threePct.toFixed(0) + '%'), e('span', { className: 'scv-season' }, '(' + ss.seasonThreePct.toFixed(0) + '%)')),
                                                e('div', { className: 'scv-delta ' + getCompClass(dThree, true), style: { marginTop: '3px', fontSize: '11px' } }, (dThree >= 0 ? '▲ +' : '▼ ') + Math.abs(dThree).toFixed(0) + '%')
                                            )
                                        )
                                    );
                                })()
                            );
                        })
                    )
                ); 
            };

            // Matchups Modal
            const MatchupsModal = () => {
                if (!showMatchupsModal || !selectedLineup) return null;
                const matchups = getLineupMatchups(selectedLineup.normalizedLineup);
                return e('div', { className: 'modal-overlay', onClick: () => { setShowMatchupsModal(false); setSelectedLineup(null); } },
                    e('div', { className: 'modal-content matchup-modal', onClick: ev => ev.stopPropagation() },
                        e('div', { className: 'modal-header' },
                            e('div', null,
                                e('h2', { style: { fontSize: '20px', fontWeight: 'bold' }}, '⚔️ Lineup Matchups'),
                                e('p', { style: { marginTop: '8px', fontSize: '13px', color: '#60a5fa' }}, selectedLineup.Lineup.split(',').map(p => applyPlayerMerge(p.trim())).join(', ')),
                                e('p', { style: { marginTop: '4px', fontSize: '12px', opacity: 0.7 }}, matchups.length + ' matchups found | ' + matchups.reduce((s, m) => s + m.poss, 0).toFixed(0) + ' total possessions')
                            ),
                            e('button', { className: 'modal-close', onClick: () => { setShowMatchupsModal(false); setSelectedLineup(null); } }, '×')
                        ),
                        matchups.length === 0 ? 
                            e('p', { style: { textAlign: 'center', padding: '40px', opacity: 0.7 }}, 'No matchup data available for this lineup') :
                            e('div', { style: { overflowX: 'auto' }},
                                e('table', { className: 'matchup-table' },
                                    e('thead', null,
                                        e('tr', null,
                                            e('th', null, 'Opponent Lineup'),
                                            e('th', null, 'Team'),
                                            e('th', { style: { textAlign: 'right' }}, 'Poss'),
                                            e('th', { style: { textAlign: 'right' }}, 'Your Off'),
                                            e('th', { style: { textAlign: 'right' }}, 'Your Def'),
                                            e('th', { style: { textAlign: 'right' }}, 'Your Net'),
                                            e('th', { style: { textAlign: 'right' }}, 'Opp Season Net')
                                        )
                                    ),
                                    e('tbody', null,
                                        matchups.map((m, i) => {
                                            const yourNet = m.yourOff - m.yourDef;
                                            return e('tr', { key: i },
                                                e('td', { style: { fontSize: '11px', maxWidth: '300px', overflow: 'hidden', textOverflow: 'ellipsis' }}, 
                                                    m.oppLineup.split(',').map(p => applyPlayerMerge(p.trim())).join(', ')
                                                ),
                                                e('td', { style: { color: '#a78bfa', fontWeight: '600' }}, m.oppTeam),
                                                e('td', { style: { textAlign: 'right', fontWeight: 'bold', color: '#06b6d4' }}, m.poss.toFixed(0)),
                                                e('td', { style: { textAlign: 'right', color: '#4ade80' }}, m.yourOff.toFixed(1)),
                                                e('td', { style: { textAlign: 'right', color: '#f87171' }}, m.yourDef.toFixed(1)),
                                                e('td', { style: { textAlign: 'right', fontWeight: 'bold', color: getNetColor(yourNet) }}, yourNet.toFixed(1)),
                                                e('td', { style: { textAlign: 'right', color: m.oppSeasonNet !== null ? getNetColor(m.oppSeasonNet) : '#6b7280' }}, 
                                                    m.oppSeasonNet !== null ? m.oppSeasonNet.toFixed(1) : 'N/A'
                                                )
                                            );
                                        })
                                    )
                                )
                            )
                    )
                );
            };

            // V4.2: WOWY (With Or Without You) Component
            const WOWYSection = () => {
                // Get player initials for display (handles suffixes like Jr, III, etc.)
                const getInitialsLocal = (name) => {
                    const suffixes = ['Jr.', 'Jr', 'Sr.', 'Sr', 'II', 'III', 'IV', 'V'];
                    const parts = name.split(/[\s,]+/).filter(p => p.length > 0);
                    if (parts.length >= 2) {
                        const lastPart = parts[parts.length - 1];
                        const hasSuffix = suffixes.some(s => lastPart === s || lastPart === s + '.');
                        if (hasSuffix && parts.length > 2) {
                            return (parts[0][0] + parts[parts.length - 2][0]).toUpperCase();
                        }
                        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
                    }
                    return name.substring(0, 2).toUpperCase();
                };
                
                // V4.9.8.7.28: Get surname, handling suffixes like Jr, Jr., III, IV, V, II, Sr
                // V5.14.2: Build team players array for name disambiguation
                // V6.1: Apply merge rules
                const wowyTeamPlayersArray = useMemo(() => {
                    const allPlayers = new Set();
                    lineupData.filter(d => d.Team === team).forEach(d => {
                        if (!d.Lineup) return;
                        d.Lineup.split(',').map(p => applyPlayerMerge(p.trim())).forEach(p => allPlayers.add(p));
                    });
                    return Array.from(allPlayers);
                }, [lineupData, team, applyPlayerMerge, playerMergeRules]);

                // V5.14.2: Use global getDisplayName with team players for disambiguation
                const getSurname = (name) => getDisplayName(name, true, wowyTeamPlayersArray);

                // Toggle player selection for WOWY
                const toggleWowyPlayer = (player) => {
                    setWowyPlayers(prev => {
                        const newPlayers = prev.includes(player) 
                            ? prev.filter(p => p !== player)
                            : prev.length >= 5 ? prev : [...prev, player];
                        // Reset teammate impact if not exactly 1 player selected
                        if (newPlayers.length !== 1) {
                            setShowTeammateImpact(false);
                        }
                        return newPlayers;
                    });
                };

                // VS Starters: Compute starter analysis from stints data for WOWY filtering
                const wowyStarterAnalysis = useMemo(() => {
                    if (!showVsStarters || !stintsData.length) return { regularStarters: {}, gameStarters: {} };
                    const minGamesStarted = leaderboardTableVsStartersMinGames;
                    const playerGamesStarted = {};
                    const gameStarters = {};
                    const gameTeamStints = {};
                    stintsData.forEach(s => {
                        const gameId = s.game_id;
                        if (!gameId) return;
                        ['home', 'away'].forEach(side => {
                            const teamName = s[side + '_team'];
                            if (!teamName) return;
                            const key = gameId + '|' + teamName;
                            if (!gameTeamStints[key]) gameTeamStints[key] = { team: teamName, gameId, stints: [] };
                            gameTeamStints[key].stints.push(s);
                        });
                    });
                    Object.entries(gameTeamStints).forEach(([key, { team: tm, gameId, stints }]) => {
                        const p1Stints = stints.filter(s => parseInt(s.period) === 1);
                        if (p1Stints.length === 0) return;
                        const minStartTime = Math.min(...p1Stints.map(s => parseFloat(s.start_time) || 0));
                        const openingStint = p1Stints.find(s => (parseFloat(s.start_time) || 0) === minStartTime);
                        if (!openingStint) return;
                        const isHome = openingStint.home_team === tm;
                        const lineupStr = isHome ? openingStint.home_lineup : openingStint.away_lineup;
                        if (!lineupStr) return;
                        const players = lineupStr.split(',').map(p => applyPlayerMerge(p.trim()));
                        gameStarters[key] = new Set(players.map(p => p.toLowerCase()));
                        if (!playerGamesStarted[tm]) playerGamesStarted[tm] = {};
                        players.forEach(player => {
                            if (!player) return;
                            playerGamesStarted[tm][player] = (playerGamesStarted[tm][player] || 0) + 1;
                        });
                    });
                    const regularStarters = {};
                    Object.entries(playerGamesStarted).forEach(([teamName, players]) => {
                        regularStarters[teamName] = new Set(
                            Object.entries(players).filter(([_, count]) => count >= minGamesStarted).map(([player, _]) => player.toLowerCase())
                        );
                    });
                    return { regularStarters, gameStarters };
                }, [showVsStarters, stintsData, leaderboardTableVsStartersMinGames, applyPlayerMerge]);

                // VS Starters filter helper for WOWY
                const wowyVsStartersFilter = (s) => {
                    if (!wowyStarterAnalysis.regularStarters) return false;
                    const isHome = s.home_team === team;
                    const oppTeam = isHome ? s.away_team : s.home_team;
                    const oppLineup = isHome ? s.away_lineup : s.home_lineup;
                    const gameId = s.game_id;
                    if (!oppLineup || !oppTeam) return false;
                    // Check regular starters
                    const oppStarters = wowyStarterAnalysis.regularStarters[oppTeam] || new Set();
                    const oppPlayers = oppLineup.split(',').map(p => applyPlayerMerge(p.trim()).toLowerCase());
                    const regularStarterCount = oppPlayers.filter(p => oppStarters.has(p)).length;
                    if (regularStarterCount >= 4) return true;
                    // Check game starters
                    const gameKey = gameId + '|' + oppTeam;
                    const gameStarterSet = wowyStarterAnalysis.gameStarters[gameKey];
                    if (gameStarterSet) {
                        const gameStarterCount = oppPlayers.filter(p => gameStarterSet.has(p)).length;
                        if (gameStarterCount >= 4) return true;
                    }
                    return false;
                };

                // Calculate WOWY combinations from lineup data
                const wowyCombinations = useMemo(() => {
                    if (wowyPlayers.length === 0 || !lineupData.length) return [];
                    
                    // Generate all ON/OFF combinations for selected players
                    const generateCombinations = (players) => {
                        const combinations = [];
                        const total = Math.pow(2, players.length);
                        for (let i = 0; i < total; i++) {
                            const combo = {};
                            players.forEach((player, idx) => {
                                combo[player] = (i & (1 << idx)) !== 0 ? 'ON' : 'OFF';
                            });
                            combinations.push(combo);
                        }
                        return combinations;
                    };

                    const combinations = generateCombinations(wowyPlayers);
                    const results = [];

                    combinations.forEach(combo => {
                        // V4.9.8.7.31 FIX: Use normalizePlayerName for consistent matching
                        // V6.1: Apply merge rules before normalization
                        const onPlayers = Object.entries(combo).filter(([_, status]) => status === 'ON').map(([p]) => normalizePlayerName(applyPlayerMerge(p)));
                        const offPlayers = Object.entries(combo).filter(([_, status]) => status === 'OFF').map(([p]) => normalizePlayerName(applyPlayerMerge(p)));

                        // Filter lineups matching this combination
                        const matchingLineups = lineupData.filter(d => {
                            if (d.Team !== team) return false;
                            const lineupPlayersNorm = d.Lineup.split(',').map(p => normalizePlayerName(applyPlayerMerge(p.trim())));
                            
                            // All ON players must be in lineup (exact normalized match)
                            const hasAllOn = onPlayers.every(op => lineupPlayersNorm.includes(op));
                            // No OFF players should be in lineup (exact normalized match)
                            const hasNoOff = offPlayers.every(op => !lineupPlayersNorm.includes(op));
                            
                            return hasAllOn && hasNoOff;
                        });

                        if (matchingLineups.length === 0) {
                            results.push({ combo, lineups: 0, poss: 0, minutes: 0, stats: null });
                            return;
                        }

                        // Aggregate stats using Dean Oliver possessions
                        let totalPoss = 0, totalPossVs = 0, totalTime = 0;
                        let tFgm = 0, tFga = 0, t3pm = 0, t3pa = 0, tFta = 0, tOreb = 0, tDreb = 0, tTov = 0;
                        let tFgmV = 0, tFgaV = 0, t3pmV = 0, t3paV = 0, tFtaV = 0, tOrebV = 0, tDrebV = 0, tTovV = 0;
                        let wOff = 0, wDef = 0;

                        matchingLineups.forEach(d => {
                            const fga = parseFloat(d.FGA) || 0, oreb = parseFloat(d.OREB) || 0;
                            const tov = parseFloat(d.TOV) || 0, fta = parseFloat(d.FTA) || 0;
                            const fgaVs = parseFloat(d.FGA_VS) || 0, orebVs = parseFloat(d.OREB_VS) || 0;
                            const tovVs = parseFloat(d.TOV_VS) || 0, ftaVs = parseFloat(d.FTA_VS) || 0;
                            const poss = calcPoss(fga, oreb, tov, fta);
                            const possVs = calcPoss(fgaVs, orebVs, tovVs, ftaVs);
                            const time = parseFloat(d.TOTAL_TIME) || 0;
                            const off = parseFloat(d.OFF_RTG) || 0;
                            const def = parseFloat(d.DEF_RTG) || 0;
                            
                            totalPoss += poss;
                            totalPossVs += possVs;
                            totalTime += time;
                            
                            tFgm += parseFloat(d.FGM) || 0;
                            tFga += fga;
                            t3pm += parseFloat(d['3PM']) || 0;
                            t3pa += parseFloat(d['3PA']) || 0;
                            tFta += fta;
                            tOreb += oreb;
                            tDreb += parseFloat(d.DREB) || 0;
                            tTov += tov;
                            
                            tFgmV += parseFloat(d.FGM_VS) || 0;
                            tFgaV += fgaVs;
                            t3pmV += parseFloat(d['3PM_VS']) || 0;
                            t3paV += parseFloat(d['3PA_VS']) || 0;
                            tFtaV += ftaVs;
                            tOrebV += orebVs;
                            tDrebV += parseFloat(d.DREB_VS) || 0;
                            tTovV += tovVs;
                            
                            const combP = poss + possVs;
                            wOff += off * combP;
                            wDef += def * combP;
                        });

                        const combPoss = totalPoss + totalPossVs;
                        const combMins = totalTime / 60; // Convert seconds to minutes
                        if (combMins < wowyMinPoss) {
                            results.push({ combo, lineups: matchingLineups.length, poss: combPoss, minutes: totalTime, stats: null });
                            return;
                        }

                        const offRtg = combPoss > 0 ? wOff / combPoss : 0;
                        const defRtg = combPoss > 0 ? wDef / combPoss : 0;
                        const netRtg = offRtg - defRtg;
                        
                        // Calculate Four Factors (raw)
                        // V4.9.8.7.31 FIX: Use Basketball Reference TOV% formula for consistency
                        const offTovDenom = tFga + 0.44 * tFta + tTov;
                        const defTovDenom = tFgaV + 0.44 * tFtaV + tTovV;
                        const offEfg = tFga > 0 ? ((tFgm + 0.5 * t3pm) / tFga) * 100 : 0;
                        const offTov = offTovDenom > 0 ? (tTov / offTovDenom) * 100 : 0;
                        const offOreb = (tOreb + tDrebV) > 0 ? (tOreb / (tOreb + tDrebV)) * 100 : 0;
                        const offFtR = tFga > 0 ? (tFta / tFga) * 100 : 0;
                        
                        const defEfg = tFgaV > 0 ? ((tFgmV + 0.5 * t3pmV) / tFgaV) * 100 : 0;
                        const defTov = defTovDenom > 0 ? (tTovV / defTovDenom) * 100 : 0;
                        const defOreb = (tOrebV + tDreb) > 0 ? (tOrebV / (tOrebV + tDreb)) * 100 : 0;
                        const defFtR = tFgaV > 0 ? (tFtaV / tFgaV) * 100 : 0;
                        
                        // =======================================================================
                        // LUCK ADJUSTMENT FOR WOWY
                        // =======================================================================
                        let adjOffRtg = offRtg;
                        let adjDefRtg = defRtg;
                        let adjOffEfg = offEfg;
                        let adjDefEfg = defEfg;
                        let offLuckDelta = 0;
                        let defLuckDelta = 0;
                        
                        // Offensive luck adjustment (regress to league average 3PT%)
                        if (wowyOffLuckAdj > 0 && t3pa > 0) {
                            // Calculate league average 3PT%
                            let leagueAvg3Pct = 36; // fallback
                            if (allTeamsAverages.length > 0) {
                                const totalTpm = allTeamsAverages.reduce((sum, t) => sum + (t.tpm || 0), 0);
                                const totalTpa = allTeamsAverages.reduce((sum, t) => sum + (t.tpa || 0), 0);
                                leagueAvg3Pct = totalTpa > 0 ? (totalTpm / totalTpa) * 100 : 36;
                            }
                            
                            const actual3Pct = t3pa > 0 ? (t3pm / t3pa) * 100 : 0;
                            const expected3pm = t3pa * (leagueAvg3Pct / 100);
                            offLuckDelta = t3pm - expected3pm;
                            const adjDelta3pm = offLuckDelta * (wowyOffLuckAdj / 100);
                            
                            // Adjust offensive rating
                            const offPtsDelta = -3 * adjDelta3pm;
                            adjOffRtg = offRtg + (totalPoss > 0 ? (offPtsDelta / totalPoss) * 100 : 0);
                            
                            // Adjust offensive eFG%
                            const adj3pm = Math.max(0, t3pm - adjDelta3pm);
                            const adjFgm = Math.max(0, tFgm - adjDelta3pm);
                            adjOffEfg = tFga > 0 ? ((adjFgm + 0.5 * adj3pm) / tFga) * 100 : offEfg;
                        }
                        
                        // Defensive luck adjustment (regress opponent 3PT% to league average)
                        if (wowyDefLuckAdj > 0 && t3paV > 0) {
                            let leagueAvg3Pct = 36;
                            if (allTeamsAverages.length > 0) {
                                const totalTpm = allTeamsAverages.reduce((sum, t) => sum + (t.tpm || 0), 0);
                                const totalTpa = allTeamsAverages.reduce((sum, t) => sum + (t.tpa || 0), 0);
                                leagueAvg3Pct = totalTpa > 0 ? (totalTpm / totalTpa) * 100 : 36;
                            }
                            
                            const defExpected3pm = t3paV * (leagueAvg3Pct / 100);
                            defLuckDelta = t3pmV - defExpected3pm;
                            const defAdjDelta3pm = defLuckDelta * (wowyDefLuckAdj / 100);
                            
                            // Adjust defensive rating
                            const defPtsDelta = -3 * defAdjDelta3pm;
                            adjDefRtg = defRtg + (totalPossVs > 0 ? (defPtsDelta / totalPossVs) * 100 : 0);
                            
                            // Adjust defensive eFG%
                            const adj3pmV = Math.max(0, t3pmV - defAdjDelta3pm);
                            const adjFgmV = Math.max(0, tFgmV - defAdjDelta3pm);
                            adjDefEfg = tFgaV > 0 ? ((adjFgmV + 0.5 * adj3pmV) / tFgaV) * 100 : defEfg;
                        }
                        
                        const adjNetRtg = adjOffRtg - adjDefRtg;

                        results.push({
                            combo,
                            lineups: matchingLineups.length,
                            poss: combPoss,
                            minutes: totalTime,
                            stats: {
                                offRtg: adjOffRtg, defRtg: adjDefRtg, netRtg: adjNetRtg,
                                offEfg: adjOffEfg, offTov, offOreb, offFtR,
                                defEfg: adjDefEfg, defTov, defOreb, defFtR,
                                // Keep raw values for reference
                                rawOffRtg: offRtg, rawDefRtg: defRtg, rawNetRtg: netRtg,
                                rawOffEfg: offEfg, rawDefEfg: defEfg,
                                offLuckDelta, defLuckDelta
                            }
                        });
                    });

                    // Sort by possessions descending
                    return results.sort((a, b) => b.poss - a.poss);
                }, [wowyPlayers, lineupData, team, wowyMinPoss, wowyOffLuckAdj, wowyDefLuckAdj, allTeamsAverages]);

                // Calculate team averages for delta display
                const teamAvgForDelta = useMemo(() => {
                    const ta = allTeamsAverages.find(t => t.team === team);
                    return ta || { off: 100, def: 100, net: 0 };
                }, [allTeamsAverages, team]);

                // V4.9.8.7: Teammate Impact Analysis - calculate on/off for selected player with each teammate
                const teammateImpactData = useMemo(() => {
                    if (wowyPlayers.length !== 1 || !showTeammateImpact || !lineupData.length) return null;

                    const selectedPlayer = wowyPlayers[0];

                    // Calculate league average 3PT% for luck adjustment
                    let leagueAvg3Pct = 36; // fallback
                    if (allTeamsAverages.length > 0) {
                        const totalTpm = allTeamsAverages.reduce((sum, t) => sum + (t.tpm || 0), 0);
                        const totalTpa = allTeamsAverages.reduce((sum, t) => sum + (t.tpa || 0), 0);
                        leagueAvg3Pct = totalTpa > 0 ? (totalTpm / totalTpa) * 100 : 36;
                    }

                    // V4.9.8.7.31 FIX: Use normalizePlayerName for consistent matching
                    const selectedPlayerNorm = normalizePlayerName(selectedPlayer);

                    // V5.21: BPM 2.0 coefficients from hackastat.eu using percentage-based stats
                    // Raw BPM coefficients
                    const BPM_COEFFS = {
                        a: 0.123391,  // ReMPG = MP / (GP + 2)
                        b: 0.119597,  // ORB%
                        c: -0.151287, // DRB%
                        d: 1.255644,  // STL%
                        e: 0.531838,  // BLK%
                        f: -0.305868, // AST%
                        g: 0.921292,  // USG% × TOV% (subtracted)
                        h: 0.711217,  // Scoring coefficient
                        i: 0.017022,  // AST interaction
                        j: 0.297639,  // 3PAr interaction
                        k: 0.213485,  // Threshold scoring
                        l: 0.725930   // sqrt(AST% × TRB%)
                    };
                    // OBPM coefficients
                    const OBPM_COEFFS = {
                        a: 0.064448,
                        b: 0.211125,
                        c: -0.107545,
                        d: 0.346513,
                        e: -0.052476,
                        f: -0.041787,
                        g: 0.932965,
                        h: 0.687359,
                        i: 0.007952,
                        j: 0.374706,
                        k: -0.181891,
                        l: 0.239862
                    };

                    // League average 3PAr for BPM calculation
                    const lgAvg3PAr = 0.40; // ~40% of FGA are 3PA in modern NBA

                    // Helper to calculate possessions
                    const calcPossLocal = (fga, oreb, tov, fta) => fga - oreb + tov + 0.44 * fta;

                    // V5.19: Helper to normalize lineup string for matching
                    const normalizeLineupString = (lineup) => {
                        if (!lineup) return '';
                        return lineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',');
                    };

                    // V5.19: Helper to construct full lineup from Player + Teammates columns
                    const getFullLineupFromPlayerData = (pd) => {
                        const player = pd.Player || '';
                        const teammates = pd.Teammates || '';
                        if (!player || !teammates) return '';
                        // Combine player with teammates to form full 5-player lineup
                        return player + ',' + teammates;
                    };

                    // Helper to get individual player box stats from playerData for specific lineups
                    // V5.19: Uses Player + Teammates to construct lineup, then matches against lineupData lineups
                    // V5.20: Also returns lineup possessions from lineupData for per 100 calculation
                    // V5.21: Also collects lineup context (team totals) for percentage calculations
                    const getPlayerIndividualStats = (player, lineups) => {
                        if (!playerData.length) {
                            console.warn('[BPM IMPACT] playerData (player_lineup_stats_enhanced) not loaded');
                            return null;
                        }

                        const playerNorm = normalizePlayerName(player);
                        // Create a Set of normalized lineup strings for fast lookup (from lineupData)
                        const normalizedLineupSet = new Set(lineups.map(l => normalizeLineupString(l.Lineup)));

                        const relevantPlayerRows = playerData.filter(pd => {
                            if (!pd.Player) return false;
                            const pdNorm = normalizePlayerName(pd.Player);
                            if (pdNorm !== playerNorm) return false;
                            if (pd.Team !== team) return false;
                            // V5.19: Construct full lineup from Player + Teammates, then normalize and match
                            const fullLineup = getFullLineupFromPlayerData(pd);
                            const pdLineupNorm = normalizeLineupString(fullLineup);
                            return normalizedLineupSet.has(pdLineupNorm);
                        });

                        if (!relevantPlayerRows.length) {
                            return null;
                        }

                        // V5.21: Get ALL players' stats for matching lineups (for team context)
                        const allPlayersInLineups = playerData.filter(pd => {
                            if (!pd.Player || pd.Team !== team) return false;
                            const fullLineup = getFullLineupFromPlayerData(pd);
                            const pdLineupNorm = normalizeLineupString(fullLineup);
                            return normalizedLineupSet.has(pdLineupNorm);
                        });

                        // V5.21: Calculate lineup totals from lineupData for percentage denominators
                        const lineupTotals = lineups.reduce((acc, l) => {
                            const fga = parseFloat(l.FGA) || 0;
                            const oreb = parseFloat(l.OREB) || 0;
                            const dreb = parseFloat(l.DREB) || 0;
                            const tov = parseFloat(l.TOV) || 0;
                            const fta = parseFloat(l.FTA) || 0;
                            const fgm = parseFloat(l.FGM) || 0;
                            const fgaV = parseFloat(l.FGA_VS) || 0;
                            const orebV = parseFloat(l.OREB_VS) || 0;
                            const drebV = parseFloat(l.DREB_VS) || 0;
                            const poss = parseFloat(l.POSS) || calcPossLocal(fga, oreb, tov, fta);
                            const possV = parseFloat(l.POSS_VS) || calcPossLocal(fgaV, orebV, parseFloat(l.TOV_VS) || 0, parseFloat(l.FTA_VS) || 0);
                            return {
                                fga: acc.fga + fga,
                                fgm: acc.fgm + fgm,
                                oreb: acc.oreb + oreb,
                                dreb: acc.dreb + dreb,
                                tov: acc.tov + tov,
                                fta: acc.fta + fta,
                                poss: acc.poss + poss,
                                possV: acc.possV + possV,
                                orebV: acc.orebV + orebV, // Opponent OREB = missed shots available for team DREB
                                drebV: acc.drebV + drebV,
                                fgaV: acc.fgaV + fgaV,
                                mins: acc.mins + (parseFloat(l.TOTAL_TIME) || 0) / 60
                            };
                        }, { fga: 0, fgm: 0, oreb: 0, dreb: 0, tov: 0, fta: 0, poss: 0, possV: 0, orebV: 0, drebV: 0, fgaV: 0, mins: 0 });

                        // V5.21: Calculate team FGM for AST% denominator (from all players in these lineups)
                        const teamFgm = allPlayersInLineups.reduce((sum, pd) => sum + (parseFloat(pd.FGM) || 0), 0);

                        const playerStats = relevantPlayerRows.reduce((acc, pd) => ({
                            pts: acc.pts + (parseFloat(pd.PTS) || 0),
                            fga: acc.fga + (parseFloat(pd.FGA) || 0),
                            fgm: acc.fgm + (parseFloat(pd.FGM) || 0),
                            tpa: acc.tpa + (parseFloat(pd['3PA']) || 0),
                            tpm: acc.tpm + (parseFloat(pd['3PM']) || 0),
                            fta: acc.fta + (parseFloat(pd.FTA) || 0),
                            ftm: acc.ftm + (parseFloat(pd.FTM) || 0),
                            oreb: acc.oreb + (parseFloat(pd.OREB) || 0),
                            dreb: acc.dreb + (parseFloat(pd.DREB) || 0),
                            ast: acc.ast + (parseFloat(pd.AST) || 0),
                            stl: acc.stl + (parseFloat(pd.STL) || 0),
                            blk: acc.blk + (parseFloat(pd.BLK) || 0),
                            tov: acc.tov + (parseFloat(pd.TOV) || 0),
                            mins: acc.mins + (parseFloat(pd.Minutes) || parseFloat(pd.MIN) || (parseFloat(pd.TOTAL_TIME) || 0) / 60 || 0),
                            gp: acc.gp + 1 // Count rows as proxy for games played in these lineups
                        }), { pts: 0, fga: 0, fgm: 0, tpa: 0, tpm: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, mins: 0, gp: 0 });

                        // V5.21: Return player stats with lineup context for BPM 2.0 percentage calculations
                        return { ...playerStats, lineupTotals, teamFgm };
                    };

                    // V5.21: Calculate BPM 2.0 using percentage-based stats from hackastat.eu
                    // Uses lineup context for team-level denominators
                    const calcMyersBpm = (pStats) => {
                        if (!pStats || !pStats.lineupTotals) return null;
                        const lt = pStats.lineupTotals;
                        if (lt.poss < 1 || lt.mins < 0.1) return null;

                        // Calculate percentage stats using lineup context as "team"
                        // ReMPG = MP / (GP + 2) - using minutes and lineup count as proxy
                        const reMpg = pStats.mins / (pStats.gp + 2);

                        // ORB% = Player OREB / (Team OREB opportunities)
                        // OREB opportunities = Team OREB + Opponent DREB (missed shots rebounded)
                        const orebOpps = lt.oreb + lt.drebV;
                        const orbPct = orebOpps > 0 ? (pStats.oreb / orebOpps) * 100 : 0;

                        // DRB% = Player DREB / (Team DREB opportunities)
                        // DREB opportunities = Team DREB + Opponent OREB
                        const drebOpps = lt.dreb + lt.orebV;
                        const drbPct = drebOpps > 0 ? (pStats.dreb / drebOpps) * 100 : 0;

                        // TRB% for versatility term
                        const trbPct = (orebOpps + drebOpps) > 0 ? ((pStats.oreb + pStats.dreb) / (orebOpps + drebOpps)) * 100 : 0;

                        // STL% = Player STL / Opponent possessions
                        const stlPct = lt.possV > 0 ? (pStats.stl / lt.possV) * 100 : 0;

                        // BLK% = Player BLK / Opponent 2PT FGA (estimate as 60% of FGA)
                        const opp2pa = lt.fgaV * 0.6;
                        const blkPct = opp2pa > 0 ? (pStats.blk / opp2pa) * 100 : 0;

                        // AST% = Player AST / Teammate FGM (excluding own FGM)
                        const tmFgmExcludingSelf = pStats.teamFgm - pStats.fgm;
                        const astPct = tmFgmExcludingSelf > 0 ? (pStats.ast / tmFgmExcludingSelf) * 100 : 0;

                        // USG% = (FGA + 0.44*FTA + TOV) / Team possessions while on court
                        const playerPossUsed = pStats.fga + 0.44 * pStats.fta + pStats.tov;
                        const usgPct = lt.poss > 0 ? (playerPossUsed / lt.poss) * 100 : 0;

                        // TOV% = TOV / Possessions used
                        const tovPct = playerPossUsed > 0 ? (pStats.tov / playerPossUsed) * 100 : 0;

                        // TS% = PTS / (2 * (FGA + 0.44 * FTA))
                        const tsa = 2 * (pStats.fga + 0.44 * pStats.fta);
                        const tsPct = tsa > 0 ? (pStats.pts / tsa) * 100 : 0;

                        // Team TS% from lineup totals
                        const teamTsa = 2 * (lt.fga + 0.44 * lt.fta);
                        const teamTsPct = teamTsa > 0 ? ((lt.fgm * 2 + (lt.fga > 0 ? (lt.fgm / lt.fga) * lt.fga * 0.5 : 0)) / teamTsa) * 100 : 50;

                        // 3PAr = 3PA / FGA
                        const threePAr = pStats.fga > 0 ? pStats.tpa / pStats.fga : 0;

                        // Calculate Raw BPM using BPM 2.0 formula
                        // Term 1: a * ReMPG
                        const term1 = BPM_COEFFS.a * reMpg;
                        // Term 2: b * ORB%
                        const term2 = BPM_COEFFS.b * orbPct;
                        // Term 3: c * DRB%
                        const term3 = BPM_COEFFS.c * drbPct;
                        // Term 4: d * STL%
                        const term4 = BPM_COEFFS.d * stlPct;
                        // Term 5: e * BLK%
                        const term5 = BPM_COEFFS.e * blkPct;
                        // Term 6: f * AST%
                        const term6 = BPM_COEFFS.f * astPct;
                        // Term 7: -g * USG% * TOV%
                        const term7 = -BPM_COEFFS.g * (usgPct / 100) * tovPct;
                        // Term 8: Scoring = h * USG% * (1 - TOV%/100) * [2*(TS% - TmTS%)/100 + i*AST%/100 + j*(3PAr - lg3PAr) - k]
                        const scoringTerm = BPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                            (2 * (tsPct - teamTsPct) / 100 + BPM_COEFFS.i * astPct / 100 + BPM_COEFFS.j * (threePAr - lgAvg3PAr) - BPM_COEFFS.k);
                        // Term 9: l * sqrt(AST% * TRB%)
                        const term9 = BPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;

                        const rawBpm = term1 + term2 + term3 + term4 + term5 + term6 + term7 + scoringTerm + term9;

                        // Calculate OBPM with OBPM coefficients
                        const oTerm1 = OBPM_COEFFS.a * reMpg;
                        const oTerm2 = OBPM_COEFFS.b * orbPct;
                        const oTerm3 = OBPM_COEFFS.c * drbPct;
                        const oTerm4 = OBPM_COEFFS.d * stlPct;
                        const oTerm5 = OBPM_COEFFS.e * blkPct;
                        const oTerm6 = OBPM_COEFFS.f * astPct;
                        const oTerm7 = -OBPM_COEFFS.g * (usgPct / 100) * tovPct;
                        const oScoringTerm = OBPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                            (2 * (tsPct - teamTsPct) / 100 + OBPM_COEFFS.i * astPct / 100 + OBPM_COEFFS.j * (threePAr - lgAvg3PAr) - OBPM_COEFFS.k);
                        const oTerm9 = OBPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;

                        const rawObpm = oTerm1 + oTerm2 + oTerm3 + oTerm4 + oTerm5 + oTerm6 + oTerm7 + oScoringTerm + oTerm9;

                        // DBPM = BPM - OBPM
                        const rawDbpm = rawBpm - rawObpm;

                        return { bpm: rawBpm, obpm: rawObpm, dbpm: rawDbpm };
                    };

                    // Get all teammates (other players who have played with the selected player) - V6.1: Apply merge rules
                    const teammates = new Set();
                    lineupData.filter(d => d.Team === team).forEach(d => {
                        if (!d.Lineup) return;
                        const lineupPlayers = d.Lineup.split(',').map(p => applyPlayerMerge(p.trim()));
                        const lineupPlayersNorm = lineupPlayers.map(p => normalizePlayerName(p));
                        const hasSelected = lineupPlayersNorm.includes(selectedPlayerNorm);
                        if (hasSelected) {
                            lineupPlayers.forEach((p, idx) => {
                                if (lineupPlayersNorm[idx] !== selectedPlayerNorm) {
                                    teammates.add(p);
                                }
                            });
                        }
                    });

                    const results = [];

                    // For each teammate, calculate stats when BOTH are on court vs when ONLY selected player is on
                    teammates.forEach(teammate => {
                        const teammateNorm = normalizePlayerName(teammate);

                        // Both ON: Selected player ON, Teammate ON
                        const bothOnLineups = lineupData.filter(d => {
                            if (d.Team !== team) return false;
                            const lpNorm = d.Lineup ? d.Lineup.split(',').map(p => normalizePlayerName(p.trim())) : [];
                            const hasSelected = lpNorm.includes(selectedPlayerNorm);
                            const hasTeammate = lpNorm.includes(teammateNorm);
                            return hasSelected && hasTeammate;
                        });

                        // Solo: Selected player ON, Teammate OFF
                        const soloLineups = lineupData.filter(d => {
                            if (d.Team !== team) return false;
                            const lpNorm = d.Lineup ? d.Lineup.split(',').map(p => normalizePlayerName(p.trim())) : [];
                            const hasSelected = lpNorm.includes(selectedPlayerNorm);
                            const hasTeammate = lpNorm.includes(teammateNorm);
                            return hasSelected && !hasTeammate;
                        });
                        
                        // Calculate aggregated stats for each scenario WITH luck adjustment and Four Factors
                        const calcScenarioStats = (lineups) => {
                            if (lineups.length === 0) return null;
                            let tPoss = 0, tPossV = 0, tPts = 0, tPtsV = 0;
                            let t3pm = 0, t3pa = 0, t3pmV = 0, t3paV = 0;
                            // Four Factors data
                            let tFgm = 0, tFga = 0, tFgmV = 0, tFgaV = 0;
                            let tOreb = 0, tDreb = 0, tOrebV = 0, tDrebV = 0;
                            let tTov = 0, tTovV = 0;
                            let tFta = 0, tFtaV = 0;
                            // Track actual minutes from MIN field
                            let tMins = 0;

                            lineups.forEach(d => {
                                const fga = parseFloat(d.FGA)||0, oreb = parseFloat(d.OREB)||0, tov = parseFloat(d.TOV)||0, fta = parseFloat(d.FTA)||0;
                                const fgaV = parseFloat(d.FGA_VS)||0, orebV = parseFloat(d.OREB_VS)||0, tovV = parseFloat(d.TOV_VS)||0, ftaV = parseFloat(d.FTA_VS)||0;
                                const dreb = parseFloat(d.DREB)||0, drebV = parseFloat(d.DREB_VS)||0;
                                const fgm = parseFloat(d.FGM)||0, fgmV = parseFloat(d.FGM_VS)||0;

                                const poss = calcPoss(fga, oreb, tov, fta);
                                const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                                const pts = parseFloat(d.PTS) || (fgm*2 + (parseFloat(d['3PM'])||0) + (parseFloat(d.FTM)||0));
                                const ptsV = parseFloat(d.PTS_VS) || (fgmV*2 + (parseFloat(d['3PM_VS'])||0) + (parseFloat(d.FTM_VS)||0));

                                tPoss += poss;
                                tPossV += possV;
                                tPts += pts;
                                tPtsV += ptsV;

                                // Accumulate actual minutes from MIN field (or TOTAL_TIME in seconds)
                                const minVal = parseFloat(d.MIN) || (parseFloat(d.TOTAL_TIME) || 0) / 60;
                                tMins += minVal;

                                // Collect shooting data
                                t3pm += parseFloat(d['3PM']) || 0;
                                t3pa += parseFloat(d['3PA']) || 0;
                                t3pmV += parseFloat(d['3PM_VS']) || 0;
                                t3paV += parseFloat(d['3PA_VS']) || 0;

                                // Collect Four Factors data
                                tFgm += fgm; tFga += fga;
                                tFgmV += fgmV; tFgaV += fgaV;
                                tOreb += oreb; tDreb += dreb;
                                tOrebV += orebV; tDrebV += drebV;
                                tTov += tov; tTovV += tovV;
                                tFta += fta; tFtaV += ftaV;
                            });

                            const avgPoss = (tPoss + tPossV) / 2;
                            if (tMins < wowyMinPoss) return null;
                            
                            // Raw ratings
                            const rawOffRtg = tPoss > 0 ? (tPts / tPoss) * 100 : 0;
                            const rawDefRtg = tPossV > 0 ? (tPtsV / tPossV) * 100 : 0;
                            
                            // Four Factors calculations
                            // V4.9.8.7.31 FIX: Use Basketball Reference TOV% formula for consistency
                            const offTovDenom = tFga + 0.44 * tFta + tTov;
                            const defTovDenom = tFgaV + 0.44 * tFtaV + tTovV;
                            const offEfg = tFga > 0 ? ((tFgm + 0.5 * t3pm) / tFga) * 100 : 0;
                            const offTov = offTovDenom > 0 ? (tTov / offTovDenom) * 100 : 0;
                            const offOreb = (tOreb + tDrebV) > 0 ? (tOreb / (tOreb + tDrebV)) * 100 : 0;
                            const offFtr = tFga > 0 ? (tFta / tFga) * 100 : 0;
                            
                            const defEfg = tFgaV > 0 ? ((tFgmV + 0.5 * t3pmV) / tFgaV) * 100 : 0;
                            const defTov = defTovDenom > 0 ? (tTovV / defTovDenom) * 100 : 0;
                            const defOreb = (tOrebV + tDreb) > 0 ? (tOrebV / (tOrebV + tDreb)) * 100 : 0;
                            const defFtr = tFgaV > 0 ? (tFtaV / tFgaV) * 100 : 0;
                            
                            // Apply luck adjustment
                            let adjOffRtg = rawOffRtg;
                            let adjDefRtg = rawDefRtg;
                            let adjOffEfg = offEfg;
                            let adjDefEfg = defEfg;
                            
                            // Offensive luck adjustment
                            if (wowyOffLuckAdj > 0 && t3pa > 0) {
                                const expected3pm = t3pa * (leagueAvg3Pct / 100);
                                const offLuckDelta = t3pm - expected3pm;
                                const adjDelta3pm = offLuckDelta * (wowyOffLuckAdj / 100);
                                const offPtsDelta = -3 * adjDelta3pm;
                                adjOffRtg = rawOffRtg + (tPoss > 0 ? (offPtsDelta / tPoss) * 100 : 0);
                                // Adjust eFG%
                                const adj3pm = Math.max(0, t3pm - adjDelta3pm);
                                const adjFgm = Math.max(0, tFgm - adjDelta3pm);
                                adjOffEfg = tFga > 0 ? ((adjFgm + 0.5 * adj3pm) / tFga) * 100 : offEfg;
                            }
                            
                            // Defensive luck adjustment
                            if (wowyDefLuckAdj > 0 && t3paV > 0) {
                                const defExpected3pm = t3paV * (leagueAvg3Pct / 100);
                                const defLuckDelta = t3pmV - defExpected3pm;
                                const defAdjDelta3pm = defLuckDelta * (wowyDefLuckAdj / 100);
                                const defPtsDelta = -3 * defAdjDelta3pm;
                                adjDefRtg = rawDefRtg + (tPossV > 0 ? (defPtsDelta / tPossV) * 100 : 0);
                                // Adjust defensive eFG%
                                const adj3pmV = Math.max(0, t3pmV - defAdjDelta3pm);
                                const adjFgmV = Math.max(0, tFgmV - defAdjDelta3pm);
                                adjDefEfg = tFgaV > 0 ? ((adjFgmV + 0.5 * adj3pmV) / tFgaV) * 100 : defEfg;
                            }
                            
                            // V5.13: Calculate simplified BPM using Myers' linear method
                            // BPM estimates contribution per 100 possessions vs league average
                            // Using Four Factors to approximate offensive/defensive contribution
                            // League averages: eFG% ~53%, TOV% ~13%, OREB% ~25%, FTR ~25%, ORtg ~112, DRtg ~112
                            const leagueAvgOffRtg = 112;
                            const leagueAvgDefRtg = 112;
                            const leagueAvgEfg = 53;
                            const leagueAvgTov = 13;
                            const leagueAvgOreb = 25;
                            const leagueAvgFtr = 25;

                            // OBPM: measures offensive contribution above average
                            // Weighted combination of: shooting efficiency, ball security, offensive rebounding, free throws
                            const efgContrib = (adjOffEfg - leagueAvgEfg) * 0.6;  // eFG% impact
                            const tovContrib = (leagueAvgTov - offTov) * 0.4;     // Lower TOV% is better
                            const orebContrib = (offOreb - leagueAvgOreb) * 0.15; // OREB% impact
                            const ftrContrib = (offFtr - leagueAvgFtr) * 0.08;    // FTR impact
                            const obpm = efgContrib + tovContrib + orebContrib + ftrContrib;

                            // DBPM: measures defensive contribution above average
                            // Weighted combination of: opponent shooting, forcing turnovers, defensive rebounding, opponent FT
                            const defEfgContrib = (leagueAvgEfg - adjDefEfg) * 0.5;  // Lower opp eFG% is better
                            const defTovContrib = (defTov - leagueAvgTov) * 0.35;    // Higher opp TOV% is better
                            const defOrebContrib = (leagueAvgOreb - defOreb) * 0.12; // Lower opp OREB% is better
                            const defFtrContrib = (leagueAvgFtr - defFtr) * 0.06;    // Lower opp FTR is better
                            const dbpm = defEfgContrib + defTovContrib + defOrebContrib + defFtrContrib;

                            // Total BPM
                            const bpm = obpm + dbpm;

                            return {
                                poss: avgPoss,
                                mins: tMins,  // Actual minutes from MIN field
                                offRtg: adjOffRtg,
                                defRtg: adjDefRtg,
                                netRtg: adjOffRtg - adjDefRtg,
                                rawOffRtg,
                                rawDefRtg,
                                rawNetRtg: rawOffRtg - rawDefRtg,
                                // Four Factors
                                offEfg: adjOffEfg, offTov, offOreb, offFtr,
                                defEfg: adjDefEfg, defTov, defOreb, defFtr,
                                rawOffEfg: offEfg, rawDefEfg: defEfg,
                                // V5.13: BPM metrics
                                bpm, obpm, dbpm,
                                lineups: lineups.length
                            };
                        };
                        
                        const bothStats = calcScenarioStats(bothOnLineups);
                        const soloStats = calcScenarioStats(soloLineups);

                        // V5.16: Calculate FIRST PLAYER'S individual BPM delta using Myers method
                        // This shows how the selected player's personal stats-based BPM changes
                        // when playing WITH vs WITHOUT the teammate
                        const p1StatsWith = getPlayerIndividualStats(selectedPlayer, bothOnLineups);
                        const p1StatsWithout = getPlayerIndividualStats(selectedPlayer, soloLineups);
                        const p1BpmWith = calcMyersBpm(p1StatsWith);
                        const p1BpmWithout = calcMyersBpm(p1StatsWithout);

                        // Calculate individual BPM delta (first player's on-off BPM)
                        let individualBpmDelta = null;
                        if (p1BpmWith && p1BpmWithout) {
                            individualBpmDelta = {
                                bpm: p1BpmWith.bpm - p1BpmWithout.bpm,
                                obpm: p1BpmWith.obpm - p1BpmWithout.obpm,
                                dbpm: p1BpmWith.dbpm - p1BpmWithout.dbpm
                            };
                        }

                        // V5.23: Calculate PER for both scenarios
                        const calcPER = (pStats, lineupTotals) => {
                            if (!pStats || pStats.mins < 0.1) return null;
                            const lt = lineupTotals || {};
                            const teamPace = lt.mins > 0 ? ((lt.poss || 0) / lt.mins) * 48 : 100;
                            const leagueAvgPace = 100;
                            const paceFactor = leagueAvgPace / Math.max(teamPace, 50);
                            const pts = pStats.pts || 0;
                            const reb = (pStats.oreb || 0) + (pStats.dreb || 0);
                            const ast = pStats.ast || 0;
                            const stl = pStats.stl || 0;
                            const blk = pStats.blk || 0;
                            const missedFg = (pStats.fga || 0) - (pStats.fgm || 0);
                            const missedFt = (pStats.fta || 0) - (pStats.ftm || 0);
                            const tov = pStats.tov || 0;
                            return pStats.mins > 0 ?
                                ((pts + reb + ast * 1.5 + stl * 2 + blk * 2 - missedFg - missedFt * 0.5 - tov * 1.5) / pStats.mins) * 15 * paceFactor : 0;
                        };
                        const p1PerWith = p1StatsWith ? calcPER(p1StatsWith, p1StatsWith.lineupTotals) : null;
                        const p1PerWithout = p1StatsWithout ? calcPER(p1StatsWithout, p1StatsWithout.lineupTotals) : null;
                        const perDelta = (p1PerWith !== null && p1PerWithout !== null) ? p1PerWith - p1PerWithout : null;

                        if (bothStats || soloStats) {
                            results.push({
                                teammate,
                                bothOn: bothStats ? {
                                    ...bothStats,
                                    // V5.17: Add first player's individual BPM when WITH teammate (no fallback)
                                    p1Bpm: p1BpmWith ? p1BpmWith.bpm : null,
                                    p1Obpm: p1BpmWith ? p1BpmWith.obpm : null,
                                    p1Dbpm: p1BpmWith ? p1BpmWith.dbpm : null,
                                    // V5.23: Add PER when WITH teammate
                                    p1Per: p1PerWith
                                } : null,
                                solo: soloStats ? {
                                    ...soloStats,
                                    // V5.17: Add first player's individual BPM when WITHOUT teammate (no fallback)
                                    p1Bpm: p1BpmWithout ? p1BpmWithout.bpm : null,
                                    p1Obpm: p1BpmWithout ? p1BpmWithout.obpm : null,
                                    p1Dbpm: p1BpmWithout ? p1BpmWithout.dbpm : null,
                                    // V5.23: Add PER when WITHOUT teammate
                                    p1Per: p1PerWithout
                                } : null,
                                // Calculate the delta (impact of having teammate on court)
                                delta: bothStats && soloStats ? {
                                    offRtg: bothStats.offRtg - soloStats.offRtg,
                                    defRtg: bothStats.defRtg - soloStats.defRtg,
                                    netRtg: bothStats.netRtg - soloStats.netRtg,
                                    // V5.17: Use FIRST PLAYER'S individual BPM delta (Myers method) - NO FALLBACK
                                    // Shows how selected player's personal BPM changes with/without teammate
                                    // Returns null if player_lineup_stats_enhanced data not available
                                    bpm: individualBpmDelta ? individualBpmDelta.bpm : null,
                                    obpm: individualBpmDelta ? individualBpmDelta.obpm : null,
                                    dbpm: individualBpmDelta ? individualBpmDelta.dbpm : null,
                                    // V5.23: PER delta
                                    per: perDelta
                                } : null
                            });
                        }
                    });

                    // Sort by delta net rating (best teammate impact first)
                    return results.sort((a, b) => {
                        const aDelta = a.delta?.netRtg ?? -999;
                        const bDelta = b.delta?.netRtg ?? -999;
                        return bDelta - aDelta;
                    });
                }, [wowyPlayers, showTeammateImpact, lineupData, team, wowyMinPoss, wowyOffLuckAdj, wowyDefLuckAdj, allTeamsAverages, playerData]);

                // V4.9.8.7.28: Best N-Player Combinations Analysis
                const bestCombosData = useMemo(() => {
                    if (!showBestCombos || !lineupData.length) return null;
                    
                    // Get all unique players for this team - V6.1: Apply merge rules
                    const allPlayers = new Set();
                    lineupData.filter(d => d.Team === team).forEach(d => {
                        if (!d.Lineup) return;
                        d.Lineup.split(',').map(p => applyPlayerMerge(p.trim())).forEach(p => allPlayers.add(p));
                    });
                    const playerList = Array.from(allPlayers);
                    
                    // Generate all N-player combinations
                    const generateCombinations = (arr, n) => {
                        if (n === 1) return arr.map(el => [el]);
                        const combos = [];
                        for (let i = 0; i <= arr.length - n; i++) {
                            const head = arr.slice(i, i + 1);
                            const tailCombos = generateCombinations(arr.slice(i + 1), n - 1);
                            tailCombos.forEach(tail => combos.push([...head, ...tail]));
                        }
                        return combos;
                    };
                    
                    const combos = generateCombinations(playerList, bestCombosSize);
                    
                    // Calculate league average 3PT%
                    let leagueAvg3Pct = 36;
                    if (allTeamsAverages.length > 0) {
                        const totalTpm = allTeamsAverages.reduce((sum, t) => sum + (t.tpm || 0), 0);
                        const totalTpa = allTeamsAverages.reduce((sum, t) => sum + (t.tpa || 0), 0);
                        leagueAvg3Pct = totalTpa > 0 ? (totalTpm / totalTpa) * 100 : 36;
                    }
                    
                    // Calculate stats for each combination
                    const results = combos.map(players => {
                        const playersLower = players.map(p => p.toLowerCase());
                        
                        // Find lineups containing ALL players in this combination
                        const matchingLineups = lineupData.filter(d => {
                            if (d.Team !== team) return false;
                            const lineupPlayers = d.Lineup ? d.Lineup.split(',').map(p => p.trim().toLowerCase()) : [];
                            return playersLower.every(cp => lineupPlayers.some(lp => lp.includes(cp) || cp.includes(lp)));
                        });
                        
                        if (matchingLineups.length === 0) return null;
                        
                        // Aggregate stats
                        let tPoss = 0, tPossV = 0, tPts = 0, tPtsV = 0, tTime = 0;
                        let tFgm = 0, tFga = 0, t3pm = 0, t3pa = 0, tFta = 0, tFtm = 0;
                        let tOreb = 0, tDreb = 0, tTov = 0;
                        let tFgmV = 0, tFgaV = 0, t3pmV = 0, t3paV = 0, tFtaV = 0, tFtmV = 0;
                        let tOrebV = 0, tDrebV = 0, tTovV = 0;
                        
                        matchingLineups.forEach(d => {
                            const fga = parseFloat(d.FGA)||0, oreb = parseFloat(d.OREB)||0, tov = parseFloat(d.TOV)||0, fta = parseFloat(d.FTA)||0;
                            const fgaV = parseFloat(d.FGA_VS)||0, orebV = parseFloat(d.OREB_VS)||0, tovV = parseFloat(d.TOV_VS)||0, ftaV = parseFloat(d.FTA_VS)||0;
                            const fgm = parseFloat(d.FGM)||0, fgmV = parseFloat(d.FGM_VS)||0;
                            const dreb = parseFloat(d.DREB)||0, drebV = parseFloat(d.DREB_VS)||0;
                            
                            const poss = calcPoss(fga, oreb, tov, fta);
                            const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                            const pts = fgm*2 + (parseFloat(d['3PM'])||0) + (parseFloat(d.FTM)||0);
                            const ptsV = fgmV*2 + (parseFloat(d['3PM_VS'])||0) + (parseFloat(d.FTM_VS)||0);
                            
                            tPoss += poss; tPossV += possV;
                            tPts += pts; tPtsV += ptsV;
                            tTime += parseFloat(d.TIME) || parseFloat(d.TOTAL_TIME) || 0;
                            
                            tFgm += fgm; tFga += fga;
                            t3pm += parseFloat(d['3PM'])||0; t3pa += parseFloat(d['3PA'])||0;
                            tFta += fta; tFtm += parseFloat(d.FTM)||0;
                            tOreb += oreb; tDreb += dreb; tTov += tov;
                            
                            tFgmV += fgmV; tFgaV += fgaV;
                            t3pmV += parseFloat(d['3PM_VS'])||0; t3paV += parseFloat(d['3PA_VS'])||0;
                            tFtaV += ftaV; tFtmV += parseFloat(d.FTM_VS)||0;
                            tOrebV += orebV; tDrebV += drebV; tTovV += tovV;
                        });
                        
                        const combPoss = tPoss + tPossV;
                        const combMins = tTime / 60; // Convert seconds to minutes
                        if (combMins < wowyMinPoss) return null;

                        // Raw ratings
                        const rawOffRtg = tPoss > 0 ? (tPts / tPoss) * 100 : 0;
                        const rawDefRtg = tPossV > 0 ? (tPtsV / tPossV) * 100 : 0;
                        
                        // Four Factors
                        // V4.9.8.7.31 FIX: Use Basketball Reference TOV% formula for consistency
                        const offTovDenom = tFga + 0.44 * tFta + tTov;
                        const defTovDenom = tFgaV + 0.44 * tFtaV + tTovV;
                        let offEfg = tFga > 0 ? ((tFgm + 0.5*t3pm)/tFga)*100 : 0;
                        let offTov = offTovDenom > 0 ? (tTov/offTovDenom)*100 : 0;
                        let offOreb = (tOreb+tDrebV) > 0 ? (tOreb/(tOreb+tDrebV))*100 : 0;
                        let offFtR = tFga > 0 ? (tFta/tFga)*100 : 0;
                        
                        let defEfg = tFgaV > 0 ? ((tFgmV + 0.5*t3pmV)/tFgaV)*100 : 0;
                        let defTov = defTovDenom > 0 ? (tTovV/defTovDenom)*100 : 0;
                        let defOreb = (tOrebV+tDreb) > 0 ? (tOrebV/(tOrebV+tDreb))*100 : 0;
                        let defFtR = tFgaV > 0 ? (tFtaV/tFgaV)*100 : 0;
                        
                        // Apply luck adjustments
                        let adjOffRtg = rawOffRtg, adjDefRtg = rawDefRtg;
                        let adjOffEfg = offEfg, adjDefEfg = defEfg;
                        
                        if (wowyOffLuckAdj > 0 && t3pa > 0) {
                            const expected3pm = t3pa * (leagueAvg3Pct / 100);
                            const offLuckDelta = t3pm - expected3pm;
                            const adjDelta = offLuckDelta * (wowyOffLuckAdj / 100);
                            adjOffRtg = rawOffRtg + (tPoss > 0 ? (-3 * adjDelta / tPoss) * 100 : 0);
                            const adj3pm = Math.max(0, t3pm - adjDelta);
                            adjOffEfg = tFga > 0 ? ((tFgm - adjDelta + 0.5*adj3pm)/tFga)*100 : offEfg;
                        }
                        
                        if (wowyDefLuckAdj > 0 && t3paV > 0) {
                            const expected3pmV = t3paV * (leagueAvg3Pct / 100);
                            const defLuckDelta = t3pmV - expected3pmV;
                            const adjDelta = defLuckDelta * (wowyDefLuckAdj / 100);
                            adjDefRtg = rawDefRtg + (tPossV > 0 ? (-3 * adjDelta / tPossV) * 100 : 0);
                            const adj3pmV = Math.max(0, t3pmV - adjDelta);
                            adjDefEfg = tFgaV > 0 ? ((tFgmV - adjDelta + 0.5*adj3pmV)/tFgaV)*100 : defEfg;
                        }
                        
                        return {
                            players,
                            lineups: matchingLineups.length,
                            poss: combPoss,
                            minutes: tTime / 60,
                            offRtg: adjOffRtg,
                            defRtg: adjDefRtg,
                            netRtg: adjOffRtg - adjDefRtg,
                            rawOffRtg, rawDefRtg, rawNetRtg: rawOffRtg - rawDefRtg,
                            offEfg: adjOffEfg, offTov, offOreb, offFtR,
                            defEfg: adjDefEfg, defTov, defOreb, defFtR
                        };
                    }).filter(r => r !== null);
                    
                    // Sort by net rating descending
                    results.sort((a, b) => b.netRtg - a.netRtg);
                    
                    return results.slice(0, bestCombosCount);
                }, [showBestCombos, lineupData, team, bestCombosSize, bestCombosCount, wowyMinPoss, wowyOffLuckAdj, wowyDefLuckAdj, allTeamsAverages]);

                // VS Starters WOWY: Compute on/off combinations using stints data filtered to VS Starters
                const vsStartersWowyData = useMemo(() => {
                    if (!showVsStarters || wowyPlayers.length === 0 || !stintsData.length) return [];
                    if (!wowyStarterAnalysis.regularStarters || Object.keys(wowyStarterAnalysis.regularStarters).length === 0) return [];

                    // Generate ON/OFF combinations (same as wowyCombinations)
                    const generateCombinations = (players) => {
                        const combinations = [];
                        const total = Math.pow(2, players.length);
                        for (let i = 0; i < total; i++) {
                            const combo = {};
                            players.forEach((player, idx) => {
                                combo[player] = (i & (1 << idx)) !== 0 ? 'ON' : 'OFF';
                            });
                            combinations.push(combo);
                        }
                        return combinations;
                    };

                    const combinations = generateCombinations(wowyPlayers);
                    const teamStints = stintsData.filter(s => s.home_team === team || s.away_team === team);
                    const vsStarterStints = teamStints.filter(wowyVsStartersFilter);

                    if (vsStarterStints.length === 0) return [];

                    // League average 3PT%
                    let leagueAvg3Pct = 36;
                    if (allTeamsAverages.length > 0) {
                        const totalTpm = allTeamsAverages.reduce((sum, t) => sum + (t.tpm || 0), 0);
                        const totalTpa = allTeamsAverages.reduce((sum, t) => sum + (t.tpa || 0), 0);
                        leagueAvg3Pct = totalTpa > 0 ? (totalTpm / totalTpa) * 100 : 36;
                    }

                    const results = [];
                    combinations.forEach(combo => {
                        const onPlayers = Object.entries(combo).filter(([_, status]) => status === 'ON').map(([p]) => normalizePlayerName(applyPlayerMerge(p)));
                        const offPlayers = Object.entries(combo).filter(([_, status]) => status === 'OFF').map(([p]) => normalizePlayerName(applyPlayerMerge(p)));

                        // Filter stints: team's lineup must contain all ON players and no OFF players
                        const matchingStints = vsStarterStints.filter(s => {
                            const isHome = s.home_team === team;
                            const lineup = isHome ? (s.home_lineup || '') : (s.away_lineup || '');
                            const lineupPlayersNorm = lineup.split(',').map(p => normalizePlayerName(applyPlayerMerge(p.trim())));
                            const hasAllOn = onPlayers.every(op => lineupPlayersNorm.includes(op));
                            const hasNoOff = offPlayers.every(op => !lineupPlayersNorm.includes(op));
                            return hasAllOn && hasNoOff;
                        });

                        if (matchingStints.length === 0) {
                            results.push({ combo, lineups: 0, poss: 0, minutes: 0, stats: null });
                            return;
                        }

                        // Aggregate stint stats
                        let totalDuration = 0, totalPoss = 0;
                        let tFgm = 0, tFga = 0, t3pm = 0, t3pa = 0, tFtm = 0, tFta = 0;
                        let tOreb = 0, tDreb = 0, tTov = 0;
                        let tPts = 0, tPtsV = 0;
                        let tFgmV = 0, tFgaV = 0, t3pmV = 0, t3paV = 0, tFtmV = 0, tFtaV = 0;
                        let tOrebV = 0, tDrebV = 0, tTovV = 0;

                        matchingStints.forEach(s => {
                            const isHome = s.home_team === team;
                            const pre = isHome ? 'home_' : 'away_';
                            const opp = isHome ? 'away_' : 'home_';
                            totalDuration += parseFloat(s.duration) || 0;
                            totalPoss += parseFloat(s.possessions) || 0;
                            tPts += parseFloat(s[pre + 'points']) || 0;
                            tPtsV += parseFloat(s[opp + 'points']) || 0;
                            tFgm += parseFloat(s[pre + 'fgm']) || 0;
                            tFga += parseFloat(s[pre + 'fga']) || 0;
                            t3pm += parseFloat(s[pre + 'fg3m']) || 0;
                            t3pa += parseFloat(s[pre + 'fg3a']) || 0;
                            tFtm += parseFloat(s[pre + 'ftm']) || 0;
                            tFta += parseFloat(s[pre + 'fta']) || 0;
                            tOreb += parseFloat(s[pre + 'oreb']) || 0;
                            tDreb += parseFloat(s[pre + 'dreb']) || 0;
                            tTov += parseFloat(s[pre + 'tov']) || 0;
                            tFgmV += parseFloat(s[opp + 'fgm']) || 0;
                            tFgaV += parseFloat(s[opp + 'fga']) || 0;
                            t3pmV += parseFloat(s[opp + 'fg3m']) || 0;
                            t3paV += parseFloat(s[opp + 'fg3a']) || 0;
                            tFtmV += parseFloat(s[opp + 'ftm']) || 0;
                            tFtaV += parseFloat(s[opp + 'fta']) || 0;
                            tOrebV += parseFloat(s[opp + 'oreb']) || 0;
                            tDrebV += parseFloat(s[opp + 'dreb']) || 0;
                            tTovV += parseFloat(s[opp + 'tov']) || 0;
                        });

                        const combMins = totalDuration / 60;
                        if (combMins < wowyMinPoss) {
                            results.push({ combo, lineups: matchingStints.length, poss: totalPoss, minutes: totalDuration, stats: null });
                            return;
                        }

                        const poss = Math.max(totalPoss, 1);
                        const offRtg = (tPts / poss) * 100;
                        const defRtg = (tPtsV / poss) * 100;
                        const netRtg = offRtg - defRtg;

                        // Four Factors
                        const offTovDenom = tFga + 0.44 * tFta + tTov;
                        const defTovDenom = tFgaV + 0.44 * tFtaV + tTovV;
                        const offEfg = tFga > 0 ? ((tFgm + 0.5 * t3pm) / tFga) * 100 : 0;
                        const offTov = offTovDenom > 0 ? (tTov / offTovDenom) * 100 : 0;
                        const offOreb = (tOreb + tDrebV) > 0 ? (tOreb / (tOreb + tDrebV)) * 100 : 0;
                        const offFtR = tFga > 0 ? (tFta / tFga) * 100 : 0;
                        const defEfg = tFgaV > 0 ? ((tFgmV + 0.5 * t3pmV) / tFgaV) * 100 : 0;
                        const defTov = defTovDenom > 0 ? (tTovV / defTovDenom) * 100 : 0;
                        const defOreb = (tOrebV + tDreb) > 0 ? (tOrebV / (tOrebV + tDreb)) * 100 : 0;
                        const defFtR = tFgaV > 0 ? (tFtaV / tFgaV) * 100 : 0;

                        // Luck adjustments
                        let adjOffRtg = offRtg, adjDefRtg = defRtg;
                        let adjOffEfg = offEfg, adjDefEfg = defEfg;
                        if (wowyOffLuckAdj > 0 && t3pa > 0) {
                            const expected3pm = t3pa * (leagueAvg3Pct / 100);
                            const offLuckDelta = t3pm - expected3pm;
                            const adjDelta3pm = offLuckDelta * (wowyOffLuckAdj / 100);
                            adjOffRtg = offRtg + (totalPoss > 0 ? (-3 * adjDelta3pm / totalPoss) * 100 : 0);
                            const adj3pm = Math.max(0, t3pm - adjDelta3pm);
                            const adjFgm = Math.max(0, tFgm - adjDelta3pm);
                            adjOffEfg = tFga > 0 ? ((adjFgm + 0.5 * adj3pm) / tFga) * 100 : offEfg;
                        }
                        if (wowyDefLuckAdj > 0 && t3paV > 0) {
                            const defExpected3pm = t3paV * (leagueAvg3Pct / 100);
                            const defLuckDelta = t3pmV - defExpected3pm;
                            const defAdjDelta3pm = defLuckDelta * (wowyDefLuckAdj / 100);
                            adjDefRtg = defRtg + (totalPoss > 0 ? (-3 * defAdjDelta3pm / totalPoss) * 100 : 0);
                            const adj3pmV = Math.max(0, t3pmV - defAdjDelta3pm);
                            const adjFgmV = Math.max(0, tFgmV - defAdjDelta3pm);
                            adjDefEfg = tFgaV > 0 ? ((adjFgmV + 0.5 * adj3pmV) / tFgaV) * 100 : defEfg;
                        }
                        const adjNetRtg = adjOffRtg - adjDefRtg;

                        results.push({
                            combo,
                            lineups: matchingStints.length,
                            poss: totalPoss,
                            minutes: totalDuration,
                            stats: {
                                offRtg: adjOffRtg, defRtg: adjDefRtg, netRtg: adjNetRtg,
                                rawOffRtg: offRtg, rawDefRtg: defRtg, rawNetRtg: netRtg,
                                offEfg: adjOffEfg, offTov, offOreb, offFtR,
                                defEfg: adjDefEfg, defTov, defOreb, defFtR
                            }
                        });
                    });
                    return results;
                }, [showVsStarters, wowyPlayers, stintsData, team, wowyStarterAnalysis, wowyMinPoss, wowyOffLuckAdj, wowyDefLuckAdj, allTeamsAverages, applyPlayerMerge]);

                return e('div', { style: { marginTop: '24px' }},
                    // WOWY Container
                    e('div', { className: 'wowy-container' },
                        // Header
                        e('div', { className: 'wowy-header' },
                            e('div', null,
                                e('div', { className: 'wowy-title' }, '🔄 WOWY Analysis'),
                                e('div', { className: 'wowy-subtitle' },
                                    showVsStarters && wowyPlayers.length > 0
                                        ? '🎯 VS Starters: Showing ' + vsStartersWowyData.filter(c => c.stats).length + ' combinations with ' + wowyMinPoss + '+ minutes'
                                        : wowyPlayers.length > 0
                                        ? 'Showing ' + wowyCombinations.filter(c => c.stats).length + ' combinations with ' + wowyMinPoss + '+ minutes'
                                        : 'Select up to 5 players below to analyze their on/off combinations'
                                )
                            ),
                            e('div', { style: { display: 'flex', gap: '12px', alignItems: 'center', flexWrap: 'wrap' }},
                                e('div', { className: 'wowy-min-filter' },
                                    e('label', null, 'Min Mins:'),
                                    e('input', {
                                        type: 'number',
                                        value: wowyMinPoss,
                                        onChange: (ev) => setWowyMinPoss(Math.max(1, parseInt(ev.target.value) || 1)),
                                        min: 1
                                    })
                                ),
                                // V4.9.8.7: Teammate Impact Analysis button (shows when exactly 1 player selected)
                                wowyPlayers.length === 1 && e('button', {
                                    className: 'btn',
                                    style: { 
                                        background: showTeammateImpact 
                                            ? 'linear-gradient(135deg, #8b5cf6, #7c3aed)' 
                                            : 'linear-gradient(135deg, #6366f1, #4f46e5)',
                                        fontSize: '12px'
                                    },
                                    onClick: () => { setShowTeammateImpact(!showTeammateImpact); if (!showTeammateImpact) { setShowVsStarters(false); } }
                                }, showTeammateImpact ? '📊 Hide Teammate Impact' : '📊 Teammate Impact Analysis'),
                                // V4.9.8.7.28: Best Combinations button
                                e('button', {
                                    className: 'btn',
                                    style: { 
                                        background: showBestCombos 
                                            ? 'linear-gradient(135deg, #f59e0b, #d97706)' 
                                            : 'linear-gradient(135deg, #eab308, #ca8a04)',
                                        fontSize: '12px'
                                    },
                                    onClick: () => { setShowBestCombos(!showBestCombos); if (!showBestCombos) { setWowyPlayers([]); setShowTeammateImpact(false); setShowVsStarters(false); } }
                                }, showBestCombos ? '🏆 Hide Best Combos' : '🏆 Best Combinations'),
                                // VS Starters button (only shown when stints data is loaded)
                                stintsData.length > 0 && e('button', {
                                    className: 'btn',
                                    style: {
                                        background: showVsStarters
                                            ? 'linear-gradient(135deg, #06b6d4, #0891b2)'
                                            : 'linear-gradient(135deg, #22d3ee, #06b6d4)',
                                        fontSize: '12px'
                                    },
                                    onClick: () => { setShowVsStarters(!showVsStarters); if (!showVsStarters) { setShowBestCombos(false); setShowTeammateImpact(false); } }
                                }, showVsStarters ? '🎯 Hide VS Starters' : '🎯 VS Starters'),
                                wowyPlayers.length > 0 && e('button', {
                                    className: 'btn btn-secondary',
                                    onClick: () => { setWowyPlayers([]); setShowTeammateImpact(false); setShowVsStarters(false); }
                                }, 'Clear Selection')
                            )
                        ),
                        
                        // V4.9.8.7.28: Best Combinations Controls
                        showBestCombos && e('div', { style: { 
                            padding: '16px 24px', 
                            borderBottom: '1px solid #475569',
                            background: 'linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(217, 119, 6, 0.05))'
                        }},
                            e('div', { style: { display: 'flex', gap: '24px', alignItems: 'center', flexWrap: 'wrap' }},
                                e('div', { style: { fontSize: '14px', fontWeight: '700', color: '#fbbf24' }}, '🏆 Best Player Combinations'),
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                    e('span', { style: { fontSize: '12px', color: '#94a3b8' }}, 'Combo Size:'),
                                    e('select', {
                                        value: bestCombosSize,
                                        onChange: ev => setBestCombosSize(parseInt(ev.target.value)),
                                        style: { padding: '4px 8px', borderRadius: '4px', background: '#1e293b', border: '1px solid #475569', color: '#f1f5f9' }
                                    },
                                        e('option', { value: 2 }, '2-Player'),
                                        e('option', { value: 3 }, '3-Player'),
                                        e('option', { value: 4 }, '4-Player'),
                                        e('option', { value: 5 }, '5-Player (Full Lineup)')
                                    )
                                ),
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                    e('span', { style: { fontSize: '12px', color: '#94a3b8' }}, 'Show Top:'),
                                    e('select', {
                                        value: bestCombosCount,
                                        onChange: ev => setBestCombosCount(parseInt(ev.target.value)),
                                        style: { padding: '4px 8px', borderRadius: '4px', background: '#1e293b', border: '1px solid #475569', color: '#f1f5f9' }
                                    },
                                        e('option', { value: 5 }, '5'),
                                        e('option', { value: 10 }, '10'),
                                        e('option', { value: 15 }, '15'),
                                        e('option', { value: 20 }, '20'),
                                        e('option', { value: 30 }, '30')
                                    )
                                ),
                                bestCombosData && e('span', { style: { fontSize: '11px', color: '#94a3b8' }},
                                    bestCombosData.length + ' combinations found with ' + wowyMinPoss + '+ minutes'
                                )
                            )
                        ),
                        
                        // Luck Adjustment Sliders
                        e('div', { style: { 
                            padding: '16px 24px', 
                            borderBottom: '1px solid #475569',
                            background: 'rgba(251, 191, 36, 0.05)'
                        }},
                            e('div', { style: { display: 'flex', gap: '32px', alignItems: 'center', flexWrap: 'wrap' }},
                                e('div', { style: { fontSize: '13px', fontWeight: '600', color: '#fbbf24' }}, '🎲 3PT Luck Adjustment'),
                                // Offensive slider
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', flex: '1', minWidth: '200px' }},
                                    e('span', { style: { fontSize: '12px', color: '#4ade80', fontWeight: '600', width: '50px' }}, 'Off:'),
                                    e('input', {
                                        type: 'range',
                                        min: 0,
                                        max: 100,
                                        value: wowyOffLuckAdj,
                                        onChange: (ev) => setWowyOffLuckAdj(parseInt(ev.target.value)),
                                        style: { flex: '1', accentColor: '#22c55e' }
                                    }),
                                    e('span', { style: { 
                                        fontSize: '12px', 
                                        fontWeight: 'bold',
                                        color: wowyOffLuckAdj > 0 ? '#4ade80' : '#94a3b8',
                                        minWidth: '40px',
                                        textAlign: 'right'
                                    }}, wowyOffLuckAdj + '%')
                                ),
                                // Defensive slider
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', flex: '1', minWidth: '200px' }},
                                    e('span', { style: { fontSize: '12px', color: '#f87171', fontWeight: '600', width: '50px' }}, 'Def:'),
                                    e('input', {
                                        type: 'range',
                                        min: 0,
                                        max: 100,
                                        value: wowyDefLuckAdj,
                                        onChange: (ev) => setWowyDefLuckAdj(parseInt(ev.target.value)),
                                        style: { flex: '1', accentColor: '#ef4444' }
                                    }),
                                    e('span', { style: { 
                                        fontSize: '12px', 
                                        fontWeight: 'bold',
                                        color: wowyDefLuckAdj > 0 ? '#f87171' : '#94a3b8',
                                        minWidth: '40px',
                                        textAlign: 'right'
                                    }}, wowyDefLuckAdj + '%')
                                ),
                                (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('button', {
                                    className: 'btn btn-secondary',
                                    style: { fontSize: '11px', padding: '4px 10px' },
                                    onClick: () => { setWowyOffLuckAdj(0); setWowyDefLuckAdj(0); }
                                }, 'Reset')
                            ),
                            (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('div', { style: { fontSize: '10px', color: '#94a3b8', marginTop: '8px' }},
                                'Regresses 3PT% toward league average (~36%). Higher % = more regression.'
                            )
                        ),
                        
                        // V4.9.8.7: Teammate Impact Analysis Display - WOWY Style
                        showTeammateImpact && wowyPlayers.length === 1 && teammateImpactData && teammateImpactData.length > 0 && e('div', { style: { overflowX: 'auto' }},
                            // Header banner
                            e('div', { style: { 
                                background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(99, 102, 241, 0.1))',
                                borderBottom: '1px solid rgba(139, 92, 246, 0.3)',
                                padding: '12px 24px',
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center',
                                flexWrap: 'wrap',
                                gap: '12px'
                            }},
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '10px' }},
                                    e('span', { style: { fontSize: '18px' }}, '🔍'),
                                    e('div', null,
                                        e('span', { style: { color: '#c4b5fd', fontWeight: 'bold', fontSize: '14px' }}, 
                                            'Teammate Impact: ' + wowyPlayers[0]
                                        ),
                                        e('span', { style: { color: '#a78bfa', fontSize: '12px', marginLeft: '8px' }}, 
                                            '(' + teammateImpactData.length + ' teammates)'
                                        ),
                                        (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('span', { 
                                            style: { color: '#fbbf24', fontSize: '11px', marginLeft: '8px' }
                                        }, '🎲 Luck Adjusted')
                                    )
                                ),
                                e('div', { style: { fontSize: '11px', color: '#94a3b8' }},
                                    'Sorted by teammate impact on net rating',
                                    (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('span', { style: { color: '#fbbf24', marginLeft: '8px' }},
                                        '(Off: ' + wowyOffLuckAdj + '%, Def: ' + wowyDefLuckAdj + '%)'
                                    )
                                )
                            ),
                            e('table', { className: 'wowy-table' },
                                e('thead', null,
                                    e('tr', null,
                                        e('th', { style: { minWidth: '200px' }}, 'LINEUP'),
                                        e('th', null, 'MIN'),
                                        e('th', null, 'OFF', wowyOffLuckAdj > 0 && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                        e('th', null, 'DEF', wowyDefLuckAdj > 0 && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                        e('th', null, 'NET', (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                        e('th', { style: { minWidth: '90px' }, title: 'Box Plus/Minus (Myers method) - estimated pts/100 poss vs avg' }, 'BPM'),
                                        e('th', { style: { minWidth: '80px' }, title: 'Player Efficiency Rating' }, 'PER'),
                                        e('th', { style: { minWidth: '100px' }}, 'Δ NET', (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                        e('th', { style: { minWidth: '100px' }, title: 'BPM Impact - change in production when teammate is added' }, 'Δ BPM'),
                                        e('th', { style: { minWidth: '100px' }, title: 'PER Impact - change in player efficiency when teammate is added' }, 'Δ PER')
                                    )
                                ),
                                e('tbody', null,
                                    // Flatten teammate data into WOWY-style rows (WITH row, WITHOUT row, then Four Factors comparison)
                                    ...teammateImpactData.flatMap((row, idx) => {
                                        const selectedPlayer = wowyPlayers[0];
                                        const rows = [];
                                        
                                        // WITH teammate row
                                        if (row.bothOn) {
                                            rows.push(e('tr', { 
                                                key: idx + '-with',
                                                style: { 
                                                    background: 'rgba(34, 197, 94, 0.05)',
                                                    borderTop: idx > 0 ? '2px solid rgba(139, 92, 246, 0.3)' : 'none'
                                                }
                                            },
                                                e('td', null,
                                                    e('div', { className: 'wowy-lineup-cell' },
                                                        // Selected player - always ON
                                                        e('div', { className: 'wowy-player-badge' },
                                                            e('div', { className: 'wowy-player-img on' },
                                                                getInitialsLocal(selectedPlayer),
                                                                e('span', { className: 'wowy-status-badge on' }, 'ON')
                                                            ),
                                                            e('div', { className: 'wowy-player-name' }, getSurname(selectedPlayer))
                                                        ),
                                                        // Teammate - ON
                                                        e('div', { className: 'wowy-player-badge' },
                                                            e('div', { className: 'wowy-player-img on' },
                                                                getInitialsLocal(row.teammate),
                                                                e('span', { className: 'wowy-status-badge on' }, 'ON')
                                                            ),
                                                            e('div', { className: 'wowy-player-name' }, getSurname(row.teammate))
                                                        )
                                                    )
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#94a3b8' }}, row.bothOn.mins ? row.bothOn.mins.toFixed(1) : Math.round(row.bothOn.poss))
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#4ade80' }}, row.bothOn.offRtg.toFixed(1)),
                                                    wowyOffLuckAdj > 0 && row.bothOn.rawOffRtg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                        'raw: ' + row.bothOn.rawOffRtg.toFixed(1))
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#f87171' }}, row.bothOn.defRtg.toFixed(1)),
                                                    wowyDefLuckAdj > 0 && row.bothOn.rawDefRtg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                        'raw: ' + row.bothOn.rawDefRtg.toFixed(1))
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', {
                                                        className: 'wowy-stat-main ' + (row.bothOn.netRtg >= 0 ? 'wowy-net-positive' : 'wowy-net-negative'),
                                                        style: { fontSize: '18px' }
                                                    }, (row.bothOn.netRtg >= 0 ? '+' : '') + row.bothOn.netRtg.toFixed(1)),
                                                    (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && row.bothOn.rawNetRtg !== undefined && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                        'raw: ' + (row.bothOn.rawNetRtg >= 0 ? '+' : '') + row.bothOn.rawNetRtg.toFixed(1))
                                                ),
                                                // V5.13: BPM cell (with teammate ON)
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', {
                                                        className: 'wowy-stat-main',
                                                        style: {
                                                            fontSize: '14px',
                                                            color: row.bothOn.bpm >= 2 ? '#22c55e'
                                                                : row.bothOn.bpm <= -2 ? '#ef4444'
                                                                : row.bothOn.bpm >= 0 ? '#86efac' : '#fca5a5'
                                                        }
                                                    }, (row.bothOn.bpm >= 0 ? '+' : '') + row.bothOn.bpm.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '2px' }},
                                                        'O: ' + (row.bothOn.obpm >= 0 ? '+' : '') + row.bothOn.obpm.toFixed(1) +
                                                        ' / D: ' + (row.bothOn.dbpm >= 0 ? '+' : '') + row.bothOn.dbpm.toFixed(1))
                                                ),
                                                // V5.23: PER cell (with teammate ON)
                                                e('td', { className: 'wowy-stat' },
                                                    row.bothOn.p1Per !== null ? e('div', {
                                                        className: 'wowy-stat-main',
                                                        style: {
                                                            fontSize: '14px',
                                                            color: row.bothOn.p1Per >= 20 ? '#22c55e'
                                                                : row.bothOn.p1Per >= 15 ? '#86efac'
                                                                : row.bothOn.p1Per >= 10 ? '#94a3b8' : '#fca5a5'
                                                        }
                                                    }, row.bothOn.p1Per.toFixed(1)) : e('div', { style: { fontSize: '12px', color: '#64748b' }}, 'N/A')
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    row.delta && e('div', {
                                                        style: {
                                                            fontSize: '16px',
                                                            fontWeight: 'bold',
                                                            color: row.delta.netRtg >= 5 ? '#22c55e'
                                                                : row.delta.netRtg <= -5 ? '#ef4444'
                                                                : row.delta.netRtg >= 0 ? '#86efac' : '#fca5a5',
                                                            background: row.delta.netRtg >= 5 ? 'rgba(34, 197, 94, 0.2)'
                                                                : row.delta.netRtg <= -5 ? 'rgba(239, 68, 68, 0.2)'
                                                                : 'transparent',
                                                            padding: '4px 8px',
                                                            borderRadius: '4px'
                                                        }
                                                    }, (row.delta.netRtg >= 0 ? '+' : '') + row.delta.netRtg.toFixed(1))
                                                ),
                                                // V5.13: BPM Impact cell (delta)
                                                // V5.17: Handle null BPM values (show N/A if player_lineup_stats_enhanced not loaded)
                                                e('td', { className: 'wowy-stat' },
                                                    row.delta && row.delta.bpm !== null ? e('div', {
                                                        style: {
                                                            fontSize: '16px',
                                                            fontWeight: 'bold',
                                                            color: row.delta.bpm >= 1.5 ? '#22c55e'
                                                                : row.delta.bpm <= -1.5 ? '#ef4444'
                                                                : row.delta.bpm >= 0 ? '#86efac' : '#fca5a5',
                                                            background: row.delta.bpm >= 1.5 ? 'rgba(34, 197, 94, 0.2)'
                                                                : row.delta.bpm <= -1.5 ? 'rgba(239, 68, 68, 0.2)'
                                                                : 'transparent',
                                                            padding: '4px 8px',
                                                            borderRadius: '4px'
                                                        }
                                                    }, (row.delta.bpm >= 0 ? '+' : '') + row.delta.bpm.toFixed(1)) : row.delta ? e('div', { style: { fontSize: '12px', color: '#64748b', fontStyle: 'italic' }}, 'N/A') : null,
                                                    row.delta && row.delta.obpm !== null && row.delta.dbpm !== null ? e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '2px' }},
                                                        'O: ' + (row.delta.obpm >= 0 ? '+' : '') + row.delta.obpm.toFixed(1) +
                                                        ' / D: ' + (row.delta.dbpm >= 0 ? '+' : '') + row.delta.dbpm.toFixed(1)) : row.delta && row.delta.bpm === null ? e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '2px' }}, 'Load player_lineup_stats') : null
                                                ),
                                                // V5.23: PER Impact cell (delta)
                                                e('td', { className: 'wowy-stat' },
                                                    row.delta && row.delta.per !== null ? e('div', {
                                                        style: {
                                                            fontSize: '16px',
                                                            fontWeight: 'bold',
                                                            color: row.delta.per >= 2 ? '#22c55e'
                                                                : row.delta.per <= -2 ? '#ef4444'
                                                                : row.delta.per >= 0 ? '#a78bfa' : '#fca5a5',
                                                            background: row.delta.per >= 2 ? 'rgba(139, 92, 246, 0.2)'
                                                                : row.delta.per <= -2 ? 'rgba(239, 68, 68, 0.2)'
                                                                : 'transparent',
                                                            padding: '4px 8px',
                                                            borderRadius: '4px'
                                                        }
                                                    }, (row.delta.per >= 0 ? '+' : '') + row.delta.per.toFixed(1)) : row.delta ? e('div', { style: { fontSize: '12px', color: '#64748b', fontStyle: 'italic' }}, 'N/A') : null,
                                                    row.bothOn.p1Per !== null && row.solo && row.solo.p1Per !== null ? e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '2px' }},
                                                        'w/' + row.bothOn.p1Per.toFixed(1) + ' → w/o ' + row.solo.p1Per.toFixed(1)) : null
                                                )
                                            ));
                                        }

                                        // WITHOUT teammate row
                                        if (row.solo) {
                                            rows.push(e('tr', { 
                                                key: idx + '-without',
                                                style: { background: 'rgba(239, 68, 68, 0.03)' }
                                            },
                                                e('td', null,
                                                    e('div', { className: 'wowy-lineup-cell' },
                                                        // Selected player - always ON
                                                        e('div', { className: 'wowy-player-badge' },
                                                            e('div', { className: 'wowy-player-img on' },
                                                                getInitialsLocal(selectedPlayer),
                                                                e('span', { className: 'wowy-status-badge on' }, 'ON')
                                                            ),
                                                            e('div', { className: 'wowy-player-name' }, getSurname(selectedPlayer))
                                                        ),
                                                        // Teammate - OFF
                                                        e('div', { className: 'wowy-player-badge' },
                                                            e('div', { className: 'wowy-player-img off' },
                                                                getInitialsLocal(row.teammate),
                                                                e('span', { className: 'wowy-status-badge off' }, 'OFF')
                                                            ),
                                                            e('div', { className: 'wowy-player-name' }, getSurname(row.teammate))
                                                        )
                                                    )
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#94a3b8' }}, row.solo.mins ? row.solo.mins.toFixed(1) : Math.round(row.solo.poss))
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#4ade80' }}, row.solo.offRtg.toFixed(1)),
                                                    wowyOffLuckAdj > 0 && row.solo.rawOffRtg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                        'raw: ' + row.solo.rawOffRtg.toFixed(1))
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#f87171' }}, row.solo.defRtg.toFixed(1)),
                                                    wowyDefLuckAdj > 0 && row.solo.rawDefRtg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                        'raw: ' + row.solo.rawDefRtg.toFixed(1))
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', {
                                                        className: 'wowy-stat-main ' + (row.solo.netRtg >= 0 ? 'wowy-net-positive' : 'wowy-net-negative'),
                                                        style: { fontSize: '18px' }
                                                    }, (row.solo.netRtg >= 0 ? '+' : '') + row.solo.netRtg.toFixed(1)),
                                                    (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && row.solo.rawNetRtg !== undefined && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                        'raw: ' + (row.solo.rawNetRtg >= 0 ? '+' : '') + row.solo.rawNetRtg.toFixed(1))
                                                ),
                                                // V5.13: BPM cell (without teammate - baseline)
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', {
                                                        className: 'wowy-stat-main',
                                                        style: {
                                                            fontSize: '14px',
                                                            color: row.solo.bpm >= 2 ? '#22c55e'
                                                                : row.solo.bpm <= -2 ? '#ef4444'
                                                                : row.solo.bpm >= 0 ? '#86efac' : '#fca5a5'
                                                        }
                                                    }, (row.solo.bpm >= 0 ? '+' : '') + row.solo.bpm.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '2px' }},
                                                        'O: ' + (row.solo.obpm >= 0 ? '+' : '') + row.solo.obpm.toFixed(1) +
                                                        ' / D: ' + (row.solo.dbpm >= 0 ? '+' : '') + row.solo.dbpm.toFixed(1))
                                                ),
                                                // V5.23: PER cell (without teammate - baseline)
                                                e('td', { className: 'wowy-stat' },
                                                    row.solo.p1Per !== null ? e('div', {
                                                        className: 'wowy-stat-main',
                                                        style: {
                                                            fontSize: '14px',
                                                            color: row.solo.p1Per >= 20 ? '#22c55e'
                                                                : row.solo.p1Per >= 15 ? '#86efac'
                                                                : row.solo.p1Per >= 10 ? '#94a3b8' : '#fca5a5'
                                                        }
                                                    }, row.solo.p1Per.toFixed(1)) : e('div', { style: { fontSize: '12px', color: '#64748b' }}, 'N/A')
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { style: { color: '#64748b', fontSize: '12px' }}, 'baseline')
                                                ),
                                                // V5.13: BPM baseline placeholder
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { style: { color: '#64748b', fontSize: '12px' }}, 'baseline')
                                                ),
                                                // V5.23: PER baseline placeholder
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { style: { color: '#64748b', fontSize: '12px' }}, 'baseline')
                                                )
                                            ));
                                        }

                                        // Four Factors comparison row with deltas (only if both scenarios exist)
                                        if (row.bothOn && row.solo) {
                                            // Calculate deltas for Four Factors
                                            const ffDelta = {
                                                offEfg: row.bothOn.offEfg - row.solo.offEfg,
                                                offTov: row.bothOn.offTov - row.solo.offTov,
                                                offOreb: row.bothOn.offOreb - row.solo.offOreb,
                                                offFtr: row.bothOn.offFtr - row.solo.offFtr,
                                                defEfg: row.bothOn.defEfg - row.solo.defEfg,
                                                defTov: row.bothOn.defTov - row.solo.defTov,
                                                defOreb: row.bothOn.defOreb - row.solo.defOreb,
                                                defFtr: row.bothOn.defFtr - row.solo.defFtr
                                            };
                                            
                                            // Helper to format delta with color
                                            const formatDelta = (val, invert = false) => {
                                                const isGood = invert ? val < 0 : val > 0;
                                                const color = Math.abs(val) < 0.5 ? '#94a3b8' : (isGood ? '#22c55e' : '#ef4444');
                                                return e('span', { style: { color, fontWeight: Math.abs(val) >= 2 ? 'bold' : 'normal' }}, 
                                                    (val >= 0 ? '+' : '') + val.toFixed(1));
                                            };
                                            
                                            rows.push(e('tr', {
                                                key: idx + '-ff',
                                                style: { background: 'rgba(139, 92, 246, 0.08)' }
                                            },
                                                e('td', { colSpan: 11, style: { padding: '12px 16px' }},
                                                    e('div', { style: { display: 'flex', gap: '24px', flexWrap: 'wrap', alignItems: 'flex-start' }},
                                                        // Label
                                                        e('div', { style: { 
                                                            fontSize: '11px', 
                                                            color: '#a78bfa', 
                                                            fontWeight: 'bold',
                                                            minWidth: '100px',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            gap: '6px'
                                                        }}, 
                                                            '📊 FOUR FACTORS',
                                                            (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('span', { style: { color: '#fbbf24' }}, '🎲')
                                                        ),
                                                        // Offensive Four Factors with ON / OFF / Δ
                                                        e('div', { style: { flex: 1, minWidth: '280px' }},
                                                            e('div', { style: { fontSize: '10px', color: '#4ade80', fontWeight: '600', marginBottom: '6px' }}, '⚔️ OFFENSE'),
                                                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '8px', fontSize: '10px' }},
                                                                // eFG%
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'eFG%', wowyOffLuckAdj > 0 && e('span', { style: { color: '#fbbf24', marginLeft: '2px' }}, '🎲')),
                                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', gap: '4px' }},
                                                                        e('span', { style: { color: '#4ade80' }}, row.bothOn.offEfg.toFixed(1)),
                                                                        e('span', { style: { color: '#94a3b8' }}, '/'),
                                                                        e('span', { style: { color: '#fb923c' }}, row.solo.offEfg.toFixed(1))
                                                                    ),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.offEfg))
                                                                ),
                                                                // TOV%
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'TOV%'),
                                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', gap: '4px' }},
                                                                        e('span', { style: { color: '#4ade80' }}, row.bothOn.offTov.toFixed(1)),
                                                                        e('span', { style: { color: '#94a3b8' }}, '/'),
                                                                        e('span', { style: { color: '#fb923c' }}, row.solo.offTov.toFixed(1))
                                                                    ),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.offTov, true))
                                                                ),
                                                                // OREB%
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'OREB%'),
                                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', gap: '4px' }},
                                                                        e('span', { style: { color: '#4ade80' }}, row.bothOn.offOreb.toFixed(1)),
                                                                        e('span', { style: { color: '#94a3b8' }}, '/'),
                                                                        e('span', { style: { color: '#fb923c' }}, row.solo.offOreb.toFixed(1))
                                                                    ),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.offOreb))
                                                                ),
                                                                // FTR
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'FTR'),
                                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', gap: '4px' }},
                                                                        e('span', { style: { color: '#4ade80' }}, row.bothOn.offFtr.toFixed(1)),
                                                                        e('span', { style: { color: '#94a3b8' }}, '/'),
                                                                        e('span', { style: { color: '#fb923c' }}, row.solo.offFtr.toFixed(1))
                                                                    ),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.offFtr))
                                                                )
                                                            )
                                                        ),
                                                        // Defensive Four Factors with ON / OFF / Δ
                                                        e('div', { style: { flex: 1, minWidth: '280px' }},
                                                            e('div', { style: { fontSize: '10px', color: '#f87171', fontWeight: '600', marginBottom: '6px' }}, '🛡️ DEFENSE'),
                                                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '8px', fontSize: '10px' }},
                                                                // Opp eFG%
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'Opp eFG%', wowyDefLuckAdj > 0 && e('span', { style: { color: '#fbbf24', marginLeft: '2px' }}, '🎲')),
                                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', gap: '4px' }},
                                                                        e('span', { style: { color: '#4ade80' }}, row.bothOn.defEfg.toFixed(1)),
                                                                        e('span', { style: { color: '#94a3b8' }}, '/'),
                                                                        e('span', { style: { color: '#fb923c' }}, row.solo.defEfg.toFixed(1))
                                                                    ),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.defEfg, true))
                                                                ),
                                                                // Opp TOV%
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'Opp TOV%'),
                                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', gap: '4px' }},
                                                                        e('span', { style: { color: '#4ade80' }}, row.bothOn.defTov.toFixed(1)),
                                                                        e('span', { style: { color: '#94a3b8' }}, '/'),
                                                                        e('span', { style: { color: '#fb923c' }}, row.solo.defTov.toFixed(1))
                                                                    ),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.defTov))
                                                                ),
                                                                // Opp OREB%
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'Opp OREB%'),
                                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', gap: '4px' }},
                                                                        e('span', { style: { color: '#4ade80' }}, row.bothOn.defOreb.toFixed(1)),
                                                                        e('span', { style: { color: '#94a3b8' }}, '/'),
                                                                        e('span', { style: { color: '#fb923c' }}, row.solo.defOreb.toFixed(1))
                                                                    ),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.defOreb, true))
                                                                ),
                                                                // Opp FTR
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'Opp FTR'),
                                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', gap: '4px' }},
                                                                        e('span', { style: { color: '#4ade80' }}, row.bothOn.defFtr.toFixed(1)),
                                                                        e('span', { style: { color: '#94a3b8' }}, '/'),
                                                                        e('span', { style: { color: '#fb923c' }}, row.solo.defFtr.toFixed(1))
                                                                    ),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.defFtr, true))
                                                                )
                                                            )
                                                        ),
                                                        // Legend
                                                        e('div', { style: { fontSize: '9px', color: '#64748b', alignSelf: 'flex-end' }},
                                                            e('span', { style: { color: '#4ade80' }}, 'ON'), ' / ',
                                                            e('span', { style: { color: '#fb923c' }}, 'OFF'), ' / Δ'
                                                        )
                                                    )
                                                )
                                            ));
                                        }
                                        
                                        return rows;
                                    })
                                )
                            ),
                            // Summary section
                            e('div', { style: {
                                padding: '12px 24px',
                                background: 'rgba(139, 92, 246, 0.1)',
                                borderTop: '1px solid rgba(139, 92, 246, 0.2)',
                                display: 'flex',
                                gap: '24px',
                                flexWrap: 'wrap',
                                alignItems: 'center'
                            }},
                                e('div', null,
                                    e('div', { style: { fontSize: '10px', color: '#a78bfa', marginBottom: '2px' }}, '🏆 Best Fit (NET)'),
                                    e('div', { style: { fontWeight: 'bold', color: '#22c55e', fontSize: '13px' }},
                                        getSurname(teammateImpactData[0]?.teammate || '') + ' (' +
                                        (teammateImpactData[0]?.delta?.netRtg >= 0 ? '+' : '') +
                                        (teammateImpactData[0]?.delta?.netRtg?.toFixed(1) || 'N/A') + ')'
                                    )
                                ),
                                teammateImpactData.length > 1 && e('div', null,
                                    e('div', { style: { fontSize: '10px', color: '#a78bfa', marginBottom: '2px' }}, '⚠️ Worst Fit (NET)'),
                                    e('div', { style: { fontWeight: 'bold', color: '#ef4444', fontSize: '13px' }},
                                        getSurname(teammateImpactData[teammateImpactData.length - 1]?.teammate || '') + ' (' +
                                        (teammateImpactData[teammateImpactData.length - 1]?.delta?.netRtg >= 0 ? '+' : '') +
                                        (teammateImpactData[teammateImpactData.length - 1]?.delta?.netRtg?.toFixed(1) || 'N/A') + ')'
                                    )
                                ),
                                // V5.13: Best/Worst BPM Impact
                                (() => {
                                    const sortedByBpm = [...teammateImpactData].filter(d => d.delta?.bpm != null).sort((a, b) => (b.delta?.bpm || 0) - (a.delta?.bpm || 0));
                                    const bestBpm = sortedByBpm[0];
                                    const worstBpm = sortedByBpm[sortedByBpm.length - 1];
                                    return [
                                        bestBpm && e('div', { key: 'best-bpm' },
                                            e('div', { style: { fontSize: '10px', color: '#60a5fa', marginBottom: '2px' }}, '📈 Best BPM Impact'),
                                            e('div', { style: { fontWeight: 'bold', color: '#22c55e', fontSize: '13px' }},
                                                getSurname(bestBpm.teammate || '') + ' (' +
                                                (bestBpm.delta?.bpm >= 0 ? '+' : '') +
                                                bestBpm.delta?.bpm?.toFixed(1) + ')'
                                            )
                                        ),
                                        worstBpm && sortedByBpm.length > 1 && e('div', { key: 'worst-bpm' },
                                            e('div', { style: { fontSize: '10px', color: '#60a5fa', marginBottom: '2px' }}, '📉 Worst BPM Impact'),
                                            e('div', { style: { fontWeight: 'bold', color: '#ef4444', fontSize: '13px' }},
                                                getSurname(worstBpm.teammate || '') + ' (' +
                                                (worstBpm.delta?.bpm >= 0 ? '+' : '') +
                                                worstBpm.delta?.bpm?.toFixed(1) + ')'
                                            )
                                        )
                                    ];
                                })(),
                                e('div', { style: { marginLeft: 'auto', fontSize: '11px', color: '#94a3b8' }},
                                    'BPM = Box Plus/Minus (Myers method) • Δ = Impact of adding teammate'
                                )
                            )
                        ),
                        
                        // Results Table (hide when teammate impact or VS Starters is showing)
                        !showTeammateImpact && !showVsStarters && wowyPlayers.length > 0 && wowyCombinations.filter(c => c.stats).length > 0 ? e('div', { style: { overflowX: 'auto' }},
                            e('table', { className: 'wowy-table' },
                                e('thead', null,
                                    e('tr', null,
                                        e('th', { style: { minWidth: '200px' }}, 'LINEUP'),
                                        e('th', null, 'MIN'),
                                        e('th', null, 'OFF', wowyOffLuckAdj > 0 && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                        e('th', null, 'DEF', wowyDefLuckAdj > 0 && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                        e('th', null, 'NET', (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                        e('th', { style: { minWidth: '320px' }}, 'FOUR FACTORS (OFF / DEF)', (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲'))
                                    )
                                ),
                                e('tbody', null,
                                    wowyCombinations.filter(c => c.stats).map((row, idx) => {
                                        // Format minutes as MM:SS (row.minutes is in seconds)
                                        const totalSecs = Math.round(row.minutes || 0);
                                        const minsVal = Math.floor(totalSecs / 60);
                                        const secsVal = totalSecs % 60;
                                        const minsDisplay = minsVal + ':' + String(secsVal).padStart(2, '0');
                                        
                                        return e('tr', { key: idx },
                                            // Lineup cell with player badges
                                            e('td', null,
                                                e('div', { className: 'wowy-lineup-cell' },
                                                    wowyPlayers.map(player => 
                                                        e('div', { key: player, className: 'wowy-player-badge' },
                                                            e('div', { 
                                                                className: 'wowy-player-img ' + (row.combo[player] === 'ON' ? 'on' : 'off')
                                                            },
                                                                getInitialsLocal(player),
                                                                e('span', { 
                                                                    className: 'wowy-status-badge ' + (row.combo[player] === 'ON' ? 'on' : 'off')
                                                                }, row.combo[player])
                                                            ),
                                                            e('div', { className: 'wowy-player-name' }, getSurname(player))
                                                        )
                                                    )
                                                )
                                            ),
                                            // Minutes
                                            e('td', { className: 'wowy-stat' },
                                                e('div', { className: 'wowy-stat-main', style: { color: '#94a3b8' }}, minsDisplay)
                                            ),
                                            // Offensive Rating
                                            e('td', { className: 'wowy-stat' },
                                                e('div', { className: 'wowy-stat-main', style: { color: '#4ade80' }}, row.stats.offRtg.toFixed(1)),
                                                e('div', { 
                                                    className: 'wowy-stat-sub ' + (row.stats.offRtg - teamAvgForDelta.off >= 0 ? 'positive' : 'negative')
                                                }, (row.stats.offRtg - teamAvgForDelta.off >= 0 ? '+' : '') + (row.stats.offRtg - teamAvgForDelta.off).toFixed(1)),
                                                wowyOffLuckAdj > 0 && row.stats.rawOffRtg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                    'raw: ' + row.stats.rawOffRtg.toFixed(1)
                                                )
                                            ),
                                            // Defensive Rating
                                            e('td', { className: 'wowy-stat' },
                                                e('div', { className: 'wowy-stat-main', style: { color: '#f87171' }}, row.stats.defRtg.toFixed(1)),
                                                e('div', { 
                                                    className: 'wowy-stat-sub ' + (row.stats.defRtg - teamAvgForDelta.def <= 0 ? 'positive' : 'negative')
                                                }, (row.stats.defRtg - teamAvgForDelta.def >= 0 ? '+' : '') + (row.stats.defRtg - teamAvgForDelta.def).toFixed(1)),
                                                wowyDefLuckAdj > 0 && row.stats.rawDefRtg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                    'raw: ' + row.stats.rawDefRtg.toFixed(1)
                                                )
                                            ),
                                            // Net Rating
                                            e('td', { className: 'wowy-stat' },
                                                e('div', { 
                                                    className: 'wowy-stat-main ' + (row.stats.netRtg >= 0 ? 'wowy-net-positive' : 'wowy-net-negative'),
                                                    style: { fontSize: '20px' }
                                                }, (row.stats.netRtg >= 0 ? '+' : '') + row.stats.netRtg.toFixed(1)),
                                                (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && row.stats.rawNetRtg !== undefined && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                    'raw: ' + (row.stats.rawNetRtg >= 0 ? '+' : '') + row.stats.rawNetRtg.toFixed(1)
                                                )
                                            ),
                                            // Four Factors (Offensive and Defensive)
                                            e('td', null,
                                                e('div', { style: { display: 'flex', flexDirection: 'column', gap: '6px' }},
                                                    // Offensive Four Factors
                                                    e('div', null,
                                                        e('div', { style: { fontSize: '9px', color: '#4ade80', fontWeight: '600', marginBottom: '4px' }}, '⚔️ OFFENSE'),
                                                        e('div', { className: 'wowy-ff-grid' },
                                                            e('div', { className: 'wowy-ff-item' },
                                                                e('div', { className: 'wowy-ff-label' }, 'eFG%', wowyOffLuckAdj > 0 && e('span', { style: { color: '#fbbf24', marginLeft: '2px' }}, '🎲')),
                                                                e('div', { className: 'wowy-ff-value', style: { color: '#4ade80' }}, row.stats.offEfg.toFixed(1)),
                                                                wowyOffLuckAdj > 0 && row.stats.rawOffEfg && e('div', { style: { fontSize: '8px', color: '#fbbf24' }}, 'raw: ' + row.stats.rawOffEfg.toFixed(1))
                                                            ),
                                                            e('div', { className: 'wowy-ff-item' },
                                                                e('div', { className: 'wowy-ff-label' }, 'TOV%'),
                                                                e('div', { className: 'wowy-ff-value', style: { color: '#4ade80' }}, row.stats.offTov.toFixed(1))
                                                            ),
                                                            e('div', { className: 'wowy-ff-item' },
                                                                e('div', { className: 'wowy-ff-label' }, 'OREB%'),
                                                                e('div', { className: 'wowy-ff-value', style: { color: '#4ade80' }}, row.stats.offOreb.toFixed(1))
                                                            ),
                                                            e('div', { className: 'wowy-ff-item' },
                                                                e('div', { className: 'wowy-ff-label' }, 'FTR'),
                                                                e('div', { className: 'wowy-ff-value', style: { color: '#4ade80' }}, row.stats.offFtR.toFixed(1))
                                                            )
                                                        )
                                                    ),
                                                    // Defensive Four Factors
                                                    e('div', null,
                                                        e('div', { style: { fontSize: '9px', color: '#f87171', fontWeight: '600', marginBottom: '4px' }}, '🛡️ DEFENSE'),
                                                        e('div', { className: 'wowy-ff-grid' },
                                                            e('div', { className: 'wowy-ff-item' },
                                                                e('div', { className: 'wowy-ff-label' }, 'Opp eFG%', wowyDefLuckAdj > 0 && e('span', { style: { color: '#fbbf24', marginLeft: '2px' }}, '🎲')),
                                                                e('div', { className: 'wowy-ff-value', style: { color: '#f87171' }}, row.stats.defEfg.toFixed(1)),
                                                                wowyDefLuckAdj > 0 && row.stats.rawDefEfg && e('div', { style: { fontSize: '8px', color: '#fbbf24' }}, 'raw: ' + row.stats.rawDefEfg.toFixed(1))
                                                            ),
                                                            e('div', { className: 'wowy-ff-item' },
                                                                e('div', { className: 'wowy-ff-label' }, 'Opp TOV%'),
                                                                e('div', { className: 'wowy-ff-value', style: { color: '#f87171' }}, row.stats.defTov.toFixed(1))
                                                            ),
                                                            e('div', { className: 'wowy-ff-item' },
                                                                e('div', { className: 'wowy-ff-label' }, 'Opp OREB%'),
                                                                e('div', { className: 'wowy-ff-value', style: { color: '#f87171' }}, row.stats.defOreb.toFixed(1))
                                                            ),
                                                            e('div', { className: 'wowy-ff-item' },
                                                                e('div', { className: 'wowy-ff-label' }, 'Opp FTR'),
                                                                e('div', { className: 'wowy-ff-value', style: { color: '#f87171' }}, row.stats.defFtR.toFixed(1))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        );
                                    })
                                )
                            )
                        ) : !showTeammateImpact && !showVsStarters && wowyPlayers.length > 0 ? e('div', { className: 'wowy-empty' },
                            e('div', { className: 'wowy-empty-icon' }, '📊'),
                            e('div', null, 'No combinations found with ' + wowyMinPoss + '+ minutes'),
                            e('div', { style: { fontSize: '12px', marginTop: '8px', opacity: 0.7 }}, 'Try lowering the minimum minutes threshold')
                        ) : !showTeammateImpact && !showBestCombos && !showVsStarters && e('div', { className: 'wowy-empty' },
                            e('div', { className: 'wowy-empty-icon' }, '👇'),
                            e('div', null, 'Select players below to see their on/off combinations'),
                            e('div', { style: { fontSize: '12px', marginTop: '8px', opacity: 0.7 }}, 'Select 1 player for Teammate Impact Analysis')
                        ),
                        
                        // V4.9.8.7.28: Best Combinations Display
                        showBestCombos && bestCombosData && bestCombosData.length > 0 && e('div', { style: { overflowX: 'auto' }},
                            e('table', { className: 'wowy-table' },
                                e('thead', null,
                                    e('tr', null,
                                        e('th', { style: { minWidth: '200px' }}, 'PLAYERS'),
                                        e('th', null, 'MIN'),
                                        e('th', null, 'OFF', wowyOffLuckAdj > 0 && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                        e('th', null, 'DEF', wowyDefLuckAdj > 0 && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                        e('th', null, 'NET', (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲'))
                                    )
                                ),
                                e('tbody', null,
                                    bestCombosData.map((combo, idx) => {
                                        // Format delta helper
                                        const formatDelta = (val, invert = false) => {
                                            const d = invert ? -val : val;
                                            const color = d > 1 ? '#4ade80' : d < -1 ? '#f87171' : '#94a3b8';
                                            return e('span', { style: { color, fontWeight: 'bold' }}, (d >= 0 ? '+' : '') + d.toFixed(1));
                                        };
                                        
                                        // Calculate deltas vs team average
                                        const teamAvgForDelta = allTeamsAverages.find(t => t.team === team) || { off: 100, def: 100, offEfg: 50, offTov: 14, offOreb: 25, offFtr: 25, defEfg: 50, defTov: 14, defOreb: 25, defFtr: 25 };
                                        const ffDelta = {
                                            offEfg: combo.offEfg - (teamAvgForDelta.offEfg || 50),
                                            offTov: combo.offTov - (teamAvgForDelta.offTov || 14),
                                            offOreb: combo.offOreb - (teamAvgForDelta.offOreb || 25),
                                            offFtR: combo.offFtR - (teamAvgForDelta.offFtR || 25),
                                            defEfg: combo.defEfg - (teamAvgForDelta.defEfg || 50),
                                            defTov: combo.defTov - (teamAvgForDelta.defTov || 14),
                                            defOreb: combo.defOreb - (teamAvgForDelta.defOreb || 25),
                                            defFtR: combo.defFtR - (teamAvgForDelta.defFtR || 25)
                                        };
                                        
                                        return [
                                            // Main row
                                            e('tr', { 
                                                key: idx,
                                                style: { 
                                                    background: idx === 0 ? 'rgba(245, 158, 11, 0.1)' : idx < 3 ? 'rgba(245, 158, 11, 0.05)' : 'transparent',
                                                    borderTop: idx > 0 ? '2px solid rgba(245, 158, 11, 0.2)' : 'none'
                                                }
                                            },
                                                e('td', null,
                                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                                        idx < 3 && e('span', { style: { 
                                                            fontSize: '16px', 
                                                            marginRight: '4px',
                                                            filter: idx === 0 ? 'none' : idx === 1 ? 'grayscale(0.3)' : 'grayscale(0.6)'
                                                        }}, idx === 0 ? '🥇' : idx === 1 ? '🥈' : '🥉'),
                                                        e('div', { className: 'wowy-lineup-cell' },
                                                            combo.players.map((player, pIdx) => 
                                                                e('div', { key: pIdx, className: 'wowy-player-badge' },
                                                                    e('div', { className: 'wowy-player-img on', style: { width: '40px', height: '40px', fontSize: '14px' }},
                                                                        getInitialsLocal(player)
                                                                    ),
                                                                    e('div', { className: 'wowy-player-name', style: { fontSize: '9px' }}, 
                                                                        getSurname(player)
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#94a3b8' }}, combo.minutes.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#64748b' }}, Math.round(combo.poss) + ' poss')
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#4ade80' }}, combo.offRtg.toFixed(1)),
                                                    wowyOffLuckAdj > 0 && e('div', { style: { fontSize: '9px', color: '#fbbf24' }}, 'raw: ' + combo.rawOffRtg.toFixed(1))
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#f87171' }}, combo.defRtg.toFixed(1)),
                                                    wowyDefLuckAdj > 0 && e('div', { style: { fontSize: '9px', color: '#fbbf24' }}, 'raw: ' + combo.rawDefRtg.toFixed(1))
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { 
                                                        style: { 
                                                            fontSize: '20px', 
                                                            fontWeight: 'bold',
                                                            color: combo.netRtg >= 0 ? '#4ade80' : '#f87171',
                                                            background: combo.netRtg >= 10 ? 'rgba(74, 222, 128, 0.2)' : combo.netRtg <= -10 ? 'rgba(248, 113, 113, 0.2)' : 'transparent',
                                                            padding: '4px 12px',
                                                            borderRadius: '8px'
                                                        }
                                                    }, (combo.netRtg >= 0 ? '+' : '') + combo.netRtg.toFixed(1))
                                                )
                                            ),
                                            // Four Factors row
                                            e('tr', { key: idx + '-ff', style: { background: 'rgba(15, 23, 42, 0.4)' }},
                                                e('td', { colSpan: 5, style: { padding: '12px 16px' }},
                                                    e('div', { style: { display: 'flex', gap: '24px', flexWrap: 'wrap' }},
                                                        // Offensive Four Factors
                                                        e('div', { style: { flex: 1, minWidth: '280px' }},
                                                            e('div', { style: { fontSize: '10px', color: '#4ade80', fontWeight: '600', marginBottom: '6px', display: 'flex', alignItems: 'center', gap: '6px' }}, 
                                                                '⚔️ OFFENSE',
                                                                wowyOffLuckAdj > 0 && e('span', { style: { color: '#fbbf24' }}, '🎲')
                                                            ),
                                                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '8px', fontSize: '10px' }},
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'eFG%'),
                                                                    e('div', { style: { color: '#4ade80', fontWeight: 'bold' }}, combo.offEfg.toFixed(1)),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.offEfg))
                                                                ),
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'TOV%'),
                                                                    e('div', { style: { color: '#4ade80', fontWeight: 'bold' }}, combo.offTov.toFixed(1)),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.offTov, true))
                                                                ),
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'OREB%'),
                                                                    e('div', { style: { color: '#4ade80', fontWeight: 'bold' }}, combo.offOreb.toFixed(1)),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.offOreb))
                                                                ),
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'FTR'),
                                                                    e('div', { style: { color: '#4ade80', fontWeight: 'bold' }}, combo.offFtR.toFixed(1)),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.offFtR))
                                                                )
                                                            )
                                                        ),
                                                        // Defensive Four Factors
                                                        e('div', { style: { flex: 1, minWidth: '280px' }},
                                                            e('div', { style: { fontSize: '10px', color: '#f87171', fontWeight: '600', marginBottom: '6px', display: 'flex', alignItems: 'center', gap: '6px' }}, 
                                                                '🛡️ DEFENSE',
                                                                wowyDefLuckAdj > 0 && e('span', { style: { color: '#fbbf24' }}, '🎲')
                                                            ),
                                                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '8px', fontSize: '10px' }},
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'Opp eFG%'),
                                                                    e('div', { style: { color: '#f87171', fontWeight: 'bold' }}, combo.defEfg.toFixed(1)),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.defEfg, true))
                                                                ),
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'Opp TOV%'),
                                                                    e('div', { style: { color: '#f87171', fontWeight: 'bold' }}, combo.defTov.toFixed(1)),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.defTov))
                                                                ),
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'Opp OREB%'),
                                                                    e('div', { style: { color: '#f87171', fontWeight: 'bold' }}, combo.defOreb.toFixed(1)),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.defOreb, true))
                                                                ),
                                                                e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px' }},
                                                                    e('div', { style: { color: '#94a3b8', marginBottom: '2px' }}, 'Opp FTR'),
                                                                    e('div', { style: { color: '#f87171', fontWeight: 'bold' }}, combo.defFtR.toFixed(1)),
                                                                    e('div', { style: { marginTop: '2px' }}, 'Δ ', formatDelta(ffDelta.defFtR, true))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        ];
                                    })
                                )
                            )
                        ),
                        
                        showBestCombos && (!bestCombosData || bestCombosData.length === 0) && e('div', { className: 'wowy-empty' },
                            e('div', { className: 'wowy-empty-icon' }, '🔍'),
                            e('div', null, 'No ' + bestCombosSize + '-player combinations found with ' + wowyMinPoss + '+ minutes'),
                            e('div', { style: { fontSize: '12px', marginTop: '8px', opacity: 0.7 }}, 'Try lowering the minimum minutes requirement')
                        ),

                        // VS Starters WOWY Display
                        showVsStarters && e('div', null,
                            // VS Starters info bar
                            e('div', { style: {
                                padding: '12px 24px',
                                borderBottom: '1px solid rgba(6, 182, 212, 0.3)',
                                background: 'linear-gradient(135deg, rgba(6, 182, 212, 0.1), rgba(8, 145, 178, 0.05))',
                                display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap'
                            }},
                                e('span', { style: { fontSize: '13px', fontWeight: '600', color: '#06b6d4' }}, '🎯 VS Starters WOWY'),
                                e('span', { style: { fontSize: '11px', color: '#94a3b8' }},
                                    'Showing on/off splits vs lineups with 4+ regular starters (min ' + leaderboardTableVsStartersMinGames + ' games started) — configurable in Settings'
                                )
                            ),
                            // VS Starters table
                            wowyPlayers.length > 0 && vsStartersWowyData.filter(c => c.stats).length > 0 ? e('div', { style: { overflowX: 'auto' }},
                                e('table', { className: 'wowy-table' },
                                    e('thead', null,
                                        e('tr', null,
                                            e('th', { style: { minWidth: '200px' }}, 'LINEUP'),
                                            e('th', null, 'MIN'),
                                            e('th', null, 'OFF', wowyOffLuckAdj > 0 && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                            e('th', null, 'DEF', wowyDefLuckAdj > 0 && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                            e('th', null, 'NET', (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲')),
                                            e('th', { style: { minWidth: '320px' }}, 'FOUR FACTORS (OFF / DEF)', (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && e('span', { style: { color: '#fbbf24', fontSize: '10px', marginLeft: '4px' }}, '🎲'))
                                        )
                                    ),
                                    e('tbody', null,
                                        vsStartersWowyData.filter(c => c.stats).map((row, idx) => {
                                            const totalSecs = Math.round(row.minutes || 0);
                                            const minsVal = Math.floor(totalSecs / 60);
                                            const secsVal = totalSecs % 60;
                                            const minsDisplay = minsVal + ':' + String(secsVal).padStart(2, '0');
                                            return e('tr', { key: idx },
                                                e('td', null,
                                                    e('div', { className: 'wowy-lineup-cell' },
                                                        wowyPlayers.map(player =>
                                                            e('div', { key: player, className: 'wowy-player-badge' },
                                                                e('div', {
                                                                    className: 'wowy-player-img ' + (row.combo[player] === 'ON' ? 'on' : 'off')
                                                                },
                                                                    getInitialsLocal(player),
                                                                    e('span', {
                                                                        className: 'wowy-status-badge ' + (row.combo[player] === 'ON' ? 'on' : 'off')
                                                                    }, row.combo[player])
                                                                ),
                                                                e('div', { className: 'wowy-player-name' }, getSurname(player))
                                                            )
                                                        )
                                                    )
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#94a3b8' }}, minsDisplay)
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#4ade80' }}, row.stats.offRtg.toFixed(1)),
                                                    e('div', {
                                                        className: 'wowy-stat-sub ' + (row.stats.offRtg - teamAvgForDelta.off >= 0 ? 'positive' : 'negative')
                                                    }, (row.stats.offRtg - teamAvgForDelta.off >= 0 ? '+' : '') + (row.stats.offRtg - teamAvgForDelta.off).toFixed(1)),
                                                    wowyOffLuckAdj > 0 && row.stats.rawOffRtg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                        'raw: ' + row.stats.rawOffRtg.toFixed(1)
                                                    )
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', { className: 'wowy-stat-main', style: { color: '#f87171' }}, row.stats.defRtg.toFixed(1)),
                                                    e('div', {
                                                        className: 'wowy-stat-sub ' + (row.stats.defRtg - teamAvgForDelta.def <= 0 ? 'positive' : 'negative')
                                                    }, (row.stats.defRtg - teamAvgForDelta.def >= 0 ? '+' : '') + (row.stats.defRtg - teamAvgForDelta.def).toFixed(1)),
                                                    wowyDefLuckAdj > 0 && row.stats.rawDefRtg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                        'raw: ' + row.stats.rawDefRtg.toFixed(1)
                                                    )
                                                ),
                                                e('td', { className: 'wowy-stat' },
                                                    e('div', {
                                                        className: 'wowy-stat-main ' + (row.stats.netRtg >= 0 ? 'wowy-net-positive' : 'wowy-net-negative'),
                                                        style: { fontSize: '20px' }
                                                    }, (row.stats.netRtg >= 0 ? '+' : '') + row.stats.netRtg.toFixed(1)),
                                                    (wowyOffLuckAdj > 0 || wowyDefLuckAdj > 0) && row.stats.rawNetRtg !== undefined && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                                        'raw: ' + (row.stats.rawNetRtg >= 0 ? '+' : '') + row.stats.rawNetRtg.toFixed(1)
                                                    )
                                                ),
                                                e('td', null,
                                                    e('div', { style: { display: 'flex', flexDirection: 'column', gap: '6px' }},
                                                        e('div', null,
                                                            e('div', { style: { fontSize: '9px', color: '#4ade80', fontWeight: '600', marginBottom: '4px' }}, '⚔️ OFFENSE'),
                                                            e('div', { className: 'wowy-ff-grid' },
                                                                e('div', { className: 'wowy-ff-item' },
                                                                    e('div', { className: 'wowy-ff-label' }, 'eFG%', wowyOffLuckAdj > 0 && e('span', { style: { color: '#fbbf24', marginLeft: '2px' }}, '🎲')),
                                                                    e('div', { className: 'wowy-ff-value', style: { color: '#4ade80' }}, row.stats.offEfg.toFixed(1))
                                                                ),
                                                                e('div', { className: 'wowy-ff-item' },
                                                                    e('div', { className: 'wowy-ff-label' }, 'TOV%'),
                                                                    e('div', { className: 'wowy-ff-value', style: { color: '#4ade80' }}, row.stats.offTov.toFixed(1))
                                                                ),
                                                                e('div', { className: 'wowy-ff-item' },
                                                                    e('div', { className: 'wowy-ff-label' }, 'OREB%'),
                                                                    e('div', { className: 'wowy-ff-value', style: { color: '#4ade80' }}, row.stats.offOreb.toFixed(1))
                                                                ),
                                                                e('div', { className: 'wowy-ff-item' },
                                                                    e('div', { className: 'wowy-ff-label' }, 'FTR'),
                                                                    e('div', { className: 'wowy-ff-value', style: { color: '#4ade80' }}, row.stats.offFtR.toFixed(1))
                                                                )
                                                            )
                                                        ),
                                                        e('div', null,
                                                            e('div', { style: { fontSize: '9px', color: '#f87171', fontWeight: '600', marginBottom: '4px' }}, '🛡️ DEFENSE'),
                                                            e('div', { className: 'wowy-ff-grid' },
                                                                e('div', { className: 'wowy-ff-item' },
                                                                    e('div', { className: 'wowy-ff-label' }, 'Opp eFG%', wowyDefLuckAdj > 0 && e('span', { style: { color: '#fbbf24', marginLeft: '2px' }}, '🎲')),
                                                                    e('div', { className: 'wowy-ff-value', style: { color: '#f87171' }}, row.stats.defEfg.toFixed(1))
                                                                ),
                                                                e('div', { className: 'wowy-ff-item' },
                                                                    e('div', { className: 'wowy-ff-label' }, 'Opp TOV%'),
                                                                    e('div', { className: 'wowy-ff-value', style: { color: '#f87171' }}, row.stats.defTov.toFixed(1))
                                                                ),
                                                                e('div', { className: 'wowy-ff-item' },
                                                                    e('div', { className: 'wowy-ff-label' }, 'Opp OREB%'),
                                                                    e('div', { className: 'wowy-ff-value', style: { color: '#f87171' }}, row.stats.defOreb.toFixed(1))
                                                                ),
                                                                e('div', { className: 'wowy-ff-item' },
                                                                    e('div', { className: 'wowy-ff-label' }, 'Opp FTR'),
                                                                    e('div', { className: 'wowy-ff-value', style: { color: '#f87171' }}, row.stats.defFtR.toFixed(1))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            );
                                        })
                                    )
                                )
                            ) : wowyPlayers.length > 0 ? e('div', { className: 'wowy-empty' },
                                e('div', { className: 'wowy-empty-icon' }, '🎯'),
                                e('div', null, 'No VS Starters data found with ' + wowyMinPoss + '+ minutes'),
                                e('div', { style: { fontSize: '12px', marginTop: '8px', opacity: 0.7 }}, 'Ensure stints CSV is loaded and try lowering minimum minutes')
                            ) : e('div', { className: 'wowy-empty' },
                                e('div', { className: 'wowy-empty-icon' }, '👇'),
                                e('div', null, 'Select players below to see their VS Starters on/off splits'),
                                e('div', { style: { fontSize: '12px', marginTop: '8px', opacity: 0.7 }}, 'Shows performance when facing opponent lineups with 4+ regular starters')
                            )
                        ),

                        // Player Selector (hide when best combos is shown)
                        !showBestCombos && e('div', { className: 'wowy-selector' },
                            e('div', { className: 'wowy-selector-title' }, 
                                'Select Players (' + wowyPlayers.length + '/5)',
                                wowyPlayers.length >= 5 && e('span', { style: { color: '#f59e0b', marginLeft: '8px' }}, '• Maximum reached')
                            ),
                            e('div', { className: 'wowy-player-grid' },
                                teamPlayers.map(player =>
                                    e('div', {
                                        key: player,
                                        className: 'wowy-player-select' + (wowyPlayers.includes(player) ? ' selected' : ''),
                                        onClick: () => toggleWowyPlayer(player),
                                        style: wowyPlayers.length >= 5 && !wowyPlayers.includes(player) ? { opacity: 0.4, cursor: 'not-allowed' } : {}
                                    },
                                        e('div', { className: 'wowy-player-img' }, getInitialsLocal(player)),
                                        e('div', { className: 'wowy-player-name' }, getSurname(player))
                                    )
                                )
                            )
                        )
                    )
                );
            };

            // =======================================================================
            // V4.4: COMPARISON TAB COMPONENT
            // Compare any two 5-player combinations across teams (or team-wide)
            // =======================================================================
            const CompareSection = () => {
                // Get players for each team
                const getTeamPlayers = (teamName) => {
                    if (!teamName) return [];
                    const s = new Set();
                    lineupData.filter(d => d.Team === teamName).forEach(d => { 
                        if (d.Lineup) d.Lineup.split(',').forEach(p => { const t = p.trim(); if (t) s.add(t); }); 
                    });
                    return Array.from(s).sort();
                };
                
                const teamAPlayers = getTeamPlayers(compareTeamA);
                const teamBPlayers = getTeamPlayers(compareTeamB);
                
                // Get all lineups for a team for quick selection
                const getTeamLineups = (teamName) => {
                    if (!teamName) return [];
                    return lineupData.filter(d => d.Team === teamName).map(d => {
                        const fga = parseFloat(d.FGA) || 0, oreb = parseFloat(d.OREB) || 0, tov = parseFloat(d.TOV) || 0, fta = parseFloat(d.FTA) || 0;
                        const fgaVs = parseFloat(d.FGA_VS) || 0, orebVs = parseFloat(d.OREB_VS) || 0, tovVs = parseFloat(d.TOV_VS) || 0, ftaVs = parseFloat(d.FTA_VS) || 0;
                        const poss = calcPoss(fga, oreb, tov, fta) + calcPoss(fgaVs, orebVs, tovVs, ftaVs);
                        // V6.1: Apply merge rules for player display
                        return { lineup: d.Lineup, poss, players: d.Lineup ? d.Lineup.split(',').map(p => applyPlayerMerge(p.trim())) : [] };
                    }).sort((a, b) => b.poss - a.poss).slice(0, 30);
                };
                
                const teamALineups = getTeamLineups(compareTeamA);
                const teamBLineups = getTeamLineups(compareTeamB);
                
                // Calculate stats for a set of players (or team-wide if no players selected)
                const calcCombinationStats = (players, teamName) => {
                    if (!teamName) return null;
                    
                    const validPlayers = players.filter(p => p);
                    const isTeamWide = validPlayers.length === 0;
                    
                    let matchingLineups;
                    if (isTeamWide) {
                        // Team-wide: use all lineups for this team
                        matchingLineups = lineupData.filter(d => d.Team === teamName);
                    } else {
                        // Player-specific: filter to lineups containing all selected players
                        const playerNorms = validPlayers.map(p => normalizePlayerName(p));
                        matchingLineups = lineupData.filter(d => {
                            if (d.Team !== teamName) return false;
                            const lp = d.Lineup ? d.Lineup.split(',').map(p => normalizePlayerName(p.trim())) : [];
                            return playerNorms.every(pn => lp.includes(pn));
                        });
                    }
                    
                    if (matchingLineups.length === 0) return null;
                    
                    // Aggregate stats
                    const t = matchingLineups.reduce((a, d) => {
                        const time = parseFloat(d.TOTAL_TIME)||0;
                        const fga = parseFloat(d.FGA)||0, oreb = parseFloat(d.OREB)||0, tov = parseFloat(d.TOV)||0, fta = parseFloat(d.FTA)||0;
                        const fgaV = parseFloat(d.FGA_VS)||0, orebV = parseFloat(d.OREB_VS)||0, tovV = parseFloat(d.TOV_VS)||0, ftaV = parseFloat(d.FTA_VS)||0;
                        const poss = calcPoss(fga, oreb, tov, fta), possV = calcPoss(fgaV, orebV, tovV, ftaV);
                        const fgm = parseFloat(d.FGM)||0, tpm = parseFloat(d['3PM'])||0, tpa = parseFloat(d['3PA'])||0;
                        const fgmV = parseFloat(d.FGM_VS)||0, tpmV = parseFloat(d['3PM_VS'])||0, tpaV = parseFloat(d['3PA_VS'])||0;
                        const dreb = parseFloat(d.DREB)||0, drebV = parseFloat(d.DREB_VS)||0;
                        const ast = parseFloat(d.AST)||0, stl = parseFloat(d.STL)||0, blk = parseFloat(d.BLK)||0;
                        const ftm = parseFloat(d.FTM)||0, ftmV = parseFloat(d.FTM_VS)||0;
                        const rimA = parseFloat(d.RIM_ATT)||0, rimM = parseFloat(d.RIM_MADE)||0;
                        const midA = parseFloat(d.OTD_2PT_ATT)||0, midM = parseFloat(d.OTD_2PT_MADE)||0;
                        const threeA = parseFloat(d.OTD_3PT_ATT)||0, threeM = parseFloat(d.OTD_3PT_MADE)||0;
                        const rimAV = parseFloat(d.RIM_ATT_VS)||0, rimMV = parseFloat(d.RIM_MADE_VS)||0;
                        const midAV = parseFloat(d.OTD_2PT_ATT_VS)||0, midMV = parseFloat(d.OTD_2PT_MADE_VS)||0;
                        const threeAV = parseFloat(d.OTD_3PT_ATT_VS)||0, threeMV = parseFloat(d.OTD_3PT_MADE_VS)||0;
                        const secChance = parseFloat(d['2ND_CHANCE_PTS'])||0, fastBreak = parseFloat(d.FAST_BREAK_PTS)||0, ptsOffTov = parseFloat(d.PTS_OFF_TOV)||0;
                        const secChanceV = parseFloat(d['2ND_CHANCE_PTS_VS'])||0, fastBreakV = parseFloat(d.FAST_BREAK_PTS_VS)||0, ptsOffTovV = parseFloat(d.PTS_OFF_TOV_VS)||0;
                        const passTo = parseFloat(d.PASS_TO)||0, dribTo = parseFloat(d.DRIBBLE_TO)||0, defTo = parseFloat(d.DEFENSE_TO)||0, miscTo = parseFloat(d.MISC_TO)||0;
                        const passToV = parseFloat(d.PASS_TO_VS)||0, dribToV = parseFloat(d.DRIBBLE_TO_VS)||0, defToV = parseFloat(d.DEFENSE_TO_VS)||0, miscToV = parseFloat(d.MISC_TO_VS)||0;
                        const paceF = parseFloat(d.PACE_FOR)||0, paceV = parseFloat(d.PACE_VS)||0;
                        return {
                            time: a.time + time, poss: a.poss + poss, possV: a.possV + possV,
                            fgm: a.fgm + fgm, fga: a.fga + fga, tpm: a.tpm + tpm, tpa: a.tpa + tpa, fta: a.fta + fta, ftm: a.ftm + ftm,
                            oreb: a.oreb + oreb, dreb: a.dreb + dreb, tov: a.tov + tov, ast: a.ast + ast, stl: a.stl + stl, blk: a.blk + blk,
                            fgmV: a.fgmV + fgmV, fgaV: a.fgaV + fgaV, tpmV: a.tpmV + tpmV, tpaV: a.tpaV + tpaV, ftaV: a.ftaV + ftaV, ftmV: a.ftmV + ftmV,
                            orebV: a.orebV + orebV, drebV: a.drebV + drebV, tovV: a.tovV + tovV,
                            rimA: a.rimA + rimA, rimM: a.rimM + rimM, midA: a.midA + midA, midM: a.midM + midM, threeA: a.threeA + threeA, threeM: a.threeM + threeM,
                            rimAV: a.rimAV + rimAV, rimMV: a.rimMV + rimMV, midAV: a.midAV + midAV, midMV: a.midMV + midMV, threeAV: a.threeAV + threeAV, threeMV: a.threeMV + threeMV,
                            secChance: a.secChance + secChance, fastBreak: a.fastBreak + fastBreak, ptsOffTov: a.ptsOffTov + ptsOffTov,
                            secChanceV: a.secChanceV + secChanceV, fastBreakV: a.fastBreakV + fastBreakV, ptsOffTovV: a.ptsOffTovV + ptsOffTovV,
                            passTo: a.passTo + passTo, dribTo: a.dribTo + dribTo, defTo: a.defTo + defTo, miscTo: a.miscTo + miscTo,
                            passToV: a.passToV + passToV, dribToV: a.dribToV + dribToV, defToV: a.defToV + defToV, miscToV: a.miscToV + miscToV,
                            wPaceF: a.wPaceF + paceF * time, wPaceV: a.wPaceV + paceV * time
                        };
                    }, { time: 0, poss: 0, possV: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, tov: 0, ast: 0, stl: 0, blk: 0, fgmV: 0, fgaV: 0, tpmV: 0, tpaV: 0, ftaV: 0, ftmV: 0, orebV: 0, drebV: 0, tovV: 0, rimA: 0, rimM: 0, midA: 0, midM: 0, threeA: 0, threeM: 0, rimAV: 0, rimMV: 0, midAV: 0, midMV: 0, threeAV: 0, threeMV: 0, secChance: 0, fastBreak: 0, ptsOffTov: 0, secChanceV: 0, fastBreakV: 0, ptsOffTovV: 0, passTo: 0, dribTo: 0, defTo: 0, miscTo: 0, passToV: 0, dribToV: 0, defToV: 0, miscToV: 0, wPaceF: 0, wPaceV: 0 });
                    
                    // Calculate rates
                    const pts = 2 * t.fgm + t.tpm + t.ftm;
                    const ptsV = 2 * t.fgmV + t.tpmV + t.ftmV;
                    let off = t.poss > 0 ? (pts / t.poss) * 100 : 0;
                    let def = t.possV > 0 ? (ptsV / t.possV) * 100 : 0;
                    let offEfgRaw = t.fga > 0 ? ((t.fgm + 0.5*t.tpm)/t.fga)*100 : 0;
                    let defEfgRaw = t.fgaV > 0 ? ((t.fgmV + 0.5*t.tpmV)/t.fgaV)*100 : 0;
                    
                    // Apply luck adjustment if enabled
                    if (compareLuckAdj > 0 && leagueAverages) {
                        const leagueAvg3Pct = 36;
                        const expected3pm = t.tpa * (leagueAvg3Pct / 100);
                        const offAdj = (t.tpm - expected3pm) * (compareLuckAdj / 100);
                        const expectedOpp3pm = t.tpaV * (leagueAvg3Pct / 100);
                        const defAdj = (t.tpmV - expectedOpp3pm) * (compareLuckAdj / 100);
                        const adjPts = pts - offAdj * 3;
                        const adjPtsV = ptsV - defAdj * 3;
                        off = t.poss > 0 ? (adjPts / t.poss) * 100 : 0;
                        def = t.possV > 0 ? (adjPtsV / t.possV) * 100 : 0;
                    }
                    
                    const totalShots = t.rimA + t.midA + t.threeA;
                    const totalShotsV = t.rimAV + t.midAV + t.threeAV;
                    const totalTo = t.passTo + t.dribTo + t.defTo + t.miscTo;
                    const totalToV = t.passToV + t.dribToV + t.defToV + t.miscToV;
                    
                    return {
                        poss: t.poss + t.possV,
                        offPoss: t.poss,
                        defPoss: t.possV,
                        off, def, net: off - def,
                        paceF: t.time > 0 ? t.wPaceF / t.time : 0,
                        paceV: t.time > 0 ? t.wPaceV / t.time : 0,
                        offEfg: offEfgRaw,
                        offTov: t.poss > 0 ? (t.tov/t.poss)*100 : 0,
                        offOreb: (t.oreb+t.drebV) > 0 ? (t.oreb/(t.oreb+t.drebV))*100 : 0,
                        offFtR: t.fga > 0 ? (t.fta/t.fga)*100 : 0,
                        defEfg: defEfgRaw,
                        defTov: t.possV > 0 ? (t.tovV/t.possV)*100 : 0,
                        defOreb: (t.orebV+t.dreb) > 0 ? (t.orebV/(t.orebV+t.dreb))*100 : 0,
                        defFtR: t.fgaV > 0 ? (t.ftaV/t.fgaV)*100 : 0,
                        rimPct: t.rimA > 0 ? (t.rimM/t.rimA)*100 : 0,
                        midPct: t.midA > 0 ? (t.midM/t.midA)*100 : 0,
                        threePct: t.threeA > 0 ? (t.threeM/t.threeA)*100 : 0,
                        rimRate: totalShots > 0 ? (t.rimA/totalShots)*100 : 0,
                        midRate: totalShots > 0 ? (t.midA/totalShots)*100 : 0,
                        threeRate: totalShots > 0 ? (t.threeA/totalShots)*100 : 0,
                        rimPctV: t.rimAV > 0 ? (t.rimMV/t.rimAV)*100 : 0,
                        midPctV: t.midAV > 0 ? (t.midMV/t.midAV)*100 : 0,
                        threePctV: t.threeAV > 0 ? (t.threeMV/t.threeAV)*100 : 0,
                        rimRateV: totalShotsV > 0 ? (t.rimAV/totalShotsV)*100 : 0,
                        midRateV: totalShotsV > 0 ? (t.midAV/totalShotsV)*100 : 0,
                        threeRateV: totalShotsV > 0 ? (t.threeAV/totalShotsV)*100 : 0,
                        // V4.6.1: Add raw shot data for contribution calculation
                        rimAtt: t.rimA, rimM: t.rimM, midAtt: t.midA, midM: t.midM, threeAtt: t.threeA, threeM: t.threeM,
                        rimAttV: t.rimAV, rimMV: t.rimMV, midAttV: t.midAV, midMV: t.midMV, threeAttV: t.threeAV, threeMV: t.threeMV,
                        passToPct: totalTo > 0 ? (t.passTo/totalTo)*100 : 0,
                        dribToPct: totalTo > 0 ? (t.dribTo/totalTo)*100 : 0,
                        defToPct: totalTo > 0 ? (t.defTo/totalTo)*100 : 0,
                        miscToPct: totalTo > 0 ? (t.miscTo/totalTo)*100 : 0,
                        passToVPct: totalToV > 0 ? (t.passToV/totalToV)*100 : 0,
                        dribToVPct: totalToV > 0 ? (t.dribToV/totalToV)*100 : 0,
                        defToVPct: totalToV > 0 ? (t.defToV/totalToV)*100 : 0,
                        miscToVPct: totalToV > 0 ? (t.miscToV/totalToV)*100 : 0,
                        fastBreak100: t.poss > 0 ? (t.fastBreak/t.poss)*100 : 0,
                        fastBreak100V: t.possV > 0 ? (t.fastBreakV/t.possV)*100 : 0,
                        ptsOffTov100: t.poss > 0 ? (t.ptsOffTov/t.poss)*100 : 0,
                        ptsOffTov100V: t.possV > 0 ? (t.ptsOffTovV/t.possV)*100 : 0,
                        secChance100: t.poss > 0 ? (t.secChance/t.poss)*100 : 0,
                        secChance100V: t.possV > 0 ? (t.secChanceV/t.possV)*100 : 0,
                        astPct: t.fgm > 0 ? (t.ast/t.fgm)*100 : 0,
                        stlPct: t.possV > 0 ? (t.stl/t.possV)*100 : 0,
                        blkPct: (t.fgaV-t.tpaV) > 0 ? (t.blk/(t.fgaV-t.tpaV))*100 : 0,
                        isTeamWide
                    };
                };
                
                const statsA = calcCombinationStats(comparePlayersA, compareTeamA);
                const statsB = calcCombinationStats(comparePlayersB, compareTeamB);
                
                // Helper to set a player slot
                const setPlayerSlot = (side, index, player) => {
                    if (side === 'A') {
                        const newPlayers = [...comparePlayersA];
                        newPlayers[index] = player;
                        setComparePlayersA(newPlayers);
                    } else {
                        const newPlayers = [...comparePlayersB];
                        newPlayers[index] = player;
                        setComparePlayersB(newPlayers);
                    }
                };
                
                // Helper to load full lineup
                const loadLineup = (side, players) => {
                    const p = players.slice(0, 5);
                    while (p.length < 5) p.push('');
                    if (side === 'A') setComparePlayersA(p);
                    else setComparePlayersB(p);
                };
                
                // Get display value (raw or relative to league)
                const getDisplayValue = (value, leagueAvgKey, format = 1) => {
                    if (!showRelativeToLeague || !leagueAverages) return value.toFixed(format);
                    const leagueVal = leagueAverages[leagueAvgKey] || 0;
                    const diff = value - leagueVal;
                    return (diff >= 0 ? '+' : '') + diff.toFixed(format);
                };
                
                // V4.7.1: eFG% Matchup Modeling - uses player on/off impacts OR team-wide stats to project eFG%
                // Models: Team A offense vs Team B defense, and vice versa
                // UPDATED with: correct sign, minimum poss, linear k scaling, soft clamping, interaction terms
                const modelCompareMatchup = (offPlayers, offTeam, defPlayers, defTeam, offStats, defStats) => {
                    if (!leagueAvgShotStats) return null;
                    if (comparePriorStrength === 0) return null; // Skip if modeling disabled
                    
                    const validOffPlayers = offPlayers.filter(p => p);
                    const validDefPlayers = defPlayers.filter(p => p);
                    
                    // Get on/off impacts for players (simplified version - full RAPM is in main model)
                    const getPlayerImpacts = (players, teamName) => {
                        if (players.length === 0) return null;
                        
                        const impacts = {
                            rimPct: 0, midPct: 0, threePct: 0,
                            rimVol: 0, midVol: 0, threeVol: 0,
                            rimPctV: 0, midPctV: 0, threePctV: 0,
                            rimVolV: 0, midVolV: 0, threeVolV: 0,
                            totalOnPoss: 0, playerCount: 0
                        };
                        
                        players.forEach(name => {
                            const d = onOffData.find(p => p.player === name && (teamName ? p.team === teamName : true));
                            if (!d || !d.onStats || !d.offStats) return;
                            
                            impacts.totalOnPoss += d.onPoss || 0;
                            impacts.playerCount++;
                            
                            // Offensive impacts
                            impacts.rimPct += (d.onStats.rimPct || 0) - (d.offStats.rimPct || 0);
                            impacts.midPct += (d.onStats.midPct || 0) - (d.offStats.midPct || 0);
                            impacts.threePct += (d.onStats.threePct || 0) - (d.offStats.threePct || 0);
                            impacts.rimVol += (d.onStats.rimVol || 0) - (d.offStats.rimVol || 0);
                            impacts.midVol += (d.onStats.midVol || 0) - (d.offStats.midVol || 0);
                            impacts.threeVol += (d.onStats.threeVol || 0) - (d.offStats.threeVol || 0);
                            // Defensive impacts
                            impacts.rimPctV += (d.onStats.rimPctV || 0) - (d.offStats.rimPctV || 0);
                            impacts.midPctV += (d.onStats.midPctV || 0) - (d.offStats.midPctV || 0);
                            impacts.threePctV += (d.onStats.threePctV || 0) - (d.offStats.threePctV || 0);
                            impacts.rimVolV += (d.onStats.rimVolV || 0) - (d.offStats.rimVolV || 0);
                            impacts.midVolV += (d.onStats.midVolV || 0) - (d.offStats.midVolV || 0);
                            impacts.threeVolV += (d.onStats.threeVolV || 0) - (d.offStats.threeVolV || 0);
                        });
                        
                        // V4.7.1b: Softer correlation adjustment (n^0.15 barely noticeable)
                        if (impacts.playerCount > 1) {
                            const corrFactor = Math.pow(impacts.playerCount, 0.15);
                            ['rimPct', 'midPct', 'threePct', 'rimVol', 'midVol', 'threeVol',
                             'rimPctV', 'midPctV', 'threePctV', 'rimVolV', 'midVolV', 'threeVolV'].forEach(k => {
                                impacts[k] /= corrFactor;
                            });
                        }
                        
                        return impacts.playerCount > 0 ? impacts : null;
                    };
                    
                    // Get team-wide shot profile differences from league average
                    const getTeamProfile = (stats, isOffense) => {
                        if (!stats || !leagueAvgShotStats) return null;
                        
                        if (isOffense) {
                            return {
                                rimPct: (stats.rimPct || 0) - leagueAvgShotStats.rimPct,
                                midPct: (stats.midPct || 0) - leagueAvgShotStats.midPct,
                                threePct: (stats.threePct || 0) - leagueAvgShotStats.threePct,
                                rimVol: (stats.rimRate || 0) - leagueAvgShotStats.rimVol,
                                midVol: (stats.midRate || 0) - leagueAvgShotStats.midVol,
                                threeVol: (stats.threeRate || 0) - leagueAvgShotStats.threeVol,
                                poss: stats.offPoss || 100
                            };
                        } else {
                            // Defense: how opponents shoot against this team
                            return {
                                rimPctV: (stats.rimPctV || 0) - leagueAvgShotStats.rimPctV,
                                midPctV: (stats.midPctV || 0) - leagueAvgShotStats.midPctV,
                                threePctV: (stats.threePctV || 0) - leagueAvgShotStats.threePctV,
                                rimVolV: (stats.rimRateV || 0) - leagueAvgShotStats.rimVolV,
                                midVolV: (stats.midRateV || 0) - leagueAvgShotStats.midVolV,
                                threeVolV: (stats.threeRateV || 0) - leagueAvgShotStats.threeVolV,
                                poss: stats.defPoss || 100
                            };
                        }
                    };
                    
                    // Get player impacts or fall back to team-wide profiles
                    let offImpacts = getPlayerImpacts(validOffPlayers, offTeam);
                    let defImpacts = getPlayerImpacts(validDefPlayers, defTeam);
                    
                    // If no player data, use team-wide profiles
                    const offTeamProfile = !offImpacts && offStats ? getTeamProfile(offStats, true) : null;
                    const defTeamProfile = !defImpacts && defStats ? getTeamProfile(defStats, false) : null;
                    
                    // If we have neither player impacts nor team profiles, return null
                    if (!offImpacts && !offTeamProfile && !defImpacts && !defTeamProfile) return null;
                    
                    // Calculate reliability weight
                    const offPoss = offImpacts?.totalOnPoss || offTeamProfile?.poss || 0;
                    const defPoss = defImpacts?.totalOnPoss || defTeamProfile?.poss || 0;
                    const offCount = offImpacts?.playerCount || (offTeamProfile ? 5 : 0); // Team = 5 players worth
                    const defCount = defImpacts?.playerCount || (defTeamProfile ? 5 : 0);
                    
                    // V4.7.1b FIX: Use MINIMUM for combined poss (bottleneck principle)
                    const combinedPoss = offPoss > 0 && defPoss > 0 ? 
                        Math.min(offPoss, defPoss) : 
                        Math.max(offPoss, defPoss);
                    const combinedCount = offCount + defCount;
                    
                    // V4.7.1b: k scales with SQRT of player count (gentler - lets matchup effects show)
                    const k = comparePriorStrength * Math.sqrt(Math.max(1, combinedCount));
                    const reliabilityWeight = combinedPoss / (combinedPoss + k);
                    
                    // V4.7.1 FIX: Combined impact with CORRECT SIGN and INTERACTION TERMS
                    // Offense: positive rimPct = shoots better at rim than average
                    // Defense: positive rimPctV = allows opponents to shoot better at rim than average (bad D)
                    // Therefore we ADD defensive impact (bad D helps offense)
                    const interactionStrength = 0.02;
                    const combinedImpacts = {};
                    ['rimPct', 'midPct', 'threePct', 'rimVol', 'midVol', 'threeVol'].forEach(key => {
                        const offImp = offImpacts?.[key] || offTeamProfile?.[key] || 0;
                        const defImp = defImpacts?.[key + 'V'] || defTeamProfile?.[key + 'V'] || 0;
                        // V4.7.1: ADD defensive impact (not subtract) + interaction term
                        combinedImpacts[key] = offImp + defImp + interactionStrength * offImp * defImp;
                    });
                    
                    // V4.7.1: Soft clamping via logit transformation
                    const softClamp = (leaguePct, impact, weight, minPct, maxPct) => {
                        const leagueP = Math.max(0.01, Math.min(0.99, leaguePct / 100));
                        const impactP = impact / 100;
                        const logitP = Math.log(leagueP / (1 - leagueP));
                        const jacobian = leagueP * (1 - leagueP);
                        const impactLogit = jacobian > 0.01 ? impactP / jacobian : impactP * 10;
                        const projLogit = logitP + impactLogit * weight;
                        const projP = 1 / (1 + Math.exp(-projLogit));
                        return Math.max(minPct, Math.min(maxPct, projP * 100));
                    };
                    
                    // Project with soft clamping
                    const projected = {
                        rimPct: softClamp(leagueAvgShotStats.rimPct, combinedImpacts.rimPct, reliabilityWeight, 40, 80),
                        midPct: softClamp(leagueAvgShotStats.midPct, combinedImpacts.midPct, reliabilityWeight, 25, 60),
                        threePct: softClamp(leagueAvgShotStats.threePct, combinedImpacts.threePct, reliabilityWeight, 20, 50),
                        rimVol: leagueAvgShotStats.rimVol + combinedImpacts.rimVol * reliabilityWeight,
                        midVol: leagueAvgShotStats.midVol + combinedImpacts.midVol * reliabilityWeight,
                        threeVol: leagueAvgShotStats.threeVol + combinedImpacts.threeVol * reliabilityWeight
                    };
                    
                    // V4.7.1: Normalize volumes to league-derived FGA/100
                    const targetFga = leagueAvgShotStats.fgaPer100 || 80;
                    projected.rimVol = Math.max(1, projected.rimVol);
                    projected.midVol = Math.max(1, projected.midVol);
                    projected.threeVol = Math.max(1, projected.threeVol);
                    const totalVol = projected.rimVol + projected.midVol + projected.threeVol;
                    if (totalVol > 0) {
                        const scale = targetFga / totalVol;
                        projected.rimVol *= scale;
                        projected.midVol *= scale;
                        projected.threeVol *= scale;
                    }
                    
                    // Calculate modeled eFG%
                    const total = projected.rimVol + projected.midVol + projected.threeVol;
                    const modeledEfg = (
                        (projected.rimVol / total) * projected.rimPct +
                        (projected.midVol / total) * projected.midPct +
                        (projected.threeVol / total) * projected.threePct * 1.5
                    );
                    
                    // V4.7.1: Estimate confidence interval
                    const avgVariance = 25; // Approximate variance for on/off differentials
                    const efgVariance = avgVariance * reliabilityWeight * reliabilityWeight * 
                        (Math.pow(projected.rimVol/total, 2) + Math.pow(projected.midVol/total, 2) + 
                         Math.pow(1.5 * projected.threeVol/total, 2));
                    const efgSE = Math.sqrt(efgVariance);
                    
                    return {
                        modeledEfg,
                        projected,
                        combinedImpacts,
                        offImpacts,
                        defImpacts,
                        offTeamProfile,
                        defTeamProfile,
                        reliabilityWeight,
                        combinedPoss,
                        k,
                        usedTeamWide: !offImpacts || !defImpacts,
                        // V4.7.1: Additional diagnostics
                        standardError: efgSE,
                        ci95: [modeledEfg - 1.96 * efgSE, modeledEfg + 1.96 * efgSE]
                    };
                };
                
                // Model Team A offense vs Team B defense (pass stats for team-wide fallback)
                const modeledAvsB = modelCompareMatchup(comparePlayersA, compareTeamA, comparePlayersB, compareTeamB, statsA, statsB);
                // Model Team B offense vs Team A defense  
                const modeledBvsA = modelCompareMatchup(comparePlayersB, compareTeamB, comparePlayersA, compareTeamA, statsB, statsA);
                
                // TUG OF WAR comparison row component
                // V4.6.1: Fixed opponent adjustment to use OPPONENT's corresponding stat quality
                // V4.6.3: Added master slider integration
                const TugOfWarRow = ({ label, valueA, valueB, higherBetter = true, format = 1, leagueKey, oppAdjKey }) => {
                    // V4.6.3: Combine master slider + individual slider (capped at 100)
                    const individualAdj = oppAdjKey ? (compareOppAdj[oppAdjKey] || 0) : 0;
                    const oppAdj = Math.min(100, compareMasterOppAdj + individualAdj);
                    
                    // Apply opponent-specific strength adjustment
                    // For offensive stats: adjust based on opponent's corresponding DEFENSIVE stat
                    // For defensive stats: adjust based on opponent's corresponding OFFENSIVE stat
                    let adjA = valueA, adjB = valueB;
                    if (oppAdj > 0 && leagueAverages && leagueKey && statsA && statsB) {
                        const leagueAvg = leagueAverages[leagueKey] || ((valueA + valueB) / 2);
                        const adjFactor = oppAdj / 100;
                        
                        // Map offensive stat to corresponding defensive stat
                        const statMappings = {
                            'off': 'def', 'offEfg': 'defEfg', 'offTov': 'defTov', 'offOreb': 'defOreb', 'offFtR': 'defFtR',
                            'def': 'off', 'defEfg': 'offEfg', 'defTov': 'offTov', 'defOreb': 'offOreb', 'defFtR': 'offFtR'
                        };
                        const correspondingStat = statMappings[leagueKey];
                        
                        if (correspondingStat) {
                            const isOffensiveStat = leagueKey.startsWith('off');
                            const oppStatKey = correspondingStat;
                            const oppLeagueAvg = leagueAverages[oppStatKey] || leagueAvg;
                            
                            // Get opponent's quality in the corresponding stat
                            // Team A faces Team B, Team B faces Team A
                            const bOppStatVal = statsB[oppStatKey] || oppLeagueAvg;
                            const aOppStatVal = statsA[oppStatKey] || oppLeagueAvg;
                            
                            // Calculate how much opponent differs from league average
                            const bOppDiff = bOppStatVal - oppLeagueAvg;
                            const aOppDiff = aOppStatVal - oppLeagueAvg;
                            
                            if (isOffensiveStat) {
                                // For offensive stats facing defense:
                                // - If opponent has HIGH defEfg (weak D, allows good shooting), our offense looks inflated → adjust DOWN
                                // - If opponent has LOW defEfg (strong D), our offense looks deflated → adjust UP
                                // - For TOV%: opponent's high defTov% (forces turnovers) = strong D
                                if (leagueKey === 'offTov') {
                                    // High opponent defTov% = they force TOs = makes our TOV% look worse
                                    adjA = valueA - bOppDiff * adjFactor * 0.5;
                                    adjB = valueB - aOppDiff * adjFactor * 0.5;
                                } else {
                                    // High opponent defEfg/defOreb/defFtR = weak D = inflates our stats
                                    adjA = valueA - bOppDiff * adjFactor * 0.5;
                                    adjB = valueB - aOppDiff * adjFactor * 0.5;
                                }
                            } else {
                                // For defensive stats facing offense:
                                // - If opponent has HIGH offEfg (good O), our defense looks worse → adjust DOWN (improve)
                                // - If opponent has LOW offEfg (weak O), our defense looks better → adjust UP (worsen)
                                if (leagueKey === 'defTov') {
                                    // High opponent offTov% = they turn it over a lot = makes our forced TOV look inflated
                                    adjA = valueA - bOppDiff * adjFactor * 0.5;
                                    adjB = valueB - aOppDiff * adjFactor * 0.5;
                                } else {
                                    // High opponent offEfg/offOreb/offFtR = good O = makes our D look worse
                                    adjA = valueA - bOppDiff * adjFactor * 0.5;
                                    adjB = valueB - aOppDiff * adjFactor * 0.5;
                                }
                            }
                        }
                    }
                    
                    const diff = adjA - adjB;
                    const absDiff = Math.abs(diff);
                    const winner = higherBetter ? (diff > 0.3 ? 'A' : diff < -0.3 ? 'B' : 'tie') : (diff < -0.3 ? 'A' : diff > 0.3 ? 'B' : 'tie');
                    
                    // Calculate bar width as percentage of half the bar (max 45% from center)
                    const maxDiff = 15; // Normalize: 15 point diff = full bar
                    const barWidth = Math.min(45, (absDiff / maxDiff) * 45);
                    
                    // Get display values
                    const displayA = showRelativeToLeague && leagueAverages && leagueKey ? 
                        ((adjA - (leagueAverages[leagueKey] || 0)) >= 0 ? '+' : '') + (adjA - (leagueAverages[leagueKey] || 0)).toFixed(format) :
                        adjA.toFixed(format);
                    const displayB = showRelativeToLeague && leagueAverages && leagueKey ? 
                        ((adjB - (leagueAverages[leagueKey] || 0)) >= 0 ? '+' : '') + (adjB - (leagueAverages[leagueKey] || 0)).toFixed(format) :
                        adjB.toFixed(format);
                    
                    return e('div', { style: { marginBottom: '16px' }},
                        // Label row with values
                        e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' }},
                            e('span', { style: { fontSize: '16px', fontWeight: 'bold', color: winner === 'A' ? '#60a5fa' : '#94a3b8', minWidth: '60px' }}, displayA),
                            e('div', { style: { flex: 1, textAlign: 'center' }},
                                e('span', { style: { fontSize: '12px', color: '#94a3b8', fontWeight: '600' }}, label)
                            ),
                            e('span', { style: { fontSize: '16px', fontWeight: 'bold', color: winner === 'B' ? '#c084fc' : '#94a3b8', minWidth: '60px', textAlign: 'right' }}, displayB)
                        ),
                        // Tug of war bar - properly centered
                        e('div', { style: { height: '28px', background: 'rgba(0,0,0,0.4)', borderRadius: '14px', position: 'relative', overflow: 'hidden' }},
                            // Center line (always visible)
                            e('div', { style: { position: 'absolute', left: '50%', top: '4px', bottom: '4px', width: '3px', background: 'rgba(255,255,255,0.4)', transform: 'translateX(-50%)', zIndex: 2, borderRadius: '2px' }}),
                            // Team A bar (extends LEFT from center when A wins)
                            winner === 'A' && e('div', { style: { 
                                position: 'absolute',
                                right: '50%',
                                top: '3px',
                                bottom: '3px',
                                width: barWidth + '%',
                                background: 'linear-gradient(270deg, #60a5fa, #3b82f6)',
                                borderRadius: '11px 0 0 11px',
                                transition: 'width 0.3s ease',
                                boxShadow: '0 0 10px rgba(59, 130, 246, 0.5)'
                            }}),
                            // Team B bar (extends RIGHT from center when B wins)
                            winner === 'B' && e('div', { style: { 
                                position: 'absolute',
                                left: '50%',
                                top: '3px',
                                bottom: '3px',
                                width: barWidth + '%',
                                background: 'linear-gradient(90deg, #c084fc, #a855f7)',
                                borderRadius: '0 11px 11px 0',
                                transition: 'width 0.3s ease',
                                boxShadow: '0 0 10px rgba(168, 85, 247, 0.5)'
                            }}),
                            // Advantage indicator text
                            e('div', { style: { 
                                position: 'absolute',
                                left: '50%',
                                top: '50%',
                                transform: 'translate(-50%, -50%)',
                                fontSize: '11px',
                                fontWeight: 'bold',
                                color: 'white',
                                textShadow: '0 1px 3px rgba(0,0,0,0.8)',
                                zIndex: 3,
                                whiteSpace: 'nowrap'
                            }}, winner === 'tie' ? '≈' : (winner === 'A' ? '◄ +' + absDiff.toFixed(format) : '+' + absDiff.toFixed(format) + ' ►'))
                        ),
                        // Opponent quality adjustment slider (hidden on mobile - master slider only)
                        oppAdjKey && e('div', { className: 'tow-individual-slider', style: { display: 'flex', alignItems: 'center', gap: '8px', marginTop: '6px' }},
                            e('span', { style: { fontSize: '10px', color: '#64748b', width: '85px' }}, 'Opp Quality Adj'),
                            e('input', { 
                                type: 'range', 
                                min: 0, 
                                max: 100, 
                                value: oppAdj,
                                onChange: ev => setCompareOppAdj(prev => ({ ...prev, [oppAdjKey]: parseInt(ev.target.value) })),
                                style: { flex: 1, height: '4px', accentColor: '#fbbf24' }
                            }),
                            e('span', { style: { fontSize: '10px', color: oppAdj > 0 ? '#fbbf24' : '#64748b', width: '35px', textAlign: 'right' }}, oppAdj + '%')
                        )
                    );
                };
                
                const isTeamASelected = comparePlayersA.some(p => p);
                const isTeamBSelected = comparePlayersB.some(p => p);
                
                return e('div', null,
                    // Team/Player Selection
                    e('div', { className: 'compare-container' },
                        // Team A Panel
                        e('div', { className: 'compare-panel team-a' },
                            e('div', { className: 'compare-panel-header team-a' }, 
                                '🔵 ', compareTeamA || 'Select Team',
                                statsA && statsA.isTeamWide && e('span', { style: { fontSize: '11px', marginLeft: '8px', color: '#94a3b8' }}, '(Team-Wide)')
                            ),
                            e('div', { className: 'form-group' },
                                e('label', null, 'Team'),
                                e('select', { 
                                    value: compareTeamA, 
                                    onChange: ev => { setCompareTeamA(ev.target.value); setComparePlayersA(['', '', '', '', '']); }
                                }, 
                                    e('option', { value: '' }, 'Select Team...'),
                                    teams.map(t => e('option', { key: t, value: t }, t))
                                )
                            ),
                            e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '8px' }}, 
                                'Select players below or leave empty for team-wide stats'
                            ),
                            e('div', { className: 'compare-player-grid' },
                                comparePlayersA.map((player, idx) => 
                                    e('div', { 
                                        key: idx, 
                                        className: 'compare-player-slot' + (player ? ' filled' : ''),
                                    },
                                        player ? e('div', null,
                                            e('div', { className: 'player-name' }, player.length > 10 ? player.substring(0, 10) + '..' : player),
                                            e('div', { className: 'remove-btn', onClick: () => setPlayerSlot('A', idx, '') }, '✕ Remove')
                                        ) : e('select', {
                                            value: '',
                                            onChange: ev => setPlayerSlot('A', idx, ev.target.value),
                                            style: { width: '100%', background: 'transparent', border: 'none', color: '#94a3b8', fontSize: '11px' }
                                        },
                                            e('option', { value: '' }, 'Any'),
                                            teamAPlayers.filter(p => !comparePlayersA.includes(p)).map(p => 
                                                e('option', { key: p, value: p }, p.length > 12 ? p.substring(0, 12) + '..' : p)
                                            )
                                        )
                                    )
                                )
                            ),
                            e('div', { className: 'compare-lineup-picker' },
                                e('div', { className: 'compare-lineup-picker-title' }, '⚡ Quick Select (Top 30 by Poss)'),
                                e('div', { className: 'compare-lineup-list' },
                                    teamALineups.map((lu, idx) => 
                                        e('div', { 
                                            key: idx, 
                                            className: 'compare-lineup-item',
                                            onClick: () => loadLineup('A', lu.players)
                                        },
                                            e('div', { className: 'lineup-name' }, lu.players.join(', ')),
                                            e('div', { className: 'lineup-poss' }, lu.poss.toFixed(0) + ' poss')
                                        )
                                    )
                                )
                            )
                        ),
                        // Team B Panel
                        e('div', { className: 'compare-panel team-b' },
                            e('div', { className: 'compare-panel-header team-b' }, 
                                '🟣 ', compareTeamB || 'Select Team',
                                statsB && statsB.isTeamWide && e('span', { style: { fontSize: '11px', marginLeft: '8px', color: '#94a3b8' }}, '(Team-Wide)')
                            ),
                            e('div', { className: 'form-group' },
                                e('label', null, 'Team'),
                                e('select', { 
                                    value: compareTeamB, 
                                    onChange: ev => { setCompareTeamB(ev.target.value); setComparePlayersB(['', '', '', '', '']); }
                                }, 
                                    e('option', { value: '' }, 'Select Team...'),
                                    teams.map(t => e('option', { key: t, value: t }, t))
                                )
                            ),
                            e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '8px' }}, 
                                'Select players below or leave empty for team-wide stats'
                            ),
                            e('div', { className: 'compare-player-grid' },
                                comparePlayersB.map((player, idx) => 
                                    e('div', { 
                                        key: idx, 
                                        className: 'compare-player-slot' + (player ? ' filled' : ''),
                                    },
                                        player ? e('div', null,
                                            e('div', { className: 'player-name' }, player.length > 10 ? player.substring(0, 10) + '..' : player),
                                            e('div', { className: 'remove-btn', onClick: () => setPlayerSlot('B', idx, '') }, '✕ Remove')
                                        ) : e('select', {
                                            value: '',
                                            onChange: ev => setPlayerSlot('B', idx, ev.target.value),
                                            style: { width: '100%', background: 'transparent', border: 'none', color: '#94a3b8', fontSize: '11px' }
                                        },
                                            e('option', { value: '' }, 'Any'),
                                            teamBPlayers.filter(p => !comparePlayersB.includes(p)).map(p => 
                                                e('option', { key: p, value: p }, p.length > 12 ? p.substring(0, 12) + '..' : p)
                                            )
                                        )
                                    )
                                )
                            ),
                            e('div', { className: 'compare-lineup-picker' },
                                e('div', { className: 'compare-lineup-picker-title' }, '⚡ Quick Select (Top 30 by Poss)'),
                                e('div', { className: 'compare-lineup-list' },
                                    teamBLineups.map((lu, idx) => 
                                        e('div', { 
                                            key: idx, 
                                            className: 'compare-lineup-item',
                                            onClick: () => loadLineup('B', lu.players)
                                        },
                                            e('div', { className: 'lineup-name' }, lu.players.join(', ')),
                                            e('div', { className: 'lineup-poss' }, lu.poss.toFixed(0) + ' poss')
                                        )
                                    )
                                )
                            )
                        )
                    ),
                    
                    // Controls Row
                    e('div', { style: { display: 'flex', gap: '16px', margin: '20px 0', flexWrap: 'wrap' }},
                        // V4.6.1: Prior Strength (eFG% Model)
                        e('div', { style: { flex: 1, minWidth: '280px', background: 'rgba(168, 85, 247, 0.1)', border: '1px solid rgba(168, 85, 247, 0.3)', borderRadius: '8px', padding: '12px' }},
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' }},
                                e('span', { style: { fontSize: '12px', fontWeight: '600', color: '#c084fc' }}, '📐 eFG% Model Prior'),
                                e('input', { type: 'range', min: 0, max: 200, value: comparePriorStrength, onChange: ev => setComparePriorStrength(parseInt(ev.target.value)), style: { flex: 1 }}),
                                e('span', { style: { fontWeight: 'bold', color: comparePriorStrength > 0 ? '#c084fc' : '#94a3b8', minWidth: '50px' }}, 'k=' + comparePriorStrength)
                            ),
                            e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '4px' }}, 
                                comparePriorStrength > 0 ? 
                                    'Models eFG% using player On/Off shot impacts. Scroll down for projections.' :
                                    'Set k>0 to enable eFG% matchup modeling (uses On/Off data)'
                            )
                        ),
                        // Luck Adjustment
                        e('div', { style: { flex: 1, minWidth: '250px', background: 'rgba(251, 191, 36, 0.1)', border: '1px solid rgba(251, 191, 36, 0.3)', borderRadius: '8px', padding: '12px' }},
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' }},
                                e('span', { style: { fontSize: '12px', fontWeight: '600', color: '#fbbf24' }}, '🎲 3PT Luck'),
                                e('input', { type: 'range', min: 0, max: 100, value: compareLuckAdj, onChange: ev => setCompareLuckAdj(parseInt(ev.target.value)), style: { flex: 1 }}),
                                e('span', { style: { fontWeight: 'bold', color: compareLuckAdj > 0 ? '#4ade80' : '#94a3b8', minWidth: '40px' }}, compareLuckAdj + '%')
                            )
                        ),
                        // Reset opponent adjustments
                        e('button', { 
                            className: 'btn btn-secondary',
                            onClick: () => { setCompareOppAdj({ offEfg: 0, offTov: 0, offOreb: 0, offFtR: 0, defEfg: 0, defTov: 0, defOreb: 0, defFtR: 0 }); setComparePriorStrength(0); setCompareMasterOppAdj(0); },
                            style: { alignSelf: 'center' }
                        }, '↻ Reset All Adj')
                    ),
                    
                    // Results Section
                    (statsA && statsB) ? e('div', { className: 'compare-results' },
                        // Summary Card
                        e('div', { className: 'compare-summary-card' },
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }},
                                e('div', null,
                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: '#fbbf24' }}, '📊 Head-to-Head Summary'),
                                    e('div', { style: { fontSize: '12px', color: '#94a3b8' }}, 
                                        (statsA.isTeamWide ? compareTeamA + ' (Team)' : compareTeamA) + ' (' + statsA.poss.toFixed(0) + ' poss) vs ' + 
                                        (statsB.isTeamWide ? compareTeamB + ' (Team)' : compareTeamB) + ' (' + statsB.poss.toFixed(0) + ' poss)'
                                    )
                                ),
                                showRelativeToLeague && e('span', { style: { fontSize: '11px', padding: '4px 8px', background: 'rgba(34, 197, 94, 0.2)', border: '1px solid rgba(34, 197, 94, 0.4)', borderRadius: '4px', color: '#4ade80' }}, '📊 Relative to League')
                            ),
                            e('div', { className: 'compare-summary-grid' },
                                e('div', { className: 'compare-summary-item' },
                                    e('div', { className: 'compare-summary-label' }, 'NET RATING'),
                                    e('div', { className: 'compare-summary-values' },
                                        e('span', { className: 'compare-summary-value team-a' }, (statsA.net >= 0 ? '+' : '') + statsA.net.toFixed(1)),
                                        e('span', { style: { color: '#64748b' }}, 'vs'),
                                        e('span', { className: 'compare-summary-value team-b' }, (statsB.net >= 0 ? '+' : '') + statsB.net.toFixed(1))
                                    ),
                                    e('div', { 
                                        className: 'compare-summary-diff',
                                        style: { background: statsA.net > statsB.net ? 'rgba(59, 130, 246, 0.3)' : statsA.net < statsB.net ? 'rgba(168, 85, 247, 0.3)' : 'rgba(100, 116, 139, 0.3)', color: statsA.net > statsB.net ? '#93c5fd' : statsA.net < statsB.net ? '#d8b4fe' : '#cbd5e1', marginTop: '8px' }
                                    }, statsA.net > statsB.net ? '🔵 +' + (statsA.net - statsB.net).toFixed(1) : statsA.net < statsB.net ? '🟣 +' + (statsB.net - statsA.net).toFixed(1) : 'Even')
                                ),
                                e('div', { className: 'compare-summary-item' },
                                    e('div', { className: 'compare-summary-label' }, 'OFF RATING'),
                                    e('div', { className: 'compare-summary-values' },
                                        e('span', { className: 'compare-summary-value team-a' }, statsA.off.toFixed(1)),
                                        e('span', { style: { color: '#64748b' }}, 'vs'),
                                        e('span', { className: 'compare-summary-value team-b' }, statsB.off.toFixed(1))
                                    )
                                ),
                                e('div', { className: 'compare-summary-item' },
                                    e('div', { className: 'compare-summary-label' }, 'DEF RATING'),
                                    e('div', { className: 'compare-summary-values' },
                                        e('span', { className: 'compare-summary-value team-a' }, statsA.def.toFixed(1)),
                                        e('span', { style: { color: '#64748b' }}, 'vs'),
                                        e('span', { className: 'compare-summary-value team-b' }, statsB.def.toFixed(1))
                                    )
                                )
                            )
                        ),
                        
                        // Four Factors with Tug of War
                        e('div', { className: 'compare-section' },
                            e('div', { className: 'compare-section-title' }, 
                                '📈 Four Factors Comparison',
                                e('span', { style: { fontSize: '11px', color: '#94a3b8', marginLeft: '12px', fontWeight: 'normal' }}, 
                                    'Adjust "Opp Strength" sliders to account for schedule difficulty'
                                )
                            ),
                            
                            // V4.6.3: Universal Master Opp Quality Adjustment Slider
                            e('div', { style: { 
                                marginBottom: '20px', 
                                padding: '14px 18px', 
                                background: 'linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(249, 115, 22, 0.1))', 
                                border: '2px solid rgba(251, 191, 36, 0.4)', 
                                borderRadius: '10px' 
                            }},
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '16px', flexWrap: 'wrap' }},
                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                        e('span', { style: { fontSize: '16px' }}, '🎯'),
                                        e('span', { style: { fontSize: '13px', fontWeight: '700', color: '#fbbf24' }}, 'MASTER Opp Quality Adj')
                                    ),
                                    e('input', { 
                                        type: 'range', 
                                        min: 0, 
                                        max: 100, 
                                        value: compareMasterOppAdj,
                                        onChange: ev => setCompareMasterOppAdj(parseInt(ev.target.value)),
                                        style: { flex: 1, minWidth: '200px', height: '8px', accentColor: '#f59e0b' }
                                    }),
                                    e('span', { style: { 
                                        fontSize: '14px', 
                                        fontWeight: 'bold', 
                                        color: compareMasterOppAdj > 0 ? '#f59e0b' : '#64748b', 
                                        minWidth: '45px',
                                        textAlign: 'right',
                                        padding: '4px 8px',
                                        background: compareMasterOppAdj > 0 ? 'rgba(251, 191, 36, 0.2)' : 'transparent',
                                        borderRadius: '4px'
                                    }}, compareMasterOppAdj + '%'),
                                    e('button', {
                                        className: 'btn btn-secondary',
                                        style: { padding: '6px 12px', fontSize: '11px' },
                                        onClick: () => setCompareMasterOppAdj(0)
                                    }, '↻ Reset')
                                ),
                                e('div', { style: { fontSize: '10px', color: '#94a3b8', marginTop: '8px' }},
                                    compareMasterOppAdj > 0 ? 
                                        '✓ Applies ' + compareMasterOppAdj + '% adjustment to ALL four factors (stacks with individual sliders)' :
                                        'Slide to apply opponent quality adjustment to all four factors at once'
                                )
                            ),
                            
                            // V4.7.1: When eFG% model is active, use modeled values instead of raw stats
                            (() => {
                                // modeledAvsB = Team A offense vs Team B defense
                                // modeledBvsA = Team B offense vs Team A defense
                                const useModeledEfg = comparePriorStrength > 0 && modeledAvsB && modeledBvsA;
                                const effA_offEfg = useModeledEfg ? modeledAvsB.modeledEfg : statsA.offEfg;
                                const effB_offEfg = useModeledEfg ? modeledBvsA.modeledEfg : statsB.offEfg;
                                const effA_defEfg = useModeledEfg ? modeledBvsA.modeledEfg : statsA.defEfg; // What B shoots vs A
                                const effB_defEfg = useModeledEfg ? modeledAvsB.modeledEfg : statsB.defEfg; // What A shoots vs B
                                
                                return e('div', { className: 'compare-four-factors-grid', style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '32px' }},
                                    // Offensive Four Factors
                                    e('div', null,
                                        e('div', { style: { fontSize: '14px', fontWeight: '600', color: '#4ade80', marginBottom: '16px' }},
                                            '⚡ OFFENSE',
                                            useModeledEfg && e('span', { style: { fontSize: '10px', color: '#22d3ee', marginLeft: '8px' }}, '(eFG% modeled)')
                                        ),
                                        e(TugOfWarRow, { label: 'eFG%', valueA: effA_offEfg, valueB: effB_offEfg, higherBetter: true, leagueKey: 'offEfg', oppAdjKey: 'offEfg' }),
                                        e(TugOfWarRow, { label: 'TOV%', valueA: statsA.offTov, valueB: statsB.offTov, higherBetter: false, leagueKey: 'offTov', oppAdjKey: 'offTov' }),
                                        e(TugOfWarRow, { label: 'OREB%', valueA: statsA.offOreb, valueB: statsB.offOreb, higherBetter: true, leagueKey: 'offOreb', oppAdjKey: 'offOreb' }),
                                        e(TugOfWarRow, { label: 'FT Rate', valueA: statsA.offFtR, valueB: statsB.offFtR, higherBetter: true, leagueKey: 'offFtR', oppAdjKey: 'offFtR' })
                                    ),
                                    // Defensive Four Factors
                                    e('div', null,
                                        e('div', { style: { fontSize: '14px', fontWeight: '600', color: '#f87171', marginBottom: '16px' }}, 
                                            '🛡️ DEFENSE',
                                            useModeledEfg && e('span', { style: { fontSize: '10px', color: '#22d3ee', marginLeft: '8px' }}, '(eFG% modeled)')
                                        ),
                                        e(TugOfWarRow, { label: 'Opp eFG%', valueA: effA_defEfg, valueB: effB_defEfg, higherBetter: false, leagueKey: 'defEfg', oppAdjKey: 'defEfg' }),
                                        e(TugOfWarRow, { label: 'Opp TOV%', valueA: statsA.defTov, valueB: statsB.defTov, higherBetter: true, leagueKey: 'defTov', oppAdjKey: 'defTov' }),
                                        e(TugOfWarRow, { label: 'Opp OREB%', valueA: statsA.defOreb, valueB: statsB.defOreb, higherBetter: false, leagueKey: 'defOreb', oppAdjKey: 'defOreb' }),
                                        e(TugOfWarRow, { label: 'Opp FT Rate', valueA: statsA.defFtR, valueB: statsB.defFtR, higherBetter: false, leagueKey: 'defFtR', oppAdjKey: 'defFtR' })
                                    )
                                );
                            })(),
                            
                            // V4.6.3: Simulated Ratings Section (always visible with any adjustment)
                            (() => {
                                // V4.7.1: Calculate adjusted four factors, using modeled eFG% when available
                                const useModeledEfg = comparePriorStrength > 0 && modeledAvsB && modeledBvsA;
                                
                                const getAdjustedFF = (stats, oppStats, isTeamA) => {
                                    if (!stats || !oppStats || !leagueAverages) return stats;
                                    
                                    // Start with stats, but override eFG% with modeled values if model is active
                                    const adjusted = { ...stats };
                                    
                                    // V4.7.1: Apply modeled eFG% values
                                    if (useModeledEfg) {
                                        if (isTeamA) {
                                            adjusted.offEfg = modeledAvsB.modeledEfg;  // A offense vs B defense
                                            adjusted.defEfg = modeledBvsA.modeledEfg;  // B offense vs A defense (what A allows)
                                        } else {
                                            adjusted.offEfg = modeledBvsA.modeledEfg;  // B offense vs A defense
                                            adjusted.defEfg = modeledAvsB.modeledEfg;  // A offense vs B defense (what B allows)
                                        }
                                    }
                                    
                                    const statKeys = ['offEfg', 'offTov', 'offOreb', 'offFtR', 'defEfg', 'defTov', 'defOreb', 'defFtR'];
                                    
                                    statKeys.forEach(key => {
                                        const individualAdj = compareOppAdj[key] || 0;
                                        const totalAdj = Math.min(100, compareMasterOppAdj + individualAdj);
                                        
                                        // V4.7.1: Skip opponent adjustment for eFG% if using modeled values
                                        // (the model already accounts for matchup)
                                        if (useModeledEfg && (key === 'offEfg' || key === 'defEfg')) return;
                                        
                                        if (totalAdj <= 0) return;
                                        
                                        const leagueAvg = leagueAverages[key] || stats[key];
                                        const adjFactor = totalAdj / 100;
                                        
                                        // Map offensive stat to defensive counterpart
                                        const statMappings = {
                                            'offEfg': 'defEfg', 'offTov': 'defTov', 'offOreb': 'defOreb', 'offFtR': 'defFtR',
                                            'defEfg': 'offEfg', 'defTov': 'offTov', 'defOreb': 'offOreb', 'defFtR': 'offFtR'
                                        };
                                        const correspondingStat = statMappings[key];
                                        if (!correspondingStat) return;
                                        
                                        const oppLeagueAvg = leagueAverages[correspondingStat] || leagueAvg;
                                        const oppStatVal = oppStats[correspondingStat] || oppLeagueAvg;
                                        const oppDiff = oppStatVal - oppLeagueAvg;
                                        
                                        adjusted[key] = adjusted[key] - oppDiff * adjFactor * 0.5;
                                    });
                                    
                                    return adjusted;
                                };
                                
                                const adjA = getAdjustedFF(statsA, statsB, true);
                                const adjB = getAdjustedFF(statsB, statsA, false);
                                
                                const simA = calcSimulatedRatings(adjA, leagueAverages);
                                const simB = calcSimulatedRatings(adjB, leagueAverages);
                                
                                // Calculate actual vs simulated delta
                                const actualOrtgA = statsA.off || 0;
                                const actualDrtgA = statsA.def || 0;
                                const actualOrtgB = statsB.off || 0;
                                const actualDrtgB = statsB.def || 0;
                                
                                const hasAnyAdj = compareMasterOppAdj > 0 || Object.values(compareOppAdj).some(v => v > 0);
                                const hasModelOrAdj = hasAnyAdj || useModeledEfg;
                                
                                if (!simA || !simB) return null;
                                
                                return e('div', { style: { 
                                    marginTop: '24px', 
                                    padding: '20px', 
                                    background: 'linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.08))', 
                                    border: '1px solid rgba(139, 92, 246, 0.3)', 
                                    borderRadius: '12px' 
                                }},
                                    e('div', { className: 'compare-sim-header', style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '16px' }},
                                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap' }},
                                            e('span', { style: { fontSize: '18px' }}, '🧮'),
                                            e('span', { style: { fontSize: '15px', fontWeight: '700', color: '#a78bfa' }}, 'Simulated Ratings from Four Factors'),
                                            useModeledEfg && e('span', { style: { 
                                                fontSize: '10px', 
                                                padding: '3px 8px', 
                                                background: 'rgba(34, 211, 238, 0.2)', 
                                                border: '1px solid rgba(34, 211, 238, 0.4)',
                                                borderRadius: '4px', 
                                                color: '#22d3ee' 
                                            }}, '🎯 eFG% MODELED'),
                                            hasAnyAdj && e('span', { style: { 
                                                fontSize: '10px', 
                                                padding: '3px 8px', 
                                                background: 'rgba(251, 191, 36, 0.2)', 
                                                border: '1px solid rgba(251, 191, 36, 0.4)',
                                                borderRadius: '4px', 
                                                color: '#fbbf24' 
                                            }}, '⚙️ OPP ADJ')
                                        ),
                                        e('div', { style: { fontSize: '10px', color: '#64748b' }}, 'Dean Oliver coefficients')
                                    ),
                                    
                                    // Ratings comparison grid
                                    e('div', { className: 'compare-sim-ratings-grid', style: { display: 'grid', gridTemplateColumns: '1fr auto 1fr', gap: '16px', alignItems: 'center' }},
                                        // Team A ratings
                                        e('div', { style: { textAlign: 'center' }},
                                            e('div', { style: { fontSize: '12px', color: '#60a5fa', fontWeight: '600', marginBottom: '8px' }},
                                                '🔵 ' + (compareTeamA || 'Team A')
                                            ),
                                            e('div', { className: 'compare-sim-team-stats', style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }},
                                                e('div', { style: { background: 'rgba(34, 197, 94, 0.15)', padding: '10px', borderRadius: '8px' }},
                                                    e('div', { style: { fontSize: '10px', color: '#4ade80', marginBottom: '4px' }}, 'Sim ORTG'),
                                                    e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, simA.ortg.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#64748b' }}, 
                                                        'Actual: ' + actualOrtgA.toFixed(1),
                                                        hasModelOrAdj && e('span', { style: { color: simA.ortg > actualOrtgA ? '#4ade80' : '#f87171' }}, 
                                                            ' (' + (simA.ortg > actualOrtgA ? '+' : '') + (simA.ortg - actualOrtgA).toFixed(1) + ')'
                                                        )
                                                    )
                                                ),
                                                e('div', { style: { background: 'rgba(239, 68, 68, 0.15)', padding: '10px', borderRadius: '8px' }},
                                                    e('div', { style: { fontSize: '10px', color: '#f87171', marginBottom: '4px' }}, 'Sim DRTG'),
                                                    e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, simA.drtg.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#64748b' }}, 
                                                        'Actual: ' + actualDrtgA.toFixed(1),
                                                        hasModelOrAdj && e('span', { style: { color: simA.drtg < actualDrtgA ? '#4ade80' : '#f87171' }}, 
                                                            ' (' + (simA.drtg > actualDrtgA ? '+' : '') + (simA.drtg - actualDrtgA).toFixed(1) + ')'
                                                        )
                                                    )
                                                ),
                                                e('div', { style: { background: 'rgba(59, 130, 246, 0.15)', padding: '10px', borderRadius: '8px' }},
                                                    e('div', { style: { fontSize: '10px', color: '#60a5fa', marginBottom: '4px' }}, 'Sim NET'),
                                                    e('div', { style: { fontSize: '20px', fontWeight: 'bold', color: simA.net >= 0 ? '#4ade80' : '#f87171' }}, 
                                                        (simA.net >= 0 ? '+' : '') + simA.net.toFixed(1)
                                                    ),
                                                    e('div', { style: { fontSize: '9px', color: '#64748b' }}, 
                                                        'Actual: ' + (statsA.net >= 0 ? '+' : '') + statsA.net.toFixed(1)
                                                    )
                                                )
                                            )
                                        ),
                                        
                                        // VS divider with net comparison
                                        e('div', { style: { textAlign: 'center', padding: '0 16px' }},
                                            e('div', { style: { fontSize: '20px', fontWeight: 'bold', color: '#64748b' }}, 'VS'),
                                            e('div', { style: { 
                                                marginTop: '8px',
                                                padding: '8px 12px', 
                                                background: simA.net > simB.net ? 'rgba(59, 130, 246, 0.2)' : simA.net < simB.net ? 'rgba(168, 85, 247, 0.2)' : 'rgba(100, 116, 139, 0.2)',
                                                borderRadius: '6px',
                                                fontSize: '11px',
                                                fontWeight: '600',
                                                color: simA.net > simB.net ? '#93c5fd' : simA.net < simB.net ? '#d8b4fe' : '#94a3b8'
                                            }},
                                                simA.net > simB.net ? '🔵 +' + (simA.net - simB.net).toFixed(1) :
                                                simA.net < simB.net ? '🟣 +' + (simB.net - simA.net).toFixed(1) : 'EVEN'
                                            )
                                        ),
                                        
                                        // Team B ratings
                                        e('div', { style: { textAlign: 'center' }},
                                            e('div', { style: { fontSize: '12px', color: '#c084fc', fontWeight: '600', marginBottom: '8px' }},
                                                '🟣 ' + (compareTeamB || 'Team B')
                                            ),
                                            e('div', { className: 'compare-sim-team-stats', style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }},
                                                e('div', { style: { background: 'rgba(34, 197, 94, 0.15)', padding: '10px', borderRadius: '8px' }},
                                                    e('div', { style: { fontSize: '10px', color: '#4ade80', marginBottom: '4px' }}, 'Sim ORTG'),
                                                    e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, simB.ortg.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#64748b' }}, 
                                                        'Actual: ' + actualOrtgB.toFixed(1),
                                                        hasModelOrAdj && e('span', { style: { color: simB.ortg > actualOrtgB ? '#4ade80' : '#f87171' }}, 
                                                            ' (' + (simB.ortg > actualOrtgB ? '+' : '') + (simB.ortg - actualOrtgB).toFixed(1) + ')'
                                                        )
                                                    )
                                                ),
                                                e('div', { style: { background: 'rgba(239, 68, 68, 0.15)', padding: '10px', borderRadius: '8px' }},
                                                    e('div', { style: { fontSize: '10px', color: '#f87171', marginBottom: '4px' }}, 'Sim DRTG'),
                                                    e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, simB.drtg.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#64748b' }}, 
                                                        'Actual: ' + actualDrtgB.toFixed(1),
                                                        hasModelOrAdj && e('span', { style: { color: simB.drtg < actualDrtgB ? '#4ade80' : '#f87171' }}, 
                                                            ' (' + (simB.drtg > actualDrtgB ? '+' : '') + (simB.drtg - actualDrtgB).toFixed(1) + ')'
                                                        )
                                                    )
                                                ),
                                                e('div', { style: { background: 'rgba(168, 85, 247, 0.15)', padding: '10px', borderRadius: '8px' }},
                                                    e('div', { style: { fontSize: '10px', color: '#c084fc', marginBottom: '4px' }}, 'Sim NET'),
                                                    e('div', { style: { fontSize: '20px', fontWeight: 'bold', color: simB.net >= 0 ? '#4ade80' : '#f87171' }}, 
                                                        (simB.net >= 0 ? '+' : '') + simB.net.toFixed(1)
                                                    ),
                                                    e('div', { style: { fontSize: '9px', color: '#64748b' }}, 
                                                        'Actual: ' + (statsB.net >= 0 ? '+' : '') + statsB.net.toFixed(1)
                                                    )
                                                )
                                            )
                                        )
                                    ),
                                    
                                    // Methodology note
                                    e('div', { style: { marginTop: '16px', padding: '10px', background: 'rgba(0,0,0,0.15)', borderRadius: '6px', fontSize: '10px', color: '#64748b' }},
                                        e('strong', { style: { color: '#a78bfa' }}, '📖 Methodology: '),
                                        'Simulated ratings use Dean Oliver\'s Four Factors coefficients (eFG%: ×1.85, TOV%: ×-1.25, OREB%: ×0.60, FT Rate: ×0.45). ',
                                        'When adjustments are applied, the simulation shows how ratings ',
                                        e('em', null, 'would'),
                                        ' look if accounting for opponent quality. Δ shows difference from actual rating.',
                                        hasAnyAdj && e('span', { style: { color: '#fbbf24', marginLeft: '6px' }}, 
                                            '⚙️ Current total adjustment: Master ' + compareMasterOppAdj + '% + individual sliders'
                                        )
                                    )
                                );
                            })()
                        ),
                        
                        // V4.6.1: eFG% Matchup Modeling Section
                        comparePriorStrength > 0 && e('div', { className: 'compare-section' },
                            e('div', { className: 'compare-section-title' }, '📐 eFG% Matchup Model', 
                                e('span', { style: { fontSize: '11px', marginLeft: '8px', color: '#94a3b8', fontWeight: 'normal' }}, 
                                    'k=' + comparePriorStrength + ' | weight = poss/(poss+k)'
                                )
                            ),
                            e('div', { className: 'compare-four-factors-grid', style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '24px' }},
                                // Team A offense vs Team B defense
                                e('div', { style: { background: 'rgba(59, 130, 246, 0.1)', border: '1px solid rgba(59, 130, 246, 0.3)', borderRadius: '8px', padding: '16px' }},
                                    e('div', { style: { fontSize: '12px', fontWeight: '600', color: '#60a5fa', marginBottom: '12px' }},
                                        '🔵 ' + (compareTeamA || 'Team A') + ' OFF vs 🟣 ' + (compareTeamB || 'Team B') + ' DEF',
                                        modeledAvsB?.usedTeamWide && e('span', { style: { fontSize: '9px', color: '#fbbf24', marginLeft: '6px' }}, '(team-wide)')
                                    ),
                                    modeledAvsB ? e('div', null,
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }},
                                            e('span', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Modeled eFG%'),
                                            e('span', { style: { fontSize: '24px', fontWeight: 'bold', color: getRelativeColor(modeledAvsB.modeledEfg - (leagueAverages?.offEfg || 50), true, 8) }}, 
                                                modeledAvsB.modeledEfg.toFixed(1) + '%'
                                            )
                                        ),
                                        e('div', { style: { fontSize: '10px', color: '#64748b', marginBottom: '8px' }}, 
                                            'vs League Avg: ' + (modeledAvsB.modeledEfg - (leagueAverages?.offEfg || 50) >= 0 ? '+' : '') + 
                                            (modeledAvsB.modeledEfg - (leagueAverages?.offEfg || 50)).toFixed(1) + '%'
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.3)', borderRadius: '8px', padding: '12px', marginTop: '10px', border: '1px solid rgba(255,255,255,0.15)' }},
                                            e('div', { style: { fontSize: '12px', color: '#f0f0f0', marginBottom: '8px', fontWeight: '600' }}, '📊 Projected Shot Profile:'),
                                            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px' }},
                                                e('div', { style: { background: 'rgba(239, 68, 68, 0.2)', padding: '10px', borderRadius: '6px', textAlign: 'center', border: '1px solid rgba(239, 68, 68, 0.4)' }},
                                                    e('div', { style: { fontSize: '11px', color: '#f87171', marginBottom: '4px', fontWeight: '600' }}, 'RIM'),
                                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: '#ef4444' }}, modeledAvsB.projected.rimPct.toFixed(1) + '%'),
                                                    e('div', { style: { fontSize: '11px', color: '#94a3b8' }}, '@ ' + modeledAvsB.projected.rimVol.toFixed(0) + '/100')
                                                ),
                                                e('div', { style: { background: 'rgba(249, 115, 22, 0.2)', padding: '10px', borderRadius: '6px', textAlign: 'center', border: '1px solid rgba(249, 115, 22, 0.4)' }},
                                                    e('div', { style: { fontSize: '11px', color: '#fb923c', marginBottom: '4px', fontWeight: '600' }}, 'MID'),
                                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: '#f97316' }}, modeledAvsB.projected.midPct.toFixed(1) + '%'),
                                                    e('div', { style: { fontSize: '11px', color: '#94a3b8' }}, '@ ' + modeledAvsB.projected.midVol.toFixed(0) + '/100')
                                                ),
                                                e('div', { style: { background: 'rgba(59, 130, 246, 0.2)', padding: '10px', borderRadius: '6px', textAlign: 'center', border: '1px solid rgba(59, 130, 246, 0.4)' }},
                                                    e('div', { style: { fontSize: '11px', color: '#60a5fa', marginBottom: '4px', fontWeight: '600' }}, '3PT'),
                                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: '#3b82f6' }}, modeledAvsB.projected.threePct.toFixed(1) + '%'),
                                                    e('div', { style: { fontSize: '11px', color: '#94a3b8' }}, '@ ' + modeledAvsB.projected.threeVol.toFixed(0) + '/100')
                                                )
                                            )
                                        ),
                                        e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '6px' }}, 
                                            'Reliability: ' + (modeledAvsB.reliabilityWeight * 100).toFixed(0) + '% (' + modeledAvsB.combinedPoss.toFixed(0) + ' min poss)',
                                            modeledAvsB.ci95 && e('span', { style: { marginLeft: '8px', color: '#a78bfa' }}, 
                                                '95% CI: [' + modeledAvsB.ci95[0].toFixed(1) + '%, ' + modeledAvsB.ci95[1].toFixed(1) + '%]'
                                            ),
                                            modeledAvsB.usedTeamWide && ' • Using team shot profiles'
                                        )
                                    ) : e('div', { style: { fontSize: '11px', color: '#64748b', fontStyle: 'italic', textAlign: 'center', padding: '20px' }}, 
                                        !compareTeamA || !compareTeamB ? 
                                            'Select both teams to model matchup' : 
                                            'No shot profile data available'
                                    )
                                ),
                                // Team B offense vs Team A defense
                                e('div', { style: { background: 'rgba(168, 85, 247, 0.1)', border: '1px solid rgba(168, 85, 247, 0.3)', borderRadius: '8px', padding: '16px' }},
                                    e('div', { style: { fontSize: '12px', fontWeight: '600', color: '#c084fc', marginBottom: '12px' }}, 
                                        '🟣 ' + (compareTeamB || 'Team B') + ' OFF vs 🔵 ' + (compareTeamA || 'Team A') + ' DEF',
                                        modeledBvsA?.usedTeamWide && e('span', { style: { fontSize: '9px', color: '#fbbf24', marginLeft: '6px' }}, '(team-wide)')
                                    ),
                                    modeledBvsA ? e('div', null,
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }},
                                            e('span', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Modeled eFG%'),
                                            e('span', { style: { fontSize: '24px', fontWeight: 'bold', color: getRelativeColor(modeledBvsA.modeledEfg - (leagueAverages?.offEfg || 50), true, 8) }}, 
                                                modeledBvsA.modeledEfg.toFixed(1) + '%'
                                            )
                                        ),
                                        e('div', { style: { fontSize: '10px', color: '#64748b', marginBottom: '8px' }}, 
                                            'vs League Avg: ' + (modeledBvsA.modeledEfg - (leagueAverages?.offEfg || 50) >= 0 ? '+' : '') + 
                                            (modeledBvsA.modeledEfg - (leagueAverages?.offEfg || 50)).toFixed(1) + '%'
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.3)', borderRadius: '8px', padding: '12px', marginTop: '10px', border: '1px solid rgba(255,255,255,0.15)' }},
                                            e('div', { style: { fontSize: '12px', color: '#f0f0f0', marginBottom: '8px', fontWeight: '600' }}, '📊 Projected Shot Profile:'),
                                            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px' }},
                                                e('div', { style: { background: 'rgba(239, 68, 68, 0.2)', padding: '10px', borderRadius: '6px', textAlign: 'center', border: '1px solid rgba(239, 68, 68, 0.4)' }},
                                                    e('div', { style: { fontSize: '11px', color: '#f87171', marginBottom: '4px', fontWeight: '600' }}, 'RIM'),
                                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: '#ef4444' }}, modeledBvsA.projected.rimPct.toFixed(1) + '%'),
                                                    e('div', { style: { fontSize: '11px', color: '#94a3b8' }}, '@ ' + modeledBvsA.projected.rimVol.toFixed(0) + '/100')
                                                ),
                                                e('div', { style: { background: 'rgba(249, 115, 22, 0.2)', padding: '10px', borderRadius: '6px', textAlign: 'center', border: '1px solid rgba(249, 115, 22, 0.4)' }},
                                                    e('div', { style: { fontSize: '11px', color: '#fb923c', marginBottom: '4px', fontWeight: '600' }}, 'MID'),
                                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: '#f97316' }}, modeledBvsA.projected.midPct.toFixed(1) + '%'),
                                                    e('div', { style: { fontSize: '11px', color: '#94a3b8' }}, '@ ' + modeledBvsA.projected.midVol.toFixed(0) + '/100')
                                                ),
                                                e('div', { style: { background: 'rgba(59, 130, 246, 0.2)', padding: '10px', borderRadius: '6px', textAlign: 'center', border: '1px solid rgba(59, 130, 246, 0.4)' }},
                                                    e('div', { style: { fontSize: '11px', color: '#60a5fa', marginBottom: '4px', fontWeight: '600' }}, '3PT'),
                                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: '#3b82f6' }}, modeledBvsA.projected.threePct.toFixed(1) + '%'),
                                                    e('div', { style: { fontSize: '11px', color: '#94a3b8' }}, '@ ' + modeledBvsA.projected.threeVol.toFixed(0) + '/100')
                                                )
                                            )
                                        ),
                                        e('div', { style: { fontSize: '9px', color: '#64748b', marginTop: '6px' }}, 
                                            'Reliability: ' + (modeledBvsA.reliabilityWeight * 100).toFixed(0) + '% (' + modeledBvsA.combinedPoss.toFixed(0) + ' min poss)',
                                            modeledBvsA.ci95 && e('span', { style: { marginLeft: '8px', color: '#a78bfa' }}, 
                                                '95% CI: [' + modeledBvsA.ci95[0].toFixed(1) + '%, ' + modeledBvsA.ci95[1].toFixed(1) + '%]'
                                            ),
                                            modeledBvsA.usedTeamWide && ' • Using team shot profiles'
                                        )
                                    ) : e('div', { style: { fontSize: '11px', color: '#64748b', fontStyle: 'italic', textAlign: 'center', padding: '20px' }}, 
                                        !compareTeamA || !compareTeamB ? 
                                            'Select both teams to model matchup' : 
                                            'No shot profile data available'
                                    )
                                )
                            ),
                            // eFG% Advantage Summary
                            (modeledAvsB && modeledBvsA) && e('div', { style: { marginTop: '16px', padding: '12px', background: 'rgba(251, 191, 36, 0.1)', border: '1px solid rgba(251, 191, 36, 0.3)', borderRadius: '8px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '11px', color: '#fbbf24', marginBottom: '6px' }}, 'Projected eFG% Differential'),
                                (() => {
                                    const diff = modeledAvsB.modeledEfg - modeledBvsA.modeledEfg;
                                    const winner = diff > 0.5 ? 'A' : diff < -0.5 ? 'B' : 'tie';
                                    return e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: winner === 'A' ? '#60a5fa' : winner === 'B' ? '#c084fc' : '#fbbf24' }},
                                        winner === 'tie' ? 'Even' : (winner === 'A' ? '🔵 ' : '🟣 ') + '+' + Math.abs(diff).toFixed(1) + '%'
                                    );
                                })()
                            )
                        ),
                        
                        // Shot Distribution Section - V4.6: Added shot contribution to eFG%
                        e('div', { className: 'compare-section' },
                            e('div', { className: 'compare-section-title' }, '🎯 Shot Distribution & eFG% Contribution'),
                            e('div', { className: 'compare-shot-dist' },
                                e('div', { className: 'compare-shot-panel' },
                                    e('div', { className: 'compare-shot-title team-a' }, '🔵 ' + compareTeamA + ' Offense'),
                                    e('div', { className: 'shot-dist-bar' },
                                        e('div', { className: 'shot-segment shot-rim', style: { width: statsA.rimRate + '%' }}, statsA.rimRate > 10 ? statsA.rimRate.toFixed(0) + '%' : ''),
                                        e('div', { className: 'shot-segment shot-mid', style: { width: statsA.midRate + '%' }}, statsA.midRate > 10 ? statsA.midRate.toFixed(0) + '%' : ''),
                                        e('div', { className: 'shot-segment shot-three', style: { width: statsA.threeRate + '%' }}, statsA.threeRate > 10 ? statsA.threeRate.toFixed(0) + '%' : '')
                                    ),
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginTop: '8px', fontSize: '11px' }},
                                        e('span', { style: { color: '#ef4444' }}, 'Rim: ' + statsA.rimPct.toFixed(1) + '%'),
                                        e('span', { style: { color: '#f97316' }}, 'Mid: ' + statsA.midPct.toFixed(1) + '%'),
                                        e('span', { style: { color: '#3b82f6' }}, '3PT: ' + statsA.threePct.toFixed(1) + '%')
                                    ),
                                    // V4.6.2: Shot contribution to eFG% - CORRECTED FORMULA with both metrics
                                    e('div', { style: { marginTop: '12px', padding: '12px', background: 'rgba(34, 197, 94, 0.15)', border: '1px solid rgba(34, 197, 94, 0.4)', borderRadius: '8px' }},
                                        e('div', { style: { fontSize: '12px', color: '#4ade80', marginBottom: '8px', fontWeight: '600' }}, '📊 eFG% Contribution (Vol + Eff vs League):'),
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '14px', fontWeight: 'bold' }},
                                            (() => {
                                                const totalAtt = statsA.rimAtt + statsA.midAtt + statsA.threeAtt;
                                                const la = leagueAvgShotStats || {};
                                                const rimC = calcShotContributionV2(statsA.rimM, statsA.rimAtt, totalAtt, false, la.rimFreq || 0.35, la.rimEfgEquiv || 60);
                                                const midC = calcShotContributionV2(statsA.midM, statsA.midAtt, totalAtt, false, la.midFreq || 0.18, la.midEfgEquiv || 40);
                                                const threeC = calcShotContributionV2(statsA.threeM, statsA.threeAtt, totalAtt, true, la.threeFreq || 0.47, la.threeEfgEquiv || 52.5);
                                                const totalContrib = rimC.contribution + midC.contribution + threeC.contribution;
                                                return [
                                                    e('span', { key: 'rim', style: { color: getRelativeColor(rimC.contribution, true, 3) }}, 'Rim: ' + (rimC.contribution >= 0 ? '+' : '') + rimC.contribution.toFixed(2)),
                                                    e('span', { key: 'mid', style: { color: getRelativeColor(midC.contribution, true, 3) }}, 'Mid: ' + (midC.contribution >= 0 ? '+' : '') + midC.contribution.toFixed(2)),
                                                    e('span', { key: 'three', style: { color: getRelativeColor(threeC.contribution, true, 3) }}, '3PT: ' + (threeC.contribution >= 0 ? '+' : '') + threeC.contribution.toFixed(2)),
                                                    e('span', { key: 'total', style: { color: getRelativeColor(totalContrib, true, 5), borderLeft: '1px solid #475569', paddingLeft: '8px' }}, 'Σ ' + (totalContrib >= 0 ? '+' : '') + totalContrib.toFixed(2))
                                                ];
                                            })()
                                        ),
                                        // V4.6.2: Zone Skill metric (Option B)
                                        e('div', { style: { marginTop: '10px', paddingTop: '10px', borderTop: '1px solid rgba(34, 197, 94, 0.3)' }},
                                            e('div', { style: { fontSize: '11px', color: '#86efac', marginBottom: '6px' }}, '🎯 Zone Skill (Eff vs Zone Avg):'),
                                            e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '12px' }},
                                                (() => {
                                                    const totalAtt = statsA.rimAtt + statsA.midAtt + statsA.threeAtt;
                                                    const la = leagueAvgShotStats || {};
                                                    const rimC = calcShotContributionV2(statsA.rimM, statsA.rimAtt, totalAtt, false, la.rimFreq || 0.35, la.rimEfgEquiv || 60);
                                                    const midC = calcShotContributionV2(statsA.midM, statsA.midAtt, totalAtt, false, la.midFreq || 0.18, la.midEfgEquiv || 40);
                                                    const threeC = calcShotContributionV2(statsA.threeM, statsA.threeAtt, totalAtt, true, la.threeFreq || 0.47, la.threeEfgEquiv || 52.5);
                                                    const totalSkill = rimC.zoneSkill + midC.zoneSkill + threeC.zoneSkill;
                                                    return [
                                                        e('span', { key: 'rim', style: { color: getRelativeColor(rimC.zoneSkill, true, 2) }}, 'Rim: ' + (rimC.zoneSkill >= 0 ? '+' : '') + rimC.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'mid', style: { color: getRelativeColor(midC.zoneSkill, true, 2) }}, 'Mid: ' + (midC.zoneSkill >= 0 ? '+' : '') + midC.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'three', style: { color: getRelativeColor(threeC.zoneSkill, true, 2) }}, '3PT: ' + (threeC.zoneSkill >= 0 ? '+' : '') + threeC.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'total', style: { color: getRelativeColor(totalSkill, true, 4), borderLeft: '1px solid #475569', paddingLeft: '8px' }}, 'Σ ' + (totalSkill >= 0 ? '+' : '') + totalSkill.toFixed(2))
                                                    ];
                                                })()
                                            )
                                        )
                                    )
                                ),
                                e('div', { className: 'compare-shot-panel' },
                                    e('div', { className: 'compare-shot-title team-b' }, '🟣 ' + compareTeamB + ' Offense'),
                                    e('div', { className: 'shot-dist-bar' },
                                        e('div', { className: 'shot-segment shot-rim', style: { width: statsB.rimRate + '%' }}, statsB.rimRate > 10 ? statsB.rimRate.toFixed(0) + '%' : ''),
                                        e('div', { className: 'shot-segment shot-mid', style: { width: statsB.midRate + '%' }}, statsB.midRate > 10 ? statsB.midRate.toFixed(0) + '%' : ''),
                                        e('div', { className: 'shot-segment shot-three', style: { width: statsB.threeRate + '%' }}, statsB.threeRate > 10 ? statsB.threeRate.toFixed(0) + '%' : '')
                                    ),
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginTop: '8px', fontSize: '11px' }},
                                        e('span', { style: { color: '#ef4444' }}, 'Rim: ' + statsB.rimPct.toFixed(1) + '%'),
                                        e('span', { style: { color: '#f97316' }}, 'Mid: ' + statsB.midPct.toFixed(1) + '%'),
                                        e('span', { style: { color: '#3b82f6' }}, '3PT: ' + statsB.threePct.toFixed(1) + '%')
                                    ),
                                    // V4.6.2: Shot contribution to eFG% - CORRECTED FORMULA with both metrics
                                    e('div', { style: { marginTop: '12px', padding: '12px', background: 'rgba(34, 197, 94, 0.15)', border: '1px solid rgba(34, 197, 94, 0.4)', borderRadius: '8px' }},
                                        e('div', { style: { fontSize: '12px', color: '#4ade80', marginBottom: '8px', fontWeight: '600' }}, '📊 eFG% Contribution (Vol + Eff vs League):'),
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '14px', fontWeight: 'bold' }},
                                            (() => {
                                                const totalAtt = statsB.rimAtt + statsB.midAtt + statsB.threeAtt;
                                                const la = leagueAvgShotStats || {};
                                                const rimC = calcShotContributionV2(statsB.rimM, statsB.rimAtt, totalAtt, false, la.rimFreq || 0.35, la.rimEfgEquiv || 60);
                                                const midC = calcShotContributionV2(statsB.midM, statsB.midAtt, totalAtt, false, la.midFreq || 0.18, la.midEfgEquiv || 40);
                                                const threeC = calcShotContributionV2(statsB.threeM, statsB.threeAtt, totalAtt, true, la.threeFreq || 0.47, la.threeEfgEquiv || 52.5);
                                                const totalContrib = rimC.contribution + midC.contribution + threeC.contribution;
                                                return [
                                                    e('span', { key: 'rim', style: { color: getRelativeColor(rimC.contribution, true, 3) }}, 'Rim: ' + (rimC.contribution >= 0 ? '+' : '') + rimC.contribution.toFixed(2)),
                                                    e('span', { key: 'mid', style: { color: getRelativeColor(midC.contribution, true, 3) }}, 'Mid: ' + (midC.contribution >= 0 ? '+' : '') + midC.contribution.toFixed(2)),
                                                    e('span', { key: 'three', style: { color: getRelativeColor(threeC.contribution, true, 3) }}, '3PT: ' + (threeC.contribution >= 0 ? '+' : '') + threeC.contribution.toFixed(2)),
                                                    e('span', { key: 'total', style: { color: getRelativeColor(totalContrib, true, 5), borderLeft: '1px solid #475569', paddingLeft: '8px' }}, 'Σ ' + (totalContrib >= 0 ? '+' : '') + totalContrib.toFixed(2))
                                                ];
                                            })()
                                        ),
                                        // V4.6.2: Zone Skill metric (Option B)
                                        e('div', { style: { marginTop: '10px', paddingTop: '10px', borderTop: '1px solid rgba(34, 197, 94, 0.3)' }},
                                            e('div', { style: { fontSize: '11px', color: '#86efac', marginBottom: '6px' }}, '🎯 Zone Skill (Eff vs Zone Avg):'),
                                            e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '12px' }},
                                                (() => {
                                                    const totalAtt = statsB.rimAtt + statsB.midAtt + statsB.threeAtt;
                                                    const la = leagueAvgShotStats || {};
                                                    const rimC = calcShotContributionV2(statsB.rimM, statsB.rimAtt, totalAtt, false, la.rimFreq || 0.35, la.rimEfgEquiv || 60);
                                                    const midC = calcShotContributionV2(statsB.midM, statsB.midAtt, totalAtt, false, la.midFreq || 0.18, la.midEfgEquiv || 40);
                                                    const threeC = calcShotContributionV2(statsB.threeM, statsB.threeAtt, totalAtt, true, la.threeFreq || 0.47, la.threeEfgEquiv || 52.5);
                                                    const totalSkill = rimC.zoneSkill + midC.zoneSkill + threeC.zoneSkill;
                                                    return [
                                                        e('span', { key: 'rim', style: { color: getRelativeColor(rimC.zoneSkill, true, 2) }}, 'Rim: ' + (rimC.zoneSkill >= 0 ? '+' : '') + rimC.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'mid', style: { color: getRelativeColor(midC.zoneSkill, true, 2) }}, 'Mid: ' + (midC.zoneSkill >= 0 ? '+' : '') + midC.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'three', style: { color: getRelativeColor(threeC.zoneSkill, true, 2) }}, '3PT: ' + (threeC.zoneSkill >= 0 ? '+' : '') + threeC.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'total', style: { color: getRelativeColor(totalSkill, true, 4), borderLeft: '1px solid #475569', paddingLeft: '8px' }}, 'Σ ' + (totalSkill >= 0 ? '+' : '') + totalSkill.toFixed(2))
                                                    ];
                                                })()
                                            )
                                        )
                                    )
                                )
                            )
                        ),
                        
                        // V4.6.1: Defensive Shot Distribution Section
                        e('div', { className: 'compare-section' },
                            e('div', { className: 'compare-section-title' }, '🛡️ Defensive Shot Distribution (Allowed)'),
                            e('div', { className: 'compare-shot-dist' },
                                e('div', { className: 'compare-shot-panel' },
                                    e('div', { className: 'compare-shot-title', style: { color: '#f87171' }}, '🔵 ' + compareTeamA + ' Defense (Allowed)'),
                                    e('div', { className: 'shot-dist-bar' },
                                        e('div', { className: 'shot-segment shot-rim', style: { width: statsA.rimRateV + '%' }}, statsA.rimRateV > 10 ? statsA.rimRateV.toFixed(0) + '%' : ''),
                                        e('div', { className: 'shot-segment shot-mid', style: { width: statsA.midRateV + '%' }}, statsA.midRateV > 10 ? statsA.midRateV.toFixed(0) + '%' : ''),
                                        e('div', { className: 'shot-segment shot-three', style: { width: statsA.threeRateV + '%' }}, statsA.threeRateV > 10 ? statsA.threeRateV.toFixed(0) + '%' : '')
                                    ),
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginTop: '8px', fontSize: '11px' }},
                                        e('span', { style: { color: '#ef4444' }}, 'Rim: ' + statsA.rimPctV.toFixed(1) + '%'),
                                        e('span', { style: { color: '#f97316' }}, 'Mid: ' + statsA.midPctV.toFixed(1) + '%'),
                                        e('span', { style: { color: '#3b82f6' }}, '3PT: ' + statsA.threePctV.toFixed(1) + '%')
                                    ),
                                    // V4.6.2: Defensive shot contribution - CORRECTED FORMULA with both metrics
                                    e('div', { style: { marginTop: '12px', padding: '12px', background: 'rgba(239, 68, 68, 0.15)', border: '1px solid rgba(239, 68, 68, 0.4)', borderRadius: '8px' }},
                                        e('div', { style: { fontSize: '12px', color: '#f87171', marginBottom: '8px', fontWeight: '600' }}, '🛡️ Opp eFG% Contribution (Vol + Eff vs League, lower = better D):'),
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '14px', fontWeight: 'bold' }},
                                            (() => {
                                                const totalAttV = statsA.rimAttV + statsA.midAttV + statsA.threeAttV;
                                                const la = leagueAvgShotStats || {};
                                                const rimCV = calcShotContributionV2(statsA.rimMV, statsA.rimAttV, totalAttV, false, la.rimFreqV || 0.35, la.rimEfgEquivV || 60);
                                                const midCV = calcShotContributionV2(statsA.midMV, statsA.midAttV, totalAttV, false, la.midFreqV || 0.18, la.midEfgEquivV || 40);
                                                const threeCV = calcShotContributionV2(statsA.threeMV, statsA.threeAttV, totalAttV, true, la.threeFreqV || 0.47, la.threeEfgEquivV || 52.5);
                                                const totalContrib = rimCV.contribution + midCV.contribution + threeCV.contribution;
                                                return [
                                                    e('span', { key: 'rim', style: { color: getRelativeColor(rimCV.contribution, false, 3) }}, 'Rim: ' + (rimCV.contribution >= 0 ? '+' : '') + rimCV.contribution.toFixed(2)),
                                                    e('span', { key: 'mid', style: { color: getRelativeColor(midCV.contribution, false, 3) }}, 'Mid: ' + (midCV.contribution >= 0 ? '+' : '') + midCV.contribution.toFixed(2)),
                                                    e('span', { key: 'three', style: { color: getRelativeColor(threeCV.contribution, false, 3) }}, '3PT: ' + (threeCV.contribution >= 0 ? '+' : '') + threeCV.contribution.toFixed(2)),
                                                    e('span', { key: 'total', style: { color: getRelativeColor(totalContrib, false, 5), borderLeft: '1px solid #475569', paddingLeft: '8px' }}, 'Σ ' + (totalContrib >= 0 ? '+' : '') + totalContrib.toFixed(2))
                                                ];
                                            })()
                                        ),
                                        // V4.6.2: Zone Skill metric for defense
                                        e('div', { style: { marginTop: '10px', paddingTop: '10px', borderTop: '1px solid rgba(239, 68, 68, 0.3)' }},
                                            e('div', { style: { fontSize: '11px', color: '#fca5a5', marginBottom: '6px' }}, '🎯 Zone Skill (Eff vs Zone Avg, lower = better D):'),
                                            e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '12px' }},
                                                (() => {
                                                    const totalAttV = statsA.rimAttV + statsA.midAttV + statsA.threeAttV;
                                                    const la = leagueAvgShotStats || {};
                                                    const rimCV = calcShotContributionV2(statsA.rimMV, statsA.rimAttV, totalAttV, false, la.rimFreqV || 0.35, la.rimEfgEquivV || 60);
                                                    const midCV = calcShotContributionV2(statsA.midMV, statsA.midAttV, totalAttV, false, la.midFreqV || 0.18, la.midEfgEquivV || 40);
                                                    const threeCV = calcShotContributionV2(statsA.threeMV, statsA.threeAttV, totalAttV, true, la.threeFreqV || 0.47, la.threeEfgEquivV || 52.5);
                                                    const totalSkill = rimCV.zoneSkill + midCV.zoneSkill + threeCV.zoneSkill;
                                                    return [
                                                        e('span', { key: 'rim', style: { color: getRelativeColor(rimCV.zoneSkill, false, 2) }}, 'Rim: ' + (rimCV.zoneSkill >= 0 ? '+' : '') + rimCV.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'mid', style: { color: getRelativeColor(midCV.zoneSkill, false, 2) }}, 'Mid: ' + (midCV.zoneSkill >= 0 ? '+' : '') + midCV.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'three', style: { color: getRelativeColor(threeCV.zoneSkill, false, 2) }}, '3PT: ' + (threeCV.zoneSkill >= 0 ? '+' : '') + threeCV.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'total', style: { color: getRelativeColor(totalSkill, false, 4), borderLeft: '1px solid #475569', paddingLeft: '8px' }}, 'Σ ' + (totalSkill >= 0 ? '+' : '') + totalSkill.toFixed(2))
                                                    ];
                                                })()
                                            )
                                        )
                                    )
                                ),
                                e('div', { className: 'compare-shot-panel' },
                                    e('div', { className: 'compare-shot-title', style: { color: '#f87171' }}, '🟣 ' + compareTeamB + ' Defense (Allowed)'),
                                    e('div', { className: 'shot-dist-bar' },
                                        e('div', { className: 'shot-segment shot-rim', style: { width: statsB.rimRateV + '%' }}, statsB.rimRateV > 10 ? statsB.rimRateV.toFixed(0) + '%' : ''),
                                        e('div', { className: 'shot-segment shot-mid', style: { width: statsB.midRateV + '%' }}, statsB.midRateV > 10 ? statsB.midRateV.toFixed(0) + '%' : ''),
                                        e('div', { className: 'shot-segment shot-three', style: { width: statsB.threeRateV + '%' }}, statsB.threeRateV > 10 ? statsB.threeRateV.toFixed(0) + '%' : '')
                                    ),
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginTop: '8px', fontSize: '11px' }},
                                        e('span', { style: { color: '#ef4444' }}, 'Rim: ' + statsB.rimPctV.toFixed(1) + '%'),
                                        e('span', { style: { color: '#f97316' }}, 'Mid: ' + statsB.midPctV.toFixed(1) + '%'),
                                        e('span', { style: { color: '#3b82f6' }}, '3PT: ' + statsB.threePctV.toFixed(1) + '%')
                                    ),
                                    // V4.6.2: Defensive shot contribution - CORRECTED FORMULA with both metrics
                                    e('div', { style: { marginTop: '12px', padding: '12px', background: 'rgba(239, 68, 68, 0.15)', border: '1px solid rgba(239, 68, 68, 0.4)', borderRadius: '8px' }},
                                        e('div', { style: { fontSize: '12px', color: '#f87171', marginBottom: '8px', fontWeight: '600' }}, '🛡️ Opp eFG% Contribution (Vol + Eff vs League, lower = better D):'),
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '14px', fontWeight: 'bold' }},
                                            (() => {
                                                const totalAttV = statsB.rimAttV + statsB.midAttV + statsB.threeAttV;
                                                const la = leagueAvgShotStats || {};
                                                const rimCV = calcShotContributionV2(statsB.rimMV, statsB.rimAttV, totalAttV, false, la.rimFreqV || 0.35, la.rimEfgEquivV || 60);
                                                const midCV = calcShotContributionV2(statsB.midMV, statsB.midAttV, totalAttV, false, la.midFreqV || 0.18, la.midEfgEquivV || 40);
                                                const threeCV = calcShotContributionV2(statsB.threeMV, statsB.threeAttV, totalAttV, true, la.threeFreqV || 0.47, la.threeEfgEquivV || 52.5);
                                                const totalContrib = rimCV.contribution + midCV.contribution + threeCV.contribution;
                                                return [
                                                    e('span', { key: 'rim', style: { color: getRelativeColor(rimCV.contribution, false, 3) }}, 'Rim: ' + (rimCV.contribution >= 0 ? '+' : '') + rimCV.contribution.toFixed(2)),
                                                    e('span', { key: 'mid', style: { color: getRelativeColor(midCV.contribution, false, 3) }}, 'Mid: ' + (midCV.contribution >= 0 ? '+' : '') + midCV.contribution.toFixed(2)),
                                                    e('span', { key: 'three', style: { color: getRelativeColor(threeCV.contribution, false, 3) }}, '3PT: ' + (threeCV.contribution >= 0 ? '+' : '') + threeCV.contribution.toFixed(2)),
                                                    e('span', { key: 'total', style: { color: getRelativeColor(totalContrib, false, 5), borderLeft: '1px solid #475569', paddingLeft: '8px' }}, 'Σ ' + (totalContrib >= 0 ? '+' : '') + totalContrib.toFixed(2))
                                                ];
                                            })()
                                        ),
                                        // V4.6.2: Zone Skill metric for defense
                                        e('div', { style: { marginTop: '10px', paddingTop: '10px', borderTop: '1px solid rgba(239, 68, 68, 0.3)' }},
                                            e('div', { style: { fontSize: '11px', color: '#fca5a5', marginBottom: '6px' }}, '🎯 Zone Skill (Eff vs Zone Avg, lower = better D):'),
                                            e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '12px' }},
                                                (() => {
                                                    const totalAttV = statsB.rimAttV + statsB.midAttV + statsB.threeAttV;
                                                    const la = leagueAvgShotStats || {};
                                                    const rimCV = calcShotContributionV2(statsB.rimMV, statsB.rimAttV, totalAttV, false, la.rimFreqV || 0.35, la.rimEfgEquivV || 60);
                                                    const midCV = calcShotContributionV2(statsB.midMV, statsB.midAttV, totalAttV, false, la.midFreqV || 0.18, la.midEfgEquivV || 40);
                                                    const threeCV = calcShotContributionV2(statsB.threeMV, statsB.threeAttV, totalAttV, true, la.threeFreqV || 0.47, la.threeEfgEquivV || 52.5);
                                                    const totalSkill = rimCV.zoneSkill + midCV.zoneSkill + threeCV.zoneSkill;
                                                    return [
                                                        e('span', { key: 'rim', style: { color: getRelativeColor(rimCV.zoneSkill, false, 2) }}, 'Rim: ' + (rimCV.zoneSkill >= 0 ? '+' : '') + rimCV.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'mid', style: { color: getRelativeColor(midCV.zoneSkill, false, 2) }}, 'Mid: ' + (midCV.zoneSkill >= 0 ? '+' : '') + midCV.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'three', style: { color: getRelativeColor(threeCV.zoneSkill, false, 2) }}, '3PT: ' + (threeCV.zoneSkill >= 0 ? '+' : '') + threeCV.zoneSkill.toFixed(2)),
                                                        e('span', { key: 'total', style: { color: getRelativeColor(totalSkill, false, 4), borderLeft: '1px solid #475569', paddingLeft: '8px' }}, 'Σ ' + (totalSkill >= 0 ? '+' : '') + totalSkill.toFixed(2))
                                                    ];
                                                })()
                                            )
                                        )
                                    )
                                )
                            )
                        ),
                        
                        // Transition & Turnovers
                        e('div', { className: 'compare-section' },
                            e('div', { className: 'compare-section-title' }, '🔄 Turnovers & Transition'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '12px' }},
                                // TO Breakdown
                                e('div', { className: 'compare-to-item' },
                                    e('div', { className: 'compare-to-label' }, 'FB Pts/100'),
                                    e('div', { className: 'compare-to-value', style: { color: '#60a5fa' }}, statsA.fastBreak100.toFixed(1)),
                                    e('div', { className: 'compare-to-value', style: { color: '#c084fc', fontSize: '12px' }}, 'vs ' + statsB.fastBreak100.toFixed(1))
                                ),
                                e('div', { className: 'compare-to-item' },
                                    e('div', { className: 'compare-to-label' }, 'Pts Off TO'),
                                    e('div', { className: 'compare-to-value', style: { color: '#60a5fa' }}, statsA.ptsOffTov100.toFixed(1)),
                                    e('div', { className: 'compare-to-value', style: { color: '#c084fc', fontSize: '12px' }}, 'vs ' + statsB.ptsOffTov100.toFixed(1))
                                ),
                                e('div', { className: 'compare-to-item' },
                                    e('div', { className: 'compare-to-label' }, '2nd Chance'),
                                    e('div', { className: 'compare-to-value', style: { color: '#60a5fa' }}, statsA.secChance100.toFixed(1)),
                                    e('div', { className: 'compare-to-value', style: { color: '#c084fc', fontSize: '12px' }}, 'vs ' + statsB.secChance100.toFixed(1))
                                ),
                                e('div', { className: 'compare-to-item' },
                                    e('div', { className: 'compare-to-label' }, 'AST%'),
                                    e('div', { className: 'compare-to-value', style: { color: '#60a5fa' }}, statsA.astPct.toFixed(1)),
                                    e('div', { className: 'compare-to-value', style: { color: '#c084fc', fontSize: '12px' }}, 'vs ' + statsB.astPct.toFixed(1))
                                ),
                                e('div', { className: 'compare-to-item' },
                                    e('div', { className: 'compare-to-label' }, 'STL%'),
                                    e('div', { className: 'compare-to-value', style: { color: '#60a5fa' }}, statsA.stlPct.toFixed(1)),
                                    e('div', { className: 'compare-to-value', style: { color: '#c084fc', fontSize: '12px' }}, 'vs ' + statsB.stlPct.toFixed(1))
                                ),
                                e('div', { className: 'compare-to-item' },
                                    e('div', { className: 'compare-to-label' }, 'BLK%'),
                                    e('div', { className: 'compare-to-value', style: { color: '#60a5fa' }}, statsA.blkPct.toFixed(1)),
                                    e('div', { className: 'compare-to-value', style: { color: '#c084fc', fontSize: '12px' }}, 'vs ' + statsB.blkPct.toFixed(1))
                                ),
                                e('div', { className: 'compare-to-item' },
                                    e('div', { className: 'compare-to-label' }, 'Pace (Off)'),
                                    e('div', { className: 'compare-to-value', style: { color: '#60a5fa' }}, statsA.paceF.toFixed(1)),
                                    e('div', { className: 'compare-to-value', style: { color: '#c084fc', fontSize: '12px' }}, 'vs ' + statsB.paceF.toFixed(1))
                                ),
                                e('div', { className: 'compare-to-item' },
                                    e('div', { className: 'compare-to-label' }, 'Opp FB/100'),
                                    e('div', { className: 'compare-to-value', style: { color: '#60a5fa' }}, statsA.fastBreak100V.toFixed(1)),
                                    e('div', { className: 'compare-to-value', style: { color: '#c084fc', fontSize: '12px' }}, 'vs ' + statsB.fastBreak100V.toFixed(1))
                                )
                            )
                        )
                    ) : e('div', { style: { textAlign: 'center', padding: '60px', color: '#64748b' }},
                        e('div', { style: { fontSize: '48px', marginBottom: '16px' }}, '⚔️'),
                        e('div', { style: { fontSize: '18px', fontWeight: '600', marginBottom: '8px' }}, 'Select Teams to Compare'),
                        e('div', { style: { fontSize: '14px' }}, 'Choose teams from both sides to see comparison. Leave player slots empty for team-wide stats.')
                    )
                );
            };

            // Main render
            return e('div', { className: 'container' },
                // FLOATING SCRAPER PROGRESS BAR (non-blocking, fixed at top)
                isScraperRunning && scraperProgress && e('div', {
                    style: {
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        right: 0,
                        zIndex: 99999,
                        background: 'linear-gradient(135deg, #3b82f6, #8b5cf6)',
                        padding: '10px 20px',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '16px',
                        boxShadow: '0 4px 20px rgba(0,0,0,0.4)'
                    }
                },
                    e('div', { style: { flex: 1 }},
                        e('div', { style: { fontSize: '13px', fontWeight: 600, color: 'white', marginBottom: '4px' }},
                            '🔄 Updating data... ' + (scraperProgress.current_game ? 'Game ' + scraperProgress.current_game : '')
                        ),
                        e('div', { style: { height: '6px', background: 'rgba(255,255,255,0.2)', borderRadius: '3px' }},
                            e('div', { style: {
                                width: (scraperProgress.progress_percent || 0) + '%',
                                height: '100%',
                                background: '#4ade80',
                                borderRadius: '3px',
                                transition: 'width 0.3s ease'
                            }})
                        ),
                        e('div', { style: { fontSize: '10px', color: 'rgba(255,255,255,0.7)', marginTop: '2px' }},
                            (scraperProgress.games_completed || 0) + ' / ' + (scraperProgress.games_total || '?') + ' games • ' + (scraperProgress.message || 'Processing...')
                        )
                    ),
                    e('button', {
                        onClick: handleCancelScraper,
                        style: { padding: '6px 14px', background: 'rgba(255,255,255,0.2)', border: 'none', borderRadius: '6px', color: 'white', fontSize: '12px', cursor: 'pointer' }
                    }, '✕ Cancel')
                ),
                e(PlayerModal),
                e(MatchupsModal),
                e(ShotDistModal),
                e(TurnoverModal),
                e(OrebModal),
                e(AstModal),
                // V5.12: Leaderboard modal (when showLeaderboard is true and not in tab mode)
                showLeaderboard && activeTab !== 'leaderboard' && e(Leaderboard),
                // V5.12: Collapsible header with file uploads
                e('div', { style: { marginBottom: '16px' }},
                    e('div', { 
                        style: { 
                            display: 'flex', 
                            justifyContent: 'space-between', 
                            alignItems: 'center', 
                            padding: '12px 16px', 
                            background: 'rgba(30, 41, 59, 0.8)', 
                            borderRadius: headerExpanded ? '8px 8px 0 0' : '8px',
                            cursor: 'pointer',
                            border: '1px solid #475569'
                        },
                        onClick: () => setHeaderExpanded(!headerExpanded)
                    },
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' }},
                            e('h1', { style: { fontSize: '1.5rem', fontWeight: 'bold', background: 'linear-gradient(to right, #60a5fa, #a78bfa)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', margin: 0 }}, 'Basketball Lineup Analyzer V4.8')
                        ),
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' }},
                            // File status badges (compact)
                            e('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' }},
                                playerFile && e('span', { style: { fontSize: '10px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(139, 92, 246, 0.3)', color: '#a78bfa' }}, '✓ Player'),
                                matchupFile && e('span', { style: { fontSize: '10px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(34, 211, 238, 0.3)', color: '#22d3ee' }}, '✓ Matchups'),
                                seasonFile && e('span', { style: { fontSize: '10px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(16, 185, 129, 0.3)', color: '#10b981' }}, '✓ Season'),
                                stintsFile && e('span', { style: { fontSize: '10px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(6, 182, 212, 0.3)', color: '#06b6d4' }}, '✓ Stints'),
                                assistComboFile && e('span', { style: { fontSize: '10px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(245, 158, 11, 0.3)', color: '#f59e0b' }}, '✓ Assists'),
                                clutchFile && e('span', { style: { fontSize: '10px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(239, 68, 68, 0.3)', color: '#ef4444' }}, '✓ Clutch'),
                                teamTotalsFile && e('span', { style: { fontSize: '10px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(124, 58, 237, 0.3)', color: '#a78bfa' }}, '✓ Team Totals'),
                                // Data source badge with folder info
                                dataSource === 'scraper' && currentDataFolderInfo && e('span', {
                                    style: { fontSize: '10px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(16, 185, 129, 0.4)', color: '#10b981', fontWeight: 'bold' },
                                    title: 'Data from: ' + currentDataFolderInfo.folderName
                                }, '📊 ' + currentDataFolderInfo.competitionCode + ' (' + currentDataFolderInfo.formattedDate + ' ' + currentDataFolderInfo.formattedTime + ')'),
                                dataSource === 'scraper' && !currentDataFolderInfo && e('span', { style: { fontSize: '10px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(16, 185, 129, 0.4)', color: '#10b981', fontWeight: 'bold' }}, '📊 Scraper Data')
                            ),
                            // Competition code dropdown + Scraper controls (only in Tauri)
                            isTauriApp && e('div', {
                                style: { display: 'flex', alignItems: 'center', gap: '8px', marginLeft: '8px' },
                                onClick: (ev) => ev.stopPropagation() // Prevent header collapse when clicking controls
                            },
                                // Competition code dropdown
                                availableCompetitionCodes.length > 0 && e('select', {
                                    style: {
                                        padding: '5px 8px',
                                        fontSize: '11px',
                                        background: '#1e293b',
                                        border: '1px solid #475569',
                                        borderRadius: '6px',
                                        color: '#e2e8f0',
                                        cursor: 'pointer',
                                        minWidth: '80px'
                                    },
                                    value: selectedCompetitionCode || '',
                                    onChange: async (ev) => {
                                        const newCode = ev.target.value;
                                        if (newCode && newCode !== selectedCompetitionCode) {
                                            setSelectedCompetitionCode(newCode);
                                            // Clear current data
                                            setLineupCsv(null); setPlayerCsv(null); setStintsCsv(null); setPlayerStintsCsv(null);
                                            setSeasonCsv(null); setMatchupCsv(null); setClutchCsv(null);
                                            setAssistComboCsv(null); setTeamTotalsCsv(null);
                                            setLineupFile(null); setPlayerFile(null); setStintsFile(null); setPlayerStintsFile(null);
                                            setSeasonFile(null); setMatchupFile(null); setClutchFile(null);
                                            setAssistComboFile(null); setTeamTotalsFile(null);
                                            // Load newest folder for this competition code
                                            setAutoLoadMessage('Loading ' + newCode + '...');
                                            await tryLoadFromTauriScraperFolder(newCode);
                                        }
                                    }
                                },
                                    e('option', { value: '', disabled: true }, '📁 Competition'),
                                    availableCompetitionCodes.map(code => e('option', { key: code, value: code }, code))
                                ),
                                // Update Data button
                                !isScraperRunning ? e('button', {
                                    style: {
                                        padding: '6px 12px',
                                        fontSize: '11px',
                                        fontWeight: '600',
                                        background: 'linear-gradient(135deg, #10b981, #059669)',
                                        color: 'white',
                                        border: 'none',
                                        borderRadius: '6px',
                                        cursor: 'pointer',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '4px',
                                        whiteSpace: 'nowrap'
                                    },
                                    onClick: handleUpdateData
                                }, '🚀 Update Data') : e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                    // Progress indicator
                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' }},
                                        e('div', { style: {
                                            width: '14px', height: '14px',
                                            border: '2px solid rgba(16, 185, 129, 0.3)',
                                            borderTop: '2px solid #10b981',
                                            borderRadius: '50%',
                                            animation: 'spin 1s linear infinite'
                                        }}),
                                        e('span', { style: { fontSize: '11px', color: '#10b981', fontWeight: '600' }},
                                            scraperProgress ?
                                                (scraperProgress.games_completed && scraperProgress.games_total ?
                                                    scraperProgress.games_completed + '/' + scraperProgress.games_total + ' games' :
                                                    (scraperProgress.progress_percent || 0) + '%') :
                                                'Starting...'
                                        )
                                    ),
                                    // Cancel button
                                    e('button', {
                                        style: {
                                            padding: '4px 8px',
                                            fontSize: '10px',
                                            fontWeight: '600',
                                            background: 'rgba(239, 68, 68, 0.2)',
                                            color: '#f87171',
                                            border: '1px solid rgba(239, 68, 68, 0.3)',
                                            borderRadius: '4px',
                                            cursor: 'pointer'
                                        },
                                        onClick: handleCancelScraper
                                    }, '✕')
                                )
                            ),
                            e('span', { style: { fontSize: '18px', color: '#94a3b8', transition: 'transform 0.2s', transform: headerExpanded ? 'rotate(180deg)' : 'rotate(0deg)' }}, '▼')
                        )
                    ),
                    // Expandable section with file uploads
                    headerExpanded && e('div', {
                        style: {
                            padding: '16px',
                            background: 'rgba(30, 41, 59, 0.5)',
                            borderRadius: '0 0 8px 8px',
                            border: '1px solid #475569',
                            borderTop: 'none'
                        }
                    },
                        e('div', { style: { display: 'flex', gap: '8px', flexWrap: 'wrap', marginBottom: '12px' }},
                            e('button', {
                                className: 'btn',
                                style: { background: showRelativeToLeague ? '#22c55e' : '#64748b', color: 'white' },
                                onClick: () => setShowRelativeToLeague(!showRelativeToLeague)
                            }, showRelativeToLeague ? '📊 Relative Mode ON' : '📊 Raw Numbers')
                        ),
                        e('div', { style: { display: 'flex', gap: '8px', flexWrap: 'wrap' }},
                            e('label', null, e('input', { type: 'file', accept: '.csv', onChange: handleLineup, style: { display: 'none' } }), e('div', { className: 'btn btn-secondary' }, 'Lineup')),
                            e('label', null, e('input', { type: 'file', accept: '.csv', onChange: handlePlayer, style: { display: 'none' } }), e('div', { className: 'btn btn-toggle' }, 'Player')),
                            e('label', null, e('input', { type: 'file', accept: '.csv', onChange: handleMatchup, style: { display: 'none' } }), e('div', { className: 'btn', style: { background: '#0891b2', color: 'white' } }, 'Matchup')),
                            e('label', null, e('input', { type: 'file', accept: '.csv', onChange: handleSeason, style: { display: 'none' } }), e('div', { className: 'btn btn-success' }, 'Season')),
                            e('label', null, e('input', { type: 'file', accept: '.csv', onChange: handleAssistCombo, style: { display: 'none' } }), e('div', { className: 'btn', style: { background: '#d97706', color: 'white', fontSize: '12px' } }, '🤝 Assists')),
                            e('label', null, e('input', { type: 'file', accept: '.csv', onChange: handleClutch, style: { display: 'none' } }), e('div', { className: 'btn', style: { background: '#dc2626', color: 'white', fontSize: '12px' } }, '⏱️ Clutch')),
                            e('label', null, e('input', { type: 'file', accept: '.csv', onChange: handleStints, style: { display: 'none' } }), e('div', { className: 'btn', style: { background: '#0891b2', color: 'white', fontSize: '12px' } }, '📊 Stints')),
                            e('label', null, e('input', { type: 'file', accept: '.csv', onChange: handleTeamTotals, style: { display: 'none' } }), e('div', { className: 'btn', style: { background: '#7c3aed', color: 'white', fontSize: '12px' } }, '📋 Team Totals'))
                        )
                    )
                ),
                // V4.2: Tab Navigation - shows if either lineup data or stints data is loaded
                (lineupData.length > 0 || stintsData.length > 0) && e('div', { className: 'tab-nav' },
                    lineupData.length > 0 && e('button', {
                        className: 'tab-btn' + (activeTab === 'analyzer' ? ' active' : ''),
                        onClick: () => setActiveTab('analyzer'),
                        title: 'Analyze lineup combinations and see how players perform together'
                    }, '📊 Lineup Analyzer'),
                    // V5.12: Leaderboard as main tab
                    lineupData.length > 0 && e('button', {
                        className: 'tab-btn' + (activeTab === 'leaderboard' ? ' active' : ''),
                        style: activeTab === 'leaderboard' ? { background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)' } : {},
                        onClick: () => setActiveTab('leaderboard'),
                        title: 'Player rankings with on-off stats, shooting splits, and advanced metrics'
                    }, '🏆 Leaderboard'),
                    lineupData.length > 0 && e('button', {
                        className: 'tab-btn' + (activeTab === 'wowy' ? ' active' : ''),
                        onClick: () => setActiveTab('wowy'),
                        title: 'With Or Without You - see how team performs with/without specific players'
                    }, '🔄 WOWY Mode'),
                    lineupData.length > 0 && e('button', {
                        className: 'tab-btn' + (activeTab === 'compare' ? ' active' : ''),
                        onClick: () => { setActiveTab('compare'); if (!compareTeamA && teams.length > 0) setCompareTeamA(teams[0]); if (!compareTeamB && teams.length > 1) setCompareTeamB(teams[1]); },
                        title: 'Compare two teams side-by-side with four factors and ratings'
                    }, '⚔️ Compare'),
                    stintsData.length > 0 && e('button', {
                        className: 'tab-btn' + (activeTab === 'gamerange' ? ' active' : ''),
                        onClick: () => { setActiveTab('gamerange'); if (!gameRangeTeam && stintsTeams.length > 0) setGameRangeTeam(stintsTeams[0]); },
                        title: 'Filter stats by date range to see performance over specific periods'
                    }, '📅 Game Range'),
                    lineupData.length > 0 && e('button', {
                        className: 'tab-btn' + (activeTab === 'export' ? ' active' : ''),
                        style: activeTab === 'export' ? { background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)' } : {},
                        onClick: () => { setActiveTab('export'); if (!exportTeam && teams.length > 0) setExportTeam(teams[0]); if (!exportLineupTeam && teams.length > 0) setExportLineupTeam(teams[0]); if (!exportFFTeam && teams.length > 0) setExportFFTeam(teams[0]); if (!exportShotTeam && teams.length > 0) setExportShotTeam(teams[0]); },
                        title: 'Create shareable graphics of lineup stats and four factors'
                    }, '📸 Export View'),
                    // V5.0: Stat Impact Analysis as main tab
                    matchupData.length > 0 && e('button', {
                        className: 'tab-btn' + (activeTab === 'statimpact' ? ' active' : ''),
                        style: activeTab === 'statimpact' ? { background: 'linear-gradient(135deg, #f97316 0%, #ea580c 100%)' } : {},
                        onClick: () => setActiveTab('statimpact'),
                        title: 'See which stats matter most for winning using regression analysis'
                    }, '🔬 Stat Impact'),
                    // V5.4: Strength of Schedule tab
                    teamTotalsData.length > 0 && e('button', {
                        className: 'tab-btn' + (activeTab === 'sos' ? ' active' : ''),
                        style: activeTab === 'sos' ? { background: 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)' } : {},
                        onClick: () => setActiveTab('sos'),
                        title: 'League standings adjusted for opponent difficulty with ELO and expected wins'
                    }, '📊 Strength of Schedule'),
                    // V6.0: Advanced Games View tab (embedded GAMEVIS)
                    e('button', {
                        className: 'tab-btn' + (activeTab === 'advancedgames' ? ' active' : ''),
                        style: activeTab === 'advancedgames' ? { background: 'linear-gradient(135deg, #00d4ff 0%, #ff00aa 100%)' } : {},
                        onClick: () => setActiveTab('advancedgames'),
                        title: 'Deep-dive into individual games with play-by-play visualizations'
                    }, '🎮 Advanced Games View'),
                    // V6.1: Settings Tab - Always visible
                    e('button', {
                        className: 'tab-btn' + (activeTab === 'settings' ? ' active' : ''),
                        style: activeTab === 'settings' ? { background: 'linear-gradient(135deg, #64748b 0%, #475569 100%)' } : {},
                        onClick: () => setActiveTab('settings'),
                        title: 'Configure app settings and data filters'
                    }, '⚙️ Settings')
                ),
                // V5.12: Leaderboard as full-width tab content
                activeTab === 'leaderboard' && lineupData.length > 0 && e(Leaderboard),
                // Show WOWY tab content
                activeTab === 'wowy' && lineupData.length > 0 && e('div', null,
                    e('div', { className: 'controls', style: { marginBottom: '24px' }},
                        e('div', { className: 'form-group' },
                            e('label', null, 'Team'),
                            e('select', { value: team, onChange: ev => { setTeam(ev.target.value); setWowyPlayers([]); } }, 
                                teams.map(t => e('option', { key: t, value: t }, t))
                            )
                        )
                    ),
                    e(WOWYSection)
                ),
                // Show Compare tab content
                activeTab === 'compare' && lineupData.length > 0 && e('div', null,
                    e('div', { className: 'dataset-info', style: { marginBottom: '24px' }},
                        e('strong', null, '⚔️ Lineup Comparison Tool'),
                        e('div', { style: { marginTop: '8px', fontSize: '13px', opacity: 0.9 }},
                            'Compare any two player combinations (from any team) head-to-head. Select players manually or use Quick Select to load full lineups. ',
                            'All stats are aggregated from lineups containing the selected players.'
                        ),
                        e('div', { style: { marginTop: '8px', fontSize: '11px', opacity: 0.7 }},
                            '• Four Factors: eFG%, TOV%, OREB%, FT Rate for offense and defense',
                            e('br'),
                            '• Shot Distribution: Rim/Mid/3PT rates and percentages',
                            e('br'),
                            '• Transition: Fast break points, points off turnovers, 2nd chance points'
                        )
                    ),
                    e(CompareSection)
                ),
                // V4.9.8.7.17: Game Range Analysis Tab
                activeTab === 'gamerange' && stintsData.length > 0 && e('div', null,
                    e('div', { className: 'dataset-info', style: { marginBottom: '24px' }},
                        e('strong', null, '📅 Game Range Analysis'),
                        e('div', { style: { marginTop: '8px', fontSize: '13px', opacity: 0.9 }},
                            'Analyze Four Factors and ratings for specific game ranges. Select a team, filter by wins/losses, optionally filter by player combination, ',
                            'then choose which games (by row order in stints data) to include in the analysis.'
                        ),
                        e('div', { style: { marginTop: '8px', fontSize: '11px', opacity: 0.7 }},
                            '• Uses stints.csv data for game-by-game analysis',
                            e('br'),
                            '• Game numbers reflect row order in the data file',
                            e('br'),
                            '• Win/Loss filter: Compare team performance in wins vs losses',
                            e('br'),
                            '• Player filter is optional - leave empty for team-wide stats'
                        )
                    ),
                    e('div', { className: 'controls', style: { marginBottom: '24px' }},
                        // Team selection
                        e('div', { className: 'grid-2', style: { gap: '16px' }},
                            e('div', { className: 'form-group', style: { marginBottom: 0 }},
                                e('label', null, 'Team'),
                                e('select', { 
                                    value: gameRangeTeam, 
                                    onChange: ev => { 
                                        setGameRangeTeam(ev.target.value); 
                                        setGameRangePlayers({ p1: '', p2: '', p3: '', p4: '', p5: '' });
                                        setGameRangeWinFilter('all');
                                        setGameRangeResults(null);
                                    } 
                                }, 
                                    e('option', { value: '' }, '-- Select Team --'),
                                    stintsTeams.map(t => e('option', { key: t, value: t }, t))
                                )
                            ),
                            // Win/Loss Filter
                            gameRangeTeam && e('div', { className: 'form-group', style: { marginBottom: 0 }},
                                e('label', null, 'Game Result Filter', 
                                    (() => {
                                        const teamGames = gamesByTeam.get(gameRangeTeam) || [];
                                        const wins = teamGames.filter(g => g.isWin).length;
                                        const losses = teamGames.length - wins;
                                        return e('span', { style: { marginLeft: '8px', fontSize: '11px', color: '#94a3b8' }},
                                            '(' + wins + 'W - ' + losses + 'L)'
                                        );
                                    })()
                                ),
                                e('select', { 
                                    value: gameRangeWinFilter, 
                                    onChange: ev => {
                                        setGameRangeWinFilter(ev.target.value);
                                        setGameRangeResults(null);
                                    }
                                }, 
                                    e('option', { value: 'all' }, '📊 All Games'),
                                    e('option', { value: 'wins' }, '✅ Wins Only'),
                                    e('option', { value: 'losses' }, '❌ Losses Only')
                                )
                            )
                        ),
                        // Player combination filters (optional)
                        gameRangeTeam && e('div', { style: { marginTop: '16px' }},
                            e('div', { className: 'flex-between' },
                                e('label', null, 'Player Filter (Optional)', 
                                    e('span', { style: { marginLeft: '8px', fontSize: '11px', color: '#fbbf24' }}, 
                                        Object.values(gameRangePlayers).filter(p => p).length === 0 ? '(Team-wide)' : '(' + Object.values(gameRangePlayers).filter(p => p).length + ' selected)'
                                    )
                                ),
                                e('button', { 
                                    className: 'btn btn-secondary', 
                                    onClick: () => setGameRangePlayers({ p1: '', p2: '', p3: '', p4: '', p5: '' }),
                                    style: { fontSize: '12px', padding: '6px 12px' }
                                }, 'Clear')
                            ),
                            e('div', { className: 'grid-5', style: { marginTop: '12px' }}, 
                                ['p1', 'p2', 'p3', 'p4', 'p5'].map((p, i) => e('div', { key: p }, 
                                    e('label', { className: 'text-xs' }, 'Player ' + (i + 1)), 
                                    e('select', { 
                                        value: gameRangePlayers[p], 
                                        onChange: ev => setGameRangePlayers(pr => ({ ...pr, [p]: ev.target.value })) 
                                    }, 
                                        e('option', { value: '' }, 'Any'), 
                                        gameRangeTeamPlayers.map(pl => e('option', { 
                                            key: pl, 
                                            value: pl, 
                                            disabled: Object.values(gameRangePlayers).includes(pl) && gameRangePlayers[p] !== pl 
                                        }, pl))
                                    )
                                ))
                            )
                        ),
                        // Game range selection
                        gameRangeTeam && gamesByTeam.get(gameRangeTeam) && e('div', { style: { marginTop: '24px', paddingTop: '16px', borderTop: '1px solid #475569' }},
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '16px', marginBottom: '12px' }},
                                e('label', null, 'Filter By'),
                                // V5.12: Toggle between Games and Dates mode
                                e('div', { style: { display: 'flex', gap: '8px' }},
                                    e('button', {
                                        className: 'btn ' + (gameRangeDateMode === 'games' ? 'btn-primary' : 'btn-secondary'),
                                        style: { fontSize: '11px', padding: '4px 12px' },
                                        onClick: () => setGameRangeDateMode('games')
                                    }, '📊 Game #'),
                                    e('button', {
                                        className: 'btn ' + (gameRangeDateMode === 'dates' ? 'btn-primary' : 'btn-secondary'),
                                        style: { fontSize: '11px', padding: '4px 12px' },
                                        onClick: () => setGameRangeDateMode('dates')
                                    }, '📅 Date Range')
                                ),
                                e('span', { style: { fontSize: '11px', color: '#94a3b8' }}, 
                                    (() => {
                                        const allGames = gamesByTeam.get(gameRangeTeam);
                                        const filteredCount = gameRangeWinFilter === 'all' ? allGames.length :
                                            gameRangeWinFilter === 'wins' ? allGames.filter(g => g.isWin).length :
                                            allGames.filter(g => !g.isWin).length;
                                        return '(' + filteredCount + ' games ' + (gameRangeWinFilter === 'all' ? 'available' : gameRangeWinFilter === 'wins' ? '(wins)' : '(losses)') + ')';
                                    })()
                                )
                            ),
                            // Game Number mode
                            gameRangeDateMode === 'games' && e('div', { className: 'grid-3', style: { alignItems: 'end' }},
                                e('div', null,
                                    e('label', { className: 'text-xs' }, 'From Game'),
                                    e('select', { 
                                        value: gameRangeStart, 
                                        onChange: ev => setGameRangeStart(parseInt(ev.target.value) || 1),
                                        style: { width: '100%' }
                                    },
                                        gamesByTeam.get(gameRangeTeam).map(g => 
                                            e('option', { key: g.gameNumber, value: g.gameNumber }, 
                                                g.gameNumber + '. ' + (g.result === 'W' ? '✓' : '✗') + ' ' + (g.isHome ? 'vs ' : '@ ') + g.opponent + ' (' + g.teamPts + '-' + g.oppPts + ')' + (g.gameDate ? ' [' + g.gameDate + ']' : '')
                                            )
                                        )
                                    )
                                ),
                                e('div', null,
                                    e('label', { className: 'text-xs' }, 'To Game'),
                                    e('select', { 
                                        value: gameRangeEnd, 
                                        onChange: ev => setGameRangeEnd(parseInt(ev.target.value) || 1),
                                        style: { width: '100%' }
                                    },
                                        gamesByTeam.get(gameRangeTeam).map(g => 
                                            e('option', { key: g.gameNumber, value: g.gameNumber }, 
                                                g.gameNumber + '. ' + (g.result === 'W' ? '✓' : '✗') + ' ' + (g.isHome ? 'vs ' : '@ ') + g.opponent + ' (' + g.teamPts + '-' + g.oppPts + ')' + (g.gameDate ? ' [' + g.gameDate + ']' : '')
                                            )
                                        )
                                    )
                                ),
                                e('button', { 
                                    className: 'btn btn-primary',
                                    onClick: calculateGameRangeStats,
                                    style: { padding: '10px 24px' }
                                }, '📊 Calculate')
                            ),
                            // Date Range mode
                            gameRangeDateMode === 'dates' && e('div', { className: 'grid-3', style: { alignItems: 'end' }},
                                e('div', null,
                                    e('label', { className: 'text-xs' }, 'From Date'),
                                    e('input', { 
                                        type: 'date',
                                        value: gameRangeDateStart,
                                        onChange: ev => setGameRangeDateStart(ev.target.value),
                                        style: { width: '100%', padding: '8px', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: 'white' }
                                    })
                                ),
                                e('div', null,
                                    e('label', { className: 'text-xs' }, 'To Date'),
                                    e('input', { 
                                        type: 'date',
                                        value: gameRangeDateEnd,
                                        onChange: ev => setGameRangeDateEnd(ev.target.value),
                                        style: { width: '100%', padding: '8px', background: '#1e293b', border: '1px solid #475569', borderRadius: '6px', color: 'white' }
                                    })
                                ),
                                e('button', { 
                                    className: 'btn btn-primary',
                                    onClick: calculateGameRangeStats,
                                    style: { padding: '10px 24px' }
                                }, '📊 Calculate')
                            ),
                            // Quick range buttons
                            e('div', { style: { marginTop: '12px', display: 'flex', gap: '8px', flexWrap: 'wrap' }},
                                e('button', { 
                                    className: 'btn btn-secondary', 
                                    style: { fontSize: '11px', padding: '4px 8px' },
                                    onClick: () => { setGameRangeStart(1); setGameRangeEnd(Math.min(5, gamesByTeam.get(gameRangeTeam).length)); }
                                }, 'First 5'),
                                e('button', { 
                                    className: 'btn btn-secondary', 
                                    style: { fontSize: '11px', padding: '4px 8px' },
                                    onClick: () => { setGameRangeStart(1); setGameRangeEnd(Math.min(10, gamesByTeam.get(gameRangeTeam).length)); }
                                }, 'First 10'),
                                e('button', { 
                                    className: 'btn btn-secondary', 
                                    style: { fontSize: '11px', padding: '4px 8px' },
                                    onClick: () => { 
                                        const len = gamesByTeam.get(gameRangeTeam).length;
                                        setGameRangeStart(Math.max(1, len - 4)); 
                                        setGameRangeEnd(len); 
                                    }
                                }, 'Last 5'),
                                e('button', { 
                                    className: 'btn btn-secondary', 
                                    style: { fontSize: '11px', padding: '4px 8px' },
                                    onClick: () => { 
                                        const len = gamesByTeam.get(gameRangeTeam).length;
                                        setGameRangeStart(Math.max(1, len - 9)); 
                                        setGameRangeEnd(len); 
                                    }
                                }, 'Last 10'),
                                e('button', { 
                                    className: 'btn btn-secondary', 
                                    style: { fontSize: '11px', padding: '4px 8px' },
                                    onClick: () => { 
                                        setGameRangeStart(1); 
                                        setGameRangeEnd(gamesByTeam.get(gameRangeTeam).length); 
                                    }
                                }, 'All Games'),
                                // Win/Loss quick buttons
                                e('span', { style: { borderLeft: '1px solid #475569', height: '20px', margin: '0 4px' }}),
                                e('button', { 
                                    className: 'btn btn-success', 
                                    style: { fontSize: '11px', padding: '4px 8px' },
                                    onClick: () => { 
                                        setGameRangeWinFilter('wins');
                                        setGameRangeStart(1); 
                                        setGameRangeEnd(gamesByTeam.get(gameRangeTeam).length); 
                                    }
                                }, '✅ All Wins'),
                                e('button', { 
                                    className: 'btn btn-impact', 
                                    style: { fontSize: '11px', padding: '4px 8px' },
                                    onClick: () => { 
                                        setGameRangeWinFilter('losses');
                                        setGameRangeStart(1); 
                                        setGameRangeEnd(gamesByTeam.get(gameRangeTeam).length); 
                                    }
                                }, '❌ All Losses')
                            )
                        )
                    ),
                    // Game Range Results
                    gameRangeResults && !gameRangeResults.error && (() => {
                        const st = gameRangeResults.stats;
                        // V4.9.8.7.30: Calculate ranks using teamAvgArrays
                        const grPcts = teamAvgArrays.net && teamAvgArrays.net.length ? {
                            net: calcTeamRankAndPct(st.net, teamAvgArrays.net, true),
                            off: calcTeamRankAndPct(st.off, teamAvgArrays.off, true),
                            def: calcTeamRankAndPct(st.def, teamAvgArrays.def, false),
                            offEfg: calcTeamRankAndPct(st.offEfg, teamAvgArrays.offEfg, true),
                            offTov: calcTeamRankAndPct(st.offTov, teamAvgArrays.offTov, false),
                            offOreb: calcTeamRankAndPct(st.offOreb, teamAvgArrays.offOreb, true),
                            offFtR: calcTeamRankAndPct(st.offFtR, teamAvgArrays.offFtR, true),
                            defEfg: calcTeamRankAndPct(st.defEfg, teamAvgArrays.defEfg, false),
                            defTov: calcTeamRankAndPct(st.defTov, teamAvgArrays.defTov, true),
                            defOreb: calcTeamRankAndPct(st.defOreb, teamAvgArrays.defOreb, false),
                            defFtR: calcTeamRankAndPct(st.defFtR, teamAvgArrays.defFtR, false),
                            rimPct: calcTeamRankAndPct(st.rimPct, teamAvgArrays.rimPct, true),
                            midPct: calcTeamRankAndPct(st.midPct, teamAvgArrays.midPct, true),
                            threePct: calcTeamRankAndPct(st.threePct, teamAvgArrays.threePct, true),
                            rimPctV: calcTeamRankAndPct(st.rimPctV, teamAvgArrays.rimPctV, false),
                            midPctV: calcTeamRankAndPct(st.midPctV, teamAvgArrays.midPctV, false),
                            threePctV: calcTeamRankAndPct(st.threePctV, teamAvgArrays.threePctV, false),
                            astPct: calcTeamRankAndPct(st.astPct, teamAvgArrays.astPct, true),
                            stlPct: calcTeamRankAndPct(st.stlPct, teamAvgArrays.stlPct, true),
                            blkPct: calcTeamRankAndPct(st.blkPct, teamAvgArrays.blkPct, true),
                        } : {};
                        const hasPcts = Object.keys(grPcts).length > 0;
                        
                        return e('div', null,
                        // Summary card
                        e('div', { className: 'section', style: { background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(139, 92, 246, 0.1))', border: '2px solid rgba(59, 130, 246, 0.3)' }},
                            e('div', { className: 'flex-between' },
                                e('h2', { className: 'section-title', style: { color: '#60a5fa' }}, 
                                    // V5.12: Display based on filter mode
                                    gameRangeResults.filterMode === 'dates' && gameRangeResults.dateRange
                                        ? '📅 ' + gameRangeResults.team + ' - ' + (gameRangeResults.dateRange.start || 'Start') + ' to ' + (gameRangeResults.dateRange.end || 'End')
                                        : '📅 ' + gameRangeResults.team + ' - Games ' + (gameRangeResults.gameRange?.start || 1) + ' to ' + (gameRangeResults.gameRange?.end || '?'),
                                    gameRangeResults.winFilter && gameRangeResults.winFilter !== 'all' && e('span', { 
                                        style: { 
                                            marginLeft: '12px', 
                                            fontSize: '14px', 
                                            padding: '4px 12px', 
                                            borderRadius: '12px',
                                            background: gameRangeResults.winFilter === 'wins' ? 'rgba(34, 197, 94, 0.3)' : 'rgba(239, 68, 68, 0.3)',
                                            color: gameRangeResults.winFilter === 'wins' ? '#4ade80' : '#f87171'
                                        }
                                    }, gameRangeResults.winFilter === 'wins' ? '✅ Wins Only' : '❌ Losses Only')
                                ),
                                e('div', { style: { textAlign: 'right' }},
                                    e('div', { style: { fontSize: '13px', color: '#94a3b8' }}, 
                                        gameRangeResults.gamesCount + ' ' + (gameRangeResults.winFilter === 'wins' ? 'wins' : gameRangeResults.winFilter === 'losses' ? 'losses' : 'games') + ' | ' + gameRangeResults.stintsCount + ' stints | ' + Math.round(gameRangeResults.possessions) + ' possessions'
                                    ),
                                    gameRangeResults.players.length > 0 && e('div', { style: { fontSize: '11px', color: '#a78bfa', marginTop: '4px' }}, 
                                        'With: ' + gameRangeResults.players.join(', ')
                                    )
                                )
                            )
                        ),
                        // Ratings summary with percentile colors
                        e('div', { className: 'stats-grid', style: { marginBottom: '24px' }},
                            e('div', { className: hasPcts ? getPerfFromPct(grPcts.off) : 'stat-card', style: { padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                                e('div', { className: 'stat-label' }, 'Off Rating'),
                                e('div', { className: 'stat-value', style: { color: '#4ade80' }}, gameRangeResults.ratings.off.toFixed(1)),
                                hasPcts && e(Pct, { val: grPcts.off })
                            ),
                            e('div', { className: hasPcts ? getPerfFromPct(grPcts.def) : 'stat-card', style: { padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                                e('div', { className: 'stat-label' }, 'Def Rating'),
                                e('div', { className: 'stat-value', style: { color: '#f87171' }}, gameRangeResults.ratings.def.toFixed(1)),
                                hasPcts && e(Pct, { val: grPcts.def })
                            ),
                            e('div', { className: hasPcts ? getPerfFromPct(grPcts.net) : 'stat-card', style: { padding: '16px', borderRadius: '8px', textAlign: 'center' }},
                                e('div', { className: 'stat-label' }, 'Net Rating'),
                                e('div', { className: 'stat-value', style: { color: getNetColor(gameRangeResults.ratings.net) }}, (gameRangeResults.ratings.net >= 0 ? '+' : '') + gameRangeResults.ratings.net.toFixed(1)),
                                hasPcts && e(Pct, { val: grPcts.net })
                            ),
                            e('div', { className: 'stat-card' },
                                e('div', { className: 'stat-label' }, 'Games'),
                                e('div', { className: 'stat-value' }, gameRangeResults.gamesCount)
                            ),
                            e('div', { className: 'stat-card' },
                                e('div', { className: 'stat-label' }, 'Possessions'),
                                e('div', { className: 'stat-value' }, Math.round(gameRangeResults.possessions))
                            )
                        ),
                        // Four Factors with percentile colors
                        e('div', { className: 'section' },
                            e('h2', { className: 'section-title' }, 'Four Factors'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '24px' }},
                                // Offensive Four Factors
                                e('div', { style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '8px', padding: '16px' }},
                                    e('h3', { style: { color: '#4ade80', marginBottom: '12px' }}, 'Offensive'),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }},
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.offEfg) : '', style: { padding: '12px', borderRadius: '6px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'eFG%'),
                                            e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, st.offEfg.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.offEfg })
                                        ),
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.offTov) : '', style: { padding: '12px', borderRadius: '6px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'TOV%'),
                                            e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, st.offTov.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.offTov })
                                        ),
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.offOreb) : '', style: { padding: '12px', borderRadius: '6px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'OREB%'),
                                            e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, st.offOreb.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.offOreb })
                                        ),
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.offFtR) : '', style: { padding: '12px', borderRadius: '6px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'FT Rate'),
                                            e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, st.offFtR.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.offFtR })
                                        )
                                    )
                                ),
                                // Defensive Four Factors
                                e('div', { style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '8px', padding: '16px' }},
                                    e('h3', { style: { color: '#f87171', marginBottom: '12px' }}, 'Defensive (Opp)'),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }},
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.defEfg) : '', style: { padding: '12px', borderRadius: '6px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'Opp eFG%'),
                                            e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, st.defEfg.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.defEfg })
                                        ),
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.defTov) : '', style: { padding: '12px', borderRadius: '6px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'Opp TOV%'),
                                            e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, st.defTov.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.defTov })
                                        ),
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.defOreb) : '', style: { padding: '12px', borderRadius: '6px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'Opp OREB%'),
                                            e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, st.defOreb.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.defOreb })
                                        ),
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.defFtR) : '', style: { padding: '12px', borderRadius: '6px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '12px', opacity: 0.8 }}, 'Opp FT Rate'),
                                            e('div', { style: { fontSize: '24px', fontWeight: 'bold' }}, st.defFtR.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.defFtR })
                                        )
                                    )
                                )
                            )
                        ),
                        // Shot Distribution
                        e('div', { className: 'section' },
                            e('h2', { className: 'section-title' }, '🎯 Shot Distribution'),
                            e('div', { className: 'grid-2' },
                                // Offensive shots
                                e('div', { style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '8px', padding: '16px' }},
                                    e('h3', { style: { color: '#4ade80', marginBottom: '12px' }}, 'Offensive'),
                                    // Shot distribution bar
                                    e('div', { className: 'shot-dist-bar' }, 
                                        st.rimRate > 0 && e('div', { className: 'shot-segment shot-rim', style: { width: st.rimRate + '%' }}, st.rimRate >= 15 ? 'Rim ' + st.rimRate.toFixed(0) + '%' : ''), 
                                        st.midRate > 0 && e('div', { className: 'shot-segment shot-mid', style: { width: st.midRate + '%' }}, st.midRate >= 15 ? 'Mid ' + st.midRate.toFixed(0) + '%' : ''), 
                                        st.threeRate > 0 && e('div', { className: 'shot-segment shot-three', style: { width: st.threeRate + '%' }}, st.threeRate >= 15 ? '3PT ' + st.threeRate.toFixed(0) + '%' : '')
                                    ),
                                    e('div', { className: 'grid-3', style: { marginTop: '16px' }},
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.rimPct) : '', style: { padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '11px', opacity: 0.8 }}, 'Rim'),
                                            e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, st.rimPct.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.rimPct }),
                                            e('div', { style: { fontSize: '11px', opacity: 0.7 }}, Math.round(st.rimM) + '/' + Math.round(st.rimA)),
                                            e('div', { style: { fontSize: '10px', color: '#a78bfa', marginTop: '4px' }}, st.rimVol.toFixed(1) + '/100')
                                        ),
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.midPct) : '', style: { padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '11px', opacity: 0.8 }}, 'Mid'),
                                            e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, st.midPct.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.midPct }),
                                            e('div', { style: { fontSize: '11px', opacity: 0.7 }}, Math.round(st.midM) + '/' + Math.round(st.midA)),
                                            e('div', { style: { fontSize: '10px', color: '#a78bfa', marginTop: '4px' }}, st.midVol.toFixed(1) + '/100')
                                        ),
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.threePct) : '', style: { padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '11px', opacity: 0.8 }}, '3PT'),
                                            e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, st.threePct.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.threePct }),
                                            e('div', { style: { fontSize: '11px', opacity: 0.7 }}, Math.round(st.threeM) + '/' + Math.round(st.threeA)),
                                            e('div', { style: { fontSize: '10px', color: '#a78bfa', marginTop: '4px' }}, st.threeVol.toFixed(1) + '/100')
                                        )
                                    ),
                                    e('div', { style: { fontSize: '10px', opacity: 0.6, marginTop: '8px', textAlign: 'center' }}, 'Purple = attempts per 100 possessions')
                                ),
                                // Defensive shots (allowed)
                                e('div', { style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '8px', padding: '16px' }},
                                    e('h3', { style: { color: '#f87171', marginBottom: '12px' }}, 'Opponent (Allowed)'),
                                    // Shot distribution bar
                                    e('div', { className: 'shot-dist-bar' }, 
                                        st.rimRateV > 0 && e('div', { className: 'shot-segment shot-rim', style: { width: st.rimRateV + '%' }}, st.rimRateV >= 15 ? 'Rim ' + st.rimRateV.toFixed(0) + '%' : ''), 
                                        st.midRateV > 0 && e('div', { className: 'shot-segment shot-mid', style: { width: st.midRateV + '%' }}, st.midRateV >= 15 ? 'Mid ' + st.midRateV.toFixed(0) + '%' : ''), 
                                        st.threeRateV > 0 && e('div', { className: 'shot-segment shot-three', style: { width: st.threeRateV + '%' }}, st.threeRateV >= 15 ? '3PT ' + st.threeRateV.toFixed(0) + '%' : '')
                                    ),
                                    e('div', { className: 'grid-3', style: { marginTop: '16px' }},
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.rimPctV) : '', style: { padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '11px', opacity: 0.8 }}, 'Rim'),
                                            e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, st.rimPctV.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.rimPctV }),
                                            e('div', { style: { fontSize: '11px', opacity: 0.7 }}, Math.round(st.rimMV) + '/' + Math.round(st.rimAV)),
                                            e('div', { style: { fontSize: '10px', color: '#a78bfa', marginTop: '4px' }}, st.rimVolV.toFixed(1) + '/100')
                                        ),
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.midPctV) : '', style: { padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '11px', opacity: 0.8 }}, 'Mid'),
                                            e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, st.midPctV.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.midPctV }),
                                            e('div', { style: { fontSize: '11px', opacity: 0.7 }}, Math.round(st.midMV) + '/' + Math.round(st.midAV)),
                                            e('div', { style: { fontSize: '10px', color: '#a78bfa', marginTop: '4px' }}, st.midVolV.toFixed(1) + '/100')
                                        ),
                                        e('div', { className: hasPcts ? getPerfFromPct(grPcts.threePctV) : '', style: { padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '11px', opacity: 0.8 }}, '3PT'),
                                            e('div', { style: { fontSize: '20px', fontWeight: 'bold' }}, st.threePctV.toFixed(1) + '%'),
                                            hasPcts && e(Pct, { val: grPcts.threePctV }),
                                            e('div', { style: { fontSize: '11px', opacity: 0.7 }}, Math.round(st.threeMV) + '/' + Math.round(st.threeAV)),
                                            e('div', { style: { fontSize: '10px', color: '#a78bfa', marginTop: '4px' }}, st.threeVolV.toFixed(1) + '/100')
                                        )
                                    )
                                )
                            )
                        ),
                        // Turnovers
                        e('div', { className: 'section' },
                            e('h2', { className: 'section-title' }, '🔄 Turnovers'),
                            e('div', { className: 'grid-2' },
                                // Committed
                                e('div', { style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '8px', padding: '16px' }},
                                    e('h3', { style: { color: '#f87171', marginBottom: '12px' }}, 'Committed (' + Math.round(st.tTo) + ')'),
                                    (() => {
                                        const pR = st.tTo > 0 ? (st.passTo / st.tTo) * 100 : 0;
                                        const dR = st.tTo > 0 ? (st.dribTo / st.tTo) * 100 : 0;
                                        const dfR = st.tTo > 0 ? (st.defTo / st.tTo) * 100 : 0;
                                        const mR = st.tTo > 0 ? (st.miscTo / st.tTo) * 100 : 0;
                                        return [
                                            e('div', { key: 'bar', className: 'shot-dist-bar', style: { height: '32px' }}, 
                                                pR > 0 && e('div', { className: 'shot-segment', style: { width: pR + '%', background: '#ef4444' }}, pR >= 15 ? pR.toFixed(0) + '%' : ''), 
                                                dR > 0 && e('div', { className: 'shot-segment', style: { width: dR + '%', background: '#f97316' }}, dR >= 15 ? dR.toFixed(0) + '%' : ''), 
                                                dfR > 0 && e('div', { className: 'shot-segment', style: { width: dfR + '%', background: '#eab308' }}, dfR >= 15 ? dfR.toFixed(0) + '%' : ''), 
                                                mR > 0 && e('div', { className: 'shot-segment', style: { width: mR + '%', background: '#6b7280' }}, mR >= 15 ? mR.toFixed(0) + '%' : '')
                                            ),
                                            e('div', { key: 'breakdown', className: 'to-breakdown' }, 
                                                e('div', { className: 'to-segment', style: { background: 'rgba(239,68,68,0.3)', border: '1px solid rgba(239,68,68,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Pass'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(st.passTo))), 
                                                e('div', { className: 'to-segment', style: { background: 'rgba(249,115,22,0.3)', border: '1px solid rgba(249,115,22,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Dribble'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(st.dribTo))), 
                                                e('div', { className: 'to-segment', style: { background: 'rgba(234,179,8,0.3)', border: '1px solid rgba(234,179,8,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Defense'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(st.defTo))), 
                                                e('div', { className: 'to-segment', style: { background: 'rgba(107,114,128,0.3)', border: '1px solid rgba(107,114,128,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Misc'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(st.miscTo)))
                                            )
                                        ];
                                    })()
                                ),
                                // Forced
                                e('div', { style: { background: 'rgba(34, 197, 94, 0.1)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '8px', padding: '16px' }},
                                    e('h3', { style: { color: '#4ade80', marginBottom: '12px' }}, 'Forced (' + Math.round(st.tToV) + ')'),
                                    (() => {
                                        const pRV = st.tToV > 0 ? (st.passToV / st.tToV) * 100 : 0;
                                        const dRV = st.tToV > 0 ? (st.dribToV / st.tToV) * 100 : 0;
                                        const dfRV = st.tToV > 0 ? (st.defToV / st.tToV) * 100 : 0;
                                        const mRV = st.tToV > 0 ? (st.miscToV / st.tToV) * 100 : 0;
                                        return [
                                            e('div', { key: 'bar', className: 'shot-dist-bar', style: { height: '32px' }}, 
                                                pRV > 0 && e('div', { className: 'shot-segment', style: { width: pRV + '%', background: '#22c55e' }}, pRV >= 15 ? pRV.toFixed(0) + '%' : ''), 
                                                dRV > 0 && e('div', { className: 'shot-segment', style: { width: dRV + '%', background: '#84cc16' }}, dRV >= 15 ? dRV.toFixed(0) + '%' : ''), 
                                                dfRV > 0 && e('div', { className: 'shot-segment', style: { width: dfRV + '%', background: '#facc15' }}, dfRV >= 15 ? dfRV.toFixed(0) + '%' : ''), 
                                                mRV > 0 && e('div', { className: 'shot-segment', style: { width: mRV + '%', background: '#9ca3af' }}, mRV >= 15 ? mRV.toFixed(0) + '%' : '')
                                            ),
                                            e('div', { key: 'breakdown', className: 'to-breakdown' }, 
                                                e('div', { className: 'to-segment', style: { background: 'rgba(34,197,94,0.3)', border: '1px solid rgba(34,197,94,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Pass'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(st.passToV))), 
                                                e('div', { className: 'to-segment', style: { background: 'rgba(132,204,22,0.3)', border: '1px solid rgba(132,204,22,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Dribble'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(st.dribToV))), 
                                                e('div', { className: 'to-segment', style: { background: 'rgba(250,204,21,0.3)', border: '1px solid rgba(250,204,21,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Defense'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(st.defToV))), 
                                                e('div', { className: 'to-segment', style: { background: 'rgba(156,163,175,0.3)', border: '1px solid rgba(156,163,175,0.6)' }}, e('div', { style: { fontSize: '11px' }}, 'Misc'), e('div', { style: { fontSize: '18px', fontWeight: 'bold' }}, Math.round(st.miscToV)))
                                            )
                                        ];
                                    })()
                                )
                            )
                        ),
                        // Playmaking Stats
                        e('div', { className: 'section' },
                            e('h2', { className: 'section-title' }, '🏀 Playmaking & Defense'),
                            e('div', { className: 'stats-grid' },
                                e('div', { className: hasPcts ? getPerfFromPct(grPcts.astPct) : 'stat-card', style: { padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                    e('div', { className: 'stat-label' }, 'AST%'),
                                    e('div', { className: 'stat-value' }, st.astPct.toFixed(1) + '%'),
                                    hasPcts && e(Pct, { val: grPcts.astPct })
                                ),
                                e('div', { className: hasPcts ? getPerfFromPct(grPcts.stlPct) : 'stat-card', style: { padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                    e('div', { className: 'stat-label' }, 'STL%'),
                                    e('div', { className: 'stat-value' }, st.stlPct.toFixed(1) + '%'),
                                    hasPcts && e(Pct, { val: grPcts.stlPct })
                                ),
                                e('div', { className: hasPcts ? getPerfFromPct(grPcts.blkPct) : 'stat-card', style: { padding: '12px', borderRadius: '8px', textAlign: 'center' }},
                                    e('div', { className: 'stat-label' }, 'BLK%'),
                                    e('div', { className: 'stat-value' }, st.blkPct.toFixed(1) + '%'),
                                    hasPcts && e(Pct, { val: grPcts.blkPct })
                                )
                            )
                        ),
                        // Games included table
                        e('div', { className: 'section' },
                            e('h2', { className: 'section-title' }, 'Games Included (' + gameRangeResults.selectedGames.length + ')'),
                            e('p', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '12px' }}, 
                                'Games are shown in row order (order of first appearance in stints.csv)'
                            ),
                            e('div', { style: { overflowX: 'auto', maxHeight: '300px', overflowY: 'auto' }},
                                e('table', null,
                                    e('thead', null,
                                        e('tr', null,
                                            e('th', { style: { width: '50px' }}, '#'),
                                            e('th', null, 'Game #'),
                                            e('th', null, 'Date'),
                                            e('th', null, 'Result'),
                                            e('th', null, 'Score'),
                                            e('th', null, 'Opponent'),
                                            e('th', null, 'Location')
                                        )
                                    ),
                                    e('tbody', null,
                                        gameRangeResults.selectedGames.map((g, i) => 
                                            e('tr', { key: g.gameId },
                                                e('td', { style: { fontWeight: 'bold', color: '#60a5fa' }}, (i + 1) + '.'),
                                                e('td', { style: { color: '#94a3b8' }}, 'Game ' + g.gameNumber),
                                                e('td', { style: { color: '#a78bfa', fontSize: '11px' }}, g.gameDate || '-'),
                                                e('td', null, g.isWin ? 
                                                    e('span', { style: { color: '#4ade80', fontWeight: 'bold' }}, '✓ W') : 
                                                    e('span', { style: { color: '#f87171', fontWeight: 'bold' }}, '✗ L')
                                                ),
                                                e('td', { style: { fontFamily: 'monospace', fontWeight: 'bold', color: g.isWin ? '#4ade80' : '#f87171' }}, 
                                                    g.teamPts + '-' + g.oppPts
                                                ),
                                                e('td', null, g.opponent),
                                                e('td', null, g.isHome ? 
                                                    e('span', { style: { color: '#4ade80' }}, '🏠 Home') : 
                                                    e('span', { style: { color: '#f97316' }}, '✈️ Away')
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    );
                    })(),
                    // Error message
                    gameRangeResults && gameRangeResults.error && e('div', { 
                        className: 'section', 
                        style: { background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)' }
                    },
                        e('div', { style: { textAlign: 'center', padding: '40px', color: '#f87171' }},
                            e('div', { style: { fontSize: '32px', marginBottom: '12px' }}, '⚠️'),
                            e('div', { style: { fontSize: '16px' }}, gameRangeResults.error)
                        )
                    ),
                    // No team selected placeholder
                    !gameRangeTeam && e('div', { 
                        className: 'section',
                        style: { textAlign: 'center', padding: '60px', color: '#64748b' }
                    },
                        e('div', { style: { fontSize: '48px', marginBottom: '16px' }}, '📅'),
                        e('div', { style: { fontSize: '18px', fontWeight: '600', marginBottom: '8px' }}, 'Select a Team to Begin'),
                        e('div', { style: { fontSize: '14px' }}, 'Choose a team from the dropdown to see available games and analyze specific game ranges.')
                    )
                ),
                
                // V5.0: Export View Tab Content
                activeTab === 'export' && lineupData.length > 0 && e('div', null,
                    e('div', { className: 'dataset-info', style: { marginBottom: '24px', background: 'linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(217, 119, 6, 0.1))', border: '2px solid rgba(245, 158, 11, 0.4)' }},
                        e('strong', null, '📸 Social Media Export View'),
                        e('div', { style: { marginTop: '8px', fontSize: '13px', opacity: 0.9 }},
                            'Generate beautiful, screenshot-ready graphics for social media. Choose from Leaderboards, Team Four Factors, Shot Distribution, Best Lineups, or WOWY analysis.'
                        ),
                        e('div', { style: { marginTop: '8px', fontSize: '11px', opacity: 0.7 }},
                            '• Use filters to customize data • Take a screenshot of the export frame for Instagram, Twitter, etc.',
                            e('br'),
                            '• All graphics are optimized for social media posting with professional styling'
                        )
                    ),
                    
                    // Export Mode Tabs
                    e('div', { className: 'export-mode-tabs' },
                        e('button', { 
                            className: 'export-mode-tab' + (exportMode === 'leaderboard' ? ' active' : ''),
                            onClick: () => { setExportMode('leaderboard'); setExportTitle('Player Leaderboard'); setExportSubtitle('Advanced Analytics'); }
                        }, '🏆 Leaderboard'),
                        e('button', { 
                            className: 'export-mode-tab' + (exportMode === 'chart' ? ' active' : ''),
                            onClick: () => { setExportMode('chart'); setExportTitle(exportChartTitle); setExportSubtitle('Player Comparison Chart'); }
                        }, '📈 Chart'),
                        e('button', { 
                            className: 'export-mode-tab' + (exportMode === 'fourfactors' ? ' active' : ''),
                            onClick: () => { setExportMode('fourfactors'); setExportTitle('Team Four Factors'); setExportSubtitle('Offensive & Defensive Efficiency'); }
                        }, '📊 Four Factors'),
                        e('button', { 
                            className: 'export-mode-tab' + (exportMode === 'shotdist' ? ' active' : ''),
                            onClick: () => { setExportMode('shotdist'); setExportTitle('Shot Distribution'); setExportSubtitle('Rim • Mid-Range • Three-Point'); }
                        }, '🎯 Shot Distribution'),
                        e('button', { 
                            className: 'export-mode-tab' + (exportMode === 'lineups' ? ' active' : ''),
                            onClick: () => { setExportMode('lineups'); setExportTitle('Best Lineups'); setExportSubtitle('Top Performing Combinations'); }
                        }, '👥 Best Lineups'),
                        e('button', { 
                            className: 'export-mode-tab' + (exportMode === 'wowy' ? ' active' : ''),
                            onClick: () => { setExportMode('wowy'); setExportTitle('Player Impact'); setExportSubtitle('With Or Without You Analysis'); }
                        }, '🔄 WOWY'),
                        e('button', { 
                            className: 'export-mode-tab' + (exportMode === 'sos' ? ' active' : ''),
                            onClick: () => { setExportMode('sos'); setExportTitle('League Standings'); setExportSubtitle('Adjusted Ratings & Strength of Schedule'); }
                        }, '📈 SOS')
                    ),
                    
                    // Export Controls
                    e('div', { className: 'export-controls' },
                        e('div', { className: 'export-control-group' },
                            e('label', null, 'Title'),
                            e('input', { 
                                type: 'text', 
                                value: exportTitle, 
                                onChange: ev => setExportTitle(ev.target.value),
                                style: { minWidth: '200px' }
                            })
                        ),
                        e('div', { className: 'export-control-group' },
                            e('label', null, 'Subtitle'),
                            e('input', { 
                                type: 'text', 
                                value: exportSubtitle, 
                                onChange: ev => setExportSubtitle(ev.target.value),
                                style: { minWidth: '180px' }
                            })
                        ),
                        
                        // Mode-specific controls
                        exportMode === 'leaderboard' && e(React.Fragment, null,
                            // Individual vs On/Off Toggle
                            e('div', { className: 'export-toggle-container' },
                                e('span', { className: 'export-toggle-label' + (!exportUseOnOff ? ' active' : '') }, 'Individual'),
                                e('div', { 
                                    className: 'export-toggle' + (exportUseOnOff ? ' active' : ''),
                                    onClick: () => setExportUseOnOff(!exportUseOnOff)
                                }),
                                e('span', { className: 'export-toggle-label' + (exportUseOnOff ? ' active' : '') }, 'On/Off')
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Sort By'),
                                e('select', { 
                                    value: exportStat, 
                                    onChange: ev => setExportStat(ev.target.value)
                                },
                                    // Individual stats (only show when in individual mode) - per 75 possessions
                                    // Uses same stat names as leaderboard individual tab
                                    !exportUseOnOff && e('optgroup', { label: 'Usage' },
                                        e('option', { value: 'usage' }, 'Usage %')
                                    ),
                                    !exportUseOnOff && e('optgroup', { label: 'Box Score' },
                                        e('option', { value: 'pts75' }, 'PTS/75'),
                                        e('option', { value: 'reb75' }, 'REB/75'),
                                        e('option', { value: 'oreb75' }, 'OREB/75'),
                                        e('option', { value: 'dreb75' }, 'DREB/75'),
                                        e('option', { value: 'ast75' }, 'AST/75'),
                                        e('option', { value: 'astUsgRatio' }, 'AST/USG'),
                                        e('option', { value: 'stl75' }, 'STL/75'),
                                        e('option', { value: 'blk75' }, 'BLK/75'),
                                        e('option', { value: 'tov75' }, 'TOV/75')
                                    ),
                                    !exportUseOnOff && e('optgroup', { label: 'Shooting' },
                                        e('option', { value: 'tsPct' }, 'TS%'),
                                        e('option', { value: 'rimPct' }, 'RIM %'),
                                        e('option', { value: 'midPct' }, 'MID %'),
                                        e('option', { value: 'threePct' }, '3PT %')
                                    ),
                                    !exportUseOnOff && e('optgroup', { label: 'Shot Volume' },
                                        e('option', { value: 'rimA75' }, 'RIM ATT/75'),
                                        e('option', { value: 'midA75' }, 'MID ATT/75'),
                                        e('option', { value: 'threeA75' }, '3PT ATT/75')
                                    ),
                                    !exportUseOnOff && e('optgroup', { label: 'Playmaking' },
                                        e('option', { value: 'tpc75' }, 'TPC/75'),
                                        e('option', { value: 'playerAstPct' }, 'AST%')
                                    ),
                                    !exportUseOnOff && e('optgroup', { label: 'Turnovers' },
                                        e('option', { value: 'passTo' }, 'Pass TOs'),
                                        e('option', { value: 'dribTo' }, 'Dribble TOs')
                                    ),
                                    !exportUseOnOff && e('optgroup', { label: 'Scoring' },
                                        e('option', { value: 'ptsAst75' }, 'PTS AST/75'),
                                        e('option', { value: 'secChancePts75' }, '2nd Chance PTS/75'),
                                        e('option', { value: 'fastBreakPts75' }, 'Fast Break PTS/75'),
                                        e('option', { value: 'clutchPts75' }, 'Clutch PTS/75')
                                    ),
                                    !exportUseOnOff && e('optgroup', { label: 'Box Plus/Minus' },
                                        e('option', { value: 'bpm' }, 'BPM'),
                                        e('option', { value: 'obpm' }, 'OBPM'),
                                        e('option', { value: 'dbpm' }, 'DBPM')
                                    ),
                                    !exportUseOnOff && e('optgroup', { label: 'Bayesian Box APM' },
                                        e('option', { value: 'apm' }, '🔮 APM'),
                                        e('option', { value: 'oapm' }, '🔮 OAPM'),
                                        e('option', { value: 'dapm' }, '🔮 DAPM')
                                    ),
                                    // On/Off stats (only show when in on-off mode)
                                    exportUseOnOff && e('optgroup', { label: 'Ratings' },
                                        e('option', { value: 'net' }, 'Net Rating'),
                                        e('option', { value: 'off' }, 'Offensive Rating'),
                                        e('option', { value: 'def' }, 'Defensive Rating')
                                    ),
                                    exportUseOnOff && e('optgroup', { label: 'Box Plus/Minus' },
                                        e('option', { value: 'bpm' }, 'BPM (Box Plus/Minus)'),
                                        e('option', { value: 'obpm' }, 'OBPM (Offensive)'),
                                        e('option', { value: 'dbpm' }, 'DBPM (Defensive)')
                                    ),
                                    exportUseOnOff && playerApmStats && playerApmStats.players && e('optgroup', { label: '🔮 Bayesian Box APM' },
                                        e('option', { value: 'apm' }, '🔮 APM (BPM + RAPM)'),
                                        e('option', { value: 'oapm' }, '🔮 OAPM (Offensive)'),
                                        e('option', { value: 'dapm' }, '🔮 DAPM (Defensive)')
                                    ),
                                    exportUseOnOff && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg && e('optgroup', { label: 'RAPM' },
                                        e('option', { value: 'rapm' }, 'RAPM (Reg. Adj. +/-)'),
                                        e('option', { value: 'orapm' }, 'ORAPM (Offensive)'),
                                        e('option', { value: 'drapm' }, 'DRAPM (Defensive)')
                                    ),
                                    exportUseOnOff && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.eFG && e('optgroup', { label: 'Single-Stat RAPM (Offensive)' },
                                        e('option', { value: 'rapmOffEfg' }, 'RAPM Off eFG%'),
                                        e('option', { value: 'rapmOffTov' }, 'RAPM Off TOV%'),
                                        e('option', { value: 'rapmOffOreb' }, 'RAPM Off OREB%'),
                                        e('option', { value: 'rapmOffFtr' }, 'RAPM Off FT Rate'),
                                        e('option', { value: 'rapmOffAst' }, 'RAPM Off AST%')
                                    ),
                                    exportUseOnOff && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.eFG && e('optgroup', { label: 'Single-Stat RAPM (Defensive)' },
                                        e('option', { value: 'rapmDefEfg' }, 'RAPM Def eFG%'),
                                        e('option', { value: 'rapmDefTov' }, 'RAPM Def TOV%'),
                                        e('option', { value: 'rapmDefOreb' }, 'RAPM Def OREB%'),
                                        e('option', { value: 'rapmDefFtr' }, 'RAPM Def FT Rate'),
                                        e('option', { value: 'rapmStl' }, 'RAPM STL%'),
                                        e('option', { value: 'rapmBlk' }, 'RAPM BLK%')
                                    ),
                                    exportUseOnOff && e('optgroup', { label: 'Combined Impact (Z-Score)' },
                                        e('option', { value: 'fourFactorsImpact' }, '⚡ Four Factors Impact'),
                                        e('option', { value: 'scoringBattleImpact' }, '🎯 Scoring Battle Impact'),
                                        e('option', { value: 'possBattleImpact' }, '🔄 Possession Battle Impact')
                                    ),
                                    exportUseOnOff && e('optgroup', { label: 'Teammate Impact' },
                                        e('option', { value: 'bpmImpactCombos' }, '👥 BPM Impact Combos'),
                                        e('option', { value: 'bpmImpactZScore' }, '📉 BPM Impact Z-Score'),
                                        e('option', { value: 'perImpactCombos' }, '📊 PER Impact Combos'),
                                        e('option', { value: 'perImpactZScore' }, '📉 PER Impact Z-Score')
                                    ),
                                    exportUseOnOff && e('optgroup', { label: 'Four Factors (Off)' },
                                        e('option', { value: 'offEfg' }, 'Off eFG%'),
                                        e('option', { value: 'offTov' }, 'Off TOV%'),
                                        e('option', { value: 'offOreb' }, 'Off OREB%'),
                                        e('option', { value: 'offFtR' }, 'Off FT Rate')
                                    ),
                                    exportUseOnOff && e('optgroup', { label: 'Four Factors (Def)' },
                                        e('option', { value: 'defEfg' }, 'Def eFG% (Allowed)'),
                                        e('option', { value: 'defTov' }, 'Def TOV% (Forced)'),
                                        e('option', { value: 'defOreb' }, 'Def OREB% (Allowed)'),
                                        e('option', { value: 'defFtR' }, 'Def FT Rate (Allowed)')
                                    ),
                                    // Shared stats (both modes)
                                    e('optgroup', { label: 'Shot Making' },
                                        e('option', { value: 'rimPct' }, 'Rim %'),
                                        e('option', { value: 'midPct' }, 'Mid %'),
                                        e('option', { value: 'threePct' }, '3PT %')
                                    ),
                                    exportUseOnOff && e('optgroup', { label: 'Shot Volume (Off)' },
                                        e('option', { value: 'rimVol' }, 'Rim Vol/100'),
                                        e('option', { value: 'midVol' }, 'Mid Vol/100'),
                                        e('option', { value: 'threeVol' }, '3PT Vol/100')
                                    ),
                                    exportUseOnOff && e('optgroup', { label: 'Shot Volume Allowed (Def)' },
                                        e('option', { value: 'rimVolV' }, 'Def Rim Vol/100'),
                                        e('option', { value: 'midVolV' }, 'Def Mid Vol/100'),
                                        e('option', { value: 'threeVolV' }, 'Def 3PT Vol/100')
                                    ),
                                    e('optgroup', { label: 'Playmaking & Defense' },
                                        e('option', { value: 'astPct' }, 'AST%'),
                                        e('option', { value: 'stlPct' }, 'STL%'),
                                        e('option', { value: 'blkPct' }, 'BLK%')
                                    ),
                                    exportUseOnOff && e('optgroup', { label: 'Pace' },
                                        e('option', { value: 'paceF' }, 'Offensive Pace'),
                                        e('option', { value: 'paceV' }, 'Defensive Pace')
                                    )
                                )
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Order'),
                                e('select', { 
                                    value: exportSortAsc ? 'asc' : 'desc', 
                                    onChange: ev => setExportSortAsc(ev.target.value === 'asc')
                                },
                                    e('option', { value: 'desc' }, 'Best → Worst'),
                                    e('option', { value: 'asc' }, 'Worst → Best')
                                )
                            ),
                            // Luck adjustment sliders for On/Off mode - Offense
                            exportUseOnOff && e('div', { className: 'export-control-group', style: { minWidth: '120px' }},
                                e('label', null, '🎲 Off Luck'),
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                    e('input', { 
                                        type: 'range', 
                                        min: 0, 
                                        max: 100, 
                                        value: exportOffLuckAdj, 
                                        onChange: ev => setExportOffLuckAdj(parseInt(ev.target.value)),
                                        style: { width: '60px' }
                                    }),
                                    e('span', { style: { fontSize: '10px', color: exportOffLuckAdj > 0 ? '#4ade80' : '#64748b', minWidth: '28px' }}, exportOffLuckAdj + '%')
                                )
                            ),
                            // Luck adjustment sliders for On/Off mode - Defense
                            exportUseOnOff && e('div', { className: 'export-control-group', style: { minWidth: '120px' }},
                                e('label', null, '🎲 Def Luck'),
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                    e('input', { 
                                        type: 'range', 
                                        min: 0, 
                                        max: 100, 
                                        value: exportDefLuckAdj, 
                                        onChange: ev => setExportDefLuckAdj(parseInt(ev.target.value)),
                                        style: { width: '60px' }
                                    }),
                                    e('span', { style: { fontSize: '10px', color: exportDefLuckAdj > 0 ? '#f87171' : '#64748b', minWidth: '28px' }}, exportDefLuckAdj + '%')
                                )
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Team Filter'),
                                e('select', { 
                                    value: exportTeam, 
                                    onChange: ev => setExportTeam(ev.target.value)
                                },
                                    e('option', { value: '' }, 'All Teams'),
                                    teams.map(t => e('option', { key: t, value: t }, t))
                                )
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, exportUseOnOff ? 'Min ON Mins' : 'Min Mins'),
                                e('input', { 
                                    type: 'number', 
                                    value: exportMinMins, 
                                    onChange: ev => setExportMinMins(parseInt(ev.target.value) || 0),
                                    min: 0,
                                    style: { width: '80px' }
                                })
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Top N'),
                                e('input', { 
                                    type: 'number', 
                                    value: exportTopN, 
                                    onChange: ev => setExportTopN(parseInt(ev.target.value) || 10),
                                    min: 1,
                                    max: 30,
                                    style: { width: '60px' }
                                })
                            ),
                            // V5.5: Relative stats toggle (only for on-off mode)
                            exportUseOnOff && e('div', { className: 'export-toggle-container' },
                                e('span', { className: 'export-toggle-label' + (!exportShowRelative ? ' active' : '') }, 'Raw'),
                                e('div', { 
                                    className: 'export-toggle' + (exportShowRelative ? ' active' : ''),
                                    onClick: () => setExportShowRelative(!exportShowRelative)
                                }),
                                e('span', { className: 'export-toggle-label' + (exportShowRelative ? ' active' : '') }, '+/- Avg')
                            ),
                            // V5.7: RAPM calculation button for leaderboard with lambda control
                            exportUseOnOff && e('div', { className: 'export-control-group', style: { marginLeft: '12px', display: 'flex', alignItems: 'center', gap: '8px' }},
                                // Lambda input
                                stintsData.length > 0 && e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                    e('label', { style: { fontSize: '10px', color: '#94a3b8' }}, 'λ:'),
                                    e('input', {
                                        type: 'number',
                                        value: rapmLambda,
                                        onChange: ev => setRapmLambda(Math.max(1, parseInt(ev.target.value) || 800)),
                                        style: { width: '60px', padding: '4px 6px', fontSize: '10px', background: '#0f172a', border: '1px solid #475569', borderRadius: '4px', color: 'white' }
                                    })
                                ),
                                // Status/Calculate button
                                playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg 
                                    ? e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' }},
                                        e('span', { style: { fontSize: '10px', color: '#4ade80' }}, '✓ RAPM (λ=' + (playerRapmStats.lambda || rapmLambda) + ')'),
                                        e('button', {
                                            style: { padding: '4px 8px', fontSize: '10px', background: rapmLambda !== playerRapmStats.lambda ? '#7c3aed' : '#1e293b', border: '1px solid #475569', borderRadius: '4px', color: rapmLambda !== playerRapmStats.lambda ? 'white' : '#94a3b8', cursor: 'pointer' },
                                            onClick: triggerPlayerRAPMCalculation
                                        }, rapmLambda !== playerRapmStats.lambda ? '⚡ Recalc' : '↻ Recalc')
                                    )
                                    : isCalculatingPlayerRAPM 
                                        ? e('span', { style: { fontSize: '11px', color: '#60a5fa' }}, '⏳ ' + playerRapmProgress + '%')
                                        : stintsData.length > 0 
                                            ? e('button', {
                                                style: { padding: '6px 12px', fontSize: '11px', background: 'linear-gradient(135deg, #3b82f6, #2563eb)', border: 'none', borderRadius: '6px', color: 'white', cursor: 'pointer', fontWeight: '600' },
                                                onClick: triggerPlayerRAPMCalculation
                                            }, '📊 Calculate RAPM')
                                            : e('span', { style: { fontSize: '11px', color: '#64748b' }}, 'Upload stints.csv for RAPM')
                            ),
                            // V5.12: APM calculation button (requires RAPM to be calculated first)
                            exportUseOnOff && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg && e('div', { className: 'export-control-group', style: { display: 'flex', alignItems: 'center', gap: '6px' }},
                                playerApmStats && playerApmStats.players 
                                    ? e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' }},
                                        e('span', { style: { fontSize: '10px', color: '#a78bfa' }}, '✓ 🔮 APM (λ=' + (playerApmStats.lambda || rapmLambda) + ')'),
                                        e('button', {
                                            style: { padding: '4px 8px', fontSize: '10px', background: rapmLambda !== playerApmStats.lambda ? '#8b5cf6' : '#1e293b', border: '1px solid #6d28d9', borderRadius: '4px', color: rapmLambda !== playerApmStats.lambda ? 'white' : '#a78bfa', cursor: 'pointer' },
                                            onClick: triggerAPMCalculation
                                        }, rapmLambda !== playerApmStats.lambda ? '⚡ Recalc' : '↻ Recalc')
                                    )
                                    : isCalculatingAPM 
                                        ? e('span', { style: { fontSize: '11px', color: '#a78bfa' }}, '🔮 ' + apmProgress + '%')
                                        : seasonStatsMap.size > 0 
                                            ? e('button', {
                                                style: { padding: '6px 12px', fontSize: '11px', background: 'linear-gradient(135deg, #8b5cf6, #7c3aed)', border: 'none', borderRadius: '6px', color: 'white', cursor: 'pointer', fontWeight: '600' },
                                                onClick: triggerAPMCalculation
                                            }, '🔮 Calculate APM')
                                            : e('span', { style: { fontSize: '10px', color: '#64748b' }}, 'Upload season stats for APM')
                            ),
                            // V5.2: Secondary stats toggle
                            e('div', { className: 'export-toggle-container' },
                                e('span', { className: 'export-toggle-label' + (!exportShowSecondary ? ' active' : '') }, 'Main Only'),
                                e('div', { 
                                    className: 'export-toggle' + (exportShowSecondary ? ' active' : ''),
                                    onClick: () => setExportShowSecondary(!exportShowSecondary)
                                }),
                                e('span', { className: 'export-toggle-label' + (exportShowSecondary ? ' active' : '') }, '+ Secondary')
                            )
                        ),
                        // V5.6: Secondary stats selection with count selector and mode-specific stats
                        exportMode === 'leaderboard' && exportShowSecondary && e('div', { style: { marginTop: '12px', padding: '12px', background: 'rgba(15, 23, 42, 0.5)', borderRadius: '8px' }},
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '10px' }},
                                e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Secondary Stats:'),
                                e('select', { 
                                    value: exportSecondaryCount,
                                    onChange: ev => setExportSecondaryCount(parseInt(ev.target.value)),
                                    style: { padding: '4px 8px', fontSize: '11px', background: '#0f172a', border: '1px solid #475569', borderRadius: '4px', color: 'white' }
                                },
                                    [1,2,3,4,5,6,7,8,9,10].map(n => e('option', { key: n, value: n }, n + ' stat' + (n > 1 ? 's' : '')))
                                ),
                                e('button', {
                                    onClick: () => {
                                        setExportSecondaryStats(exportUseOnOff 
                                            ? ['offEfg', 'defEfg', 'offTov', 'defTov', 'offOreb', 'defOreb', 'offFtR', 'defFtR', 'paceF', 'poss']
                                            : ['ppg', 'rpg', 'apg', 'spg', 'fgPct', 'threePct', 'ftPct', 'usg', 'astPct', 'per']
                                        );
                                        setExportSecondaryCount(4);
                                    },
                                    style: { padding: '3px 8px', fontSize: '10px', background: '#374151', border: '1px solid #4b5563', borderRadius: '4px', color: '#94a3b8', cursor: 'pointer' }
                                }, '↺ Reset')
                            ),
                            e('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' }},
                                [...Array(exportSecondaryCount)].map((_, idx) => {
                                    // Mode-specific stats
                                    const individualStats = [
                                        { value: '', label: '-- None --', group: '' },
                                        // Usage
                                        { value: 'usage', label: 'Usage %', group: 'Usage' },
                                        // Box Score
                                        { value: 'pts75', label: 'PTS/75', group: 'Box Score' },
                                        { value: 'reb75', label: 'REB/75', group: 'Box Score' },
                                        { value: 'oreb75', label: 'OREB/75', group: 'Box Score' },
                                        { value: 'dreb75', label: 'DREB/75', group: 'Box Score' },
                                        { value: 'ast75', label: 'AST/75', group: 'Box Score' },
                                        { value: 'astUsgRatio', label: 'AST/USG', group: 'Box Score' },
                                        { value: 'stl75', label: 'STL/75', group: 'Box Score' },
                                        { value: 'blk75', label: 'BLK/75', group: 'Box Score' },
                                        { value: 'tov75', label: 'TOV/75', group: 'Box Score' },
                                        // Shooting
                                        { value: 'tsPct', label: 'TS%', group: 'Shooting' },
                                        { value: 'rimPct', label: 'RIM %', group: 'Shooting' },
                                        { value: 'midPct', label: 'MID %', group: 'Shooting' },
                                        { value: 'threePct', label: '3PT %', group: 'Shooting' },
                                        // Shot Volume
                                        { value: 'rimA75', label: 'RIM ATT/75', group: 'Shot Volume' },
                                        { value: 'midA75', label: 'MID ATT/75', group: 'Shot Volume' },
                                        { value: 'threeA75', label: '3PT ATT/75', group: 'Shot Volume' },
                                        // Playmaking
                                        { value: 'tpc75', label: 'TPC/75', group: 'Playmaking' },
                                        { value: 'playerAstPct', label: 'AST%', group: 'Playmaking' },
                                        // Turnovers
                                        { value: 'passTo', label: 'Pass TOs', group: 'Turnovers' },
                                        { value: 'dribTo', label: 'Dribble TOs', group: 'Turnovers' },
                                        // Scoring
                                        { value: 'ptsAst75', label: 'PTS AST/75', group: 'Scoring' },
                                        { value: 'secChancePts75', label: '2nd Chance PTS/75', group: 'Scoring' },
                                        { value: 'fastBreakPts75', label: 'Fast Break PTS/75', group: 'Scoring' },
                                        { value: 'clutchPts75', label: 'Clutch PTS/75', group: 'Scoring' },
                                        // Box Plus/Minus
                                        { value: 'bpm', label: 'BPM', group: 'Box Plus/Minus' },
                                        { value: 'obpm', label: 'OBPM', group: 'Box Plus/Minus' },
                                        { value: 'dbpm', label: 'DBPM', group: 'Box Plus/Minus' },
                                        // Bayesian Box APM
                                        { value: 'apm', label: '🔮 APM', group: 'Bayesian Box APM' },
                                        { value: 'oapm', label: '🔮 OAPM', group: 'Bayesian Box APM' },
                                        { value: 'dapm', label: '🔮 DAPM', group: 'Bayesian Box APM' }
                                    ];
                                    const onOffStats = [
                                        { value: '', label: '-- None --', group: '' },
                                        // Ratings
                                        { value: 'net', label: 'Net Rtg', group: 'Ratings' },
                                        { value: 'off', label: 'Off Rtg', group: 'Ratings' },
                                        { value: 'def', label: 'Def Rtg', group: 'Ratings' },
                                        // Combined Impact
                                        { value: 'fourFactorsImpact', label: '⚡ FF Impact', group: 'Combined Impact' },
                                        { value: 'scoringBattleImpact', label: '🎯 Scoring Impact', group: 'Combined Impact' },
                                        { value: 'possBattleImpact', label: '🔄 Poss Impact', group: 'Combined Impact' },
                                        // Four Factors (Off)
                                        { value: 'offEfg', label: 'Off eFG%', group: 'Four Factors (Off)' },
                                        { value: 'offTov', label: 'Off TOV%', group: 'Four Factors (Off)' },
                                        { value: 'offOreb', label: 'Off OREB%', group: 'Four Factors (Off)' },
                                        { value: 'offFtR', label: 'Off FT Rate', group: 'Four Factors (Off)' },
                                        // Four Factors (Def)
                                        { value: 'defEfg', label: 'Def eFG%', group: 'Four Factors (Def)' },
                                        { value: 'defTov', label: 'Def TOV% (Forced)', group: 'Four Factors (Def)' },
                                        { value: 'defOreb', label: 'Def OREB%', group: 'Four Factors (Def)' },
                                        { value: 'defFtR', label: 'Def FT Rate', group: 'Four Factors (Def)' },
                                        // Playmaking & Defense
                                        { value: 'astPct', label: 'AST%', group: 'Playmaking' },
                                        { value: 'stlPct', label: 'STL%', group: 'Defense' },
                                        { value: 'blkPct', label: 'BLK%', group: 'Defense' },
                                        // Shooting
                                        { value: 'threePct', label: '3PT%', group: 'Shooting' },
                                        { value: 'rimPct', label: 'Rim%', group: 'Shooting' },
                                        { value: 'midPct', label: 'Mid%', group: 'Shooting' },
                                        // Shot Volume (Off)
                                        { value: 'rimVol', label: 'Rim Vol/100', group: 'Shot Volume (Off)' },
                                        { value: 'midVol', label: 'Mid Vol/100', group: 'Shot Volume (Off)' },
                                        { value: 'threeVol', label: '3PT Vol/100', group: 'Shot Volume (Off)' },
                                        // Shot Volume (Def)
                                        { value: 'rimVolV', label: 'Def Rim Vol/100', group: 'Shot Volume (Def)' },
                                        { value: 'midVolV', label: 'Def Mid Vol/100', group: 'Shot Volume (Def)' },
                                        { value: 'threeVolV', label: 'Def 3PT Vol/100', group: 'Shot Volume (Def)' },
                                        // Pace
                                        { value: 'paceF', label: 'Off Pace', group: 'Pace' },
                                        { value: 'paceV', label: 'Def Pace', group: 'Pace' },
                                        // Box Plus/Minus
                                        { value: 'bpm', label: 'BPM', group: 'Box Plus/Minus' },
                                        { value: 'obpm', label: 'OBPM', group: 'Box Plus/Minus' },
                                        { value: 'dbpm', label: 'DBPM', group: 'Box Plus/Minus' },
                                        // RAPM
                                        { value: 'rapm', label: 'RAPM', group: 'RAPM' },
                                        { value: 'orapm', label: 'ORAPM', group: 'RAPM' },
                                        { value: 'drapm', label: 'DRAPM', group: 'RAPM' },
                                        // Single-Stat RAPM
                                        { value: 'rapmOffEfg', label: 'RAPM Off eFG%', group: 'Single-Stat RAPM' },
                                        { value: 'rapmDefEfg', label: 'RAPM Def eFG%', group: 'Single-Stat RAPM' },
                                        { value: 'rapmOffTov', label: 'RAPM Off TOV%', group: 'Single-Stat RAPM' },
                                        { value: 'rapmDefTov', label: 'RAPM Def TOV%', group: 'Single-Stat RAPM' },
                                        { value: 'rapmOffOreb', label: 'RAPM Off OREB%', group: 'Single-Stat RAPM' },
                                        { value: 'rapmDefOreb', label: 'RAPM Def OREB%', group: 'Single-Stat RAPM' },
                                        { value: 'rapmOffFtr', label: 'RAPM Off FTR', group: 'Single-Stat RAPM' },
                                        { value: 'rapmDefFtr', label: 'RAPM Def FTR', group: 'Single-Stat RAPM' },
                                        { value: 'rapmOffAst', label: 'RAPM Off AST%', group: 'Single-Stat RAPM' },
                                        { value: 'rapmStl', label: 'RAPM STL%', group: 'Single-Stat RAPM' },
                                        { value: 'rapmBlk', label: 'RAPM BLK%', group: 'Single-Stat RAPM' }
                                    ];
                                    const allStats = exportUseOnOff ? onOffStats : individualStats;
                                    // Group stats for optgroup display
                                    const groupedStats = allStats.reduce((acc, s) => {
                                        const grp = s.group || '';
                                        if (!acc[grp]) acc[grp] = [];
                                        acc[grp].push(s);
                                        return acc;
                                    }, {});
                                    return e('select', {
                                        key: idx,
                                        value: exportSecondaryStats[idx] || '',
                                        onChange: ev => {
                                            const newVal = ev.target.value;
                                            setExportSecondaryStats(prev => {
                                                const newArr = [...prev];
                                                if (newVal) {
                                                    newArr[idx] = newVal;
                                                } else {
                                                    newArr.splice(idx, 1);
                                                }
                                                return newArr.filter(Boolean);
                                            });
                                        },
                                        style: { padding: '5px 8px', fontSize: '10px', background: '#0f172a', border: '1px solid #475569', borderRadius: '4px', color: 'white', minWidth: '95px' }
                                    },
                                        Object.entries(groupedStats).map(([grp, opts]) =>
                                            grp === '' ? opts.map(s => e('option', { key: s.value, value: s.value }, s.label)) :
                                            e('optgroup', { key: grp, label: grp }, opts.map(s => e('option', { key: s.value, value: s.value }, s.label)))
                                        )
                                    );
                                })
                            )
                        ),
                        
                        // V5.6: Chart Tab Controls
                        exportMode === 'chart' && e('div', { style: { marginTop: '16px' }},
                            // Row 0: Data Mode Toggle (Players vs Teams)
                            e('div', { style: { display: 'flex', gap: '16px', flexWrap: 'wrap', marginBottom: '12px', alignItems: 'center' }},
                                e('div', { className: 'export-toggle-container' },
                                    e('span', { className: 'export-toggle-label' + (exportChartDataMode === 'players' ? ' active' : '') }, '👤 Players'),
                                    e('div', { 
                                        className: 'export-toggle' + (exportChartDataMode === 'teams' ? ' active' : ''),
                                        onClick: () => {
                                            const newMode = exportChartDataMode === 'players' ? 'teams' : 'players';
                                            setExportChartDataMode(newMode);
                                            // Reset axis selections to appropriate defaults for the new mode
                                            if (newMode === 'teams') {
                                                // Set to vsLg or absolute defaults based on current toggle
                                                if (exportChartAbsolute) {
                                                    setExportChartX('adjOrtg');
                                                    setExportChartY('adjDrtg');
                                                } else {
                                                    setExportChartX('adjOrtgVsLg');
                                                    setExportChartY('adjDrtgVsLg');
                                                }
                                            } else {
                                                setExportChartX('off');
                                                setExportChartY('def');
                                            }
                                        }
                                    }),
                                    e('span', { className: 'export-toggle-label' + (exportChartDataMode === 'teams' ? ' active' : '') }, '🏀 Teams')
                                ),
                                teamTotalsData.length === 0 && exportChartDataMode === 'teams' && e('span', { style: { fontSize: '11px', color: '#fbbf24' }}, '⚠️ Load team_totals.csv for team data')
                            ),
                            // Row 1: Axis selectors - Different options for players vs teams
                            e('div', { style: { display: 'flex', gap: '16px', flexWrap: 'wrap', marginBottom: '12px' }},
                                e('div', { className: 'export-control-group' },
                                    e('label', null, 'X-Axis Stat' + (exportChartDataMode === 'players' ? (exportChartAbsolute ? ' (Absolute)' : ' (ON-OFF)') : (exportChartAbsolute ? ' (Absolute)' : ' (vs. Lg Avg)'))),
                                    e('select', { 
                                        value: exportChartX, 
                                        onChange: ev => setExportChartX(ev.target.value)
                                    },
                                        // TEAMS MODE OPTIONS - changes based on Absolute vs. League Avg mode
                                        exportChartDataMode === 'teams' && exportChartAbsolute && e('optgroup', { label: '📊 Ratings (Absolute)' },
                                            e('option', { value: 'adjOrtg' }, 'Adj Off Rtg'),
                                            e('option', { value: 'adjDrtg' }, 'Adj Def Rtg'),
                                            e('option', { value: 'adjNet' }, 'Adj Net Rtg'),
                                            e('option', { value: 'rawOrtg' }, 'Raw Off Rtg'),
                                            e('option', { value: 'rawDrtg' }, 'Raw Def Rtg'),
                                            e('option', { value: 'rawNet' }, 'Raw Net Rtg')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute && e('optgroup', { label: '📊 Ratings (vs. Lg Avg)' },
                                            e('option', { value: 'adjOrtgVsLg' }, 'Adj Off Rtg vs Lg'),
                                            e('option', { value: 'adjDrtgVsLg' }, 'Adj Def Rtg vs Lg'),
                                            e('option', { value: 'adjNetVsLg' }, 'Adj Net Rtg'),
                                            e('option', { value: 'rawOrtgVsLg' }, 'Raw Off Rtg vs Lg'),
                                            e('option', { value: 'rawDrtgVsLg' }, 'Raw Def Rtg vs Lg'),
                                            e('option', { value: 'rawNetVsLg' }, 'Raw Net Rtg')
                                        ),
                                        exportChartDataMode === 'teams' && e('optgroup', { label: '🏆 Record & Expected Wins' },
                                            e('option', { value: 'wins' }, 'Wins'),
                                            e('option', { value: 'losses' }, 'Losses'),
                                            e('option', { value: 'winPct' }, 'Win %'),
                                            e('option', { value: 'pythExpWins' }, 'Pyth xWins'),
                                            e('option', { value: 'pythProjWins' }, 'Proj Wins'),
                                            e('option', { value: 'sosNet' }, 'SOS Net')
                                        ),
                                        exportChartDataMode === 'teams' && exportChartAbsolute && e('optgroup', { label: '🎯 Offense Four Factors (Absolute)' },
                                            e('option', { value: 'offEfg' }, 'Off eFG%'),
                                            e('option', { value: 'offTovPct' }, 'Off TOV%'),
                                            e('option', { value: 'offOrebPct' }, 'Off OREB%'),
                                            e('option', { value: 'offFtRate' }, 'Off FT Rate')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute && e('optgroup', { label: '🎯 Offense Four Factors (vs. Lg Avg)' },
                                            e('option', { value: 'offEfgVsLg' }, 'Off eFG% vs Lg'),
                                            e('option', { value: 'offTovPctVsLg' }, 'Off TOV% vs Lg'),
                                            e('option', { value: 'offOrebPctVsLg' }, 'Off OREB% vs Lg'),
                                            e('option', { value: 'offFtRateVsLg' }, 'Off FT Rate vs Lg')
                                        ),
                                        exportChartDataMode === 'teams' && exportChartAbsolute && e('optgroup', { label: '🛡️ Defense Four Factors (Absolute)' },
                                            e('option', { value: 'defEfg' }, 'Def eFG% (Opp)'),
                                            e('option', { value: 'defTovPct' }, 'Def TOV% (Opp)'),
                                            e('option', { value: 'defOrebPct' }, 'Def OREB% (Opp)'),
                                            e('option', { value: 'defFtRate' }, 'Def FT Rate (Opp)')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute && e('optgroup', { label: '🛡️ Defense Four Factors (vs. Lg Avg)' },
                                            e('option', { value: 'defEfgVsLg' }, 'Def eFG% vs Lg'),
                                            e('option', { value: 'defTovPctVsLg' }, 'Def TOV% vs Lg'),
                                            e('option', { value: 'defOrebPctVsLg' }, 'Def OREB% vs Lg'),
                                            e('option', { value: 'defFtRateVsLg' }, 'Def FT Rate vs Lg')
                                        ),
                                        exportChartDataMode === 'teams' && e('optgroup', { label: '⚡ Off Points Added' },
                                            e('option', { value: 'offEfgPA' }, 'Off eFG% PA'),
                                            e('option', { value: 'offTovPA' }, 'Off TOV% PA'),
                                            e('option', { value: 'offOrebPA' }, 'Off OREB% PA'),
                                            e('option', { value: 'offFtRPA' }, 'Off FT Rate PA'),
                                            e('option', { value: 'offScoringPA' }, '🎯 Off Scoring PA'),
                                            e('option', { value: 'offPossPA' }, '🔄 Off Poss PA'),
                                            e('option', { value: 'offTotalPA' }, '⬆️ Off Total PA')
                                        ),
                                        exportChartDataMode === 'teams' && e('optgroup', { label: '⚡ Def Points Added' },
                                            e('option', { value: 'defEfgPA' }, 'Def eFG% PA'),
                                            e('option', { value: 'defTovPA' }, 'Def TOV% PA'),
                                            e('option', { value: 'defOrebPA' }, 'Def OREB% PA'),
                                            e('option', { value: 'defFtRPA' }, 'Def FT Rate PA'),
                                            e('option', { value: 'defScoringPA' }, '🎯 Def Scoring PA'),
                                            e('option', { value: 'defPossPA' }, '🔄 Def Poss PA'),
                                            e('option', { value: 'defTotalPA' }, '⬇️ Def Total PA')
                                        ),
                                        // PLAYERS MODE OPTIONS (existing)
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Ratings (ON)' : 'Ratings ON-OFF' },
                                            e('option', { value: 'net' }, 'Net Rating'),
                                            e('option', { value: 'off' }, 'Offensive Rating'),
                                            e('option', { value: 'def' }, 'Defensive Rating')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: 'Combined Impact (Z-Score)' },
                                            e('option', { value: 'fourFactorsImpact' }, '⚡ Four Factors Impact'),
                                            e('option', { value: 'scoringBattleImpact' }, '🎯 Scoring Battle'),
                                            e('option', { value: 'possBattleImpact' }, '🔄 Possession Battle')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: 'Box Plus/Minus' },
                                            e('option', { value: 'bpm' }, 'BPM'),
                                            e('option', { value: 'obpm' }, 'OBPM'),
                                            e('option', { value: 'dbpm' }, 'DBPM')
                                        ),
                                        exportChartDataMode === 'players' && playerApmStats && playerApmStats.players && e('optgroup', { label: '🔮 Bayesian Box APM' },
                                            e('option', { value: 'apm' }, '🔮 APM'),
                                            e('option', { value: 'oapm' }, '🔮 OAPM'),
                                            e('option', { value: 'dapm' }, '🔮 DAPM')
                                        ),
                                        exportChartDataMode === 'players' && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg && e('optgroup', { label: 'RAPM' },
                                            e('option', { value: 'rapm' }, 'RAPM'),
                                            e('option', { value: 'orapm' }, 'ORAPM'),
                                            e('option', { value: 'drapm' }, 'DRAPM')
                                        ),
                                        exportChartDataMode === 'players' && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.eFG && e('optgroup', { label: 'Single-Stat RAPM (Off)' },
                                            e('option', { value: 'rapmOffEfg' }, 'RAPM Off eFG%'),
                                            e('option', { value: 'rapmOffTov' }, 'RAPM Off TOV%'),
                                            e('option', { value: 'rapmOffOreb' }, 'RAPM Off OREB%'),
                                            e('option', { value: 'rapmOffFtr' }, 'RAPM Off FTR'),
                                            e('option', { value: 'rapmOffAst' }, 'RAPM Off AST%')
                                        ),
                                        exportChartDataMode === 'players' && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.eFG && e('optgroup', { label: 'Single-Stat RAPM (Def)' },
                                            e('option', { value: 'rapmDefEfg' }, 'RAPM Def eFG%'),
                                            e('option', { value: 'rapmDefTov' }, 'RAPM Def TOV%'),
                                            e('option', { value: 'rapmDefOreb' }, 'RAPM Def OREB%'),
                                            e('option', { value: 'rapmDefFtr' }, 'RAPM Def FTR'),
                                            e('option', { value: 'rapmStl' }, 'RAPM STL%'),
                                            e('option', { value: 'rapmBlk' }, 'RAPM BLK%')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Four Factors (ON)' : 'Four Factors ON-OFF' },
                                            e('option', { value: 'offEfg' }, 'Off eFG%'),
                                            e('option', { value: 'defEfg' }, 'Def eFG%'),
                                            e('option', { value: 'offTov' }, 'Off TOV%'),
                                            e('option', { value: 'defTov' }, 'Def TOV%'),
                                            e('option', { value: 'offOreb' }, 'Off OREB%'),
                                            e('option', { value: 'defOreb' }, 'Def OREB%'),
                                            e('option', { value: 'offFtR' }, 'Off FT Rate'),
                                            e('option', { value: 'defFtR' }, 'Def FT Rate')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Shot Making (ON)' : 'Shot Making ON-OFF' },
                                            e('option', { value: 'rimPct' }, 'Rim%'),
                                            e('option', { value: 'midPct' }, 'Mid%'),
                                            e('option', { value: 'threePct' }, '3PT%')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Shot Volume (ON)' : 'Shot Volume ON-OFF' },
                                            e('option', { value: 'rimVol' }, 'Rim Vol/100'),
                                            e('option', { value: 'midVol' }, 'Mid Vol/100'),
                                            e('option', { value: 'threeVol' }, '3PT Vol/100')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Playmaking (ON)' : 'Playmaking ON-OFF' },
                                            e('option', { value: 'astPct' }, 'AST%'),
                                            e('option', { value: 'stlPct' }, 'STL%'),
                                            e('option', { value: 'blkPct' }, 'BLK%')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Pace (ON)' : 'Pace ON-OFF' },
                                            e('option', { value: 'paceF' }, 'Off Pace'),
                                            e('option', { value: 'paceV' }, 'Def Pace')
                                        )
                                    )
                                ),
                                e('div', { className: 'export-control-group' },
                                    e('label', null, 'Y-Axis Stat' + (exportChartDataMode === 'players' ? (exportChartAbsolute ? ' (Absolute)' : ' (ON-OFF)') : (exportChartAbsolute ? ' (Absolute)' : ' (vs. Lg Avg)'))),
                                    e('select', { 
                                        value: exportChartY, 
                                        onChange: ev => setExportChartY(ev.target.value)
                                    },
                                        // TEAMS MODE OPTIONS - changes based on Absolute vs. League Avg mode
                                        exportChartDataMode === 'teams' && exportChartAbsolute && e('optgroup', { label: '📊 Ratings (Absolute)' },
                                            e('option', { value: 'adjOrtg' }, 'Adj Off Rtg'),
                                            e('option', { value: 'adjDrtg' }, 'Adj Def Rtg'),
                                            e('option', { value: 'adjNet' }, 'Adj Net Rtg'),
                                            e('option', { value: 'rawOrtg' }, 'Raw Off Rtg'),
                                            e('option', { value: 'rawDrtg' }, 'Raw Def Rtg'),
                                            e('option', { value: 'rawNet' }, 'Raw Net Rtg')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute && e('optgroup', { label: '📊 Ratings (vs. Lg Avg)' },
                                            e('option', { value: 'adjOrtgVsLg' }, 'Adj Off Rtg vs Lg'),
                                            e('option', { value: 'adjDrtgVsLg' }, 'Adj Def Rtg vs Lg'),
                                            e('option', { value: 'adjNetVsLg' }, 'Adj Net Rtg'),
                                            e('option', { value: 'rawOrtgVsLg' }, 'Raw Off Rtg vs Lg'),
                                            e('option', { value: 'rawDrtgVsLg' }, 'Raw Def Rtg vs Lg'),
                                            e('option', { value: 'rawNetVsLg' }, 'Raw Net Rtg')
                                        ),
                                        exportChartDataMode === 'teams' && e('optgroup', { label: '🏆 Record & Expected Wins' },
                                            e('option', { value: 'wins' }, 'Wins'),
                                            e('option', { value: 'losses' }, 'Losses'),
                                            e('option', { value: 'winPct' }, 'Win %'),
                                            e('option', { value: 'pythExpWins' }, 'Pyth xWins'),
                                            e('option', { value: 'pythProjWins' }, 'Proj Wins'),
                                            e('option', { value: 'sosNet' }, 'SOS Net')
                                        ),
                                        exportChartDataMode === 'teams' && exportChartAbsolute && e('optgroup', { label: '🎯 Offense Four Factors (Absolute)' },
                                            e('option', { value: 'offEfg' }, 'Off eFG%'),
                                            e('option', { value: 'offTovPct' }, 'Off TOV%'),
                                            e('option', { value: 'offOrebPct' }, 'Off OREB%'),
                                            e('option', { value: 'offFtRate' }, 'Off FT Rate')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute && e('optgroup', { label: '🎯 Offense Four Factors (vs. Lg Avg)' },
                                            e('option', { value: 'offEfgVsLg' }, 'Off eFG% vs Lg'),
                                            e('option', { value: 'offTovPctVsLg' }, 'Off TOV% vs Lg'),
                                            e('option', { value: 'offOrebPctVsLg' }, 'Off OREB% vs Lg'),
                                            e('option', { value: 'offFtRateVsLg' }, 'Off FT Rate vs Lg')
                                        ),
                                        exportChartDataMode === 'teams' && exportChartAbsolute && e('optgroup', { label: '🛡️ Defense Four Factors (Absolute)' },
                                            e('option', { value: 'defEfg' }, 'Def eFG% (Opp)'),
                                            e('option', { value: 'defTovPct' }, 'Def TOV% (Opp)'),
                                            e('option', { value: 'defOrebPct' }, 'Def OREB% (Opp)'),
                                            e('option', { value: 'defFtRate' }, 'Def FT Rate (Opp)')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute && e('optgroup', { label: '🛡️ Defense Four Factors (vs. Lg Avg)' },
                                            e('option', { value: 'defEfgVsLg' }, 'Def eFG% vs Lg'),
                                            e('option', { value: 'defTovPctVsLg' }, 'Def TOV% vs Lg'),
                                            e('option', { value: 'defOrebPctVsLg' }, 'Def OREB% vs Lg'),
                                            e('option', { value: 'defFtRateVsLg' }, 'Def FT Rate vs Lg')
                                        ),
                                        exportChartDataMode === 'teams' && e('optgroup', { label: '⚡ Off Points Added' },
                                            e('option', { value: 'offEfgPA' }, 'Off eFG% PA'),
                                            e('option', { value: 'offTovPA' }, 'Off TOV% PA'),
                                            e('option', { value: 'offOrebPA' }, 'Off OREB% PA'),
                                            e('option', { value: 'offFtRPA' }, 'Off FT Rate PA'),
                                            e('option', { value: 'offScoringPA' }, '🎯 Off Scoring PA'),
                                            e('option', { value: 'offPossPA' }, '🔄 Off Poss PA'),
                                            e('option', { value: 'offTotalPA' }, '⬆️ Off Total PA')
                                        ),
                                        exportChartDataMode === 'teams' && e('optgroup', { label: '⚡ Def Points Added' },
                                            e('option', { value: 'defEfgPA' }, 'Def eFG% PA'),
                                            e('option', { value: 'defTovPA' }, 'Def TOV% PA'),
                                            e('option', { value: 'defOrebPA' }, 'Def OREB% PA'),
                                            e('option', { value: 'defFtRPA' }, 'Def FT Rate PA'),
                                            e('option', { value: 'defScoringPA' }, '🎯 Def Scoring PA'),
                                            e('option', { value: 'defPossPA' }, '🔄 Def Poss PA'),
                                            e('option', { value: 'defTotalPA' }, '⬇️ Def Total PA')
                                        ),
                                        // PLAYERS MODE OPTIONS
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Ratings (ON)' : 'Ratings ON-OFF' },
                                            e('option', { value: 'net' }, 'Net Rating'),
                                            e('option', { value: 'off' }, 'Offensive Rating'),
                                            e('option', { value: 'def' }, 'Defensive Rating')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: 'Combined Impact (Z-Score)' },
                                            e('option', { value: 'fourFactorsImpact' }, '⚡ Four Factors Impact'),
                                            e('option', { value: 'scoringBattleImpact' }, '🎯 Scoring Battle'),
                                            e('option', { value: 'possBattleImpact' }, '🔄 Possession Battle')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: 'Box Plus/Minus' },
                                            e('option', { value: 'bpm' }, 'BPM'),
                                            e('option', { value: 'obpm' }, 'OBPM'),
                                            e('option', { value: 'dbpm' }, 'DBPM')
                                        ),
                                        exportChartDataMode === 'players' && playerApmStats && playerApmStats.players && e('optgroup', { label: '🔮 Bayesian Box APM' },
                                            e('option', { value: 'apm' }, '🔮 APM'),
                                            e('option', { value: 'oapm' }, '🔮 OAPM'),
                                            e('option', { value: 'dapm' }, '🔮 DAPM')
                                        ),
                                        exportChartDataMode === 'players' && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg && e('optgroup', { label: 'RAPM' },
                                            e('option', { value: 'rapm' }, 'RAPM'),
                                            e('option', { value: 'orapm' }, 'ORAPM'),
                                            e('option', { value: 'drapm' }, 'DRAPM')
                                        ),
                                        exportChartDataMode === 'players' && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.eFG && e('optgroup', { label: 'Single-Stat RAPM (Off)' },
                                            e('option', { value: 'rapmOffEfg' }, 'RAPM Off eFG%'),
                                            e('option', { value: 'rapmOffTov' }, 'RAPM Off TOV%'),
                                            e('option', { value: 'rapmOffOreb' }, 'RAPM Off OREB%'),
                                            e('option', { value: 'rapmOffFtr' }, 'RAPM Off FTR'),
                                            e('option', { value: 'rapmOffAst' }, 'RAPM Off AST%')
                                        ),
                                        exportChartDataMode === 'players' && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.eFG && e('optgroup', { label: 'Single-Stat RAPM (Def)' },
                                            e('option', { value: 'rapmDefEfg' }, 'RAPM Def eFG%'),
                                            e('option', { value: 'rapmDefTov' }, 'RAPM Def TOV%'),
                                            e('option', { value: 'rapmDefOreb' }, 'RAPM Def OREB%'),
                                            e('option', { value: 'rapmDefFtr' }, 'RAPM Def FTR'),
                                            e('option', { value: 'rapmStl' }, 'RAPM STL%'),
                                            e('option', { value: 'rapmBlk' }, 'RAPM BLK%')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Four Factors (ON)' : 'Four Factors ON-OFF' },
                                            e('option', { value: 'offEfg' }, 'Off eFG%'),
                                            e('option', { value: 'defEfg' }, 'Def eFG%'),
                                            e('option', { value: 'offTov' }, 'Off TOV%'),
                                            e('option', { value: 'defTov' }, 'Def TOV%'),
                                            e('option', { value: 'offOreb' }, 'Off OREB%'),
                                            e('option', { value: 'defOreb' }, 'Def OREB%'),
                                            e('option', { value: 'offFtR' }, 'Off FT Rate'),
                                            e('option', { value: 'defFtR' }, 'Def FT Rate')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Shot Making (ON)' : 'Shot Making ON-OFF' },
                                            e('option', { value: 'rimPct' }, 'Rim%'),
                                            e('option', { value: 'midPct' }, 'Mid%'),
                                            e('option', { value: 'threePct' }, '3PT%')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Shot Volume (ON)' : 'Shot Volume ON-OFF' },
                                            e('option', { value: 'rimVol' }, 'Rim Vol/100'),
                                            e('option', { value: 'midVol' }, 'Mid Vol/100'),
                                            e('option', { value: 'threeVol' }, '3PT Vol/100')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Playmaking (ON)' : 'Playmaking ON-OFF' },
                                            e('option', { value: 'astPct' }, 'AST%'),
                                            e('option', { value: 'stlPct' }, 'STL%'),
                                            e('option', { value: 'blkPct' }, 'BLK%')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute ? 'Pace (ON)' : 'Pace ON-OFF' },
                                            e('option', { value: 'paceF' }, 'Off Pace'),
                                            e('option', { value: 'paceV' }, 'Def Pace')
                                        )
                                    )
                                ),
                                // Filter controls - different for players vs teams
                                exportChartDataMode === 'players' && e('div', { className: 'export-control-group' },
                                    e('label', null, 'Team Filter'),
                                    e('select', { 
                                        value: exportTeam, 
                                        onChange: ev => setExportTeam(ev.target.value)
                                    },
                                        e('option', { value: '' }, 'All Teams'),
                                        teams.map(t => e('option', { key: t, value: t }, t))
                                    )
                                ),
                                exportChartDataMode === 'players' && e('div', { className: 'export-control-group' },
                                    e('label', null, 'Min Minutes'),
                                    e('input', { 
                                        type: 'number', 
                                        value: exportMinMins, 
                                        onChange: ev => setExportMinMins(parseInt(ev.target.value) || 0),
                                        min: 0,
                                        style: { width: '80px' }
                                    })
                                )
                            ),
                            // V5.9: Twin Plot second axis selectors (only when twin plot enabled)
                            exportChartTwinPlot && e('div', { style: { display: 'flex', gap: '16px', flexWrap: 'wrap', marginBottom: '12px', padding: '12px', background: 'rgba(139, 92, 246, 0.1)', borderRadius: '8px', border: '1px solid rgba(139, 92, 246, 0.3)' }},
                                e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%', marginBottom: '4px' }},
                                    e('div', { style: { fontSize: '11px', color: '#a78bfa', fontWeight: '600' }}, '📊 Second Chart Axes'),
                                    // Toggle for second chart mode
                                    e('div', { className: 'export-toggle-container', style: { margin: 0 }},
                                        e('span', { className: 'export-toggle-label' + (!exportChartAbsolute2 ? ' active' : ''), style: { fontSize: '10px' } }, 
                                            exportChartDataMode === 'teams' ? 'vs. Lg Avg' : 'ON-OFF'
                                        ),
                                        e('div', { 
                                            className: 'export-toggle' + (exportChartAbsolute2 ? ' active' : ''),
                                            style: { transform: 'scale(0.85)' },
                                            onClick: () => {
                                                const newAbsolute2 = !exportChartAbsolute2;
                                                setExportChartAbsolute2(newAbsolute2);
                                                // Reset axes when in teams mode to match new mode
                                                if (exportChartDataMode === 'teams') {
                                                    if (newAbsolute2) {
                                                        setExportChartX2('offEfg');
                                                        setExportChartY2('defEfg');
                                                    } else {
                                                        setExportChartX2('offEfgVsLg');
                                                        setExportChartY2('defEfgVsLg');
                                                    }
                                                }
                                            }
                                        }),
                                        e('span', { className: 'export-toggle-label' + (exportChartAbsolute2 ? ' active' : ''), style: { fontSize: '10px' } }, 'Absolute')
                                    )
                                ),
                                e('div', { className: 'export-control-group' },
                                    e('label', null, 'X2-Axis Stat' + (exportChartDataMode === 'players' ? (exportChartAbsolute2 ? ' (Absolute)' : ' (ON-OFF)') : (exportChartAbsolute2 ? ' (Absolute)' : ' (vs. Lg Avg)'))),
                                    e('select', { 
                                        value: exportChartX2, 
                                        onChange: ev => setExportChartX2(ev.target.value)
                                    },
                                        // TEAMS MODE OPTIONS - Absolute
                                        exportChartDataMode === 'teams' && exportChartAbsolute2 && e('optgroup', { label: '📊 Ratings (Absolute)' },
                                            e('option', { value: 'adjOrtg' }, 'Adj Off Rtg'),
                                            e('option', { value: 'adjDrtg' }, 'Adj Def Rtg'),
                                            e('option', { value: 'adjNet' }, 'Adj Net Rtg'),
                                            e('option', { value: 'rawOrtg' }, 'Raw Off Rtg'),
                                            e('option', { value: 'rawDrtg' }, 'Raw Def Rtg'),
                                            e('option', { value: 'rawNet' }, 'Raw Net Rtg')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute2 && e('optgroup', { label: '📊 Ratings (vs. Lg Avg)' },
                                            e('option', { value: 'adjOrtgVsLg' }, 'Adj Off Rtg vs Lg'),
                                            e('option', { value: 'adjDrtgVsLg' }, 'Adj Def Rtg vs Lg'),
                                            e('option', { value: 'adjNetVsLg' }, 'Adj Net Rtg'),
                                            e('option', { value: 'rawOrtgVsLg' }, 'Raw Off Rtg vs Lg'),
                                            e('option', { value: 'rawDrtgVsLg' }, 'Raw Def Rtg vs Lg'),
                                            e('option', { value: 'rawNetVsLg' }, 'Raw Net Rtg')
                                        ),
                                        exportChartDataMode === 'teams' && e('optgroup', { label: '🏆 Record & Expected Wins' },
                                            e('option', { value: 'wins' }, 'Wins'),
                                            e('option', { value: 'losses' }, 'Losses'),
                                            e('option', { value: 'winPct' }, 'Win %'),
                                            e('option', { value: 'pythExpWins' }, 'Pyth xWins'),
                                            e('option', { value: 'pythProjWins' }, 'Proj Wins'),
                                            e('option', { value: 'sosNet' }, 'SOS Net')
                                        ),
                                        exportChartDataMode === 'teams' && exportChartAbsolute2 && e('optgroup', { label: '🎯 Offense Four Factors (Absolute)' },
                                            e('option', { value: 'offEfg' }, 'Off eFG%'),
                                            e('option', { value: 'offTovPct' }, 'Off TOV%'),
                                            e('option', { value: 'offOrebPct' }, 'Off OREB%'),
                                            e('option', { value: 'offFtRate' }, 'Off FT Rate')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute2 && e('optgroup', { label: '🎯 Offense Four Factors (vs. Lg Avg)' },
                                            e('option', { value: 'offEfgVsLg' }, 'Off eFG% vs Lg'),
                                            e('option', { value: 'offTovPctVsLg' }, 'Off TOV% vs Lg'),
                                            e('option', { value: 'offOrebPctVsLg' }, 'Off OREB% vs Lg'),
                                            e('option', { value: 'offFtRateVsLg' }, 'Off FT Rate vs Lg')
                                        ),
                                        exportChartDataMode === 'teams' && exportChartAbsolute2 && e('optgroup', { label: '🛡️ Defense Four Factors (Absolute)' },
                                            e('option', { value: 'defEfg' }, 'Def eFG% (Opp)'),
                                            e('option', { value: 'defTovPct' }, 'Def TOV% (Opp)'),
                                            e('option', { value: 'defOrebPct' }, 'Def OREB% (Opp)'),
                                            e('option', { value: 'defFtRate' }, 'Def FT Rate (Opp)')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute2 && e('optgroup', { label: '🛡️ Defense Four Factors (vs. Lg Avg)' },
                                            e('option', { value: 'defEfgVsLg' }, 'Def eFG% vs Lg'),
                                            e('option', { value: 'defTovPctVsLg' }, 'Def TOV% vs Lg'),
                                            e('option', { value: 'defOrebPctVsLg' }, 'Def OREB% vs Lg'),
                                            e('option', { value: 'defFtRateVsLg' }, 'Def FT Rate vs Lg')
                                        ),
                                        exportChartDataMode === 'teams' && e('optgroup', { label: '⚡ Points Added' },
                                            e('option', { value: 'offTotalPA' }, '⬆️ Off Total PA'),
                                            e('option', { value: 'defTotalPA' }, '⬇️ Def Total PA'),
                                            e('option', { value: 'offScoringPA' }, '🎯 Off Scoring PA'),
                                            e('option', { value: 'defScoringPA' }, '🎯 Def Scoring PA'),
                                            e('option', { value: 'offPossPA' }, '🔄 Off Poss PA'),
                                            e('option', { value: 'defPossPA' }, '🔄 Def Poss PA')
                                        ),
                                        // PLAYERS MODE OPTIONS
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Ratings (ON)' : 'Ratings ON-OFF' },
                                            e('option', { value: 'net' }, 'Net Rating'),
                                            e('option', { value: 'off' }, 'Offensive Rating'),
                                            e('option', { value: 'def' }, 'Defensive Rating')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: 'Combined Impact (Z-Score)' },
                                            e('option', { value: 'fourFactorsImpact' }, '⚡ Four Factors Impact'),
                                            e('option', { value: 'scoringBattleImpact' }, '🎯 Scoring Battle'),
                                            e('option', { value: 'possBattleImpact' }, '🔄 Possession Battle')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: 'Box Plus/Minus' },
                                            e('option', { value: 'bpm' }, 'BPM'),
                                            e('option', { value: 'obpm' }, 'OBPM'),
                                            e('option', { value: 'dbpm' }, 'DBPM')
                                        ),
                                        exportChartDataMode === 'players' && playerApmStats && playerApmStats.players && e('optgroup', { label: '🔮 Bayesian Box APM' },
                                            e('option', { value: 'apm' }, '🔮 APM'),
                                            e('option', { value: 'oapm' }, '🔮 OAPM'),
                                            e('option', { value: 'dapm' }, '🔮 DAPM')
                                        ),
                                        exportChartDataMode === 'players' && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg && e('optgroup', { label: 'RAPM' },
                                            e('option', { value: 'rapm' }, 'RAPM'),
                                            e('option', { value: 'orapm' }, 'ORAPM'),
                                            e('option', { value: 'drapm' }, 'DRAPM')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Four Factors (ON)' : 'Four Factors ON-OFF' },
                                            e('option', { value: 'offEfg' }, 'Off eFG%'),
                                            e('option', { value: 'defEfg' }, 'Def eFG%'),
                                            e('option', { value: 'offTov' }, 'Off TOV%'),
                                            e('option', { value: 'defTov' }, 'Def TOV%'),
                                            e('option', { value: 'offOreb' }, 'Off OREB%'),
                                            e('option', { value: 'defOreb' }, 'Def OREB%'),
                                            e('option', { value: 'offFtR' }, 'Off FT Rate'),
                                            e('option', { value: 'defFtR' }, 'Def FT Rate')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Shot Making (ON)' : 'Shot Making ON-OFF' },
                                            e('option', { value: 'rimPct' }, 'Rim%'),
                                            e('option', { value: 'midPct' }, 'Mid%'),
                                            e('option', { value: 'threePct' }, '3PT%')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Shot Volume (ON)' : 'Shot Volume ON-OFF' },
                                            e('option', { value: 'rimVol' }, 'Rim Vol/100'),
                                            e('option', { value: 'midVol' }, 'Mid Vol/100'),
                                            e('option', { value: 'threeVol' }, '3PT Vol/100')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Playmaking (ON)' : 'Playmaking ON-OFF' },
                                            e('option', { value: 'astPct' }, 'AST%'),
                                            e('option', { value: 'stlPct' }, 'STL%'),
                                            e('option', { value: 'blkPct' }, 'BLK%')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Pace (ON)' : 'Pace ON-OFF' },
                                            e('option', { value: 'paceF' }, 'Off Pace'),
                                            e('option', { value: 'paceV' }, 'Def Pace')
                                        )
                                    )
                                ),
                                e('div', { className: 'export-control-group' },
                                    e('label', null, 'Y2-Axis Stat' + (exportChartDataMode === 'players' ? (exportChartAbsolute2 ? ' (Absolute)' : ' (ON-OFF)') : (exportChartAbsolute2 ? ' (Absolute)' : ' (vs. Lg Avg)'))),
                                    e('select', { 
                                        value: exportChartY2, 
                                        onChange: ev => setExportChartY2(ev.target.value)
                                    },
                                        // TEAMS MODE OPTIONS - Absolute
                                        exportChartDataMode === 'teams' && exportChartAbsolute2 && e('optgroup', { label: '📊 Ratings (Absolute)' },
                                            e('option', { value: 'adjOrtg' }, 'Adj Off Rtg'),
                                            e('option', { value: 'adjDrtg' }, 'Adj Def Rtg'),
                                            e('option', { value: 'adjNet' }, 'Adj Net Rtg'),
                                            e('option', { value: 'rawOrtg' }, 'Raw Off Rtg'),
                                            e('option', { value: 'rawDrtg' }, 'Raw Def Rtg'),
                                            e('option', { value: 'rawNet' }, 'Raw Net Rtg')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute2 && e('optgroup', { label: '📊 Ratings (vs. Lg Avg)' },
                                            e('option', { value: 'adjOrtgVsLg' }, 'Adj Off Rtg vs Lg'),
                                            e('option', { value: 'adjDrtgVsLg' }, 'Adj Def Rtg vs Lg'),
                                            e('option', { value: 'adjNetVsLg' }, 'Adj Net Rtg'),
                                            e('option', { value: 'rawOrtgVsLg' }, 'Raw Off Rtg vs Lg'),
                                            e('option', { value: 'rawDrtgVsLg' }, 'Raw Def Rtg vs Lg'),
                                            e('option', { value: 'rawNetVsLg' }, 'Raw Net Rtg')
                                        ),
                                        exportChartDataMode === 'teams' && e('optgroup', { label: '🏆 Record & Expected Wins' },
                                            e('option', { value: 'wins' }, 'Wins'),
                                            e('option', { value: 'losses' }, 'Losses'),
                                            e('option', { value: 'winPct' }, 'Win %'),
                                            e('option', { value: 'pythExpWins' }, 'Pyth xWins'),
                                            e('option', { value: 'pythProjWins' }, 'Proj Wins'),
                                            e('option', { value: 'sosNet' }, 'SOS Net')
                                        ),
                                        exportChartDataMode === 'teams' && exportChartAbsolute2 && e('optgroup', { label: '🎯 Offense Four Factors (Absolute)' },
                                            e('option', { value: 'offEfg' }, 'Off eFG%'),
                                            e('option', { value: 'offTovPct' }, 'Off TOV%'),
                                            e('option', { value: 'offOrebPct' }, 'Off OREB%'),
                                            e('option', { value: 'offFtRate' }, 'Off FT Rate')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute2 && e('optgroup', { label: '🎯 Offense Four Factors (vs. Lg Avg)' },
                                            e('option', { value: 'offEfgVsLg' }, 'Off eFG% vs Lg'),
                                            e('option', { value: 'offTovPctVsLg' }, 'Off TOV% vs Lg'),
                                            e('option', { value: 'offOrebPctVsLg' }, 'Off OREB% vs Lg'),
                                            e('option', { value: 'offFtRateVsLg' }, 'Off FT Rate vs Lg')
                                        ),
                                        exportChartDataMode === 'teams' && exportChartAbsolute2 && e('optgroup', { label: '🛡️ Defense Four Factors (Absolute)' },
                                            e('option', { value: 'defEfg' }, 'Def eFG% (Opp)'),
                                            e('option', { value: 'defTovPct' }, 'Def TOV% (Opp)'),
                                            e('option', { value: 'defOrebPct' }, 'Def OREB% (Opp)'),
                                            e('option', { value: 'defFtRate' }, 'Def FT Rate (Opp)')
                                        ),
                                        exportChartDataMode === 'teams' && !exportChartAbsolute2 && e('optgroup', { label: '🛡️ Defense Four Factors (vs. Lg Avg)' },
                                            e('option', { value: 'defEfgVsLg' }, 'Def eFG% vs Lg'),
                                            e('option', { value: 'defTovPctVsLg' }, 'Def TOV% vs Lg'),
                                            e('option', { value: 'defOrebPctVsLg' }, 'Def OREB% vs Lg'),
                                            e('option', { value: 'defFtRateVsLg' }, 'Def FT Rate vs Lg')
                                        ),
                                        exportChartDataMode === 'teams' && e('optgroup', { label: '⚡ Points Added' },
                                            e('option', { value: 'offTotalPA' }, '⬆️ Off Total PA'),
                                            e('option', { value: 'defTotalPA' }, '⬇️ Def Total PA'),
                                            e('option', { value: 'offScoringPA' }, '🎯 Off Scoring PA'),
                                            e('option', { value: 'defScoringPA' }, '🎯 Def Scoring PA'),
                                            e('option', { value: 'offPossPA' }, '🔄 Off Poss PA'),
                                            e('option', { value: 'defPossPA' }, '🔄 Def Poss PA')
                                        ),
                                        // PLAYERS MODE OPTIONS
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Ratings (ON)' : 'Ratings ON-OFF' },
                                            e('option', { value: 'net' }, 'Net Rating'),
                                            e('option', { value: 'off' }, 'Offensive Rating'),
                                            e('option', { value: 'def' }, 'Defensive Rating')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: 'Combined Impact (Z-Score)' },
                                            e('option', { value: 'fourFactorsImpact' }, '⚡ Four Factors Impact'),
                                            e('option', { value: 'scoringBattleImpact' }, '🎯 Scoring Battle'),
                                            e('option', { value: 'possBattleImpact' }, '🔄 Possession Battle')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: 'Box Plus/Minus' },
                                            e('option', { value: 'bpm' }, 'BPM'),
                                            e('option', { value: 'obpm' }, 'OBPM'),
                                            e('option', { value: 'dbpm' }, 'DBPM')
                                        ),
                                        exportChartDataMode === 'players' && playerApmStats && playerApmStats.players && e('optgroup', { label: '🔮 Bayesian Box APM' },
                                            e('option', { value: 'apm' }, '🔮 APM'),
                                            e('option', { value: 'oapm' }, '🔮 OAPM'),
                                            e('option', { value: 'dapm' }, '🔮 DAPM')
                                        ),
                                        exportChartDataMode === 'players' && playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg && e('optgroup', { label: 'RAPM' },
                                            e('option', { value: 'rapm' }, 'RAPM'),
                                            e('option', { value: 'orapm' }, 'ORAPM'),
                                            e('option', { value: 'drapm' }, 'DRAPM')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Four Factors (ON)' : 'Four Factors ON-OFF' },
                                            e('option', { value: 'offEfg' }, 'Off eFG%'),
                                            e('option', { value: 'defEfg' }, 'Def eFG%'),
                                            e('option', { value: 'offTov' }, 'Off TOV%'),
                                            e('option', { value: 'defTov' }, 'Def TOV%'),
                                            e('option', { value: 'offOreb' }, 'Off OREB%'),
                                            e('option', { value: 'defOreb' }, 'Def OREB%'),
                                            e('option', { value: 'offFtR' }, 'Off FT Rate'),
                                            e('option', { value: 'defFtR' }, 'Def FT Rate')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Shot Making (ON)' : 'Shot Making ON-OFF' },
                                            e('option', { value: 'rimPct' }, 'Rim%'),
                                            e('option', { value: 'midPct' }, 'Mid%'),
                                            e('option', { value: 'threePct' }, '3PT%')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Shot Volume (ON)' : 'Shot Volume ON-OFF' },
                                            e('option', { value: 'rimVol' }, 'Rim Vol/100'),
                                            e('option', { value: 'midVol' }, 'Mid Vol/100'),
                                            e('option', { value: 'threeVol' }, '3PT Vol/100')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Playmaking (ON)' : 'Playmaking ON-OFF' },
                                            e('option', { value: 'astPct' }, 'AST%'),
                                            e('option', { value: 'stlPct' }, 'STL%'),
                                            e('option', { value: 'blkPct' }, 'BLK%')
                                        ),
                                        exportChartDataMode === 'players' && e('optgroup', { label: exportChartAbsolute2 ? 'Pace (ON)' : 'Pace ON-OFF' },
                                            e('option', { value: 'paceF' }, 'Off Pace'),
                                            e('option', { value: 'paceV' }, 'Def Pace')
                                        )
                                    )
                                )
                            ),
                            // Row 2: Labels and options
                            e('div', { style: { display: 'flex', gap: '12px', flexWrap: 'wrap', marginBottom: '12px', alignItems: 'flex-end' }},
                                e('div', { className: 'export-control-group' },
                                    e('label', null, 'Chart Title'),
                                    e('input', { 
                                        type: 'text', 
                                        value: exportChartTitle, 
                                        onChange: ev => setExportChartTitle(ev.target.value),
                                        placeholder: 'Chart Title',
                                        style: { minWidth: '180px' }
                                    })
                                ),
                                e('div', { className: 'export-control-group' },
                                    e('label', null, 'X-Axis Label'),
                                    e('input', { 
                                        type: 'text', 
                                        value: exportChartXLabel, 
                                        onChange: ev => setExportChartXLabel(ev.target.value),
                                        placeholder: 'Auto',
                                        style: { minWidth: '120px' }
                                    })
                                ),
                                e('div', { className: 'export-control-group' },
                                    e('label', null, 'Y-Axis Label'),
                                    e('input', { 
                                        type: 'text', 
                                        value: exportChartYLabel, 
                                        onChange: ev => setExportChartYLabel(ev.target.value),
                                        placeholder: 'Auto',
                                        style: { minWidth: '120px' }
                                    })
                                ),
                                e('div', { className: 'export-toggle-container' },
                                    e('span', { className: 'export-toggle-label' + (!exportChartShowCorrelation ? ' active' : '') }, 'No Line'),
                                    e('div', { 
                                        className: 'export-toggle' + (exportChartShowCorrelation ? ' active' : ''),
                                        onClick: () => setExportChartShowCorrelation(!exportChartShowCorrelation)
                                    }),
                                    e('span', { className: 'export-toggle-label' + (exportChartShowCorrelation ? ' active' : '') }, 'Trend Line')
                                ),
                                // Toggle for showing/hiding player/team names
                                e('div', { className: 'export-toggle-container' },
                                    e('span', { className: 'export-toggle-label' + (!exportChartShowLabels ? ' active' : '') }, 'No Names'),
                                    e('div', {
                                        className: 'export-toggle' + (exportChartShowLabels ? ' active' : ''),
                                        onClick: () => setExportChartShowLabels(!exportChartShowLabels)
                                    }),
                                    e('span', { className: 'export-toggle-label' + (exportChartShowLabels ? ' active' : '') }, 'Names')
                                ),
                                // V5.24: Smart Labels toggle - only show outlier names to reduce clutter
                                exportChartShowLabels && exportChartDataMode === 'players' && e('div', { className: 'export-toggle-container' },
                                    e('span', { className: 'export-toggle-label' + (!exportChartSmartLabels ? ' active' : '') }, 'All Names'),
                                    e('div', {
                                        className: 'export-toggle' + (exportChartSmartLabels ? ' active' : ''),
                                        onClick: () => setExportChartSmartLabels(!exportChartSmartLabels)
                                    }),
                                    e('span', { className: 'export-toggle-label' + (exportChartSmartLabels ? ' active' : '') }, 'Smart')
                                ),
                                // V5.24: Team Highlight dropdown (only when all teams shown in player mode)
                                exportChartDataMode === 'players' && exportTeam === '' && e('div', { className: 'export-control-group', style: { marginLeft: '8px' }},
                                    e('label', { style: { fontSize: '10px' }}, 'Highlight'),
                                    e('select', {
                                        value: exportChartHighlightTeam,
                                        onChange: ev => setExportChartHighlightTeam(ev.target.value),
                                        style: { fontSize: '11px', padding: '4px 8px', minWidth: '100px' }
                                    },
                                        e('option', { value: '' }, 'None'),
                                        teams.map(t => e('option', { key: t, value: t }, t))
                                    )
                                ),
                                // Toggle for showing/hiding stat legends
                                e('div', { className: 'export-toggle-container' },
                                    e('span', { className: 'export-toggle-label' + (!exportShowLegend ? ' active' : '') }, 'No Legend'),
                                    e('div', { 
                                        className: 'export-toggle' + (exportShowLegend ? ' active' : ''),
                                        onClick: () => setExportShowLegend(!exportShowLegend)
                                    }),
                                    e('span', { className: 'export-toggle-label' + (exportShowLegend ? ' active' : '') }, 'Legend')
                                ),
                                // V5.8: Relative (ON-OFF) vs Absolute (raw ON) toggle - different labels for teams mode
                                e('div', { className: 'export-toggle-container' },
                                    e('span', { className: 'export-toggle-label' + (!exportChartAbsolute ? ' active' : '') }, 
                                        exportChartDataMode === 'teams' ? 'vs. Lg Avg' : 'ON-OFF'
                                    ),
                                    e('div', { 
                                        className: 'export-toggle' + (exportChartAbsolute ? ' active' : ''),
                                        onClick: () => {
                                            const newAbsolute = !exportChartAbsolute;
                                            setExportChartAbsolute(newAbsolute);
                                            // Reset axes when in teams mode to match new mode
                                            if (exportChartDataMode === 'teams') {
                                                if (newAbsolute) {
                                                    setExportChartX('adjOrtg');
                                                    setExportChartY('adjDrtg');
                                                } else {
                                                    setExportChartX('adjOrtgVsLg');
                                                    setExportChartY('adjDrtgVsLg');
                                                }
                                            }
                                        }
                                    }),
                                    e('span', { className: 'export-toggle-label' + (exportChartAbsolute ? ' active' : '') }, 'Absolute')
                                ),
                                // V5.9: Single vs Twin Plot toggle
                                e('div', { className: 'export-toggle-container' },
                                    e('span', { className: 'export-toggle-label' + (!exportChartTwinPlot ? ' active' : '') }, 'Single'),
                                    e('div', { 
                                        className: 'export-toggle' + (exportChartTwinPlot ? ' active' : ''),
                                        onClick: () => setExportChartTwinPlot(!exportChartTwinPlot)
                                    }),
                                    e('span', { className: 'export-toggle-label' + (exportChartTwinPlot ? ' active' : '') }, 'Twin Plot')
                                ),
                                // Image persistence controls
                                (Object.keys(exportPlayerImages).length > 0 || Object.keys(exportSOSTeamImages).length > 0) && e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' }},
                                    e('span', { style: { fontSize: '10px', color: '#94a3b8' }}, 
                                        '📷 ' + (Object.keys(exportPlayerImages).length + Object.keys(exportSOSTeamImages).length) + ' saved'
                                    ),
                                    e('button', {
                                        onClick: () => {
                                            if (confirm('Clear all saved player/team images from browser storage?')) {
                                                setExportPlayerImages({});
                                                setExportSOSTeamImages({});
                                                localStorage.removeItem('lineupAnalyzer_playerImages');
                                                localStorage.removeItem('lineupAnalyzer_teamImages');
                                            }
                                        },
                                        style: { padding: '2px 6px', fontSize: '9px', background: '#374151', border: '1px solid #4b5563', borderRadius: '4px', color: '#f87171', cursor: 'pointer' }
                                    }, '✕ Clear'),
                                    e('button', {
                                        onClick: () => {
                                            const data = { playerImages: exportPlayerImages, teamImages: exportSOSTeamImages };
                                            const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
                                            const url = URL.createObjectURL(blob);
                                            const a = document.createElement('a');
                                            a.href = url;
                                            a.download = 'lineup_images.json';
                                            a.click();
                                            URL.revokeObjectURL(url);
                                        },
                                        style: { padding: '2px 6px', fontSize: '9px', background: '#374151', border: '1px solid #4b5563', borderRadius: '4px', color: '#60a5fa', cursor: 'pointer' }
                                    }, '💾 Export')
                                ),
                                // Import images button (always visible)
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                    e('label', { 
                                        style: { padding: '2px 6px', fontSize: '9px', background: '#374151', border: '1px solid #4b5563', borderRadius: '4px', color: '#4ade80', cursor: 'pointer', display: 'inline-block' }
                                    },
                                        '📥 Import',
                                        e('input', {
                                            type: 'file',
                                            accept: '.json',
                                            style: { display: 'none' },
                                            onChange: ev => {
                                                const file = ev.target.files[0];
                                                if (!file) return;
                                                const reader = new FileReader();
                                                reader.onload = e => {
                                                    try {
                                                        const data = JSON.parse(e.target.result);
                                                        if (data.playerImages) setExportPlayerImages(prev => ({ ...prev, ...data.playerImages }));
                                                        if (data.teamImages) setExportSOSTeamImages(prev => ({ ...prev, ...data.teamImages }));
                                                        alert('Imported ' + (Object.keys(data.playerImages || {}).length + Object.keys(data.teamImages || {}).length) + ' images');
                                                    } catch (err) {
                                                        alert('Error importing images: ' + err.message);
                                                    }
                                                };
                                                reader.readAsText(file);
                                                ev.target.value = '';
                                            }
                                        })
                                    )
                                ),
                                // V5.7: RAPM calculation with lambda control for chart
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                    // Lambda input
                                    stintsData.length > 0 && e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                        e('label', { style: { fontSize: '10px', color: '#94a3b8' }}, 'λ:'),
                                        e('input', {
                                            type: 'number',
                                            value: rapmLambda,
                                            onChange: ev => setRapmLambda(Math.max(1, parseInt(ev.target.value) || 800)),
                                            style: { width: '60px', padding: '4px 6px', fontSize: '10px', background: '#0f172a', border: '1px solid #475569', borderRadius: '4px', color: 'white' }
                                        })
                                    ),
                                    // Status/Calculate button
                                    playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg 
                                        ? e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' }},
                                            e('span', { style: { fontSize: '10px', color: '#4ade80' }}, '✓ RAPM (λ=' + (playerRapmStats.lambda || rapmLambda) + ')'),
                                            e('button', {
                                                style: { padding: '4px 8px', fontSize: '10px', background: rapmLambda !== playerRapmStats.lambda ? '#7c3aed' : '#1e293b', border: '1px solid #475569', borderRadius: '4px', color: rapmLambda !== playerRapmStats.lambda ? 'white' : '#94a3b8', cursor: 'pointer' },
                                                onClick: triggerPlayerRAPMCalculation
                                            }, rapmLambda !== playerRapmStats.lambda ? '⚡ Recalc' : '↻ Recalc')
                                        )
                                        : isCalculatingPlayerRAPM 
                                            ? e('span', { style: { fontSize: '11px', color: '#60a5fa' }}, '⏳ ' + playerRapmProgress + '%')
                                            : stintsData.length > 0 
                                                ? e('button', {
                                                    style: { padding: '6px 12px', fontSize: '11px', background: 'linear-gradient(135deg, #3b82f6, #2563eb)', border: 'none', borderRadius: '6px', color: 'white', cursor: 'pointer', fontWeight: '600' },
                                                    onClick: triggerPlayerRAPMCalculation
                                                }, '📊 Calculate RAPM')
                                                : e('span', { style: { fontSize: '11px', color: '#64748b' }}, 'Upload stints.csv for RAPM')
                                )
                            )
                        ),
                        
                        // V5.2: Enhanced Four Factors Controls
                        exportMode === 'fourfactors' && e('div', { style: { marginTop: '16px' }},
                            // Row 1: Team mode and order by
                            e('div', { style: { display: 'flex', gap: '16px', flexWrap: 'wrap', marginBottom: '12px' }},
                                e('div', { className: 'export-control-group' },
                                    e('label', null, 'Team Selection'),
                                    e('select', { 
                                        value: exportFFTeamMode, 
                                        onChange: ev => setExportFFTeamMode(ev.target.value)
                                    },
                                        e('option', { value: 'all' }, 'All Teams'),
                                        e('option', { value: 'select' }, 'Select Teams')
                                    )
                                ),
                                e('div', { className: 'export-control-group' },
                                    e('label', null, 'Order By'),
                                    e('select', {
                                        value: exportFFOrderBy,
                                        onChange: ev => setExportFFOrderBy(ev.target.value)
                                    },
                                        // Ratings
                                        e('option', { value: 'net' }, 'Net Rating'),
                                        e('option', { value: 'off' }, 'Offensive Rating'),
                                        e('option', { value: 'def' }, 'Defensive Rating'),
                                        // Four Factors - Offense
                                        e('option', { value: 'offEfg' }, 'Off eFG%'),
                                        e('option', { value: 'offTov' }, 'Off TOV%'),
                                        e('option', { value: 'offOreb' }, 'Off OREB%'),
                                        e('option', { value: 'offFtR' }, 'Off FT Rate'),
                                        // Four Factors - Defense
                                        e('option', { value: 'defEfg' }, 'Def eFG% (Allowed)'),
                                        e('option', { value: 'defTov' }, 'Def TOV% (Forced)'),
                                        e('option', { value: 'defOreb' }, 'Def OREB% (Allowed)'),
                                        e('option', { value: 'defFtR' }, 'Def FT Rate (Allowed)'),
                                        // Extra Stats - Offense
                                        e('option', { value: 'offRimVol' }, 'Off Rim %'),
                                        e('option', { value: 'offRimPct' }, 'Off Rim FG%'),
                                        e('option', { value: 'offThreeVol' }, 'Off 3PT %'),
                                        e('option', { value: 'offThreePct' }, 'Off 3PT FG%'),
                                        e('option', { value: 'offAstPct' }, 'Off AST%'),
                                        // Extra Stats - Defense
                                        e('option', { value: 'defRimVol' }, 'Def Rim % (Allowed)'),
                                        e('option', { value: 'defRimPct' }, 'Def Rim FG% (Allowed)'),
                                        e('option', { value: 'defThreeVol' }, 'Def 3PT % (Allowed)'),
                                        e('option', { value: 'defThreePct' }, 'Def 3PT FG% (Allowed)')
                                    )
                                ),
                                e('div', { className: 'export-control-group' },
                                    e('label', null, 'Date Filter'),
                                    e('select', { 
                                        value: exportFFDateMode, 
                                        onChange: ev => setExportFFDateMode(ev.target.value)
                                    },
                                        e('option', { value: 'all' }, 'All Games'),
                                        e('option', { value: 'after' }, 'After Date'),
                                        e('option', { value: 'before' }, 'Before Date'),
                                        e('option', { value: 'range' }, 'Date Range'),
                                        e('option', { value: 'gamerange' }, 'Game Range (1-N)')
                                    )
                                ),
                                // V5.12: Secondary stats toggle for Four Factors
                                e('div', { className: 'export-toggle-container' },
                                    e('span', { className: 'export-toggle-label' + (!exportFFShowSecondary ? ' active' : '') }, 'Ratings Only'),
                                    e('div', { 
                                        className: 'export-toggle' + (exportFFShowSecondary ? ' active' : ''),
                                        onClick: () => setExportFFShowSecondary(!exportFFShowSecondary)
                                    }),
                                    e('span', { className: 'export-toggle-label' + (exportFFShowSecondary ? ' active' : '') }, '+ Four Factors')
                                ),
                                // V5.12: Sorted stat only toggle
                                e('div', { className: 'export-toggle-container' },
                                    e('span', { className: 'export-toggle-label' + (!exportFFSortedStatOnly ? ' active' : '') }, 'All Stats'),
                                    e('div', { 
                                        className: 'export-toggle' + (exportFFSortedStatOnly ? ' active' : ''),
                                        onClick: () => setExportFFSortedStatOnly(!exportFFSortedStatOnly)
                                    }),
                                    e('span', { className: 'export-toggle-label' + (exportFFSortedStatOnly ? ' active' : '') }, 'Sorted Only')
                                ),
                                // Extra stats toggle (Rim/3PT/AST)
                                e('div', { className: 'export-toggle-container' },
                                    e('span', { className: 'export-toggle-label' + (!exportFFShowExtraStats ? ' active' : '') }, 'Four Factors'),
                                    e('div', { 
                                        className: 'export-toggle' + (exportFFShowExtraStats ? ' active' : ''),
                                        onClick: () => setExportFFShowExtraStats(!exportFFShowExtraStats)
                                    }),
                                    e('span', { className: 'export-toggle-label' + (exportFFShowExtraStats ? ' active' : '') }, '+ Extra Stats')
                                )
                            ),
                            
                            // Date inputs using dropdowns (shown based on date mode)
                            (exportFFDateMode === 'after' || exportFFDateMode === 'range') && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                                e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, exportFFDateMode === 'range' ? 'From:' : 'After:'),
                                // Year dropdown
                                e('select', { 
                                    className: 'export-date-input',
                                    value: exportFFDateYear,
                                    onChange: ev => { setExportFFDateYear(ev.target.value); setExportFFDateAfter(ev.target.value && exportFFDateMonth && exportFFDateDay ? `${ev.target.value}-${exportFFDateMonth}-${exportFFDateDay}` : ''); },
                                    style: { width: '85px' }
                                },
                                    e('option', { value: '' }, 'Year'),
                                    [2020, 2021, 2022, 2023, 2024, 2025, 2026].map(y => e('option', { key: y, value: y }, y))
                                ),
                                // Month dropdown
                                e('select', { 
                                    className: 'export-date-input',
                                    value: exportFFDateMonth,
                                    onChange: ev => { setExportFFDateMonth(ev.target.value); setExportFFDateAfter(exportFFDateYear && ev.target.value && exportFFDateDay ? `${exportFFDateYear}-${ev.target.value}-${exportFFDateDay}` : ''); },
                                    style: { width: '70px' }
                                },
                                    e('option', { value: '' }, 'Mon'),
                                    ['01','02','03','04','05','06','07','08','09','10','11','12'].map((m, i) => e('option', { key: m, value: m }, ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][i]))
                                ),
                                // Day dropdown
                                e('select', { 
                                    className: 'export-date-input',
                                    value: exportFFDateDay,
                                    onChange: ev => { setExportFFDateDay(ev.target.value); setExportFFDateAfter(exportFFDateYear && exportFFDateMonth && ev.target.value ? `${exportFFDateYear}-${exportFFDateMonth}-${ev.target.value}` : ''); },
                                    style: { width: '65px' }
                                },
                                    e('option', { value: '' }, 'Day'),
                                    [...Array(31)].map((_, i) => { const d = String(i + 1).padStart(2, '0'); return e('option', { key: d, value: d }, i + 1); })
                                ),
                                exportFFDateMode === 'range' && e('label', { style: { fontSize: '11px', color: '#94a3b8', marginLeft: '12px' }}, 'To:'),
                                exportFFDateMode === 'range' && e('select', { 
                                    className: 'export-date-input',
                                    value: exportFFDateEndYear,
                                    onChange: ev => { setExportFFDateEndYear(ev.target.value); setExportFFDateBefore(ev.target.value && exportFFDateEndMonth && exportFFDateEndDay ? `${ev.target.value}-${exportFFDateEndMonth}-${exportFFDateEndDay}` : ''); },
                                    style: { width: '85px' }
                                },
                                    e('option', { value: '' }, 'Year'),
                                    [2020, 2021, 2022, 2023, 2024, 2025, 2026].map(y => e('option', { key: y, value: y }, y))
                                ),
                                exportFFDateMode === 'range' && e('select', { 
                                    className: 'export-date-input',
                                    value: exportFFDateEndMonth,
                                    onChange: ev => { setExportFFDateEndMonth(ev.target.value); setExportFFDateBefore(exportFFDateEndYear && ev.target.value && exportFFDateEndDay ? `${exportFFDateEndYear}-${ev.target.value}-${exportFFDateEndDay}` : ''); },
                                    style: { width: '70px' }
                                },
                                    e('option', { value: '' }, 'Mon'),
                                    ['01','02','03','04','05','06','07','08','09','10','11','12'].map((m, i) => e('option', { key: m, value: m }, ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][i]))
                                ),
                                exportFFDateMode === 'range' && e('select', { 
                                    className: 'export-date-input',
                                    value: exportFFDateEndDay,
                                    onChange: ev => { setExportFFDateEndDay(ev.target.value); setExportFFDateBefore(exportFFDateEndYear && exportFFDateEndMonth && ev.target.value ? `${exportFFDateEndYear}-${exportFFDateEndMonth}-${ev.target.value}` : ''); },
                                    style: { width: '65px' }
                                },
                                    e('option', { value: '' }, 'Day'),
                                    [...Array(31)].map((_, i) => { const d = String(i + 1).padStart(2, '0'); return e('option', { key: d, value: d }, i + 1); })
                                ),
                                // Apply button for date filter
                                e('button', {
                                    style: { marginLeft: '12px', padding: '6px 16px', background: exportFFDateApplied ? '#10b981' : '#3b82f6', border: 'none', borderRadius: '6px', color: '#fff', fontWeight: '600', fontSize: '12px', cursor: 'pointer' },
                                    onClick: () => {
                                        // Build date strings from partial inputs (use defaults for missing parts)
                                        const afterDate = exportFFDateYear ? `${exportFFDateYear}-${exportFFDateMonth || '01'}-${exportFFDateDay || '01'}` : '';
                                        const beforeDate = exportFFDateMode === 'range' && exportFFDateEndYear ? `${exportFFDateEndYear}-${exportFFDateEndMonth || '12'}-${exportFFDateEndDay || '31'}` : '';
                                        setExportFFDateAfter(afterDate);
                                        setExportFFDateBefore(beforeDate);
                                        setExportFFDateApplied(true);
                                    }
                                }, exportFFDateApplied ? '✓ Applied' : 'Apply Filter'),
                                exportFFDateApplied && e('button', {
                                    style: { marginLeft: '8px', padding: '6px 12px', background: '#475569', border: 'none', borderRadius: '6px', color: '#fff', fontSize: '11px', cursor: 'pointer' },
                                    onClick: () => { setExportFFDateApplied(false); setExportFFDateAfter(''); setExportFFDateBefore(''); }
                                }, 'Clear')
                            ),
                            (exportFFDateMode === 'before') && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                                e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Before:'),
                                e('select', { 
                                    className: 'export-date-input',
                                    value: exportFFDateEndYear,
                                    onChange: ev => { setExportFFDateEndYear(ev.target.value); setExportFFDateApplied(false); },
                                    style: { width: '85px' }
                                },
                                    e('option', { value: '' }, 'Year'),
                                    [2020, 2021, 2022, 2023, 2024, 2025, 2026].map(y => e('option', { key: y, value: y }, y))
                                ),
                                e('select', { 
                                    className: 'export-date-input',
                                    value: exportFFDateEndMonth,
                                    onChange: ev => { setExportFFDateEndMonth(ev.target.value); setExportFFDateApplied(false); },
                                    style: { width: '70px' }
                                },
                                    e('option', { value: '' }, 'Mon'),
                                    ['01','02','03','04','05','06','07','08','09','10','11','12'].map((m, i) => e('option', { key: m, value: m }, ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][i]))
                                ),
                                e('select', { 
                                    className: 'export-date-input',
                                    value: exportFFDateEndDay,
                                    onChange: ev => { setExportFFDateEndDay(ev.target.value); setExportFFDateApplied(false); },
                                    style: { width: '65px' }
                                },
                                    e('option', { value: '' }, 'Day'),
                                    [...Array(31)].map((_, i) => { const d = String(i + 1).padStart(2, '0'); return e('option', { key: d, value: d }, i + 1); })
                                ),
                                // Apply button
                                e('button', {
                                    style: { marginLeft: '12px', padding: '6px 16px', background: exportFFDateApplied ? '#10b981' : '#3b82f6', border: 'none', borderRadius: '6px', color: '#fff', fontWeight: '600', fontSize: '12px', cursor: 'pointer' },
                                    onClick: () => {
                                        const beforeDate = exportFFDateEndYear ? `${exportFFDateEndYear}-${exportFFDateEndMonth || '12'}-${exportFFDateEndDay || '31'}` : '';
                                        setExportFFDateBefore(beforeDate);
                                        setExportFFDateApplied(true);
                                    }
                                }, exportFFDateApplied ? '✓ Applied' : 'Apply Filter'),
                                exportFFDateApplied && e('button', {
                                    style: { marginLeft: '8px', padding: '6px 12px', background: '#475569', border: 'none', borderRadius: '6px', color: '#fff', fontSize: '11px', cursor: 'pointer' },
                                    onClick: () => { setExportFFDateApplied(false); setExportFFDateBefore(''); }
                                }, 'Clear')
                            ),
                            // Game range inputs (shown when gamerange mode selected)
                            exportFFDateMode === 'gamerange' && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                                e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'From Game:'),
                                e('input', { 
                                    type: 'number', 
                                    className: 'export-date-input',
                                    value: exportFFGameRange.start,
                                    min: 1,
                                    onChange: ev => setExportFFGameRange(prev => ({ ...prev, start: parseInt(ev.target.value) || 1 })),
                                    style: { width: '70px' }
                                }),
                                e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'To Game:'),
                                e('input', { 
                                    type: 'number', 
                                    className: 'export-date-input',
                                    value: exportFFGameRange.end,
                                    min: 1,
                                    onChange: ev => setExportFFGameRange(prev => ({ ...prev, end: parseInt(ev.target.value) || 100 })),
                                    style: { width: '70px' }
                                }),
                                e('span', { style: { fontSize: '10px', color: '#64748b', marginLeft: '8px' }}, 
                                    stintsData.length > 0 ? '(stints data loaded)' : teamTotalsData.length > 0 ? '(team_totals loaded)' : '(load stints.csv or team_totals.csv for game dates)'
                                )
                            ),
                            
                            // Team selection pills (shown when in select mode)
                            exportFFTeamMode === 'select' && e('div', { style: { marginBottom: '12px' }},
                                e('label', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '8px', display: 'block' }}, 
                                    'Select Teams (click to toggle, max 4):'
                                ),
                                e('div', { className: 'export-team-pills' },
                                    teams.map(t => e('div', {
                                        key: t,
                                        className: 'export-team-pill' + (exportFFSelectedTeams.includes(t) ? ' selected' : ''),
                                        onClick: () => {
                                            if (exportFFSelectedTeams.includes(t)) {
                                                setExportFFSelectedTeams(prev => prev.filter(x => x !== t));
                                            } else if (exportFFSelectedTeams.length < 4) {
                                                setExportFFSelectedTeams(prev => [...prev, t]);
                                            }
                                        }
                                    }, t))
                                )
                            ),
                            
                            // Stats to show
                            e('div', { style: { marginBottom: '12px' }},
                                e('label', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '8px', display: 'block' }}, 
                                    'Stats to Display:'
                                ),
                                e('div', { className: 'export-stat-checkboxes' },
                                    [
                                        { key: 'offEfg', label: 'Off eFG%' },
                                        { key: 'offTov', label: 'Off TOV%' },
                                        { key: 'offOreb', label: 'Off OREB%' },
                                        { key: 'offFtR', label: 'Off FT Rate' },
                                        { key: 'defEfg', label: 'Def eFG%' },
                                        { key: 'defTov', label: 'Def TOV%' },
                                        { key: 'defOreb', label: 'Def OREB%' },
                                        { key: 'defFtR', label: 'Def FT Rate' }
                                    ].map(stat => e('div', {
                                        key: stat.key,
                                        className: 'export-stat-checkbox' + (exportFFShowStats.includes(stat.key) ? ' selected' : ''),
                                        onClick: () => {
                                            if (exportFFShowStats.includes(stat.key)) {
                                                setExportFFShowStats(prev => prev.filter(s => s !== stat.key));
                                            } else {
                                                setExportFFShowStats(prev => [...prev, stat.key]);
                                            }
                                        }
                                    }, stat.label))
                                )
                            )
                        ),
                        
                        // Shot Distribution Controls (V5.4: Enhanced with date filtering)
                        exportMode === 'shotdist' && e(React.Fragment, null,
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Team Mode'),
                                e('select', { 
                                    value: exportShotTeamMode, 
                                    onChange: ev => setExportShotTeamMode(ev.target.value)
                                },
                                    e('option', { value: 'single' }, 'Single Team'),
                                    e('option', { value: 'all' }, 'All Teams')
                                )
                            ),
                            exportShotTeamMode === 'single' && e('div', { className: 'export-control-group' },
                                e('label', null, 'Team'),
                                e('select', { 
                                    value: exportShotTeam, 
                                    onChange: ev => setExportShotTeam(ev.target.value)
                                },
                                    teams.map(t => e('option', { key: t, value: t }, t))
                                )
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Date Filter'),
                                e('select', { 
                                    value: exportShotDateMode, 
                                    onChange: ev => setExportShotDateMode(ev.target.value)
                                },
                                    e('option', { value: 'all' }, 'All Games'),
                                    e('option', { value: 'after' }, 'After Date'),
                                    e('option', { value: 'before' }, 'Before Date'),
                                    e('option', { value: 'range' }, 'Date Range'),
                                    e('option', { value: 'gamerange' }, 'Game Range (1-N)')
                                )
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Min Minutes'),
                                e('input', {
                                    type: 'number',
                                    value: exportMinPoss,
                                    onChange: ev => setExportMinPoss(parseInt(ev.target.value) || 0),
                                    min: 0,
                                    style: { width: '80px' }
                                })
                            )
                        ),
                        // Shot Distribution date inputs
                        exportMode === 'shotdist' && (exportShotDateMode === 'after' || exportShotDateMode === 'range') && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, exportShotDateMode === 'range' ? 'From:' : 'After:'),
                            e('input', { 
                                type: 'date', 
                                className: 'export-date-input',
                                value: exportShotDateAfter,
                                onChange: ev => setExportShotDateAfter(ev.target.value)
                            }),
                            exportShotDateMode === 'range' && e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'To:'),
                            exportShotDateMode === 'range' && e('input', { 
                                type: 'date', 
                                className: 'export-date-input',
                                value: exportShotDateBefore,
                                onChange: ev => setExportShotDateBefore(ev.target.value)
                            })
                        ),
                        exportMode === 'shotdist' && exportShotDateMode === 'before' && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Before:'),
                            e('input', { 
                                type: 'date', 
                                className: 'export-date-input',
                                value: exportShotDateBefore,
                                onChange: ev => setExportShotDateBefore(ev.target.value)
                            })
                        ),
                        exportMode === 'shotdist' && exportShotDateMode === 'gamerange' && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'From Game:'),
                            e('input', { 
                                type: 'number', 
                                className: 'export-date-input',
                                value: exportShotGameRange.start,
                                min: 1,
                                onChange: ev => setExportShotGameRange(prev => ({ ...prev, start: parseInt(ev.target.value) || 1 })),
                                style: { width: '70px' }
                            }),
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'To Game:'),
                            e('input', { 
                                type: 'number', 
                                className: 'export-date-input',
                                value: exportShotGameRange.end,
                                min: 1,
                                onChange: ev => setExportShotGameRange(prev => ({ ...prev, end: parseInt(ev.target.value) || 100 })),
                                style: { width: '70px' }
                            }),
                            e('span', { style: { fontSize: '10px', color: '#64748b', marginLeft: '8px' }}, 
                                stintsData.length > 0 || teamTotalsData.length > 0 ? '✓' : '(load stints/team_totals for dates)'
                            )
                        ),
                        // Shot Distribution player filter (only for single team)
                        exportMode === 'shotdist' && exportShotTeamMode === 'single' && e('div', { style: { display: 'flex', gap: '8px', alignItems: 'flex-end', marginTop: '8px' }},
                            e('span', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '10px' }}, 'Optional player filter:'),
                            [...Array(5)].map((_, i) => {
                                const currentTeam = exportShotTeam;
                                const players = exportShotPlayers;
                                const setPlayers = setExportShotPlayers;
                                // V6.1: Apply merge rules for player list
                                const teamPlayers = currentTeam ? [...new Set(lineupData.filter(l => l.Team === currentTeam).flatMap(l => {
                                    if (!l.Lineup) return [];
                                    return l.Lineup.split(',').map(p => applyPlayerMerge(p.trim())).filter(Boolean);
                                }))].sort() : [];
                                return e('select', {
                                    key: i,
                                    value: players['p' + (i+1)] || '',
                                    onChange: ev => setPlayers(prev => ({ ...prev, ['p' + (i+1)]: ev.target.value })),
                                    style: { width: '100px', padding: '6px', fontSize: '11px' }
                                },
                                    e('option', { value: '' }, 'Any'),
                                    teamPlayers.map(p => e('option', { key: p, value: p }, p.split(' ').pop()))
                                );
                            })
                        ),
                        
                        exportMode === 'lineups' && e(React.Fragment, null,
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Team Mode'),
                                e('select', { 
                                    value: exportLineupTeamMode, 
                                    onChange: ev => setExportLineupTeamMode(ev.target.value)
                                },
                                    e('option', { value: 'single' }, 'Single Team'),
                                    e('option', { value: 'all' }, 'All Teams')
                                )
                            ),
                            exportLineupTeamMode === 'single' && e('div', { className: 'export-control-group' },
                                e('label', null, 'Team'),
                                e('select', { 
                                    value: exportLineupTeam, 
                                    onChange: ev => setExportLineupTeam(ev.target.value)
                                },
                                    teams.map(t => e('option', { key: t, value: t }, t))
                                )
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Sort By'),
                                e('select', { 
                                    value: exportLineupSortBy, 
                                    onChange: ev => setExportLineupSortBy(ev.target.value)
                                },
                                    e('option', { value: 'netRtg' }, 'Net Rating'),
                                    e('option', { value: 'offRtg' }, 'Offensive Rating'),
                                    e('option', { value: 'defRtg' }, 'Defensive Rating (Low)')
                                )
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Date Filter'),
                                e('select', { 
                                    value: exportLineupDateMode, 
                                    onChange: ev => setExportLineupDateMode(ev.target.value)
                                },
                                    e('option', { value: 'all' }, 'All Games'),
                                    e('option', { value: 'after' }, 'After Date'),
                                    e('option', { value: 'before' }, 'Before Date'),
                                    e('option', { value: 'range' }, 'Date Range'),
                                    e('option', { value: 'gamerange' }, 'Game Range (1-N)')
                                )
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Min Poss'),
                                e('input', { 
                                    type: 'number', 
                                    value: exportLineupMinPoss, 
                                    onChange: ev => setExportLineupMinPoss(parseInt(ev.target.value) || 0),
                                    min: 0,
                                    style: { width: '70px' }
                                })
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Top N'),
                                e('input', { 
                                    type: 'number', 
                                    value: exportTopN, 
                                    onChange: ev => setExportTopN(parseInt(ev.target.value) || 5),
                                    min: 1,
                                    max: 20,
                                    style: { width: '60px' }
                                })
                            ),
                            // Luck adjustment sliders for Best Lineups - Offense
                            e('div', { className: 'export-control-group', style: { minWidth: '120px' }},
                                e('label', null, '🎲 Off Luck'),
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                    e('input', { 
                                        type: 'range', 
                                        min: 0, 
                                        max: 100, 
                                        value: exportLineupOffLuckAdj, 
                                        onChange: ev => setExportLineupOffLuckAdj(parseInt(ev.target.value)),
                                        style: { width: '60px' }
                                    }),
                                    e('span', { style: { fontSize: '10px', color: exportLineupOffLuckAdj > 0 ? '#4ade80' : '#64748b', minWidth: '28px' }}, exportLineupOffLuckAdj + '%')
                                )
                            ),
                            // Luck adjustment sliders for Best Lineups - Defense
                            e('div', { className: 'export-control-group', style: { minWidth: '120px' }},
                                e('label', null, '🎲 Def Luck'),
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                    e('input', { 
                                        type: 'range', 
                                        min: 0, 
                                        max: 100, 
                                        value: exportLineupDefLuckAdj, 
                                        onChange: ev => setExportLineupDefLuckAdj(parseInt(ev.target.value)),
                                        style: { width: '60px' }
                                    }),
                                    e('span', { style: { fontSize: '10px', color: exportLineupDefLuckAdj > 0 ? '#f87171' : '#64748b', minWidth: '28px' }}, exportLineupDefLuckAdj + '%')
                                )
                            )
                        ),
                        // Best Lineups date inputs
                        exportMode === 'lineups' && (exportLineupDateMode === 'after' || exportLineupDateMode === 'range') && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, exportLineupDateMode === 'range' ? 'From:' : 'After:'),
                            e('input', { 
                                type: 'date', 
                                className: 'export-date-input',
                                value: exportLineupDateAfter,
                                onChange: ev => setExportLineupDateAfter(ev.target.value)
                            }),
                            exportLineupDateMode === 'range' && e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'To:'),
                            exportLineupDateMode === 'range' && e('input', { 
                                type: 'date', 
                                className: 'export-date-input',
                                value: exportLineupDateBefore,
                                onChange: ev => setExportLineupDateBefore(ev.target.value)
                            })
                        ),
                        exportMode === 'lineups' && exportLineupDateMode === 'before' && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Before:'),
                            e('input', { 
                                type: 'date', 
                                className: 'export-date-input',
                                value: exportLineupDateBefore,
                                onChange: ev => setExportLineupDateBefore(ev.target.value)
                            })
                        ),
                        exportMode === 'lineups' && exportLineupDateMode === 'gamerange' && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'From Game:'),
                            e('input', { 
                                type: 'number', 
                                className: 'export-date-input',
                                value: exportLineupGameRange.start,
                                min: 1,
                                onChange: ev => setExportLineupGameRange(prev => ({ ...prev, start: parseInt(ev.target.value) || 1 })),
                                style: { width: '70px' }
                            }),
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'To Game:'),
                            e('input', { 
                                type: 'number', 
                                className: 'export-date-input',
                                value: exportLineupGameRange.end,
                                min: 1,
                                onChange: ev => setExportLineupGameRange(prev => ({ ...prev, end: parseInt(ev.target.value) || 100 })),
                                style: { width: '70px' }
                            })
                        ),
                        
                        exportMode === 'wowy' && e(React.Fragment, null,
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Team'),
                                e('select', { 
                                    value: exportWowyTeam || exportTeam, 
                                    onChange: ev => { setExportWowyTeam(ev.target.value); setExportWowyPlayers([]); setExportWowyPlayer(''); setExportWowySelectedPlayers([]); }
                                },
                                    teams.map(t => e('option', { key: t, value: t }, t))
                                )
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Mode'),
                                e('select', {
                                    value: exportWowyShowTeammateImpact ? 'teammate-impact' : exportWowyMode,
                                    onChange: ev => {
                                        if (ev.target.value === 'teammate-impact') {
                                            setExportWowyShowTeammateImpact(true);
                                            setExportWowyMode('single');
                                        } else {
                                            setExportWowyShowTeammateImpact(false);
                                            setExportWowyMode(ev.target.value);
                                        }
                                    }
                                },
                                    e('option', { value: 'single' }, 'Single Player'),
                                    e('option', { value: 'combinations' }, 'Best Combinations'),
                                    e('option', { value: 'teammate-impact' }, 'Teammate Impact')
                                )
                            ),
                            // V5.5: Combo size selector (like main WOWY tab)
                            exportWowyMode === 'combinations' && e('div', { className: 'export-control-group' },
                                e('label', null, 'Combo Size'),
                                e('select', { 
                                    value: exportWowyCombosSize, 
                                    onChange: ev => setExportWowyCombosSize(parseInt(ev.target.value))
                                },
                                    e('option', { value: 2 }, '2-Player'),
                                    e('option', { value: 3 }, '3-Player'),
                                    e('option', { value: 4 }, '4-Player'),
                                    e('option', { value: 5 }, '5-Player')
                                )
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Date Filter'),
                                e('select', { 
                                    value: exportWowyDateMode, 
                                    onChange: ev => setExportWowyDateMode(ev.target.value)
                                },
                                    e('option', { value: 'all' }, 'All Games'),
                                    e('option', { value: 'after' }, 'After Date'),
                                    e('option', { value: 'before' }, 'Before Date'),
                                    e('option', { value: 'range' }, 'Date Range'),
                                    e('option', { value: 'gamerange' }, 'Game Range (1-N)')
                                )
                            ),
                            e('div', { className: 'export-control-group' },
                                e('label', null, 'Min Minutes'),
                                e('input', { 
                                    type: 'number', 
                                    value: exportWowyMinPoss, 
                                    onChange: ev => setExportWowyMinPoss(parseInt(ev.target.value) || 0),
                                    min: 0,
                                    style: { width: '70px' }
                                })
                            ),
                            exportWowyMode === 'combinations' && e('div', { className: 'export-control-group' },
                                e('label', null, 'Show Top'),
                                e('select', { 
                                    value: exportWowyCombosTopN, 
                                    onChange: ev => setExportWowyCombosTopN(parseInt(ev.target.value))
                                },
                                    e('option', { value: 5 }, '5'),
                                    e('option', { value: 10 }, '10'),
                                    e('option', { value: 15 }, '15'),
                                    e('option', { value: 20 }, '20')
                                )
                            ),
                            exportWowyMode === 'combinations' && e('div', { className: 'export-control-group' },
                                e('label', null, 'Sort'),
                                e('select', { 
                                    value: exportWowySortAsc ? 'asc' : 'desc', 
                                    onChange: ev => setExportWowySortAsc(ev.target.value === 'asc')
                                },
                                    e('option', { value: 'desc' }, 'Best → Worst'),
                                    e('option', { value: 'asc' }, 'Worst → Best')
                                )
                            ),
                            // Luck adjustment sliders for WOWY - Offense
                            e('div', { className: 'export-control-group', style: { minWidth: '120px' }},
                                e('label', null, '🎲 Off Luck'),
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                    e('input', { 
                                        type: 'range', 
                                        min: 0, 
                                        max: 100, 
                                        value: exportWowyOffLuckAdj, 
                                        onChange: ev => setExportWowyOffLuckAdj(parseInt(ev.target.value)),
                                        style: { width: '60px' }
                                    }),
                                    e('span', { style: { fontSize: '10px', color: exportWowyOffLuckAdj > 0 ? '#4ade80' : '#64748b', minWidth: '28px' }}, exportWowyOffLuckAdj + '%')
                                )
                            ),
                            // Luck adjustment sliders for WOWY - Defense
                            e('div', { className: 'export-control-group', style: { minWidth: '120px' }},
                                e('label', null, '🎲 Def Luck'),
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                    e('input', { 
                                        type: 'range', 
                                        min: 0, 
                                        max: 100, 
                                        value: exportWowyDefLuckAdj, 
                                        onChange: ev => setExportWowyDefLuckAdj(parseInt(ev.target.value)),
                                        style: { width: '60px' }
                                    }),
                                    e('span', { style: { fontSize: '10px', color: exportWowyDefLuckAdj > 0 ? '#f87171' : '#64748b', minWidth: '28px' }}, exportWowyDefLuckAdj + '%')
                                )
                            ),
                            // V5.6: Show teammates toggle for single player mode
                            exportWowyMode === 'single' && !exportWowyShowTeammateImpact && e('div', { className: 'export-toggle-container' },
                                e('span', { className: 'export-toggle-label' + (!exportWowyShowTeammates ? ' active' : '') }, 'Main Only'),
                                e('div', {
                                    className: 'export-toggle' + (exportWowyShowTeammates ? ' active' : ''),
                                    onClick: () => setExportWowyShowTeammates(!exportWowyShowTeammates)
                                }),
                                e('span', { className: 'export-toggle-label' + (exportWowyShowTeammates ? ' active' : '') }, '+ Teammates')
                            ),
                            // V5.13: Table View toggle for all WOWY modes
                            e('div', { className: 'export-toggle-container' },
                                e('span', { className: 'export-toggle-label' + (!exportWowyTableView ? ' active' : '') }, 'Cards'),
                                e('div', {
                                    className: 'export-toggle' + (exportWowyTableView ? ' active' : ''),
                                    onClick: () => setExportWowyTableView(!exportWowyTableView)
                                }),
                                e('span', { className: 'export-toggle-label' + (exportWowyTableView ? ' active' : '') }, 'Table')
                            )
                        ),
                        // WOWY date inputs
                        exportMode === 'wowy' && (exportWowyDateMode === 'after' || exportWowyDateMode === 'range') && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, exportWowyDateMode === 'range' ? 'From:' : 'After:'),
                            e('input', { 
                                type: 'date', 
                                className: 'export-date-input',
                                value: exportWowyDateAfter,
                                onChange: ev => setExportWowyDateAfter(ev.target.value)
                            }),
                            exportWowyDateMode === 'range' && e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'To:'),
                            exportWowyDateMode === 'range' && e('input', { 
                                type: 'date', 
                                className: 'export-date-input',
                                value: exportWowyDateBefore,
                                onChange: ev => setExportWowyDateBefore(ev.target.value)
                            })
                        ),
                        exportMode === 'wowy' && exportWowyDateMode === 'before' && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Before:'),
                            e('input', { 
                                type: 'date', 
                                className: 'export-date-input',
                                value: exportWowyDateBefore,
                                onChange: ev => setExportWowyDateBefore(ev.target.value)
                            })
                        ),
                        exportMode === 'wowy' && exportWowyDateMode === 'gamerange' && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'From Game:'),
                            e('input', { 
                                type: 'number', 
                                className: 'export-date-input',
                                value: exportWowyGameRange.start,
                                min: 1,
                                onChange: ev => setExportWowyGameRange(prev => ({ ...prev, start: parseInt(ev.target.value) || 1 })),
                                style: { width: '70px' }
                            }),
                            e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'To Game:'),
                            e('input', { 
                                type: 'number', 
                                className: 'export-date-input',
                                value: exportWowyGameRange.end,
                                min: 1,
                                onChange: ev => setExportWowyGameRange(prev => ({ ...prev, end: parseInt(ev.target.value) || 100 })),
                                style: { width: '70px' }
                            })
                        ),
                        // WOWY Player Selection (shown below controls) - V5.5 multi-player support
                        exportMode === 'wowy' && exportWowyMode === 'single' && e('div', { className: 'export-wowy-player-grid', style: { marginTop: '16px', marginBottom: '20px' }},
                            e('div', { style: { width: '100%', marginBottom: '12px', fontSize: '12px', color: '#94a3b8' }}, 
                                'Select players for WOWY analysis (click to toggle):',
                                exportWowySelectedPlayers.length > 0 && e('span', { style: { color: '#4ade80', marginLeft: '8px' }}, 
                                    exportWowySelectedPlayers.length + ' player' + (exportWowySelectedPlayers.length > 1 ? 's' : '') + ' selected'
                                )
                            ),
                            (() => {
                                const currentTeam = exportWowyTeam || exportTeam || (teams.length > 0 ? teams[0] : '');
                                // V6.1: Apply merge rules for player list
                                const teamPlayers = currentTeam ? [...new Set(lineupData.filter(l => l.Team === currentTeam).flatMap(l => {
                                    if (!l.Lineup) return [];
                                    return l.Lineup.split(',').map(p => applyPlayerMerge(p.trim())).filter(Boolean);
                                }))].sort() : [];
                                
                                const toggleWowyPlayer = (player) => {
                                    if (exportWowySelectedPlayers.includes(player)) {
                                        setExportWowySelectedPlayers(prev => prev.filter(p => p !== player));
                                    } else if (exportWowySelectedPlayers.length < 5) {
                                        setExportWowySelectedPlayers(prev => [...prev, player]);
                                    }
                                };
                                
                                return teamPlayers.map(player => 
                                    e('div', {
                                        key: player,
                                        className: 'export-wowy-player-btn' + (exportWowySelectedPlayers.includes(player) ? ' selected' : ''),
                                        onClick: () => toggleWowyPlayer(player)
                                    },
                                        e('div', { className: 'export-wowy-player-circle' }, getInitials(player)),
                                        e('div', { className: 'export-wowy-player-name-label' }, getDisplayName(player, true))
                                    )
                                );
                            })()
                        )
                    ),
                    
                    // SOS Export Controls
                    exportMode === 'sos' && teamTotalsData.length > 0 && e('div', { className: 'export-controls', style: { marginTop: '8px' }},
                        e('div', { className: 'export-control-group' },
                            e('label', null, 'Date Filter'),
                            e('select', { 
                                value: exportSOSDateMode, 
                                onChange: ev => setExportSOSDateMode(ev.target.value)
                            },
                                e('option', { value: 'all' }, 'All Games'),
                                e('option', { value: 'after' }, 'After Date'),
                                e('option', { value: 'before' }, 'Before Date'),
                                e('option', { value: 'range' }, 'Date Range'),
                                e('option', { value: 'gamerange' }, 'Game Range (1-N)')
                            )
                        ),
                        // Toggle Points Added view
                        e('div', { className: 'export-toggle-container' },
                            e('span', { className: 'export-toggle-label' + (!exportSOSShowPA ? ' active' : '') }, 'Ratings Only'),
                            e('div', { 
                                className: 'export-toggle' + (exportSOSShowPA ? ' active' : ''),
                                onClick: () => setExportSOSShowPA(!exportSOSShowPA)
                            }),
                            e('span', { className: 'export-toggle-label' + (exportSOSShowPA ? ' active' : '') }, '+ Points Added')
                        ),
                        // Toggle view mode (cards vs tables)
                        e('div', { className: 'export-toggle-container' },
                            e('span', { className: 'export-toggle-label' + (exportSOSViewMode === 'cards' ? ' active' : '') }, '📇 Cards'),
                            e('div', { 
                                className: 'export-toggle' + (exportSOSViewMode === 'tables' ? ' active' : ''),
                                onClick: () => setExportSOSViewMode(exportSOSViewMode === 'cards' ? 'tables' : 'cards')
                            }),
                            e('span', { className: 'export-toggle-label' + (exportSOSViewMode === 'tables' ? ' active' : '') }, '📊 Tables')
                        )
                    ),
                    // SOS Date inputs
                    exportMode === 'sos' && (exportSOSDateMode === 'after' || exportSOSDateMode === 'range') && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                        e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, exportSOSDateMode === 'range' ? 'From:' : 'After:'),
                        e('input', { 
                            type: 'date', 
                            className: 'export-date-input',
                            value: exportSOSDateAfter,
                            onChange: ev => setExportSOSDateAfter(ev.target.value)
                        })
                    ),
                    exportMode === 'sos' && (exportSOSDateMode === 'before' || exportSOSDateMode === 'range') && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                        e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, exportSOSDateMode === 'range' ? 'To:' : 'Before:'),
                        e('input', { 
                            type: 'date', 
                            className: 'export-date-input',
                            value: exportSOSDateBefore,
                            onChange: ev => setExportSOSDateBefore(ev.target.value)
                        })
                    ),
                    exportMode === 'sos' && exportSOSDateMode === 'gamerange' && e('div', { className: 'export-date-inputs', style: { marginBottom: '12px' }},
                        e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'From Game:'),
                        e('input', { 
                            type: 'number', 
                            className: 'export-date-input',
                            value: exportSOSGameRange.start,
                            min: 1,
                            onChange: ev => setExportSOSGameRange(prev => ({ ...prev, start: parseInt(ev.target.value) || 1 })),
                            style: { width: '70px' }
                        }),
                        e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'To Game:'),
                        e('input', { 
                            type: 'number', 
                            className: 'export-date-input',
                            value: exportSOSGameRange.end,
                            min: 1,
                            onChange: ev => setExportSOSGameRange(prev => ({ ...prev, end: parseInt(ev.target.value) || 100 })),
                            style: { width: '70px' }
                        })
                    ),
                    // SOS notice when team_totals not loaded
                    exportMode === 'sos' && teamTotalsData.length === 0 && e('div', { style: { textAlign: 'center', padding: '40px', background: 'rgba(251, 191, 36, 0.15)', borderRadius: '12px', border: '1px solid rgba(251, 191, 36, 0.3)', marginTop: '20px' }},
                        e('div', { style: { fontSize: '16px', color: '#fbbf24', fontWeight: '600', marginBottom: '8px' }}, '⚠️ team_totals.csv Required'),
                        e('div', { style: { fontSize: '13px', color: '#94a3b8' }}, 'Load team_totals.csv to use the SOS Export View')
                    ),
                    
                    // Export Frame - The actual exportable content
                    e('div', { className: 'export-frame', id: 'exportFrame' },
                        // Header
                        e('div', { className: 'export-frame-header' },
                            e('div', { className: 'export-frame-title' }, exportTitle),
                            e('div', { className: 'export-frame-subtitle' }, exportSubtitle)
                        ),
                        
                        // Leaderboard Export
                        exportMode === 'leaderboard' && (() => {
                            // Get leaderboard data from onOffData (already calculated correctly)
                            const statConfig = {
                                'net': { label: 'Net Rtg', higherBetter: true },
                                'off': { label: 'Off Rtg', higherBetter: true },
                                'def': { label: 'Def Rtg', higherBetter: false },
                                'bpm': { label: 'BPM', higherBetter: true },
                                'obpm': { label: 'OBPM', higherBetter: true },
                                'dbpm': { label: 'DBPM', higherBetter: true },
                                // V5.11: Bayesian Box APM
                                'apm': { label: '🔮 APM', higherBetter: true },
                                'oapm': { label: '🔮 OAPM', higherBetter: true },
                                'dapm': { label: '🔮 DAPM', higherBetter: true },
                                'rapm': { label: 'RAPM', higherBetter: true },
                                'orapm': { label: 'ORAPM', higherBetter: true },
                                'drapm': { label: 'DRAPM', higherBetter: true },
                                // Single-stat RAPM
                                'rapmOffEfg': { label: 'RAPM Off eFG%', higherBetter: true },
                                'rapmDefEfg': { label: 'RAPM Def eFG%', higherBetter: false },
                                'rapmOffTov': { label: 'RAPM Off TOV%', higherBetter: false },
                                'rapmDefTov': { label: 'RAPM Def TOV%', higherBetter: false },
                                'rapmOffOreb': { label: 'RAPM Off OREB%', higherBetter: true },
                                'rapmDefOreb': { label: 'RAPM Def OREB%', higherBetter: false },
                                'rapmOffFtr': { label: 'RAPM Off FTR', higherBetter: true },
                                'rapmDefFtr': { label: 'RAPM Def FTR', higherBetter: false },
                                'rapmOffAst': { label: 'RAPM Off AST%', higherBetter: true },
                                'rapmStl': { label: 'RAPM STL%', higherBetter: true },
                                'rapmBlk': { label: 'RAPM BLK%', higherBetter: true },
                                'fourFactorsImpact': { label: '⚡ FF Impact', higherBetter: true },
                                'scoringBattleImpact': { label: '🎯 Scoring', higherBetter: true },
                                'possBattleImpact': { label: '🔄 Possession', higherBetter: true },
                                'offEfg': { label: 'eFG%', higherBetter: true },
                                'defEfg': { label: 'Opp eFG%', higherBetter: false },
                                'offOreb': { label: 'OREB%', higherBetter: true },
                                'defOreb': { label: 'Opp OREB%', higherBetter: false },
                                'offTov': { label: 'TOV%', higherBetter: false },
                                'defTov': { label: 'Forced TO%', higherBetter: true },
                                'offFtR': { label: 'FT Rate', higherBetter: true },
                                'defFtR': { label: 'Opp FT Rate', higherBetter: false },
                                'rimPct': { label: 'Rim%', higherBetter: true },
                                'midPct': { label: 'Mid%', higherBetter: true },
                                'threePct': { label: '3PT%', higherBetter: true },
                                'rimVol': { label: 'Rim Vol', higherBetter: true },
                                'midVol': { label: 'Mid Vol', higherBetter: false },
                                'threeVol': { label: '3PT Vol', higherBetter: true },
                                'rimVolV': { label: 'Def Rim Vol', higherBetter: false },
                                'midVolV': { label: 'Def Mid Vol', higherBetter: true },
                                'threeVolV': { label: 'Def 3PT Vol', higherBetter: false },
                                'stlPct': { label: 'STL%', higherBetter: true },
                                'blkPct': { label: 'BLK%', higherBetter: true },
                                'astPct': { label: 'AST%', higherBetter: true },
                                'paceF': { label: 'Off Pace', higherBetter: true },
                                'paceV': { label: 'Def Pace', higherBetter: false },
                                'bpmImpactCombos': { label: 'BPM Impact Combos', higherBetter: true, isCombo: true },
                                'bpmImpactZScore': { label: 'BPM Impact Z-Score', higherBetter: false, isCombo: true },
                                'perImpactCombos': { label: 'PER Impact Combos', higherBetter: true, isCombo: true },
                                'perImpactZScore': { label: 'PER Impact Z-Score', higherBetter: false, isCombo: true },
                                // V5.15: Individual per-75 stats (same names as leaderboard individual tab)
                                'usage': { label: 'Usage %', higherBetter: true },
                                'pts75': { label: 'PTS/75', higherBetter: true },
                                'reb75': { label: 'REB/75', higherBetter: true },
                                'oreb75': { label: 'OREB/75', higherBetter: true },
                                'dreb75': { label: 'DREB/75', higherBetter: true },
                                'ast75': { label: 'AST/75', higherBetter: true },
                                'astUsgRatio': { label: 'AST/USG', higherBetter: true },
                                'stl75': { label: 'STL/75', higherBetter: true },
                                'blk75': { label: 'BLK/75', higherBetter: true },
                                'tov75': { label: 'TOV/75', higherBetter: false },
                                'tsPct': { label: 'TS%', higherBetter: true },
                                'rimA75': { label: 'RIM ATT/75', higherBetter: true },
                                'midA75': { label: 'MID ATT/75', higherBetter: false },
                                'threeA75': { label: '3PT ATT/75', higherBetter: true },
                                'tpc75': { label: 'TPC/75', higherBetter: true },
                                'playerAstPct': { label: 'AST%', higherBetter: true },
                                'passTo': { label: 'Pass TOs', higherBetter: false },
                                'dribTo': { label: 'Dribble TOs', higherBetter: false },
                                'ptsAst75': { label: 'PTS AST/75', higherBetter: true },
                                'secChancePts75': { label: '2nd Chance/75', higherBetter: true },
                                'fastBreakPts75': { label: 'Fast Break/75', higherBetter: true },
                                'clutchPts75': { label: 'Clutch/75', higherBetter: true }
                            }[exportStat] || { label: 'Net Rtg', higherBetter: true };
                            
                            // Full stat config for all stats (including individual mode stats)
                            const allStatConfig = {
                                'net': { label: 'Net Rtg', higherBetter: true },
                                'off': { label: 'Off Rtg', higherBetter: true },
                                'def': { label: 'Def Rtg', higherBetter: false },
                                'bpm': { label: 'BPM', higherBetter: true },
                                'obpm': { label: 'OBPM', higherBetter: true },
                                'dbpm': { label: 'DBPM', higherBetter: true },
                                // V5.11: Bayesian Box APM
                                'apm': { label: '🔮 APM', higherBetter: true },
                                'oapm': { label: '🔮 OAPM', higherBetter: true },
                                'dapm': { label: '🔮 DAPM', higherBetter: true },
                                'rapm': { label: 'RAPM', higherBetter: true },
                                'orapm': { label: 'ORAPM', higherBetter: true },
                                'drapm': { label: 'DRAPM', higherBetter: true },
                                // Single-stat RAPM
                                'rapmOffEfg': { label: 'RAPM Off eFG%', higherBetter: true },
                                'rapmDefEfg': { label: 'RAPM Def eFG%', higherBetter: false },
                                'rapmOffTov': { label: 'RAPM Off TOV%', higherBetter: false },
                                'rapmDefTov': { label: 'RAPM Def TOV%', higherBetter: false },
                                'rapmOffOreb': { label: 'RAPM Off OREB%', higherBetter: true },
                                'rapmDefOreb': { label: 'RAPM Def OREB%', higherBetter: false },
                                'rapmOffFtr': { label: 'RAPM Off FTR', higherBetter: true },
                                'rapmDefFtr': { label: 'RAPM Def FTR', higherBetter: false },
                                'rapmOffAst': { label: 'RAPM Off AST%', higherBetter: true },
                                'rapmStl': { label: 'RAPM STL%', higherBetter: true },
                                'rapmBlk': { label: 'RAPM BLK%', higherBetter: true },
                                'fourFactorsImpact': { label: '⚡ FF Impact', higherBetter: true },
                                'scoringBattleImpact': { label: '🎯 Scoring', higherBetter: true },
                                'possBattleImpact': { label: '🔄 Possession', higherBetter: true },
                                'offEfg': { label: 'eFG%', higherBetter: true },
                                'defEfg': { label: 'Opp eFG%', higherBetter: false },
                                'offOreb': { label: 'OREB%', higherBetter: true },
                                'defOreb': { label: 'Opp OREB%', higherBetter: false },
                                'offTov': { label: 'TOV%', higherBetter: false },
                                'defTov': { label: 'Forced TO%', higherBetter: true },
                                'offFtR': { label: 'FT Rate', higherBetter: true },
                                'defFtR': { label: 'Opp FT Rate', higherBetter: false },
                                'rimPct': { label: 'Rim%', higherBetter: true },
                                'midPct': { label: 'Mid%', higherBetter: true },
                                'threePct': { label: '3PT%', higherBetter: true },
                                'rimVol': { label: 'Rim Vol', higherBetter: true },
                                'midVol': { label: 'Mid Vol', higherBetter: false },
                                'threeVol': { label: '3PT Vol', higherBetter: true },
                                'rimVolV': { label: 'Def Rim Vol', higherBetter: false },
                                'midVolV': { label: 'Def Mid Vol', higherBetter: true },
                                'threeVolV': { label: 'Def 3PT Vol', higherBetter: false },
                                'stlPct': { label: 'STL%', higherBetter: true },
                                'blkPct': { label: 'BLK%', higherBetter: true },
                                'astPct': { label: 'AST%', higherBetter: true },
                                'paceF': { label: 'Off Pace', higherBetter: true },
                                'paceV': { label: 'Def Pace', higherBetter: false },
                                // V5.6: Individual mode stats
                                'ppg': { label: 'PPG', higherBetter: true },
                                'rpg': { label: 'RPG', higherBetter: true },
                                'apg': { label: 'APG', higherBetter: true },
                                'spg': { label: 'SPG', higherBetter: true },
                                'bpg': { label: 'BPG', higherBetter: true },
                                'mpg': { label: 'MPG', higherBetter: true },
                                'fgPct': { label: 'FG%', higherBetter: true },
                                'ftPct': { label: 'FT%', higherBetter: true },
                                'tsPct': { label: 'TS%', higherBetter: true },
                                'efgPct': { label: 'eFG%', higherBetter: true },
                                'usg': { label: 'USG%', higherBetter: true },
                                'per': { label: 'PER', higherBetter: true },
                                'ortg': { label: 'ORtg', higherBetter: true },
                                'drtg': { label: 'DRtg', higherBetter: false },
                                // V5.15: Extended individual stats - per 75 possessions (same names as leaderboard)
                                'usage': { label: 'Usage %', higherBetter: true },
                                'pts75': { label: 'PTS/75', higherBetter: true },
                                'reb75': { label: 'REB/75', higherBetter: true },
                                'oreb75': { label: 'OREB/75', higherBetter: true },
                                'dreb75': { label: 'DREB/75', higherBetter: true },
                                'ast75': { label: 'AST/75', higherBetter: true },
                                'astUsgRatio': { label: 'AST/USG', higherBetter: true },
                                'stl75': { label: 'STL/75', higherBetter: true },
                                'blk75': { label: 'BLK/75', higherBetter: true },
                                'tov75': { label: 'TOV/75', higherBetter: false },
                                'rimA75': { label: 'RIM ATT/75', higherBetter: true },
                                'midA75': { label: 'MID ATT/75', higherBetter: false },
                                'threeA75': { label: '3PT ATT/75', higherBetter: true },
                                'tpc75': { label: 'TPC/75', higherBetter: true },
                                'playerAstPct': { label: 'AST%', higherBetter: true },
                                'passTo': { label: 'Pass TOs', higherBetter: false },
                                'dribTo': { label: 'Dribble TOs', higherBetter: false },
                                'ptsAst75': { label: 'PTS AST/75', higherBetter: true },
                                'secChancePts75': { label: '2nd Chance/75', higherBetter: true },
                                'fastBreakPts75': { label: 'Fast Break/75', higherBetter: true },
                                'clutchPts75': { label: 'Clutch/75', higherBetter: true }
                            };
                            
                            // Calculate BPM coefficients (simplified standard BPM formula)
                            // V5.10: Use BPM from CSV if available, otherwise calculate
                            const calcBPM = (player, seasonStats) => {
                                if (!seasonStats) return { bpm: 0, obpm: 0, dbpm: 0 };
                                
                                // If CSV has BPM values, use them directly
                                if (seasonStats.bpm !== null && seasonStats.bpm !== undefined && !isNaN(seasonStats.bpm)) {
                                    return {
                                        bpm: seasonStats.bpm,
                                        obpm: seasonStats.obpm || 0,
                                        dbpm: seasonStats.dbpm || 0
                                    };
                                }
                                
                                // Otherwise calculate BPM from box score stats
                                const mpg = seasonStats.mpg || 20;
                                const usg = (seasonStats.usg || 20) / 100;
                                const pts = seasonStats.ppg || 0;
                                const ast = (seasonStats.ast / seasonStats.games) || 0;
                                const reb = (seasonStats.reb / seasonStats.games) || 0;
                                const stl = (seasonStats.stl / seasonStats.games) || 0;
                                const blk = (seasonStats.blk / seasonStats.games) || 0;
                                const tov = (seasonStats.tov / seasonStats.games) || 0;
                                const tsPct = seasonStats.fga > 0 ? (seasonStats.pts / (2 * (seasonStats.fga + 0.44 * seasonStats.fta))) : 0.5;
                                // Standard BPM components
                                const scoringImpact = (tsPct - 0.55) * 100 * usg;
                                const assistImpact = ast * 0.5;
                                const rebImpact = reb * 0.3;
                                const defImpact = stl * 1.5 + blk * 0.8;
                                const tovPenalty = tov * -0.5;
                                // Offensive BPM
                                const obpm = scoringImpact + assistImpact + rebImpact * 0.3 + tovPenalty;
                                // Defensive BPM
                                const dbpm = defImpact + rebImpact * 0.7;
                                // Total BPM
                                const bpm = obpm + dbpm;
                                return { bpm, obpm, dbpm };
                            };
                            
                            // Use onOffData if using on/off stats, otherwise calculate from season
                            // V5.9: First build ALL players (unfiltered) for universal percentile calculations
                            // V5.10: Added single-stat RAPM extraction
                            
                            // Helper to get single-stat RAPM value
                            const getSingleStatRapm = (playerName, statKey, useDefCoef = false) => {
                                if (!playerRapmStats || !playerRapmStats.stats || !playerRapmStats.stats[statKey]) return 0;
                                const statResults = playerRapmStats.stats[statKey];
                                const normalizedName = normalizePlayerName(playerName);
                                const matchingPlayer = Object.keys(statResults).find(p => normalizePlayerName(p) === normalizedName);
                                if (matchingPlayer && statResults[matchingPlayer]) {
                                    return useDefCoef ? (statResults[matchingPlayer].dRAPM || 0) : (statResults[matchingPlayer].oRAPM || 0);
                                }
                                return 0;
                            };
                            
                            const buildPlayerData = (d, isOnOff) => {
                                if (isOnOff) {
                                    const seasonStats = seasonStatsMap.get(normalizePlayerName(d.player));
                                    const bpmData = calcBPM(d.player, seasonStats);
                                    let rapm = 0, orapm = 0, drapm = 0;
                                    if (playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg) {
                                        const ortgStats = playerRapmStats.stats.ORtg;
                                        const normalizedName = normalizePlayerName(d.player);
                                        const matchingPlayer = Object.keys(ortgStats).find(p => normalizePlayerName(p) === normalizedName);
                                        if (matchingPlayer && ortgStats[matchingPlayer]) {
                                            orapm = ortgStats[matchingPlayer].oRAPM || 0;
                                            const rawDrapm = ortgStats[matchingPlayer].dRAPM || 0;
                                            rapm = orapm + rawDrapm;
                                            // V8.1: Negate DRAPM display so positive = good defense
                                            drapm = -rawDrapm;
                                        }
                                    }

                                    // V5.10: Extract all single-stat RAPM values
                                    // V5.12: Defensive RAPM stats are NEGATED so that:
                                    //   - Negative = good defense (below avg opp performance) = green/sorted first
                                    //   - Positive = bad defense (above avg opp performance) = red/sorted last
                                    const rapmOffEfg = getSingleStatRapm(d.player, 'eFG', false);   // Higher = better
                                    const rapmDefEfg = -getSingleStatRapm(d.player, 'eFG', true);   // Lower = better (negative = good defense)
                                    const rapmOffTov = getSingleStatRapm(d.player, 'TOV', false);   // Lower = better (negative = fewer TOs)
                                    const rapmDefTov = -getSingleStatRapm(d.player, 'TOV', true);   // Higher = better (negative = good defense = forces TOs)
                                    const rapmOffOreb = getSingleStatRapm(d.player, 'OREB', false); // Higher = better
                                    const rapmDefOreb = -getSingleStatRapm(d.player, 'OREB', true); // Lower = better (negative = good defense)
                                    const rapmOffFtr = getSingleStatRapm(d.player, 'FTR', false);   // Higher = better
                                    const rapmDefFtr = -getSingleStatRapm(d.player, 'FTR', true);   // Lower = better (negative = good defense)
                                    const rapmOffAst = getSingleStatRapm(d.player, 'AST', false);   // Higher = better
                                    const rapmStl = getSingleStatRapm(d.player, 'STL', false);      // Higher = better
                                    const rapmBlk = getSingleStatRapm(d.player, 'BLK', false);      // Higher = better
                                    
                                    // V5.11: Extract APM values (hybrid RAPM with Bayesian Box)
                                    let apm = 0, oapm = 0, dapm = 0;
                                    if (playerApmStats && playerApmStats.players) {
                                        const apmResult = PlayerRAPMEngine.getPlayerApmValue(playerApmStats, d.player);
                                        if (apmResult) {
                                            apm = apmResult.apm || 0;
                                            oapm = apmResult.oapm || 0;
                                            dapm = apmResult.dapm || 0;
                                        }
                                    }
                                    
                                    return {
                                        name: d.player,
                                        team: d.team,
                                        onMins: d.onMinutes,
                                        onPoss: d.onPoss,
                                        ...d.onStats,
                                        ...bpmData,
                                        rapm, orapm, drapm,
                                        // V5.11: Bayesian Box APM values
                                        apm, oapm, dapm,
                                        // Single-stat RAPM values
                                        rapmOffEfg, rapmDefEfg,
                                        rapmOffTov, rapmDefTov,
                                        rapmOffOreb, rapmDefOreb,
                                        rapmOffFtr, rapmDefFtr,
                                        rapmOffAst, rapmStl, rapmBlk,
                                        seasonStats
                                    };
                                } else {
                                    const seasonStats = { ...d, games: parseFloat(d.Games) || 1, mpg: parseFloat(d.MPG) || 0, ppg: parseFloat(d.PPG) || 0, pts: parseFloat(d.PTS) || 0, fga: parseFloat(d.FGA) || 0, fgm: parseFloat(d.FGM) || 0, fta: parseFloat(d.FTA) || 0, ftm: parseFloat(d.FTM) || 0, tpa: parseFloat(d['3PA']) || 0, tpm: parseFloat(d['3PM']) || 0, reb: parseFloat(d.REB) || 0, ast: parseFloat(d.AST) || 0, stl: parseFloat(d.STL) || 0, blk: parseFloat(d.BLK) || 0, tov: parseFloat(d.TOV) || 0, usg: parseFloat(d['USG%']) || 20 };
                                    const bpmData = calcBPM(d.Player_Name, seasonStats);
                                    const min = parseFloat(d.MIN) || 1;
                                    const games = parseFloat(d.Games) || 1;
                                    const fga = parseFloat(d.FGA) || 0;
                                    const fgm = parseFloat(d.FGM) || 0;
                                    const tpm = parseFloat(d['3PM']) || 0;
                                    const fta = parseFloat(d.FTA) || 0;
                                    const tov = parseFloat(d.TOV) || 0;
                                    const oreb = parseFloat(d.OREB) || 0;
                                    const dreb = parseFloat(d.DREB) || 0;
                                    let rapm = 0, orapm = 0, drapm = 0;
                                    if (playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg) {
                                        const ortgStats = playerRapmStats.stats.ORtg;
                                        const normalizedName = normalizePlayerName(d.Player_Name);
                                        const matchingPlayer = Object.keys(ortgStats).find(p => normalizePlayerName(p) === normalizedName);
                                        if (matchingPlayer && ortgStats[matchingPlayer]) {
                                            orapm = ortgStats[matchingPlayer].oRAPM || 0;
                                            const rawDrapm = ortgStats[matchingPlayer].dRAPM || 0;
                                            rapm = orapm + rawDrapm;
                                            // V8.1: Negate DRAPM display so positive = good defense
                                            drapm = -rawDrapm;
                                        }
                                    }

                                    // V5.10: Extract all single-stat RAPM values for individual mode
                                    // V5.12: Defensive RAPM stats are NEGATED so that:
                                    //   - Negative = good defense (below avg opp performance) = green/sorted first
                                    //   - Positive = bad defense (above avg opp performance) = red/sorted last
                                    const rapmOffEfg = getSingleStatRapm(d.Player_Name, 'eFG', false);
                                    const rapmDefEfg = -getSingleStatRapm(d.Player_Name, 'eFG', true);
                                    const rapmOffTov = getSingleStatRapm(d.Player_Name, 'TOV', false);
                                    const rapmDefTov = -getSingleStatRapm(d.Player_Name, 'TOV', true);
                                    const rapmOffOreb = getSingleStatRapm(d.Player_Name, 'OREB', false);
                                    const rapmDefOreb = -getSingleStatRapm(d.Player_Name, 'OREB', true);
                                    const rapmOffFtr = getSingleStatRapm(d.Player_Name, 'FTR', false);
                                    const rapmDefFtr = -getSingleStatRapm(d.Player_Name, 'FTR', true);
                                    const rapmOffAst = getSingleStatRapm(d.Player_Name, 'AST', false);
                                    const rapmStl = getSingleStatRapm(d.Player_Name, 'STL', false);
                                    const rapmBlk = getSingleStatRapm(d.Player_Name, 'BLK', false);
                                    
                                    // V5.11: Extract APM values (hybrid RAPM with Bayesian Box)
                                    let apm = 0, oapm = 0, dapm = 0;
                                    if (playerApmStats && playerApmStats.players) {
                                        const apmResult = PlayerRAPMEngine.getPlayerApmValue(playerApmStats, d.Player_Name);
                                        if (apmResult) {
                                            apm = apmResult.apm || 0;
                                            oapm = apmResult.oapm || 0;
                                            dapm = apmResult.dapm || 0;
                                        }
                                    }

                                    // V5.15: Get pre-computed per-75 stats from leaguePlayerAverages
                                    let per75Stats = {};
                                    if (leaguePlayerAverages && leaguePlayerAverages.players) {
                                        const normalizedName = normalizePlayerName(d.Player_Name);
                                        const leaguePlayer = leaguePlayerAverages.players.find(p => normalizePlayerName(p.player) === normalizedName);
                                        if (leaguePlayer) {
                                            per75Stats = {
                                                usage: leaguePlayer.usage || 0,
                                                pts75: leaguePlayer.pts75 || 0,
                                                reb75: leaguePlayer.reb75 || 0,
                                                oreb75: leaguePlayer.oreb75 || 0,
                                                dreb75: leaguePlayer.dreb75 || 0,
                                                ast75: leaguePlayer.ast75 || 0,
                                                stl75: leaguePlayer.stl75 || 0,
                                                blk75: leaguePlayer.blk75 || 0,
                                                tov75: leaguePlayer.tov75 || 0,
                                                astUsgRatio: leaguePlayer.astUsgRatio || 0,
                                                tsPct: leaguePlayer.tsPct || 0,
                                                rimPct: leaguePlayer.rimPct || 0,
                                                midPct: leaguePlayer.midPct || 0,
                                                threePct: leaguePlayer.threePct || 0,
                                                rimA75: leaguePlayer.rimA75 || 0,
                                                midA75: leaguePlayer.midA75 || 0,
                                                threeA75: leaguePlayer.threeA75 || 0,
                                                tpc75: leaguePlayer.tpc75 || 0,
                                                playerAstPct: leaguePlayer.playerAstPct || 0,
                                                passTo: leaguePlayer.passTo || 0,
                                                dribTo: leaguePlayer.dribTo || 0,
                                                ptsAst75: leaguePlayer.ptsAst75 || 0,
                                                secChancePts75: leaguePlayer.secChancePts75 || 0,
                                                fastBreakPts75: leaguePlayer.fastBreakPts75 || 0,
                                                clutchPts75: leaguePlayer.clutchPts75 || 0
                                            };
                                        }
                                    }

                                    return {
                                        name: d.Player_Name,
                                        team: d.Team,
                                        onMins: min,
                                        onPoss: min * 1.5,
                                        off: 0, def: 0, net: 0,
                                        offEfg: fga > 0 ? ((fgm + 0.5 * tpm) / fga) * 100 : 0,
                                        offTov: (fga + 0.44 * fta + tov) > 0 ? (tov / (fga + 0.44 * fta + tov)) * 100 : 0,
                                        offOreb: (oreb + dreb) > 0 ? (oreb / (oreb + dreb)) * 100 : 0,
                                        offFtR: fga > 0 ? (fta / fga) * 100 : 0,
                                        stlPct: (parseFloat(d.STL) / games) || 0,
                                        blkPct: (parseFloat(d.BLK) / games) || 0,
                                        astPct: fgm > 0 ? ((parseFloat(d.AST) || 0) / fgm) * 100 : 0,
                                        ...bpmData,
                                        rapm, orapm, drapm,
                                        // V5.11: Bayesian Box APM values
                                        apm, oapm, dapm,
                                        // Single-stat RAPM values
                                        rapmOffEfg, rapmDefEfg,
                                        rapmOffTov, rapmDefTov,
                                        rapmOffOreb, rapmDefOreb,
                                        rapmOffFtr, rapmDefFtr,
                                        rapmOffAst, rapmStl, rapmBlk,
                                        // V5.15: Per-75 possession stats from leaguePlayerAverages
                                        ...per75Stats,
                                        seasonStats
                                    };
                                }
                            };
                            
                            // Build ALL players for universal percentiles (no team/mins filter)
                            const allPlayersUnfiltered = exportUseOnOff 
                                ? onOffData.map(d => buildPlayerData(d, true))
                                : seasonData.map(d => buildPlayerData(d, false));
                            
                            // Build filtered players for display
                            const players = exportUseOnOff 
                                ? onOffData
                                    .filter(d => exportTeam === '' || d.team === exportTeam)
                                    .filter(d => d.onMinutes >= exportMinMins)
                                    .map(d => buildPlayerData(d, true))
                                : seasonData
                                    .filter(d => exportTeam === '' || d.Team === exportTeam)
                                    .filter(d => (parseFloat(d.MIN) || 0) >= exportMinMins)
                                    .map(d => buildPlayerData(d, false));
                            
                            // Apply luck adjustment to players (On/Off mode only)
                            const applyLeaderboardLuckAdj = (p, offAdjPct, defAdjPct) => {
                                if ((offAdjPct === 0 && defAdjPct === 0) || !exportUseOnOff) return p;
                                const leagueAvg3Pct = 36; // League average 3PT%
                                
                                // Get raw data from player (from onStats spread)
                                const tpm = p.tpm || 0, tpa = p.tpa || 0;
                                const tpmV = p.tpmV || 0, tpaV = p.tpaV || 0;
                                const fgm = p.fgm || 0, fga = p.fga || 0;
                                const fgmV = p.fgmV || 0, fgaV = p.fgaV || 0;
                                const offPoss = p.offPoss || p.onPoss / 2 || 1;
                                const defPoss = p.defPoss || p.onPoss / 2 || 1;
                                
                                // Offensive luck: regress 3PT% toward league average
                                const offLuckDelta = tpm - (tpa * leagueAvg3Pct / 100);
                                const offAdj3pm = offLuckDelta * (offAdjPct / 100);
                                
                                // Defensive luck: regress opponent 3PT% toward league average
                                const defLuckDelta = tpmV - (tpaV * leagueAvg3Pct / 100);
                                const defAdj3pm = defLuckDelta * (defAdjPct / 100);
                                
                                // Adjusted points (raw pts = fgm * 2 + tpm + ftm)
                                const origPts = fgm * 2 + tpm + (p.ftm || 0);
                                const origPtsV = fgmV * 2 + tpmV + (p.ftmV || 0);
                                const adjPts = origPts - offAdj3pm * 3;
                                const adjPtsV = origPtsV - defAdj3pm * 3;
                                
                                // Adjusted ratings
                                const adjOff = offPoss > 0 ? (adjPts / offPoss) * 100 : p.off;
                                const adjDef = defPoss > 0 ? (adjPtsV / defPoss) * 100 : p.def;
                                
                                // Adjusted eFG%
                                const adj3pm = Math.max(0, tpm - offAdj3pm);
                                const adjFgm = fgm - offAdj3pm;
                                const adjOffEfg = fga > 0 ? ((adjFgm + 0.5 * adj3pm) / fga) * 100 : p.offEfg;
                                
                                const adj3pmV = Math.max(0, tpmV - defAdj3pm);
                                const adjFgmV = fgmV - defAdj3pm;
                                const adjDefEfg = fgaV > 0 ? ((adjFgmV + 0.5 * adj3pmV) / fgaV) * 100 : p.defEfg;
                                
                                return {
                                    ...p,
                                    off: adjOff,
                                    def: adjDef,
                                    net: adjOff - adjDef,
                                    offEfg: adjOffEfg,
                                    defEfg: adjDefEfg
                                };
                            };
                            
                            // Apply luck adjustment to all players
                            const adjustedPlayers = players.map(p => applyLeaderboardLuckAdj(p, exportOffLuckAdj, exportDefLuckAdj));
                            const adjustedAllPlayers = allPlayersUnfiltered.map(p => applyLeaderboardLuckAdj(p, exportOffLuckAdj, exportDefLuckAdj));
                            
                            // V5.8: Calculate Four Factors Impact stats (z-score normalized)
                            // Calculate distributions for the 8 four factors
                            const calcDistribution = (arr) => {
                                if (!arr.length) return { mean: 0, stdDev: 1 };
                                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                                const variance = arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
                                return { mean, stdDev: Math.sqrt(variance) || 1 };
                            };
                            
                            // V5.9: Use ALL players (unfiltered) for universal percentile distributions
                            const ffDistributions = {
                                offEfg: calcDistribution(adjustedAllPlayers.map(p => p.offEfg || 0)),
                                offTov: calcDistribution(adjustedAllPlayers.map(p => p.offTov || 0)),
                                offOreb: calcDistribution(adjustedAllPlayers.map(p => p.offOreb || 0)),
                                offFtR: calcDistribution(adjustedAllPlayers.map(p => p.offFtR || 0)),
                                defEfg: calcDistribution(adjustedAllPlayers.map(p => p.defEfg || 0)),
                                defTov: calcDistribution(adjustedAllPlayers.map(p => p.defTov || 0)),
                                defOreb: calcDistribution(adjustedAllPlayers.map(p => p.defOreb || 0)),
                                defFtR: calcDistribution(adjustedAllPlayers.map(p => p.defFtR || 0))
                            };
                            
                            // Calculate z-score helper
                            const calcZScore = (val, dist, higherBetter) => {
                                const z = (val - dist.mean) / dist.stdDev;
                                return higherBetter ? z : -z; // Flip sign if lower is better
                            };
                            
                            // V5.9: Add impact stats to ALL players first (for universal percentiles)
                            adjustedAllPlayers.forEach(p => {
                                const zScores = {
                                    offEfg: calcZScore(p.offEfg || 0, ffDistributions.offEfg, true),
                                    offTov: calcZScore(p.offTov || 0, ffDistributions.offTov, false),
                                    offOreb: calcZScore(p.offOreb || 0, ffDistributions.offOreb, true),
                                    offFtR: calcZScore(p.offFtR || 0, ffDistributions.offFtR, true),
                                    defEfg: calcZScore(p.defEfg || 0, ffDistributions.defEfg, false),
                                    defTov: calcZScore(p.defTov || 0, ffDistributions.defTov, true),
                                    defOreb: calcZScore(p.defOreb || 0, ffDistributions.defOreb, false),
                                    defFtR: calcZScore(p.defFtR || 0, ffDistributions.defFtR, false)
                                };
                                p.possBattleImpact = zScores.offOreb + zScores.offTov + zScores.defOreb + zScores.defTov;
                                p.scoringBattleImpact = zScores.offEfg + zScores.offFtR + zScores.defEfg + zScores.defFtR;
                                p.fourFactorsImpact = p.possBattleImpact + p.scoringBattleImpact;
                            });
                            
                            // Add impact stats to filtered players (using same distributions)
                            adjustedPlayers.forEach(p => {
                                const zScores = {
                                    offEfg: calcZScore(p.offEfg || 0, ffDistributions.offEfg, true),
                                    offTov: calcZScore(p.offTov || 0, ffDistributions.offTov, false), // Lower TOV% is better
                                    offOreb: calcZScore(p.offOreb || 0, ffDistributions.offOreb, true),
                                    offFtR: calcZScore(p.offFtR || 0, ffDistributions.offFtR, true),
                                    defEfg: calcZScore(p.defEfg || 0, ffDistributions.defEfg, false), // Lower opp eFG% is better
                                    defTov: calcZScore(p.defTov || 0, ffDistributions.defTov, true), // Higher forced TOV% is better
                                    defOreb: calcZScore(p.defOreb || 0, ffDistributions.defOreb, false), // Lower opp OREB% is better
                                    defFtR: calcZScore(p.defFtR || 0, ffDistributions.defFtR, false) // Lower opp FT rate is better
                                };
                                
                                // Possession Battle: OREB% and TOV% factors
                                p.possBattleImpact = zScores.offOreb + zScores.offTov + zScores.defOreb + zScores.defTov;
                                
                                // Scoring Battle: eFG% and FT Rate factors
                                p.scoringBattleImpact = zScores.offEfg + zScores.offFtR + zScores.defEfg + zScores.defFtR;
                                
                                // Four Factors Impact: All 8 factors combined
                                p.fourFactorsImpact = p.possBattleImpact + p.scoringBattleImpact;
                            });
                            
                            // V5.5: Calculate team averages for all stats (from filtered players - for display)
                            const teamAverages = {};
                            const allTeams = [...new Set(adjustedPlayers.map(p => p.team))];
                            allTeams.forEach(team => {
                                const teamPlayers = adjustedPlayers.filter(p => p.team === team);
                                if (teamPlayers.length === 0) return;
                                const statKeys = ['net', 'off', 'def', 'bpm', 'obpm', 'dbpm', 'rapm', 'orapm', 'drapm', 'offEfg', 'defEfg', 'offOreb', 'defOreb', 'offTov', 'defTov', 'offFtR', 'defFtR', 'rimPct', 'midPct', 'threePct', 'rimVol', 'midVol', 'threeVol', 'rimVolV', 'midVolV', 'threeVolV', 'stlPct', 'blkPct', 'astPct', 'paceF', 'paceV', 'fourFactorsImpact', 'scoringBattleImpact', 'possBattleImpact', 'rapmOffEfg', 'rapmDefEfg', 'rapmOffTov', 'rapmDefTov', 'rapmOffOreb', 'rapmDefOreb', 'rapmOffFtr', 'rapmDefFtr', 'rapmOffAst', 'rapmStl', 'rapmBlk'];
                                teamAverages[team] = {};
                                statKeys.forEach(key => {
                                    const vals = teamPlayers.map(p => p[key] || 0).filter(v => !isNaN(v));
                                    teamAverages[team][key] = vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : 0;
                                });
                            });
                            
                            // V5.9: Calculate universal team averages (from ALL players - for universal percentiles)
                            const universalTeamAverages = {};
                            const allTeamsUnfiltered = [...new Set(adjustedAllPlayers.map(p => p.team))];
                            allTeamsUnfiltered.forEach(team => {
                                const teamPlayers = adjustedAllPlayers.filter(p => p.team === team);
                                if (teamPlayers.length === 0) return;
                                const statKeys = ['net', 'off', 'def', 'bpm', 'obpm', 'dbpm', 'rapm', 'orapm', 'drapm', 'offEfg', 'defEfg', 'offOreb', 'defOreb', 'offTov', 'defTov', 'offFtR', 'defFtR', 'rimPct', 'midPct', 'threePct', 'rimVol', 'midVol', 'threeVol', 'rimVolV', 'midVolV', 'threeVolV', 'stlPct', 'blkPct', 'astPct', 'paceF', 'paceV', 'fourFactorsImpact', 'scoringBattleImpact', 'possBattleImpact', 'rapmOffEfg', 'rapmDefEfg', 'rapmOffTov', 'rapmDefTov', 'rapmOffOreb', 'rapmDefOreb', 'rapmOffFtr', 'rapmDefFtr', 'rapmOffAst', 'rapmStl', 'rapmBlk'];
                                universalTeamAverages[team] = {};
                                statKeys.forEach(key => {
                                    const vals = teamPlayers.map(p => p[key] || 0).filter(v => !isNaN(v));
                                    universalTeamAverages[team][key] = vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : 0;
                                });
                            });
                            
                            // V5.9: Precompute universal relative values (rel_*) on all players
                            const relStatKeys = ['net', 'off', 'def', 'bpm', 'obpm', 'dbpm', 'rapm', 'orapm', 'drapm', 'offEfg', 'defEfg', 'offOreb', 'defOreb', 'offTov', 'defTov', 'offFtR', 'defFtR', 'rimPct', 'midPct', 'threePct', 'rimVol', 'midVol', 'threeVol', 'rimVolV', 'midVolV', 'threeVolV', 'stlPct', 'blkPct', 'astPct', 'paceF', 'paceV', 'fourFactorsImpact', 'scoringBattleImpact', 'possBattleImpact', 'rapmOffEfg', 'rapmDefEfg', 'rapmOffTov', 'rapmDefTov', 'rapmOffOreb', 'rapmDefOreb', 'rapmOffFtr', 'rapmDefFtr', 'rapmOffAst', 'rapmStl', 'rapmBlk'];
                            adjustedAllPlayers.forEach(p => {
                                const teamAvg = universalTeamAverages[p.team] || {};
                                relStatKeys.forEach(key => {
                                    p['rel_' + key] = (p[key] || 0) - (teamAvg[key] || 0);
                                });
                            });

                            // Also precompute on filtered players (for display - uses filtered team averages)
                            adjustedPlayers.forEach(p => {
                                const teamAvg = teamAverages[p.team] || {};
                                relStatKeys.forEach(key => {
                                    p['relDisplay_' + key] = (p[key] || 0) - (teamAvg[key] || 0);
                                });
                                // Also copy universal relative values for percentile comparison
                                const uniTeamAvg = universalTeamAverages[p.team] || {};
                                relStatKeys.forEach(key => {
                                    p['rel_' + key] = (p[key] || 0) - (uniTeamAvg[key] || 0);
                                });
                            });
                            
                            // Get stat value for sorting
                            // V5.15: Simplified - pull pre-computed values directly from player object
                            // Same approach as leaderboard individual tab
                            const getStatValue = (p) => {
                                // Individual stats - pull directly from player object (pre-computed in leaguePlayerAverages.players)
                                if (!exportUseOnOff) {
                                    // All individual stats are pre-computed on the player object
                                    // Usage: usage
                                    // Box Score: pts75, reb75, oreb75, dreb75, ast75, astUsgRatio, stl75, blk75, tov75
                                    // Shooting: tsPct, rimPct, midPct, threePct
                                    // Shot Volume: rimA75, midA75, threeA75
                                    // Playmaking: tpc75, playerAstPct
                                    // Turnovers: passTo, dribTo
                                    // Scoring: ptsAst75, secChancePts75, fastBreakPts75, clutchPts75
                                    // BPM: bpm, obpm, dbpm
                                    // APM: apm, oapm, dapm
                                    return p[exportStat] || 0;
                                }
                                // On/Off stats
                                switch (exportStat) {
                                    case 'net': return p.net || 0;
                                    case 'off': return p.off || 0;
                                    case 'def': return p.def || 0;
                                    case 'bpm': return p.bpm || 0;
                                    case 'obpm': return p.obpm || 0;
                                    case 'dbpm': return p.dbpm || 0;
                                    // V5.11: Bayesian Box APM stats
                                    case 'apm': return p.apm || 0;
                                    case 'oapm': return p.oapm || 0;
                                    case 'dapm': return p.dapm || 0;
                                    case 'rapm': return p.rapm || 0;
                                    case 'orapm': return p.orapm || 0;
                                    case 'drapm': return p.drapm || 0;
                                    default: return p[exportStat] || 0;
                                }
                            };
                            
                            // V5.9: Format stat display based on relative toggle - uses precomputed relDisplay_ values
                            // V5.10: RAPM and BPM stats are already +/- average, so always show with +/- prefix, no team adjustment
                            const isRapmStat = (statKey) => {
                                return statKey === 'rapm' || statKey === 'orapm' || statKey === 'drapm' ||
                                       statKey.startsWith('rapm');
                            };
                            
                            // V5.10: BPM stats are also +/- average
                            const isBpmStat = (statKey) => {
                                return statKey === 'bpm' || statKey === 'obpm' || statKey === 'dbpm' ||
                                       statKey === 'indivBpm' || statKey === 'indivObpm' || statKey === 'indivDbpm';
                            };
                            
                            // V5.11: APM stats are also +/- average
                            const isApmStat = (statKey) => {
                                return statKey === 'apm' || statKey === 'oapm' || statKey === 'dapm' ||
                                       statKey === 'indivApm' || statKey === 'indivOapm' || statKey === 'indivDapm';
                            };
                            
                            // Combined check for any +/- average stat
                            const isPlusMinusStat = (statKey) => isRapmStat(statKey) || isBpmStat(statKey) || isApmStat(statKey);
                            
                            const formatStatDisplay = (p, statKey, cfg) => {
                                // V5.15: Simplified - pull pre-computed values directly from player object
                                // Same approach as leaderboard individual tab
                                let rawVal = p[statKey] || 0;

                                // RAPM and BPM stats are already +/- average - always show with prefix, never adjust
                                if (isPlusMinusStat(statKey)) {
                                    const prefix = rawVal >= 0 ? '+' : '';
                                    return prefix + rawVal.toFixed(1);
                                }

                                if (exportShowRelative) {
                                    const relVal = p['relDisplay_' + statKey] || 0;
                                    const prefix = relVal >= 0 ? '+' : '';
                                    return prefix + relVal.toFixed(1);
                                }
                                return rawVal.toFixed(1);
                            };
                            
                            // V5.9: Get color for relative stat - uses precomputed relDisplay_ values
                            // V5.10: RAPM and BPM stats use raw value for coloring (already +/- average)
                            const getRelativeColor = (p, statKey, cfg) => {
                                const higherBetter = cfg?.higherBetter !== false;
                                
                                // RAPM and BPM stats are already +/- average - color based on raw value
                                if (isPlusMinusStat(statKey)) {
                                    const rawVal = p[statKey] || 0;
                                    const isGood = higherBetter ? rawVal > 0 : rawVal < 0;
                                    if (Math.abs(rawVal) < 0.1) return '#94a3b8'; // Neutral
                                    return isGood ? '#4ade80' : '#f87171';
                                }
                                
                                if (!exportShowRelative) return '#ffffff';
                                const relVal = p['relDisplay_' + statKey] || 0;
                                const isGood = higherBetter ? relVal > 0 : relVal < 0;
                                if (Math.abs(relVal) < 0.5) return '#94a3b8'; // Neutral
                                return isGood ? '#4ade80' : '#f87171';
                            };
                            
                            // V5.9: Sort by selected stat - use precomputed relative values when in relative mode
                            // V5.10: RAPM and BPM stats always sort by raw value (already +/- average)
                            // Returns a value where HIGHER = BETTER (so we always sort descending)
                            const getSortValue = (p) => {
                                // RAPM and BPM stats are already +/- average - always use raw value for sorting
                                if (isPlusMinusStat(exportStat)) {
                                    const rawVal = p[exportStat] || 0;
                                    return statConfig.higherBetter ? rawVal : -rawVal;
                                }
                                
                                if (exportShowRelative) {
                                    // In relative mode, sort by the precomputed +/- vs team average
                                    const relVal = p['relDisplay_' + exportStat] || 0;
                                    // For stats where lower is better (e.g., def rating), 
                                    // a negative relative value is GOOD (below team avg = better defense)
                                    // So we flip the sign to sort correctly
                                    return statConfig.higherBetter ? relVal : -relVal;
                                }
                                // In non-relative mode, use raw value but flip for lower-is-better stats
                                const rawVal = getStatValue(p);
                                return statConfig.higherBetter ? rawVal : -rawVal;
                            };
                            
                            // Sort: depends on exportSortAsc setting
                            // When desc (best to worst): higher getSortValue = better, sort descending
                            // When asc (worst to best): lower getSortValue = worse, sort ascending
                            const sorted = [...adjustedPlayers].sort((a, b) => {
                                const diff = getSortValue(b) - getSortValue(a);
                                return exportSortAsc ? -diff : diff;
                            }).slice(0, exportTopN);
                            
                            // Percentile class helper
                            const getPctClass = (val, higherBetter, allVals) => {
                                if (!allVals || allVals.length < 3) return '';
                                const sortedVals = [...allVals].sort((a, b) => a - b);
                                const idx = sortedVals.findIndex(v => v >= val);
                                const pct = idx >= 0 ? (idx / sortedVals.length) * 100 : 100;
                                const effectivePct = higherBetter ? pct : (100 - pct);
                                if (effectivePct >= 90) return 'pct-90';
                                if (effectivePct >= 80) return 'pct-80';
                                if (effectivePct >= 70) return 'pct-70';
                                if (effectivePct >= 60) return 'pct-60';
                                if (effectivePct >= 50) return 'pct-50';
                                if (effectivePct >= 40) return 'pct-40';
                                if (effectivePct >= 30) return 'pct-30';
                                if (effectivePct >= 20) return 'pct-20';
                                return 'pct-10';
                            };
                            
                            // Handle player image upload
                            const handleImageUpload = (playerName, e) => {
                                const file = e.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = (ev) => {
                                        setExportPlayerImages(prev => ({ ...prev, [playerName]: ev.target.result }));
                                    };
                                    reader.readAsDataURL(file);
                                }
                            };
                            
                            // V5.7: Get performance class for stat value like Four Factors
                            // V5.9: Get performance class - supports both raw and relative modes
                            // Uses count-based percentile to avoid floating point comparison issues
                            const getStatPerfClass = (val, statKey, allVals, isRelativeMode = false, isRapmStatFlag = false) => {
                                if (!allVals || allVals.length < 3) return '';
                                const cfg = allStatConfig[statKey] || { higherBetter: true };
                                const higherBetter = cfg.higherBetter !== false;
                                
                                // V5.10: For RAPM stats, color based on positive/negative value
                                // RAPM stats are already +/- average, so positive = good for higherBetter stats
                                if (isRapmStatFlag) {
                                    const isGood = higherBetter ? val > 0 : val < 0;
                                    const absVal = Math.abs(val);
                                    if (absVal < 0.3) return 'perf-average'; // Near zero
                                    if (isGood) {
                                        return absVal > 1.5 ? 'perf-excellent' : 'perf-good';
                                    } else {
                                        return absVal > 1.5 ? 'perf-poor' : 'perf-below';
                                    }
                                }
                                
                                // Count how many values are BETTER than the current value
                                // For higherBetter: count values > val
                                // For lowerBetter (like def rating): count values < val
                                // In relative mode for lowerBetter: more negative = better, so count values < val
                                let betterCount = 0;
                                
                                if (isRelativeMode) {
                                    // In relative mode:
                                    // For higherBetter stats: higher relative value = better (more positive is good)
                                    // For lowerBetter stats: lower relative value = better (more negative is good)
                                    if (higherBetter) {
                                        betterCount = allVals.filter(v => v > val).length;
                                    } else {
                                        betterCount = allVals.filter(v => v < val).length;
                                    }
                                } else {
                                    // Non-relative mode
                                    if (higherBetter) {
                                        betterCount = allVals.filter(v => v > val).length;
                                    } else {
                                        betterCount = allVals.filter(v => v < val).length;
                                    }
                                }
                                
                                // Calculate percentile (lower = better rank)
                                const pct = ((betterCount + 1) / allVals.length) * 100;
                                
                                if (pct <= 10) return 'perf-excellent';
                                if (pct <= 30) return 'perf-good';
                                if (pct <= 70) return 'perf-average';
                                if (pct <= 90) return 'perf-below';
                                return 'perf-poor';
                            };
                            
                            // V5.9: Pre-calculate all values for each stat for percentile calculation - use UNFILTERED for universal colors
                            const statAllVals = {};
                            const statAllRelVals = {}; // Universal relative values (for reference)
                            const statAllRelDisplayVals = {}; // Display relative values (for color coding in relative mode)
                            // Include exportStat and all secondary stats, using Set to avoid duplicates
                            const allStatsToCalc = [...new Set(['net', 'off', 'def', exportStat, ...exportSecondaryStats])];
                            allStatsToCalc.forEach(statKey => {
                                statAllVals[statKey] = adjustedAllPlayers.map(p => p[statKey] || 0);
                                // Use precomputed rel_ values for universal comparison
                                statAllRelVals[statKey] = adjustedAllPlayers.map(p => p['rel_' + statKey] || 0);
                                // Use relDisplay_ values from filtered players for color coding (matches what's displayed)
                                statAllRelDisplayVals[statKey] = adjustedPlayers.map(p => p['relDisplay_' + statKey] || 0);
                            });
                            
                            // V5.9: Universal percentile arrays for main stats
                            const allNetVals = statAllVals['net'];
                            const allOffVals = statAllVals['off'];
                            const allDefVals = statAllVals['def'];
                            
                            // V5.14: Special handling for BPM Impact Combos
                            if (exportStat === 'bpmImpactCombos' || exportStat === 'bpmImpactZScore') {
                                // Helper to get surname with suffix (e.g., "Mitchell Jr." not just "Jr.")
                                const suffixes = ['Jr', 'Jr.', 'III', 'IV', 'V', 'II', 'Sr', 'Sr.', 'Iii', 'Ii', 'Iv'];
                                const getSurnameOnly = (name) => {
                                    const cleanName = (name || '').split(',')[0].trim();
                                    const parts = cleanName.split(' ').filter(p => p.length > 0);
                                    if (parts.length === 0) return name;
                                    if (parts.length === 1) return parts[0];
                                    const lastWord = parts[parts.length - 1];
                                    if (suffixes.some(s => s.toLowerCase() === lastWord.toLowerCase())) {
                                        return parts.length >= 2 ? parts.slice(-2).join(' ') : lastWord;
                                    }
                                    return lastWord;
                                };

                                // Build map of players per team to detect duplicate surnames
                                const teamPlayersMap = {};
                                lineupData.forEach(l => {
                                    const team = l.Team || '';
                                    const players = (l.Lineup || '').split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                                    if (!teamPlayersMap[team]) teamPlayersMap[team] = new Set();
                                    players.forEach(p => teamPlayersMap[team].add(p));
                                });

                                // Get players with same surname on team
                                const getPlayersWithSameSurname = (name, team) => {
                                    const surname = getSurnameOnly(name).toLowerCase();
                                    const teamPlayers = teamPlayersMap[team] || new Set();
                                    const matches = [];
                                    teamPlayers.forEach(p => {
                                        if (getSurnameOnly(p).toLowerCase() === surname) matches.push(p);
                                    });
                                    return matches;
                                };

                                // Get display name with minimum prefix to disambiguate
                                const getDisplayName = (name, team) => {
                                    const cleanName = (name || '').split(',')[0].trim();
                                    const parts = cleanName.split(' ').filter(p => p.length > 0);
                                    const surname = getSurnameOnly(name);
                                    if (parts.length <= 1) return surname;

                                    const sameNamePlayers = getPlayersWithSameSurname(name, team);
                                    if (sameNamePlayers.length <= 1) return surname;

                                    // Get first names of all players with same surname
                                    const firstName = parts[0];
                                    const otherFirstNames = sameNamePlayers
                                        .filter(p => p !== name)
                                        .map(p => (p.split(',')[0].trim().split(' ').filter(x => x.length > 0)[0] || '').toLowerCase());

                                    // Find minimum prefix length to disambiguate
                                    let prefixLen = 1;
                                    const firstNameLower = firstName.toLowerCase();
                                    while (prefixLen < firstName.length) {
                                        const prefix = firstNameLower.slice(0, prefixLen);
                                        const hasConflict = otherFirstNames.some(fn => fn.slice(0, prefixLen) === prefix);
                                        if (!hasConflict) break;
                                        prefixLen++;
                                    }

                                    return firstName.slice(0, prefixLen) + '. ' + surname;
                                };

                                // V5.21: BPM 2.0 coefficients from hackastat.eu using percentage-based stats
                                const BPM_COEFFS = {
                                    a: 0.123391, b: 0.119597, c: -0.151287, d: 1.255644,
                                    e: 0.531838, f: -0.305868, g: 0.921292, h: 0.711217,
                                    i: 0.017022, j: 0.297639, k: 0.213485, l: 0.725930
                                };
                                const OBPM_COEFFS = {
                                    a: 0.064448, b: 0.211125, c: -0.107545, d: 0.346513,
                                    e: -0.052476, f: -0.041787, g: 0.932965, h: 0.687359,
                                    i: 0.007952, j: 0.374706, k: -0.181891, l: 0.239862
                                };
                                const lgAvg3PAr = 0.40;

                                // Calculate BPM for all two-player combinations from lineup data
                                const calcPoss = (fga, oreb, tov, fta) => fga - oreb + tov + 0.44 * fta;
                                const teamCombos = {};

                                // Get lineups for selected team (or all teams)
                                const relevantLineups = lineupData.filter(l => exportTeam === '' || l.Team === exportTeam);

                                // Process each lineup to extract two-player combinations and track lineups
                                relevantLineups.forEach(l => {
                                    const players = (l.Lineup || '').split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                                    const team = l.Team || '';
                                    const mins = (parseFloat(l.MIN) || (parseFloat(l.TOTAL_TIME) || 0) / 60);
                                    const fga = parseFloat(l.FGA) || 0, oreb = parseFloat(l.OREB) || 0, tov = parseFloat(l.TOV) || 0, fta = parseFloat(l.FTA) || 0;
                                    const fgaV = parseFloat(l.FGA_VS) || 0, orebV = parseFloat(l.OREB_VS) || 0, tovV = parseFloat(l.TOV_VS) || 0, ftaV = parseFloat(l.FTA_VS) || 0;
                                    const poss = calcPoss(fga, oreb, tov, fta);
                                    const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                                    const fgm = parseFloat(l.FGM) || 0, tpm = parseFloat(l['3PM']) || 0, ftm = parseFloat(l.FTM) || 0;
                                    const fgmV = parseFloat(l.FGM_VS) || 0, tpmV = parseFloat(l['3PM_VS']) || 0, ftmV = parseFloat(l.FTM_VS) || 0;
                                    const pts = fgm * 2 + tpm + ftm;
                                    const ptsV = fgmV * 2 + tpmV + ftmV;
                                    const dreb = parseFloat(l.DREB) || 0, drebV = parseFloat(l.DREB_VS) || 0;

                                    // For each pair of players
                                    for (let i = 0; i < players.length; i++) {
                                        for (let j = i + 1; j < players.length; j++) {
                                            const p1 = players[i], p2 = players[j];
                                            const comboKey = [p1, p2].sort().join('|||');
                                            if (!teamCombos[team]) teamCombos[team] = {};
                                            if (!teamCombos[team][comboKey]) {
                                                teamCombos[team][comboKey] = { p1, p2, team, mins: 0, poss: 0, possV: 0, pts: 0, ptsV: 0, fgm: 0, fga: 0, tpm: 0, tpa: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, tov: 0, stl: 0, blk: 0, ast: 0, fgmV: 0, fgaV: 0, tpmV: 0, orebV: 0, drebV: 0, tovV: 0, lineups: [] };
                                            }
                                            const c = teamCombos[team][comboKey];
                                            c.mins += mins;
                                            c.poss += poss; c.possV += possV;
                                            c.pts += pts; c.ptsV += ptsV;
                                            c.fgm += fgm; c.fga += fga;
                                            c.tpm += tpm; c.tpa += parseFloat(l['3PA']) || 0;
                                            c.ftm += ftm; c.fta += fta;
                                            c.oreb += oreb; c.dreb += dreb; c.tov += tov;
                                            c.stl += parseFloat(l.STL) || 0; c.blk += parseFloat(l.BLK) || 0; c.ast += parseFloat(l.AST) || 0;
                                            c.fgmV += fgmV; c.fgaV += fgaV; c.tpmV += tpmV;
                                            c.orebV += orebV; c.drebV += drebV; c.tovV += tovV;
                                            c.lineups.push(l.Lineup); // Track lineups for player stats lookup
                                        }
                                    }
                                });

                                // V5.19: Helper to normalize lineup string for matching
                                const normalizeLineupStr = (lineup) => {
                                    if (!lineup) return '';
                                    return lineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',');
                                };

                                // V5.19: Helper to construct full lineup from Player + Teammates columns
                                const getFullLineupFromPd = (pd) => {
                                    const player = pd.Player || '';
                                    const teammates = pd.Teammates || '';
                                    if (!player || !teammates) return '';
                                    return player + ',' + teammates;
                                };

                                // V5.21: Helper to get individual player box stats with lineup context for BPM 2.0
                                const getPlayerComboStats = (player, team, lineupStrings, comboData) => {
                                    if (!playerData.length) return null;
                                    const playerNorm = normalizePlayerName(player);
                                    const uniqueLineups = [...new Set(lineupStrings)];
                                    const normalizedLineupSet = new Set(uniqueLineups.map(l => normalizeLineupStr(l)));

                                    const relevantPlayerRows = playerData.filter(pd => {
                                        if (!pd.Player) return false;
                                        const pdNorm = normalizePlayerName(pd.Player);
                                        if (pdNorm !== playerNorm || pd.Team !== team) return false;
                                        const fullLineup = getFullLineupFromPd(pd);
                                        return normalizedLineupSet.has(normalizeLineupStr(fullLineup));
                                    });

                                    if (!relevantPlayerRows.length) return null;

                                    const allPlayersInLineups = playerData.filter(pd => {
                                        if (!pd.Player || pd.Team !== team) return false;
                                        const fullLineup = getFullLineupFromPd(pd);
                                        return normalizedLineupSet.has(normalizeLineupStr(fullLineup));
                                    });
                                    const teamFgm = allPlayersInLineups.reduce((sum, pd) => sum + (parseFloat(pd.FGM) || 0), 0);

                                    const lineupTotals = {
                                        fga: comboData.fga, fgm: comboData.fgm, oreb: comboData.oreb, dreb: comboData.dreb,
                                        tov: comboData.tov, fta: comboData.fta, poss: comboData.poss, possV: comboData.possV,
                                        orebV: comboData.orebV, drebV: comboData.drebV, fgaV: comboData.fgaV, mins: comboData.mins
                                    };

                                    const playerStats = relevantPlayerRows.reduce((acc, pd) => ({
                                        pts: acc.pts + (parseFloat(pd.PTS) || 0),
                                        fga: acc.fga + (parseFloat(pd.FGA) || 0),
                                        fgm: acc.fgm + (parseFloat(pd.FGM) || 0),
                                        tpa: acc.tpa + (parseFloat(pd['3PA']) || 0),
                                        tpm: acc.tpm + (parseFloat(pd['3PM']) || 0),
                                        fta: acc.fta + (parseFloat(pd.FTA) || 0),
                                        ftm: acc.ftm + (parseFloat(pd.FTM) || 0),
                                        oreb: acc.oreb + (parseFloat(pd.OREB) || 0),
                                        dreb: acc.dreb + (parseFloat(pd.DREB) || 0),
                                        ast: acc.ast + (parseFloat(pd.AST) || 0),
                                        stl: acc.stl + (parseFloat(pd.STL) || 0),
                                        blk: acc.blk + (parseFloat(pd.BLK) || 0),
                                        tov: acc.tov + (parseFloat(pd.TOV) || 0),
                                        mins: acc.mins + (parseFloat(pd.Minutes) || parseFloat(pd.MIN) || 0),
                                        gp: acc.gp + 1
                                    }), { pts: 0, fga: 0, fgm: 0, tpa: 0, tpm: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, mins: 0, gp: 0 });

                                    return { ...playerStats, lineupTotals, teamFgm };
                                };

                                // V5.21: Calculate BPM 2.0 using percentage-based stats from hackastat.eu
                                const calcMyersBpm = (pStats) => {
                                    if (!pStats || !pStats.lineupTotals) return null;
                                    const lt = pStats.lineupTotals;
                                    if (lt.poss < 1 || lt.mins < 0.1) return null;

                                    const reMpg = pStats.mins / (pStats.gp + 2);
                                    const orebOpps = lt.oreb + lt.drebV;
                                    const orbPct = orebOpps > 0 ? (pStats.oreb / orebOpps) * 100 : 0;
                                    const drebOpps = lt.dreb + lt.orebV;
                                    const drbPct = drebOpps > 0 ? (pStats.dreb / drebOpps) * 100 : 0;
                                    const trbPct = (orebOpps + drebOpps) > 0 ? ((pStats.oreb + pStats.dreb) / (orebOpps + drebOpps)) * 100 : 0;
                                    const stlPct = lt.possV > 0 ? (pStats.stl / lt.possV) * 100 : 0;
                                    const opp2pa = lt.fgaV * 0.6;
                                    const blkPct = opp2pa > 0 ? (pStats.blk / opp2pa) * 100 : 0;
                                    const tmFgmExcludingSelf = pStats.teamFgm - pStats.fgm;
                                    const astPct = tmFgmExcludingSelf > 0 ? (pStats.ast / tmFgmExcludingSelf) * 100 : 0;
                                    const playerPossUsed = pStats.fga + 0.44 * pStats.fta + pStats.tov;
                                    const usgPct = lt.poss > 0 ? (playerPossUsed / lt.poss) * 100 : 0;
                                    const tovPct = playerPossUsed > 0 ? (pStats.tov / playerPossUsed) * 100 : 0;
                                    const tsa = 2 * (pStats.fga + 0.44 * pStats.fta);
                                    const tsPct = tsa > 0 ? (pStats.pts / tsa) * 100 : 0;
                                    const teamTsa = 2 * (lt.fga + 0.44 * lt.fta);
                                    const teamTsPct = teamTsa > 0 ? ((lt.fgm * 2 + (lt.fga > 0 ? (lt.fgm / lt.fga) * lt.fga * 0.5 : 0)) / teamTsa) * 100 : 50;
                                    const threePAr = pStats.fga > 0 ? pStats.tpa / pStats.fga : 0;

                                    const term1 = BPM_COEFFS.a * reMpg;
                                    const term2 = BPM_COEFFS.b * orbPct;
                                    const term3 = BPM_COEFFS.c * drbPct;
                                    const term4 = BPM_COEFFS.d * stlPct;
                                    const term5 = BPM_COEFFS.e * blkPct;
                                    const term6 = BPM_COEFFS.f * astPct;
                                    const term7 = -BPM_COEFFS.g * (usgPct / 100) * tovPct;
                                    const scoringTerm = BPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                                        (2 * (tsPct - teamTsPct) / 100 + BPM_COEFFS.i * astPct / 100 + BPM_COEFFS.j * (threePAr - lgAvg3PAr) - BPM_COEFFS.k);
                                    const term9 = BPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;
                                    const rawBpm = term1 + term2 + term3 + term4 + term5 + term6 + term7 + scoringTerm + term9;

                                    const oTerm1 = OBPM_COEFFS.a * reMpg;
                                    const oTerm2 = OBPM_COEFFS.b * orbPct;
                                    const oTerm3 = OBPM_COEFFS.c * drbPct;
                                    const oTerm4 = OBPM_COEFFS.d * stlPct;
                                    const oTerm5 = OBPM_COEFFS.e * blkPct;
                                    const oTerm6 = OBPM_COEFFS.f * astPct;
                                    const oTerm7 = -OBPM_COEFFS.g * (usgPct / 100) * tovPct;
                                    const oScoringTerm = OBPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                                        (2 * (tsPct - teamTsPct) / 100 + OBPM_COEFFS.i * astPct / 100 + OBPM_COEFFS.j * (threePAr - lgAvg3PAr) - OBPM_COEFFS.k);
                                    const oTerm9 = OBPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;
                                    const rawObpm = oTerm1 + oTerm2 + oTerm3 + oTerm4 + oTerm5 + oTerm6 + oTerm7 + oScoringTerm + oTerm9;

                                    return { bpm: rawBpm, obpm: rawObpm, dbpm: rawBpm - rawObpm };
                                };

                                // V5.21: Helper to get player stats when NOT playing with a specific teammate with lineup context
                                const getPlayerSoloStats = (player, team, excludeTeammate) => {
                                    if (!playerData.length) return null;
                                    const playerNorm = normalizePlayerName(player);
                                    const teammateNorm = normalizePlayerName(excludeTeammate);

                                    const soloLineups = relevantLineups.filter(l => {
                                        if (l.Team !== team) return false;
                                        const lineupPlayers = (l.Lineup || '').split(',').map(p => p.trim());
                                        const lineupNorm = lineupPlayers.map(p => normalizePlayerName(p));
                                        return lineupNorm.includes(playerNorm) && !lineupNorm.includes(teammateNorm);
                                    });

                                    if (!soloLineups.length) return null;

                                    const lineupTotals = soloLineups.reduce((acc, l) => {
                                        const fga = parseFloat(l.FGA) || 0, oreb = parseFloat(l.OREB) || 0;
                                        const dreb = parseFloat(l.DREB) || 0, tov = parseFloat(l.TOV) || 0, fta = parseFloat(l.FTA) || 0;
                                        const fgm = parseFloat(l.FGM) || 0;
                                        const fgaV = parseFloat(l.FGA_VS) || 0, orebV = parseFloat(l.OREB_VS) || 0, drebV = parseFloat(l.DREB_VS) || 0;
                                        const poss = parseFloat(l.POSS) || calcPoss(fga, oreb, tov, fta);
                                        const possV = parseFloat(l.POSS_VS) || calcPoss(fgaV, orebV, parseFloat(l.TOV_VS) || 0, parseFloat(l.FTA_VS) || 0);
                                        return {
                                            fga: acc.fga + fga, fgm: acc.fgm + fgm, oreb: acc.oreb + oreb, dreb: acc.dreb + dreb,
                                            tov: acc.tov + tov, fta: acc.fta + fta, poss: acc.poss + poss, possV: acc.possV + possV,
                                            orebV: acc.orebV + orebV, drebV: acc.drebV + drebV, fgaV: acc.fgaV + fgaV,
                                            mins: acc.mins + (parseFloat(l.TOTAL_TIME) || 0) / 60
                                        };
                                    }, { fga: 0, fgm: 0, oreb: 0, dreb: 0, tov: 0, fta: 0, poss: 0, possV: 0, orebV: 0, drebV: 0, fgaV: 0, mins: 0 });

                                    const normalizedSoloLineupSet = new Set(soloLineups.map(l => normalizeLineupStr(l.Lineup)));

                                    const allPlayersInLineups = playerData.filter(pd => {
                                        if (!pd.Player || pd.Team !== team) return false;
                                        const fullLineup = getFullLineupFromPd(pd);
                                        return normalizedSoloLineupSet.has(normalizeLineupStr(fullLineup));
                                    });
                                    const teamFgm = allPlayersInLineups.reduce((sum, pd) => sum + (parseFloat(pd.FGM) || 0), 0);

                                    const relevantPlayerRows = playerData.filter(pd => {
                                        if (!pd.Player) return false;
                                        const pdNorm = normalizePlayerName(pd.Player);
                                        if (pdNorm !== playerNorm || pd.Team !== team) return false;
                                        const fullLineup = getFullLineupFromPd(pd);
                                        return normalizedSoloLineupSet.has(normalizeLineupStr(fullLineup));
                                    });

                                    if (!relevantPlayerRows.length) return null;

                                    const playerStats = relevantPlayerRows.reduce((acc, pd) => ({
                                        pts: acc.pts + (parseFloat(pd.PTS) || 0),
                                        fga: acc.fga + (parseFloat(pd.FGA) || 0),
                                        fgm: acc.fgm + (parseFloat(pd.FGM) || 0),
                                        tpa: acc.tpa + (parseFloat(pd['3PA']) || 0),
                                        tpm: acc.tpm + (parseFloat(pd['3PM']) || 0),
                                        fta: acc.fta + (parseFloat(pd.FTA) || 0),
                                        ftm: acc.ftm + (parseFloat(pd.FTM) || 0),
                                        oreb: acc.oreb + (parseFloat(pd.OREB) || 0),
                                        dreb: acc.dreb + (parseFloat(pd.DREB) || 0),
                                        ast: acc.ast + (parseFloat(pd.AST) || 0),
                                        stl: acc.stl + (parseFloat(pd.STL) || 0),
                                        blk: acc.blk + (parseFloat(pd.BLK) || 0),
                                        tov: acc.tov + (parseFloat(pd.TOV) || 0),
                                        mins: acc.mins + (parseFloat(pd.Minutes) || parseFloat(pd.MIN) || 0),
                                        gp: acc.gp + 1
                                    }), { pts: 0, fga: 0, fgm: 0, tpa: 0, tpm: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, mins: 0, gp: 0 });

                                    return { ...playerStats, lineupTotals, teamFgm };
                                };

                                // Convert to array and calculate BPM DELTA using Myers method with individual player stats
                                const allCombos = [];
                                Object.entries(teamCombos).forEach(([team, combos]) => {
                                    Object.values(combos).forEach(c => {
                                        if (c.mins < exportMinMins) return; // Filter by minimum minutes together
                                        const avgPoss = (c.poss + c.possV) / 2;
                                        if (avgPoss < 1) return;

                                        // Calculate ratings for context
                                        const offRtg = c.poss > 0 ? (c.pts / c.poss) * 100 : 100;
                                        const defRtg = c.possV > 0 ? (c.ptsV / c.possV) * 100 : 100;
                                        const netRtg = offRtg - defRtg;

                                        // V5.21: Calculate BPM 2.0 using individual player stats with lineup context
                                        const p1StatsTogether = getPlayerComboStats(c.p1, team, c.lineups, c);
                                        // Get P1's individual stats when playing WITHOUT P2
                                        const p1StatsApart = getPlayerSoloStats(c.p1, team, c.p2);

                                        // Calculate BPM delta (P1's BPM with P2 - P1's BPM without P2)
                                        let bpm = null, obpm = null, dbpm = null;
                                        if (p1StatsTogether) {
                                            const p1BpmTogether = calcMyersBpm(p1StatsTogether);
                                            if (p1BpmTogether) {
                                                const p1BpmApart = p1StatsApart ? calcMyersBpm(p1StatsApart) : null;
                                                if (p1BpmApart) {
                                                    // Delta: how P1's BPM changes when playing with P2
                                                    bpm = p1BpmTogether.bpm - p1BpmApart.bpm;
                                                    obpm = p1BpmTogether.obpm - p1BpmApart.obpm;
                                                    dbpm = p1BpmTogether.dbpm - p1BpmApart.dbpm;
                                                }
                                            }
                                        }

                                        allCombos.push({
                                            p1: c.p1, p2: c.p2, team,
                                            mins: c.mins, poss: avgPoss,
                                            offRtg, defRtg, netRtg,
                                            bpm, obpm, dbpm
                                        });
                                    });
                                });

                                // Calculate Z-Score for BPM Impact
                                const validBpmDeltas = allCombos.filter(c => c.bpm !== null).map(c => c.bpm);
                                const meanDelta = validBpmDeltas.length > 0 ? validBpmDeltas.reduce((a, b) => a + b, 0) / validBpmDeltas.length : 0;
                                const variance = validBpmDeltas.length > 0 ? validBpmDeltas.reduce((sum, v) => sum + Math.pow(v - meanDelta, 2), 0) / validBpmDeltas.length : 0;
                                const stdDevDelta = Math.sqrt(variance);

                                // Add Z-Score to each combo
                                allCombos.forEach(c => {
                                    c.zScore = c.bpm !== null && stdDevDelta > 0.01 ? (c.bpm - meanDelta) / stdDevDelta : null;
                                });

                                // Sort based on stat type
                                if (exportStat === 'bpmImpactZScore') {
                                    // Sort by Z-Score ascending (most negative first)
                                    allCombos.sort((a, b) => {
                                        if (a.zScore !== null && b.zScore !== null) return exportSortAsc ? b.zScore - a.zScore : a.zScore - b.zScore;
                                        if (a.zScore !== null) return -1;
                                        if (b.zScore !== null) return 1;
                                        return b.netRtg - a.netRtg;
                                    });
                                } else {
                                    // V5.18: Sort by BPM (descending), fall back to netRtg when BPM is null
                                    allCombos.sort((a, b) => {
                                        if (a.bpm !== null && b.bpm !== null) {
                                            return exportSortAsc ? a.bpm - b.bpm : b.bpm - a.bpm;
                                        }
                                        if (a.bpm !== null && b.bpm === null) return -1;
                                        if (a.bpm === null && b.bpm !== null) return 1;
                                        return exportSortAsc ? a.netRtg - b.netRtg : b.netRtg - a.netRtg;
                                    });
                                }
                                const displayCombos = allCombos.slice(0, exportTopN);

                                const getBpmColor = (bpm) => {
                                    if (bpm === null) return '#64748b';
                                    if (bpm >= 3) return '#22c55e';
                                    if (bpm >= 1) return '#4ade80';
                                    if (bpm >= -1) return '#94a3b8';
                                    if (bpm >= -3) return '#fb923c';
                                    return '#ef4444';
                                };

                                const getZScoreColor = (z) => {
                                    if (z === null) return '#64748b';
                                    if (z <= -2) return '#ef4444';
                                    if (z <= -1) return '#fb923c';
                                    if (z <= 1) return '#94a3b8';
                                    if (z <= 2) return '#4ade80';
                                    return '#22c55e';
                                };

                                return e('div', { className: 'export-cards-grid-v2' },
                                    displayCombos.map((c, i) => {
                                        const cardBg = exportStat === 'bpmImpactZScore' && c.zScore !== null && c.zScore <= -1.5 ? 'rgba(239, 68, 68, 0.15)' : undefined;
                                        const netColor = c.netRtg >= 5 ? '#22c55e' : c.netRtg >= 0 ? '#4ade80' : c.netRtg >= -5 ? '#fb923c' : '#ef4444';
                                        return e('div', { key: i, className: 'export-card-v3', style: { padding: '12px', background: cardBg }},
                                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '10px' }},
                                                e('div', { style: { fontSize: '16px', fontWeight: 'bold', color: '#fbbf24', minWidth: '32px' }}, '#' + (i + 1)),
                                                e('div', { style: { flex: 1 }},
                                                    e('div', { style: { fontSize: '13px', fontWeight: '600' }},
                                                        e('span', { style: { color: '#60a5fa' }}, getDisplayName(c.p1, c.team)),
                                                        e('span', { style: { color: '#64748b', margin: '0 6px' }}, 'w/'),
                                                        e('span', { style: { color: '#a78bfa' }}, getDisplayName(c.p2, c.team))
                                                    ),
                                                    e('div', { style: { fontSize: '10px', color: '#64748b' }}, c.team)
                                                )
                                            ),
                                            e('div', { style: { display: 'grid', gridTemplateColumns: exportStat === 'bpmImpactZScore' ? 'repeat(4, 1fr)' : 'repeat(3, 1fr)', gap: '8px', textAlign: 'center' }},
                                                e('div', { style: { background: 'rgba(96, 165, 250, 0.15)', padding: '8px 4px', borderRadius: '6px' }},
                                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: getBpmColor(c.bpm) }}, c.bpm === null ? 'N/A' : (c.bpm >= 0 ? '+' : '') + c.bpm.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8' }}, 'BPM Δ')
                                                ),
                                                exportStat === 'bpmImpactZScore' && e('div', { style: { background: 'rgba(245, 158, 11, 0.15)', padding: '8px 4px', borderRadius: '6px' }},
                                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: getZScoreColor(c.zScore) }}, c.zScore === null ? 'N/A' : (c.zScore >= 0 ? '+' : '') + c.zScore.toFixed(2)),
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8' }}, 'Z-Score')
                                                ),
                                                e('div', { style: { background: 'rgba(74, 222, 128, 0.1)', padding: '8px 4px', borderRadius: '6px' }},
                                                    e('div', { style: { fontSize: '14px', fontWeight: '600', color: c.obpm === null ? '#64748b' : c.obpm >= 0 ? '#4ade80' : '#f87171' }}, c.obpm === null ? 'N/A' : (c.obpm >= 0 ? '+' : '') + c.obpm.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8' }}, 'OBPM')
                                                ),
                                                e('div', { style: { background: 'rgba(248, 113, 113, 0.1)', padding: '8px 4px', borderRadius: '6px' }},
                                                    e('div', { style: { fontSize: '14px', fontWeight: '600', color: c.dbpm === null ? '#64748b' : c.dbpm >= 0 ? '#4ade80' : '#f87171' }}, c.dbpm === null ? 'N/A' : (c.dbpm >= 0 ? '+' : '') + c.dbpm.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8' }}, 'DBPM')
                                                )
                                            ),
                                            e('div', { style: { display: 'flex', justifyContent: 'space-between', marginTop: '8px', fontSize: '11px' }},
                                                e('span', { style: { color: netColor }}, 'Net: ' + (c.netRtg >= 0 ? '+' : '') + c.netRtg.toFixed(1)),
                                                e('span', { style: { color: '#64748b' }}, c.mins.toFixed(1) + ' min')
                                            )
                                        );
                                    })
                                );
                            }

                            // V5.22: PER Impact Combos handling
                            if (exportStat === 'perImpactCombos' || exportStat === 'perImpactZScore') {
                                // PER calculation function
                                const calcPER = (pStats, lineupTotals) => {
                                    if (!pStats || pStats.mins < 0.1) return null;
                                    const lt = lineupTotals || {};
                                    const teamPace = lt.mins > 0 ? ((lt.poss || 0) / lt.mins) * 48 : 100;
                                    const leagueAvgPace = 100;
                                    const paceFactor = leagueAvgPace / Math.max(teamPace, 50);
                                    const pts = pStats.pts || 0;
                                    const reb = (pStats.oreb || 0) + (pStats.dreb || 0);
                                    const ast = pStats.ast || 0;
                                    const stl = pStats.stl || 0;
                                    const blk = pStats.blk || 0;
                                    const missedFg = (pStats.fga || 0) - (pStats.fgm || 0);
                                    const missedFt = (pStats.fta || 0) - (pStats.ftm || 0);
                                    const tov = pStats.tov || 0;
                                    return pStats.mins > 0 ?
                                        ((pts + reb + ast * 1.5 + stl * 2 + blk * 2 - missedFg - missedFt * 0.5 - tov * 1.5) / pStats.mins) * 15 * paceFactor : 0;
                                };

                                // Reuse same helper functions from BPM Impact section
                                const calcPoss = (fga, oreb, tov, fta) => fga - oreb + tov + 0.44 * fta;

                                // V5.24: Add local getDisplayName for name disambiguation
                                const suffixes = ['Jr', 'Jr.', 'III', 'IV', 'V', 'II', 'Sr', 'Sr.', 'Iii', 'Ii', 'Iv'];
                                const getSurnameOnly = (name) => {
                                    const cleanName = (name || '').split(',')[0].trim();
                                    const parts = cleanName.split(' ').filter(p => p.length > 0);
                                    if (parts.length === 0) return name;
                                    if (parts.length === 1) return parts[0];
                                    const lastWord = parts[parts.length - 1];
                                    if (suffixes.some(s => s.toLowerCase() === lastWord.toLowerCase())) {
                                        return parts.length >= 2 ? parts.slice(-2).join(' ') : lastWord;
                                    }
                                    return lastWord;
                                };
                                const teamPlayersMap = {};
                                lineupData.forEach(l => {
                                    const team = l.Team || '';
                                    const players = (l.Lineup || '').split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                                    if (!teamPlayersMap[team]) teamPlayersMap[team] = new Set();
                                    players.forEach(p => teamPlayersMap[team].add(p));
                                });
                                const getPlayersWithSameSurname = (name, team) => {
                                    const surname = getSurnameOnly(name).toLowerCase();
                                    const teamPlayers = teamPlayersMap[team] || new Set();
                                    const matches = [];
                                    teamPlayers.forEach(p => {
                                        if (getSurnameOnly(p).toLowerCase() === surname) matches.push(p);
                                    });
                                    return matches;
                                };
                                const getDisplayName = (name, team) => {
                                    const cleanName = (name || '').split(',')[0].trim();
                                    const parts = cleanName.split(' ').filter(p => p.length > 0);
                                    const surname = getSurnameOnly(name);
                                    if (parts.length <= 1) return surname;
                                    const sameNamePlayers = getPlayersWithSameSurname(name, team);
                                    if (sameNamePlayers.length <= 1) return surname;
                                    const firstName = parts[0];
                                    const otherFirstNames = sameNamePlayers
                                        .filter(p => p !== name)
                                        .map(p => (p.split(',')[0].trim().split(' ').filter(x => x.length > 0)[0] || '').toLowerCase());
                                    let prefixLen = 1;
                                    const firstNameLower = firstName.toLowerCase();
                                    while (prefixLen < firstName.length) {
                                        const prefix = firstNameLower.slice(0, prefixLen);
                                        const hasConflict = otherFirstNames.some(fn => fn.slice(0, prefixLen) === prefix);
                                        if (!hasConflict) break;
                                        prefixLen++;
                                    }
                                    return firstName.slice(0, prefixLen) + '. ' + surname;
                                };

                                const teamCombos = {};
                                const relevantLineups = lineupData.filter(l => exportTeam === '' || l.Team === exportTeam);

                                relevantLineups.forEach(l => {
                                    const players = (l.Lineup || '').split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                                    const team = l.Team || '';
                                    const mins = (parseFloat(l.MIN) || (parseFloat(l.TOTAL_TIME) || 0) / 60);
                                    const fga = parseFloat(l.FGA) || 0, oreb = parseFloat(l.OREB) || 0, tov = parseFloat(l.TOV) || 0, fta = parseFloat(l.FTA) || 0;
                                    const fgaV = parseFloat(l.FGA_VS) || 0, orebV = parseFloat(l.OREB_VS) || 0, tovV = parseFloat(l.TOV_VS) || 0, ftaV = parseFloat(l.FTA_VS) || 0;
                                    const poss = calcPoss(fga, oreb, tov, fta);
                                    const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                                    const fgm = parseFloat(l.FGM) || 0, tpm = parseFloat(l['3PM']) || 0, ftm = parseFloat(l.FTM) || 0;
                                    const fgmV = parseFloat(l.FGM_VS) || 0, tpmV = parseFloat(l['3PM_VS']) || 0, ftmV = parseFloat(l.FTM_VS) || 0;
                                    const pts = fgm * 2 + tpm + ftm;
                                    const ptsV = fgmV * 2 + tpmV + ftmV;

                                    for (let i = 0; i < players.length; i++) {
                                        for (let j = i + 1; j < players.length; j++) {
                                            const p1 = players[i], p2 = players[j];
                                            const comboKey = [p1, p2].sort().join('|||');
                                            if (!teamCombos[team]) teamCombos[team] = {};
                                            if (!teamCombos[team][comboKey]) {
                                                teamCombos[team][comboKey] = { p1, p2, team, mins: 0, poss: 0, possV: 0, pts: 0, ptsV: 0, lineups: [] };
                                            }
                                            const c = teamCombos[team][comboKey];
                                            c.mins += mins;
                                            c.poss += poss; c.possV += possV;
                                            c.pts += pts; c.ptsV += ptsV;
                                            c.lineups.push(l.Lineup);
                                        }
                                    }
                                });

                                const normalizeLineupStr = (lineup) => lineup ? lineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',') : '';
                                const getFullLineupFromPd = (pd) => pd.Player && pd.Teammates ? pd.Player + ',' + pd.Teammates : '';

                                const getPlayerStatsForPER = (player, team, lineupStrings) => {
                                    if (!playerData.length) return null;
                                    const playerNorm = normalizePlayerName(player);
                                    const normalizedLineupSet = new Set([...new Set(lineupStrings)].map(l => normalizeLineupStr(l)));
                                    const rows = playerData.filter(pd => pd.Player && normalizePlayerName(pd.Player) === playerNorm && pd.Team === team && normalizedLineupSet.has(normalizeLineupStr(getFullLineupFromPd(pd))));
                                    if (!rows.length) return null;
                                    return rows.reduce((acc, pd) => ({
                                        pts: acc.pts + (parseFloat(pd.PTS) || 0), fga: acc.fga + (parseFloat(pd.FGA) || 0), fgm: acc.fgm + (parseFloat(pd.FGM) || 0),
                                        fta: acc.fta + (parseFloat(pd.FTA) || 0), ftm: acc.ftm + (parseFloat(pd.FTM) || 0),
                                        oreb: acc.oreb + (parseFloat(pd.OREB) || 0), dreb: acc.dreb + (parseFloat(pd.DREB) || 0),
                                        ast: acc.ast + (parseFloat(pd.AST) || 0), stl: acc.stl + (parseFloat(pd.STL) || 0), blk: acc.blk + (parseFloat(pd.BLK) || 0), tov: acc.tov + (parseFloat(pd.TOV) || 0),
                                        mins: acc.mins + (parseFloat(pd.Minutes) || parseFloat(pd.MIN) || 0)
                                    }), { pts: 0, fga: 0, fgm: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, mins: 0 });
                                };

                                const getSoloStatsForPER = (player, team, excludeTeammate) => {
                                    if (!playerData.length) return null;
                                    const playerNorm = normalizePlayerName(player);
                                    const teammateNorm = normalizePlayerName(excludeTeammate);
                                    const soloLineups = relevantLineups.filter(l => {
                                        if (l.Team !== team) return false;
                                        const lineupNorm = (l.Lineup || '').split(',').map(p => normalizePlayerName(p.trim()));
                                        return lineupNorm.includes(playerNorm) && !lineupNorm.includes(teammateNorm);
                                    });
                                    if (!soloLineups.length) return null;
                                    const lineupTotals = soloLineups.reduce((acc, l) => ({
                                        poss: acc.poss + (parseFloat(l.POSS) || calcPoss(parseFloat(l.FGA)||0, parseFloat(l.OREB)||0, parseFloat(l.TOV)||0, parseFloat(l.FTA)||0)),
                                        mins: acc.mins + (parseFloat(l.TOTAL_TIME) || 0) / 60
                                    }), { poss: 0, mins: 0 });
                                    const normalizedSet = new Set(soloLineups.map(l => normalizeLineupStr(l.Lineup)));
                                    const rows = playerData.filter(pd => pd.Player && normalizePlayerName(pd.Player) === playerNorm && pd.Team === team && normalizedSet.has(normalizeLineupStr(getFullLineupFromPd(pd))));
                                    if (!rows.length) return null;
                                    const stats = rows.reduce((acc, pd) => ({
                                        pts: acc.pts + (parseFloat(pd.PTS) || 0), fga: acc.fga + (parseFloat(pd.FGA) || 0), fgm: acc.fgm + (parseFloat(pd.FGM) || 0),
                                        fta: acc.fta + (parseFloat(pd.FTA) || 0), ftm: acc.ftm + (parseFloat(pd.FTM) || 0),
                                        oreb: acc.oreb + (parseFloat(pd.OREB) || 0), dreb: acc.dreb + (parseFloat(pd.DREB) || 0),
                                        ast: acc.ast + (parseFloat(pd.AST) || 0), stl: acc.stl + (parseFloat(pd.STL) || 0), blk: acc.blk + (parseFloat(pd.BLK) || 0), tov: acc.tov + (parseFloat(pd.TOV) || 0),
                                        mins: acc.mins + (parseFloat(pd.Minutes) || parseFloat(pd.MIN) || 0)
                                    }), { pts: 0, fga: 0, fgm: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, mins: 0 });
                                    return { ...stats, lineupTotals };
                                };

                                const allCombos = [];
                                Object.entries(teamCombos).forEach(([team, combos]) => {
                                    Object.values(combos).forEach(c => {
                                        if (c.mins < exportMinMins) return;
                                        const avgPoss = (c.poss + c.possV) / 2;
                                        if (avgPoss < 1) return;
                                        const offRtg = c.poss > 0 ? (c.pts / c.poss) * 100 : 100;
                                        const defRtg = c.possV > 0 ? (c.ptsV / c.possV) * 100 : 100;
                                        const netRtg = offRtg - defRtg;
                                        const p1StatsTogether = getPlayerStatsForPER(c.p1, team, c.lineups);
                                        const p1StatsApart = getSoloStatsForPER(c.p1, team, c.p2);
                                        let perDelta = null, perTogether = null, perApart = null;
                                        const lineupTotals = { poss: c.poss, mins: c.mins };
                                        if (p1StatsTogether && p1StatsTogether.mins > 0) {
                                            perTogether = calcPER(p1StatsTogether, lineupTotals);
                                            if (p1StatsApart && p1StatsApart.mins > 0) {
                                                perApart = calcPER(p1StatsApart, p1StatsApart.lineupTotals);
                                                if (perTogether !== null && perApart !== null) perDelta = perTogether - perApart;
                                            }
                                        }
                                        allCombos.push({ p1: c.p1, p2: c.p2, team, mins: c.mins, poss: avgPoss, offRtg, defRtg, netRtg, perDelta, perTogether, perApart });
                                    });
                                });

                                // Calculate Z-Scores
                                const validDeltas = allCombos.filter(c => c.perDelta !== null).map(c => c.perDelta);
                                const meanDelta = validDeltas.length > 0 ? validDeltas.reduce((a, b) => a + b, 0) / validDeltas.length : 0;
                                const stdDevDelta = validDeltas.length > 1 ? Math.sqrt(validDeltas.reduce((sum, v) => sum + Math.pow(v - meanDelta, 2), 0) / (validDeltas.length - 1)) : 1;
                                allCombos.forEach(c => { c.zScore = c.perDelta !== null && stdDevDelta > 0.01 ? (c.perDelta - meanDelta) / stdDevDelta : null; });

                                if (exportStat === 'perImpactZScore') {
                                    allCombos.sort((a, b) => {
                                        if (a.zScore !== null && b.zScore !== null) return exportSortAsc ? b.zScore - a.zScore : a.zScore - b.zScore;
                                        if (a.zScore !== null) return -1;
                                        if (b.zScore !== null) return 1;
                                        return b.netRtg - a.netRtg;
                                    });
                                } else {
                                    allCombos.sort((a, b) => {
                                        if (a.perDelta !== null && b.perDelta !== null) return exportSortAsc ? a.perDelta - b.perDelta : b.perDelta - a.perDelta;
                                        if (a.perDelta !== null) return -1;
                                        if (b.perDelta !== null) return 1;
                                        return b.netRtg - a.netRtg;
                                    });
                                }

                                const displayCombos = allCombos.slice(0, exportTopN);
                                const getPerColor = (per) => per === null ? '#64748b' : per >= 5 ? '#22c55e' : per >= 2 ? '#4ade80' : per >= -2 ? '#94a3b8' : per >= -5 ? '#fb923c' : '#ef4444';
                                const getZScoreColor = (z) => z === null ? '#64748b' : z <= -2 ? '#ef4444' : z <= -1 ? '#fb923c' : z <= 1 ? '#94a3b8' : z <= 2 ? '#4ade80' : '#22c55e';

                                return e('div', { className: 'export-cards-grid-v2' },
                                    displayCombos.map((c, i) => {
                                        const cardBg = exportStat === 'perImpactZScore' && c.zScore !== null && c.zScore <= -1.5 ? 'rgba(239, 68, 68, 0.15)' : undefined;
                                        return e('div', { key: i, className: 'export-card-v3', style: { padding: '12px', background: cardBg }},
                                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '10px' }},
                                                e('div', { style: { fontSize: '16px', fontWeight: 'bold', color: '#a78bfa', minWidth: '32px' }}, '#' + (i + 1)),
                                                e('div', { style: { flex: 1 }},
                                                    e('div', { style: { fontSize: '13px', fontWeight: '600' }},
                                                        e('span', { style: { color: '#60a5fa' }}, getDisplayName(c.p1, c.team)),
                                                        e('span', { style: { color: '#64748b', margin: '0 6px' }}, 'w/'),
                                                        e('span', { style: { color: '#a78bfa' }}, getDisplayName(c.p2, c.team))
                                                    ),
                                                    e('div', { style: { fontSize: '10px', color: '#64748b' }}, c.team)
                                                )
                                            ),
                                            e('div', { style: { display: 'grid', gridTemplateColumns: exportStat === 'perImpactZScore' ? 'repeat(4, 1fr)' : 'repeat(3, 1fr)', gap: '8px', textAlign: 'center' }},
                                                e('div', { style: { background: 'rgba(167, 139, 250, 0.15)', padding: '8px 4px', borderRadius: '6px' }},
                                                    e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: getPerColor(c.perDelta) }}, c.perDelta === null ? 'N/A' : (c.perDelta >= 0 ? '+' : '') + c.perDelta.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8' }}, 'PER Δ')
                                                ),
                                                exportStat === 'perImpactZScore' && e('div', { style: { background: 'rgba(245, 158, 11, 0.15)', padding: '8px 4px', borderRadius: '6px' }},
                                                    e('div', { style: { fontSize: '16px', fontWeight: 'bold', color: getZScoreColor(c.zScore) }}, c.zScore === null ? 'N/A' : (c.zScore >= 0 ? '+' : '') + c.zScore.toFixed(2)),
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8' }}, 'Z-Score')
                                                ),
                                                e('div', { style: { background: 'rgba(74, 222, 128, 0.1)', padding: '8px 4px', borderRadius: '6px' }},
                                                    e('div', { style: { fontSize: '14px', fontWeight: '600', color: '#4ade80' }}, c.perTogether === null ? 'N/A' : c.perTogether.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8' }}, 'PER w/')
                                                ),
                                                e('div', { style: { background: 'rgba(248, 113, 113, 0.1)', padding: '8px 4px', borderRadius: '6px' }},
                                                    e('div', { style: { fontSize: '14px', fontWeight: '600', color: '#f87171' }}, c.perApart === null ? 'N/A' : c.perApart.toFixed(1)),
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8' }}, 'PER w/o')
                                                )
                                            ),
                                            e('div', { style: { display: 'flex', justifyContent: 'space-between', marginTop: '8px', fontSize: '11px' }},
                                                e('span', { style: { color: c.netRtg >= 0 ? '#4ade80' : '#f87171' }}, 'Net: ' + (c.netRtg >= 0 ? '+' : '') + c.netRtg.toFixed(1)),
                                                e('span', { style: { color: '#64748b' }}, c.mins.toFixed(1) + ' min')
                                            )
                                        );
                                    })
                                );
                            }

                            return e('div', null,
                                // Luck adjustment indicator (only show when active)
                                (exportOffLuckAdj > 0 || exportDefLuckAdj > 0) && exportUseOnOff && e('div', { style: { 
                                    textAlign: 'center', 
                                    marginBottom: '12px', 
                                    padding: '8px 16px',
                                    background: 'rgba(251, 191, 36, 0.1)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(251, 191, 36, 0.3)'
                                }},
                                    e('span', { style: { fontSize: '14px', color: '#fbbf24', fontWeight: '600' }}, 
                                        '🎲 3PT Luck Adjusted — ',
                                        exportOffLuckAdj > 0 && e('span', { style: { color: '#4ade80' }}, 'Off ' + exportOffLuckAdj + '%'),
                                        exportOffLuckAdj > 0 && exportDefLuckAdj > 0 && ' | ',
                                        exportDefLuckAdj > 0 && e('span', { style: { color: '#f87171' }}, 'Def ' + exportDefLuckAdj + '%'),
                                        ' (regressed toward 36% league avg)'
                                    )
                                ),
                                // Sort direction indicator (only show when worst to best)
                                exportSortAsc && e('div', { style: { 
                                    textAlign: 'center', 
                                    marginBottom: '12px', 
                                    padding: '8px 16px',
                                    background: 'rgba(239, 68, 68, 0.1)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(239, 68, 68, 0.3)'
                                }},
                                    e('span', { style: { fontSize: '14px', color: '#f87171', fontWeight: '600' }}, '📉 Sorted: Worst → Best')
                                ),
                                e('div', { className: 'export-cards-grid-v2' },
                                sorted.map((p, i) => {
                                    // V5.6: Calculate adaptive name font size based on name length (more granular)
                                    const displayName = getDisplayName(p.name, false);
                                    const nameLen = displayName.length;
                                    const nameFontSize = nameLen > 20 ? '11px' : nameLen > 16 ? '12px' : '13px';
                                    
                                    // V5.6: Get the secondary stats to display (based on count selector)
                                    const secondaryToShow = exportSecondaryStats.slice(0, exportSecondaryCount).filter(Boolean);
                                    
                                    // V5.6: Always use 3 columns, group stats into rows
                                    const statRows = [];
                                    for (let j = 0; j < secondaryToShow.length; j += 3) {
                                        statRows.push(secondaryToShow.slice(j, j + 3));
                                    }
                                    
                                    return e('div', { key: p.name, className: 'export-card-v3' },
                                        // Rank badge (absolute positioned top-left)
                                        e('div', { className: 'export-card-v3-rank' }, '#' + (i + 1)),
                                        // Header with photo and info
                                        e('div', { className: 'export-card-v3-header' },
                                            e('div', {
                                                className: 'export-card-v3-photo',
                                                onClick: () => document.getElementById('img-upload-' + i).click()
                                            },
                                                exportPlayerImages[p.name] ? e('img', { src: exportPlayerImages[p.name], alt: p.name }) : getInitials(p.name),
                                                e('input', {
                                                    type: 'file',
                                                    id: 'img-upload-' + i,
                                                    accept: 'image/*',
                                                    style: { display: 'none' },
                                                    onChange: (ev) => handleImageUpload(p.name, ev)
                                                })
                                            ),
                                            e('div', { className: 'export-card-v3-info' },
                                                e('div', {
                                                    className: 'export-card-v3-name',
                                                    style: { fontSize: nameFontSize }
                                                }, displayName),
                                                e('div', { className: 'export-card-v3-team', title: p.team }, p.team)
                                            )
                                        ),
                                        
                                        // Secondary stats section - V5.7 with Four Factors styling
                                        exportShowSecondary && secondaryToShow.length > 0 && e('div', { 
                                            className: 'export-card-v3-secondary',
                                            style: { display: 'flex', flexDirection: 'column', gap: '4px' }
                                        },
                                            statRows.map((row, rowIdx) => e('div', { 
                                                key: rowIdx, 
                                                style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '4px' } 
                                            },
                                                row.map(statKey => {
                                                    const cfg = allStatConfig[statKey] || { label: statKey, higherBetter: true };
                                                    // V5.15: Simplified - pull pre-computed values directly from player object
                                                    // Same approach as leaderboard individual tab
                                                    const statVal = p[statKey] || 0;
                                                    // V5.10: RAPM and BPM stats are already +/- average - always show with +/- prefix
                                                    const displayVal = isPlusMinusStat(statKey)
                                                        ? ((statVal >= 0 ? '+' : '') + statVal.toFixed(1))
                                                        : (exportUseOnOff && exportShowRelative 
                                                            ? formatStatDisplay(p, statKey, cfg)
                                                            : statVal.toFixed(1));
                                                    // V5.9: Get performance class for color coding - use relDisplay_ values (matches displayed value)
                                                    // V5.10: RAPM and BPM stats use raw value for performance class (already +/- average)
                                                    const perfClass = isPlusMinusStat(statKey)
                                                        ? getStatPerfClass(statVal, statKey, statAllVals[statKey], false, true)
                                                        : (exportShowRelative 
                                                            ? getStatPerfClass(p['relDisplay_' + statKey] || 0, statKey, statAllRelDisplayVals[statKey], true)
                                                            : getStatPerfClass(statVal, statKey, statAllVals[statKey], false));
                                                    // V5.6: Adaptive label font size based on label length
                                                    const labelLen = cfg.label.length;
                                                    const labelFontSize = labelLen > 10 ? '7px' : labelLen > 7 ? '8px' : '9px';
                                                    return e('div', { 
                                                        key: statKey, 
                                                        className: 'export-ff-stat-box-sm ' + perfClass,
                                                        style: { 
                                                            display: 'flex', 
                                                            flexDirection: 'column', 
                                                            padding: '4px 6px',
                                                            borderRadius: '6px',
                                                            textAlign: 'center'
                                                        }
                                                    },
                                                        e('div', { 
                                                            style: { fontSize: labelFontSize, color: '#94a3b8', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', lineHeight: '1.2' }
                                                        }, cfg.label),
                                                        e('div', { 
                                                            style: { fontSize: '13px', fontWeight: '700', color: '#fff', lineHeight: '1.2' }
                                                        }, displayVal)
                                                    );
                                                })
                                            ))
                                        ),
                                        
                                        // Main stat at BOTTOM - V5.9 with performance styling supporting relative mode
                                        // V5.10: RAPM and BPM stats always use raw value (already +/- average)
                                        e('div', { 
                                            className: 'export-card-v3-main ' + (isPlusMinusStat(exportStat)
                                                ? getStatPerfClass(getStatValue(p), exportStat, statAllVals[exportStat], false, true)
                                                : (exportShowRelative 
                                                    ? getStatPerfClass(p['relDisplay_' + exportStat] || 0, exportStat, statAllRelDisplayVals[exportStat], true)
                                                    : getStatPerfClass(getStatValue(p), exportStat, statAllVals[exportStat], false))),
                                            style: { borderRadius: '8px' }
                                        },
                                            e('div', { className: 'export-card-v3-main-label' }, statConfig.label + (exportUseOnOff && exportShowRelative && !isPlusMinusStat(exportStat) ? ' vs Avg' : '')),
                                            e('div', { 
                                                className: 'export-card-v3-main-value',
                                                style: { color: '#fff' }
                                            }, 
                                                exportUseOnOff ? formatStatDisplay(p, exportStat, statConfig) : getStatValue(p).toFixed(1)
                                            )
                                        )
                                    );
                                })
                            )
                            );
                        })(),
                        
                        // Leaderboard Legend
                        exportMode === 'leaderboard' && exportShowLegend && e('div', { style: { marginTop: '16px', padding: '10px 14px', background: 'rgba(15, 23, 42, 0.8)', borderRadius: '8px', border: '1px solid #334155' }},
                            e('div', { style: { fontSize: '10px', color: '#64748b', marginBottom: '6px', fontWeight: '600' }}, '📊 STAT LEGEND'),
                            e('div', { style: { fontSize: '9px', color: '#94a3b8', lineHeight: '1.4' }},
                                e('div', { style: { marginBottom: '6px', padding: '4px 6px', background: 'rgba(59, 130, 246, 0.1)', borderRadius: '4px', borderLeft: '2px solid #3b82f6' }},
                                    e('span', { style: { color: '#60a5fa', fontWeight: '600' }}, 'Sort By: '),
                                    e('span', { style: { color: '#e2e8f0' }}, getStatDef(exportStat).name || exportStat),
                                    ' — ', getStatDef(exportStat).desc || 'Player statistic',
                                    e('span', { style: { color: exportSortAsc ? '#f87171' : '#4ade80', marginLeft: '8px' }}, 
                                        exportSortAsc ? '(Worst → Best)' : '(Best → Worst)'
                                    )
                                ),
                                exportShowSecondary && exportSecondaryStats.slice(0, exportSecondaryCount).length > 0 && e('div', { style: { marginBottom: '4px' }},
                                    e('div', { style: { color: '#a78bfa', fontWeight: '600', marginBottom: '4px' }}, 'Secondary Stats:'),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '3px' }},
                                        exportSecondaryStats.slice(0, exportSecondaryCount).map((s) => 
                                            e('div', { key: s, style: { padding: '2px 4px', background: 'rgba(30, 41, 59, 0.5)', borderRadius: '3px' }},
                                                e('span', { style: { color: '#e2e8f0', fontWeight: '500' }}, getStatDef(s).name || s),
                                                e('span', { style: { color: '#64748b' }}, ' — ' + (getStatDef(s).desc || '').substring(0, 40) + ((getStatDef(s).desc || '').length > 40 ? '...' : ''))
                                            )
                                        )
                                    )
                                ),
                                e('div', { style: { borderTop: '1px solid #334155', paddingTop: '4px', marginTop: '4px', color: '#64748b' }},
                                    exportUseOnOff 
                                        ? '📊 ON/OFF Mode: Values show team performance difference with player ON vs OFF court'
                                        : '📈 Individual Mode: Traditional per-game and shooting statistics'
                                ),
                                // RAPM deep explainer when RAPM stats are selected
                                (exportStat.includes('rapm') || exportStat === 'rapm' || exportSecondaryStats.slice(0, exportSecondaryCount).some(s => s && s.includes('rapm'))) && e('div', { style: { marginTop: '6px', padding: '6px 8px', background: 'rgba(139, 92, 246, 0.1)', borderRadius: '4px', borderLeft: '2px solid #a78bfa' }},
                                    e('div', { style: { color: '#a78bfa', fontWeight: '600', marginBottom: '3px' }}, '🔬 RAPM METHODOLOGY'),
                                    e('div', { style: { color: '#94a3b8', lineHeight: '1.4' }},
                                        'RAPM uses ridge regression (λ=' + (playerRapmStats?.lambda || rapmLambda) + ') to solve the "credit assignment" problem — isolating each player\'s contribution from lineup-level data. ',
                                        'Unlike raw +/-, it controls for teammates and opponents, reducing noise from playing with/against elite players. ',
                                        'Values represent estimated point differential per 100 possessions attributable to the individual player. ',
                                        'Single-stat RAPM variants isolate impact on specific Four Factors (eFG%, TOV%, OREB%, FT Rate).'
                                    )
                                )
                            )
                        ),
                        
                        // V5.6: Chart Export - Full screen scatter plot with correlation
                        exportMode === 'chart' && (() => {
                            // V5.7: Stat config for chart - all stats are ON-OFF differentials
                            // V5.8: Dynamic stat config based on absolute vs relative mode
                            const chartStatConfig = exportChartAbsolute ? {
                                // Absolute mode labels (raw ON values)
                                'net': { label: 'Net Rating (ON)', higherBetter: true },
                                'off': { label: 'Off Rating (ON)', higherBetter: true },
                                'def': { label: 'Def Rating (ON)', higherBetter: false },
                                'fourFactorsImpact': { label: '⚡ Four Factors Impact', higherBetter: true },
                                'scoringBattleImpact': { label: '🎯 Scoring Battle Impact', higherBetter: true },
                                'possBattleImpact': { label: '🔄 Possession Battle Impact', higherBetter: true },
                                'scoringBattle': { label: 'Scoring Battle', higherBetter: true },
                                'possessionBattle': { label: 'Possession Battle', higherBetter: true },
                                'bpm': { label: 'BPM', higherBetter: true },
                                'obpm': { label: 'OBPM', higherBetter: true },
                                'dbpm': { label: 'DBPM', higherBetter: true },
                                // V5.11: Bayesian Box APM
                                'apm': { label: '🔮 APM', higherBetter: true },
                                'oapm': { label: '🔮 OAPM', higherBetter: true },
                                'dapm': { label: '🔮 DAPM', higherBetter: true },
                                'rapm': { label: 'RAPM', higherBetter: true },
                                'orapm': { label: 'ORAPM', higherBetter: true },
                                'drapm': { label: 'DRAPM', higherBetter: true },
                                // Single-stat RAPM
                                'rapmOffEfg': { label: 'RAPM Off eFG%', higherBetter: true },
                                'rapmDefEfg': { label: 'RAPM Def eFG%', higherBetter: false },
                                'rapmOffTov': { label: 'RAPM Off TOV%', higherBetter: false },
                                'rapmDefTov': { label: 'RAPM Def TOV%', higherBetter: false },
                                'rapmOffOreb': { label: 'RAPM Off OREB%', higherBetter: true },
                                'rapmDefOreb': { label: 'RAPM Def OREB%', higherBetter: false },
                                'rapmOffFtr': { label: 'RAPM Off FTR', higherBetter: true },
                                'rapmDefFtr': { label: 'RAPM Def FTR', higherBetter: false },
                                'rapmOffAst': { label: 'RAPM Off AST%', higherBetter: true },
                                'rapmStl': { label: 'RAPM STL%', higherBetter: true },
                                'rapmBlk': { label: 'RAPM BLK%', higherBetter: true },
                                'offEfg': { label: 'Off eFG% (ON)', higherBetter: true },
                                'defEfg': { label: 'Def eFG% (ON)', higherBetter: false },
                                'offTov': { label: 'Off TOV% (ON)', higherBetter: false },
                                'defTov': { label: 'Def TOV% (ON)', higherBetter: true },
                                'offOreb': { label: 'Off OREB% (ON)', higherBetter: true },
                                'defOreb': { label: 'Def OREB% (ON)', higherBetter: false },
                                'offFtR': { label: 'Off FT Rate (ON)', higherBetter: true },
                                'defFtR': { label: 'Def FT Rate (ON)', higherBetter: false },
                                'rimPct': { label: 'Rim% (ON)', higherBetter: true },
                                'midPct': { label: 'Mid% (ON)', higherBetter: true },
                                'threePct': { label: '3PT% (ON)', higherBetter: true },
                                'rimVol': { label: 'Rim Vol (ON)', higherBetter: true },
                                'midVol': { label: 'Mid Vol (ON)', higherBetter: false },
                                'threeVol': { label: '3PT Vol (ON)', higherBetter: true },
                                'astPct': { label: 'AST% (ON)', higherBetter: true },
                                'stlPct': { label: 'STL% (ON)', higherBetter: true },
                                'blkPct': { label: 'BLK% (ON)', higherBetter: true },
                                'paceF': { label: 'Off Pace (ON)', higherBetter: true },
                                'paceV': { label: 'Def Pace (ON)', higherBetter: false }
                            } : {
                                // Relative mode labels (ON-OFF differentials)
                                'net': { label: 'Net Rating ON-OFF', higherBetter: true },
                                'off': { label: 'Off Rating ON-OFF', higherBetter: true },
                                'def': { label: 'Def Rating ON-OFF', higherBetter: false },
                                'fourFactorsImpact': { label: '⚡ Four Factors Impact', higherBetter: true },
                                'scoringBattleImpact': { label: '🎯 Scoring Battle Impact', higherBetter: true },
                                'possBattleImpact': { label: '🔄 Possession Battle Impact', higherBetter: true },
                                'scoringBattle': { label: 'Scoring Battle', higherBetter: true },
                                'possessionBattle': { label: 'Possession Battle', higherBetter: true },
                                'bpm': { label: 'BPM', higherBetter: true },
                                'obpm': { label: 'OBPM', higherBetter: true },
                                'dbpm': { label: 'DBPM', higherBetter: true },
                                // V5.11: Bayesian Box APM
                                'apm': { label: '🔮 APM', higherBetter: true },
                                'oapm': { label: '🔮 OAPM', higherBetter: true },
                                'dapm': { label: '🔮 DAPM', higherBetter: true },
                                'rapm': { label: 'RAPM', higherBetter: true },
                                'orapm': { label: 'ORAPM', higherBetter: true },
                                'drapm': { label: 'DRAPM', higherBetter: true },
                                // Single-stat RAPM
                                'rapmOffEfg': { label: 'RAPM Off eFG%', higherBetter: true },
                                'rapmDefEfg': { label: 'RAPM Def eFG%', higherBetter: false },
                                'rapmOffTov': { label: 'RAPM Off TOV%', higherBetter: false },
                                'rapmDefTov': { label: 'RAPM Def TOV%', higherBetter: false },
                                'rapmOffOreb': { label: 'RAPM Off OREB%', higherBetter: true },
                                'rapmDefOreb': { label: 'RAPM Def OREB%', higherBetter: false },
                                'rapmOffFtr': { label: 'RAPM Off FTR', higherBetter: true },
                                'rapmDefFtr': { label: 'RAPM Def FTR', higherBetter: false },
                                'rapmOffAst': { label: 'RAPM Off AST%', higherBetter: true },
                                'rapmStl': { label: 'RAPM STL%', higherBetter: true },
                                'rapmBlk': { label: 'RAPM BLK%', higherBetter: true },
                                'offEfg': { label: 'Off eFG% ON-OFF', higherBetter: true },
                                'defEfg': { label: 'Def eFG% ON-OFF', higherBetter: false },
                                'offTov': { label: 'Off TOV% ON-OFF', higherBetter: false },
                                'defTov': { label: 'Def TOV% ON-OFF', higherBetter: true },
                                'offOreb': { label: 'Off OREB% ON-OFF', higherBetter: true },
                                'defOreb': { label: 'Def OREB% ON-OFF', higherBetter: false },
                                'offFtR': { label: 'Off FT Rate ON-OFF', higherBetter: true },
                                'defFtR': { label: 'Def FT Rate ON-OFF', higherBetter: false },
                                'rimPct': { label: 'Rim% ON-OFF', higherBetter: true },
                                'midPct': { label: 'Mid% ON-OFF', higherBetter: true },
                                'threePct': { label: '3PT% ON-OFF', higherBetter: true },
                                'rimVol': { label: 'Rim Vol ON-OFF', higherBetter: true },
                                'midVol': { label: 'Mid Vol ON-OFF', higherBetter: false },
                                'threeVol': { label: '3PT Vol ON-OFF', higherBetter: true },
                                'astPct': { label: 'AST% ON-OFF', higherBetter: true },
                                'stlPct': { label: 'STL% ON-OFF', higherBetter: true },
                                'blkPct': { label: 'BLK% ON-OFF', higherBetter: true },
                                'paceF': { label: 'Off Pace ON-OFF', higherBetter: true },
                                'paceV': { label: 'Def Pace ON-OFF', higherBetter: false }
                            };
                            
                            // Teams stat config (for teams mode)
                            const teamStatConfig = {
                                // Absolute stats
                                'adjOrtg': { label: 'Adj Off Rtg', higherBetter: true },
                                'adjDrtg': { label: 'Adj Def Rtg', higherBetter: false },
                                'adjNet': { label: 'Adj Net Rtg', higherBetter: true },
                                'rawOrtg': { label: 'Raw Off Rtg', higherBetter: true },
                                'rawDrtg': { label: 'Raw Def Rtg', higherBetter: false },
                                'rawNet': { label: 'Raw Net Rtg', higherBetter: true },
                                'wins': { label: 'Wins', higherBetter: true },
                                'losses': { label: 'Losses', higherBetter: false },
                                'winPct': { label: 'Win %', higherBetter: true },
                                'pythExpWins': { label: 'Pyth Expected Wins', higherBetter: true },
                                'pythProjWins': { label: 'Projected Wins', higherBetter: true },
                                'sosNet': { label: 'SOS Net', higherBetter: true },
                                'offEfg': { label: 'Off eFG%', higherBetter: true },
                                'offTovPct': { label: 'Off TOV%', higherBetter: false },
                                'offOrebPct': { label: 'Off OREB%', higherBetter: true },
                                'offFtRate': { label: 'Off FT Rate', higherBetter: true },
                                'defEfg': { label: 'Def eFG% (Opp)', higherBetter: false },
                                'defTovPct': { label: 'Def TOV% (Opp)', higherBetter: true },
                                'defOrebPct': { label: 'Def OREB% (Opp)', higherBetter: false },
                                'defFtRate': { label: 'Def FT Rate (Opp)', higherBetter: false },
                                'offEfgPA': { label: 'Off eFG% PA', higherBetter: true },
                                'offTovPA': { label: 'Off TOV% PA', higherBetter: true },
                                'offOrebPA': { label: 'Off OREB% PA', higherBetter: true },
                                'offFtRPA': { label: 'Off FT Rate PA', higherBetter: true },
                                'offScoringPA': { label: '🎯 Off Scoring PA', higherBetter: true },
                                'offPossPA': { label: '🔄 Off Poss PA', higherBetter: true },
                                'offTotalPA': { label: '⬆️ Off Total PA', higherBetter: true },
                                'defEfgPA': { label: 'Def eFG% PA', higherBetter: true },
                                'defTovPA': { label: 'Def TOV% PA', higherBetter: true },
                                'defOrebPA': { label: 'Def OREB% PA', higherBetter: true },
                                'defFtRPA': { label: 'Def FT Rate PA', higherBetter: true },
                                'defScoringPA': { label: '🎯 Def Scoring PA', higherBetter: true },
                                'defPossPA': { label: '🔄 Def Poss PA', higherBetter: true },
                                'defTotalPA': { label: '⬇️ Def Total PA', higherBetter: true },
                                // vs. League Average stats (all are differentials where higher = better)
                                'adjOrtgVsLg': { label: 'Adj Off Rtg vs Lg', higherBetter: true },
                                'adjDrtgVsLg': { label: 'Adj Def Rtg vs Lg', higherBetter: true },
                                'adjNetVsLg': { label: 'Adj Net Rtg vs Lg', higherBetter: true },
                                'rawOrtgVsLg': { label: 'Raw Off Rtg vs Lg', higherBetter: true },
                                'rawDrtgVsLg': { label: 'Raw Def Rtg vs Lg', higherBetter: true },
                                'rawNetVsLg': { label: 'Raw Net Rtg vs Lg', higherBetter: true },
                                'offEfgVsLg': { label: 'Off eFG% vs Lg', higherBetter: true },
                                'offTovPctVsLg': { label: 'Off TOV% vs Lg', higherBetter: true },
                                'offOrebPctVsLg': { label: 'Off OREB% vs Lg', higherBetter: true },
                                'offFtRateVsLg': { label: 'Off FT Rate vs Lg', higherBetter: true },
                                'defEfgVsLg': { label: 'Def eFG% vs Lg', higherBetter: true },
                                'defTovPctVsLg': { label: 'Def TOV% vs Lg', higherBetter: true },
                                'defOrebPctVsLg': { label: 'Def OREB% vs Lg', higherBetter: true },
                                'defFtRateVsLg': { label: 'Def FT Rate vs Lg', higherBetter: true }
                            };
                            
                            // =====================================================
                            // TEAMS MODE: Build team data from teamTotalsData
                            // =====================================================
                            let chartTeams = [];
                            if (exportChartDataMode === 'teams' && teamTotalsData.length > 0) {
                                // Build game data
                                const gameResults = new Map();
                                teamTotalsData.forEach(row => {
                                    const gameId = row.game_id;
                                    const teamName = row.team;
                                    if (!gameId || !teamName) return;
                                    if (!gameResults.has(gameId)) {
                                        gameResults.set(gameId, { teams: [], data: {} });
                                    }
                                    const game = gameResults.get(gameId);
                                    game.teams.push(teamName);
                                    game.data[teamName] = {
                                        pts: parseFloat(row.points) || 0,
                                        fgm: parseFloat(row.fgm) || 0,
                                        fga: parseFloat(row.fga) || 0,
                                        fg3m: parseFloat(row.fg3m) || 0,
                                        fg3a: parseFloat(row.fg3a) || 0,
                                        ftm: parseFloat(row.ftm) || 0,
                                        fta: parseFloat(row.fta) || 0,
                                        oreb: parseFloat(row.oreb) || 0,
                                        dreb: parseFloat(row.dreb) || 0,
                                        tov: parseFloat(row.tov) || 0,
                                        poss: parseFloat(row.poss) || 0
                                    };
                                });
                                
                                // Build team stats
                                const tStats = new Map();
                                gameResults.forEach(game => {
                                    if (game.teams.length !== 2) return;
                                    const [t1, t2] = game.teams;
                                    const d1 = game.data[t1], d2 = game.data[t2];
                                    
                                    [{ n: t1, own: d1, opp: d2, oppN: t2 }, { n: t2, own: d2, opp: d1, oppN: t1 }].forEach(({ n, own, opp, oppN }) => {
                                        if (!tStats.has(n)) {
                                            tStats.set(n, { games: 0, wins: 0, losses: 0, pts: 0, ptsA: 0, poss: 0, possA: 0,
                                                fgm: 0, fga: 0, fg3m: 0, fg3a: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, tov: 0,
                                                fgmA: 0, fgaA: 0, fg3mA: 0, fg3aA: 0, ftmA: 0, ftaA: 0, orebA: 0, drebA: 0, tovA: 0,
                                                opponents: [] });
                                        }
                                        const t = tStats.get(n);
                                        t.games++; t.pts += own.pts; t.ptsA += opp.pts;
                                        const ownPoss = own.poss || (own.fga - own.oreb + own.tov + 0.44 * own.fta);
                                        const oppPoss = opp.poss || (opp.fga - opp.oreb + opp.tov + 0.44 * opp.fta);
                                        t.poss += ownPoss; t.possA += oppPoss;
                                        t.fgm += own.fgm; t.fga += own.fga; t.fg3m += own.fg3m; t.fg3a += own.fg3a;
                                        t.ftm += own.ftm; t.fta += own.fta; t.oreb += own.oreb; t.dreb += own.dreb; t.tov += own.tov;
                                        t.fgmA += opp.fgm; t.fgaA += opp.fga; t.fg3mA += opp.fg3m; t.fg3aA += opp.fg3a;
                                        t.ftmA += opp.ftm; t.ftaA += opp.fta; t.orebA += opp.oreb; t.drebA += opp.dreb; t.tovA += opp.tov;
                                        if (own.pts > opp.pts) t.wins++; else t.losses++;
                                        t.opponents.push(oppN);
                                    });
                                });
                                
                                // League averages
                                let lgPts = 0, lgPoss = 0;
                                tStats.forEach(t => { lgPts += t.pts; lgPoss += t.poss; });
                                const leagueAvg = lgPoss > 0 ? (lgPts / lgPoss) * 100 : 100;
                                
                                // Raw ratings
                                const rawRtgs = new Map();
                                tStats.forEach((t, n) => {
                                    const ortg = t.poss > 0 ? (t.pts / t.poss) * 100 : leagueAvg;
                                    const drtg = t.possA > 0 ? (t.ptsA / t.possA) * 100 : leagueAvg;
                                    rawRtgs.set(n, { ortg, drtg, net: ortg - drtg });
                                });
                                
                                // Adjusted ratings
                                let adjO = new Map(), adjD = new Map();
                                rawRtgs.forEach((r, n) => { adjO.set(n, r.ortg); adjD.set(n, r.drtg); });
                                for (let i = 0; i < 10; i++) {
                                    const nO = new Map(), nD = new Map();
                                    tStats.forEach((t, n) => {
                                        if (t.opponents.length === 0) return;
                                        let sD = 0, sO = 0;
                                        t.opponents.forEach(op => { sD += adjD.get(op) || leagueAvg; sO += adjO.get(op) || leagueAvg; });
                                        const avgD = sD / t.opponents.length, avgO = sO / t.opponents.length;
                                        const raw = rawRtgs.get(n);
                                        nO.set(n, raw.ortg + (leagueAvg - avgD) * 0.8);
                                        nD.set(n, raw.drtg + (leagueAvg - avgO) * 0.8);
                                    });
                                    adjO = nO; adjD = nD;
                                }
                                
                                // SOS
                                const calcSOS = (n) => {
                                    const t = tStats.get(n);
                                    if (!t || t.opponents.length === 0) return 0;
                                    let sum = 0;
                                    t.opponents.forEach(op => sum += (adjO.get(op) || 100) - (adjD.get(op) || 100));
                                    return sum / t.opponents.length;
                                };
                                
                                // Build chart data
                                const allTeams = [...tStats.keys()];
                                const nTeams = allTeams.length;
                                const PYTH_EXP = 14;
                                
                                // First pass: calculate all team stats to get league averages
                                const teamStatsRaw = allTeams.map(name => {
                                    const t = tStats.get(name);
                                    const aO = adjO.get(name) || 100, aD = adjD.get(name) || 100;
                                    const raw = rawRtgs.get(name) || { ortg: 100, drtg: 100 };
                                    
                                    // Four Factors
                                    const offEfg = t.fga > 0 ? ((t.fgm + 0.5 * t.fg3m) / t.fga) * 100 : 50;
                                    const offTovPct = (t.fga + 0.44 * t.fta + t.tov) > 0 ? (t.tov / (t.fga + 0.44 * t.fta + t.tov)) * 100 : 12;
                                    const offOrebPct = (t.oreb + t.drebA) > 0 ? (t.oreb / (t.oreb + t.drebA)) * 100 : 25;
                                    const offFtRate = t.fga > 0 ? (t.fta / t.fga) * 100 : 25;
                                    const defEfg = t.fgaA > 0 ? ((t.fgmA + 0.5 * t.fg3mA) / t.fgaA) * 100 : 50;
                                    const defTovPct = (t.fgaA + 0.44 * t.ftaA + t.tovA) > 0 ? (t.tovA / (t.fgaA + 0.44 * t.ftaA + t.tovA)) * 100 : 12;
                                    const defOrebPct = (t.orebA + t.dreb) > 0 ? (t.orebA / (t.orebA + t.dreb)) * 100 : 25;
                                    const defFtRate = t.fgaA > 0 ? (t.ftaA / t.fgaA) * 100 : 25;
                                    
                                    return { name, t, aO, aD, raw, offEfg, offTovPct, offOrebPct, offFtRate, defEfg, defTovPct, defOrebPct, defFtRate };
                                });
                                
                                // Calculate league averages
                                const lgAvg = {
                                    adjOrtg: teamStatsRaw.reduce((s, t) => s + t.aO, 0) / nTeams,
                                    adjDrtg: teamStatsRaw.reduce((s, t) => s + t.aD, 0) / nTeams,
                                    rawOrtg: teamStatsRaw.reduce((s, t) => s + t.raw.ortg, 0) / nTeams,
                                    rawDrtg: teamStatsRaw.reduce((s, t) => s + t.raw.drtg, 0) / nTeams,
                                    offEfg: teamStatsRaw.reduce((s, t) => s + t.offEfg, 0) / nTeams,
                                    offTovPct: teamStatsRaw.reduce((s, t) => s + t.offTovPct, 0) / nTeams,
                                    offOrebPct: teamStatsRaw.reduce((s, t) => s + t.offOrebPct, 0) / nTeams,
                                    offFtRate: teamStatsRaw.reduce((s, t) => s + t.offFtRate, 0) / nTeams,
                                    defEfg: teamStatsRaw.reduce((s, t) => s + t.defEfg, 0) / nTeams,
                                    defTovPct: teamStatsRaw.reduce((s, t) => s + t.defTovPct, 0) / nTeams,
                                    defOrebPct: teamStatsRaw.reduce((s, t) => s + t.defOrebPct, 0) / nTeams,
                                    defFtRate: teamStatsRaw.reduce((s, t) => s + t.defFtRate, 0) / nTeams
                                };
                                
                                // Second pass: build final chart data with vs league avg stats
                                chartTeams = teamStatsRaw.map(({ name, t, aO, aD, raw, offEfg, offTovPct, offOrebPct, offFtRate, defEfg, defTovPct, defOrebPct, defFtRate }) => {
                                    
                                    // Points Added
                                    const offEfgPA = (offEfg - 50) * 2.0;
                                    const offTovPA = (12 - offTovPct) * 1.4;
                                    const offOrebPA = (offOrebPct - 25) * 0.7;
                                    const offFtRPA = (offFtRate - 25) * 0.4;
                                    const defEfgPA = (50 - defEfg) * 2.0;
                                    const defTovPA = (defTovPct - 12) * 1.4;
                                    const defOrebPA = (25 - defOrebPct) * 0.7;
                                    const defFtRPA = (25 - defFtRate) * 0.4;
                                    
                                    // Pyth
                                    const pf = Math.pow(t.pts / t.games, PYTH_EXP);
                                    const pa = Math.pow(t.ptsA / t.games, PYTH_EXP);
                                    const pythExpWins = (pf + pa) > 0 ? pf / (pf + pa) * t.games : t.games / 2;
                                    
                                    // Proj wins
                                    let pythProjWins = 0;
                                    const adjNet = aO - aD;
                                    allTeams.forEach(op => {
                                        if (op === name) return;
                                        const oppNet = (adjO.get(op) || 100) - (adjD.get(op) || 100);
                                        pythProjWins += (1 / (1 + Math.pow(10, -(adjNet - oppNet) / 10))) * 4;
                                    });
                                    
                                    // vs. League Average differentials
                                    const adjOrtgVsLg = aO - lgAvg.adjOrtg;
                                    const adjDrtgVsLg = lgAvg.adjDrtg - aD; // Flipped: lower def rating is better
                                    const adjNetVsLg = adjNet; // Net is already a differential
                                    const rawOrtgVsLg = raw.ortg - lgAvg.rawOrtg;
                                    const rawDrtgVsLg = lgAvg.rawDrtg - raw.drtg; // Flipped
                                    const rawNetVsLg = raw.net;
                                    const offEfgVsLg = offEfg - lgAvg.offEfg;
                                    const offTovPctVsLg = lgAvg.offTovPct - offTovPct; // Flipped: lower TOV is better
                                    const offOrebPctVsLg = offOrebPct - lgAvg.offOrebPct;
                                    const offFtRateVsLg = offFtRate - lgAvg.offFtRate;
                                    const defEfgVsLg = lgAvg.defEfg - defEfg; // Flipped: lower opp eFG is better
                                    const defTovPctVsLg = defTovPct - lgAvg.defTovPct; // Higher opp TOV is better
                                    const defOrebPctVsLg = lgAvg.defOrebPct - defOrebPct; // Flipped: lower opp OREB is better
                                    const defFtRateVsLg = lgAvg.defFtRate - defFtRate; // Flipped: lower opp FT rate is better
                                    
                                    return {
                                        name, team: name,
                                        // Absolute stats
                                        adjOrtg: aO, adjDrtg: aD, adjNet,
                                        rawOrtg: raw.ortg, rawDrtg: raw.drtg, rawNet: raw.net,
                                        wins: t.wins, losses: t.losses, winPct: t.games > 0 ? (t.wins / t.games) * 100 : 50,
                                        pythExpWins, pythProjWins: Math.round(pythProjWins),
                                        sosNet: calcSOS(name),
                                        offEfg, offTovPct, offOrebPct, offFtRate,
                                        defEfg, defTovPct, defOrebPct, defFtRate,
                                        offEfgPA, offTovPA, offOrebPA, offFtRPA,
                                        offScoringPA: offEfgPA + offFtRPA, offPossPA: offTovPA + offOrebPA,
                                        offTotalPA: offEfgPA + offTovPA + offOrebPA + offFtRPA,
                                        defEfgPA, defTovPA, defOrebPA, defFtRPA,
                                        defScoringPA: defEfgPA + defFtRPA, defPossPA: defTovPA + defOrebPA,
                                        defTotalPA: defEfgPA + defTovPA + defOrebPA + defFtRPA,
                                        // vs. League Average stats (for differential mode)
                                        adjOrtgVsLg, adjDrtgVsLg, adjNetVsLg,
                                        rawOrtgVsLg, rawDrtgVsLg, rawNetVsLg,
                                        offEfgVsLg, offTovPctVsLg, offOrebPctVsLg, offFtRateVsLg,
                                        defEfgVsLg, defTovPctVsLg, defOrebPctVsLg, defFtRateVsLg
                                    };
                                });
                            }
                            
                            // =====================================================
                            // PLAYERS MODE: Get player data (original logic)
                            // =====================================================
                            const players = onOffData
                                .filter(d => exportTeam === '' || d.team === exportTeam)
                                .filter(d => d.onMinutes >= exportMinMins)
                                .map(d => {
                                    // V5.10: Use BPM from CSV if available, otherwise calculate
                                    const seasonStats = seasonStatsMap.get(normalizePlayerName(d.player));
                                    let bpm = 0, obpm = 0, dbpm = 0;
                                    if (seasonStats) {
                                        // Check if CSV has BPM values
                                        if (seasonStats.bpm !== null && seasonStats.bpm !== undefined && !isNaN(seasonStats.bpm)) {
                                            bpm = seasonStats.bpm;
                                            obpm = seasonStats.obpm || 0;
                                            dbpm = seasonStats.dbpm || 0;
                                        } else {
                                            // Calculate from box score stats
                                            const mpg = seasonStats.mpg || 20;
                                            const usg = (seasonStats.usg || 20) / 100;
                                            const pts = seasonStats.ppg || 0;
                                            const games = seasonStats.games || 1;
                                            const ast = (seasonStats.ast / games) || 0;
                                            const reb = (seasonStats.reb / games) || 0;
                                            const stl = (seasonStats.stl / games) || 0;
                                            const blk = (seasonStats.blk / games) || 0;
                                            const tov = (seasonStats.tov / games) || 0;
                                            const tsPct = seasonStats.fga > 0 ? (seasonStats.pts / (2 * (seasonStats.fga + 0.44 * seasonStats.fta))) : 0.5;
                                            const scoringImpact = (tsPct - 0.55) * 100 * usg;
                                            const assistImpact = ast * 0.5;
                                            const rebImpact = reb * 0.3;
                                            const defImpact = stl * 1.5 + blk * 0.8;
                                            const tovPenalty = tov * -0.5;
                                            obpm = scoringImpact + assistImpact + rebImpact * 0.3 + tovPenalty;
                                            dbpm = defImpact + rebImpact * 0.7;
                                            bpm = obpm + dbpm;
                                        }
                                    }
                                    
                                    // V5.7: Get RAPM from playerRapmStats - correct structure access
                                    let rapm = 0, orapm = 0, drapm = 0;
                                    if (playerRapmStats && playerRapmStats.stats && playerRapmStats.stats.ORtg) {
                                        const ortgStats = playerRapmStats.stats.ORtg;
                                        const normalizedName = normalizePlayerName(d.player);
                                        const matchingPlayer = Object.keys(ortgStats).find(p => normalizePlayerName(p) === normalizedName);
                                        if (matchingPlayer && ortgStats[matchingPlayer]) {
                                            orapm = ortgStats[matchingPlayer].oRAPM || 0;
                                            const rawDrapm = ortgStats[matchingPlayer].dRAPM || 0;
                                            rapm = orapm + rawDrapm;
                                            // V8.1: Negate DRAPM display so positive = good defense
                                            drapm = -rawDrapm;
                                        }
                                    }

                                    // V5.12: Extract APM values (hybrid RAPM with Bayesian Box)
                                    let apm = 0, oapm = 0, dapm = 0;
                                    if (playerApmStats && playerApmStats.players) {
                                        const apmResult = PlayerRAPMEngine.getPlayerApmValue(playerApmStats, d.player);
                                        if (apmResult) {
                                            apm = apmResult.apm || 0;
                                            oapm = apmResult.oapm || 0;
                                            dapm = apmResult.dapm || 0;
                                        }
                                    }
                                    
                                    // V5.10: Helper to get single-stat RAPM value for chart
                                    const getChartSingleStatRapm = (playerName, statKey, useDefCoef = false) => {
                                        if (!playerRapmStats || !playerRapmStats.stats || !playerRapmStats.stats[statKey]) return 0;
                                        const statResults = playerRapmStats.stats[statKey];
                                        const normalizedName = normalizePlayerName(playerName);
                                        const matchingPlayer = Object.keys(statResults).find(p => normalizePlayerName(p) === normalizedName);
                                        if (matchingPlayer && statResults[matchingPlayer]) {
                                            return useDefCoef ? (statResults[matchingPlayer].dRAPM || 0) : (statResults[matchingPlayer].oRAPM || 0);
                                        }
                                        return 0;
                                    };
                                    
                                    // V5.10: Extract all single-stat RAPM values for chart
                                    // Use RAW values - higherBetter in statConfig handles sorting direction
                                    // V5.12: Defensive RAPM stats are NEGATED so that:
                                    //   - Negative = good defense (below avg opp performance) = green/sorted first
                                    //   - Positive = bad defense (above avg opp performance) = red/sorted last
                                    const rapmOffEfg = getChartSingleStatRapm(d.player, 'eFG', false);
                                    const rapmDefEfg = -getChartSingleStatRapm(d.player, 'eFG', true);
                                    const rapmOffTov = getChartSingleStatRapm(d.player, 'TOV', false);
                                    const rapmDefTov = -getChartSingleStatRapm(d.player, 'TOV', true);
                                    const rapmOffOreb = getChartSingleStatRapm(d.player, 'OREB', false);
                                    const rapmDefOreb = -getChartSingleStatRapm(d.player, 'OREB', true);
                                    const rapmOffFtr = getChartSingleStatRapm(d.player, 'FTR', false);
                                    const rapmDefFtr = -getChartSingleStatRapm(d.player, 'FTR', true);
                                    const rapmOffAst = getChartSingleStatRapm(d.player, 'AST', false);
                                    const rapmStl = getChartSingleStatRapm(d.player, 'STL', false);
                                    const rapmBlk = getChartSingleStatRapm(d.player, 'BLK', false);
                                    
                                    // V5.8: Calculate stats based on absolute vs relative (ON-OFF) mode
                                    const on = d.onStats || {};
                                    const off = d.offStats || {};
                                    
                                    // V5.8: Use raw ON values for absolute mode, ON-OFF differentials for relative mode
                                    let net, offRtg, defRtg;
                                    let offEfg, defEfg, offTov, defTov, offOreb, defOreb, offFtR, defFtR;
                                    let rimPct, midPct, threePct, rimVol, midVol, threeVol;
                                    let astPct, stlPct, blkPct, paceF, paceV;
                                    
                                    if (exportChartAbsolute) {
                                        // Absolute mode: raw ON court values
                                        net = on.net || 0;
                                        offRtg = on.off || 0;
                                        defRtg = on.def || 0;
                                        offEfg = on.offEfg || 0;
                                        defEfg = on.defEfg || 0;
                                        offTov = on.offTov || 0;
                                        defTov = on.defTov || 0;
                                        offOreb = on.offOreb || 0;
                                        defOreb = on.defOreb || 0;
                                        offFtR = on.offFtR || 0;
                                        defFtR = on.defFtR || 0;
                                        rimPct = on.rimPct || 0;
                                        midPct = on.midPct || 0;
                                        threePct = on.threePct || 0;
                                        rimVol = on.rimVol || 0;
                                        midVol = on.midVol || 0;
                                        threeVol = on.threeVol || 0;
                                        astPct = on.astPct || 0;
                                        stlPct = on.stlPct || 0;
                                        blkPct = on.blkPct || 0;
                                        paceF = on.paceF || 0;
                                        paceV = on.paceV || 0;
                                    } else {
                                        // Relative mode: ON-OFF differentials
                                        net = (on.net || 0) - (off.net || 0);
                                        offRtg = (on.off || 0) - (off.off || 0);
                                        defRtg = (on.def || 0) - (off.def || 0);
                                        offEfg = (on.offEfg || 0) - (off.offEfg || 0);
                                        defEfg = (on.defEfg || 0) - (off.defEfg || 0);
                                        offTov = (on.offTov || 0) - (off.offTov || 0);
                                        defTov = (on.defTov || 0) - (off.defTov || 0);
                                        offOreb = (on.offOreb || 0) - (off.offOreb || 0);
                                        defOreb = (on.defOreb || 0) - (off.defOreb || 0);
                                        offFtR = (on.offFtR || 0) - (off.offFtR || 0);
                                        defFtR = (on.defFtR || 0) - (off.defFtR || 0);
                                        rimPct = (on.rimPct || 0) - (off.rimPct || 0);
                                        midPct = (on.midPct || 0) - (off.midPct || 0);
                                        threePct = (on.threePct || 0) - (off.threePct || 0);
                                        rimVol = (on.rimVol || 0) - (off.rimVol || 0);
                                        midVol = (on.midVol || 0) - (off.midVol || 0);
                                        threeVol = (on.threeVol || 0) - (off.threeVol || 0);
                                        astPct = (on.astPct || 0) - (off.astPct || 0);
                                        stlPct = (on.stlPct || 0) - (off.stlPct || 0);
                                        blkPct = (on.blkPct || 0) - (off.blkPct || 0);
                                        paceF = (on.paceF || 0) - (off.paceF || 0);
                                        paceV = (on.paceV || 0) - (off.paceV || 0);
                                    }
                                    
                                    // Calculate Scoring Battle and Possession Battle from ON stats
                                    const scoringBattle = (on.offEfg || 0) - (on.defEfg || 0);
                                    const possessionBattle = ((on.defTov || 0) - (on.offTov || 0)) + ((on.offOreb || 0) - (on.defOreb || 0));
                                    
                                    return {
                                        name: d.player,
                                        team: d.team,
                                        onMins: d.onMinutes,
                                        net, off: offRtg, def: defRtg,
                                        offEfg, defEfg, offTov, defTov, offOreb, defOreb, offFtR, defFtR,
                                        rimPct, midPct, threePct, rimVol, midVol, threeVol,
                                        astPct, stlPct, blkPct, paceF, paceV,
                                        bpm, obpm, dbpm,
                                        rapm, orapm, drapm,
                                        // V5.12: Bayesian Box APM values
                                        apm, oapm, dapm,
                                        // Single-stat RAPM values
                                        rapmOffEfg, rapmDefEfg,
                                        rapmOffTov, rapmDefTov,
                                        rapmOffOreb, rapmDefOreb,
                                        rapmOffFtr, rapmDefFtr,
                                        rapmOffAst, rapmStl, rapmBlk,
                                        scoringBattle, possessionBattle
                                    };
                                });
                            
                            // V5.8: Calculate Four Factors Impact stats for chart (z-score normalized)
                            const calcChartDistribution = (arr) => {
                                if (!arr.length) return { mean: 0, stdDev: 1 };
                                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                                const variance = arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
                                return { mean, stdDev: Math.sqrt(variance) || 1 };
                            };
                            
                            const chartFFDistributions = {
                                offEfg: calcChartDistribution(players.map(p => p.offEfg || 0)),
                                offTov: calcChartDistribution(players.map(p => p.offTov || 0)),
                                offOreb: calcChartDistribution(players.map(p => p.offOreb || 0)),
                                offFtR: calcChartDistribution(players.map(p => p.offFtR || 0)),
                                defEfg: calcChartDistribution(players.map(p => p.defEfg || 0)),
                                defTov: calcChartDistribution(players.map(p => p.defTov || 0)),
                                defOreb: calcChartDistribution(players.map(p => p.defOreb || 0)),
                                defFtR: calcChartDistribution(players.map(p => p.defFtR || 0))
                            };
                            
                            const calcChartZScore = (val, dist, higherBetter) => {
                                const z = (val - dist.mean) / dist.stdDev;
                                return higherBetter ? z : -z;
                            };
                            
                            // Add impact stats to each player
                            players.forEach(p => {
                                const zScores = {
                                    offEfg: calcChartZScore(p.offEfg || 0, chartFFDistributions.offEfg, true),
                                    offTov: calcChartZScore(p.offTov || 0, chartFFDistributions.offTov, false),
                                    offOreb: calcChartZScore(p.offOreb || 0, chartFFDistributions.offOreb, true),
                                    offFtR: calcChartZScore(p.offFtR || 0, chartFFDistributions.offFtR, true),
                                    defEfg: calcChartZScore(p.defEfg || 0, chartFFDistributions.defEfg, false),
                                    defTov: calcChartZScore(p.defTov || 0, chartFFDistributions.defTov, true),
                                    defOreb: calcChartZScore(p.defOreb || 0, chartFFDistributions.defOreb, false),
                                    defFtR: calcChartZScore(p.defFtR || 0, chartFFDistributions.defFtR, false)
                                };
                                p.possBattleImpact = zScores.offOreb + zScores.offTov + zScores.defOreb + zScores.defTov;
                                p.scoringBattleImpact = zScores.offEfg + zScores.offFtR + zScores.defEfg + zScores.defFtR;
                                p.fourFactorsImpact = p.possBattleImpact + p.scoringBattleImpact;
                            });
                            
                            // Get stat values
                            const getStatVal = (p, stat) => p[stat] || 0;
                            
                            // Unified data array for chart rendering
                            const chartData = exportChartDataMode === 'teams' ? chartTeams : players;
                            const activeStatConfig = exportChartDataMode === 'teams' ? teamStatConfig : chartStatConfig;
                            
                            // Check if data is available
                            if (chartData.length === 0) {
                                return e('div', { style: { textAlign: 'center', padding: '40px', color: '#94a3b8' }},
                                    exportChartDataMode === 'teams' 
                                        ? e('div', null,
                                            e('div', { style: { fontSize: '20px', marginBottom: '8px' }}, '🏀'),
                                            e('div', { style: { fontSize: '14px', fontWeight: '600', marginBottom: '4px' }}, 'No Team Data Available'),
                                            e('div', { style: { fontSize: '12px' }}, 'Load team_totals.csv to use Teams mode in charts')
                                        )
                                        : e('div', null,
                                            e('div', { style: { fontSize: '14px', fontWeight: '600' }}, 'No Player Data Available'),
                                            e('div', { style: { fontSize: '12px' }}, 'Load game data to view player charts')
                                        )
                                );
                            }
                            
                            // V5.9: Helper function to render a single chart
                            const renderSingleChart = (xStat, yStat, chartW, chartH, chartId) => {
                                // Calculate chart bounds for this specific chart
                                const xValsLocal = chartData.map(p => getStatVal(p, xStat));
                                const yValsLocal = chartData.map(p => getStatVal(p, yStat));
                                
                                const rawXMinLocal = Math.min(...xValsLocal);
                                const rawXMaxLocal = Math.max(...xValsLocal);
                                const rawYMinLocal = Math.min(...yValsLocal);
                                const rawYMaxLocal = Math.max(...yValsLocal);
                                
                                const xSpansZeroLocal = rawXMinLocal < 0 && rawXMaxLocal > 0;
                                const ySpansZeroLocal = rawYMinLocal < 0 && rawYMaxLocal > 0;
                                
                                let xMinLocal, xMaxLocal, yMinLocal, yMaxLocal;
                                if (xSpansZeroLocal) {
                                    const xAbsMax = Math.max(Math.abs(rawXMinLocal), Math.abs(rawXMaxLocal));
                                    xMinLocal = -xAbsMax * 1.1;
                                    xMaxLocal = xAbsMax * 1.1;
                                } else {
                                    const xRange = rawXMaxLocal - rawXMinLocal;
                                    const xPadding = Math.max(xRange * 0.1, 1);
                                    xMinLocal = rawXMinLocal - xPadding;
                                    xMaxLocal = rawXMaxLocal + xPadding;
                                }
                                
                                if (ySpansZeroLocal) {
                                    const yAbsMax = Math.max(Math.abs(rawYMinLocal), Math.abs(rawYMaxLocal));
                                    yMinLocal = -yAbsMax * 1.1;
                                    yMaxLocal = yAbsMax * 1.1;
                                } else {
                                    const yRange = rawYMaxLocal - rawYMinLocal;
                                    const yPadding = Math.max(yRange * 0.1, 1);
                                    yMinLocal = rawYMinLocal - yPadding;
                                    yMaxLocal = rawYMaxLocal + yPadding;
                                }
                                
                                // Dimensions
                                const paddingLocal = { top: 50, right: 30, bottom: 60, left: 60 };
                                const plotWidthLocal = chartW - paddingLocal.left - paddingLocal.right;
                                const plotHeightLocal = chartH - paddingLocal.top - paddingLocal.bottom;
                                
                                // V5.9: Get stat config for axis inversion
                                const xStatCfgLocal = activeStatConfig[xStat] || { higherBetter: true };
                                const yStatCfgLocal = activeStatConfig[yStat] || { higherBetter: true };
                                
                                // Scale functions - V5.9: Invert axes for stats where lower is better
                                const scaleXLocal = (val) => {
                                    const normalized = (val - xMinLocal) / (xMaxLocal - xMinLocal);
                                    return xStatCfgLocal.higherBetter 
                                        ? paddingLocal.left + normalized * plotWidthLocal
                                        : paddingLocal.left + plotWidthLocal - normalized * plotWidthLocal;
                                };
                                const scaleYLocal = (val) => {
                                    const normalized = (val - yMinLocal) / (yMaxLocal - yMinLocal);
                                    return yStatCfgLocal.higherBetter
                                        ? paddingLocal.top + plotHeightLocal - normalized * plotHeightLocal
                                        : paddingLocal.top + normalized * plotHeightLocal;
                                };
                                
                                // Ticks
                                const getNiceTicksLocal = (min, max, targetCount) => {
                                    const range = max - min;
                                    const roughStep = range / targetCount;
                                    const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
                                    const residual = roughStep / magnitude;
                                    let niceStep;
                                    if (residual <= 1.5) niceStep = 1 * magnitude;
                                    else if (residual <= 3) niceStep = 2 * magnitude;
                                    else if (residual <= 7) niceStep = 5 * magnitude;
                                    else niceStep = 10 * magnitude;
                                    const ticks = [];
                                    const start = Math.ceil(min / niceStep) * niceStep;
                                    for (let tick = start; tick <= max; tick += niceStep) {
                                        ticks.push(Math.round(tick * 1000) / 1000);
                                    }
                                    return ticks;
                                };
                                
                                const xTicksLocal = getNiceTicksLocal(xMinLocal, xMaxLocal, 5);
                                const yTicksLocal = getNiceTicksLocal(yMinLocal, yMaxLocal, 5);
                                
                                // Zero lines
                                const zeroXLocal = scaleXLocal(0);
                                const zeroYLocal = scaleYLocal(0);
                                const showZeroXLocal = !exportChartAbsolute && 0 > xMinLocal && 0 < xMaxLocal;
                                const showZeroYLocal = !exportChartAbsolute && 0 > yMinLocal && 0 < yMaxLocal;
                                
                                // Regression
                                const calcRegressionLocal = (xData, yData) => {
                                    const n = xData.length;
                                    if (n < 2) return null;
                                    const sumX = xData.reduce((a, b) => a + b, 0);
                                    const sumY = yData.reduce((a, b) => a + b, 0);
                                    const sumXY = xData.reduce((acc, x, i) => acc + x * yData[i], 0);
                                    const sumXX = xData.reduce((acc, x) => acc + x * x, 0);
                                    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                                    const intercept = (sumY - slope * sumX) / n;
                                    const yMean = sumY / n;
                                    const ssTotal = yData.reduce((acc, y) => acc + Math.pow(y - yMean, 2), 0);
                                    const ssResidual = yData.reduce((acc, y, i) => acc + Math.pow(y - (slope * xData[i] + intercept), 2), 0);
                                    const rSquared = 1 - (ssResidual / ssTotal);
                                    return { slope, intercept, rSquared };
                                };
                                
                                const regressionLocal = exportChartShowCorrelation ? calcRegressionLocal(xValsLocal, yValsLocal) : null;
                                
                                // Color helper
                                const getAdjustedValueLocal = (val, statKey) => {
                                    const cfg = chartStatConfig[statKey];
                                    if (!cfg) return val;
                                    return cfg.higherBetter ? val : -val;
                                };
                                
                                const getImpactColorLocal = (p) => {
                                    const adjX = getAdjustedValueLocal(getStatVal(p, xStat), xStat);
                                    const adjY = getAdjustedValueLocal(getStatVal(p, yStat), yStat);
                                    const impact = (adjX + adjY) / 2;
                                    const normalized = Math.abs(adjX) > 50 || Math.abs(adjY) > 50 ? impact / 10 : impact;
                                    if (normalized > 0.5) return '#4ade80';
                                    if (normalized < -0.5) return '#f87171';
                                    return '#94a3b8';
                                };
                                
                                // Labels - V5.9: Show "Better" direction since axes are inverted for lower-is-better stats
                                const xCfgLocal = chartStatConfig[xStat] || { label: xStat, higherBetter: true };
                                const yCfgLocal = chartStatConfig[yStat] || { label: yStat, higherBetter: true };
                                const xLabelLocal = xCfgLocal.label + ' →';
                                const yLabelLocal = yCfgLocal.label + ' ↑';
                                
                                return e('svg', { 
                                    key: chartId,
                                    width: chartW, 
                                    height: chartH,
                                    style: { background: '#0f172a', borderRadius: '8px', border: '1px solid #334155' }
                                },
                                    // Quadrant backgrounds
                                    showZeroXLocal && showZeroYLocal && e('g', null,
                                        e('rect', { x: zeroXLocal, y: paddingLocal.top, width: paddingLocal.left + plotWidthLocal - zeroXLocal, height: zeroYLocal - paddingLocal.top, fill: '#22c55e', opacity: 0.05 }),
                                        e('rect', { x: paddingLocal.left, y: zeroYLocal, width: zeroXLocal - paddingLocal.left, height: paddingLocal.top + plotHeightLocal - zeroYLocal, fill: '#ef4444', opacity: 0.05 }),
                                        e('rect', { x: paddingLocal.left, y: paddingLocal.top, width: zeroXLocal - paddingLocal.left, height: zeroYLocal - paddingLocal.top, fill: '#f59e0b', opacity: 0.03 }),
                                        e('rect', { x: zeroXLocal, y: zeroYLocal, width: paddingLocal.left + plotWidthLocal - zeroXLocal, height: paddingLocal.top + plotHeightLocal - zeroYLocal, fill: '#f59e0b', opacity: 0.03 })
                                    ),
                                    
                                    // Grid lines
                                    xTicksLocal.map((tick, i) => e('line', { key: 'gx' + chartId + i, x1: scaleXLocal(tick), y1: paddingLocal.top, x2: scaleXLocal(tick), y2: paddingLocal.top + plotHeightLocal, stroke: '#334155', strokeWidth: 0.5 })),
                                    yTicksLocal.map((tick, i) => e('line', { key: 'gy' + chartId + i, x1: paddingLocal.left, y1: scaleYLocal(tick), x2: paddingLocal.left + plotWidthLocal, y2: scaleYLocal(tick), stroke: '#334155', strokeWidth: 0.5 })),
                                    
                                    // Zero lines
                                    showZeroXLocal && e('line', { x1: zeroXLocal, y1: paddingLocal.top, x2: zeroXLocal, y2: paddingLocal.top + plotHeightLocal, stroke: '#64748b', strokeWidth: 1.5 }),
                                    showZeroYLocal && e('line', { x1: paddingLocal.left, y1: zeroYLocal, x2: paddingLocal.left + plotWidthLocal, y2: zeroYLocal, stroke: '#64748b', strokeWidth: 1.5 }),
                                    
                                    // Diagonal line (when no quadrants)
                                    !(showZeroXLocal && showZeroYLocal) && e('line', {
                                        x1: paddingLocal.left, y1: paddingLocal.top + plotHeightLocal,
                                        x2: paddingLocal.left + plotWidthLocal, y2: paddingLocal.top,
                                        stroke: '#475569', strokeWidth: 1.5, strokeDasharray: '8,4'
                                    }),
                                    
                                    // Axes
                                    e('line', { x1: paddingLocal.left, y1: paddingLocal.top + plotHeightLocal, x2: paddingLocal.left + plotWidthLocal, y2: paddingLocal.top + plotHeightLocal, stroke: '#475569', strokeWidth: 2 }),
                                    e('line', { x1: paddingLocal.left, y1: paddingLocal.top, x2: paddingLocal.left, y2: paddingLocal.top + plotHeightLocal, stroke: '#475569', strokeWidth: 2 }),
                                    
                                    // Axis labels
                                    e('text', { x: chartW / 2, y: chartH - 10, fill: '#94a3b8', fontSize: '11px', textAnchor: 'middle', fontWeight: '600' }, xLabelLocal),
                                    e('text', { x: 14, y: chartH / 2, fill: '#94a3b8', fontSize: '11px', textAnchor: 'middle', fontWeight: '600', transform: `rotate(-90, 14, ${chartH/2})` }, yLabelLocal),
                                    
                                    // Tick labels
                                    xTicksLocal.map((tick, i) => e('text', { key: 'tx' + chartId + i, x: scaleXLocal(tick), y: paddingLocal.top + plotHeightLocal + 16, fill: '#64748b', fontSize: '9px', textAnchor: 'middle' }, Number.isInteger(tick) ? tick.toString() : tick.toFixed(1))),
                                    yTicksLocal.map((tick, i) => e('text', { key: 'ty' + chartId + i, x: paddingLocal.left - 8, y: scaleYLocal(tick) + 3, fill: '#64748b', fontSize: '9px', textAnchor: 'end' }, Number.isInteger(tick) ? tick.toString() : tick.toFixed(1))),
                                    
                                    // Trend line
                                    regressionLocal && e('line', {
                                        x1: scaleXLocal(xMinLocal), y1: scaleYLocal(regressionLocal.slope * xMinLocal + regressionLocal.intercept),
                                        x2: scaleXLocal(xMaxLocal), y2: scaleYLocal(regressionLocal.slope * xMaxLocal + regressionLocal.intercept),
                                        stroke: '#f59e0b', strokeWidth: 2, strokeDasharray: '6,3'
                                    }),
                                    
                                    // R² value
                                    regressionLocal && e('text', {
                                        x: paddingLocal.left + plotWidthLocal - 5, y: paddingLocal.top + 12,
                                        fill: '#f59e0b', fontSize: '10px', textAnchor: 'end', fontWeight: '600'
                                    }, 'R² = ' + regressionLocal.rSquared.toFixed(3)),
                                    
                                    // V5.24: Calculate outliers for smart labels (top/bottom 3 in each quadrant)
                                    (() => {
                                        const outlierSet = new Set();
                                        if (exportChartSmartLabels && exportChartDataMode === 'players') {
                                            // Calculate quadrant outliers
                                            const xMean = xValsLocal.reduce((a, b) => a + b, 0) / xValsLocal.length;
                                            const yMean = yValsLocal.reduce((a, b) => a + b, 0) / yValsLocal.length;
                                            const q1 = chartData.filter(p => getStatVal(p, xStat) > xMean && getStatVal(p, yStat) > yMean); // Top-right
                                            const q2 = chartData.filter(p => getStatVal(p, xStat) <= xMean && getStatVal(p, yStat) > yMean); // Top-left
                                            const q3 = chartData.filter(p => getStatVal(p, xStat) <= xMean && getStatVal(p, yStat) <= yMean); // Bottom-left
                                            const q4 = chartData.filter(p => getStatVal(p, xStat) > xMean && getStatVal(p, yStat) <= yMean); // Bottom-right
                                            // Get extreme 3 from each quadrant based on distance from center
                                            [q1, q2, q3, q4].forEach(q => {
                                                q.sort((a, b) => {
                                                    const distA = Math.pow(getStatVal(a, xStat) - xMean, 2) + Math.pow(getStatVal(a, yStat) - yMean, 2);
                                                    const distB = Math.pow(getStatVal(b, xStat) - xMean, 2) + Math.pow(getStatVal(b, yStat) - yMean, 2);
                                                    return distB - distA;
                                                });
                                                q.slice(0, 3).forEach(p => outlierSet.add(p.name));
                                            });
                                        }
                                        return outlierSet;
                                    })(),
                                    // Data points
                                    chartData.map((p, i) => {
                                        const xVal = getStatVal(p, xStat);
                                        const yVal = getStatVal(p, yStat);
                                        const cx = scaleXLocal(xVal);
                                        const cy = scaleYLocal(yVal);
                                        // V5.24: Team highlighting
                                        const isHighlighted = exportChartDataMode === 'players' && exportChartHighlightTeam && p.team === exportChartHighlightTeam;
                                        const isDimmed = exportChartDataMode === 'players' && exportChartHighlightTeam && p.team !== exportChartHighlightTeam;
                                        const pointColor = exportChartDataMode === 'teams'
                                            ? (p.adjNet >= 0 ? '#4ade80' : '#f87171')
                                            : isHighlighted ? '#fbbf24' : getImpactColorLocal(p);
                                        const hasImage = exportChartDataMode === 'teams'
                                            ? exportSOSTeamImages[p.name]
                                            : exportPlayerImages[p.name];
                                        const radius = hasImage ? 14 : (exportChartDataMode === 'teams' ? 10 : (isHighlighted ? 8 : 6));
                                        const opacity = isDimmed ? 0.3 : 0.85;
                                        // V5.24: Smart labels - only show outliers
                                        const xMean = xValsLocal.reduce((a, b) => a + b, 0) / xValsLocal.length;
                                        const yMean = yValsLocal.reduce((a, b) => a + b, 0) / yValsLocal.length;
                                        const isOutlier = (() => {
                                            if (!exportChartSmartLabels || exportChartDataMode !== 'players') return true;
                                            const q1 = chartData.filter(pp => getStatVal(pp, xStat) > xMean && getStatVal(pp, yStat) > yMean);
                                            const q2 = chartData.filter(pp => getStatVal(pp, xStat) <= xMean && getStatVal(pp, yStat) > yMean);
                                            const q3 = chartData.filter(pp => getStatVal(pp, xStat) <= xMean && getStatVal(pp, yStat) <= yMean);
                                            const q4 = chartData.filter(pp => getStatVal(pp, xStat) > xMean && getStatVal(pp, yStat) <= yMean);
                                            const sortByDist = (arr) => arr.sort((a, b) => {
                                                const distA = Math.pow(getStatVal(a, xStat) - xMean, 2) + Math.pow(getStatVal(a, yStat) - yMean, 2);
                                                const distB = Math.pow(getStatVal(b, xStat) - xMean, 2) + Math.pow(getStatVal(b, yStat) - yMean, 2);
                                                return distB - distA;
                                            });
                                            const outliers = [...sortByDist(q1).slice(0, 3), ...sortByDist(q2).slice(0, 3), ...sortByDist(q3).slice(0, 3), ...sortByDist(q4).slice(0, 3)];
                                            return outliers.some(o => o.name === p.name) || isHighlighted;
                                        })();
                                        const showLabel = exportChartShowLabels && (isOutlier || isHighlighted);

                                        return e('g', { key: chartId + '-' + p.name },
                                            hasImage ? e('clipPath', { id: 'clip-' + chartId + '-' + i },
                                                e('circle', { cx, cy, r: radius })
                                            ) : null,
                                            hasImage ? e('image', {
                                                href: exportChartDataMode === 'teams' ? exportSOSTeamImages[p.name] : exportPlayerImages[p.name],
                                                x: cx - radius, y: cy - radius,
                                                width: radius * 2, height: radius * 2,
                                                clipPath: `url(#clip-${chartId}-${i})`,
                                                preserveAspectRatio: 'xMidYMid slice',
                                                opacity: isDimmed ? 0.3 : 1
                                            }) : e('circle', { cx, cy, r: radius, fill: pointColor, opacity, stroke: isHighlighted ? '#fff' : 'none', strokeWidth: isHighlighted ? 2 : 0 }),
                                            hasImage && e('circle', { cx, cy, r: radius, fill: 'none', stroke: pointColor, strokeWidth: isHighlighted ? 3 : 2, opacity: isDimmed ? 0.3 : 1 }),
                                            showLabel && e('text', {
                                                x: cx, y: cy - radius - 3,
                                                fill: isHighlighted ? '#fbbf24' : '#e2e8f0', fontSize: exportChartDataMode === 'teams' ? '9px' : '8px', textAnchor: 'middle', fontWeight: isHighlighted ? '700' : '500'
                                            }, exportChartDataMode === 'teams' ? p.name : getDisplayName(p.name, true))
                                        );
                                    })
                                );
                            };
                            
                            // Calculate chart bounds (for single chart mode)
                            const xVals = chartData.map(p => getStatVal(p, exportChartX));
                            const yVals = chartData.map(p => getStatVal(p, exportChartY));
                            
                            // V5.7: Improved axis scaling - symmetric around zero if data spans it
                            const rawXMin = Math.min(...xVals);
                            const rawXMax = Math.max(...xVals);
                            const rawYMin = Math.min(...yVals);
                            const rawYMax = Math.max(...yVals);
                            
                            // Check if data spans zero (need symmetric axis)
                            const xSpansZero = rawXMin < 0 && rawXMax > 0;
                            const ySpansZero = rawYMin < 0 && rawYMax > 0;
                            
                            // Calculate bounds with padding
                            let xMin, xMax, yMin, yMax;
                            if (xSpansZero) {
                                // Make symmetric around zero
                                const xAbsMax = Math.max(Math.abs(rawXMin), Math.abs(rawXMax));
                                xMin = -xAbsMax * 1.1;
                                xMax = xAbsMax * 1.1;
                            } else {
                                const xRange = rawXMax - rawXMin;
                                const xPadding = Math.max(xRange * 0.1, 1);
                                xMin = rawXMin - xPadding;
                                xMax = rawXMax + xPadding;
                            }
                            
                            if (ySpansZero) {
                                // Make symmetric around zero
                                const yAbsMax = Math.max(Math.abs(rawYMin), Math.abs(rawYMax));
                                yMin = -yAbsMax * 1.1;
                                yMax = yAbsMax * 1.1;
                            } else {
                                const yRange = rawYMax - rawYMin;
                                const yPadding = Math.max(yRange * 0.1, 1);
                                yMin = rawYMin - yPadding;
                                yMax = rawYMax + yPadding;
                            }
                            
                            // Calculate linear regression for trend line
                            const calcRegression = (xData, yData) => {
                                const n = xData.length;
                                if (n < 2) return null;
                                const sumX = xData.reduce((a, b) => a + b, 0);
                                const sumY = yData.reduce((a, b) => a + b, 0);
                                const sumXY = xData.reduce((acc, x, i) => acc + x * yData[i], 0);
                                const sumXX = xData.reduce((acc, x) => acc + x * x, 0);
                                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                                const intercept = (sumY - slope * sumX) / n;
                                // Calculate R-squared
                                const yMean = sumY / n;
                                const ssTotal = yData.reduce((acc, y) => acc + Math.pow(y - yMean, 2), 0);
                                const ssResidual = yData.reduce((acc, y, i) => acc + Math.pow(y - (slope * xData[i] + intercept), 2), 0);
                                const rSquared = 1 - (ssResidual / ssTotal);
                                return { slope, intercept, rSquared };
                            };
                            
                            const regression = exportChartShowCorrelation ? calcRegression(xVals, yVals) : null;
                            
                            // Chart dimensions
                            const chartWidth = 900;
                            const chartHeight = 600;
                            const padding = { top: 60, right: 40, bottom: 70, left: 70 };
                            const plotWidth = chartWidth - padding.left - padding.right;
                            const plotHeight = chartHeight - padding.top - padding.bottom;
                            
                            // V5.9: Get stat config for axis inversion
                            const xStatCfg = activeStatConfig[exportChartX] || { higherBetter: true };
                            const yStatCfg = activeStatConfig[exportChartY] || { higherBetter: true };
                            
                            // Scale functions - V5.9: Invert axes for stats where lower is better
                            // For higherBetter: true - higher values go right/up (normal)
                            // For higherBetter: false - lower values go right/up (inverted)
                            const scaleX = (val) => {
                                const normalized = (val - xMin) / (xMax - xMin);
                                return xStatCfg.higherBetter 
                                    ? padding.left + normalized * plotWidth
                                    : padding.left + plotWidth - normalized * plotWidth;
                            };
                            const scaleY = (val) => {
                                const normalized = (val - yMin) / (yMax - yMin);
                                return yStatCfg.higherBetter
                                    ? padding.top + plotHeight - normalized * plotHeight
                                    : padding.top + normalized * plotHeight;
                            };
                            
                            // Generate axis ticks with nice round numbers
                            const getNiceTicks = (min, max, targetCount) => {
                                const range = max - min;
                                const roughStep = range / targetCount;
                                // Find a nice step size (1, 2, 5, 10, 20, 50, etc.)
                                const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
                                const residual = roughStep / magnitude;
                                let niceStep;
                                if (residual <= 1.5) niceStep = 1 * magnitude;
                                else if (residual <= 3) niceStep = 2 * magnitude;
                                else if (residual <= 7) niceStep = 5 * magnitude;
                                else niceStep = 10 * magnitude;
                                
                                const ticks = [];
                                const start = Math.ceil(min / niceStep) * niceStep;
                                for (let tick = start; tick <= max; tick += niceStep) {
                                    ticks.push(Math.round(tick * 1000) / 1000); // Round to avoid floating point issues
                                }
                                return ticks;
                            };
                            
                            const xTicks = getNiceTicks(xMin, xMax, 6);
                            const yTicks = getNiceTicks(yMin, yMax, 6);
                            
                            // V5.6: Get direction-adjusted value for coloring (like original chart)
                            const getAdjustedValue = (val, statKey) => {
                                const cfg = activeStatConfig[statKey];
                                if (!cfg) return val;
                                return cfg.higherBetter ? val : -val;
                            };
                            
                            // Get color based on impact (green=good, red=bad, gray=neutral)
                            const getImpactColor = (p) => {
                                const adjX = getAdjustedValue(getStatVal(p, exportChartX), exportChartX);
                                const adjY = getAdjustedValue(getStatVal(p, exportChartY), exportChartY);
                                const impact = (adjX + adjY) / 2;
                                // Normalize impact for rating-based stats
                                const normalized = Math.abs(adjX) > 50 || Math.abs(adjY) > 50 ? impact / 10 : impact;
                                if (normalized > 0.5) return '#4ade80'; // Green
                                if (normalized < -0.5) return '#f87171'; // Red
                                return '#94a3b8'; // Gray
                            };
                            
                            // X and Y axis labels - V5.9: Since axes are now inverted for lower-is-better stats, 
                            // "better" is always visually right/up, so we show consistent arrow direction
                            const xCfg = activeStatConfig[exportChartX] || { label: exportChartX, higherBetter: true };
                            const yCfg = activeStatConfig[exportChartY] || { label: exportChartY, higherBetter: true };
                            const xLabel = exportChartXLabel || xCfg.label + ' → Better';
                            const yLabel = exportChartYLabel || yCfg.label + ' ↑ Better';
                            
                            // Handle player image upload for chart
                            const handleChartImageUpload = (playerName, ev) => {
                                const file = ev.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = (e) => {
                                        setExportPlayerImages(prev => ({ ...prev, [playerName]: e.target.result }));
                                    };
                                    reader.readAsDataURL(file);
                                }
                            };
                            
                            // Handle team image upload for chart (teams mode)
                            const handleTeamImageUpload = (teamName, ev) => {
                                const file = ev.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = (e) => {
                                        setExportSOSTeamImages(prev => ({ ...prev, [teamName]: e.target.result }));
                                    };
                                    reader.readAsDataURL(file);
                                }
                            };
                            
                            // Zero lines position
                            const zeroX = scaleX(0);
                            const zeroY = scaleY(0);
                            // V5.8: Only show zero lines and quadrants in ON-OFF mode when data spans zero
                            const showZeroX = !exportChartAbsolute && 0 > xMin && 0 < xMax;
                            const showZeroY = !exportChartAbsolute && 0 > yMin && 0 < yMax;
                            
                            // V5.9: Twin plot rendering
                            if (exportChartTwinPlot) {
                                const twinChartW = 440;
                                const twinChartH = 500;
                                
                                return e('div', { style: { display: 'flex', flexDirection: 'column', alignItems: 'center' }},
                                    // Chart title
                                    e('div', { style: { fontSize: '20px', fontWeight: '700', color: '#fff', marginBottom: '4px', textAlign: 'center' }}, exportChartTitle),
                                    e('div', { style: { fontSize: '11px', color: '#64748b', marginBottom: '12px', textAlign: 'center' }}, 
                                        exportChartAbsolute 
                                            ? 'Absolute values (raw ON-court team performance)'
                                            : 'ON-OFF differential (team performance with player ON court minus OFF court)'
                                    ),
                                    
                                    // Legend
                                    e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '12px', display: 'flex', gap: '16px', flexWrap: 'wrap' }},
                                        e('span', null, e('span', { style: { color: '#4ade80' }}, '●'), ' Positive impact'),
                                        e('span', null, e('span', { style: { color: '#f87171' }}, '●'), ' Negative impact'),
                                        e('span', null, e('span', { style: { color: '#94a3b8' }}, '●'), ' Neutral')
                                    ),
                                    
                                    // Twin charts container (scrollable on mobile)
                                    e('div', { className: 'export-chart-scroll-wrapper', style: { display: 'flex', gap: '16px', flexWrap: 'wrap', justifyContent: 'center' }},
                                        renderSingleChart(exportChartX, exportChartY, twinChartW, twinChartH, 'chart1'),
                                        renderSingleChart(exportChartX2, exportChartY2, twinChartW, twinChartH, 'chart2')
                                    ),
                                    
                                    // Stat Legend for twin charts
                                    exportShowLegend && e('div', { style: { marginTop: '12px', padding: '10px 14px', background: 'rgba(15, 23, 42, 0.8)', borderRadius: '8px', border: '1px solid #334155', maxWidth: (twinChartW * 2 + 16) + 'px' }},
                                        e('div', { style: { fontSize: '10px', color: '#64748b', marginBottom: '6px', fontWeight: '600' }}, '📊 STAT LEGEND'),
                                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '8px', fontSize: '9px' }},
                                            // Chart 1 stats
                                            e('div', { style: { padding: '6px 8px', background: 'rgba(59, 130, 246, 0.1)', borderRadius: '4px', borderLeft: '2px solid #3b82f6' }},
                                                e('div', { style: { color: '#60a5fa', fontWeight: '600', marginBottom: '2px' }}, 'Chart 1'),
                                                e('div', { style: { color: '#94a3b8' }}, 
                                                    e('span', { style: { color: '#e2e8f0' }}, 'X: '), getStatDef(exportChartX).name + ' — ' + getStatDef(exportChartX).desc
                                                ),
                                                e('div', { style: { color: '#94a3b8', marginTop: '2px' }}, 
                                                    e('span', { style: { color: '#e2e8f0' }}, 'Y: '), getStatDef(exportChartY).name + ' — ' + getStatDef(exportChartY).desc
                                                )
                                            ),
                                            // Chart 2 stats
                                            e('div', { style: { padding: '6px 8px', background: 'rgba(139, 92, 246, 0.1)', borderRadius: '4px', borderLeft: '2px solid #a78bfa' }},
                                                e('div', { style: { color: '#a78bfa', fontWeight: '600', marginBottom: '2px' }}, 'Chart 2'),
                                                e('div', { style: { color: '#94a3b8' }}, 
                                                    e('span', { style: { color: '#e2e8f0' }}, 'X: '), getStatDef(exportChartX2).name + ' — ' + getStatDef(exportChartX2).desc
                                                ),
                                                e('div', { style: { color: '#94a3b8', marginTop: '2px' }}, 
                                                    e('span', { style: { color: '#e2e8f0' }}, 'Y: '), getStatDef(exportChartY2).name + ' — ' + getStatDef(exportChartY2).desc
                                                )
                                            )
                                        ),
                                        // Mode explanation
                                        e('div', { style: { marginTop: '6px', fontSize: '9px', color: '#64748b', borderTop: '1px solid #334155', paddingTop: '6px' }},
                                            exportChartDataMode === 'teams' 
                                                ? (exportChartAbsolute ? '📈 Absolute mode: Raw team statistics' : '📊 vs. League Avg mode: Values relative to league average (+ = better)')
                                                : (exportChartAbsolute ? '📈 Absolute mode: Team stats while player is ON court' : '📊 ON-OFF mode: Difference in team stats with player ON vs OFF court')
                                        ),
                                        // RAPM deep explainer when RAPM stats are selected
                                        (exportChartX.includes('rapm') || exportChartY.includes('rapm') || exportChartX2.includes('rapm') || exportChartY2.includes('rapm') || 
                                         exportChartX === 'rapm' || exportChartY === 'rapm' || exportChartX2 === 'rapm' || exportChartY2 === 'rapm') && e('div', { style: { marginTop: '6px', padding: '6px 8px', background: 'rgba(139, 92, 246, 0.1)', borderRadius: '4px', borderLeft: '2px solid #a78bfa', fontSize: '9px' }},
                                            e('div', { style: { color: '#a78bfa', fontWeight: '600', marginBottom: '3px' }}, '🔬 RAPM METHODOLOGY'),
                                            e('div', { style: { color: '#94a3b8', lineHeight: '1.4' }},
                                                'RAPM uses ridge regression (λ=' + (playerRapmStats?.lambda || rapmLambda) + ') to solve the "credit assignment" problem — isolating each player\'s contribution from lineup-level data. ',
                                                'Unlike raw +/-, it controls for teammates and opponents, reducing noise from playing with/against elite players. ',
                                                'Values represent estimated point differential per 100 possessions attributable to the individual player.'
                                            )
                                        )
                                    ),
                                    
                                    // Player photo upload grid below charts
                                    exportChartDataMode === 'players' && e('div', { style: { marginTop: '20px', width: '100%', maxWidth: (twinChartW * 2 + 16) + 'px' }},
                                        e('div', { style: { fontSize: '12px', color: '#94a3b8', marginBottom: '8px' }}, 'Click to add player photos:'),
                                        e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '6px' }},
                                            chartData.slice(0, 30).map((p, i) => {
                                                const pointColor = getImpactColor(p);
                                                return e('div', { 
                                                    key: p.name,
                                                    style: { display: 'flex', alignItems: 'center', gap: '4px', padding: '3px 6px', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px', cursor: 'pointer', borderLeft: `3px solid ${pointColor}` },
                                                    onClick: () => document.getElementById('twin-chart-img-' + i).click()
                                                },
                                                    e('div', { style: { width: '20px', height: '20px', borderRadius: '50%', background: exportPlayerImages[p.name] ? 'transparent' : pointColor, display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden', opacity: 0.8 }},
                                                        exportPlayerImages[p.name] 
                                                            ? e('img', { src: exportPlayerImages[p.name], style: { width: '100%', height: '100%', objectFit: 'cover' }})
                                                            : e('span', { style: { fontSize: '8px', color: '#fff', fontWeight: '700' }}, getInitials(p.name))
                                                    ),
                                                    e('span', { style: { fontSize: '10px', color: '#e2e8f0' }}, getDisplayName(p.name, true)),
                                                    e('input', { 
                                                        type: 'file', id: 'twin-chart-img-' + i, accept: 'image/*', 
                                                        style: { display: 'none' },
                                                        onChange: (ev) => handleChartImageUpload(p.name, ev)
                                                    })
                                                );
                                            })
                                        )
                                    ),
                                    // Team logo upload grid (teams mode)
                                    exportChartDataMode === 'teams' && e('div', { style: { marginTop: '20px', width: '100%', maxWidth: (twinChartW * 2 + 16) + 'px' }},
                                        e('div', { style: { fontSize: '12px', color: '#94a3b8', marginBottom: '8px' }}, 'Click to add team logos:'),
                                        e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '6px' }},
                                            chartData.map((t, i) => {
                                                const pointColor = t.adjNet >= 0 ? '#4ade80' : '#f87171';
                                                return e('div', { 
                                                    key: t.name,
                                                    style: { display: 'flex', alignItems: 'center', gap: '4px', padding: '3px 6px', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px', cursor: 'pointer', borderLeft: `3px solid ${pointColor}` },
                                                    onClick: () => document.getElementById('twin-team-img-' + i).click()
                                                },
                                                    e('div', { style: { width: '20px', height: '20px', borderRadius: '50%', background: exportSOSTeamImages[t.name] ? 'transparent' : pointColor, display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden', opacity: 0.8 }},
                                                        exportSOSTeamImages[t.name] 
                                                            ? e('img', { src: exportSOSTeamImages[t.name], style: { width: '100%', height: '100%', objectFit: 'cover' }})
                                                            : e('span', { style: { fontSize: '8px', color: '#fff', fontWeight: '700' }}, t.name.substring(0, 3).toUpperCase())
                                                    ),
                                                    e('span', { style: { fontSize: '10px', color: '#e2e8f0' }}, t.name),
                                                    e('input', { 
                                                        type: 'file', id: 'twin-team-img-' + i, accept: 'image/*', 
                                                        style: { display: 'none' },
                                                        onChange: (ev) => handleTeamImageUpload(t.name, ev)
                                                    })
                                                );
                                            })
                                        )
                                    )
                                );
                            }
                            
                            // Single chart mode (original)
                            return e('div', { style: { display: 'flex', flexDirection: 'column', alignItems: 'center' }},
                                // Chart title
                                e('div', { style: { fontSize: '20px', fontWeight: '700', color: '#fff', marginBottom: '4px', textAlign: 'center' }}, exportChartTitle),
                                e('div', { style: { fontSize: '11px', color: '#64748b', marginBottom: '12px', textAlign: 'center' }}, 
                                    exportChartDataMode === 'teams'
                                        ? (exportChartAbsolute 
                                            ? 'Team Statistics - Absolute Values (' + chartData.length + ' teams)'
                                            : 'Team Statistics - vs. League Average (' + chartData.length + ' teams)')
                                        : (exportChartAbsolute 
                                            ? 'Absolute values (raw ON-court team performance while player is on court)'
                                            : 'ON-OFF differential (team performance with player ON court minus OFF court)')
                                ),
                                
                                // Legend
                                e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '12px', display: 'flex', gap: '16px', flexWrap: 'wrap' }},
                                    exportChartDataMode === 'teams' 
                                        ? e(React.Fragment, null,
                                            e('span', null, e('span', { style: { color: '#4ade80' }}, '●'), ' Positive Net Rtg'),
                                            e('span', null, e('span', { style: { color: '#f87171' }}, '●'), ' Negative Net Rtg')
                                        )
                                        : e(React.Fragment, null,
                                            e('span', null, e('span', { style: { color: '#4ade80' }}, '●'), ' Positive impact'),
                                            e('span', null, e('span', { style: { color: '#f87171' }}, '●'), ' Negative impact'),
                                            e('span', null, e('span', { style: { color: '#94a3b8' }}, '●'), ' Neutral')
                                        ),
                                    showZeroX && showZeroY && e('span', null, ' | Quadrants show performance zones'),
                                    exportChartAbsolute && exportChartDataMode === 'players' && e('span', null, ' | Diagonal separates high/low performers')
                                ),
                                
                                // SVG Chart (scrollable on mobile)
                                e('div', { className: 'export-chart-scroll-wrapper' },
                                e('svg', {
                                    width: chartWidth,
                                    height: chartHeight,
                                    style: { background: '#0f172a', borderRadius: '12px', border: '1px solid #334155' }
                                },
                                    // Quadrant backgrounds (if both axes have zero lines)
                                    showZeroX && showZeroY && e('g', null,
                                        // Top-right quadrant (good offense, bad defense for def lower-better) - green
                                        e('rect', { x: zeroX, y: padding.top, width: padding.left + plotWidth - zeroX, height: zeroY - padding.top, fill: '#22c55e', opacity: 0.05 }),
                                        // Bottom-left quadrant - red
                                        e('rect', { x: padding.left, y: zeroY, width: zeroX - padding.left, height: padding.top + plotHeight - zeroY, fill: '#ef4444', opacity: 0.05 }),
                                        // Top-left and Bottom-right - neutral/mixed
                                        e('rect', { x: padding.left, y: padding.top, width: zeroX - padding.left, height: zeroY - padding.top, fill: '#f59e0b', opacity: 0.03 }),
                                        e('rect', { x: zeroX, y: zeroY, width: padding.left + plotWidth - zeroX, height: padding.top + plotHeight - zeroY, fill: '#f59e0b', opacity: 0.03 })
                                    ),
                                    
                                    // Grid lines
                                    xTicks.map((tick, i) => e('line', { 
                                        key: 'gx' + i, x1: scaleX(tick), y1: padding.top, x2: scaleX(tick), y2: padding.top + plotHeight,
                                        stroke: '#334155', strokeWidth: 0.5
                                    })),
                                    yTicks.map((tick, i) => e('line', { 
                                        key: 'gy' + i, x1: padding.left, y1: scaleY(tick), x2: padding.left + plotWidth, y2: scaleY(tick),
                                        stroke: '#334155', strokeWidth: 0.5
                                    })),
                                    
                                    // Zero lines (bolder)
                                    showZeroX && e('line', { x1: zeroX, y1: padding.top, x2: zeroX, y2: padding.top + plotHeight, stroke: '#64748b', strokeWidth: 1.5 }),
                                    showZeroY && e('line', { x1: padding.left, y1: zeroY, x2: padding.left + plotWidth, y2: zeroY, stroke: '#64748b', strokeWidth: 1.5 }),
                                    
                                    // Diagonal line (only show when quadrants are NOT present)
                                    !(showZeroX && showZeroY) && e('line', {
                                        x1: padding.left, y1: padding.top + plotHeight,
                                        x2: padding.left + plotWidth, y2: padding.top,
                                        stroke: '#475569', strokeWidth: 1.5, strokeDasharray: '8,4'
                                    }),
                                    
                                    // Quadrant labels (only when quadrants are present)
                                    showZeroX && showZeroY && e('g', null,
                                        e('text', { x: zeroX + (padding.left + plotWidth - zeroX) / 2, y: padding.top + 20, fill: '#4ade80', fontSize: '10px', textAnchor: 'middle', opacity: 0.7, fontWeight: '600' }, 'HIGH-HIGH'),
                                        e('text', { x: padding.left + (zeroX - padding.left) / 2, y: padding.top + plotHeight - 10, fill: '#f87171', fontSize: '10px', textAnchor: 'middle', opacity: 0.7, fontWeight: '600' }, 'LOW-LOW')
                                    ),
                                    
                                    // Positive/Negative Players labels (only when diagonal line is shown, i.e. no quadrants)
                                    !(showZeroX && showZeroY) && e('text', {
                                        x: padding.left + 10, y: padding.top + 20,
                                        fill: '#4ade80', fontSize: '11px', fontStyle: 'italic', opacity: 0.8
                                    }, 'Positive Players'),
                                    
                                    !(showZeroX && showZeroY) && e('text', {
                                        x: padding.left + plotWidth - 10, y: padding.top + plotHeight - 10,
                                        fill: '#f87171', fontSize: '11px', fontStyle: 'italic', opacity: 0.8, textAnchor: 'end'
                                    }, 'Negative Players'),
                                    
                                    // Axes
                                    e('line', { x1: padding.left, y1: padding.top + plotHeight, x2: padding.left + plotWidth, y2: padding.top + plotHeight, stroke: '#475569', strokeWidth: 2 }),
                                    e('line', { x1: padding.left, y1: padding.top, x2: padding.left, y2: padding.top + plotHeight, stroke: '#475569', strokeWidth: 2 }),
                                    
                                    // Axis labels
                                    e('text', { x: chartWidth / 2, y: chartHeight - 15, fill: '#94a3b8', fontSize: '13px', textAnchor: 'middle', fontWeight: '600' }, xLabel),
                                    e('text', { x: 20, y: chartHeight / 2, fill: '#94a3b8', fontSize: '13px', textAnchor: 'middle', fontWeight: '600', transform: `rotate(-90, 20, ${chartHeight/2})` }, yLabel),
                                    
                                    // Tick labels
                                    xTicks.map((tick, i) => e('text', { key: 'tx' + i, x: scaleX(tick), y: padding.top + plotHeight + 20, fill: '#64748b', fontSize: '10px', textAnchor: 'middle' }, Number.isInteger(tick) ? tick.toString() : tick.toFixed(1))),
                                    yTicks.map((tick, i) => e('text', { key: 'ty' + i, x: padding.left - 10, y: scaleY(tick) + 4, fill: '#64748b', fontSize: '10px', textAnchor: 'end' }, Number.isInteger(tick) ? tick.toString() : tick.toFixed(1))),
                                    
                                    // Trend line (if enabled)
                                    regression && e('line', {
                                        x1: scaleX(xMin), y1: scaleY(regression.slope * xMin + regression.intercept),
                                        x2: scaleX(xMax), y2: scaleY(regression.slope * xMax + regression.intercept),
                                        stroke: '#f59e0b', strokeWidth: 2, strokeDasharray: '8,4'
                                    }),
                                    regression && e('text', {
                                        x: chartWidth - padding.right - 10, y: padding.top + 20,
                                        fill: '#f59e0b', fontSize: '12px', textAnchor: 'end'
                                    }, `R² = ${regression.rSquared.toFixed(3)}`),
                                    
                                    // Data points with team-based colors
                                    chartData.map((p, i) => {
                                        const x = scaleX(getStatVal(p, exportChartX));
                                        const y = scaleY(getStatVal(p, exportChartY));
                                        const hasImage = exportChartDataMode === 'teams'
                                            ? exportSOSTeamImages[p.name]
                                            : exportPlayerImages[p.name];
                                        // V5.24: Team highlighting
                                        const isHighlighted = exportChartDataMode === 'players' && exportChartHighlightTeam && p.team === exportChartHighlightTeam;
                                        const isDimmed = exportChartDataMode === 'players' && exportChartHighlightTeam && p.team !== exportChartHighlightTeam;
                                        const pointColor = exportChartDataMode === 'teams'
                                            ? (p.adjNet >= 0 ? '#4ade80' : '#f87171')
                                            : isHighlighted ? '#fbbf24' : getImpactColor(p);
                                        const radius = exportChartDataMode === 'teams' ? 12 : (isHighlighted ? 8 : 6);
                                        const imageRadius = exportChartDataMode === 'teams' ? 16 : 18;
                                        const opacity = isDimmed ? 0.3 : 0.8;
                                        // V5.24: Smart labels - only show outliers
                                        const isOutlier = (() => {
                                            if (!exportChartSmartLabels || exportChartDataMode !== 'players') return true;
                                            const xMean = xVals.reduce((a, b) => a + b, 0) / xVals.length;
                                            const yMean = yVals.reduce((a, b) => a + b, 0) / yVals.length;
                                            const q1 = chartData.filter(pp => getStatVal(pp, exportChartX) > xMean && getStatVal(pp, exportChartY) > yMean);
                                            const q2 = chartData.filter(pp => getStatVal(pp, exportChartX) <= xMean && getStatVal(pp, exportChartY) > yMean);
                                            const q3 = chartData.filter(pp => getStatVal(pp, exportChartX) <= xMean && getStatVal(pp, exportChartY) <= yMean);
                                            const q4 = chartData.filter(pp => getStatVal(pp, exportChartX) > xMean && getStatVal(pp, exportChartY) <= yMean);
                                            const sortByDist = (arr) => arr.sort((a, b) => {
                                                const distA = Math.pow(getStatVal(a, exportChartX) - xMean, 2) + Math.pow(getStatVal(a, exportChartY) - yMean, 2);
                                                const distB = Math.pow(getStatVal(b, exportChartX) - xMean, 2) + Math.pow(getStatVal(b, exportChartY) - yMean, 2);
                                                return distB - distA;
                                            });
                                            const outliers = [...sortByDist(q1).slice(0, 3), ...sortByDist(q2).slice(0, 3), ...sortByDist(q3).slice(0, 3), ...sortByDist(q4).slice(0, 3)];
                                            return outliers.some(o => o.name === p.name) || isHighlighted;
                                        })();
                                        const showLabel = exportChartShowLabels && (isOutlier || isHighlighted);

                                        return e('g', { key: p.name },
                                            // Clip path for images
                                            hasImage && e('defs', null,
                                                e('clipPath', { id: 'clip-chart-' + i },
                                                    e('circle', { cx: x, cy: y, r: imageRadius })
                                                )
                                            ),
                                            // Image or colored circle
                                            hasImage
                                                ? e('image', {
                                                    href: exportChartDataMode === 'teams' ? exportSOSTeamImages[p.name] : exportPlayerImages[p.name],
                                                    x: x - imageRadius, y: y - imageRadius, width: imageRadius * 2, height: imageRadius * 2,
                                                    clipPath: `url(#clip-chart-${i})`,
                                                    style: { cursor: 'pointer' },
                                                    opacity: isDimmed ? 0.3 : 1
                                                })
                                                : e('circle', {
                                                    cx: x, cy: y, r: radius,
                                                    fill: pointColor, fillOpacity: opacity,
                                                    stroke: isHighlighted ? '#fff' : '#fff', strokeWidth: isHighlighted ? 2.5 : 1.5,
                                                    style: { cursor: 'pointer' }
                                                }),
                                            // Border for images (with impact color)
                                            hasImage && e('circle', {
                                                cx: x, cy: y, r: imageRadius,
                                                fill: 'none', stroke: pointColor, strokeWidth: isHighlighted ? 4 : 3,
                                                opacity: isDimmed ? 0.3 : 1
                                            }),
                                            // Name label
                                            showLabel && e('text', {
                                                x: x, y: y - (hasImage ? imageRadius + 4 : 10),
                                                fill: isHighlighted ? '#fbbf24' : '#fff', fontSize: exportChartDataMode === 'teams' ? '10px' : '9px', textAnchor: 'middle', fontWeight: isHighlighted ? '700' : '600'
                                            }, exportChartDataMode === 'teams' ? p.name : getDisplayName(p.name, true))
                                        );
                                    })
                                )
                                ), // close export-chart-scroll-wrapper

                                // Stat Legend for single chart
                                exportShowLegend && e('div', { style: { marginTop: '12px', padding: '10px 14px', background: 'rgba(15, 23, 42, 0.8)', borderRadius: '8px', border: '1px solid #334155', maxWidth: chartWidth + 'px' }},
                                    e('div', { style: { fontSize: '10px', color: '#64748b', marginBottom: '6px', fontWeight: '600' }}, '📊 STAT LEGEND'),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '6px', fontSize: '9px' }},
                                        e('div', { style: { color: '#94a3b8' }}, 
                                            e('span', { style: { color: '#60a5fa', fontWeight: '600' }}, 'X-Axis: '), 
                                            e('span', { style: { color: '#e2e8f0' }}, getStatDef(exportChartX).name),
                                            ' — ' + getStatDef(exportChartX).desc
                                        ),
                                        e('div', { style: { color: '#94a3b8' }}, 
                                            e('span', { style: { color: '#a78bfa', fontWeight: '600' }}, 'Y-Axis: '), 
                                            e('span', { style: { color: '#e2e8f0' }}, getStatDef(exportChartY).name),
                                            ' — ' + getStatDef(exportChartY).desc
                                        )
                                    ),
                                    e('div', { style: { marginTop: '6px', fontSize: '9px', color: '#64748b', borderTop: '1px solid #334155', paddingTop: '6px' }},
                                        exportChartDataMode === 'teams' 
                                            ? (exportChartAbsolute ? '📈 Absolute mode: Raw team statistics' : '📊 vs. League Avg: Values relative to league average (+ = better than avg)')
                                            : (exportChartAbsolute ? '📈 Absolute mode: Team stats while player is ON court' : '📊 ON-OFF mode: Difference in team stats with player ON vs OFF court')
                                    ),
                                    // RAPM deep explainer when RAPM stats are selected
                                    (exportChartX.includes('rapm') || exportChartY.includes('rapm') || exportChartX === 'rapm' || exportChartY === 'rapm') && e('div', { style: { marginTop: '6px', padding: '6px 8px', background: 'rgba(139, 92, 246, 0.1)', borderRadius: '4px', borderLeft: '2px solid #a78bfa', fontSize: '9px' }},
                                        e('div', { style: { color: '#a78bfa', fontWeight: '600', marginBottom: '3px' }}, '🔬 RAPM METHODOLOGY'),
                                        e('div', { style: { color: '#94a3b8', lineHeight: '1.4' }},
                                            'RAPM uses ridge regression (λ=' + (playerRapmStats?.lambda || rapmLambda) + ') to solve the "credit assignment" problem — isolating each player\'s contribution from lineup-level data. ',
                                            'Unlike raw +/-, it controls for teammates and opponents, reducing noise from playing with/against elite players. ',
                                            'Values represent estimated point differential per 100 possessions attributable to the individual player.'
                                        )
                                    )
                                ),
                                
                                // Player photo upload grid below chart (players mode)
                                exportChartDataMode === 'players' && e('div', { style: { marginTop: '20px', width: '100%', maxWidth: chartWidth + 'px' }},
                                    e('div', { style: { fontSize: '12px', color: '#94a3b8', marginBottom: '8px' }}, 'Click to add player photos:'),
                                    e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '6px' }},
                                        chartData.slice(0, 30).map((p, i) => {
                                            const pointColor = getImpactColor(p);
                                            return e('div', { 
                                                key: p.name,
                                                style: { display: 'flex', alignItems: 'center', gap: '4px', padding: '3px 6px', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px', cursor: 'pointer', borderLeft: `3px solid ${pointColor}` },
                                                onClick: () => document.getElementById('chart-img-' + i).click()
                                            },
                                                e('div', { style: { width: '20px', height: '20px', borderRadius: '50%', background: exportPlayerImages[p.name] ? 'transparent' : pointColor, display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden', opacity: 0.8 }},
                                                    exportPlayerImages[p.name] 
                                                        ? e('img', { src: exportPlayerImages[p.name], style: { width: '100%', height: '100%', objectFit: 'cover' }})
                                                        : e('span', { style: { fontSize: '8px', color: '#fff', fontWeight: '700' }}, getInitials(p.name))
                                                ),
                                                e('span', { style: { fontSize: '10px', color: '#e2e8f0' }}, getDisplayName(p.name, true)),
                                                e('input', { 
                                                    type: 'file', id: 'chart-img-' + i, accept: 'image/*', 
                                                    style: { display: 'none' },
                                                    onChange: (ev) => handleChartImageUpload(p.name, ev)
                                                })
                                            );
                                        })
                                    )
                                ),
                                // Team logo upload grid below chart (teams mode)
                                exportChartDataMode === 'teams' && e('div', { style: { marginTop: '20px', width: '100%', maxWidth: chartWidth + 'px' }},
                                    e('div', { style: { fontSize: '12px', color: '#94a3b8', marginBottom: '8px' }}, 'Click to add team logos:'),
                                    e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '6px' }},
                                        chartData.map((t, i) => {
                                            const pointColor = t.adjNet >= 0 ? '#4ade80' : '#f87171';
                                            return e('div', { 
                                                key: t.name,
                                                style: { display: 'flex', alignItems: 'center', gap: '4px', padding: '3px 6px', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px', cursor: 'pointer', borderLeft: `3px solid ${pointColor}` },
                                                onClick: () => document.getElementById('chart-team-img-' + i).click()
                                            },
                                                e('div', { style: { width: '20px', height: '20px', borderRadius: '50%', background: exportSOSTeamImages[t.name] ? 'transparent' : pointColor, display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden', opacity: 0.8 }},
                                                    exportSOSTeamImages[t.name] 
                                                        ? e('img', { src: exportSOSTeamImages[t.name], style: { width: '100%', height: '100%', objectFit: 'cover' }})
                                                        : e('span', { style: { fontSize: '8px', color: '#fff', fontWeight: '700' }}, t.name.substring(0, 3).toUpperCase())
                                                ),
                                                e('span', { style: { fontSize: '10px', color: '#e2e8f0' }}, t.name),
                                                e('input', { 
                                                    type: 'file', id: 'chart-team-img-' + i, accept: 'image/*', 
                                                    style: { display: 'none' },
                                                    onChange: (ev) => handleTeamImageUpload(t.name, ev)
                                                })
                                            );
                                        })
                                    )
                                )
                            );
                        })(),
                        
                        // Four Factors Export - V5.2 Enhanced Multi-Team View
                        exportMode === 'fourfactors' && (() => {
                            // Helper to parse lineup players
                            // V6.1: Apply merge rules when parsing lineup players
                            const parseLineupPlayers = (l) => {
                                if (!l.Lineup) return [];
                                return l.Lineup.split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                            };
                            
                            // Helper to calculate possession
                            const calcPoss = (fga, oreb, tov, fta) => {
                                return (fga || 0) - (oreb || 0) + (tov || 0) + 0.44 * (fta || 0);
                            };
                            
                            // V5.3: Helper to check if lineup matches date filter (enhanced with game range)
                            const matchesDateFilter = (l, teamName) => {
                                if (exportFFDateMode === 'all') return true;
                                
                                // Try to get date from lineup data first
                                let dateStr = l.Date || l.GameDate || l.date || l.game_date || '';
                                let gameId = l.GameID || l.game_id || l.Game || '';
                                
                                // If no date but have game_id, look it up from stints/team_totals
                                if (!dateStr && gameId && gameDatesLookup.has(gameId)) {
                                    dateStr = gameDatesLookup.get(gameId);
                                }
                                
                                // Game range mode - use team game order
                                if (exportFFDateMode === 'gamerange') {
                                    if (!teamName || !teamGameOrder.has(teamName)) return true;
                                    const teamGames = teamGameOrder.get(teamName);
                                    
                                    // Find this game's number for the team
                                    let gameNum = -1;
                                    if (gameId) {
                                        const gameInfo = teamGames.find(g => g.game_id === gameId);
                                        if (gameInfo) gameNum = gameInfo.gameNum;
                                    } else if (dateStr) {
                                        // Match by date if no game_id
                                        const gameInfo = teamGames.find(g => g.game_date === dateStr);
                                        if (gameInfo) gameNum = gameInfo.gameNum;
                                    }
                                    
                                    if (gameNum === -1) return true; // If can't determine game number, include it
                                    return gameNum >= exportFFGameRange.start && gameNum <= exportFFGameRange.end;
                                }
                                
                                // Date-based filtering - V5.6 enhanced to work with partial dates
                                if (!dateStr) return true; // If no date, include it
                                const lineupDate = new Date(dateStr);
                                if (isNaN(lineupDate.getTime())) return true;
                                
                                // After mode - only need after date
                                if (exportFFDateMode === 'after' && exportFFDateAfter) {
                                    return lineupDate >= new Date(exportFFDateAfter);
                                }
                                // Before mode - only need before date
                                if (exportFFDateMode === 'before' && exportFFDateBefore) {
                                    return lineupDate <= new Date(exportFFDateBefore);
                                }
                                // Range mode - can work with just from, just to, or both
                                if (exportFFDateMode === 'range') {
                                    const hasAfter = exportFFDateAfter && exportFFDateAfter.length > 0;
                                    const hasBefore = exportFFDateBefore && exportFFDateBefore.length > 0;
                                    if (hasAfter && hasBefore) {
                                        return lineupDate >= new Date(exportFFDateAfter) && lineupDate <= new Date(exportFFDateBefore);
                                    } else if (hasAfter) {
                                        return lineupDate >= new Date(exportFFDateAfter);
                                    } else if (hasBefore) {
                                        return lineupDate <= new Date(exportFFDateBefore);
                                    }
                                }
                                return true;
                            };
                            
                            // V5.6: Calculate team four factors - uses stints data when date filter is applied
                            const calcTeamFF = (teamName) => {
                                // Check if date filter is active and we should use stints
                                const useDateFilter = exportFFDateMode !== 'all' && exportFFDateApplied && stintsData.length > 0;
                                
                                if (useDateFilter) {
                                    // Filter stints by team and date
                                    const teamStints = stintsData.filter(s => {
                                        const isTeam = s.home_team === teamName || s.away_team === teamName;
                                        if (!isTeam) return false;
                                        
                                        const gameDate = s.game_date;
                                        if (!gameDate) return true;
                                        
                                        const stintDate = new Date(gameDate);
                                        if (isNaN(stintDate.getTime())) return true;
                                        
                                        // Game range mode
                                        if (exportFFDateMode === 'gamerange') {
                                            if (!teamGameOrder.has(teamName)) return true;
                                            const teamGames = teamGameOrder.get(teamName);
                                            const gameInfo = teamGames.find(g => g.game_id === s.game_id);
                                            if (!gameInfo) return true;
                                            return gameInfo.gameNum >= exportFFGameRange.start && gameInfo.gameNum <= exportFFGameRange.end;
                                        }
                                        
                                        // Date modes
                                        if (exportFFDateMode === 'after' && exportFFDateAfter) {
                                            return stintDate >= new Date(exportFFDateAfter);
                                        }
                                        if (exportFFDateMode === 'before' && exportFFDateBefore) {
                                            return stintDate <= new Date(exportFFDateBefore);
                                        }
                                        if (exportFFDateMode === 'range') {
                                            const hasAfter = exportFFDateAfter && exportFFDateAfter.length > 0;
                                            const hasBefore = exportFFDateBefore && exportFFDateBefore.length > 0;
                                            if (hasAfter && hasBefore) {
                                                return stintDate >= new Date(exportFFDateAfter) && stintDate <= new Date(exportFFDateBefore);
                                            } else if (hasAfter) {
                                                return stintDate >= new Date(exportFFDateAfter);
                                            } else if (hasBefore) {
                                                return stintDate <= new Date(exportFFDateBefore);
                                            }
                                        }
                                        return true;
                                    });
                                    
                                    // Aggregate stats from filtered stints
                                    const totals = teamStints.reduce((acc, s) => {
                                        const isHome = s.home_team === teamName;
                                        const prefix = isHome ? 'home_' : 'away_';
                                        const oppPrefix = isHome ? 'away_' : 'home_';
                                        
                                        const fga = parseFloat(s[prefix + 'fga']) || 0;
                                        const fgm = parseFloat(s[prefix + 'fgm']) || 0;
                                        const fg3a = parseFloat(s[prefix + 'fg3a']) || 0;
                                        const fg3m = parseFloat(s[prefix + 'fg3m']) || 0;
                                        const fta = parseFloat(s[prefix + 'fta']) || 0;
                                        const ftm = parseFloat(s[prefix + 'ftm']) || 0;
                                        const oreb = parseFloat(s[prefix + 'oreb']) || 0;
                                        const dreb = parseFloat(s[prefix + 'dreb']) || 0;
                                        const tov = parseFloat(s[prefix + 'tov']) || 0;
                                        const pts = parseFloat(s[prefix + 'points']) || (fgm * 2 + fg3m + ftm);
                                        const ast = parseFloat(s[prefix + 'ast']) || 0;
                                        const rimA = parseFloat(s[prefix + 'rim_att']) || parseFloat(s[prefix + 'paint_att']) || 0;
                                        const rimM = parseFloat(s[prefix + 'rim_made']) || parseFloat(s[prefix + 'paint_made']) || 0;
                                        
                                        const fgaV = parseFloat(s[oppPrefix + 'fga']) || 0;
                                        const fgmV = parseFloat(s[oppPrefix + 'fgm']) || 0;
                                        const fg3aV = parseFloat(s[oppPrefix + 'fg3a']) || 0;
                                        const fg3mV = parseFloat(s[oppPrefix + 'fg3m']) || 0;
                                        const ftaV = parseFloat(s[oppPrefix + 'fta']) || 0;
                                        const ftmV = parseFloat(s[oppPrefix + 'ftm']) || 0;
                                        const orebV = parseFloat(s[oppPrefix + 'oreb']) || 0;
                                        const drebV = parseFloat(s[oppPrefix + 'dreb']) || 0;
                                        const tovV = parseFloat(s[oppPrefix + 'tov']) || 0;
                                        const ptsV = parseFloat(s[oppPrefix + 'points']) || (fgmV * 2 + fg3mV + ftmV);
                                        const astV = parseFloat(s[oppPrefix + 'ast']) || 0;
                                        const rimAV = parseFloat(s[oppPrefix + 'rim_att']) || parseFloat(s[oppPrefix + 'paint_att']) || 0;
                                        const rimMV = parseFloat(s[oppPrefix + 'rim_made']) || parseFloat(s[oppPrefix + 'paint_made']) || 0;
                                        
                                        const poss = fga - oreb + tov + 0.44 * fta;
                                        const possV = fgaV - orebV + tovV + 0.44 * ftaV;
                                        
                                        acc.poss += poss; acc.possV += possV; acc.pts += pts; acc.ptsV += ptsV;
                                        acc.fga += fga; acc.fgm += fgm; acc.tpm += fg3m; acc.tpa += fg3a; acc.fta += fta;
                                        acc.tov += tov; acc.oreb += oreb; acc.dreb += dreb;
                                        acc.ast += ast; acc.rimA += rimA; acc.rimM += rimM;
                                        acc.fgaV += fgaV; acc.fgmV += fgmV; acc.tpmV += fg3mV; acc.tpaV += fg3aV; acc.ftaV += ftaV;
                                        acc.tovV += tovV; acc.orebV += orebV; acc.drebV += drebV;
                                        acc.astV += astV; acc.rimAV += rimAV; acc.rimMV += rimMV;
                                        return acc;
                                    }, { poss: 0, possV: 0, pts: 0, ptsV: 0, fga: 0, fgm: 0, tpm: 0, tpa: 0, fta: 0, tov: 0, oreb: 0, dreb: 0, ast: 0, rimA: 0, rimM: 0, fgaV: 0, fgmV: 0, tpmV: 0, tpaV: 0, ftaV: 0, tovV: 0, orebV: 0, drebV: 0, astV: 0, rimAV: 0, rimMV: 0 });
                                    
                                    // Count unique games
                                    const uniqueGames = new Set(teamStints.map(s => s.game_id)).size;
                                    
                                    // V5.12: Use Basketball Reference TOV% formula for consistency
                                    const offTovDenom = totals.fga + 0.44 * totals.fta + totals.tov;
                                    const defTovDenom = totals.fgaV + 0.44 * totals.ftaV + totals.tovV;
                                    
                                    return {
                                        team: teamName,
                                        games: uniqueGames,
                                        poss: totals.poss + totals.possV,
                                        offEfg: totals.fga > 0 ? ((totals.fgm + 0.5 * totals.tpm) / totals.fga) * 100 : 0,
                                        offTov: offTovDenom > 0 ? (totals.tov / offTovDenom) * 100 : 0,
                                        offOreb: (totals.fgaV - totals.fgmV + totals.oreb) > 0 ? (totals.oreb / (totals.fgaV - totals.fgmV + totals.oreb)) * 100 : 0,
                                        offFtR: totals.fga > 0 ? (totals.fta / totals.fga) * 100 : 0,
                                        defEfg: totals.fgaV > 0 ? ((totals.fgmV + 0.5 * totals.tpmV) / totals.fgaV) * 100 : 0,
                                        defTov: defTovDenom > 0 ? (totals.tovV / defTovDenom) * 100 : 0,
                                        defOreb: (totals.fga - totals.fgm + totals.orebV) > 0 ? (totals.orebV / (totals.fga - totals.fgm + totals.orebV)) * 100 : 0,
                                        defFtR: totals.fgaV > 0 ? (totals.ftaV / totals.fgaV) * 100 : 0,
                                        off: totals.poss > 0 ? (totals.pts / totals.poss) * 100 : 0,
                                        def: totals.possV > 0 ? (totals.ptsV / totals.possV) * 100 : 0,
                                        get net() { return this.off - this.def; },
                                        // New stats: Rim, 3PT, AST (VOL as shot distribution %)
                                        offRimVol: totals.fga > 0 ? (totals.rimA / totals.fga) * 100 : 0,
                                        offRimPct: totals.rimA > 0 ? (totals.rimM / totals.rimA) * 100 : 0,
                                        offThreeVol: totals.fga > 0 ? (totals.tpa / totals.fga) * 100 : 0,
                                        offThreePct: totals.tpa > 0 ? (totals.tpm / totals.tpa) * 100 : 0,
                                        offAstPct: totals.fgm > 0 ? (totals.ast / totals.fgm) * 100 : 0,
                                        defRimVol: totals.fgaV > 0 ? (totals.rimAV / totals.fgaV) * 100 : 0,
                                        defRimPct: totals.rimAV > 0 ? (totals.rimMV / totals.rimAV) * 100 : 0,
                                        defThreeVol: totals.fgaV > 0 ? (totals.tpaV / totals.fgaV) * 100 : 0,
                                        defThreePct: totals.tpaV > 0 ? (totals.tpmV / totals.tpaV) * 100 : 0
                                    };
                                }
                                
                                // Default: use lineup data (no date filter or no stints)
                                const teamLineups = lineupData.filter(l => l.Team === teamName && matchesDateFilter(l, teamName));
                                const totals = teamLineups.reduce((acc, l) => {
                                    const fga = parseFloat(l.FGA) || 0, oreb = parseFloat(l.OREB) || 0, tov = parseFloat(l.TOV) || 0, fta = parseFloat(l.FTA) || 0;
                                    const fgaV = parseFloat(l.FGA_VS) || 0, orebV = parseFloat(l.OREB_VS) || 0, tovV = parseFloat(l.TOV_VS) || 0, ftaV = parseFloat(l.FTA_VS) || 0;
                                    const poss = calcPoss(fga, oreb, tov, fta);
                                    const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                                    const fgm = parseFloat(l.FGM) || 0, tpm = parseFloat(l['3PM']) || 0, ftm = parseFloat(l.FTM) || 0;
                                    const tpa = parseFloat(l['3PA']) || 0;
                                    const fgmV = parseFloat(l.FGM_VS) || 0, tpmV = parseFloat(l['3PM_VS']) || 0, ftmV = parseFloat(l.FTM_VS) || 0;
                                    const tpaV = parseFloat(l['3PA_VS']) || 0;
                                    const dreb = parseFloat(l.DREB) || 0, drebV = parseFloat(l.DREB_VS) || 0;
                                    const ast = parseFloat(l.AST) || 0, astV = parseFloat(l.AST_VS) || 0;
                                    const rimA = parseFloat(l.RIM_FGA) || parseFloat(l.FGA_PAINT) || parseFloat(l.RIM_ATT) || 0;
                                    const rimM = parseFloat(l.RIM_FGM) || parseFloat(l.FGM_PAINT) || parseFloat(l.RIM_MADE) || 0;
                                    const rimAV = parseFloat(l.RIM_FGA_VS) || parseFloat(l.FGA_PAINT_VS) || parseFloat(l.RIM_ATT_VS) || 0;
                                    const rimMV = parseFloat(l.RIM_FGM_VS) || parseFloat(l.FGM_PAINT_VS) || parseFloat(l.RIM_MADE_VS) || 0;
                                    const pts = fgm * 2 + tpm + ftm;
                                    const ptsV = fgmV * 2 + tpmV + ftmV;
                                    acc.poss += poss; acc.possV += possV; acc.pts += pts; acc.ptsV += ptsV;
                                    acc.fga += fga; acc.fgm += fgm; acc.tpm += tpm; acc.tpa += tpa; acc.fta += fta;
                                    acc.tov += tov; acc.oreb += oreb; acc.dreb += dreb;
                                    acc.ast += ast; acc.rimA += rimA; acc.rimM += rimM;
                                    acc.fgaV += fgaV; acc.fgmV += fgmV; acc.tpmV += tpmV; acc.tpaV += tpaV; acc.ftaV += ftaV;
                                    acc.tovV += tovV; acc.orebV += orebV; acc.drebV += drebV;
                                    acc.astV += astV; acc.rimAV += rimAV; acc.rimMV += rimMV;
                                    return acc;
                                }, { poss: 0, possV: 0, pts: 0, ptsV: 0, fga: 0, fgm: 0, tpm: 0, tpa: 0, fta: 0, tov: 0, oreb: 0, dreb: 0, ast: 0, rimA: 0, rimM: 0, fgaV: 0, fgmV: 0, tpmV: 0, tpaV: 0, ftaV: 0, tovV: 0, orebV: 0, drebV: 0, astV: 0, rimAV: 0, rimMV: 0 });
                                
                                // V5.12: Use Basketball Reference TOV% formula for consistency
                                const offTovDenom = totals.fga + 0.44 * totals.fta + totals.tov;
                                const defTovDenom = totals.fgaV + 0.44 * totals.ftaV + totals.tovV;
                                
                                return {
                                    team: teamName,
                                    games: teamLineups.length,
                                    poss: totals.poss + totals.possV,
                                    offEfg: totals.fga > 0 ? ((totals.fgm + 0.5 * totals.tpm) / totals.fga) * 100 : 0,
                                    offTov: offTovDenom > 0 ? (totals.tov / offTovDenom) * 100 : 0,
                                    offOreb: (totals.fgaV - totals.fgmV + totals.oreb) > 0 ? (totals.oreb / (totals.fgaV - totals.fgmV + totals.oreb)) * 100 : 0,
                                    offFtR: totals.fga > 0 ? (totals.fta / totals.fga) * 100 : 0,
                                    defEfg: totals.fgaV > 0 ? ((totals.fgmV + 0.5 * totals.tpmV) / totals.fgaV) * 100 : 0,
                                    defTov: defTovDenom > 0 ? (totals.tovV / defTovDenom) * 100 : 0,
                                    defOreb: (totals.fga - totals.fgm + totals.orebV) > 0 ? (totals.orebV / (totals.fga - totals.fgm + totals.orebV)) * 100 : 0,
                                    defFtR: totals.fgaV > 0 ? (totals.ftaV / totals.fgaV) * 100 : 0,
                                    off: totals.poss > 0 ? (totals.pts / totals.poss) * 100 : 0,
                                    def: totals.possV > 0 ? (totals.ptsV / totals.possV) * 100 : 0,
                                    get net() { return this.off - this.def; },
                                    // New stats: Rim, 3PT, AST (VOL as shot distribution %)
                                    offRimVol: totals.fga > 0 ? (totals.rimA / totals.fga) * 100 : 0,
                                    offRimPct: totals.rimA > 0 ? (totals.rimM / totals.rimA) * 100 : 0,
                                    offThreeVol: totals.fga > 0 ? (totals.tpa / totals.fga) * 100 : 0,
                                    offThreePct: totals.tpa > 0 ? (totals.tpm / totals.tpa) * 100 : 0,
                                    offAstPct: totals.fgm > 0 ? (totals.ast / totals.fgm) * 100 : 0,
                                    defRimVol: totals.fgaV > 0 ? (totals.rimAV / totals.fgaV) * 100 : 0,
                                    defRimPct: totals.rimAV > 0 ? (totals.rimMV / totals.rimAV) * 100 : 0,
                                    defThreeVol: totals.fgaV > 0 ? (totals.tpaV / totals.fgaV) * 100 : 0,
                                    defThreePct: totals.tpaV > 0 ? (totals.tpmV / totals.tpaV) * 100 : 0
                                };
                            };
                            
                            // Get teams to display
                            const teamsToShow = exportFFTeamMode === 'select' && exportFFSelectedTeams.length > 0
                                ? exportFFSelectedTeams
                                : teams;
                            
                            // Calculate FF for all teams
                            const allTeamsFF = teamsToShow.map(t => calcTeamFF(t)).filter(t => t.poss > 100);
                            
                            // Sort by selected stat
                            const higherBetter = ['off', 'net', 'offEfg', 'offOreb', 'offFtR', 'defTov', 'offRimVol', 'offRimPct', 'offThreeVol', 'offThreePct', 'offAstPct', 'defRimVol', 'defThreeVol'].includes(exportFFOrderBy);
                            const sorted = [...allTeamsFF].sort((a, b) => higherBetter 
                                ? (b[exportFFOrderBy] || 0) - (a[exportFFOrderBy] || 0)
                                : (a[exportFFOrderBy] || 0) - (b[exportFFOrderBy] || 0)
                            );
                            
                            // Calculate ranks for each stat
                            const getRank = (teamData, stat) => {
                                const higherBetterStats = ['off', 'net', 'offEfg', 'offOreb', 'offFtR', 'defTov', 'offRimVol', 'offRimPct', 'offThreeVol', 'offThreePct', 'offAstPct', 'defRimVol', 'defThreeVol'];
                                const sortedByStat = [...allTeamsFF].sort((a, b) => 
                                    higherBetterStats.includes(stat) 
                                        ? (b[stat] || 0) - (a[stat] || 0)
                                        : (a[stat] || 0) - (b[stat] || 0)
                                );
                                return sortedByStat.findIndex(t => t.team === teamData.team) + 1;
                            };
                            
                            // Get performance class for stat - uses rank-based percentiles for extra stats
                            const getPerfClass = (val, stat, teamData) => {
                                // Extra stats use rank-based percentile coloring
                                const extraStats = ['offRimVol', 'offRimPct', 'offThreeVol', 'offThreePct', 'offAstPct', 'defRimVol', 'defRimPct', 'defThreeVol', 'defThreePct'];
                                if (extraStats.includes(stat) && teamData) {
                                    const rank = getRank(teamData, stat);
                                    const totalTeams = allTeamsFF.length;
                                    const percentile = ((totalTeams - rank + 1) / totalTeams) * 100;
                                    if (percentile >= 90) return 'perf-excellent';
                                    if (percentile >= 70) return 'perf-good';
                                    if (percentile >= 30) return 'perf-average';
                                    if (percentile >= 10) return 'perf-below';
                                    return 'perf-poor';
                                }
                                
                                // Original four factors use absolute thresholds
                                const thresholds = {
                                    offEfg: [56, 53, 50, 47], defEfg: [47, 50, 53, 56],
                                    offTov: [11, 13, 15, 17], defTov: [17, 15, 13, 11],
                                    offOreb: [30, 27, 24, 21], defOreb: [21, 24, 27, 30],
                                    offFtR: [32, 28, 24, 20], defFtR: [20, 24, 28, 32]
                                }[stat] || [0, 0, 0, 0];
                                const higherBetterStat = ['offEfg', 'offOreb', 'offFtR', 'defTov'].includes(stat);
                                if (higherBetterStat) {
                                    if (val >= thresholds[0]) return 'perf-excellent';
                                    if (val >= thresholds[1]) return 'perf-good';
                                    if (val >= thresholds[2]) return 'perf-average';
                                    if (val >= thresholds[3]) return 'perf-below';
                                    return 'perf-poor';
                                } else {
                                    if (val <= thresholds[0]) return 'perf-excellent';
                                    if (val <= thresholds[1]) return 'perf-good';
                                    if (val <= thresholds[2]) return 'perf-average';
                                    if (val <= thresholds[3]) return 'perf-below';
                                    return 'perf-poor';
                                }
                            };
                            
                            // Team image upload handler
                            const handleTeamImageUpload = (teamName, e) => {
                                const file = e.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = (ev) => {
                                        setExportFFTeamImages(prev => ({ ...prev, [teamName]: ev.target.result }));
                                    };
                                    reader.readAsDataURL(file);
                                }
                            };
                            
                            // Get initials for team
                            const getTeamInitials = (name) => {
                                if (!name) return '?';
                                const words = name.split(' ');
                                if (words.length >= 2) return (words[0][0] + words[words.length - 1][0]).toUpperCase();
                                return name.substring(0, 2).toUpperCase();
                            };
                            
                            // Stat labels
                            const statLabels = {
                                offEfg: 'eFG%', offTov: 'TOV%', offOreb: 'OREB%', offFtR: 'FT Rate',
                                defEfg: 'Opp eFG%', defTov: 'Opp TOV%', defOreb: 'Opp OREB%', defFtR: 'Opp FT Rate',
                                // New stat labels (Vol as shot distribution %)
                                offRimVol: 'Rim %', offRimPct: 'Rim FG%', offThreeVol: '3PT %', offThreePct: '3PT FG%', offAstPct: 'AST%',
                                defRimVol: 'Opp Rim %', defRimPct: 'Opp Rim FG%', defThreeVol: 'Opp 3PT %', defThreePct: 'Opp 3PT FG%'
                            };
                            
                            // Build filter description
                            const getFilterDesc = () => {
                                if (exportFFDateMode === 'all') return '';
                                if (!exportFFDateApplied) return ' | Date filter not applied';
                                if (exportFFDateMode === 'after' && exportFFDateAfter) return ' | After ' + exportFFDateAfter + (stintsData.length > 0 ? ' (via stints)' : '');
                                if (exportFFDateMode === 'before' && exportFFDateBefore) return ' | Before ' + exportFFDateBefore + (stintsData.length > 0 ? ' (via stints)' : '');
                                if (exportFFDateMode === 'range') {
                                    const hasAfter = exportFFDateAfter && exportFFDateAfter.length > 0;
                                    const hasBefore = exportFFDateBefore && exportFFDateBefore.length > 0;
                                    if (hasAfter && hasBefore) return ' | ' + exportFFDateAfter + ' to ' + exportFFDateBefore + (stintsData.length > 0 ? ' (via stints)' : '');
                                    if (hasAfter) return ' | After ' + exportFFDateAfter + (stintsData.length > 0 ? ' (via stints)' : '');
                                    if (hasBefore) return ' | Before ' + exportFFDateBefore + (stintsData.length > 0 ? ' (via stints)' : '');
                                }
                                if (exportFFDateMode === 'gamerange') return ' | Games ' + exportFFGameRange.start + '-' + exportFFGameRange.end;
                                return ' | Date filtered';
                            };
                            
                            return e('div', null,
                                // Notice when date filter is selected but stints not loaded
                                exportFFDateMode !== 'all' && stintsData.length === 0 && e('div', { style: { textAlign: 'center', marginBottom: '16px', padding: '12px', background: 'rgba(251, 191, 36, 0.15)', borderRadius: '8px', border: '1px solid rgba(251, 191, 36, 0.3)' }},
                                    e('div', { style: { fontSize: '13px', color: '#fbbf24', fontWeight: '600' }}, '⚠️ Load stints.csv for date filtering'),
                                    e('div', { style: { fontSize: '11px', color: '#94a3b8', marginTop: '4px' }}, 'Date filter will calculate stats directly from stints data when loaded')
                                ),
                                // Summary info
                                e('div', { style: { textAlign: 'center', marginBottom: '24px' }},
                                    e('div', { style: { fontSize: '14px', color: '#94a3b8' }}, 
                                        sorted.length + ' teams | Ordered by ' + (statLabels[exportFFOrderBy] || exportFFOrderBy),
                                        getFilterDesc()
                                    ),
                                    (exportFFDateMode !== 'all' || exportFFDateMode === 'gamerange') && (stintsData.length > 0 || teamTotalsData.length > 0) && 
                                        e('div', { style: { fontSize: '11px', color: '#64748b', marginTop: '4px' }}, 
                                            '📊 Game dates from ' + (stintsData.length > 0 ? 'stints.csv' : 'team_totals.csv') + ' (' + gameDatesLookup.size + ' games found)'
                                        )
                                ),
                                
                                // Team Cards Grid
                                e('div', { className: 'export-ff-team-cards' },
                                    sorted.map((t, i) => e('div', { key: t.team, className: 'export-ff-team-card' },
                                        // Team Header with logo and rank (cleaner - no poss/lineups)
                                        e('div', { className: 'export-ff-team-card-header' },
                                            e('div', { 
                                                className: 'export-ff-team-logo',
                                                onClick: () => document.getElementById('team-img-' + i).click()
                                            },
                                                exportFFTeamImages[t.team] 
                                                    ? e('img', { src: exportFFTeamImages[t.team], alt: t.team })
                                                    : getTeamInitials(t.team),
                                                e('input', { 
                                                    type: 'file', 
                                                    id: 'team-img-' + i, 
                                                    accept: 'image/*', 
                                                    style: { display: 'none' },
                                                    onChange: (ev) => handleTeamImageUpload(t.team, ev)
                                                })
                                            ),
                                            e('div', null,
                                                e('div', { className: 'export-ff-team-name' }, t.team)
                                            ),
                                            e('div', { 
                                                className: 'export-ff-team-rank',
                                                style: { color: t.net >= 0 ? '#4ade80' : '#f87171' }
                                            }, '#' + (i + 1))
                                        ),
                                        
                                        // V5.12: Sorted-only prominent stat display (when sorting by Four Factors or Extra Stats)
                                        exportFFSortedStatOnly && !['net', 'off', 'def'].includes(exportFFOrderBy) && e('div', {
                                            style: {
                                                padding: '20px',
                                                textAlign: 'center',
                                                background: getPerfClass(t[exportFFOrderBy], exportFFOrderBy, t) === 'perf-excellent' ? 'linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(34, 197, 94, 0.1))' :
                                                            getPerfClass(t[exportFFOrderBy], exportFFOrderBy, t) === 'perf-good' ? 'linear-gradient(135deg, rgba(132, 204, 22, 0.2), rgba(132, 204, 22, 0.1))' :
                                                            getPerfClass(t[exportFFOrderBy], exportFFOrderBy, t) === 'perf-average' ? 'linear-gradient(135deg, rgba(234, 179, 8, 0.15), rgba(234, 179, 8, 0.08))' :
                                                            getPerfClass(t[exportFFOrderBy], exportFFOrderBy, t) === 'perf-below' ? 'linear-gradient(135deg, rgba(249, 115, 22, 0.2), rgba(249, 115, 22, 0.1))' :
                                                            'linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.1))',
                                                borderRadius: '12px',
                                                margin: '0'
                                            }
                                        },
                                            e('div', { style: { fontSize: '11px', color: '#94a3b8', textTransform: 'uppercase', letterSpacing: '1.5px', marginBottom: '8px', fontWeight: '600' }},
                                                statLabels[exportFFOrderBy]
                                            ),
                                            e('div', { style: {
                                                fontSize: '42px',
                                                fontWeight: '800',
                                                color: getPerfClass(t[exportFFOrderBy], exportFFOrderBy, t) === 'perf-excellent' ? '#4ade80' :
                                                       getPerfClass(t[exportFFOrderBy], exportFFOrderBy, t) === 'perf-good' ? '#a3e635' :
                                                       getPerfClass(t[exportFFOrderBy], exportFFOrderBy, t) === 'perf-average' ? '#fbbf24' :
                                                       getPerfClass(t[exportFFOrderBy], exportFFOrderBy, t) === 'perf-below' ? '#fb923c' : '#f87171',
                                                textShadow: '0 2px 10px rgba(0, 0, 0, 0.3)',
                                                lineHeight: '1'
                                            }},
                                                t[exportFFOrderBy].toFixed(1)
                                            ),
                                            e('div', { style: { fontSize: '13px', color: '#64748b', marginTop: '8px', fontWeight: '600' }},
                                                'Rank: ' + getRank(t, exportFFOrderBy) + ' of ' + allTeamsFF.length
                                            )
                                        ),
                                        
                                        // V5.12: Sorted-only prominent rating display (when sorting by Net/Off/Def Rtg)
                                        exportFFSortedStatOnly && ['net', 'off', 'def'].includes(exportFFOrderBy) && e('div', { 
                                            style: { 
                                                padding: '20px', 
                                                textAlign: 'center',
                                                background: exportFFOrderBy === 'off' ? 'linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(34, 197, 94, 0.08))' :
                                                            exportFFOrderBy === 'def' ? 'linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.08))' :
                                                            t.net >= 0 ? 'linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(99, 102, 241, 0.08))' : 'linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.08))',
                                                borderRadius: '12px'
                                            }
                                        },
                                            e('div', { style: { fontSize: '11px', color: '#94a3b8', textTransform: 'uppercase', letterSpacing: '1.5px', marginBottom: '8px', fontWeight: '600' }}, 
                                                exportFFOrderBy === 'off' ? 'Offensive Rating' : exportFFOrderBy === 'def' ? 'Defensive Rating' : 'Net Rating'
                                            ),
                                            e('div', { style: { 
                                                fontSize: '42px', 
                                                fontWeight: '800', 
                                                color: exportFFOrderBy === 'off' ? '#4ade80' : exportFFOrderBy === 'def' ? '#f87171' : (t.net >= 0 ? '#818cf8' : '#f87171'),
                                                textShadow: '0 2px 10px rgba(0, 0, 0, 0.3)',
                                                lineHeight: '1'
                                            }}, 
                                                (exportFFOrderBy === 'net' && t.net >= 0 ? '+' : '') + t[exportFFOrderBy].toFixed(1)
                                            ),
                                            e('div', { style: { fontSize: '13px', color: '#64748b', marginTop: '8px', fontWeight: '600' }}, 
                                                'Rank: ' + getRank(t, exportFFOrderBy) + ' of ' + allTeamsFF.length
                                            )
                                        ),
                                        
                                        // Stats Grid (shown when NOT in sorted-only mode, or when secondary is enabled but not sorted-only for FF stats)
                                        !exportFFSortedStatOnly && exportFFShowSecondary && e('div', { className: 'export-ff-team-stats' },
                                            // Offensive section
                                            e('div', { className: 'export-ff-team-section offense' },
                                                e('div', { className: 'export-ff-team-section-title' }, '⬆️ Offense'),
                                                // Original four factors
                                                exportFFShowStats.filter(s => s.startsWith('off') && ['offEfg', 'offTov', 'offOreb', 'offFtR'].includes(s)).map(stat =>
                                                    e('div', { key: stat, className: 'export-ff-stat-box ' + getPerfClass(t[stat], stat, t) },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, statLabels[stat]),
                                                            e('div', { className: 'export-ff-stat-value' }, t[stat].toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-rank' }, getRank(t, stat) + '/' + allTeamsFF.length)
                                                    )
                                                ),
                                                // Visual separator between Four Factors and Extra Stats
                                                exportFFShowExtraStats && e('div', {
                                                    key: 'off-separator',
                                                    style: {
                                                        gridColumn: '1 / -1',
                                                        height: '1px',
                                                        background: 'linear-gradient(90deg, transparent, rgba(74, 222, 128, 0.4), transparent)',
                                                        margin: '4px 0'
                                                    }
                                                }),
                                                // New offensive stats: Rim %, Rim FG%, 3PT %, 3PT FG%, AST% (conditionally shown)
                                                exportFFShowExtraStats && ['offRimVol', 'offRimPct', 'offThreeVol', 'offThreePct', 'offAstPct'].map(stat => 
                                                    e('div', { key: stat, className: 'export-ff-stat-box ' + getPerfClass(t[stat], stat, t) },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, statLabels[stat]),
                                                            e('div', { className: 'export-ff-stat-value' }, t[stat].toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-rank' }, getRank(t, stat) + '/' + allTeamsFF.length)
                                                    )
                                                )
                                            ),
                                            // Defensive section
                                            e('div', { className: 'export-ff-team-section defense' },
                                                e('div', { className: 'export-ff-team-section-title' }, '⬇️ Defense'),
                                                // Original four factors
                                                exportFFShowStats.filter(s => s.startsWith('def') && ['defEfg', 'defTov', 'defOreb', 'defFtR'].includes(s)).map(stat =>
                                                    e('div', { key: stat, className: 'export-ff-stat-box ' + getPerfClass(t[stat], stat, t) },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, statLabels[stat]),
                                                            e('div', { className: 'export-ff-stat-value' }, t[stat].toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-rank' }, getRank(t, stat) + '/' + allTeamsFF.length)
                                                    )
                                                ),
                                                // Visual separator between Four Factors and Extra Stats
                                                exportFFShowExtraStats && e('div', {
                                                    key: 'def-separator',
                                                    style: {
                                                        gridColumn: '1 / -1',
                                                        height: '1px',
                                                        background: 'linear-gradient(90deg, transparent, rgba(248, 113, 113, 0.4), transparent)',
                                                        margin: '4px 0'
                                                    }
                                                }),
                                                // New defensive stats: Rim %, Rim FG%, 3PT %, 3PT FG% (conditionally shown)
                                                exportFFShowExtraStats && ['defRimVol', 'defRimPct', 'defThreeVol', 'defThreePct'].map(stat => 
                                                    e('div', { key: stat, className: 'export-ff-stat-box ' + getPerfClass(t[stat], stat, t) },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, statLabels[stat]),
                                                            e('div', { className: 'export-ff-stat-value' }, t[stat].toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-rank' }, getRank(t, stat) + '/' + allTeamsFF.length)
                                                    )
                                                )
                                            )
                                        ),
                                        
                                        // V5.5: Ratings at bottom (only when NOT in sorted-only mode)
                                        !exportFFSortedStatOnly && e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '4px', padding: '12px', borderTop: exportFFShowSecondary ? '1px solid rgba(71, 85, 105, 0.5)' : 'none' }},
                                            e('div', { style: { textAlign: 'center', padding: '8px', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px' }},
                                                e('div', { style: { fontSize: '18px', fontWeight: '800', color: '#4ade80' }}, t.off.toFixed(1)),
                                                e('div', { style: { fontSize: '9px', color: '#94a3b8', textTransform: 'uppercase' }}, 'Off Rtg'),
                                                e('div', { style: { fontSize: '10px', color: '#64748b', marginTop: '2px' }}, '#' + getRank(t, 'off') + '/' + allTeamsFF.length)
                                            ),
                                            e('div', { style: { textAlign: 'center', padding: '8px', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '8px' }},
                                                e('div', { style: { fontSize: '18px', fontWeight: '800', color: '#f87171' }}, t.def.toFixed(1)),
                                                e('div', { style: { fontSize: '9px', color: '#94a3b8', textTransform: 'uppercase' }}, 'Def Rtg'),
                                                e('div', { style: { fontSize: '10px', color: '#64748b', marginTop: '2px' }}, '#' + getRank(t, 'def') + '/' + allTeamsFF.length)
                                            ),
                                            e('div', { style: { textAlign: 'center', padding: '8px', background: t.net >= 0 ? 'rgba(99, 102, 241, 0.15)' : 'rgba(239, 68, 68, 0.15)', borderRadius: '8px' }},
                                                e('div', { style: { fontSize: '18px', fontWeight: '800', color: t.net >= 0 ? '#818cf8' : '#f87171' }}, (t.net >= 0 ? '+' : '') + t.net.toFixed(1)),
                                                e('div', { style: { fontSize: '9px', color: '#94a3b8', textTransform: 'uppercase' }}, 'Net Rtg')
                                            )
                                        )
                                    ))
                                )
                            );
                        })(),
                        
                        // Four Factors Legend
                        exportMode === 'fourfactors' && exportShowLegend && e('div', { style: { marginTop: '16px', padding: '10px 14px', background: 'rgba(15, 23, 42, 0.8)', borderRadius: '8px', border: '1px solid #334155' }},
                            e('div', { style: { fontSize: '10px', color: '#64748b', marginBottom: '6px', fontWeight: '600' }}, '📊 FOUR FACTORS LEGEND'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '8px', fontSize: '9px' }},
                                e('div', { style: { padding: '6px 8px', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '4px', borderLeft: '2px solid #22c55a' }},
                                    e('div', { style: { color: '#4ade80', fontWeight: '600', marginBottom: '2px' }}, '⬆️ Offense'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'eFG%'), ' — Shooting efficiency (3s count 1.5x)'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'TOV%'), ' — Turnovers per play (lower = better)'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'OREB%'), ' — Offensive rebound rate'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'FT Rate'), ' — Free throws per FG attempt')
                                ),
                                e('div', { style: { padding: '6px 8px', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '4px', borderLeft: '2px solid #ef4444' }},
                                    e('div', { style: { color: '#f87171', fontWeight: '600', marginBottom: '2px' }}, '⬇️ Defense'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'eFG%'), ' — Opponent shooting (lower = better)'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'TOV%'), ' — Forced turnovers (higher = better)'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'OREB%'), ' — Opp OREB allowed (lower = better)'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'FT Rate'), ' — Opp FT rate (lower = better)')
                                )
                            ),
                            e('div', { style: { marginTop: '6px', fontSize: '9px', color: '#64748b', borderTop: '1px solid #334155', paddingTop: '6px' }},
                                '🎨 Color coding: Green = top performers, Red = bottom performers (rank-based percentile within dataset)'
                            )
                        ),
                        
                        // SOS Export View - League Table & Points Added Analysis
                        exportMode === 'sos' && teamTotalsData.length > 0 && (() => {
                            // ============================================
                            // SOS EXPORT VIEW - Card-based mobile design
                            // Uses date-filtered data for ratings but FULL data for SOS
                            // ============================================
                            
                            // Parse ALL games first (for SOS calculation)
                            const allGameResults = new Map();
                            teamTotalsData.forEach(row => {
                                const gameId = row.game_id;
                                const teamName = row.team;
                                if (!gameId || !teamName) return;
                                if (!allGameResults.has(gameId)) {
                                    allGameResults.set(gameId, { teams: [], data: {}, date: row.game_date });
                                }
                                const game = allGameResults.get(gameId);
                                game.teams.push(teamName);
                                game.data[teamName] = {
                                    pts: parseFloat(row.points) || 0,
                                    fgm: parseFloat(row.fgm) || 0,
                                    fga: parseFloat(row.fga) || 0,
                                    fg3m: parseFloat(row.fg3m) || 0,
                                    fg3a: parseFloat(row.fg3a) || 0,
                                    ftm: parseFloat(row.ftm) || 0,
                                    fta: parseFloat(row.fta) || 0,
                                    oreb: parseFloat(row.oreb) || 0,
                                    dreb: parseFloat(row.dreb) || 0,
                                    tov: parseFloat(row.tov) || 0,
                                    poss: parseFloat(row.poss) || 0
                                };
                            });
                            
                            // Build sorted list of all complete games
                            const allGames = [];
                            allGameResults.forEach((game, gameId) => {
                                if (game.teams.length !== 2) return;
                                allGames.push({ gameId, ...game });
                            });
                            allGames.sort((a, b) => {
                                if (!a.date || !b.date) return 0;
                                return new Date(a.date) - new Date(b.date);
                            });
                            
                            // Apply date filter for ratings
                            let filteredGames = [...allGames];
                            let filterDesc = 'All Games';
                            
                            if (exportSOSDateMode === 'range' && exportSOSDateAfter && exportSOSDateBefore) {
                                const startDate = new Date(exportSOSDateAfter);
                                const endDate = new Date(exportSOSDateBefore);
                                endDate.setHours(23, 59, 59, 999);
                                filteredGames = allGames.filter(g => {
                                    if (!g.date) return false;
                                    const gameDate = new Date(g.date);
                                    return gameDate >= startDate && gameDate <= endDate;
                                });
                                filterDesc = exportSOSDateAfter + ' to ' + exportSOSDateBefore;
                            } else if (exportSOSDateMode === 'after' && exportSOSDateAfter) {
                                const startDate = new Date(exportSOSDateAfter);
                                filteredGames = allGames.filter(g => g.date && new Date(g.date) >= startDate);
                                filterDesc = 'After ' + exportSOSDateAfter;
                            } else if (exportSOSDateMode === 'before' && exportSOSDateBefore) {
                                const endDate = new Date(exportSOSDateBefore);
                                endDate.setHours(23, 59, 59, 999);
                                filteredGames = allGames.filter(g => g.date && new Date(g.date) <= endDate);
                                filterDesc = 'Before ' + exportSOSDateBefore;
                            } else if (exportSOSDateMode === 'gamerange') {
                                const startIdx = Math.max(0, exportSOSGameRange.start - 1);
                                const endIdx = Math.min(allGames.length, exportSOSGameRange.end);
                                filteredGames = allGames.slice(startIdx, endIdx);
                                filterDesc = 'Games ' + exportSOSGameRange.start + '-' + exportSOSGameRange.end;
                            }
                            
                            // Build team stats from FILTERED games (for ratings)
                            const teamStats = new Map();
                            filteredGames.forEach(game => {
                                const [team1, team2] = game.teams;
                                const d1 = game.data[team1];
                                const d2 = game.data[team2];
                                
                                [{ name: team1, own: d1, opp: d2 }, { name: team2, own: d2, opp: d1 }].forEach(({ name, own, opp }) => {
                                    if (!teamStats.has(name)) {
                                        teamStats.set(name, {
                                            games: 0, wins: 0, losses: 0, pts: 0, ptsA: 0, poss: 0, possA: 0,
                                            fgm: 0, fga: 0, fg3m: 0, fg3a: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, tov: 0,
                                            fgmA: 0, fgaA: 0, fg3mA: 0, fg3aA: 0, ftmA: 0, ftaA: 0, orebA: 0, drebA: 0, tovA: 0,
                                            opponents: []
                                        });
                                    }
                                    const t = teamStats.get(name);
                                    t.games++;
                                    if (own.pts > opp.pts) t.wins++; else t.losses++;
                                    t.pts += own.pts; t.ptsA += opp.pts;
                                    const ownPoss = own.poss || (own.fga - own.oreb + own.tov + 0.44 * own.fta);
                                    const oppPoss = opp.poss || (opp.fga - opp.oreb + opp.tov + 0.44 * opp.fta);
                                    t.poss += ownPoss; t.possA += oppPoss;
                                    t.fgm += own.fgm; t.fga += own.fga; t.fg3m += own.fg3m; t.fg3a += own.fg3a;
                                    t.ftm += own.ftm; t.fta += own.fta; t.oreb += own.oreb; t.dreb += own.dreb; t.tov += own.tov;
                                    t.fgmA += opp.fgm; t.fgaA += opp.fga; t.fg3mA += opp.fg3m; t.fg3aA += opp.fg3a;
                                    t.ftmA += opp.ftm; t.ftaA += opp.fta; t.orebA += opp.oreb; t.drebA += opp.dreb; t.tovA += opp.tov;
                                    t.opponents.push(name === team1 ? team2 : team1);
                                });
                            });
                            
                            // Build team stats from ALL games (for SOS calculation)
                            const teamStatsAll = new Map();
                            allGames.forEach(game => {
                                const [team1, team2] = game.teams;
                                const d1 = game.data[team1];
                                const d2 = game.data[team2];
                                
                                [{ name: team1, own: d1, opp: d2 }, { name: team2, own: d2, opp: d1 }].forEach(({ name, own, opp }) => {
                                    if (!teamStatsAll.has(name)) {
                                        teamStatsAll.set(name, { pts: 0, ptsA: 0, poss: 0, possA: 0, opponents: [] });
                                    }
                                    const t = teamStatsAll.get(name);
                                    t.pts += own.pts; t.ptsA += opp.pts;
                                    const ownPoss = own.poss || (own.fga - own.oreb + own.tov + 0.44 * own.fta);
                                    const oppPoss = opp.poss || (opp.fga - opp.oreb + opp.tov + 0.44 * opp.fta);
                                    t.poss += ownPoss; t.possA += oppPoss;
                                    t.opponents.push(name === team1 ? team2 : team1);
                                });
                            });
                            
                            // Calculate league average from FILTERED games
                            let totalPts = 0, totalPoss = 0;
                            teamStats.forEach(t => { totalPts += t.pts; totalPoss += t.poss; });
                            const leagueAvgOrtg = totalPoss > 0 ? (totalPts / totalPoss) * 100 : 100;
                            
                            // Calculate raw ratings
                            const teamRawRatings = new Map();
                            teamStats.forEach((t, name) => {
                                if (t.games === 0) return;
                                const ortg = t.poss > 0 ? (t.pts / t.poss) * 100 : leagueAvgOrtg;
                                const drtg = t.possA > 0 ? (t.ptsA / t.possA) * 100 : leagueAvgOrtg;
                                teamRawRatings.set(name, { ortg, drtg, netRtg: ortg - drtg });
                            });
                            
                            // Iterative SOS adjustment (KenPom style) using FULL data
                            const ITERATIONS = 10;
                            const REGRESSION = 0.8;
                            
                            // Calculate full-data raw ratings for SOS
                            const teamRawRatingsAll = new Map();
                            teamStatsAll.forEach((t, name) => {
                                const ortg = t.poss > 0 ? (t.pts / t.poss) * 100 : 100;
                                const drtg = t.possA > 0 ? (t.ptsA / t.possA) * 100 : 100;
                                teamRawRatingsAll.set(name, { ortg, drtg, netRtg: ortg - drtg });
                            });
                            
                            let adjORtgAll = new Map();
                            let adjDRtgAll = new Map();
                            teamRawRatingsAll.forEach((r, name) => { adjORtgAll.set(name, r.ortg); adjDRtgAll.set(name, r.drtg); });
                            
                            for (let iter = 0; iter < ITERATIONS; iter++) {
                                const newAdjO = new Map();
                                const newAdjD = new Map();
                                teamStatsAll.forEach((t, name) => {
                                    if (t.opponents.length === 0) return;
                                    let sumOppD = 0, sumOppO = 0;
                                    t.opponents.forEach(opp => {
                                        sumOppD += adjDRtgAll.get(opp) || 100;
                                        sumOppO += adjORtgAll.get(opp) || 100;
                                    });
                                    const avgOppD = sumOppD / t.opponents.length;
                                    const avgOppO = sumOppO / t.opponents.length;
                                    const raw = teamRawRatingsAll.get(name);
                                    newAdjO.set(name, raw.ortg + (100 - avgOppD) * REGRESSION);
                                    newAdjD.set(name, raw.drtg + (100 - avgOppO) * REGRESSION);
                                });
                                adjORtgAll = newAdjO;
                                adjDRtgAll = newAdjD;
                            }
                            
                            // Now do iterative adjustment for FILTERED data
                            let adjORtg = new Map();
                            let adjDRtg = new Map();
                            teamRawRatings.forEach((r, name) => { adjORtg.set(name, r.ortg); adjDRtg.set(name, r.drtg); });
                            
                            for (let iter = 0; iter < ITERATIONS; iter++) {
                                const newAdjO = new Map();
                                const newAdjD = new Map();
                                teamStats.forEach((t, name) => {
                                    if (t.opponents.length === 0) return;
                                    let sumOppD = 0, sumOppO = 0;
                                    t.opponents.forEach(opp => {
                                        sumOppD += adjDRtg.get(opp) || leagueAvgOrtg;
                                        sumOppO += adjORtg.get(opp) || leagueAvgOrtg;
                                    });
                                    const avgOppD = sumOppD / t.opponents.length;
                                    const avgOppO = sumOppO / t.opponents.length;
                                    const raw = teamRawRatings.get(name);
                                    newAdjO.set(name, raw.ortg + (leagueAvgOrtg - avgOppD) * REGRESSION);
                                    newAdjD.set(name, raw.drtg + (leagueAvgOrtg - avgOppO) * REGRESSION);
                                });
                                adjORtg = newAdjO;
                                adjDRtg = newAdjD;
                            }
                            
                            // Calculate SOS from FULL data
                            const calcSOSNet = (name) => {
                                const t = teamStatsAll.get(name);
                                if (!t || t.opponents.length === 0) return 0;
                                let sum = 0;
                                t.opponents.forEach(opp => {
                                    const oppNet = (adjORtgAll.get(opp) || 100) - (adjDRtgAll.get(opp) || 100);
                                    sum += oppNet;
                                });
                                return sum / t.opponents.length;
                            };
                            
                            // Pythagorean calculations
                            const PYTH_EXP = 14;
                            const netRtgToWinProb = (netA, netB) => 1 / (1 + Math.pow(10, -(netA - netB) / 10));
                            
                            // Build team ratings array
                            const teamRatings = [];
                            const allUniqueTeams = [...teamStats.keys()];
                            const nTeams = allUniqueTeams.length;
                            const FULL_SEASON_LENGTH = (nTeams - 1) * 4;
                            
                            teamStats.forEach((t, name) => {
                                if (t.games === 0) return;
                                const adjO = adjORtg.get(name) || 100;
                                const adjD = adjDRtg.get(name) || 100;
                                const adjNet = adjO - adjD;
                                
                                // Four Factors
                                const offEfg = t.fga > 0 ? ((t.fgm + 0.5 * t.fg3m) / t.fga) * 100 : 0;
                                const offTovPct = (t.fga + 0.44 * t.fta + t.tov) > 0 ? (t.tov / (t.fga + 0.44 * t.fta + t.tov)) * 100 : 0;
                                const offOrebPct = (t.oreb + t.drebA) > 0 ? (t.oreb / (t.oreb + t.drebA)) * 100 : 0;
                                const offFtRate = t.fga > 0 ? (t.fta / t.fga) * 100 : 0;
                                
                                const defEfg = t.fgaA > 0 ? ((t.fgmA + 0.5 * t.fg3mA) / t.fgaA) * 100 : 0;
                                const defTovPct = (t.fgaA + 0.44 * t.ftaA + t.tovA) > 0 ? (t.tovA / (t.fgaA + 0.44 * t.ftaA + t.tovA)) * 100 : 0;
                                const defOrebPct = (t.orebA + t.dreb) > 0 ? (t.orebA / (t.orebA + t.dreb)) * 100 : 0;
                                const defFtRate = t.fgaA > 0 ? (t.ftaA / t.fgaA) * 100 : 0;
                                
                                // Pythagorean expected wins
                                const pf14 = Math.pow(t.pts / t.games, PYTH_EXP);
                                const pa14 = Math.pow(t.ptsA / t.games, PYTH_EXP);
                                const pythWinPct = (pf14 + pa14) > 0 ? pf14 / (pf14 + pa14) : 0.5;
                                const pythExpWins = pythWinPct * t.games;
                                
                                // Pythagorean projected W-L
                                let pythProjWins = 0;
                                allUniqueTeams.forEach(opp => {
                                    if (opp === name) return;
                                    const oppData = teamStats.get(opp);
                                    const oppAdjNet = oppData ? ((adjORtg.get(opp) || 100) - (adjDRtg.get(opp) || 100)) : 0;
                                    pythProjWins += netRtgToWinProb(adjNet, oppAdjNet) * 4;
                                });
                                
                                // SOS from FULL data
                                const sosNet = calcSOSNet(name);
                                
                                teamRatings.push({
                                    name, games: t.games, wins: t.wins, losses: t.losses,
                                    adjOrtg: adjO, adjDrtg: adjD, adjNet,
                                    pythExpWins, pythProjWins: Math.round(pythProjWins), pythProjLosses: FULL_SEASON_LENGTH - Math.round(pythProjWins),
                                    sosNet,
                                    offEfg, offTovPct, offOrebPct, offFtRate,
                                    defEfg, defTovPct, defOrebPct, defFtRate,
                                    // Points Added (per 100 possessions impact)
                                    offEfgPA: (offEfg - 50) * 2.0, // Each 1% eFG ≈ 2 pts/100
                                    offTovPA: (12 - offTovPct) * 1.4, // Lower TOV% is better
                                    offOrebPA: (offOrebPct - 25) * 0.7,
                                    offFtRPA: (offFtRate - 25) * 0.4,
                                    defEfgPA: (50 - defEfg) * 2.0, // Lower opp eFG is better
                                    defTovPA: (defTovPct - 12) * 1.4, // Higher opp TOV% is better
                                    defOrebPA: (25 - defOrebPct) * 0.7, // Lower opp OREB% is better
                                    defFtRPA: (25 - defFtRate) * 0.4
                                });
                            });
                            
                            // Sort by adjusted net rating
                            teamRatings.sort((a, b) => b.adjNet - a.adjNet);
                            
                            // Scoring & Poss PA calculations
                            teamRatings.forEach(t => {
                                t.offScoringPA = t.offEfgPA + t.offFtRPA;
                                t.offPossPA = t.offTovPA + t.offOrebPA;
                                t.offTotalPA = t.offScoringPA + t.offPossPA;
                                t.defScoringPA = t.defEfgPA + t.defFtRPA;
                                t.defPossPA = t.defTovPA + t.defOrebPA;
                                t.defTotalPA = t.defScoringPA + t.defPossPA;
                            });
                            
                            // Rank helpers
                            const getRank = (team, stat, higherBetter = true) => {
                                const sorted = [...teamRatings].sort((a, b) => higherBetter ? (b[stat] - a[stat]) : (a[stat] - b[stat]));
                                return sorted.findIndex(t => t.name === team.name) + 1;
                            };
                            
                            const getPerfClass = (rank, total) => {
                                const pct = ((total - rank + 1) / total) * 100;
                                if (pct >= 90) return 'perf-excellent';
                                if (pct >= 70) return 'perf-good';
                                if (pct >= 30) return 'perf-average';
                                if (pct >= 10) return 'perf-below';
                                return 'perf-poor';
                            };
                            
                            // Team image upload handler
                            const handleTeamImageUpload = (teamName, ev) => {
                                const file = ev.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = (e) => setExportSOSTeamImages(prev => ({ ...prev, [teamName]: e.target.result }));
                                    reader.readAsDataURL(file);
                                }
                            };
                            
                            const getTeamInitials = (name) => {
                                if (!name) return '?';
                                const words = name.split(' ');
                                if (words.length >= 2) return (words[0][0] + words[words.length - 1][0]).toUpperCase();
                                return name.substring(0, 2).toUpperCase();
                            };
                            
                            return e('div', null,
                                // Filter description
                                e('div', { style: { textAlign: 'center', marginBottom: '16px', fontSize: '12px', color: '#94a3b8' }},
                                    filteredGames.length + ' games | ' + filterDesc,
                                    e('div', { style: { fontSize: '10px', color: '#64748b', marginTop: '4px' }}, 
                                        'SOS calculated from full season (' + allGames.length + ' games)'
                                    )
                                ),
                                
                                // Color Legend
                                e('div', { style: { marginBottom: '16px', padding: '10px 14px', background: 'rgba(15, 23, 42, 0.5)', borderRadius: '8px', display: 'flex', gap: '8px', flexWrap: 'wrap', alignItems: 'center', justifyContent: 'center' }},
                                    e('span', { style: { fontSize: '10px', color: '#64748b', marginRight: '4px' }}, 'League Rank:'),
                                    e('span', { className: 'legend-item legend-excellent', style: { fontSize: '9px' }}, '90+'),
                                    e('span', { className: 'legend-item legend-good', style: { fontSize: '9px' }}, '70-89'),
                                    e('span', { className: 'legend-item legend-average', style: { fontSize: '9px' }}, '30-69'),
                                    e('span', { className: 'legend-item legend-below', style: { fontSize: '9px' }}, '10-29'),
                                    e('span', { className: 'legend-item legend-poor', style: { fontSize: '9px' }}, '<10')
                                ),
                                
                                // ============================================
                                // TABLES VIEW
                                // ============================================
                                exportSOSViewMode === 'tables' && e('div', null,
                                    // Table 1: Adjusted Ratings & Expected Wins
                                    e('div', { style: { marginBottom: '24px' }},
                                        e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#a78bfa', marginBottom: '10px', textTransform: 'uppercase', letterSpacing: '0.5px' }}, 
                                            '📊 Adjusted Ratings & Expected Wins'
                                        ),
                                        e('div', { style: { overflowX: 'auto' }},
                                            e('table', { style: { width: '100%', borderCollapse: 'separate', borderSpacing: '4px', fontSize: '11px' }},
                                                e('thead', null,
                                                    e('tr', null,
                                                        e('th', { style: { padding: '8px 6px', textAlign: 'left', fontSize: '9px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '6px' }}, '#'),
                                                        e('th', { style: { padding: '8px 6px', textAlign: 'left', fontSize: '9px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '6px' }}, 'Team'),
                                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '6px' }}, 'W-L'),
                                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#a78bfa', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '6px' }}, 'Proj'),
                                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#4ade80', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '6px' }}, 'Off Rtg'),
                                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#f87171', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '6px' }}, 'Def Rtg'),
                                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#e2e8f0', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '6px' }}, 'Net'),
                                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#f472b6', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '6px' }}, 'Pyth xW'),
                                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#fbbf24', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '6px' }}, 'SOS Net')
                                                    )
                                                ),
                                                e('tbody', null,
                                                    teamRatings.map((team, idx) => 
                                                        e('tr', { key: team.name },
                                                            // Rank
                                                            e('td', { style: { padding: '4px', textAlign: 'center' }},
                                                                e('div', { style: { 
                                                                    width: '24px', height: '24px', borderRadius: '50%',
                                                                    background: 'linear-gradient(135deg, #f59e0b, #d97706)',
                                                                    display: 'flex', alignItems: 'center', justifyContent: 'center',
                                                                    fontSize: '11px', fontWeight: '800', color: 'white'
                                                                }}, idx + 1)
                                                            ),
                                                            // Team name
                                                            e('td', { style: { padding: '6px', fontWeight: '600', color: '#e2e8f0', whiteSpace: 'nowrap' }}, team.name),
                                                            // W-L
                                                            e('td', { style: { padding: '4px' }},
                                                                e('div', { style: { 
                                                                    padding: '4px 8px', borderRadius: '6px', textAlign: 'center',
                                                                    background: team.wins > team.losses ? 'rgba(34, 197, 94, 0.25)' : team.wins < team.losses ? 'rgba(239, 68, 68, 0.25)' : 'rgba(148, 163, 184, 0.2)',
                                                                    border: team.wins > team.losses ? '1px solid rgba(34, 197, 94, 0.4)' : team.wins < team.losses ? '1px solid rgba(239, 68, 68, 0.4)' : '1px solid rgba(148, 163, 184, 0.3)'
                                                                }},
                                                                    e('div', { style: { fontSize: '12px', fontWeight: '700', color: team.wins > team.losses ? '#4ade80' : team.wins < team.losses ? '#f87171' : '#94a3b8' }}, 
                                                                        team.wins + '-' + team.losses
                                                                    )
                                                                )
                                                            ),
                                                            // Proj W-L
                                                            e('td', { style: { padding: '4px' }},
                                                                e('div', { style: { 
                                                                    padding: '4px 8px', borderRadius: '6px', textAlign: 'center',
                                                                    background: 'rgba(139, 92, 246, 0.25)',
                                                                    border: '1px solid rgba(139, 92, 246, 0.4)'
                                                                }},
                                                                    e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#a78bfa' }}, 
                                                                        team.pythProjWins + '-' + team.pythProjLosses
                                                                    )
                                                                )
                                                            ),
                                                            // Off Rtg
                                                            e('td', { style: { padding: '4px' }},
                                                                e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(getRank(team, 'adjOrtg', true), nTeams), style: { padding: '4px 6px', borderRadius: '6px', textAlign: 'center' }},
                                                                    e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, team.adjOrtg.toFixed(1)),
                                                                    e('div', { style: { fontSize: '9px', fontWeight: '700', color: '#fbbf24' }}, '#' + getRank(team, 'adjOrtg', true))
                                                                )
                                                            ),
                                                            // Def Rtg
                                                            e('td', { style: { padding: '4px' }},
                                                                e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(getRank(team, 'adjDrtg', false), nTeams), style: { padding: '4px 6px', borderRadius: '6px', textAlign: 'center' }},
                                                                    e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, team.adjDrtg.toFixed(1)),
                                                                    e('div', { style: { fontSize: '9px', fontWeight: '700', color: '#fbbf24' }}, '#' + getRank(team, 'adjDrtg', false))
                                                                )
                                                            ),
                                                            // Net Rtg
                                                            e('td', { style: { padding: '4px' }},
                                                                e('div', { style: { 
                                                                    padding: '4px 6px', borderRadius: '6px', textAlign: 'center',
                                                                    background: team.adjNet >= 0 ? 'rgba(34, 197, 94, 0.25)' : 'rgba(239, 68, 68, 0.25)'
                                                                }},
                                                                    e('div', { style: { fontSize: '12px', fontWeight: '700', color: team.adjNet >= 0 ? '#4ade80' : '#f87171' }}, 
                                                                        (team.adjNet >= 0 ? '+' : '') + team.adjNet.toFixed(1)
                                                                    )
                                                                )
                                                            ),
                                                            // Pyth xW
                                                            e('td', { style: { padding: '4px' }},
                                                                e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(getRank(team, 'pythExpWins', true), nTeams), style: { padding: '4px 6px', borderRadius: '6px', textAlign: 'center' }},
                                                                    e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, team.pythExpWins.toFixed(1)),
                                                                    e('div', { style: { fontSize: '9px', fontWeight: '700', color: '#fbbf24' }}, '#' + getRank(team, 'pythExpWins', true))
                                                                )
                                                            ),
                                                            // SOS Net
                                                            e('td', { style: { padding: '4px' }},
                                                                e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(getRank(team, 'sosNet', true), nTeams), style: { padding: '4px 6px', borderRadius: '6px', textAlign: 'center' }},
                                                                    e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, (team.sosNet >= 0 ? '+' : '') + team.sosNet.toFixed(1)),
                                                                    e('div', { style: { fontSize: '9px', fontWeight: '700', color: '#fbbf24' }}, '#' + getRank(team, 'sosNet', true))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    ),
                                    
                                    // Table 2: Points Added Analysis (only if enabled)
                                    exportSOSShowPA && e('div', null,
                                        e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#a78bfa', marginBottom: '10px', textTransform: 'uppercase', letterSpacing: '0.5px' }}, 
                                            '⚡ Points Added Analysis (Four Factors)'
                                        ),
                                        
                                        // Offense Points Added Table
                                        e('div', { style: { marginBottom: '16px' }},
                                            e('div', { style: { fontSize: '10px', fontWeight: '600', color: '#4ade80', marginBottom: '8px' }}, '⬆️ Offense'),
                                            e('div', { style: { overflowX: 'auto' }},
                                                e('table', { style: { width: '100%', borderCollapse: 'separate', borderSpacing: '4px', fontSize: '10px' }},
                                                    e('thead', null,
                                                        e('tr', null,
                                                            e('th', { style: { padding: '6px', textAlign: 'left', fontSize: '8px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px' }}, 'Team'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px' }}, 'eFG%'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px' }}, 'FT Rate'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#fbbf24', background: 'rgba(251, 191, 36, 0.15)', borderRadius: '4px' }}, '🎯 Scoring'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px' }}, 'TOV%'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px' }}, 'OREB%'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#fbbf24', background: 'rgba(251, 191, 36, 0.15)', borderRadius: '4px' }}, '🔄 Poss'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#4ade80', background: 'rgba(34, 197, 94, 0.15)', borderRadius: '4px' }}, 'Total')
                                                        )
                                                    ),
                                                    e('tbody', null,
                                                        teamRatings.map(team => {
                                                            const offStats = ['offEfgPA', 'offFtRPA', 'offScoringPA', 'offTovPA', 'offOrebPA', 'offPossPA', 'offTotalPA'];
                                                            return e('tr', { key: team.name },
                                                                e('td', { style: { padding: '4px 6px', fontWeight: '600', color: '#e2e8f0', fontSize: '10px', whiteSpace: 'nowrap' }}, team.name),
                                                                offStats.map(stat => {
                                                                    const rank = getRank(team, stat, true);
                                                                    const isTotal = stat.includes('Scoring') || stat.includes('Poss') || stat.includes('Total');
                                                                    return e('td', { key: stat, style: { padding: '2px' }},
                                                                        e('div', { 
                                                                            className: 'export-ff-stat-box-sm ' + getPerfClass(rank, nTeams),
                                                                            style: { padding: '4px', borderRadius: '4px', textAlign: 'center', border: isTotal ? '1px solid rgba(251, 191, 36, 0.3)' : 'none' }
                                                                        },
                                                                            e('div', { style: { fontSize: '11px', fontWeight: '700', color: team[stat] >= 0 ? '#4ade80' : '#f87171' }}, 
                                                                                (team[stat] >= 0 ? '+' : '') + team[stat].toFixed(1)
                                                                            ),
                                                                            e('div', { style: { fontSize: '8px', fontWeight: '700', color: '#fbbf24' }}, '#' + rank)
                                                                        )
                                                                    );
                                                                })
                                                            );
                                                        })
                                                    )
                                                )
                                            )
                                        ),
                                        
                                        // Defense Points Added Table
                                        e('div', null,
                                            e('div', { style: { fontSize: '10px', fontWeight: '600', color: '#f87171', marginBottom: '8px' }}, '⬇️ Defense'),
                                            e('div', { style: { overflowX: 'auto' }},
                                                e('table', { style: { width: '100%', borderCollapse: 'separate', borderSpacing: '4px', fontSize: '10px' }},
                                                    e('thead', null,
                                                        e('tr', null,
                                                            e('th', { style: { padding: '6px', textAlign: 'left', fontSize: '8px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px' }}, 'Team'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px' }}, 'Opp eFG%'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px' }}, 'Opp FT Rate'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#fbbf24', background: 'rgba(251, 191, 36, 0.15)', borderRadius: '4px' }}, '🎯 Scoring'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px' }}, 'Opp TOV%'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#94a3b8', background: 'rgba(30, 41, 59, 0.8)', borderRadius: '4px' }}, 'Opp OREB%'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#fbbf24', background: 'rgba(251, 191, 36, 0.15)', borderRadius: '4px' }}, '🔄 Poss'),
                                                            e('th', { style: { padding: '6px', textAlign: 'center', fontSize: '8px', fontWeight: '600', color: '#f87171', background: 'rgba(239, 68, 68, 0.15)', borderRadius: '4px' }}, 'Total')
                                                        )
                                                    ),
                                                    e('tbody', null,
                                                        teamRatings.map(team => {
                                                            const defStats = ['defEfgPA', 'defFtRPA', 'defScoringPA', 'defTovPA', 'defOrebPA', 'defPossPA', 'defTotalPA'];
                                                            return e('tr', { key: team.name },
                                                                e('td', { style: { padding: '4px 6px', fontWeight: '600', color: '#e2e8f0', fontSize: '10px', whiteSpace: 'nowrap' }}, team.name),
                                                                defStats.map(stat => {
                                                                    const rank = getRank(team, stat, true);
                                                                    const isTotal = stat.includes('Scoring') || stat.includes('Poss') || stat.includes('Total');
                                                                    return e('td', { key: stat, style: { padding: '2px' }},
                                                                        e('div', { 
                                                                            className: 'export-ff-stat-box-sm ' + getPerfClass(rank, nTeams),
                                                                            style: { padding: '4px', borderRadius: '4px', textAlign: 'center', border: isTotal ? '1px solid rgba(251, 191, 36, 0.3)' : 'none' }
                                                                        },
                                                                            e('div', { style: { fontSize: '11px', fontWeight: '700', color: team[stat] >= 0 ? '#4ade80' : '#f87171' }}, 
                                                                                (team[stat] >= 0 ? '+' : '') + team[stat].toFixed(1)
                                                                            ),
                                                                            e('div', { style: { fontSize: '8px', fontWeight: '700', color: '#fbbf24' }}, '#' + rank)
                                                                        )
                                                                    );
                                                                })
                                                            );
                                                        })
                                                    )
                                                )
                                            )
                                        )
                                    )
                                ),
                                
                                // ============================================
                                // CARDS VIEW (Original)
                                // ============================================
                                exportSOSViewMode === 'cards' && e('div', { style: { display: 'flex', flexDirection: 'column', gap: '12px' }},
                                    teamRatings.map((team, idx) => 
                                        e('div', { 
                                            key: team.name,
                                            style: { 
                                                background: 'linear-gradient(145deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.98))',
                                                border: '2px solid #475569',
                                                borderRadius: '14px',
                                                padding: '16px',
                                                position: 'relative'
                                            }
                                        },
                                            // Team header
                                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '12px', paddingBottom: '12px', borderBottom: '1px solid rgba(71, 85, 105, 0.5)' }},
                                                // Rank badge
                                                e('div', { style: { 
                                                    width: '32px', height: '32px', borderRadius: '50%',
                                                    background: 'linear-gradient(135deg, #f59e0b, #d97706)',
                                                    display: 'flex', alignItems: 'center', justifyContent: 'center',
                                                    fontSize: '14px', fontWeight: '800', color: 'white',
                                                    flexShrink: 0
                                                }}, idx + 1),
                                                // Team logo/initials
                                                e('div', { 
                                                    style: { 
                                                        width: '40px', height: '40px', borderRadius: '50%',
                                                        background: 'linear-gradient(135deg, #1e293b, #334155)',
                                                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                                                        fontSize: '14px', fontWeight: '700', color: '#60a5fa',
                                                        border: '2px solid #475569', cursor: 'pointer', flexShrink: 0,
                                                        overflow: 'hidden'
                                                    },
                                                    onClick: () => document.getElementById('sos-team-img-' + idx).click()
                                                },
                                                    exportSOSTeamImages[team.name] 
                                                        ? e('img', { src: exportSOSTeamImages[team.name], style: { width: '100%', height: '100%', objectFit: 'cover' }})
                                                        : getTeamInitials(team.name),
                                                    e('input', { type: 'file', id: 'sos-team-img-' + idx, accept: 'image/*', style: { display: 'none' }, onChange: (ev) => handleTeamImageUpload(team.name, ev) })
                                                ),
                                                // Team name and record
                                                e('div', { style: { flex: 1, minWidth: 0 }},
                                                    e('div', { style: { fontSize: '15px', fontWeight: '700', color: '#e2e8f0', marginBottom: '4px' }}, team.name)
                                                ),
                                                // Record badges - more striking
                                                e('div', { style: { display: 'flex', gap: '8px', alignItems: 'center' }},
                                                    // Actual W-L
                                                    e('div', { style: { 
                                                        padding: '6px 10px', borderRadius: '8px',
                                                        background: team.wins > team.losses ? 'linear-gradient(135deg, rgba(34, 197, 94, 0.3), rgba(22, 163, 74, 0.2))' : team.wins < team.losses ? 'linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(220, 38, 38, 0.2))' : 'rgba(148, 163, 184, 0.2)',
                                                        border: team.wins > team.losses ? '1px solid rgba(34, 197, 94, 0.5)' : team.wins < team.losses ? '1px solid rgba(239, 68, 68, 0.5)' : '1px solid rgba(148, 163, 184, 0.3)',
                                                        textAlign: 'center'
                                                    }},
                                                        e('div', { style: { fontSize: '14px', fontWeight: '800', color: team.wins > team.losses ? '#4ade80' : team.wins < team.losses ? '#f87171' : '#94a3b8' }}, 
                                                            team.wins + '-' + team.losses
                                                        ),
                                                        e('div', { style: { fontSize: '7px', color: '#64748b', textTransform: 'uppercase', letterSpacing: '0.5px' }}, 'Actual')
                                                    ),
                                                    // Projected W-L
                                                    e('div', { style: { 
                                                        padding: '6px 10px', borderRadius: '8px',
                                                        background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(124, 58, 237, 0.2))',
                                                        border: '1px solid rgba(139, 92, 246, 0.5)',
                                                        textAlign: 'center'
                                                    }},
                                                        e('div', { style: { fontSize: '14px', fontWeight: '800', color: '#a78bfa' }}, 
                                                            team.pythProjWins + '-' + team.pythProjLosses
                                                        ),
                                                        e('div', { style: { fontSize: '7px', color: '#64748b', textTransform: 'uppercase', letterSpacing: '0.5px' }}, 'Proj')
                                                    ),
                                                    // Adj Net badge
                                                    e('div', { style: { 
                                                        padding: '6px 10px', borderRadius: '8px',
                                                        background: team.adjNet >= 0 ? 'linear-gradient(135deg, rgba(34, 197, 94, 0.25), rgba(22, 163, 74, 0.15))' : 'linear-gradient(135deg, rgba(239, 68, 68, 0.25), rgba(220, 38, 38, 0.15))',
                                                        border: team.adjNet >= 0 ? '1px solid rgba(34, 197, 94, 0.4)' : '1px solid rgba(239, 68, 68, 0.4)',
                                                        textAlign: 'center'
                                                    }},
                                                        e('div', { style: { fontSize: '14px', fontWeight: '800', color: team.adjNet >= 0 ? '#4ade80' : '#f87171' }}, 
                                                            (team.adjNet >= 0 ? '+' : '') + team.adjNet.toFixed(1)
                                                        ),
                                                        e('div', { style: { fontSize: '7px', color: '#64748b', textTransform: 'uppercase', letterSpacing: '0.5px' }}, 'Net')
                                                    )
                                                )
                                            ),
                                            
                                            // Stats grid
                                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '6px', marginBottom: '8px' }},
                                                // Adj ORtg
                                                e('div', { className: 'export-ff-stat-box ' + getPerfClass(getRank(team, 'adjOrtg', true), nTeams), style: { padding: '8px', borderRadius: '8px', textAlign: 'center' }},
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8', textTransform: 'uppercase' }}, 'Off Rtg'),
                                                    e('div', { style: { fontSize: '16px', fontWeight: '700', color: '#fff' }}, team.adjOrtg.toFixed(1)),
                                                    e('div', { style: { fontSize: '10px', fontWeight: '700', color: '#fbbf24', background: 'rgba(251, 191, 36, 0.2)', borderRadius: '4px', padding: '2px 6px', display: 'inline-block' }}, '#' + getRank(team, 'adjOrtg', true))
                                                ),
                                                // Adj DRtg
                                                e('div', { className: 'export-ff-stat-box ' + getPerfClass(getRank(team, 'adjDrtg', false), nTeams), style: { padding: '8px', borderRadius: '8px', textAlign: 'center' }},
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8', textTransform: 'uppercase' }}, 'Def Rtg'),
                                                    e('div', { style: { fontSize: '16px', fontWeight: '700', color: '#fff' }}, team.adjDrtg.toFixed(1)),
                                                    e('div', { style: { fontSize: '10px', fontWeight: '700', color: '#fbbf24', background: 'rgba(251, 191, 36, 0.2)', borderRadius: '4px', padding: '2px 6px', display: 'inline-block' }}, '#' + getRank(team, 'adjDrtg', false))
                                                ),
                                                // Pyth xW
                                                e('div', { className: 'export-ff-stat-box ' + getPerfClass(getRank(team, 'pythExpWins', true), nTeams), style: { padding: '8px', borderRadius: '8px', textAlign: 'center' }},
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8', textTransform: 'uppercase' }}, 'Pyth xW'),
                                                    e('div', { style: { fontSize: '16px', fontWeight: '700', color: '#fff' }}, team.pythExpWins.toFixed(1)),
                                                    e('div', { style: { fontSize: '10px', fontWeight: '700', color: '#fbbf24', background: 'rgba(251, 191, 36, 0.2)', borderRadius: '4px', padding: '2px 6px', display: 'inline-block' }}, '#' + getRank(team, 'pythExpWins', true))
                                                ),
                                                // SOS Net
                                                e('div', { className: 'export-ff-stat-box ' + getPerfClass(getRank(team, 'sosNet', true), nTeams), style: { padding: '8px', borderRadius: '8px', textAlign: 'center' }},
                                                    e('div', { style: { fontSize: '9px', color: '#94a3b8', textTransform: 'uppercase' }}, 'SOS Net'),
                                                    e('div', { style: { fontSize: '16px', fontWeight: '700', color: '#fff' }}, (team.sosNet >= 0 ? '+' : '') + team.sosNet.toFixed(1)),
                                                    e('div', { style: { fontSize: '10px', fontWeight: '700', color: '#fbbf24', background: 'rgba(251, 191, 36, 0.2)', borderRadius: '4px', padding: '2px 6px', display: 'inline-block' }}, '#' + getRank(team, 'sosNet', true))
                                                )
                                            ),
                                            
                                            // Points Added Analysis (expandable)
                                            exportSOSShowPA && e('div', { style: { marginTop: '8px', paddingTop: '8px', borderTop: '1px solid rgba(71, 85, 105, 0.3)' }},
                                                // Offense PA
                                                e('div', { style: { marginBottom: '12px' }},
                                                    e('div', { style: { fontSize: '10px', color: '#4ade80', fontWeight: '600', marginBottom: '8px', textTransform: 'uppercase', letterSpacing: '0.5px' }}, '⬆️ Offense Points Added'),
                                                    // Scoring Battle Section
                                                    e('div', { style: { marginBottom: '6px' }},
                                                        e('div', { style: { fontSize: '8px', color: '#64748b', marginBottom: '4px', textTransform: 'uppercase', letterSpacing: '0.5px' }}, '🎯 Scoring Battle'),
                                                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '4px' }},
                                                            ['offEfgPA', 'offFtRPA', 'offScoringPA'].map(stat => {
                                                                const labels = { offEfgPA: 'eFG%', offFtRPA: 'FT Rate', offScoringPA: 'Total' };
                                                                const rank = getRank(team, stat, true);
                                                                return e('div', { 
                                                                    key: stat,
                                                                    className: 'export-ff-stat-box-sm ' + getPerfClass(rank, nTeams),
                                                                    style: { padding: '6px 4px', borderRadius: '6px', textAlign: 'center' }
                                                                },
                                                                    e('div', { style: { fontSize: '8px', color: '#94a3b8', textTransform: 'uppercase' }}, labels[stat]),
                                                                    e('div', { style: { fontSize: '13px', fontWeight: '700', color: team[stat] >= 0 ? '#4ade80' : '#f87171' }}, 
                                                                        (team[stat] >= 0 ? '+' : '') + team[stat].toFixed(1)
                                                                    ),
                                                                    e('div', { style: { fontSize: '9px', fontWeight: '700', color: '#fbbf24', marginTop: '2px' }}, '#' + rank)
                                                                );
                                                            })
                                                        )
                                                    ),
                                                    // Separator
                                                    e('div', { style: { height: '1px', background: 'linear-gradient(90deg, transparent, rgba(71, 85, 105, 0.5), transparent)', margin: '6px 0' }}),
                                                    // Possession Battle Section
                                                    e('div', null,
                                                        e('div', { style: { fontSize: '8px', color: '#64748b', marginBottom: '4px', textTransform: 'uppercase', letterSpacing: '0.5px' }}, '🔄 Possession Battle'),
                                                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '4px' }},
                                                            ['offTovPA', 'offOrebPA', 'offPossPA'].map(stat => {
                                                                const labels = { offTovPA: 'TOV%', offOrebPA: 'OREB%', offPossPA: 'Total' };
                                                                const rank = getRank(team, stat, true);
                                                                return e('div', { 
                                                                    key: stat,
                                                                    className: 'export-ff-stat-box-sm ' + getPerfClass(rank, nTeams),
                                                                    style: { padding: '6px 4px', borderRadius: '6px', textAlign: 'center' }
                                                                },
                                                                    e('div', { style: { fontSize: '8px', color: '#94a3b8', textTransform: 'uppercase' }}, labels[stat]),
                                                                    e('div', { style: { fontSize: '13px', fontWeight: '700', color: team[stat] >= 0 ? '#4ade80' : '#f87171' }}, 
                                                                        (team[stat] >= 0 ? '+' : '') + team[stat].toFixed(1)
                                                                    ),
                                                                    e('div', { style: { fontSize: '9px', fontWeight: '700', color: '#fbbf24', marginTop: '2px' }}, '#' + rank)
                                                                );
                                                            })
                                                        )
                                                    )
                                                ),
                                                // Defense PA
                                                e('div', null,
                                                    e('div', { style: { fontSize: '10px', color: '#f87171', fontWeight: '600', marginBottom: '8px', textTransform: 'uppercase', letterSpacing: '0.5px' }}, '⬇️ Defense Points Added'),
                                                    // Scoring Battle Section
                                                    e('div', { style: { marginBottom: '6px' }},
                                                        e('div', { style: { fontSize: '8px', color: '#64748b', marginBottom: '4px', textTransform: 'uppercase', letterSpacing: '0.5px' }}, '🎯 Scoring Battle'),
                                                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '4px' }},
                                                            ['defEfgPA', 'defFtRPA', 'defScoringPA'].map(stat => {
                                                                const labels = { defEfgPA: 'Opp eFG%', defFtRPA: 'Opp FT Rate', defScoringPA: 'Total' };
                                                                const rank = getRank(team, stat, true);
                                                                return e('div', { 
                                                                    key: stat,
                                                                    className: 'export-ff-stat-box-sm ' + getPerfClass(rank, nTeams),
                                                                    style: { padding: '6px 4px', borderRadius: '6px', textAlign: 'center' }
                                                                },
                                                                    e('div', { style: { fontSize: '8px', color: '#94a3b8', textTransform: 'uppercase' }}, labels[stat]),
                                                                    e('div', { style: { fontSize: '13px', fontWeight: '700', color: team[stat] >= 0 ? '#4ade80' : '#f87171' }}, 
                                                                        (team[stat] >= 0 ? '+' : '') + team[stat].toFixed(1)
                                                                    ),
                                                                    e('div', { style: { fontSize: '9px', fontWeight: '700', color: '#fbbf24', marginTop: '2px' }}, '#' + rank)
                                                                );
                                                            })
                                                        )
                                                    ),
                                                    // Separator
                                                    e('div', { style: { height: '1px', background: 'linear-gradient(90deg, transparent, rgba(71, 85, 105, 0.5), transparent)', margin: '6px 0' }}),
                                                    // Possession Battle Section
                                                    e('div', null,
                                                        e('div', { style: { fontSize: '8px', color: '#64748b', marginBottom: '4px', textTransform: 'uppercase', letterSpacing: '0.5px' }}, '🔄 Possession Battle'),
                                                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '4px' }},
                                                            ['defTovPA', 'defOrebPA', 'defPossPA'].map(stat => {
                                                                const labels = { defTovPA: 'Opp TOV%', defOrebPA: 'Opp OREB%', defPossPA: 'Total' };
                                                                const rank = getRank(team, stat, true);
                                                                return e('div', { 
                                                                    key: stat,
                                                                    className: 'export-ff-stat-box-sm ' + getPerfClass(rank, nTeams),
                                                                    style: { padding: '6px 4px', borderRadius: '6px', textAlign: 'center' }
                                                                },
                                                                    e('div', { style: { fontSize: '8px', color: '#94a3b8', textTransform: 'uppercase' }}, labels[stat]),
                                                                    e('div', { style: { fontSize: '13px', fontWeight: '700', color: team[stat] >= 0 ? '#4ade80' : '#f87171' }}, 
                                                                        (team[stat] >= 0 ? '+' : '') + team[stat].toFixed(1)
                                                                    ),
                                                                    e('div', { style: { fontSize: '9px', fontWeight: '700', color: '#fbbf24', marginTop: '2px' }}, '#' + rank)
                                                                );
                                                            })
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            );
                        })(),
                        
                        // SOS Legend
                        exportMode === 'sos' && teamTotalsData.length > 0 && exportShowLegend && e('div', { style: { marginTop: '16px', padding: '10px 14px', background: 'rgba(15, 23, 42, 0.8)', borderRadius: '8px', border: '1px solid #334155' }},
                            e('div', { style: { fontSize: '10px', color: '#64748b', marginBottom: '6px', fontWeight: '600' }}, '📊 SOS & POINTS ADDED LEGEND'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '8px', fontSize: '9px' }},
                                e('div', { style: { padding: '6px 8px', background: 'rgba(59, 130, 246, 0.1)', borderRadius: '4px', borderLeft: '2px solid #3b82f6' }},
                                    e('div', { style: { color: '#60a5fa', fontWeight: '600', marginBottom: '2px' }}, '📈 Adjusted Ratings'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'Adj ORtg/DRtg'), ' — SOS-adjusted ratings (10 iterations)'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'Pyth xWins'), ' — Pythagorean expected wins (exp=14)'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'Proj Wins'), ' — Round-robin simulation projected wins'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'SOS'), ' — Avg opponent adjusted net rating')
                                ),
                                e('div', { style: { padding: '6px 8px', background: 'rgba(139, 92, 246, 0.1)', borderRadius: '4px', borderLeft: '2px solid #a78bfa' }},
                                    e('div', { style: { color: '#a78bfa', fontWeight: '600', marginBottom: '2px' }}, '⚡ Points Added'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'Scoring Battle'), ' — eFG% + FT Rate vs league avg'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'Poss Battle'), ' — TOV% + OREB% vs league avg'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'Total PA'), ' — All Four Factors combined'),
                                    e('div', { style: { color: '#94a3b8' }}, '(+ values = better than league average)')
                                )
                            ),
                            e('div', { style: { marginTop: '6px', fontSize: '9px', color: '#64748b', borderTop: '1px solid #334155', paddingTop: '6px' }},
                                '⚠️ SOS uses full season data regardless of date filter. Points Added are season-long totals.'
                            )
                        ),
                        
                        // Shot Distribution Export - V5.4 Enhanced with date filtering and all-teams mode
                        exportMode === 'shotdist' && (() => {
                            const players = exportShotPlayers;
                            const selectedPlayers = [players.p1, players.p2, players.p3, players.p4, players.p5].filter(Boolean);
                            
                            // Helper to parse lineup players
                            // V6.1: Apply merge rules when parsing lineup players
                            const parseLineupPlayers = (l) => {
                                if (!l.Lineup) return [];
                                return l.Lineup.split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                            };
                            
                            // Helper to calculate possession
                            const calcPoss = (fga, oreb, tov, fta) => {
                                return (fga || 0) - (oreb || 0) + (tov || 0) + 0.44 * (fta || 0);
                            };
                            
                            // Date filter helper
                            const matchesDateFilter = (l, teamName) => {
                                if (exportShotDateMode === 'all') return true;
                                let dateStr = l.Date || l.GameDate || l.date || l.game_date || '';
                                let gameId = l.GameID || l.game_id || l.Game || '';
                                if (!dateStr && gameId && gameDatesLookup.has(gameId)) {
                                    dateStr = gameDatesLookup.get(gameId);
                                }
                                if (exportShotDateMode === 'gamerange') {
                                    if (!teamName || !teamGameOrder.has(teamName)) return true;
                                    const teamGames = teamGameOrder.get(teamName);
                                    let gameNum = -1;
                                    if (gameId) {
                                        const gameInfo = teamGames.find(g => g.game_id === gameId);
                                        if (gameInfo) gameNum = gameInfo.gameNum;
                                    } else if (dateStr) {
                                        const gameInfo = teamGames.find(g => g.game_date === dateStr);
                                        if (gameInfo) gameNum = gameInfo.gameNum;
                                    }
                                    if (gameNum === -1) return true;
                                    return gameNum >= exportShotGameRange.start && gameNum <= exportShotGameRange.end;
                                }
                                if (!dateStr) return true;
                                const lineupDate = new Date(dateStr);
                                if (isNaN(lineupDate.getTime())) return true;
                                if (exportShotDateMode === 'after' && exportShotDateAfter) return lineupDate >= new Date(exportShotDateAfter);
                                if (exportShotDateMode === 'before' && exportShotDateBefore) return lineupDate <= new Date(exportShotDateBefore);
                                if (exportShotDateMode === 'range' && exportShotDateAfter && exportShotDateBefore) {
                                    return lineupDate >= new Date(exportShotDateAfter) && lineupDate <= new Date(exportShotDateBefore);
                                }
                                return true;
                            };
                            
                            // Calculate shot data for a team
                            const calcShotData = (teamName) => {
                                const filtered = lineupData.filter(l => {
                                    if (l.Team !== teamName) return false;
                                    if (!matchesDateFilter(l, teamName)) return false;
                                    // Filter by minutes instead of possessions
                                    const mins = (parseFloat(l.MIN) || (parseFloat(l.TOTAL_TIME) || 0) / 60);
                                    if (mins < exportMinPoss) return false;
                                    if (selectedPlayers.length > 0) {
                                        const lineupPlayers = parseLineupPlayers(l);
                                        const lineupNorm = lineupPlayers.map(p => normalizePlayerName(p));
                                        return selectedPlayers.every(p => lineupNorm.includes(normalizePlayerName(p)));
                                    }
                                    return true;
                                });
                                
                                const totals = filtered.reduce((acc, l) => {
                                    const rimFga = parseFloat(l.RIM_FGA) || parseFloat(l.FGA_PAINT) || 0;
                                    const rimFgm = parseFloat(l.RIM_FGM) || parseFloat(l.FGM_PAINT) || 0;
                                    const tpa = parseFloat(l['3PA']) || 0;
                                    const tpm = parseFloat(l['3PM']) || 0;
                                    const fga = parseFloat(l.FGA) || 0;
                                    const fgm = parseFloat(l.FGM) || 0;
                                    const twoFga = fga - tpa;
                                    const twoFgm = fgm - tpm;
                                    const actualRimFga = rimFga || Math.round(twoFga * 0.6);
                                    const actualRimFgm = rimFgm || Math.round(twoFgm * 0.65);
                                    const midFga = Math.max(0, twoFga - actualRimFga);
                                    const midFgm = Math.max(0, twoFgm - actualRimFgm);
                                    
                                    acc.rimFga += actualRimFga; acc.rimFgm += actualRimFgm;
                                    acc.midFga += midFga; acc.midFgm += midFgm;
                                    acc.tpa += tpa; acc.tpm += tpm;
                                    const lFga = parseFloat(l.FGA) || 0, lOreb = parseFloat(l.OREB) || 0, lTov = parseFloat(l.TOV) || 0, lFta = parseFloat(l.FTA) || 0;
                                    const lFgaV = parseFloat(l.FGA_VS) || 0, lOrebV = parseFloat(l.OREB_VS) || 0, lTovV = parseFloat(l.TOV_VS) || 0, lFtaV = parseFloat(l.FTA_VS) || 0;
                                    acc.poss += calcPoss(lFga, lOreb, lTov, lFta) + calcPoss(lFgaV, lOrebV, lTovV, lFtaV);
                                    acc.lineups++;
                                    return acc;
                                }, { rimFga: 0, rimFgm: 0, midFga: 0, midFgm: 0, tpa: 0, tpm: 0, poss: 0, lineups: 0 });
                                
                                const totalFga = totals.rimFga + totals.midFga + totals.tpa;
                                return {
                                    team: teamName,
                                    totals,
                                    totalFga,
                                    rimPct: totals.rimFga > 0 ? (totals.rimFgm / totals.rimFga) * 100 : 0,
                                    rimFreq: totalFga > 0 ? (totals.rimFga / totalFga) * 100 : 0,
                                    midPct: totals.midFga > 0 ? (totals.midFgm / totals.midFga) * 100 : 0,
                                    midFreq: totalFga > 0 ? (totals.midFga / totalFga) * 100 : 0,
                                    threePct: totals.tpa > 0 ? (totals.tpm / totals.tpa) * 100 : 0,
                                    threeFreq: totalFga > 0 ? (totals.tpa / totalFga) * 100 : 0
                                };
                            };
                            
                            // Get teams to process
                            const teamsToProcess = exportShotTeamMode === 'all' ? teams : [exportShotTeam];
                            const shotDataList = teamsToProcess.map(t => calcShotData(t)).filter(d => d.totalFga > 0);
                            
                            // Render shot card for a team
                            const renderShotCard = (shot, showTeamName) => e('div', { key: shot.team, className: 'export-shot-card' },
                                // Team info
                                e('div', { style: { textAlign: 'center', marginBottom: '20px' }},
                                    showTeamName && e('div', { style: { fontSize: '18px', fontWeight: '700', color: '#60a5fa', marginBottom: '4px' }}, shot.team),
                                    e('div', { style: { fontSize: '11px', color: '#64748b' }}, 
                                        shot.totals.lineups + ' lineups | ' + Math.round(shot.totalFga) + ' FGA'
                                    )
                                ),
                                
                                // Shot distribution bar
                                e('div', { className: 'export-shot-bar', style: { marginBottom: '16px' }},
                                    shot.rimFreq > 0 && e('div', { className: 'export-shot-segment rim', style: { width: shot.rimFreq + '%' }},
                                        e('div', { className: 'export-shot-segment-value' }, shot.rimFreq.toFixed(0) + '%'),
                                        e('div', { className: 'export-shot-segment-label' }, 'Rim')
                                    ),
                                    shot.midFreq > 0 && e('div', { className: 'export-shot-segment mid', style: { width: shot.midFreq + '%' }},
                                        e('div', { className: 'export-shot-segment-value' }, shot.midFreq.toFixed(0) + '%'),
                                        e('div', { className: 'export-shot-segment-label' }, 'Mid')
                                    ),
                                    shot.threeFreq > 0 && e('div', { className: 'export-shot-segment three', style: { width: shot.threeFreq + '%' }},
                                        e('div', { className: 'export-shot-segment-value' }, shot.threeFreq.toFixed(0) + '%'),
                                        e('div', { className: 'export-shot-segment-label' }, '3PT')
                                    )
                                ),
                                
                                // Detailed stats
                                e('div', { className: 'export-shot-details', style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px' }},
                                    e('div', { style: { textAlign: 'center', padding: '10px', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '8px' }},
                                        e('div', { style: { fontSize: '18px', fontWeight: '700', color: '#ef4444' }}, shot.rimPct.toFixed(1) + '%'),
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Rim FG%')
                                    ),
                                    e('div', { style: { textAlign: 'center', padding: '10px', background: 'rgba(249, 115, 22, 0.1)', borderRadius: '8px' }},
                                        e('div', { style: { fontSize: '18px', fontWeight: '700', color: '#f97316' }}, shot.midPct.toFixed(1) + '%'),
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, 'Mid FG%')
                                    ),
                                    e('div', { style: { textAlign: 'center', padding: '10px', background: 'rgba(59, 130, 246, 0.1)', borderRadius: '8px' }},
                                        e('div', { style: { fontSize: '18px', fontWeight: '700', color: '#3b82f6' }}, shot.threePct.toFixed(1) + '%'),
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8' }}, '3PT FG%')
                                    )
                                )
                            );
                            
                            return e('div', null,
                                // Summary header
                                e('div', { style: { textAlign: 'center', marginBottom: '24px' }},
                                    e('div', { style: { fontSize: '20px', fontWeight: '700', color: '#60a5fa' }}, 
                                        exportShotTeamMode === 'all' ? 'All Teams Shot Distribution' : exportShotTeam
                                    ),
                                    selectedPlayers.length > 0 && e('div', { style: { fontSize: '12px', color: '#94a3b8', marginTop: '4px' }}, 
                                        'Lineup: ' + selectedPlayers.join(' • ')
                                    ),
                                    exportShotDateMode !== 'all' && e('div', { style: { fontSize: '11px', color: '#64748b', marginTop: '4px' }}, 
                                        exportShotDateMode === 'gamerange' ? 'Games ' + exportShotGameRange.start + '-' + exportShotGameRange.end : 'Date filtered'
                                    )
                                ),
                                
                                // Shot cards
                                exportShotTeamMode === 'all' 
                                    ? e('div', { className: 'export-shot-cards' }, shotDataList.map(shot => renderShotCard(shot, true)))
                                    : shotDataList.length > 0 && renderShotCard(shotDataList[0], false)
                            );
                        })(),
                        
                        // Shot Distribution Legend
                        exportMode === 'shotdist' && exportShowLegend && e('div', { style: { marginTop: '16px', padding: '10px 14px', background: 'rgba(15, 23, 42, 0.8)', borderRadius: '8px', border: '1px solid #334155' }},
                            e('div', { style: { fontSize: '10px', color: '#64748b', marginBottom: '6px', fontWeight: '600' }}, '📊 SHOT DISTRIBUTION LEGEND'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px', fontSize: '9px' }},
                                e('div', { style: { padding: '6px 8px', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '4px', borderLeft: '2px solid #ef4444' }},
                                    e('div', { style: { color: '#f87171', fontWeight: '600', marginBottom: '2px' }}, '🎯 Rim'),
                                    e('div', { style: { color: '#94a3b8' }}, 'Shots at rim (0-4 ft)'),
                                    e('div', { style: { color: '#94a3b8' }}, 'Vol = attempts/100 poss')
                                ),
                                e('div', { style: { padding: '6px 8px', background: 'rgba(251, 191, 36, 0.1)', borderRadius: '4px', borderLeft: '2px solid #fbbf24' }},
                                    e('div', { style: { color: '#fbbf24', fontWeight: '600', marginBottom: '2px' }}, '🎯 Mid'),
                                    e('div', { style: { color: '#94a3b8' }}, 'Mid-range (4ft to 3PT)'),
                                    e('div', { style: { color: '#94a3b8' }}, 'Vol = attempts/100 poss')
                                ),
                                e('div', { style: { padding: '6px 8px', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '4px', borderLeft: '2px solid #22c55a' }},
                                    e('div', { style: { color: '#4ade80', fontWeight: '600', marginBottom: '2px' }}, '🎯 3PT'),
                                    e('div', { style: { color: '#94a3b8' }}, 'Three-pointers'),
                                    e('div', { style: { color: '#94a3b8' }}, 'Vol = attempts/100 poss')
                                )
                            ),
                            e('div', { style: { marginTop: '6px', fontSize: '9px', color: '#64748b', borderTop: '1px solid #334155', paddingTop: '6px' }},
                                '📊 FG% shown for each zone. Bar width represents shot frequency distribution.'
                            )
                        ),
                        
                        // Best Lineups Export - V5.4 Enhanced with player images, four factors, all teams mode
                        // V5.22: Added BPM for each player in lineup
                        exportMode === 'lineups' && (() => {
                            // Helper to parse lineup players
                            // V6.1: Apply merge rules when parsing lineup players
                            const parseLineupPlayers = (l) => {
                                if (!l.Lineup) return [];
                                return l.Lineup.split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                            };

                            // Helper to calculate possession using Dean Oliver formula
                            const calcPoss = (fga, oreb, tov, fta) => {
                                return (fga || 0) - (oreb || 0) + (tov || 0) + 0.44 * (fta || 0);
                            };

                            // V5.22: BPM 2.0 coefficients for player BPM calculation
                            const BPM_COEFFS = {
                                a: 0.123391, b: 0.119597, c: -0.151287, d: 1.255644,
                                e: 0.531838, f: -0.305868, g: 0.921292, h: 0.711217,
                                i: 0.017022, j: 0.297639, k: 0.213485, l: 0.725930
                            };
                            const OBPM_COEFFS = {
                                a: 0.064448, b: 0.211125, c: -0.107545, d: 0.346513,
                                e: -0.052476, f: -0.041787, g: 0.932965, h: 0.687359,
                                i: 0.007952, j: 0.374706, k: -0.181891, l: 0.239862
                            };
                            const lgAvg3PAr = 0.40;

                            // V5.22: Helper to get BPM color based on value
                            const getBpmColor = (bpm) => {
                                if (bpm === null || bpm === undefined) return '#64748b';
                                if (bpm >= 5) return '#22c55e';
                                if (bpm >= 2) return '#4ade80';
                                if (bpm >= 0) return '#86efac';
                                if (bpm >= -2) return '#fca5a5';
                                if (bpm >= -5) return '#f87171';
                                return '#ef4444';
                            };

                            // V5.22: Calculate BPM for a player in a specific lineup
                            const getPlayerBpmInLineup = (playerName, lineup) => {
                                if (!playerData || playerData.length === 0) return null;

                                const normalizedLineup = lineup.Lineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',');
                                const playerNorm = normalizePlayerName(playerName);

                                // Find player's stats in this lineup from playerData
                                const playerRow = playerData.find(pd => {
                                    if (!pd.Player || normalizePlayerName(pd.Player) !== playerNorm) return false;
                                    if (lineup.Team && pd.Team !== lineup.Team) return false;
                                    const teammates = pd.Teammates || '';
                                    const fullLineup = pd.Player + ',' + teammates;
                                    const pdLineupNorm = fullLineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',');
                                    return pdLineupNorm === normalizedLineup;
                                });

                                if (!playerRow) return null;

                                // Lineup totals for percentage denominators
                                const lt = {
                                    poss: parseFloat(lineup.POSS) || calcPoss(parseFloat(lineup.FGA)||0, parseFloat(lineup.OREB)||0, parseFloat(lineup.TOV)||0, parseFloat(lineup.FTA)||0),
                                    possV: calcPoss(parseFloat(lineup.FGA_VS)||0, parseFloat(lineup.OREB_VS)||0, parseFloat(lineup.TOV_VS)||0, parseFloat(lineup.FTA_VS)||0),
                                    oreb: parseFloat(lineup.OREB) || 0,
                                    dreb: parseFloat(lineup.DREB) || 0,
                                    orebV: parseFloat(lineup.OREB_VS) || 0,
                                    drebV: parseFloat(lineup.DREB_VS) || 0,
                                    fga: parseFloat(lineup.FGA) || 0,
                                    fgm: parseFloat(lineup.FGM) || 0,
                                    fta: parseFloat(lineup.FTA) || 0,
                                    fgaV: parseFloat(lineup.FGA_VS) || 0,
                                    mins: (parseFloat(lineup.TOTAL_TIME) || 0) / 60
                                };

                                if (lt.poss < 1) return null;

                                // Get all teammates' FGM for AST% calculation
                                const allPlayersInLineup = playerData.filter(pd => {
                                    if (lineup.Team && pd.Team !== lineup.Team) return false;
                                    const teammates = pd.Teammates || '';
                                    const fullLineup = pd.Player + ',' + teammates;
                                    const pdLineupNorm = fullLineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',');
                                    return pdLineupNorm === normalizedLineup;
                                });
                                const teamFgm = allPlayersInLineup.reduce((sum, pd) => sum + (parseFloat(pd.FGM) || 0), 0);

                                // Player stats
                                const pStats = {
                                    pts: parseFloat(playerRow.PTS) || 0,
                                    fga: parseFloat(playerRow.FGA) || 0,
                                    fgm: parseFloat(playerRow.FGM) || 0,
                                    tpa: parseFloat(playerRow['3PA']) || 0,
                                    fta: parseFloat(playerRow.FTA) || 0,
                                    oreb: parseFloat(playerRow.OREB) || 0,
                                    dreb: parseFloat(playerRow.DREB) || 0,
                                    ast: parseFloat(playerRow.AST) || 0,
                                    stl: parseFloat(playerRow.STL) || 0,
                                    blk: parseFloat(playerRow.BLK) || 0,
                                    tov: parseFloat(playerRow.TOV) || 0,
                                    mins: parseFloat(playerRow.Minutes) || (parseFloat(playerRow.TOTAL_TIME) || 0) / 60,
                                    gp: 1
                                };

                                // Calculate percentage stats
                                const reMpg = pStats.mins / (pStats.gp + 2);
                                const orebOpps = lt.oreb + lt.drebV;
                                const orbPct = orebOpps > 0 ? (pStats.oreb / orebOpps) * 100 : 0;
                                const drebOpps = lt.dreb + lt.orebV;
                                const drbPct = drebOpps > 0 ? (pStats.dreb / drebOpps) * 100 : 0;
                                const trbPct = (orebOpps + drebOpps) > 0 ? ((pStats.oreb + pStats.dreb) / (orebOpps + drebOpps)) * 100 : 0;
                                const stlPct = lt.possV > 0 ? (pStats.stl / lt.possV) * 100 : 0;
                                const opp2pa = lt.fgaV * 0.6;
                                const blkPct = opp2pa > 0 ? (pStats.blk / opp2pa) * 100 : 0;
                                const tmFgmExcludingSelf = teamFgm - pStats.fgm;
                                const astPct = tmFgmExcludingSelf > 0 ? (pStats.ast / tmFgmExcludingSelf) * 100 : 0;
                                const playerPossUsed = pStats.fga + 0.44 * pStats.fta + pStats.tov;
                                const usgPct = lt.poss > 0 ? (playerPossUsed / lt.poss) * 100 : 0;
                                const tovPct = playerPossUsed > 0 ? (pStats.tov / playerPossUsed) * 100 : 0;
                                const tsa = 2 * (pStats.fga + 0.44 * pStats.fta);
                                const tsPct = tsa > 0 ? (pStats.pts / tsa) * 100 : 0;
                                const teamTsa = 2 * (lt.fga + 0.44 * lt.fta);
                                const teamTsPct = teamTsa > 0 ? ((lt.fgm * 2 + (lt.fga > 0 ? (lt.fgm / lt.fga) * lt.fga * 0.5 : 0)) / teamTsa) * 100 : 50;
                                const threePAr = pStats.fga > 0 ? pStats.tpa / pStats.fga : 0;

                                // BPM formula
                                const term1 = BPM_COEFFS.a * reMpg;
                                const term2 = BPM_COEFFS.b * orbPct;
                                const term3 = BPM_COEFFS.c * drbPct;
                                const term4 = BPM_COEFFS.d * stlPct;
                                const term5 = BPM_COEFFS.e * blkPct;
                                const term6 = BPM_COEFFS.f * astPct;
                                const term7 = -BPM_COEFFS.g * (usgPct / 100) * tovPct;
                                const scoringTerm = BPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                                    (2 * (tsPct - teamTsPct) / 100 + BPM_COEFFS.i * astPct / 100 + BPM_COEFFS.j * (threePAr - lgAvg3PAr) - BPM_COEFFS.k);
                                const term9 = BPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;
                                const bpm = term1 + term2 + term3 + term4 + term5 + term6 + term7 + scoringTerm + term9;

                                return bpm;
                            };
                            
                            // V5.4: Date/game range filter helper
                            const matchesDateFilter = (l, teamName) => {
                                if (exportLineupDateMode === 'all') return true;
                                
                                let dateStr = l.Date || l.GameDate || l.date || l.game_date || '';
                                let gameId = l.GameID || l.game_id || l.Game || '';
                                
                                if (!dateStr && gameId && gameDatesLookup.has(gameId)) {
                                    dateStr = gameDatesLookup.get(gameId);
                                }
                                
                                if (exportLineupDateMode === 'gamerange') {
                                    if (!teamName || !teamGameOrder.has(teamName)) return true;
                                    const teamGames = teamGameOrder.get(teamName);
                                    let gameNum = -1;
                                    if (gameId) {
                                        const gameInfo = teamGames.find(g => g.game_id === gameId);
                                        if (gameInfo) gameNum = gameInfo.gameNum;
                                    } else if (dateStr) {
                                        const gameInfo = teamGames.find(g => g.game_date === dateStr);
                                        if (gameInfo) gameNum = gameInfo.gameNum;
                                    }
                                    if (gameNum === -1) return true;
                                    return gameNum >= exportLineupGameRange.start && gameNum <= exportLineupGameRange.end;
                                }
                                
                                if (!dateStr) return true;
                                const lineupDate = new Date(dateStr);
                                if (isNaN(lineupDate.getTime())) return true;
                                
                                if (exportLineupDateMode === 'after' && exportLineupDateAfter) {
                                    return lineupDate >= new Date(exportLineupDateAfter);
                                }
                                if (exportLineupDateMode === 'before' && exportLineupDateBefore) {
                                    return lineupDate <= new Date(exportLineupDateBefore);
                                }
                                if (exportLineupDateMode === 'range' && exportLineupDateAfter && exportLineupDateBefore) {
                                    return lineupDate >= new Date(exportLineupDateAfter) && lineupDate <= new Date(exportLineupDateBefore);
                                }
                                return true;
                            };
                            
                            // Get lineups based on team mode
                            const teamsToProcess = exportLineupTeamMode === 'all' ? teams : [exportLineupTeam];
                            
                            const allLineups = teamsToProcess.flatMap(teamName => 
                                lineupData
                                    .filter(l => {
                                        if (l.Team !== teamName) return false;
                                        if (!matchesDateFilter(l, teamName)) return false;
                                        const fga = parseFloat(l.FGA) || 0, oreb = parseFloat(l.OREB) || 0, tov = parseFloat(l.TOV) || 0, fta = parseFloat(l.FTA) || 0;
                                        const fgaV = parseFloat(l.FGA_VS) || 0, orebV = parseFloat(l.OREB_VS) || 0, tovV = parseFloat(l.TOV_VS) || 0, ftaV = parseFloat(l.FTA_VS) || 0;
                                        const poss = calcPoss(fga, oreb, tov, fta) + calcPoss(fgaV, orebV, tovV, ftaV);
                                        return poss >= exportLineupMinPoss;
                                    })
                                    .map(l => {
                                        const fga = parseFloat(l.FGA) || 0, oreb = parseFloat(l.OREB) || 0, tov = parseFloat(l.TOV) || 0, fta = parseFloat(l.FTA) || 0;
                                        const fgaV = parseFloat(l.FGA_VS) || 0, orebV = parseFloat(l.OREB_VS) || 0, tovV = parseFloat(l.TOV_VS) || 0, ftaV = parseFloat(l.FTA_VS) || 0;
                                        const fgm = parseFloat(l.FGM) || 0, tpm = parseFloat(l['3PM']) || 0, ftm = parseFloat(l.FTM) || 0;
                                        const fgmV = parseFloat(l.FGM_VS) || 0, tpmV = parseFloat(l['3PM_VS']) || 0, ftmV = parseFloat(l.FTM_VS) || 0;
                                        const dreb = parseFloat(l.DREB) || 0, drebV = parseFloat(l.DREB_VS) || 0;
                                        const tpa = parseFloat(l['3PA']) || 0, tpaV = parseFloat(l['3PA_VS']) || 0;
                                        const poss = calcPoss(fga, oreb, tov, fta);
                                        const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                                        const combPoss = poss + possV;
                                        const pts = fgm * 2 + tpm + ftm;
                                        const ptsV = fgmV * 2 + tpmV + ftmV;
                                        
                                        // Apply luck adjustment
                                        const leagueAvg3Pct = 36;
                                        const offLuckDelta = tpm - (tpa * leagueAvg3Pct / 100);
                                        const defLuckDelta = tpmV - (tpaV * leagueAvg3Pct / 100);
                                        const offAdj3pm = offLuckDelta * (exportLineupOffLuckAdj / 100);
                                        const defAdj3pm = defLuckDelta * (exportLineupDefLuckAdj / 100);
                                        const adjPts = pts - offAdj3pm * 3;
                                        const adjPtsV = ptsV - defAdj3pm * 3;
                                        
                                        const offRtg = poss > 0 ? (adjPts / poss) * 100 : 0;
                                        const defRtg = possV > 0 ? (adjPtsV / possV) * 100 : 0;
                                        const netRtg = offRtg - defRtg;
                                        
                                        // V5.12: Use Basketball Reference TOV% formula for consistency
                                        const offTovDenom = fga + 0.44 * fta + tov;
                                        const defTovDenom = fgaV + 0.44 * ftaV + tovV;
                                        
                                        // Four factors - offense (with luck adjustment)
                                        const adj3pm = Math.max(0, tpm - offAdj3pm);
                                        const adjFgm = fgm - offAdj3pm;
                                        const offEfg = fga > 0 ? ((adjFgm + 0.5 * adj3pm) / fga) * 100 : 0;
                                        const offTov = offTovDenom > 0 ? (tov / offTovDenom) * 100 : 0;
                                        const offOreb = (oreb + drebV) > 0 ? (oreb / (oreb + drebV)) * 100 : 0;
                                        const offFtR = fga > 0 ? (fta / fga) * 100 : 0;
                                        
                                        // Four factors - defense (with luck adjustment)
                                        const adj3pmV = Math.max(0, tpmV - defAdj3pm);
                                        const adjFgmV = fgmV - defAdj3pm;
                                        const defEfg = fgaV > 0 ? ((adjFgmV + 0.5 * adj3pmV) / fgaV) * 100 : 0;
                                        const defTov = defTovDenom > 0 ? (tovV / defTovDenom) * 100 : 0;
                                        const defOreb = (orebV + dreb) > 0 ? (orebV / (orebV + dreb)) * 100 : 0;
                                        const defFtR = fgaV > 0 ? (ftaV / fgaV) * 100 : 0;
                                        
                                        // Minutes - try multiple fields (TOTAL_TIME is in seconds)
                                        const totalTimeSeconds = parseFloat(l.TOTAL_TIME) || parseFloat(l.TotalTime) || parseFloat(l.total_time) || 0;
                                        const mins = totalTimeSeconds > 0 ? totalTimeSeconds / 60 : 
                                            (parseFloat(l.MIN) || parseFloat(l.Time) / 60 || parseFloat(l.Minutes) || parseFloat(l.Mins) || 
                                            (combPoss > 0 ? combPoss / 2 : 0)); // Fallback: estimate mins from poss
                                        const players = parseLineupPlayers(l);
                                        return { 
                                            ...l, team: l.Team, poss: combPoss, mins, offRtg, defRtg, netRtg, 
                                            offEfg, offTov, offOreb, offFtR,
                                            defEfg, defTov, defOreb, defFtR,
                                            players 
                                        };
                                    })
                            );
                            
                            // Sort based on selected criteria
                            const sorted = [...allLineups].sort((a, b) => {
                                if (exportLineupSortBy === 'netRtg') return b.netRtg - a.netRtg;
                                if (exportLineupSortBy === 'offRtg') return b.offRtg - a.offRtg;
                                if (exportLineupSortBy === 'defRtg') return a.defRtg - b.defRtg; // Lower is better
                                return b.netRtg - a.netRtg;
                            }).slice(0, exportTopN);
                            
                            // Handle player image upload
                            const handleLineupPlayerImageUpload = (playerName, ev) => {
                                const file = ev.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = (e) => {
                                        setExportLineupPlayerImages(prev => ({ ...prev, [playerName]: e.target.result }));
                                    };
                                    reader.readAsDataURL(file);
                                }
                            };
                            
                            const sortLabels = { netRtg: 'Net Rating', offRtg: 'Offensive Rating', defRtg: 'Defensive Rating (Low)' };
                            
                            return e('div', null,
                                // Luck adjustment indicator (only show when active)
                                (exportLineupOffLuckAdj > 0 || exportLineupDefLuckAdj > 0) && e('div', { style: { 
                                    textAlign: 'center', 
                                    marginBottom: '12px', 
                                    padding: '8px 16px',
                                    background: 'rgba(251, 191, 36, 0.1)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(251, 191, 36, 0.3)'
                                }},
                                    e('span', { style: { fontSize: '14px', color: '#fbbf24', fontWeight: '600' }}, 
                                        '🎲 3PT Luck Adjusted — ',
                                        exportLineupOffLuckAdj > 0 && e('span', { style: { color: '#4ade80' }}, 'Off ' + exportLineupOffLuckAdj + '%'),
                                        exportLineupOffLuckAdj > 0 && exportLineupDefLuckAdj > 0 && ' | ',
                                        exportLineupDefLuckAdj > 0 && e('span', { style: { color: '#f87171' }}, 'Def ' + exportLineupDefLuckAdj + '%'),
                                        ' (regressed toward 36% league avg)'
                                    )
                                ),
                                // Summary header
                                e('div', { style: { textAlign: 'center', marginBottom: '24px' }},
                                    e('div', { style: { fontSize: '20px', fontWeight: '700', color: '#60a5fa' }}, 
                                        exportLineupTeamMode === 'all' ? 'All Teams' : exportLineupTeam
                                    ),
                                    e('div', { style: { fontSize: '12px', color: '#94a3b8', marginTop: '4px' }}, 
                                        sorted.length + ' lineups | Min ' + exportLineupMinPoss + ' poss | Sorted by ' + sortLabels[exportLineupSortBy]
                                    ),
                                    exportLineupDateMode !== 'all' && e('div', { style: { fontSize: '11px', color: '#64748b', marginTop: '4px' }}, 
                                        exportLineupDateMode === 'gamerange' ? 'Games ' + exportLineupGameRange.start + '-' + exportLineupGameRange.end : 'Date filtered'
                                    )
                                ),
                                
                                // Lineup cards
                                e('div', { className: 'export-lineup-cards' },
                                    sorted.map((l, i) => e('div', { key: i, className: 'export-lineup-card-v2' },
                                        // Rank badge
                                        e('div', { className: 'export-lineup-rank-badge' }, i + 1),
                                        
                                        // Team badge (for all teams mode)
                                        exportLineupTeamMode === 'all' && e('div', { className: 'export-lineup-team-badge' }, l.team),
                                        
                                        // Players row - focal point with photos and BPM
                                        e('div', { className: 'export-lineup-players-row' },
                                            (l.players || []).filter(Boolean).map((p, j) => {
                                                const playerBpm = getPlayerBpmInLineup(p, l);
                                                return e('div', { key: j, className: 'export-lineup-player-card' },
                                                    e('div', {
                                                        className: 'export-lineup-player-photo',
                                                        onClick: () => document.getElementById('lineup-player-img-' + i + '-' + j).click()
                                                    },
                                                        exportLineupPlayerImages[p]
                                                            ? e('img', { src: exportLineupPlayerImages[p], alt: p })
                                                            : getInitials(p),
                                                        e('input', {
                                                            type: 'file',
                                                            id: 'lineup-player-img-' + i + '-' + j,
                                                            accept: 'image/*',
                                                            style: { display: 'none' },
                                                            onChange: (ev) => handleLineupPlayerImageUpload(p, ev)
                                                        })
                                                    ),
                                                    e('div', { className: 'export-lineup-player-name-v2' }, getDisplayName(p, true)),
                                                    // V5.22: BPM badge for each player
                                                    playerBpm !== null ? e('div', {
                                                        style: {
                                                            fontSize: '9px',
                                                            fontWeight: '700',
                                                            color: getBpmColor(playerBpm),
                                                            marginTop: '2px',
                                                            padding: '2px 6px',
                                                            borderRadius: '4px',
                                                            background: 'rgba(0,0,0,0.3)'
                                                        }
                                                    }, (playerBpm >= 0 ? '+' : '') + playerBpm.toFixed(1) + ' BPM') : null
                                                );
                                            })
                                        ),
                                        
                                        // Main stats row
                                        e('div', { className: 'export-lineup-stats-row' },
                                            e('div', { className: 'export-lineup-stat-box net' },
                                                e('div', { className: 'export-lineup-stat-value-v2', style: { color: l.netRtg >= 0 ? '#4ade80' : '#f87171' }}, 
                                                    (l.netRtg >= 0 ? '+' : '') + l.netRtg.toFixed(1)
                                                ),
                                                e('div', { className: 'export-lineup-stat-label-v2' }, 'Net Rtg')
                                            ),
                                            e('div', { className: 'export-lineup-stat-box off' },
                                                e('div', { className: 'export-lineup-stat-value-v2', style: { color: '#4ade80' }}, l.offRtg.toFixed(1)),
                                                e('div', { className: 'export-lineup-stat-label-v2' }, 'Off Rtg')
                                            ),
                                            e('div', { className: 'export-lineup-stat-box def' },
                                                e('div', { className: 'export-lineup-stat-value-v2', style: { color: '#f87171' }}, l.defRtg.toFixed(1)),
                                                e('div', { className: 'export-lineup-stat-label-v2' }, 'Def Rtg')
                                            )
                                        ),
                                        
                                        // Four Factors row - V5.5 color-coded like Four Factors export
                                        e('div', { className: 'export-lineup-ff-row' },
                                            e('div', { className: 'export-lineup-ff-section offense' },
                                                e('div', { className: 'export-lineup-ff-title' }, '⚔️ Offense'),
                                                e('div', { className: 'export-lineup-ff-stats-v2' },
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + (l.offEfg >= 56 ? 'perf-excellent' : l.offEfg >= 53 ? 'perf-good' : l.offEfg >= 50 ? 'perf-average' : l.offEfg >= 47 ? 'perf-below' : 'perf-poor')
                                                    },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, 'eFG%'),
                                                            e('div', { className: 'export-ff-stat-value' }, l.offEfg.toFixed(1))
                                                        )
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + (l.offTov <= 11 ? 'perf-excellent' : l.offTov <= 13 ? 'perf-good' : l.offTov <= 15 ? 'perf-average' : l.offTov <= 17 ? 'perf-below' : 'perf-poor')
                                                    },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, 'TOV%'),
                                                            e('div', { className: 'export-ff-stat-value' }, l.offTov.toFixed(1))
                                                        )
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + (l.offOreb >= 30 ? 'perf-excellent' : l.offOreb >= 27 ? 'perf-good' : l.offOreb >= 24 ? 'perf-average' : l.offOreb >= 21 ? 'perf-below' : 'perf-poor')
                                                    },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, 'OREB%'),
                                                            e('div', { className: 'export-ff-stat-value' }, l.offOreb.toFixed(1))
                                                        )
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + (l.offFtR >= 32 ? 'perf-excellent' : l.offFtR >= 28 ? 'perf-good' : l.offFtR >= 24 ? 'perf-average' : l.offFtR >= 20 ? 'perf-below' : 'perf-poor')
                                                    },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, 'FT Rate'),
                                                            e('div', { className: 'export-ff-stat-value' }, l.offFtR.toFixed(1))
                                                        )
                                                    )
                                                )
                                            ),
                                            e('div', { className: 'export-lineup-ff-section defense' },
                                                e('div', { className: 'export-lineup-ff-title' }, '🛡️ Defense'),
                                                e('div', { className: 'export-lineup-ff-stats-v2' },
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + (l.defEfg <= 47 ? 'perf-excellent' : l.defEfg <= 50 ? 'perf-good' : l.defEfg <= 53 ? 'perf-average' : l.defEfg <= 56 ? 'perf-below' : 'perf-poor')
                                                    },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, 'Opp eFG%'),
                                                            e('div', { className: 'export-ff-stat-value' }, l.defEfg.toFixed(1))
                                                        )
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + (l.defTov >= 17 ? 'perf-excellent' : l.defTov >= 15 ? 'perf-good' : l.defTov >= 13 ? 'perf-average' : l.defTov >= 11 ? 'perf-below' : 'perf-poor')
                                                    },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, 'Forced TO%'),
                                                            e('div', { className: 'export-ff-stat-value' }, l.defTov.toFixed(1))
                                                        )
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + (l.defOreb <= 21 ? 'perf-excellent' : l.defOreb <= 24 ? 'perf-good' : l.defOreb <= 27 ? 'perf-average' : l.defOreb <= 30 ? 'perf-below' : 'perf-poor')
                                                    },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, 'Opp OREB%'),
                                                            e('div', { className: 'export-ff-stat-value' }, l.defOreb.toFixed(1))
                                                        )
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + (l.defFtR <= 20 ? 'perf-excellent' : l.defFtR <= 24 ? 'perf-good' : l.defFtR <= 28 ? 'perf-average' : l.defFtR <= 32 ? 'perf-below' : 'perf-poor')
                                                    },
                                                        e('div', null,
                                                            e('div', { className: 'export-ff-stat-label' }, 'Opp FT Rate'),
                                                            e('div', { className: 'export-ff-stat-value' }, l.defFtR.toFixed(1))
                                                        )
                                                    )
                                                )
                                            )
                                        ),
                                        
                                        // Metadata row - V5.7: Minutes as primary, poss as secondary
                                        e('div', { className: 'export-lineup-meta-row' },
                                            e('div', { className: 'export-lineup-meta' }, e('strong', null, l.mins > 0 ? l.mins.toFixed(1) : '~' + Math.round(l.poss / 2)), ' min'),
                                            e('div', { className: 'export-lineup-meta' }, e('strong', null, Math.round(l.poss)), ' poss')
                                        ),
                                        // Luck adjustment indicator on card
                                        (exportLineupOffLuckAdj > 0 || exportLineupDefLuckAdj > 0) && e('div', { 
                                            style: { 
                                                marginTop: '6px', 
                                                fontSize: '8px', 
                                                color: '#fbbf24', 
                                                textAlign: 'center',
                                                padding: '3px 6px',
                                                background: 'rgba(251, 191, 36, 0.1)',
                                                borderRadius: '3px'
                                            }
                                        }, 
                                            '🎲 Luck Adj: ',
                                            exportLineupOffLuckAdj > 0 && e('span', { style: { color: '#4ade80' }}, 'O' + exportLineupOffLuckAdj + '%'),
                                            exportLineupOffLuckAdj > 0 && exportLineupDefLuckAdj > 0 && ' ',
                                            exportLineupDefLuckAdj > 0 && e('span', { style: { color: '#f87171' }}, 'D' + exportLineupDefLuckAdj + '%')
                                        )
                                    ))
                                )
                            );
                        })(),
                        
                        // Lineups Legend
                        exportMode === 'lineups' && exportShowLegend && e('div', { style: { marginTop: '16px', padding: '10px 14px', background: 'rgba(15, 23, 42, 0.8)', borderRadius: '8px', border: '1px solid #334155' }},
                            e('div', { style: { fontSize: '10px', color: '#64748b', marginBottom: '6px', fontWeight: '600' }}, '📊 LINEUP LEGEND'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '8px', fontSize: '9px' }},
                                e('div', { style: { padding: '6px 8px', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '4px', borderLeft: '2px solid #22c55a' }},
                                    e('div', { style: { color: '#4ade80', fontWeight: '600', marginBottom: '2px' }}, '📈 Ratings'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'Net'), ' — Points scored - allowed per 100 poss'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'ORtg'), ' — Points scored per 100 possessions'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'DRtg'), ' — Points allowed per 100 poss')
                                ),
                                e('div', { style: { padding: '6px 8px', background: 'rgba(59, 130, 246, 0.1)', borderRadius: '4px', borderLeft: '2px solid #3b82f6' }},
                                    e('div', { style: { color: '#60a5fa', fontWeight: '600', marginBottom: '2px' }}, '⏱️ Sample Size'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'Poss'), ' — Total possessions played'),
                                    e('div', { style: { color: '#94a3b8' }}, e('b', null, 'Min'), ' — Total minutes played'),
                                    e('div', { style: { color: '#94a3b8' }}, '(Higher sample = more reliable)')
                                )
                            ),
                            e('div', { style: { marginTop: '6px', fontSize: '9px', color: '#64748b', borderTop: '1px solid #334155', paddingTop: '6px' }},
                                '⚠️ Small sample lineups (<50 poss) may have high variance. Min poss filter: ' + exportLineupMinPoss
                            )
                        ),
                        
                        // WOWY Export - V5.4 Enhanced with best combinations mode, player images, four factors
                        exportMode === 'wowy' && (() => {
                            const currentTeam = exportWowyTeam || exportTeam || (teams.length > 0 ? teams[0] : '');
                            
                            // Helper to parse lineup players
                            // V6.1: Apply merge rules when parsing lineup players
                            const parseLineupPlayers = (l) => {
                                if (!l.Lineup) return [];
                                return l.Lineup.split(',').map(p => applyGlobalPlayerMerge(p.trim())).filter(Boolean);
                            };
                            
                            // Helper to check if player is in lineup
                            const playerInLineup = (lineup, player) => {
                                const lineupPlayers = parseLineupPlayers(lineup);
                                const lineupNorm = lineupPlayers.map(p => normalizePlayerName(p));
                                return lineupNorm.includes(normalizePlayerName(player));
                            };
                            
                            // Helper to calculate possession
                            const calcPoss = (fga, oreb, tov, fta) => {
                                return (fga || 0) - (oreb || 0) + (tov || 0) + 0.44 * (fta || 0);
                            };
                            
                            // Date filter helper
                            const matchesDateFilter = (l) => {
                                if (exportWowyDateMode === 'all') return true;
                                let dateStr = l.Date || l.GameDate || l.date || l.game_date || '';
                                let gameId = l.GameID || l.game_id || l.Game || '';
                                if (!dateStr && gameId && gameDatesLookup.has(gameId)) {
                                    dateStr = gameDatesLookup.get(gameId);
                                }
                                if (exportWowyDateMode === 'gamerange') {
                                    if (!teamGameOrder.has(currentTeam)) return true;
                                    const teamGames = teamGameOrder.get(currentTeam);
                                    let gameNum = -1;
                                    if (gameId) {
                                        const gameInfo = teamGames.find(g => g.game_id === gameId);
                                        if (gameInfo) gameNum = gameInfo.gameNum;
                                    } else if (dateStr) {
                                        const gameInfo = teamGames.find(g => g.game_date === dateStr);
                                        if (gameInfo) gameNum = gameInfo.gameNum;
                                    }
                                    if (gameNum === -1) return true;
                                    return gameNum >= exportWowyGameRange.start && gameNum <= exportWowyGameRange.end;
                                }
                                if (!dateStr) return true;
                                const lineupDate = new Date(dateStr);
                                if (isNaN(lineupDate.getTime())) return true;
                                if (exportWowyDateMode === 'after' && exportWowyDateAfter) return lineupDate >= new Date(exportWowyDateAfter);
                                if (exportWowyDateMode === 'before' && exportWowyDateBefore) return lineupDate <= new Date(exportWowyDateBefore);
                                if (exportWowyDateMode === 'range' && exportWowyDateAfter && exportWowyDateBefore) {
                                    return lineupDate >= new Date(exportWowyDateAfter) && lineupDate <= new Date(exportWowyDateBefore);
                                }
                                return true;
                            };
                            
                            // Calculate WOWY stats with four factors and shot distribution
                            const calcWowyStats = (lineups) => {
                                const t = lineups.reduce((acc, l) => {
                                    const fga = parseFloat(l.FGA) || 0, oreb = parseFloat(l.OREB) || 0, tov = parseFloat(l.TOV) || 0, fta = parseFloat(l.FTA) || 0;
                                    const fgaV = parseFloat(l.FGA_VS) || 0, orebV = parseFloat(l.OREB_VS) || 0, tovV = parseFloat(l.TOV_VS) || 0, ftaV = parseFloat(l.FTA_VS) || 0;
                                    const fgm = parseFloat(l.FGM) || 0, tpm = parseFloat(l['3PM']) || 0, ftm = parseFloat(l.FTM) || 0;
                                    const fgmV = parseFloat(l.FGM_VS) || 0, tpmV = parseFloat(l['3PM_VS']) || 0, ftmV = parseFloat(l.FTM_VS) || 0;
                                    const dreb = parseFloat(l.DREB) || 0, drebV = parseFloat(l.DREB_VS) || 0;
                                    const poss = calcPoss(fga, oreb, tov, fta);
                                    const possV = calcPoss(fgaV, orebV, tovV, ftaV);
                                    const pts = fgm * 2 + tpm + ftm;
                                    const ptsV = fgmV * 2 + tpmV + ftmV;
                                    const mins = (parseFloat(l.TOTAL_TIME) || 0) / 60; // Convert seconds to minutes
                                    
                                    // Shot distribution data
                                    const rimAtt = parseFloat(l.RIM_ATT) || 0, rimMade = parseFloat(l.RIM_MADE) || 0;
                                    const midAtt = parseFloat(l.OTD_2PT_ATT) || 0, midMade = parseFloat(l.OTD_2PT_MADE) || 0;
                                    const threeAtt = parseFloat(l.OTD_3PT_ATT) || 0, threeMade = parseFloat(l.OTD_3PT_MADE) || 0;
                                    const rimAttV = parseFloat(l.RIM_ATT_VS) || 0, rimMadeV = parseFloat(l.RIM_MADE_VS) || 0;
                                    const midAttV = parseFloat(l.OTD_2PT_ATT_VS) || 0, midMadeV = parseFloat(l.OTD_2PT_MADE_VS) || 0;
                                    const threeAttV = parseFloat(l.OTD_3PT_ATT_VS) || 0, threeMadeV = parseFloat(l.OTD_3PT_MADE_VS) || 0;
                                    
                                    acc.poss += poss; acc.possV += possV;
                                    acc.pts += pts; acc.ptsV += ptsV;
                                    acc.mins += mins;
                                    acc.fga += fga; acc.fgm += fgm; acc.tpm += tpm; acc.tov += tov;
                                    acc.fgaV += fgaV; acc.fgmV += fgmV; acc.tpmV += tpmV; acc.tovV += tovV;
                                    acc.oreb += oreb; acc.dreb += dreb; acc.fta += fta;
                                    acc.orebV += orebV; acc.drebV += drebV; acc.ftaV += ftaV;
                                    // Shot distribution accumulation
                                    acc.rimAtt += rimAtt; acc.rimMade += rimMade;
                                    acc.midAtt += midAtt; acc.midMade += midMade;
                                    acc.threeAtt += threeAtt; acc.threeMade += threeMade;
                                    acc.rimAttV += rimAttV; acc.rimMadeV += rimMadeV;
                                    acc.midAttV += midAttV; acc.midMadeV += midMadeV;
                                    acc.threeAttV += threeAttV; acc.threeMadeV += threeMadeV;
                                    return acc;
                                }, { poss: 0, possV: 0, pts: 0, ptsV: 0, mins: 0, fga: 0, fgm: 0, tpm: 0, tov: 0, fgaV: 0, fgmV: 0, tpmV: 0, tovV: 0, oreb: 0, dreb: 0, fta: 0, orebV: 0, drebV: 0, ftaV: 0,
                                    rimAtt: 0, rimMade: 0, midAtt: 0, midMade: 0, threeAtt: 0, threeMade: 0,
                                    rimAttV: 0, rimMadeV: 0, midAttV: 0, midMadeV: 0, threeAttV: 0, threeMadeV: 0 });
                                
                                const combPoss = t.poss + t.possV;
                                const offRtg = t.poss > 0 ? (t.pts / t.poss) * 100 : 0;
                                const defRtg = t.possV > 0 ? (t.ptsV / t.possV) * 100 : 0;
                                // V5.12: Use Basketball Reference TOV% formula
                                const offTovDenom = t.fga + 0.44 * t.fta + t.tov;
                                const defTovDenom = t.fgaV + 0.44 * t.ftaV + t.tovV;
                                
                                // Shot distribution calculations
                                const totalShots = t.rimAtt + t.midAtt + t.threeAtt;
                                const totalShotsV = t.rimAttV + t.midAttV + t.threeAttV;
                                
                                return {
                                    poss: combPoss,
                                    mins: t.mins,
                                    offRtg: offRtg,
                                    defRtg: defRtg,
                                    netRtg: offRtg - defRtg,
                                    offEfg: t.fga > 0 ? ((t.fgm + 0.5 * t.tpm) / t.fga) * 100 : 0,
                                    defEfg: t.fgaV > 0 ? ((t.fgmV + 0.5 * t.tpmV) / t.fgaV) * 100 : 0,
                                    offTov: offTovDenom > 0 ? (t.tov / offTovDenom) * 100 : 0,
                                    defTov: defTovDenom > 0 ? (t.tovV / defTovDenom) * 100 : 0,
                                    offOreb: (t.oreb + t.drebV) > 0 ? (t.oreb / (t.oreb + t.drebV)) * 100 : 0,
                                    defOreb: (t.orebV + t.dreb) > 0 ? (t.orebV / (t.orebV + t.dreb)) * 100 : 0,
                                    offFtR: t.fga > 0 ? (t.fta / t.fga) * 100 : 0,
                                    defFtR: t.fgaV > 0 ? (t.ftaV / t.fgaV) * 100 : 0,
                                    // Shot distribution - offense
                                    rimPct: totalShots > 0 ? (t.rimAtt / totalShots) * 100 : 0,
                                    midPct: totalShots > 0 ? (t.midAtt / totalShots) * 100 : 0,
                                    threePct: totalShots > 0 ? (t.threeAtt / totalShots) * 100 : 0,
                                    rimFgPct: t.rimAtt > 0 ? (t.rimMade / t.rimAtt) * 100 : 0,
                                    midFgPct: t.midAtt > 0 ? (t.midMade / t.midAtt) * 100 : 0,
                                    threeFgPct: t.threeAtt > 0 ? (t.threeMade / t.threeAtt) * 100 : 0,
                                    // Shot distribution - defense
                                    rimPctV: totalShotsV > 0 ? (t.rimAttV / totalShotsV) * 100 : 0,
                                    midPctV: totalShotsV > 0 ? (t.midAttV / totalShotsV) * 100 : 0,
                                    threePctV: totalShotsV > 0 ? (t.threeAttV / totalShotsV) * 100 : 0,
                                    rimFgPctV: t.rimAttV > 0 ? (t.rimMadeV / t.rimAttV) * 100 : 0,
                                    midFgPctV: t.midAttV > 0 ? (t.midMadeV / t.midAttV) * 100 : 0,
                                    threeFgPctV: t.threeAttV > 0 ? (t.threeMadeV / t.threeAttV) * 100 : 0,
                                    // Raw totals for luck adjustment
                                    rawPoss: t.poss,
                                    rawPossV: t.possV,
                                    rawPts: t.pts,
                                    rawPtsV: t.ptsV,
                                    rawFga: t.fga,
                                    rawFgm: t.fgm,
                                    rawTpm: t.tpm,
                                    rawTpa: t.threeAtt,
                                    rawFgaV: t.fgaV,
                                    rawFgmV: t.fgmV,
                                    rawTpmV: t.tpmV,
                                    rawTpaV: t.threeAttV
                                };
                            };
                            
                            // Handle player image upload
                            const handleWowyPlayerImageUpload = (playerName, ev) => {
                                const file = ev.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = (e) => {
                                        setExportWowyPlayerImages(prev => ({ ...prev, [playerName]: e.target.result }));
                                    };
                                    reader.readAsDataURL(file);
                                }
                            };
                            
                            // BEST COMBINATIONS MODE
                            if (exportWowyMode === 'combinations') {
                                // Get all players on team
                                const teamLineups = lineupData.filter(l => l.Team === currentTeam && matchesDateFilter(l));
                                const allPlayers = [...new Set(teamLineups.flatMap(l => parseLineupPlayers(l)))].sort();
                                
                                // V5.5: Helper to get performance class for Four Factors
                                const getPerfClass = (val, stat) => {
                                    const thresholds = {
                                        offEfg: [56, 53, 50, 47], defEfg: [47, 50, 53, 56],
                                        offTov: [11, 13, 15, 17], defTov: [17, 15, 13, 11],
                                        offOreb: [30, 27, 24, 21], defOreb: [21, 24, 27, 30],
                                        offFtR: [32, 28, 24, 20], defFtR: [20, 24, 28, 32]
                                    }[stat] || [0, 0, 0, 0];
                                    const higherBetter = ['offEfg', 'offOreb', 'offFtR', 'defTov'].includes(stat);
                                    if (higherBetter) {
                                        if (val >= thresholds[0]) return 'perf-excellent';
                                        if (val >= thresholds[1]) return 'perf-good';
                                        if (val >= thresholds[2]) return 'perf-average';
                                        if (val >= thresholds[3]) return 'perf-below';
                                        return 'perf-poor';
                                    } else {
                                        if (val <= thresholds[0]) return 'perf-excellent';
                                        if (val <= thresholds[1]) return 'perf-good';
                                        if (val <= thresholds[2]) return 'perf-average';
                                        if (val <= thresholds[3]) return 'perf-below';
                                        return 'perf-poor';
                                    }
                                };
                                
                                // Helper to get FG% color based on value and zone (for text)
                                const getFgPctColor = (pct, zone) => {
                                    // Thresholds: Rim 60+/50+/40+, Mid 45+/38+/30+, 3PT 40+/35+/30+
                                    const thresholds = zone === 'rim' ? [60, 50, 40] : zone === 'mid' ? [45, 38, 30] : [40, 35, 30];
                                    if (pct >= thresholds[0]) return '#4ade80'; // Excellent - green
                                    if (pct >= thresholds[1]) return '#fbbf24'; // Good - yellow
                                    if (pct >= thresholds[2]) return '#f97316'; // Below avg - orange
                                    return '#ef4444'; // Poor - red
                                };
                                
                                // Helper to get background gradient based on FG% quality
                                const getFgPctBackground = (pct, zone) => {
                                    // Thresholds: Rim 60+/50+/40+, Mid 45+/38+/30+, 3PT 40+/35+/30+
                                    const thresholds = zone === 'rim' ? [60, 50, 40] : zone === 'mid' ? [45, 38, 30] : [40, 35, 30];
                                    if (pct >= thresholds[0]) return 'linear-gradient(180deg, #22c55e 0%, #16a34a 100%)'; // Excellent - green
                                    if (pct >= thresholds[1]) return 'linear-gradient(180deg, #eab308 0%, #ca8a04 100%)'; // Good - yellow
                                    if (pct >= thresholds[2]) return 'linear-gradient(180deg, #f97316 0%, #ea580c 100%)'; // Below avg - orange
                                    return 'linear-gradient(180deg, #ef4444 0%, #dc2626 100%)'; // Poor - red
                                };
                                
                                // Helper to apply luck adjustment to stats
                                const applyLuckAdj = (stats, offAdjPct, defAdjPct) => {
                                    if ((offAdjPct === 0 && defAdjPct === 0) || !stats.rawTpa) return stats;
                                    const leagueAvg3Pct = 36; // League average 3PT%
                                    
                                    // Offensive luck: regress 3PT% toward league average
                                    const offLuckDelta = stats.rawTpm - (stats.rawTpa * leagueAvg3Pct / 100);
                                    const offAdj3pm = offLuckDelta * (offAdjPct / 100);
                                    
                                    // Defensive luck: regress opponent 3PT% toward league average
                                    const defLuckDelta = stats.rawTpmV - (stats.rawTpaV * leagueAvg3Pct / 100);
                                    const defAdj3pm = defLuckDelta * (defAdjPct / 100);
                                    
                                    // Adjusted points
                                    const adjPts = stats.rawPts - offAdj3pm * 3;
                                    const adjPtsV = stats.rawPtsV - defAdj3pm * 3;
                                    
                                    // Adjusted ratings
                                    const adjOffRtg = stats.rawPoss > 0 ? (adjPts / stats.rawPoss) * 100 : stats.offRtg;
                                    const adjDefRtg = stats.rawPossV > 0 ? (adjPtsV / stats.rawPossV) * 100 : stats.defRtg;
                                    
                                    // Adjusted eFG%
                                    const adj3pm = Math.max(0, stats.rawTpm - offAdj3pm);
                                    const adjFgm = stats.rawFgm - offAdj3pm;
                                    const adjOffEfg = stats.rawFga > 0 ? ((adjFgm + 0.5 * adj3pm) / stats.rawFga) * 100 : stats.offEfg;
                                    
                                    const adj3pmV = Math.max(0, stats.rawTpmV - defAdj3pm);
                                    const adjFgmV = stats.rawFgmV - defAdj3pm;
                                    const adjDefEfg = stats.rawFgaV > 0 ? ((adjFgmV + 0.5 * adj3pmV) / stats.rawFgaV) * 100 : stats.defEfg;
                                    
                                    return {
                                        ...stats,
                                        offRtg: adjOffRtg,
                                        defRtg: adjDefRtg,
                                        netRtg: adjOffRtg - adjDefRtg,
                                        offEfg: adjOffEfg,
                                        defEfg: adjDefEfg
                                    };
                                };
                                
                                // V5.5: Generate N-player combinations based on exportWowyCombosSize
                                const generateCombinations = (arr, size) => {
                                    if (size > arr.length) return [];
                                    if (size === 1) return arr.map(item => [item]);
                                    const result = [];
                                    for (let i = 0; i <= arr.length - size; i++) {
                                        const head = [arr[i]];
                                        const tailCombos = generateCombinations(arr.slice(i + 1), size - 1);
                                        for (const combo of tailCombos) {
                                            result.push([...head, ...combo]);
                                        }
                                    }
                                    return result;
                                };
                                
                                // V5.5: Calculate WOWY stats for multi-player combinations
                                const combos = generateCombinations(allPlayers, exportWowyCombosSize);
                                const allComboStats = combos.map(combo => {
                                    // For ON lineups: all combo players are present together
                                    const onLineups = teamLineups.filter(l => {
                                        const lineupPlayers = parseLineupPlayers(l);
                                        const allIn = combo.every(p => lineupPlayers.some(lp => normalizePlayerName(lp) === normalizePlayerName(p)));
                                        return allIn;
                                    });
                                    // For OFF lineups: NOT all combo players together (at least one is missing)
                                    const offLineups = teamLineups.filter(l => {
                                        const lineupPlayers = parseLineupPlayers(l);
                                        const allIn = combo.every(p => lineupPlayers.some(lp => normalizePlayerName(lp) === normalizePlayerName(p)));
                                        return !allIn; // Any lineup where they're NOT all together
                                    });
                                    
                                    const onStatsRaw = calcWowyStats(onLineups);
                                    const offStatsRaw = calcWowyStats(offLineups);
                                    
                                    // Apply luck adjustment
                                    const onStats = applyLuckAdj(onStatsRaw, exportWowyOffLuckAdj, exportWowyDefLuckAdj);
                                    const offStats = applyLuckAdj(offStatsRaw, exportWowyOffLuckAdj, exportWowyDefLuckAdj);
                                    
                                    return {
                                        players: combo,
                                        onLineupCount: onLineups.length,
                                        offLineupCount: offLineups.length,
                                        onPoss: onStats.poss,
                                        offPoss: offStats.poss,
                                        onMins: onStats.mins,
                                        offMins: offStats.mins,
                                        onStats,
                                        offStats,
                                        impact: offStats.mins > 0 ? (onStats.netRtg - offStats.netRtg) : onStats.netRtg // Handle 0 OFF minutes
                                    };
                                });
                                // Filter and sort separately to get accurate count
                                const filteredCombos = allComboStats.filter(c => c.onMins >= exportWowyMinPoss);
                                const comboImpacts = filteredCombos.sort((a, b) => exportWowySortAsc ? a.impact - b.impact : b.impact - a.impact).slice(0, exportWowyCombosTopN);
                                
                                return e('div', null,
                                    // Luck adjustment indicator (only show when active)
                                    (exportWowyOffLuckAdj > 0 || exportWowyDefLuckAdj > 0) && e('div', { style: { 
                                        textAlign: 'center', 
                                        marginBottom: '12px', 
                                        padding: '8px 16px',
                                        background: 'rgba(251, 191, 36, 0.1)',
                                        borderRadius: '8px',
                                        border: '1px solid rgba(251, 191, 36, 0.3)'
                                    }},
                                        e('span', { style: { fontSize: '14px', color: '#fbbf24', fontWeight: '600' }}, 
                                            '🎲 3PT Luck Adjusted — ',
                                            exportWowyOffLuckAdj > 0 && e('span', { style: { color: '#4ade80' }}, 'Off ' + exportWowyOffLuckAdj + '%'),
                                            exportWowyOffLuckAdj > 0 && exportWowyDefLuckAdj > 0 && ' | ',
                                            exportWowyDefLuckAdj > 0 && e('span', { style: { color: '#f87171' }}, 'Def ' + exportWowyDefLuckAdj + '%'),
                                            ' (regressed toward 36% league avg)'
                                        )
                                    ),
                                    // Summary header
                                    e('div', { style: { textAlign: 'center', marginBottom: '24px' }},
                                        e('div', { style: { fontSize: '20px', fontWeight: '700', color: '#60a5fa' }}, currentTeam),
                                        e('div', { style: { fontSize: '14px', color: exportWowySortAsc ? '#f87171' : '#f59e0b', marginTop: '4px' }},
                                            (exportWowySortAsc ? '📉 Worst ' : '🏆 Best ') + exportWowyCombosSize + '-Player Combinations'
                                        ),
                                        e('div', { style: { fontSize: '11px', color: '#64748b', marginTop: '4px' }},
                                            filteredCombos.length + ' combinations with ' + exportWowyMinPoss + '+ minutes' +
                                            (filteredCombos.length > exportWowyCombosTopN ? ' (showing ' + (exportWowySortAsc ? 'bottom ' : 'top ') + exportWowyCombosTopN + ')' : '')
                                        ),
                                        e('div', { style: { fontSize: '10px', color: '#475569', marginTop: '2px' }},
                                            teamLineups.length + ' total lineups • ' + allPlayers.length + ' players • ' + combos.length + ' possible combos'
                                        )
                                    ),

                                    // V5.13: Table View for Combinations
                                    exportWowyTableView ? e('div', { style: { overflowX: 'auto' }},
                                        e('table', { className: 'wowy-table', style: { width: '100%', fontSize: '11px' }},
                                            e('thead', null,
                                                e('tr', null,
                                                    e('th', { style: { textAlign: 'left', minWidth: '180px' }}, 'Players'),
                                                    e('th', null, 'MIN'),
                                                    e('th', { style: { fontWeight: '700' }}, 'Δ NET'),
                                                    e('th', null, 'ON OFF'),
                                                    e('th', null, 'ON DEF'),
                                                    e('th', null, 'ON NET'),
                                                    e('th', { style: { borderLeft: '2px solid #475569' }}, 'OFF NET'),
                                                    e('th', null, 'eFG%'),
                                                    e('th', null, 'TOV%'),
                                                    e('th', null, 'OREB%'),
                                                    e('th', null, 'FTR')
                                                )
                                            ),
                                            e('tbody', null,
                                                comboImpacts.map((c, i) => e('tr', { key: i },
                                                    e('td', { style: { textAlign: 'left' }},
                                                        e('span', { style: { color: '#64748b', marginRight: '6px' }}, '#' + (i + 1)),
                                                        e('span', { style: { fontWeight: '600' }}, c.players.map(p => getDisplayName(p, true).split(' ').pop()).join(' + '))
                                                    ),
                                                    e('td', null, c.onMins.toFixed(0)),
                                                    e('td', { style: { fontWeight: '700', color: c.impact >= 0 ? '#4ade80' : '#f87171' }},
                                                        (c.impact >= 0 ? '+' : '') + c.impact.toFixed(1)),
                                                    e('td', { style: { color: '#4ade80' }}, c.onStats.offRtg.toFixed(1)),
                                                    e('td', { style: { color: '#f87171' }}, c.onStats.defRtg.toFixed(1)),
                                                    e('td', { style: { color: c.onStats.netRtg >= 0 ? '#86efac' : '#fca5a5' }},
                                                        (c.onStats.netRtg >= 0 ? '+' : '') + c.onStats.netRtg.toFixed(1)),
                                                    e('td', { style: { borderLeft: '2px solid #475569', color: c.offStats?.netRtg >= 0 ? '#86efac' : '#fca5a5' }},
                                                        c.offMins > 0 ? ((c.offStats.netRtg >= 0 ? '+' : '') + c.offStats.netRtg.toFixed(1)) : '—'),
                                                    e('td', null, c.onStats.offEfg.toFixed(1)),
                                                    e('td', null, c.onStats.offTov.toFixed(1)),
                                                    e('td', null, c.onStats.offOreb.toFixed(1)),
                                                    e('td', null, c.onStats.offFtR.toFixed(1))
                                                ))
                                            )
                                        )
                                    ) :

                                    // WOWY cards grid (default)
                                    e('div', { className: 'export-wowy-cards' },
                                        comboImpacts.map((c, i) => e('div', { key: i, className: 'export-wowy-card' },
                                            // Card header with players
                                            e('div', { className: 'export-wowy-card-header', style: { flexDirection: 'column', alignItems: 'flex-start' }},
                                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', width: '100%', marginBottom: '8px' }},
                                                    e('div', { className: 'export-wowy-card-rank' }, '#' + (i + 1)),
                                                    e('div', { style: { fontSize: '14px', fontWeight: '600', color: '#ffffff', flex: 1 }}, 
                                                        c.players.map(p => getDisplayName(p, true)).join(' + ')
                                                    )
                                                ),
                                                // Player photos row
                                                e('div', { style: { display: 'flex', gap: '4px', flexWrap: 'wrap' }},
                                                    c.players.map((player, j) => 
                                                        e('div', { 
                                                            key: j,
                                                            className: 'export-wowy-card-photo',
                                                            style: { width: '36px', height: '36px', fontSize: '10px' },
                                                            onClick: () => document.getElementById('wowy-combo-img-' + i + '-' + j).click()
                                                        },
                                                            exportWowyPlayerImages[player] 
                                                                ? e('img', { src: exportWowyPlayerImages[player], alt: player })
                                                                : getInitials(player),
                                                            e('input', { 
                                                                type: 'file', 
                                                                id: 'wowy-combo-img-' + i + '-' + j, 
                                                                accept: 'image/*', 
                                                                style: { display: 'none' },
                                                                onChange: (ev) => handleWowyPlayerImageUpload(player, ev)
                                                            })
                                                        )
                                                    )
                                                )
                                            ),
                                            
                                            // Impact display
                                            e('div', { className: 'export-wowy-impact', style: { background: c.impact >= 0 ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)' }},
                                                e('div', { className: 'export-wowy-impact-value', style: { color: c.impact >= 0 ? '#4ade80' : '#f87171' }}, 
                                                    (c.impact >= 0 ? '+' : '') + c.impact.toFixed(1)
                                                ),
                                                e('div', { className: 'export-wowy-impact-label' }, 
                                                    c.offMins > 0 ? 'Net Rating Impact' : 'Net Rating (ON only)'
                                                )
                                            ),
                                            
                                            // V5.5: Full Four Factors comparison with color coding
                                            e('div', { className: 'export-wowy-ff-grid-v2' },
                                                // ON Court section
                                                e('div', { className: 'export-wowy-ff-section-v2 on' },
                                                    e('div', { className: 'export-wowy-ff-section-header' }, '✓ ON Court'),
                                                    // Ratings
                                                    e('div', { className: 'export-wowy-ratings-row' },
                                                        e('div', { style: { color: '#4ade80' }}, 'Off: ' + c.onStats.offRtg.toFixed(1)),
                                                        e('div', { style: { color: '#f87171' }}, 'Def: ' + c.onStats.defRtg.toFixed(1)),
                                                        e('div', { style: { color: c.onStats.netRtg >= 0 ? '#818cf8' : '#f87171', fontWeight: '700' }}, 
                                                            'Net: ' + (c.onStats.netRtg >= 0 ? '+' : '') + c.onStats.netRtg.toFixed(1)
                                                        )
                                                    ),
                                                    // Offense Four Factors
                                                    e('div', { className: 'export-wowy-ff-row-v2' },
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.onStats.offEfg, 'offEfg') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'eFG%'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.onStats.offEfg.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.onStats.offTov, 'offTov') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'TOV%'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.onStats.offTov.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.onStats.offOreb, 'offOreb') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'OREB%'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.onStats.offOreb.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.onStats.offFtR, 'offFtR') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'FTR'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.onStats.offFtR.toFixed(1))
                                                        )
                                                    ),
                                                    // Defense Four Factors
                                                    e('div', { className: 'export-wowy-ff-row-v2' },
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.onStats.defEfg, 'defEfg') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'Opp eFG'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.onStats.defEfg.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.onStats.defTov, 'defTov') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'Frc TO'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.onStats.defTov.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.onStats.defOreb, 'defOreb') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'Opp ORB'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.onStats.defOreb.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.onStats.defFtR, 'defFtR') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'Opp FTR'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.onStats.defFtR.toFixed(1))
                                                        )
                                                    )
                                                ),
                                                // OFF Court section
                                                c.offMins > 0 ? e('div', { className: 'export-wowy-ff-section-v2 off' },
                                                    e('div', { className: 'export-wowy-ff-section-header' }, '✗ OFF Court'),
                                                    // Ratings
                                                    e('div', { className: 'export-wowy-ratings-row' },
                                                        e('div', { style: { color: '#4ade80' }}, 'Off: ' + c.offStats.offRtg.toFixed(1)),
                                                        e('div', { style: { color: '#f87171' }}, 'Def: ' + c.offStats.defRtg.toFixed(1)),
                                                        e('div', { style: { color: c.offStats.netRtg >= 0 ? '#818cf8' : '#f87171', fontWeight: '700' }}, 
                                                            'Net: ' + (c.offStats.netRtg >= 0 ? '+' : '') + c.offStats.netRtg.toFixed(1)
                                                        )
                                                    ),
                                                    // Offense Four Factors
                                                    e('div', { className: 'export-wowy-ff-row-v2' },
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.offStats.offEfg, 'offEfg') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'eFG%'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.offStats.offEfg.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.offStats.offTov, 'offTov') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'TOV%'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.offStats.offTov.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.offStats.offOreb, 'offOreb') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'OREB%'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.offStats.offOreb.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.offStats.offFtR, 'offFtR') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'FTR'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.offStats.offFtR.toFixed(1))
                                                        )
                                                    ),
                                                    // Defense Four Factors
                                                    e('div', { className: 'export-wowy-ff-row-v2' },
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.offStats.defEfg, 'defEfg') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'Opp eFG'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.offStats.defEfg.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.offStats.defTov, 'defTov') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'Frc TO'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.offStats.defTov.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.offStats.defOreb, 'defOreb') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'Opp ORB'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.offStats.defOreb.toFixed(1))
                                                        ),
                                                        e('div', { className: 'export-ff-stat-box-sm ' + getPerfClass(c.offStats.defFtR, 'defFtR') },
                                                            e('div', { className: 'export-ff-stat-label-sm' }, 'Opp FTR'),
                                                            e('div', { className: 'export-ff-stat-value-sm' }, c.offStats.defFtR.toFixed(1))
                                                        )
                                                    )
                                                ) : e('div', { className: 'export-wowy-ff-section-v2 off', style: { display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: '100px' }},
                                                    e('div', { style: { textAlign: 'center', color: '#64748b', fontSize: '11px' }},
                                                        e('div', { style: { fontSize: '20px', marginBottom: '4px' }}, '⚠️'),
                                                        e('div', null, 'No OFF data'),
                                                        e('div', { style: { fontSize: '9px', marginTop: '2px' }}, 'At least 1 player always on court')
                                                    )
                                                )
                                            ),
                                            
                                            // Meta row
                                            e('div', { className: 'export-wowy-meta-row' },
                                                e('span', null, (c.onMins || 0).toFixed(1) + ' ON min (' + (c.onLineupCount || 0) + ' lineups)'),
                                                c.offMins > 0 
                                                    ? e('span', null, c.offMins.toFixed(1) + ' OFF min (' + (c.offLineupCount || 0) + ' lineups)')
                                                    : e('span', { style: { color: '#f59e0b' }}, 'No OFF min')
                                            ),
                                            
                                            // Compact shot distribution bar (ON court only) - FG% on top of each segment, colored by shooting quality
                                            e('div', { style: { marginTop: '6px', padding: '4px 6px', background: 'rgba(15, 23, 42, 0.4)', borderRadius: '4px' }},
                                                // Offensive shot distribution
                                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px', marginBottom: '4px' }},
                                                    e('span', { style: { fontSize: '7px', color: '#4ade80', fontWeight: '700', minWidth: '22px' }}, 'OFF'),
                                                    e('div', { style: { flex: 1, display: 'flex', height: '16px', borderRadius: '3px', overflow: 'hidden', fontSize: '8px', fontWeight: '600' }},
                                                        // Rim segment - colored by FG% quality
                                                        c.onStats.rimPct > 0 && e('div', { 
                                                            style: { 
                                                                width: c.onStats.rimPct + '%', 
                                                                background: getFgPctBackground(c.onStats.rimFgPct, 'rim'),
                                                                display: 'flex', 
                                                                alignItems: 'center', 
                                                                justifyContent: 'center',
                                                                color: '#fff',
                                                                textShadow: '0 1px 2px rgba(0,0,0,0.8)',
                                                                minWidth: c.onStats.rimPct > 10 ? '0' : '20px',
                                                                borderRight: '1px solid rgba(0,0,0,0.3)'
                                                            }
                                                        }, c.onStats.rimPct > 10 ? (c.onStats.rimFgPct || 0).toFixed(0) + '%' : ''),
                                                        // Mid segment - colored by FG% quality
                                                        c.onStats.midPct > 0 && e('div', { 
                                                            style: { 
                                                                width: c.onStats.midPct + '%', 
                                                                background: getFgPctBackground(c.onStats.midFgPct, 'mid'),
                                                                display: 'flex', 
                                                                alignItems: 'center', 
                                                                justifyContent: 'center',
                                                                color: '#fff',
                                                                textShadow: '0 1px 2px rgba(0,0,0,0.8)',
                                                                minWidth: c.onStats.midPct > 10 ? '0' : '20px',
                                                                borderRight: '1px solid rgba(0,0,0,0.3)'
                                                            }
                                                        }, c.onStats.midPct > 10 ? (c.onStats.midFgPct || 0).toFixed(0) + '%' : ''),
                                                        // 3PT segment - colored by FG% quality
                                                        c.onStats.threePct > 0 && e('div', { 
                                                            style: { 
                                                                width: c.onStats.threePct + '%', 
                                                                background: getFgPctBackground(c.onStats.threeFgPct, '3pt'),
                                                                display: 'flex', 
                                                                alignItems: 'center', 
                                                                justifyContent: 'center',
                                                                color: '#fff',
                                                                textShadow: '0 1px 2px rgba(0,0,0,0.8)',
                                                                minWidth: c.onStats.threePct > 10 ? '0' : '20px'
                                                            }
                                                        }, c.onStats.threePct > 10 ? (c.onStats.threeFgPct || 0).toFixed(0) + '%' : '')
                                                    )
                                                ),
                                                // Defensive shot distribution (opponent)
                                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                                    e('span', { style: { fontSize: '7px', color: '#f87171', fontWeight: '700', minWidth: '22px' }}, 'DEF'),
                                                    e('div', { style: { flex: 1, display: 'flex', height: '16px', borderRadius: '3px', overflow: 'hidden', fontSize: '8px', fontWeight: '600' }},
                                                        // Rim segment - colored by FG% quality (inverted - lower is better for defense)
                                                        c.onStats.rimPctV > 0 && e('div', { 
                                                            style: { 
                                                                width: c.onStats.rimPctV + '%', 
                                                                background: getFgPctBackground(100 - c.onStats.rimFgPctV, 'rim'), // Invert for defense
                                                                display: 'flex', 
                                                                alignItems: 'center', 
                                                                justifyContent: 'center',
                                                                color: '#fff',
                                                                textShadow: '0 1px 2px rgba(0,0,0,0.8)',
                                                                minWidth: c.onStats.rimPctV > 10 ? '0' : '20px',
                                                                borderRight: '1px solid rgba(0,0,0,0.3)'
                                                            }
                                                        }, c.onStats.rimPctV > 10 ? (c.onStats.rimFgPctV || 0).toFixed(0) + '%' : ''),
                                                        // Mid segment
                                                        c.onStats.midPctV > 0 && e('div', { 
                                                            style: { 
                                                                width: c.onStats.midPctV + '%', 
                                                                background: getFgPctBackground(100 - c.onStats.midFgPctV, 'mid'),
                                                                display: 'flex', 
                                                                alignItems: 'center', 
                                                                justifyContent: 'center',
                                                                color: '#fff',
                                                                textShadow: '0 1px 2px rgba(0,0,0,0.8)',
                                                                minWidth: c.onStats.midPctV > 10 ? '0' : '20px',
                                                                borderRight: '1px solid rgba(0,0,0,0.3)'
                                                            }
                                                        }, c.onStats.midPctV > 10 ? (c.onStats.midFgPctV || 0).toFixed(0) + '%' : ''),
                                                        // 3PT segment
                                                        c.onStats.threePctV > 0 && e('div', { 
                                                            style: { 
                                                                width: c.onStats.threePctV + '%', 
                                                                background: getFgPctBackground(100 - c.onStats.threeFgPctV, '3pt'),
                                                                display: 'flex', 
                                                                alignItems: 'center', 
                                                                justifyContent: 'center',
                                                                color: '#fff',
                                                                textShadow: '0 1px 2px rgba(0,0,0,0.8)',
                                                                minWidth: c.onStats.threePctV > 10 ? '0' : '20px'
                                                            }
                                                        }, c.onStats.threePctV > 10 ? (c.onStats.threeFgPctV || 0).toFixed(0) + '%' : '')
                                                    )
                                                ),
                                                // Labels below bars
                                                e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '7px', color: '#64748b', marginTop: '2px', marginLeft: '26px' }},
                                                    e('span', null, 'RIM'),
                                                    e('span', null, 'MID'),
                                                    e('span', null, '3PT')
                                                ),
                                                // Luck adjustment indicator on card
                                                (exportWowyOffLuckAdj > 0 || exportWowyDefLuckAdj > 0) && e('div', { 
                                                    style: { 
                                                        marginTop: '4px', 
                                                        fontSize: '7px', 
                                                        color: '#fbbf24', 
                                                        textAlign: 'center',
                                                        padding: '2px 4px',
                                                        background: 'rgba(251, 191, 36, 0.1)',
                                                        borderRadius: '2px'
                                                    }
                                                }, 
                                                    '🎲 Luck Adj: ',
                                                    exportWowyOffLuckAdj > 0 && e('span', { style: { color: '#4ade80' }}, 'O' + exportWowyOffLuckAdj + '%'),
                                                    exportWowyOffLuckAdj > 0 && exportWowyDefLuckAdj > 0 && ' ',
                                                    exportWowyDefLuckAdj > 0 && e('span', { style: { color: '#f87171' }}, 'D' + exportWowyDefLuckAdj + '%')
                                                )
                                            )
                                        ))
                                    )
                                );
                            }

                            // V5.13: TEAMMATE IMPACT ANALYSIS MODE
                            if (exportWowyShowTeammateImpact) {
                                const selectedPlayers = exportWowySelectedPlayers.length > 0 ? exportWowySelectedPlayers : [];

                                if (selectedPlayers.length !== 1) {
                                    return e('div', { style: { textAlign: 'center', padding: '60px', color: '#64748b' }},
                                        e('div', { style: { fontSize: '48px', marginBottom: '16px' }}, '🔍'),
                                        e('div', { style: { fontSize: '18px', fontWeight: '600' }}, 'Select One Player'),
                                        e('div', { style: { fontSize: '14px', marginTop: '8px' }}, 'Click on exactly one player above to see their teammate impact analysis')
                                    );
                                }

                                const selectedPlayer = selectedPlayers[0];
                                const selectedPlayerNorm = normalizePlayerName(selectedPlayer);
                                const teamLineupsForImpact = lineupData.filter(l => l.Team === currentTeam && matchesDateFilter(l));

                                // Get all teammates - V6.1: Apply merge rules
                                const teammates = new Set();
                                teamLineupsForImpact.forEach(d => {
                                    if (!d.Lineup) return;
                                    const lineupPlayers = d.Lineup.split(',').map(p => applyPlayerMerge(p.trim()));
                                    const lineupPlayersNorm = lineupPlayers.map(p => normalizePlayerName(p));
                                    if (lineupPlayersNorm.includes(selectedPlayerNorm)) {
                                        lineupPlayers.forEach((p, idx) => {
                                            if (lineupPlayersNorm[idx] !== selectedPlayerNorm) {
                                                teammates.add(p);
                                            }
                                        });
                                    }
                                });

                                // League averages for BPM calculation
                                const leagueAvgEfg = 53, leagueAvgTov = 13, leagueAvgOreb = 25, leagueAvgFtr = 25;
                                const leagueAvg3Pct = 36;

                                // Apply luck adjustment
                                const applyLuckAdjLocal = (stats, offAdjPct, defAdjPct) => {
                                    if ((offAdjPct === 0 && defAdjPct === 0) || !stats.rawTpa) return stats;
                                    const offLuckDelta = stats.rawTpm - (stats.rawTpa * leagueAvg3Pct / 100);
                                    const offAdj3pm = offLuckDelta * (offAdjPct / 100);
                                    const defLuckDelta = stats.rawTpmV - (stats.rawTpaV * leagueAvg3Pct / 100);
                                    const defAdj3pm = defLuckDelta * (defAdjPct / 100);
                                    const adjPts = stats.rawPts - offAdj3pm * 3;
                                    const adjPtsV = stats.rawPtsV - defAdj3pm * 3;
                                    const adjOffRtg = stats.rawPoss > 0 ? (adjPts / stats.rawPoss) * 100 : stats.offRtg;
                                    const adjDefRtg = stats.rawPossV > 0 ? (adjPtsV / stats.rawPossV) * 100 : stats.defRtg;
                                    const adj3pm = Math.max(0, stats.rawTpm - offAdj3pm);
                                    const adjFgm = stats.rawFgm - offAdj3pm;
                                    const adjOffEfg = stats.rawFga > 0 ? ((adjFgm + 0.5 * adj3pm) / stats.rawFga) * 100 : stats.offEfg;
                                    const adj3pmV = Math.max(0, stats.rawTpmV - defAdj3pm);
                                    const adjFgmV = stats.rawFgmV - defAdj3pm;
                                    const adjDefEfg = stats.rawFgaV > 0 ? ((adjFgmV + 0.5 * adj3pmV) / stats.rawFgaV) * 100 : stats.defEfg;
                                    return { ...stats, offRtg: adjOffRtg, defRtg: adjDefRtg, netRtg: adjOffRtg - adjDefRtg, offEfg: adjOffEfg, defEfg: adjDefEfg };
                                };

                                // V5.21: BPM 2.0 coefficients from hackastat.eu using percentage-based stats
                                const BPM_COEFFS = {
                                    a: 0.123391, b: 0.119597, c: -0.151287, d: 1.255644,
                                    e: 0.531838, f: -0.305868, g: 0.921292, h: 0.711217,
                                    i: 0.017022, j: 0.297639, k: 0.213485, l: 0.725930
                                };
                                const OBPM_COEFFS = {
                                    a: 0.064448, b: 0.211125, c: -0.107545, d: 0.346513,
                                    e: -0.052476, f: -0.041787, g: 0.932965, h: 0.687359,
                                    i: 0.007952, j: 0.374706, k: -0.181891, l: 0.239862
                                };
                                const lgAvg3PAr = 0.40;

                                // V5.23: Calculate PER using simplified Hollinger formula
                                const calcPER = (pStats, lineupTotals) => {
                                    if (!pStats || pStats.mins < 0.1) return null;
                                    const lt = lineupTotals || {};
                                    const teamPace = lt.mins > 0 ? ((lt.poss || 0) / lt.mins) * 48 : 100;
                                    const leagueAvgPace = 100;
                                    const paceFactor = leagueAvgPace / Math.max(teamPace, 50);
                                    const pts = pStats.pts || 0;
                                    const reb = (pStats.oreb || 0) + (pStats.dreb || 0);
                                    const ast = pStats.ast || 0;
                                    const stl = pStats.stl || 0;
                                    const blk = pStats.blk || 0;
                                    const missedFg = (pStats.fga || 0) - (pStats.fgm || 0);
                                    const missedFt = (pStats.fta || 0) - (pStats.ftm || 0);
                                    const tov = pStats.tov || 0;
                                    return pStats.mins > 0 ?
                                        ((pts + reb + ast * 1.5 + stl * 2 + blk * 2 - missedFg - missedFt * 0.5 - tov * 1.5) / pStats.mins) * 15 * paceFactor : 0;
                                };

                                // V5.21: Calculate BPM 2.0 using percentage-based stats
                                const calcBpmFromFF = (stats, playerBoxTotals = null, teamPoss = 75) => {
                                    if (playerBoxTotals && playerBoxTotals.lineupTotals) {
                                        const pStats = playerBoxTotals;
                                        const lt = pStats.lineupTotals;
                                        if (lt.poss < 1 || lt.mins < 0.1) return null;

                                        const reMpg = pStats.mins / (pStats.gp + 2);
                                        const orebOpps = lt.oreb + lt.drebV;
                                        const orbPct = orebOpps > 0 ? (pStats.oreb / orebOpps) * 100 : 0;
                                        const drebOpps = lt.dreb + lt.orebV;
                                        const drbPct = drebOpps > 0 ? (pStats.dreb / drebOpps) * 100 : 0;
                                        const trbPct = (orebOpps + drebOpps) > 0 ? ((pStats.oreb + pStats.dreb) / (orebOpps + drebOpps)) * 100 : 0;
                                        const stlPct = lt.possV > 0 ? (pStats.stl / lt.possV) * 100 : 0;
                                        const opp2pa = lt.fgaV * 0.6;
                                        const blkPct = opp2pa > 0 ? (pStats.blk / opp2pa) * 100 : 0;
                                        const tmFgmExcludingSelf = pStats.teamFgm - pStats.fgm;
                                        const astPct = tmFgmExcludingSelf > 0 ? (pStats.ast / tmFgmExcludingSelf) * 100 : 0;
                                        const playerPossUsed = pStats.fga + 0.44 * pStats.fta + pStats.tov;
                                        const usgPct = lt.poss > 0 ? (playerPossUsed / lt.poss) * 100 : 0;
                                        const tovPct = playerPossUsed > 0 ? (pStats.tov / playerPossUsed) * 100 : 0;
                                        const tsa = 2 * (pStats.fga + 0.44 * pStats.fta);
                                        const tsPct = tsa > 0 ? (pStats.pts / tsa) * 100 : 0;
                                        const teamTsa = 2 * (lt.fga + 0.44 * lt.fta);
                                        const teamTsPct = teamTsa > 0 ? ((lt.fgm * 2 + (lt.fga > 0 ? (lt.fgm / lt.fga) * lt.fga * 0.5 : 0)) / teamTsa) * 100 : 50;
                                        const threePAr = pStats.fga > 0 ? pStats.tpa / pStats.fga : 0;

                                        const term1 = BPM_COEFFS.a * reMpg;
                                        const term2 = BPM_COEFFS.b * orbPct;
                                        const term3 = BPM_COEFFS.c * drbPct;
                                        const term4 = BPM_COEFFS.d * stlPct;
                                        const term5 = BPM_COEFFS.e * blkPct;
                                        const term6 = BPM_COEFFS.f * astPct;
                                        const term7 = -BPM_COEFFS.g * (usgPct / 100) * tovPct;
                                        const scoringTerm = BPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                                            (2 * (tsPct - teamTsPct) / 100 + BPM_COEFFS.i * astPct / 100 + BPM_COEFFS.j * (threePAr - lgAvg3PAr) - BPM_COEFFS.k);
                                        const term9 = BPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;
                                        const rawBpm = term1 + term2 + term3 + term4 + term5 + term6 + term7 + scoringTerm + term9;

                                        const oTerm1 = OBPM_COEFFS.a * reMpg;
                                        const oTerm2 = OBPM_COEFFS.b * orbPct;
                                        const oTerm3 = OBPM_COEFFS.c * drbPct;
                                        const oTerm4 = OBPM_COEFFS.d * stlPct;
                                        const oTerm5 = OBPM_COEFFS.e * blkPct;
                                        const oTerm6 = OBPM_COEFFS.f * astPct;
                                        const oTerm7 = -OBPM_COEFFS.g * (usgPct / 100) * tovPct;
                                        const oScoringTerm = OBPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                                            (2 * (tsPct - teamTsPct) / 100 + OBPM_COEFFS.i * astPct / 100 + OBPM_COEFFS.j * (threePAr - lgAvg3PAr) - OBPM_COEFFS.k);
                                        const oTerm9 = OBPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;
                                        const rawObpm = oTerm1 + oTerm2 + oTerm3 + oTerm4 + oTerm5 + oTerm6 + oTerm7 + oScoringTerm + oTerm9;

                                        return { bpm: rawBpm, obpm: rawObpm, dbpm: rawBpm - rawObpm };
                                    }

                                    // Fallback: Four Factors method when no individual player stats
                                    const efgContrib = (stats.offEfg - leagueAvgEfg) * 0.6;
                                    const tovContrib = (leagueAvgTov - stats.offTov) * 0.4;
                                    const orebContrib = (stats.offOreb - leagueAvgOreb) * 0.15;
                                    const ftrContrib = (stats.offFtR - leagueAvgFtr) * 0.08;
                                    const obpm = efgContrib + tovContrib + orebContrib + ftrContrib;
                                    const defEfgContrib = (leagueAvgEfg - stats.defEfg) * 0.5;
                                    const defTovContrib = (stats.defTov - leagueAvgTov) * 0.35;
                                    const defOrebContrib = (leagueAvgOreb - stats.defOreb) * 0.12;
                                    const defFtrContrib = (leagueAvgFtr - stats.defFtR) * 0.06;
                                    const dbpm = defEfgContrib + defTovContrib + defOrebContrib + defFtrContrib;
                                    return { bpm: obpm + dbpm, obpm, dbpm };
                                };

                                // V5.19: Helper to normalize lineup string for matching
                                const normalizeLineupStr = (lineup) => {
                                    if (!lineup) return '';
                                    return lineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',');
                                };

                                // V5.19: Helper to construct full lineup from Player + Teammates columns
                                const getFullLineupFromPd = (pd) => {
                                    const player = pd.Player || '';
                                    const teammates = pd.Teammates || '';
                                    if (!player || !teammates) return '';
                                    return player + ',' + teammates;
                                };

                                // V5.19: Helper to get player's individual stats from lineups matching criteria
                                // Uses Player + Teammates to construct lineup for matching
                                // V5.21: Collects lineupTotals and teamFgm for BPM 2.0 percentage calculations
                                const getPlayerBoxTotals = (player, lineups) => {
                                    const playerNorm = normalizePlayerName(player);
                                    // Create normalized lineup set for matching (from lineupData)
                                    const normalizedLineupSet = new Set(lineups.map(l => normalizeLineupStr(l.Lineup)));

                                    // V5.21: Calculate lineup totals from lineupData for BPM 2.0 percentage denominators
                                    const lineupTotals = lineups.reduce((acc, l) => {
                                        const fga = parseFloat(l.FGA) || 0;
                                        const fgm = parseFloat(l.FGM) || 0;
                                        const oreb = parseFloat(l.OREB) || 0;
                                        const dreb = parseFloat(l.DREB) || 0;
                                        const tov = parseFloat(l.TOV) || 0;
                                        const fta = parseFloat(l.FTA) || 0;
                                        const fgaV = parseFloat(l.FGA_VS) || 0;
                                        const orebV = parseFloat(l.OREB_VS) || 0;
                                        const drebV = parseFloat(l.DREB_VS) || 0;
                                        const tovV = parseFloat(l.TOV_VS) || 0;
                                        const ftaV = parseFloat(l.FTA_VS) || 0;
                                        const mins = (parseFloat(l.TOTAL_TIME) || 0) / 60;
                                        const poss = parseFloat(l.POSS) || (fga - oreb + tov + 0.44 * fta);
                                        const possV = fgaV - orebV + tovV + 0.44 * ftaV;
                                        return {
                                            poss: acc.poss + poss,
                                            possV: acc.possV + possV,
                                            mins: acc.mins + mins,
                                            fga: acc.fga + fga,
                                            fgm: acc.fgm + fgm,
                                            fta: acc.fta + fta,
                                            oreb: acc.oreb + oreb,
                                            dreb: acc.dreb + dreb,
                                            orebV: acc.orebV + orebV,
                                            drebV: acc.drebV + drebV,
                                            fgaV: acc.fgaV + fgaV
                                        };
                                    }, { poss: 0, possV: 0, mins: 0, fga: 0, fgm: 0, fta: 0, oreb: 0, dreb: 0, orebV: 0, drebV: 0, fgaV: 0 });

                                    const relevantPlayerRows = playerData.filter(pd => {
                                        if (!pd.Player || normalizePlayerName(pd.Player) !== playerNorm) return false;
                                        if (pd.Team !== currentTeam) return false;
                                        // V5.19: Construct full lineup from Player + Teammates, then normalize and match
                                        const fullLineup = getFullLineupFromPd(pd);
                                        const pdLineupNorm = normalizeLineupStr(fullLineup);
                                        return normalizedLineupSet.has(pdLineupNorm);
                                    });

                                    if (!relevantPlayerRows.length) return null;

                                    // V5.21: Also collect teamFgm from ALL players in matching lineups for AST% denominator
                                    const allPlayersInMatchingLineups = playerData.filter(pd => {
                                        if (pd.Team !== currentTeam) return false;
                                        const fullLineup = getFullLineupFromPd(pd);
                                        const pdLineupNorm = normalizeLineupStr(fullLineup);
                                        return normalizedLineupSet.has(pdLineupNorm);
                                    });
                                    const teamFgm = allPlayersInMatchingLineups.reduce((sum, pd) => sum + (parseFloat(pd.FGM) || 0), 0);

                                    const totals = relevantPlayerRows.reduce((acc, pd) => ({
                                        pts: acc.pts + (parseFloat(pd.PTS) || 0),
                                        fga: acc.fga + (parseFloat(pd.FGA) || 0),
                                        fgm: acc.fgm + (parseFloat(pd.FGM) || 0),
                                        tpa: acc.tpa + (parseFloat(pd['3PA']) || 0),
                                        tpm: acc.tpm + (parseFloat(pd['3PM']) || 0),
                                        fta: acc.fta + (parseFloat(pd.FTA) || 0),
                                        ftm: acc.ftm + (parseFloat(pd.FTM) || 0),
                                        oreb: acc.oreb + (parseFloat(pd.OREB) || 0),
                                        dreb: acc.dreb + (parseFloat(pd.DREB) || 0),
                                        ast: acc.ast + (parseFloat(pd.AST) || 0),
                                        stl: acc.stl + (parseFloat(pd.STL) || 0),
                                        blk: acc.blk + (parseFloat(pd.BLK) || 0),
                                        tov: acc.tov + (parseFloat(pd.TOV) || 0),
                                        mins: acc.mins + (parseFloat(pd.Minutes) || parseFloat(pd.TOTAL_TIME) / 60 || 0),
                                        gp: acc.gp + 1
                                    }), { pts: 0, fga: 0, fgm: 0, tpa: 0, tpm: 0, fta: 0, ftm: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, mins: 0, gp: 0 });

                                    // V5.21: Return player stats with lineupTotals and teamFgm for BPM 2.0 calculation
                                    return { ...totals, lineupTotals, teamFgm };
                                };

                                // Calculate stats for each teammate
                                const teammateResults = [];
                                teammates.forEach(teammate => {
                                    const teammateNorm = normalizePlayerName(teammate);
                                    const bothOnLineups = teamLineupsForImpact.filter(d => {
                                        const lpNorm = d.Lineup ? d.Lineup.split(',').map(p => normalizePlayerName(p.trim())) : [];
                                        return lpNorm.includes(selectedPlayerNorm) && lpNorm.includes(teammateNorm);
                                    });
                                    const soloLineups = teamLineupsForImpact.filter(d => {
                                        const lpNorm = d.Lineup ? d.Lineup.split(',').map(p => normalizePlayerName(p.trim())) : [];
                                        return lpNorm.includes(selectedPlayerNorm) && !lpNorm.includes(teammateNorm);
                                    });

                                    const bothStats = calcWowyStats(bothOnLineups);
                                    const soloStats = calcWowyStats(soloLineups);
                                    const bothStatsAdj = applyLuckAdjLocal(bothStats, exportWowyOffLuckAdj, exportWowyDefLuckAdj);
                                    const soloStatsAdj = applyLuckAdjLocal(soloStats, exportWowyOffLuckAdj, exportWowyDefLuckAdj);

                                    // V5.21: Get player's individual box stats for BPM 2.0 calculation
                                    const selectedPlayerBoxBothOn = getPlayerBoxTotals(selectedPlayer, bothOnLineups);
                                    const selectedPlayerBoxSolo = getPlayerBoxTotals(selectedPlayer, soloLineups);

                                    // Calculate BPM 2.0 using percentage-based stats, fallback to Four Factors if no player data
                                    const bothBpm = calcBpmFromFF(bothStatsAdj, selectedPlayerBoxBothOn, bothStats.rawPoss) || { bpm: null, obpm: null, dbpm: null };
                                    const soloBpm = calcBpmFromFF(soloStatsAdj, selectedPlayerBoxSolo, soloStats.rawPoss) || { bpm: null, obpm: null, dbpm: null };

                                    // V5.23: Calculate PER for both scenarios
                                    const bothPer = selectedPlayerBoxBothOn ? calcPER(selectedPlayerBoxBothOn, selectedPlayerBoxBothOn.lineupTotals) : null;
                                    const soloPer = selectedPlayerBoxSolo ? calcPER(selectedPlayerBoxSolo, selectedPlayerBoxSolo.lineupTotals) : null;

                                    // V5.13: Require BOTH scenarios meet min minutes threshold for valid comparison
                                    if (bothStats.mins >= exportWowyMinPoss && soloStats.mins >= exportWowyMinPoss) {
                                        // V5.21: Handle null BPM values in delta calculation
                                        const bpmDelta = (bothBpm.bpm !== null && soloBpm.bpm !== null) ? bothBpm.bpm - soloBpm.bpm : null;
                                        const obpmDelta = (bothBpm.obpm !== null && soloBpm.obpm !== null) ? bothBpm.obpm - soloBpm.obpm : null;
                                        const dbpmDelta = (bothBpm.dbpm !== null && soloBpm.dbpm !== null) ? bothBpm.dbpm - soloBpm.dbpm : null;
                                        // V5.23: Calculate PER delta
                                        const perDelta = (bothPer !== null && soloPer !== null) ? bothPer - soloPer : null;
                                        teammateResults.push({
                                            teammate,
                                            combinedMins: bothStats.mins, // Time spent TOGETHER (not combined)
                                            bothOn: { ...bothStatsAdj, ...bothBpm, per: bothPer, mins: bothStats.mins, lineups: bothOnLineups.length },
                                            solo: { ...soloStatsAdj, ...soloBpm, per: soloPer, mins: soloStats.mins, lineups: soloLineups.length },
                                            delta: {
                                                netRtg: bothStatsAdj.netRtg - soloStatsAdj.netRtg,
                                                offRtg: bothStatsAdj.offRtg - soloStatsAdj.offRtg,
                                                defRtg: bothStatsAdj.defRtg - soloStatsAdj.defRtg,
                                                bpm: bpmDelta,
                                                obpm: obpmDelta,
                                                dbpm: dbpmDelta,
                                                per: perDelta
                                            }
                                        });
                                    }
                                });

                                // Sort by net rating impact
                                teammateResults.sort((a, b) => (b.delta?.netRtg || -999) - (a.delta?.netRtg || -999));

                                const formatMins = (m) => {
                                    const totalSecs = Math.round((m || 0) * 60);
                                    const mins = Math.floor(totalSecs / 60);
                                    const secs = totalSecs % 60;
                                    return mins + ':' + String(secs).padStart(2, '0');
                                };

                                // V5.14.2: Build team players array for name disambiguation
                                const teamPlayersArray = [selectedPlayer, ...Array.from(teammates)];

                                // V5.13: Table View for Teammate Impact
                                if (exportWowyTableView) {
                                    return e('div', null,
                                        // Header
                                        e('div', { style: { textAlign: 'center', marginBottom: '16px' }},
                                            e('div', { style: { fontSize: '18px', fontWeight: '700', color: '#a78bfa' }},
                                                '🔍 Teammate Impact: ' + getDisplayName(selectedPlayer, true, teamPlayersArray)
                                            ),
                                            e('div', { style: { fontSize: '12px', color: '#94a3b8', marginTop: '4px' }},
                                                teammateResults.length + ' teammates | Min: ' + exportWowyMinPoss + ' mins each scenario'
                                            )
                                        ),
                                        // Table
                                        e('div', { style: { overflowX: 'auto' }},
                                            e('table', { className: 'wowy-table', style: { width: '100%', fontSize: '11px' }},
                                                e('thead', null,
                                                    e('tr', null,
                                                        e('th', { style: { textAlign: 'left', minWidth: '120px' }}, 'Teammate'),
                                                        e('th', { title: 'Minutes played together' }, 'TOGETHER'),
                                                        e('th', { style: { background: 'rgba(96, 165, 250, 0.15)' }, title: 'BPM Impact (Myers)' }, 'Δ BPM'),
                                                        e('th', { style: { background: 'rgba(167, 139, 250, 0.15)' }, title: 'PER Impact' }, 'Δ PER'),
                                                        e('th', { title: 'Net Rating Impact' }, 'Δ NET'),
                                                        e('th', { title: 'Offensive Rating Impact' }, 'Δ OFF'),
                                                        e('th', { title: 'Defensive Rating Impact' }, 'Δ DEF'),
                                                        e('th', { style: { borderLeft: '2px solid #475569' }, title: 'Minutes WITH teammate' }, 'ON MIN'),
                                                        e('th', { title: 'Net Rating WITH' }, 'ON NET'),
                                                        e('th', { title: 'BPM WITH' }, 'ON BPM'),
                                                        e('th', { title: 'PER WITH' }, 'ON PER'),
                                                        e('th', { style: { borderLeft: '2px solid #475569' }, title: 'Minutes WITHOUT teammate' }, 'OFF MIN'),
                                                        e('th', { title: 'Net Rating WITHOUT' }, 'OFF NET'),
                                                        e('th', { title: 'BPM WITHOUT' }, 'OFF BPM'),
                                                        e('th', { title: 'PER WITHOUT' }, 'OFF PER')
                                                    )
                                                ),
                                                e('tbody', null,
                                                    teammateResults.map((row, i) => e('tr', { key: i },
                                                        e('td', { style: { textAlign: 'left', fontWeight: '600' }},
                                                            e('span', { style: { color: '#64748b', marginRight: '6px' }}, '#' + (i + 1)),
                                                            getDisplayName(row.teammate, true, teamPlayersArray)
                                                        ),
                                                        e('td', null, formatMins(row.combinedMins)),
                                                        // V5.17: Handle null BPM values
                                                        e('td', { style: {
                                                            background: 'rgba(96, 165, 250, 0.15)',
                                                            fontWeight: '700',
                                                            color: row.delta.bpm === null ? '#64748b' : row.delta.bpm >= 1.5 ? '#22c55e' : row.delta.bpm <= -1.5 ? '#ef4444' : row.delta.bpm >= 0 ? '#86efac' : '#fca5a5'
                                                        }}, row.delta.bpm === null ? 'N/A' : (row.delta.bpm >= 0 ? '+' : '') + row.delta.bpm.toFixed(1)),
                                                        // V5.23: PER Impact column
                                                        e('td', { style: {
                                                            background: 'rgba(167, 139, 250, 0.15)',
                                                            fontWeight: '700',
                                                            color: row.delta.per === null ? '#64748b' : row.delta.per >= 2 ? '#22c55e' : row.delta.per <= -2 ? '#ef4444' : row.delta.per >= 0 ? '#86efac' : '#fca5a5'
                                                        }}, row.delta.per === null ? 'N/A' : (row.delta.per >= 0 ? '+' : '') + row.delta.per.toFixed(1)),
                                                        e('td', { style: { fontWeight: '600', color: row.delta.netRtg >= 0 ? '#4ade80' : '#f87171' }},
                                                            (row.delta.netRtg >= 0 ? '+' : '') + row.delta.netRtg.toFixed(1)),
                                                        e('td', { style: { color: row.delta.offRtg >= 0 ? '#4ade80' : '#f87171' }},
                                                            (row.delta.offRtg >= 0 ? '+' : '') + row.delta.offRtg.toFixed(1)),
                                                        e('td', { style: { color: row.delta.defRtg <= 0 ? '#4ade80' : '#f87171' }},
                                                            (row.delta.defRtg >= 0 ? '+' : '') + row.delta.defRtg.toFixed(1)),
                                                        e('td', { style: { borderLeft: '2px solid #475569', color: '#94a3b8' }}, formatMins(row.bothOn.mins)),
                                                        e('td', { style: { color: row.bothOn.netRtg >= 0 ? '#86efac' : '#fca5a5' }},
                                                            (row.bothOn.netRtg >= 0 ? '+' : '') + row.bothOn.netRtg.toFixed(1)),
                                                        e('td', { style: { color: row.bothOn.bpm >= 0 ? '#86efac' : '#fca5a5' }},
                                                            row.bothOn.bpm === null ? 'N/A' : (row.bothOn.bpm >= 0 ? '+' : '') + row.bothOn.bpm.toFixed(1)),
                                                        e('td', { style: { color: row.bothOn.per !== null && row.bothOn.per >= 15 ? '#86efac' : row.bothOn.per !== null && row.bothOn.per < 10 ? '#fca5a5' : '#94a3b8' }},
                                                            row.bothOn.per === null ? 'N/A' : row.bothOn.per.toFixed(1)),
                                                        e('td', { style: { borderLeft: '2px solid #475569', color: '#94a3b8' }}, formatMins(row.solo.mins)),
                                                        e('td', { style: { color: row.solo.netRtg >= 0 ? '#86efac' : '#fca5a5' }},
                                                            (row.solo.netRtg >= 0 ? '+' : '') + row.solo.netRtg.toFixed(1)),
                                                        e('td', { style: { color: row.solo.bpm >= 0 ? '#86efac' : '#fca5a5' }},
                                                            row.solo.bpm === null ? 'N/A' : (row.solo.bpm >= 0 ? '+' : '') + row.solo.bpm.toFixed(1)),
                                                        e('td', { style: { color: row.solo.per !== null && row.solo.per >= 15 ? '#86efac' : row.solo.per !== null && row.solo.per < 10 ? '#fca5a5' : '#94a3b8' }},
                                                            row.solo.per === null ? 'N/A' : row.solo.per.toFixed(1))
                                                    ))
                                                )
                                            )
                                        )
                                    );
                                }

                                // Card View (default)
                                return e('div', null,
                                    // Header
                                    e('div', { style: { textAlign: 'center', marginBottom: '24px' }},
                                        e('div', { style: { fontSize: '20px', fontWeight: '700', color: '#a78bfa' }},
                                            '🔍 Teammate Impact: ' + getDisplayName(selectedPlayer, true, teamPlayersArray)
                                        ),
                                        e('div', { style: { fontSize: '14px', color: '#94a3b8', marginTop: '4px' }},
                                            teammateResults.length + ' teammates analyzed | Min: ' + exportWowyMinPoss + ' mins each scenario'
                                        ),
                                        (exportWowyOffLuckAdj > 0 || exportWowyDefLuckAdj > 0) && e('div', { style: { fontSize: '12px', color: '#fbbf24', marginTop: '4px' }},
                                            '🎲 Luck Adjusted (Off: ' + exportWowyOffLuckAdj + '%, Def: ' + exportWowyDefLuckAdj + '%)'
                                        )
                                    ),

                                    // Teammate Impact Cards
                                    e('div', { className: 'export-wowy-cards' },
                                        teammateResults.map((row, i) => e('div', { key: i, className: 'export-wowy-card' },
                                            // Card header with combined minutes
                                            e('div', { className: 'export-wowy-card-header' },
                                                e('div', { className: 'export-wowy-card-rank' }, '#' + (i + 1)),
                                                e('div', {
                                                    className: 'export-wowy-card-photo',
                                                    style: { cursor: 'pointer' },
                                                    onClick: () => document.getElementById('teammate-impact-img-' + i)?.click()
                                                },
                                                    exportWowyPlayerImages[row.teammate]
                                                        ? e('img', { src: exportWowyPlayerImages[row.teammate], alt: row.teammate })
                                                        : getInitials(row.teammate),
                                                    e('input', {
                                                        type: 'file',
                                                        id: 'teammate-impact-img-' + i,
                                                        accept: 'image/*',
                                                        style: { display: 'none' },
                                                        onChange: (ev) => handleWowyPlayerImageUpload(row.teammate, ev)
                                                    })
                                                ),
                                                e('div', { className: 'export-wowy-card-info' },
                                                    e('div', { className: 'export-wowy-card-name' }, getDisplayName(row.teammate, true, teamPlayersArray)),
                                                    e('div', { style: { fontSize: '11px', color: '#94a3b8' }},
                                                        formatMins(row.combinedMins) + ' together'
                                                    )
                                                )
                                            ),

                                            // BPM and PER Impact (SIDE BY SIDE DISPLAY)
                                            // V5.23: Added PER Impact next to BPM Impact
                                            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', marginBottom: '12px' }},
                                                // BPM Impact
                                                e('div', { style: {
                                                    background: row.delta.bpm === null ? 'linear-gradient(135deg, rgba(100, 116, 139, 0.2), rgba(71, 85, 105, 0.1))' : row.delta.bpm >= 0 ? 'linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(16, 185, 129, 0.1))' : 'linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.1))',
                                                    padding: '12px',
                                                    borderRadius: '10px',
                                                    border: '1px solid ' + (row.delta.bpm === null ? 'rgba(100, 116, 139, 0.4)' : row.delta.bpm >= 0 ? 'rgba(34, 197, 94, 0.4)' : 'rgba(239, 68, 68, 0.4)')
                                                }},
                                                    e('div', { style: { textAlign: 'center' }},
                                                        e('div', { style: { fontSize: '10px', color: '#60a5fa', marginBottom: '4px', fontWeight: '600' }}, 'BPM IMPACT'),
                                                        row.delta.bpm === null ?
                                                            e('div', null,
                                                                e('div', { style: { fontSize: '18px', fontWeight: '700', color: '#64748b' }}, 'N/A'),
                                                                e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '2px' }}, 'Load player data')
                                                            ) :
                                                            e('div', null,
                                                                e('div', { style: {
                                                                    fontSize: '26px',
                                                                    fontWeight: '800',
                                                                    color: row.delta.bpm >= 1.5 ? '#22c55e' : row.delta.bpm <= -1.5 ? '#ef4444' : row.delta.bpm >= 0 ? '#86efac' : '#fca5a5'
                                                                }}, (row.delta.bpm >= 0 ? '+' : '') + row.delta.bpm.toFixed(1)),
                                                                e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '2px' }},
                                                                    'O: ' + (row.delta.obpm >= 0 ? '+' : '') + row.delta.obpm.toFixed(1) + ' | D: ' + (row.delta.dbpm >= 0 ? '+' : '') + row.delta.dbpm.toFixed(1)
                                                                )
                                                            )
                                                    )
                                                ),
                                                // PER Impact
                                                e('div', { style: {
                                                    background: row.delta.per === null ? 'linear-gradient(135deg, rgba(100, 116, 139, 0.2), rgba(71, 85, 105, 0.1))' : row.delta.per >= 0 ? 'linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(109, 40, 217, 0.1))' : 'linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.1))',
                                                    padding: '12px',
                                                    borderRadius: '10px',
                                                    border: '1px solid ' + (row.delta.per === null ? 'rgba(100, 116, 139, 0.4)' : row.delta.per >= 0 ? 'rgba(139, 92, 246, 0.4)' : 'rgba(239, 68, 68, 0.4)')
                                                }},
                                                    e('div', { style: { textAlign: 'center' }},
                                                        e('div', { style: { fontSize: '10px', color: '#a78bfa', marginBottom: '4px', fontWeight: '600' }}, 'PER IMPACT'),
                                                        row.delta.per === null ?
                                                            e('div', null,
                                                                e('div', { style: { fontSize: '18px', fontWeight: '700', color: '#64748b' }}, 'N/A'),
                                                                e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '2px' }}, 'Load player data')
                                                            ) :
                                                            e('div', null,
                                                                e('div', { style: {
                                                                    fontSize: '26px',
                                                                    fontWeight: '800',
                                                                    color: row.delta.per >= 2 ? '#22c55e' : row.delta.per <= -2 ? '#ef4444' : row.delta.per >= 0 ? '#a78bfa' : '#fca5a5'
                                                                }}, (row.delta.per >= 0 ? '+' : '') + row.delta.per.toFixed(1)),
                                                                e('div', { style: { fontSize: '9px', color: '#94a3b8', marginTop: '2px' }},
                                                                    'w/' + (row.bothOn.per !== null ? row.bothOn.per.toFixed(1) : 'N/A') + ' | w/o ' + (row.solo.per !== null ? row.solo.per.toFixed(1) : 'N/A')
                                                                )
                                                            )
                                                    )
                                                )
                                            ),

                                            // Net Rating Impact
                                            e('div', { className: 'export-wowy-impact', style: { background: row.delta.netRtg >= 0 ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)' }},
                                                e('div', { className: 'export-wowy-impact-value', style: { color: row.delta.netRtg >= 0 ? '#4ade80' : '#f87171' }},
                                                    (row.delta.netRtg >= 0 ? '+' : '') + row.delta.netRtg.toFixed(1)
                                                ),
                                                e('div', { className: 'export-wowy-impact-label' }, 'Net Rating Impact')
                                            ),

                                            // ON/OFF comparison with minutes
                                            e('div', { className: 'export-wowy-ff-grid' },
                                                e('div', { className: 'export-wowy-ff-section on' },
                                                    e('div', { className: 'export-wowy-ff-title' }, '✓ WITH (' + formatMins(row.bothOn.mins) + ')'),
                                                    e('div', { className: 'export-wowy-ff-stats' },
                                                        e('div', { className: 'export-wowy-ff-stat' }, e('span', null, 'OFF'), row.bothOn.offRtg.toFixed(1)),
                                                        e('div', { className: 'export-wowy-ff-stat' }, e('span', null, 'DEF'), row.bothOn.defRtg.toFixed(1)),
                                                        e('div', { className: 'export-wowy-ff-stat', style: { fontWeight: '700' } }, e('span', null, 'NET'), (row.bothOn.netRtg >= 0 ? '+' : '') + row.bothOn.netRtg.toFixed(1)),
                                                        e('div', { className: 'export-wowy-ff-stat', style: { color: '#60a5fa' } }, e('span', null, 'BPM'), row.bothOn.bpm === null ? 'N/A' : (row.bothOn.bpm >= 0 ? '+' : '') + row.bothOn.bpm.toFixed(1)),
                                                        e('div', { className: 'export-wowy-ff-stat', style: { color: '#a78bfa' } }, e('span', null, 'PER'), row.bothOn.per === null ? 'N/A' : row.bothOn.per.toFixed(1))
                                                    )
                                                ),
                                                e('div', { className: 'export-wowy-ff-section off' },
                                                    e('div', { className: 'export-wowy-ff-title' }, '✗ WITHOUT (' + formatMins(row.solo.mins) + ')'),
                                                    e('div', { className: 'export-wowy-ff-stats' },
                                                        e('div', { className: 'export-wowy-ff-stat' }, e('span', null, 'OFF'), row.solo.offRtg.toFixed(1)),
                                                        e('div', { className: 'export-wowy-ff-stat' }, e('span', null, 'DEF'), row.solo.defRtg.toFixed(1)),
                                                        e('div', { className: 'export-wowy-ff-stat', style: { fontWeight: '700' } }, e('span', null, 'NET'), (row.solo.netRtg >= 0 ? '+' : '') + row.solo.netRtg.toFixed(1)),
                                                        e('div', { className: 'export-wowy-ff-stat', style: { color: '#60a5fa' } }, e('span', null, 'BPM'), row.solo.bpm === null ? 'N/A' : (row.solo.bpm >= 0 ? '+' : '') + row.solo.bpm.toFixed(1)),
                                                        e('div', { className: 'export-wowy-ff-stat', style: { color: '#a78bfa' } }, e('span', null, 'PER'), row.solo.per === null ? 'N/A' : row.solo.per.toFixed(1))
                                                    )
                                                )
                                            ),

                                            // Luck adjustment indicator
                                            (exportWowyOffLuckAdj > 0 || exportWowyDefLuckAdj > 0) && e('div', { style: {
                                                fontSize: '10px', color: '#fbbf24', textAlign: 'center', marginTop: '8px',
                                                padding: '4px', background: 'rgba(251, 191, 36, 0.1)', borderRadius: '4px'
                                            }}, '🎲 Luck Adj: O' + exportWowyOffLuckAdj + '% D' + exportWowyDefLuckAdj + '%')
                                        ))
                                    ),

                                    // Summary footer
                                    teammateResults.length > 0 && e('div', { style: {
                                        marginTop: '24px', padding: '16px', background: 'rgba(139, 92, 246, 0.1)',
                                        borderRadius: '12px', display: 'flex', flexWrap: 'wrap', gap: '24px', justifyContent: 'center'
                                    }},
                                        e('div', { style: { textAlign: 'center' }},
                                            e('div', { style: { fontSize: '10px', color: '#a78bfa', marginBottom: '2px' }}, '🏆 Best Fit (NET)'),
                                            e('div', { style: { fontWeight: 'bold', color: '#22c55e', fontSize: '14px' }},
                                                getDisplayName(teammateResults[0]?.teammate || '', true, teamPlayersArray) + ' (' +
                                                (teammateResults[0]?.delta?.netRtg >= 0 ? '+' : '') +
                                                (teammateResults[0]?.delta?.netRtg?.toFixed(1) || 'N/A') + ')'
                                            )
                                        ),
                                        (() => {
                                            const sortedByBpm = [...teammateResults].filter(d => d.delta?.bpm != null).sort((a, b) => (b.delta?.bpm || 0) - (a.delta?.bpm || 0));
                                            const bestBpm = sortedByBpm[0];
                                            return bestBpm && e('div', { style: { textAlign: 'center' }},
                                                e('div', { style: { fontSize: '10px', color: '#60a5fa', marginBottom: '2px' }}, '📈 Best BPM Impact'),
                                                e('div', { style: { fontWeight: 'bold', color: '#22c55e', fontSize: '14px' }},
                                                    getDisplayName(bestBpm.teammate || '', true, teamPlayersArray) + ' (' +
                                                    (bestBpm.delta?.bpm >= 0 ? '+' : '') + bestBpm.delta?.bpm?.toFixed(1) + ')'
                                                )
                                            );
                                        })(),
                                        // V5.23: Best PER Impact
                                        (() => {
                                            const sortedByPer = [...teammateResults].filter(d => d.delta?.per != null).sort((a, b) => (b.delta?.per || 0) - (a.delta?.per || 0));
                                            const bestPer = sortedByPer[0];
                                            return bestPer && e('div', { style: { textAlign: 'center' }},
                                                e('div', { style: { fontSize: '10px', color: '#a78bfa', marginBottom: '2px' }}, '📊 Best PER Impact'),
                                                e('div', { style: { fontWeight: 'bold', color: '#22c55e', fontSize: '14px' }},
                                                    getDisplayName(bestPer.teammate || '', true, teamPlayersArray) + ' (' +
                                                    (bestPer.delta?.per >= 0 ? '+' : '') + bestPer.delta?.per?.toFixed(1) + ')'
                                                )
                                            );
                                        })(),
                                        teammateResults.length > 1 && e('div', { style: { textAlign: 'center' }},
                                            e('div', { style: { fontSize: '10px', color: '#a78bfa', marginBottom: '2px' }}, '⚠️ Worst Fit (NET)'),
                                            e('div', { style: { fontWeight: 'bold', color: '#ef4444', fontSize: '14px' }},
                                                getDisplayName(teammateResults[teammateResults.length - 1]?.teammate || '', true, teamPlayersArray) + ' (' +
                                                (teammateResults[teammateResults.length - 1]?.delta?.netRtg >= 0 ? '+' : '') +
                                                (teammateResults[teammateResults.length - 1]?.delta?.netRtg?.toFixed(1) || 'N/A') + ')'
                                            )
                                        )
                                    )
                                );
                            }


                            // SINGLE/MULTI PLAYER MODE - V5.6 updated for ON/OFF matrix like main tab
                            const selectedPlayers = exportWowySelectedPlayers.length > 0 ? exportWowySelectedPlayers : [];
                            
                            if (selectedPlayers.length === 0) {
                                return e('div', { style: { textAlign: 'center', padding: '60px', color: '#64748b' }},
                                    e('div', { style: { fontSize: '48px', marginBottom: '16px' }}, '🔄'),
                                    e('div', { style: { fontSize: '18px', fontWeight: '600' }}, 'Select Players'),
                                    e('div', { style: { fontSize: '14px', marginTop: '8px' }}, 'Click on players above to see their WOWY stats (up to 5 players)')
                                );
                            }
                            
                            // V5.6: Helper to get performance class for Four Factors
                            const getPerfClass = (val, stat) => {
                                const thresholds = {
                                    offEfg: [56, 53, 50, 47], defEfg: [47, 50, 53, 56],
                                    offTov: [11, 13, 15, 17], defTov: [17, 15, 13, 11],
                                    offOreb: [30, 27, 24, 21], defOreb: [21, 24, 27, 30],
                                    offFtR: [32, 28, 24, 20], defFtR: [20, 24, 28, 32]
                                }[stat] || [0, 0, 0, 0];
                                const higherBetter = ['offEfg', 'offOreb', 'offFtR', 'defTov'].includes(stat);
                                if (higherBetter) {
                                    if (val >= thresholds[0]) return 'perf-excellent';
                                    if (val >= thresholds[1]) return 'perf-good';
                                    if (val >= thresholds[2]) return 'perf-average';
                                    if (val >= thresholds[3]) return 'perf-below';
                                    return 'perf-poor';
                                } else {
                                    if (val <= thresholds[0]) return 'perf-excellent';
                                    if (val <= thresholds[1]) return 'perf-good';
                                    if (val <= thresholds[2]) return 'perf-average';
                                    if (val <= thresholds[3]) return 'perf-below';
                                    return 'perf-poor';
                                }
                            };
                            
                            // Filter lineups by date and team
                            const teamLineups = lineupData.filter(l => l.Team === currentTeam && matchesDateFilter(l));
                            
                            // V5.6: Generate all ON/OFF combinations for selected players (2^n combinations)
                            const generateOnOffCombinations = (players) => {
                                const n = players.length;
                                const combos = [];
                                // Generate all 2^n combinations
                                for (let i = 0; i < Math.pow(2, n); i++) {
                                    const combo = players.map((p, idx) => ({
                                        name: p,
                                        isOn: Boolean(i & (1 << (n - 1 - idx)))
                                    }));
                                    combos.push(combo);
                                }
                                return combos;
                            };
                            
                            const onOffCombos = generateOnOffCombinations(selectedPlayers);
                            
                            // Calculate stats for each combination
                            const comboStats = onOffCombos.map(combo => {
                                const onPlayers = combo.filter(c => c.isOn).map(c => c.name);
                                const offPlayers = combo.filter(c => !c.isOn).map(c => c.name);
                                
                                const matchingLineups = teamLineups.filter(l => {
                                    const lineupPlayers = parseLineupPlayers(l);
                                    const lineupNorm = lineupPlayers.map(p => normalizePlayerName(p));
                                    
                                    // All "ON" players must be in the lineup
                                    const onMatch = onPlayers.every(p => lineupNorm.some(lp => lp === normalizePlayerName(p)));
                                    // All "OFF" players must NOT be in the lineup  
                                    const offMatch = offPlayers.every(p => !lineupNorm.some(lp => lp === normalizePlayerName(p)));
                                    
                                    return onMatch && offMatch;
                                });
                                
                                const stats = calcWowyStats(matchingLineups);
                                
                                return {
                                    combo,
                                    onPlayers,
                                    offPlayers,
                                    stats,
                                    poss: stats.poss,
                                    mins: stats.mins,
                                    lineupCount: matchingLineups.length,
                                    label: combo.map(c => (c.isOn ? '✓' : '✗')).join('')
                                };
                            }).filter(c => c.mins >= exportWowyMinPoss); // Filter by minutes (consistent with Best Combos)
                            
                            // Find baseline (all players ON) for comparison
                            const baselineCombo = comboStats.find(c => c.onPlayers.length === selectedPlayers.length);
                            const baselineOff = baselineCombo ? baselineCombo.stats.offRtg : 100;
                            const baselineDef = baselineCombo ? baselineCombo.stats.defRtg : 100;
                            
                            // Render compact row for each combination - V5.7 redesigned with grid layout
                            const renderComboRow = (comboData, idx) => {
                                const { combo, stats, poss, mins, lineupCount } = comboData;
                                
                                // Format minutes as MM:SS
                                const formatMins = (m) => {
                                    const totalSecs = Math.round(m * 60);
                                    const mins = Math.floor(totalSecs / 60);
                                    const secs = totalSecs % 60;
                                    return mins + ':' + String(secs).padStart(2, '0');
                                };
                                
                                return e('div', { 
                                    key: idx,
                                    style: { 
                                        background: 'rgba(15, 23, 42, 0.7)', 
                                        borderRadius: '12px', 
                                        padding: '16px',
                                        marginBottom: '12px',
                                        border: '1px solid rgba(71, 85, 105, 0.4)',
                                        display: 'grid',
                                        gridTemplateColumns: 'auto 1fr',
                                        gap: '16px'
                                    }
                                },
                                    // Left side: Player photos
                                    e('div', { style: { display: 'flex', gap: '8px', alignItems: 'center' }},
                                        combo.map((c, j) => e('div', { 
                                            key: j,
                                            style: { 
                                                display: 'flex', 
                                                flexDirection: 'column', 
                                                alignItems: 'center',
                                                cursor: 'pointer'
                                            },
                                            onClick: () => document.getElementById('wowy-matrix-img-' + idx + '-' + j) && document.getElementById('wowy-matrix-img-' + idx + '-' + j).click()
                                        },
                                            e('div', { 
                                                style: { 
                                                    width: '60px', 
                                                    height: '60px', 
                                                    borderRadius: '50%', 
                                                    background: c.isOn ? 'rgba(34, 197, 94, 0.15)' : 'rgba(239, 68, 68, 0.15)',
                                                    border: '4px solid ' + (c.isOn ? '#22c55e' : '#ef4444'),
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    overflow: 'hidden',
                                                    fontSize: '14px',
                                                    fontWeight: '700',
                                                    color: '#fff',
                                                    position: 'relative'
                                                }
                                            },
                                                exportWowyPlayerImages[c.name] 
                                                    ? e('img', { src: exportWowyPlayerImages[c.name], style: { width: '100%', height: '100%', objectFit: 'cover' }})
                                                    : getInitials(c.name),
                                                e('input', { 
                                                    type: 'file', 
                                                    id: 'wowy-matrix-img-' + idx + '-' + j, 
                                                    accept: 'image/*', 
                                                    style: { display: 'none' },
                                                    onChange: (ev) => { ev.stopPropagation(); handleWowyPlayerImageUpload(c.name, ev); }
                                                })
                                            ),
                                            // ON/OFF badge
                                            e('div', { 
                                                style: { 
                                                    marginTop: '-12px',
                                                    fontSize: '9px',
                                                    fontWeight: '800',
                                                    padding: '2px 8px',
                                                    borderRadius: '4px',
                                                    background: c.isOn ? '#22c55e' : '#ef4444',
                                                    color: '#fff',
                                                    zIndex: 1
                                                }
                                            }, c.isOn ? 'ON' : 'OFF'),
                                            // Player name
                                            e('div', { style: { fontSize: '10px', color: '#94a3b8', marginTop: '4px', textAlign: 'center', maxWidth: '65px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}, 
                                                getDisplayName(c.name, true).split(' ').pop()
                                            )
                                        ))
                                    ),
                                    
                                    // Right side: Stats grid
                                    e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 60px) 1fr', gap: '8px', alignItems: 'start' }},
                                        // Row 1: MIN, OFF, DEF, NET, Four Factors Offense
                                        e('div', { style: { textAlign: 'center', padding: '8px', background: 'rgba(30, 41, 59, 0.6)', borderRadius: '8px' }},
                                            e('div', { style: { fontSize: '9px', color: '#64748b', textTransform: 'uppercase', marginBottom: '4px' }}, 'MIN'),
                                            e('div', { style: { fontSize: '16px', fontWeight: '700', color: '#fff' }}, formatMins(mins)),
                                            e('div', { style: { fontSize: '9px', color: '#475569', marginTop: '2px' }}, lineupCount + ' lineups')
                                        ),
                                        e('div', { style: { textAlign: 'center', padding: '8px', background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px' }},
                                            e('div', { style: { fontSize: '9px', color: '#64748b', textTransform: 'uppercase', marginBottom: '4px' }}, 'OFF'),
                                            e('div', { style: { fontSize: '16px', fontWeight: '700', color: '#4ade80' }}, stats.offRtg.toFixed(1))
                                        ),
                                        e('div', { style: { textAlign: 'center', padding: '8px', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '8px' }},
                                            e('div', { style: { fontSize: '9px', color: '#64748b', textTransform: 'uppercase', marginBottom: '4px' }}, 'DEF'),
                                            e('div', { style: { fontSize: '16px', fontWeight: '700', color: '#f87171' }}, stats.defRtg.toFixed(1))
                                        ),
                                        e('div', { style: { textAlign: 'center', padding: '8px', background: stats.netRtg >= 0 ? 'rgba(99, 102, 241, 0.15)' : 'rgba(239, 68, 68, 0.15)', borderRadius: '8px' }},
                                            e('div', { style: { fontSize: '9px', color: '#64748b', textTransform: 'uppercase', marginBottom: '4px' }}, 'NET'),
                                            e('div', { style: { fontSize: '18px', fontWeight: '800', color: stats.netRtg >= 0 ? '#818cf8' : '#f87171' }}, 
                                                (stats.netRtg >= 0 ? '+' : '') + stats.netRtg.toFixed(1)
                                            )
                                        ),
                                        
                                        // Four Factors Grid (spans row)
                                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '6px', gridRow: 'span 2' }},
                                            // Offense section
                                            e('div', { style: { background: 'rgba(34, 197, 94, 0.05)', borderRadius: '8px', padding: '8px' }},
                                                e('div', { style: { fontSize: '9px', fontWeight: '700', color: '#4ade80', marginBottom: '6px', textAlign: 'center' }}, '✕ OFFENSE'),
                                                e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '4px' }},
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + getPerfClass(stats.offEfg, 'offEfg'),
                                                        style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }
                                                    },
                                                        e('div', { style: { fontSize: '8px', color: '#94a3b8' }}, 'eFG%'),
                                                        e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, stats.offEfg.toFixed(1))
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + getPerfClass(stats.offTov, 'offTov'),
                                                        style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }
                                                    },
                                                        e('div', { style: { fontSize: '8px', color: '#94a3b8' }}, 'TOV%'),
                                                        e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, stats.offTov.toFixed(1))
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + getPerfClass(stats.offOreb, 'offOreb'),
                                                        style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }
                                                    },
                                                        e('div', { style: { fontSize: '8px', color: '#94a3b8' }}, 'OREB%'),
                                                        e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, stats.offOreb.toFixed(1))
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + getPerfClass(stats.offFtR, 'offFtR'),
                                                        style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }
                                                    },
                                                        e('div', { style: { fontSize: '8px', color: '#94a3b8' }}, 'FTR'),
                                                        e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, stats.offFtR.toFixed(1))
                                                    )
                                                )
                                            ),
                                            // Defense section
                                            e('div', { style: { background: 'rgba(96, 165, 250, 0.05)', borderRadius: '8px', padding: '8px' }},
                                                e('div', { style: { fontSize: '9px', fontWeight: '700', color: '#60a5fa', marginBottom: '6px', textAlign: 'center' }}, '◯ DEFENSE'),
                                                e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '4px' }},
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + getPerfClass(stats.defEfg, 'defEfg'),
                                                        style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }
                                                    },
                                                        e('div', { style: { fontSize: '8px', color: '#94a3b8' }}, 'Opp eFG'),
                                                        e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, stats.defEfg.toFixed(1))
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + getPerfClass(stats.defTov, 'defTov'),
                                                        style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }
                                                    },
                                                        e('div', { style: { fontSize: '8px', color: '#94a3b8' }}, 'Frc TO'),
                                                        e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, stats.defTov.toFixed(1))
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + getPerfClass(stats.defOreb, 'defOreb'),
                                                        style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }
                                                    },
                                                        e('div', { style: { fontSize: '8px', color: '#94a3b8' }}, 'Opp ORB'),
                                                        e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, stats.defOreb.toFixed(1))
                                                    ),
                                                    e('div', { 
                                                        className: 'export-ff-stat-box ' + getPerfClass(stats.defFtR, 'defFtR'),
                                                        style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }
                                                    },
                                                        e('div', { style: { fontSize: '8px', color: '#94a3b8' }}, 'Opp FTR'),
                                                        e('div', { style: { fontSize: '12px', fontWeight: '700', color: '#fff' }}, stats.defFtR.toFixed(1))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                );
                            };
                            
                            return e('div', null,
                                // Header
                                e('div', { style: { textAlign: 'center', marginBottom: '20px' }},
                                    e('div', { style: { fontSize: '20px', fontWeight: '700', color: '#fff' }}, 
                                        selectedPlayers.map(p => getDisplayName(p, true)).join(' & ')
                                    ),
                                    e('div', { style: { fontSize: '14px', color: '#60a5fa', marginTop: '4px' }}, currentTeam),
                                    e('div', { style: { fontSize: '11px', color: '#64748b', marginTop: '4px' }}, 
                                        comboStats.length + ' of ' + Math.pow(2, selectedPlayers.length) + ' combinations with ' + exportWowyMinPoss + '+ minutes'
                                    )
                                ),
                                
                                // Combo rows
                                e('div', null,
                                    comboStats.map((c, i) => renderComboRow(c, i))
                                )
                            );
                        })(),
                        
                        // WOWY Legend
                        exportMode === 'wowy' && exportShowLegend && e('div', { style: { marginTop: '16px', padding: '10px 14px', background: 'rgba(15, 23, 42, 0.8)', borderRadius: '8px', border: '1px solid #334155' }},
                            e('div', { style: { fontSize: '10px', color: '#64748b', marginBottom: '6px', fontWeight: '600' }}, '📊 WOWY LEGEND (With Or Without You)'),
                            e('div', { style: { fontSize: '9px', color: '#94a3b8', lineHeight: '1.5' }},
                                e('div', { style: { marginBottom: '4px' }},
                                    e('span', { style: { color: '#4ade80', fontWeight: '600' }}, 'ON: '),
                                    'Team stats when selected player(s) are on court'
                                ),
                                e('div', { style: { marginBottom: '4px' }},
                                    e('span', { style: { color: '#f87171', fontWeight: '600' }}, 'OFF: '),
                                    'Team stats when selected player(s) are on bench'
                                ),
                                e('div', { style: { marginBottom: '4px' }},
                                    e('span', { style: { color: '#60a5fa', fontWeight: '600' }}, 'DIFF: '),
                                    'ON minus OFF (positive = player helps team)'
                                ),
                                e('div', { style: { marginBottom: '4px' }},
                                    e('span', { style: { color: '#f59e0b', fontWeight: '600' }}, '⚠️ No OFF: '),
                                    'At least one player from combo always on court (no comparison possible)'
                                ),
                                e('div', { style: { marginBottom: '4px' }},
                                    e('span', { style: { color: '#94a3b8', fontWeight: '600' }}, 'SHOT Bar: '),
                                    'Rim / Mid / 3PT distribution — segment color shows FG% quality (',
                                    e('span', { style: { color: '#4ade80' }}, 'green'), '=excellent, ',
                                    e('span', { style: { color: '#eab308' }}, 'yellow'), '=good, ',
                                    e('span', { style: { color: '#f97316' }}, 'orange'), '=below avg, ',
                                    e('span', { style: { color: '#ef4444' }}, 'red'), '=poor)'
                                ),
                                (exportWowyOffLuckAdj > 0 || exportWowyDefLuckAdj > 0) && e('div', { style: { marginBottom: '4px', color: '#fbbf24' }},
                                    e('span', { style: { fontWeight: '600' }}, '🎲 Luck Adj: '),
                                    exportWowyOffLuckAdj > 0 && e('span', { style: { color: '#4ade80' }}, 'Off ' + exportWowyOffLuckAdj + '%'),
                                    exportWowyOffLuckAdj > 0 && exportWowyDefLuckAdj > 0 && ' | ',
                                    exportWowyDefLuckAdj > 0 && e('span', { style: { color: '#f87171' }}, 'Def ' + exportWowyDefLuckAdj + '%'),
                                    ' — Regresses 3PT% toward 36% league avg'
                                ),
                                e('div', { style: { borderTop: '1px solid #334155', paddingTop: '4px', marginTop: '4px', color: '#64748b' }},
                                    exportWowyMode === 'single' 
                                        ? '👤 Single Player Mode: Shows how team performs with vs without each player'
                                        : exportWowyMode === 'pair'
                                            ? '👥 Pair Mode: Shows combined impact when both selected players are together vs apart'
                                            : (exportWowySortAsc ? '📉 Worst' : '🏆 Best') + ' Combos Mode: Ranks ' + exportWowyCombosSize + '-player combinations by net rating differential (' + (exportWowySortAsc ? 'worst' : 'best') + ' first, min ' + exportWowyMinPoss + ' min)'
                                )
                            )
                        ),
                        
                        // Footer
                        e('div', { className: 'export-frame-footer' },
                            e('div', { className: 'export-frame-branding' }, 'Basketball Analytics • Advanced Stats • @theslbshow')
                        )
                    )
                ),
                // V5.0: Stat Impact Analysis Tab Content
                activeTab === 'statimpact' && matchupData.length > 0 && e('div', null,
                    // Team and analysis controls
                    e('div', { className: 'controls', style: { marginBottom: '24px' }},
                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '16px', alignItems: 'end' }},
                            e('div', { className: 'form-group', style: { marginBottom: 0 }},
                                e('label', null, 'Team'),
                                e('select', { 
                                    value: team, 
                                    onChange: ev => setTeam(ev.target.value)
                                }, 
                                    teams.map(t => e('option', { key: t, value: t }, t))
                                )
                            ),
                            e('div', { className: 'form-group', style: { marginBottom: 0 }},
                                e('label', null, 'Opponent (Optional)'),
                                e('select', { 
                                    value: statImpactOpp || '', 
                                    onChange: ev => setStatImpactOpp(ev.target.value || null),
                                    style: { background: statImpactOpp ? 'rgba(249, 115, 22, 0.2)' : '#0f172a' }
                                }, 
                                    e('option', { value: '' }, '-- All Opponents --'),
                                    teams.filter(t => t !== team).map(t => e('option', { key: t, value: t }, t))
                                )
                            ),
                            e('div', { className: 'form-group', style: { marginBottom: 0 }},
                                e('label', null, 'Min Possessions'),
                                e('input', { 
                                    type: 'number',
                                    value: statImpactMinPoss,
                                    onChange: ev => setStatImpactMinPoss(Math.max(1, parseInt(ev.target.value) || 1)),
                                    min: 1,
                                    style: { width: '100px' }
                                })
                            ),
                            e('button', {
                                className: 'btn btn-impact',
                                style: { 
                                    padding: '12px 24px', 
                                    fontSize: '14px',
                                    background: 'linear-gradient(135deg, #f97316 0%, #ea580c 100%)',
                                    border: 'none',
                                    cursor: isCalculatingImpact ? 'wait' : 'pointer'
                                },
                                onClick: () => calculateStatImpact(statImpactOpp),
                                disabled: isCalculatingImpact
                            }, isCalculatingImpact ? '⏳ Analyzing...' : '🔬 Run Analysis')
                        )
                    ),
                    // Results display (inline, not modal)
                    statImpactResults && !statImpactResults.error && e('div', null,
                        // Summary stats with R²
                        e('div', { 
                            style: { 
                                display: 'grid', 
                                gridTemplateColumns: 'repeat(6, 1fr)', 
                                gap: '12px', 
                                marginBottom: '24px' 
                            }
                        },
                            e('div', { style: { background: 'rgba(59, 130, 246, 0.15)', padding: '16px', borderRadius: '10px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '4px' }}, 'Matchups'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#60a5fa' }}, statImpactResults.matchupCount)
                            ),
                            e('div', { style: { background: 'rgba(34, 197, 94, 0.15)', padding: '16px', borderRadius: '10px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '4px' }}, 'Avg ORTG'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#4ade80' }}, statImpactResults.avgOffRtg.toFixed(1))
                            ),
                            e('div', { style: { background: 'rgba(239, 68, 68, 0.15)', padding: '16px', borderRadius: '10px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '4px' }}, 'Avg DRTG'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#f87171' }}, statImpactResults.avgDefRtg.toFixed(1))
                            ),
                            e('div', { style: { background: 'rgba(168, 85, 247, 0.15)', padding: '16px', borderRadius: '10px', textAlign: 'center' }},
                                e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '4px' }}, 'Net Rtg'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: statImpactResults.avgNetRtg >= 0 ? '#4ade80' : '#f87171' }}, 
                                    (statImpactResults.avgNetRtg >= 0 ? '+' : '') + statImpactResults.avgNetRtg.toFixed(1)
                                )
                            ),
                            e('div', { style: { background: 'rgba(34, 197, 94, 0.25)', padding: '16px', borderRadius: '10px', textAlign: 'center', border: '1px solid rgba(34, 197, 94, 0.5)' }},
                                e('div', { style: { fontSize: '11px', color: '#86efac', marginBottom: '4px' }}, 'Off 4F R²'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#4ade80' }}, 
                                    statImpactResults.offR2 ? (statImpactResults.offR2 * 100).toFixed(1) + '%' : 'N/A'
                                )
                            ),
                            e('div', { style: { background: 'rgba(239, 68, 68, 0.25)', padding: '16px', borderRadius: '10px', textAlign: 'center', border: '1px solid rgba(239, 68, 68, 0.5)' }},
                                e('div', { style: { fontSize: '11px', color: '#fca5a5', marginBottom: '4px' }}, 'Def 4F R²'),
                                e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#f87171' }}, 
                                    statImpactResults.defR2 ? (statImpactResults.defR2 * 100).toFixed(1) + '%' : 'N/A'
                                )
                            )
                        ),
                        // Target opponent indicator
                        statImpactResults.targetOppTeam && e('div', { 
                            style: { 
                                marginBottom: '16px', 
                                padding: '12px 16px', 
                                background: 'rgba(249, 115, 22, 0.15)', 
                                border: '1px solid rgba(249, 115, 22, 0.4)', 
                                borderRadius: '8px',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px'
                            }
                        },
                            e('span', { style: { fontSize: '14px' }}, '🎯'),
                            e('span', { style: { color: '#fb923c', fontWeight: 'bold' }}, 'Analysis vs ' + statImpactResults.targetOppTeam),
                            e('span', { style: { color: '#94a3b8', fontSize: '12px', marginLeft: '8px' }}, 
                                '(' + statImpactResults.matchupCount + ' matchups)'
                            )
                        ),
                        // Two columns: Offense and Defense Impact
                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '24px' }},
                            // OFFENSIVE IMPACT
                            e('div', { 
                                style: { 
                                    background: 'rgba(34, 197, 94, 0.08)', 
                                    border: '1px solid rgba(34, 197, 94, 0.3)', 
                                    borderRadius: '12px', 
                                    padding: '20px' 
                                }
                            },
                                e('h3', { style: { color: '#4ade80', marginBottom: '8px', fontSize: '18px' }}, 
                                    '📈 Offensive Rating Drivers'
                                ),
                                e('p', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '16px' }}, 
                                    'Four Factors ranked by Dominance % (unbiased variance decomposition). Other stats by bivariate r.'
                                ),
                                statImpactResults.offenseImpacts.map((stat, i) => e('div', { 
                                    key: i,
                                    style: { 
                                        background: stat.isFourFactor ? 'rgba(34, 197, 94, 0.1)' : 'rgba(0,0,0,0.2)', 
                                        borderRadius: '8px', 
                                        padding: '12px', 
                                        marginBottom: '8px',
                                        borderLeft: stat.isFourFactor ? '4px solid #4ade80' : '4px solid #475569'
                                    }
                                },
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' }},
                                        e('div', null,
                                            e('span', { style: { fontWeight: 'bold', color: '#e2e8f0', fontSize: '14px' }}, stat.name),
                                            stat.isFourFactor && e('span', { style: { marginLeft: '6px', background: 'rgba(34, 197, 94, 0.3)', padding: '2px 6px', borderRadius: '4px', fontSize: '9px', color: '#4ade80' }}, '4F'),
                                            i === 0 && e('span', { style: { marginLeft: '6px', background: 'rgba(251, 191, 36, 0.3)', padding: '2px 6px', borderRadius: '4px', fontSize: '9px', color: '#fbbf24' }}, '🏆')
                                        ),
                                        stat.isFourFactor && stat.dominancePct !== null ? 
                                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                                e('div', { 
                                                    style: { 
                                                        fontWeight: 'bold', 
                                                        fontSize: '16px',
                                                        color: stat.dominancePct >= 30 ? '#4ade80' : stat.dominancePct >= 20 ? '#fbbf24' : '#94a3b8',
                                                        background: 'rgba(34, 197, 94, 0.2)',
                                                        padding: '2px 8px',
                                                        borderRadius: '4px'
                                                    }
                                                }, stat.dominancePct.toFixed(1) + '%'),
                                                e('span', { style: { fontSize: '10px', color: '#64748b' }}, 'Dom')
                                            ) :
                                            e('div', { 
                                                style: { 
                                                    fontWeight: 'bold', 
                                                    fontSize: '14px',
                                                    color: Math.abs(stat.correlation) >= 0.5 ? '#4ade80' : Math.abs(stat.correlation) >= 0.3 ? '#fbbf24' : '#94a3b8'
                                                }
                                            }, 'r=' + (stat.correlation >= 0 ? '+' : '') + stat.correlation.toFixed(2))
                                    ),
                                    e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '6px' }}, stat.description),
                                    stat.isFourFactor && e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '6px', marginTop: '8px' }},
                                        e('div', { style: { background: 'rgba(0,0,0,0.3)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'Partial R²'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#a78bfa' }}, 
                                                stat.partialR2 !== null ? (stat.partialR2 * 100).toFixed(1) + '%' : '-'
                                            )
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.3)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'β (std)'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: stat.betaStd > 0 ? '#4ade80' : '#f87171' }}, 
                                                stat.betaStd !== null ? (stat.betaStd >= 0 ? '+' : '') + stat.betaStd.toFixed(2) : '-'
                                            )
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.3)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'Avg'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#e2e8f0' }}, stat.mean.toFixed(1))
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.3)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'r (bivar)'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#94a3b8' }}, 
                                                (stat.correlation >= 0 ? '+' : '') + stat.correlation.toFixed(2)
                                            )
                                        )
                                    ),
                                    stat.isFourFactor && stat.betaCiLow !== null && e('div', { 
                                        style: { marginTop: '6px', fontSize: '9px', color: '#64748b', textAlign: 'center' }
                                    }, '95% CI for β: [' + stat.betaCiLow.toFixed(2) + ', ' + stat.betaCiHigh.toFixed(2) + ']'),
                                    !stat.isFourFactor && e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '6px', marginTop: '8px' }},
                                        e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'Avg'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#e2e8f0' }}, stat.mean.toFixed(1))
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'ORTG@Low'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: stat.ortgAtLow < stat.ortgAtHigh ? '#f87171' : '#4ade80' }}, stat.ortgAtLow.toFixed(1))
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'ORTG@High'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: stat.ortgAtHigh > stat.ortgAtLow ? '#4ade80' : '#f87171' }}, stat.ortgAtHigh.toFixed(1))
                                        )
                                    )
                                ))
                            ),
                            // DEFENSIVE IMPACT
                            e('div', { 
                                style: { 
                                    background: 'rgba(239, 68, 68, 0.08)', 
                                    border: '1px solid rgba(239, 68, 68, 0.3)', 
                                    borderRadius: '12px', 
                                    padding: '20px' 
                                }
                            },
                                e('h3', { style: { color: '#f87171', marginBottom: '8px', fontSize: '18px' }}, 
                                    '🛡️ Defensive Rating Drivers'
                                ),
                                e('p', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '16px' }}, 
                                    'Four Factors ranked by Dominance %. Lower DRTG = better defense.'
                                ),
                                statImpactResults.defenseImpacts.map((stat, i) => e('div', { 
                                    key: i,
                                    style: { 
                                        background: stat.isFourFactor ? 'rgba(239, 68, 68, 0.1)' : 'rgba(0,0,0,0.2)', 
                                        borderRadius: '8px', 
                                        padding: '12px', 
                                        marginBottom: '8px',
                                        borderLeft: stat.isFourFactor ? '4px solid #f87171' : '4px solid #475569'
                                    }
                                },
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' }},
                                        e('div', null,
                                            e('span', { style: { fontWeight: 'bold', color: '#e2e8f0', fontSize: '14px' }}, stat.name),
                                            stat.isFourFactor && e('span', { style: { marginLeft: '6px', background: 'rgba(239, 68, 68, 0.3)', padding: '2px 6px', borderRadius: '4px', fontSize: '9px', color: '#f87171' }}, '4F'),
                                            i === 0 && e('span', { style: { marginLeft: '6px', background: 'rgba(251, 191, 36, 0.3)', padding: '2px 6px', borderRadius: '4px', fontSize: '9px', color: '#fbbf24' }}, '🏆')
                                        ),
                                        stat.isFourFactor && stat.dominancePct !== null ? 
                                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                                e('div', { 
                                                    style: { 
                                                        fontWeight: 'bold', 
                                                        fontSize: '16px',
                                                        color: stat.dominancePct >= 30 ? '#f87171' : stat.dominancePct >= 20 ? '#fbbf24' : '#94a3b8',
                                                        background: 'rgba(239, 68, 68, 0.2)',
                                                        padding: '2px 8px',
                                                        borderRadius: '4px'
                                                    }
                                                }, stat.dominancePct.toFixed(1) + '%'),
                                                e('span', { style: { fontSize: '10px', color: '#64748b' }}, 'Dom')
                                            ) :
                                            e('div', { 
                                                style: { 
                                                    fontWeight: 'bold', 
                                                    fontSize: '14px',
                                                    color: Math.abs(stat.correlation) >= 0.5 ? '#f87171' : Math.abs(stat.correlation) >= 0.3 ? '#fbbf24' : '#94a3b8'
                                                }
                                            }, 'r=' + (stat.correlation >= 0 ? '+' : '') + stat.correlation.toFixed(2))
                                    ),
                                    e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '6px' }}, stat.description),
                                    stat.isFourFactor && e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '6px', marginTop: '8px' }},
                                        e('div', { style: { background: 'rgba(0,0,0,0.3)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'Partial R²'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#a78bfa' }}, 
                                                stat.partialR2 !== null ? (stat.partialR2 * 100).toFixed(1) + '%' : '-'
                                            )
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.3)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'β (std)'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: stat.betaStd > 0 ? '#f87171' : '#4ade80' }}, 
                                                stat.betaStd !== null ? (stat.betaStd >= 0 ? '+' : '') + stat.betaStd.toFixed(2) : '-'
                                            )
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.3)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'Avg'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#e2e8f0' }}, stat.mean.toFixed(1))
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.3)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'r (bivar)'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#94a3b8' }}, 
                                                (stat.correlation >= 0 ? '+' : '') + stat.correlation.toFixed(2)
                                            )
                                        )
                                    ),
                                    stat.isFourFactor && stat.betaCiLow !== null && e('div', { 
                                        style: { marginTop: '6px', fontSize: '9px', color: '#64748b', textAlign: 'center' }
                                    }, '95% CI for β: [' + stat.betaCiLow.toFixed(2) + ', ' + stat.betaCiHigh.toFixed(2) + ']'),
                                    !stat.isFourFactor && e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '6px', marginTop: '8px' }},
                                        e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'Avg'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#e2e8f0' }}, stat.mean.toFixed(1))
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'DRTG@Low'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: stat.drtgAtLow < stat.drtgAtHigh ? '#4ade80' : '#f87171' }}, stat.drtgAtLow.toFixed(1))
                                        ),
                                        e('div', { style: { background: 'rgba(0,0,0,0.2)', padding: '6px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#64748b' }}, 'DRTG@High'),
                                            e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: stat.drtgAtHigh < stat.drtgAtLow ? '#4ade80' : '#f87171' }}, stat.drtgAtHigh.toFixed(1))
                                        )
                                    )
                                ))
                            )
                        ),
                        // Methodology guide
                        e('div', { 
                            style: { 
                                marginTop: '24px', 
                                padding: '20px', 
                                background: 'rgba(251, 191, 36, 0.1)', 
                                border: '1px solid rgba(251, 191, 36, 0.3)', 
                                borderRadius: '12px' 
                            }
                        },
                            e('h4', { style: { color: '#fbbf24', marginBottom: '12px', fontSize: '16px' }}, '📖 V5.0 Methodology Guide'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '16px', fontSize: '12px', color: '#94a3b8', lineHeight: '1.7' }},
                                e('div', null,
                                    e('p', null, e('strong', { style: { color: '#4ade80' }}, '🎯 Dominance %'), ' - Budescu (1993) methodology. Properly decomposes variance when predictors are correlated. Replaces biased bivariate correlations.'),
                                    e('p', { style: { marginTop: '8px' }}, e('strong', { style: { color: '#a78bfa' }}, 'Partial R²'), ' - Unique variance explained after controlling for all other Four Factors. High = this factor explains variance others cannot.'),
                                    e('p', { style: { marginTop: '8px' }}, e('strong', { style: { color: '#60a5fa' }}, 'β (standardized)'), ' - Multiple regression coefficient. Expected Δrating per 1 SD change, holding other factors constant.')
                                ),
                                e('div', null,
                                    e('p', null, e('strong', { style: { color: '#94a3b8' }}, 'r (bivariate)'), ' - Simple correlation for reference. ⚠️ May be biased due to omitted variable bias when stats are correlated.'),
                                    e('p', { style: { marginTop: '8px' }}, e('strong', { style: { color: '#f87171' }}, '📊 Model Fit R²'), ' - How much variance Four Factors explain together. Dean Oliver research shows ~90% at team level.'),
                                    e('p', { style: { marginTop: '8px' }}, e('strong', { style: { color: '#fbbf24' }}, '💡 Key Insight'), ' - Focus on Dominance % for Four Factors. It properly accounts for overlapping variance between eFG%, TOV%, OREB%, and FT Rate.')
                                )
                            )
                        )
                    ),
                    // Error state
                    statImpactResults && statImpactResults.error && e('div', { 
                        style: { 
                            padding: '24px', 
                            background: 'rgba(239, 68, 68, 0.15)', 
                            border: '1px solid rgba(239, 68, 68, 0.4)',
                            borderRadius: '12px', 
                            color: '#fca5a5',
                            textAlign: 'center'
                        }
                    }, 
                        e('div', { style: { fontSize: '48px', marginBottom: '12px' }}, '⚠️'),
                        e('div', { style: { fontSize: '16px', fontWeight: 'bold', marginBottom: '8px' }}, 'Insufficient Data'),
                        e('div', { style: { fontSize: '14px' }}, statImpactResults.error)
                    ),
                    // Initial state - no results yet
                    !statImpactResults && e('div', { 
                        style: { 
                            padding: '48px', 
                            background: 'rgba(249, 115, 22, 0.08)', 
                            border: '2px dashed rgba(249, 115, 22, 0.3)',
                            borderRadius: '12px', 
                            textAlign: 'center'
                        }
                    }, 
                        e('div', { style: { fontSize: '64px', marginBottom: '16px' }}, '🔬'),
                        e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: '#fb923c', marginBottom: '8px' }}, 'Ready to Analyze'),
                        e('div', { style: { fontSize: '14px', color: '#94a3b8' }}, 
                            'Select a team and click "Run Analysis" to identify which stats most influence lineup ratings.'
                        ),
                        e('div', { style: { fontSize: '12px', color: '#64748b', marginTop: '12px' }}, 
                            'Requires matchup data with at least 30 matchups for reliable estimates.'
                        )
                    ),
                    // V5.0: Lineup Optimization Tools (moved from Lineup Analyzer)
                    e('div', { 
                        style: { 
                            marginTop: '32px',
                            background: 'linear-gradient(135deg, rgba(124, 58, 237, 0.1), rgba(34, 211, 238, 0.08))', 
                            border: '2px solid rgba(124, 58, 237, 0.3)', 
                            borderRadius: '12px', 
                            padding: '20px'
                        }
                    },
                        e('h3', { style: { color: '#a78bfa', marginBottom: '16px', fontSize: '18px' }}, '🏆 Lineup Optimization Tools'),
                        e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', flexWrap: 'wrap', gap: '16px' }},
                            // Best Combinations vs Opponent
                            e('div', { style: { flex: '1', minWidth: '400px' }},
                                e('div', { style: { color: '#f97316', fontWeight: 'bold', fontSize: '14px', marginBottom: '8px' }}, 
                                    '🏆 Best Player Combinations vs Opponent'
                                ),
                                e('p', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '12px' }}, 
                                    'Find optimal player combos based on stat impact analysis against a specific team'
                                ),
                                e('div', { style: { display: 'flex', gap: '12px', flexWrap: 'wrap', alignItems: 'flex-end' }},
                                    e('div', null,
                                        e('label', { style: { fontSize: '11px', color: '#c4b5fd', display: 'block', marginBottom: '4px' }}, 'Opponent Team'),
                                        e('select', { 
                                            value: combosOppTeam, 
                                            onChange: ev => setCombosOppTeam(ev.target.value),
                                            style: { padding: '8px', minWidth: '150px', background: '#0f172a', border: '1px solid #475569', borderRadius: '6px', color: 'white', fontSize: '12px' }
                                        }, 
                                            e('option', { value: '' }, '-- Select --'),
                                            teams.filter(t => t !== team).map(t => e('option', { key: t, value: t }, t))
                                        )
                                    ),
                                    e('div', null,
                                        e('label', { style: { fontSize: '11px', color: '#c4b5fd', display: 'block', marginBottom: '4px' }}, 'Combo Size'),
                                        e('select', { 
                                            value: combosSize, 
                                            onChange: ev => setCombosSize(parseInt(ev.target.value)),
                                            style: { padding: '8px', minWidth: '80px', background: '#0f172a', border: '1px solid #475569', borderRadius: '6px', color: 'white', fontSize: '12px' }
                                        }, 
                                            [2, 3, 4, 5].map(n => e('option', { key: n, value: n }, n + '-man'))
                                        )
                                    ),
                                    e('div', null,
                                        e('label', { style: { fontSize: '11px', color: '#c4b5fd', display: 'block', marginBottom: '4px' }}, 'Min Poss'),
                                        e('input', { 
                                            type: 'number',
                                            value: combosMinPoss, 
                                            onChange: ev => setCombosMinPoss(Math.max(1, parseInt(ev.target.value) || 1)),
                                            min: 1,
                                            style: { padding: '8px', width: '60px', background: '#0f172a', border: '1px solid #475569', borderRadius: '6px', color: 'white', fontSize: '12px' }
                                        })
                                    ),
                                    e('button', {
                                        className: 'btn',
                                        style: { 
                                            background: combosOppTeam ? 'linear-gradient(135deg, #7c3aed, #a855f7)' : 'rgba(124, 58, 237, 0.3)',
                                            color: 'white',
                                            fontSize: '12px',
                                            padding: '10px 20px',
                                            border: 'none',
                                            borderRadius: '8px',
                                            cursor: combosOppTeam && !isCalculatingCombos ? 'pointer' : 'not-allowed',
                                            fontWeight: 'bold',
                                            opacity: combosOppTeam ? 1 : 0.6
                                        },
                                        onClick: calculateBestCombos,
                                        disabled: !combosOppTeam || isCalculatingCombos
                                    }, isCalculatingCombos ? '⏳ Calculating...' : '🏆 Find Best Combos')
                                )
                            ),
                            // Counter Lineups vs Selected Players
                            e('div', { style: { flex: '1', minWidth: '450px', paddingLeft: '20px', borderLeft: '1px solid rgba(34, 211, 238, 0.3)' }},
                                e('div', { style: { color: '#22d3ee', fontWeight: 'bold', fontSize: '14px', marginBottom: '8px' }}, 
                                    '🎯 Best Combos vs Selected Players'
                                ),
                                e('p', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '12px' }}, 
                                    'Find optimal player combinations for a team against lineups with specific opponent players'
                                ),
                                e('div', { style: { display: 'flex', gap: '12px', flexWrap: 'wrap', alignItems: 'flex-end' }},
                                    e('div', null,
                                        e('label', { style: { fontSize: '11px', color: '#67e8f9', display: 'block', marginBottom: '4px' }}, 'Team to Analyze'),
                                        e('select', { 
                                            value: counterTeam, 
                                            onChange: ev => setCounterTeam(ev.target.value),
                                            style: { padding: '8px', minWidth: '150px', background: '#0f172a', border: '1px solid #475569', borderRadius: '6px', color: 'white', fontSize: '12px' }
                                        }, 
                                            e('option', { value: '' }, '-- Select Team --'),
                                            teams.map(t => e('option', { key: t, value: t }, t))
                                        )
                                    ),
                                    e('div', null,
                                        e('label', { style: { fontSize: '11px', color: '#67e8f9', display: 'block', marginBottom: '4px' }}, 'Combo Size'),
                                        e('select', { 
                                            value: counterComboSize, 
                                            onChange: ev => setCounterComboSize(parseInt(ev.target.value)),
                                            style: { padding: '8px', minWidth: '80px', background: '#0f172a', border: '1px solid #475569', borderRadius: '6px', color: 'white', fontSize: '12px' }
                                        }, 
                                            [2, 3, 4, 5].map(n => e('option', { key: n, value: n }, n + '-man'))
                                        )
                                    ),
                                    e('div', null,
                                        e('label', { style: { fontSize: '11px', color: '#67e8f9', display: 'block', marginBottom: '4px' }}, 'Min Poss'),
                                        e('input', { 
                                            type: 'number',
                                            value: counterMinPoss, 
                                            onChange: ev => setCounterMinPoss(Math.max(1, parseInt(ev.target.value) || 1)),
                                            min: 1,
                                            style: { padding: '8px', width: '60px', background: '#0f172a', border: '1px solid #475569', borderRadius: '6px', color: 'white', fontSize: '12px' }
                                        })
                                    )
                                ),
                                e('div', { style: { marginTop: '10px', display: 'flex', gap: '12px', alignItems: 'center', flexWrap: 'wrap' }},
                                    e('div', null,
                                        e('label', { style: { fontSize: '11px', color: '#67e8f9', display: 'block', marginBottom: '4px' }}, 'Include Players'),
                                        e('input', { 
                                            type: 'text',
                                            value: counterIncludePlayers,
                                            onChange: ev => setCounterIncludePlayers(ev.target.value),
                                            placeholder: 'e.g. LeBron, Davis',
                                            style: { padding: '8px', minWidth: '150px', background: '#0f172a', border: '1px solid #475569', borderRadius: '6px', color: 'white', fontSize: '12px' }
                                        })
                                    ),
                                    e('button', {
                                        className: 'btn',
                                        style: { 
                                            background: counterTeam ? 'linear-gradient(135deg, #0891b2, #22d3ee)' : 'rgba(34, 211, 238, 0.3)',
                                            color: 'white',
                                            fontSize: '12px',
                                            padding: '10px 20px',
                                            border: 'none',
                                            borderRadius: '8px',
                                            cursor: counterTeam && !isCalculatingCounter ? 'pointer' : 'not-allowed',
                                            fontWeight: 'bold',
                                            opacity: counterTeam ? 1 : 0.6
                                        },
                                        onClick: calculateCounterLineups,
                                        disabled: !counterTeam || isCalculatingCounter
                                    }, isCalculatingCounter ? '⏳ Calculating...' : '🎯 Find Best Combos')
                                )
                            )
                        ),
                        // Player Impact Correlation
                        e('div', { 
                            style: { 
                                marginTop: '16px',
                                display: 'flex',
                                gap: '16px',
                                flexWrap: 'wrap',
                                padding: '16px',
                                background: 'rgba(34, 197, 94, 0.08)',
                                border: '1px solid rgba(34, 197, 94, 0.3)',
                                borderRadius: '8px'
                            }
                        },
                            e('div', { style: { flex: '1', minWidth: '280px' }},
                                e('div', { style: { color: '#4ade80', fontWeight: 'bold', fontSize: '14px', marginBottom: '8px' }}, 
                                    '📊 Player Impact Correlation'
                                ),
                                e('p', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '12px' }},
                                    'Correlate individual player stats with lineup ORTG/DRTG to identify most impactful behaviors. ' +
                                    (playerData.length > 0 ? '(' + playerData.length + ' player-lineup records)' : '⚠️ Load player_lineup_stats_enhanced CSV')
                                ),
                                e('div', { style: { display: 'flex', gap: '12px', alignItems: 'flex-end', flexWrap: 'wrap' }},
                                    e('div', null,
                                        e('label', { style: { fontSize: '11px', color: '#86efac', display: 'block', marginBottom: '4px' }}, 'Filter Player'),
                                        e('select', { 
                                            value: playerImpactPlayer, 
                                            onChange: ev => setPlayerImpactPlayer(ev.target.value),
                                            style: { padding: '8px', minWidth: '150px', background: '#0f172a', border: '1px solid #475569', borderRadius: '6px', color: 'white', fontSize: '12px' }
                                        }, 
                                            e('option', { value: '' }, '-- All Players --'),
                                            [...new Set(playerData.filter(d => !team || d.Team === team).map(d => d.Player))].sort().map(p => 
                                                e('option', { key: p, value: p }, p)
                                            )
                                        )
                                    ),
                                    e('button', {
                                        className: 'btn',
                                        style: { 
                                            background: playerData.length > 0 ? 'linear-gradient(135deg, #16a34a, #4ade80)' : 'rgba(34, 197, 94, 0.3)',
                                            color: 'white',
                                            fontSize: '12px',
                                            padding: '10px 20px',
                                            border: 'none',
                                            borderRadius: '8px',
                                            cursor: playerData.length > 0 ? 'pointer' : 'not-allowed',
                                            fontWeight: 'bold',
                                            opacity: playerData.length > 0 ? 1 : 0.6
                                        },
                                        onClick: () => calculatePlayerImpactCorrelation(playerImpactPlayer || null),
                                        disabled: playerData.length === 0
                                    }, '📊 Analyze Player Impact')
                                )
                            ),
                            e('div', { style: { fontSize: '10px', color: '#94a3b8', maxWidth: '350px', alignSelf: 'center' }},
                                'Uses player_lineup_stats_enhanced CSV to find which individual stats (FG%, AST, TOV, etc.) correlate most strongly with lineup success. ',
                                'Select a player to see their specific stat-to-rating correlations for scouting/defense.'
                            )
                        ),
                        // eFG% Model Prior Strength
                        e('div', { 
                            style: { 
                                marginTop: '16px',
                                padding: '12px 16px',
                                background: 'rgba(251, 191, 36, 0.1)',
                                border: '1px solid rgba(251, 191, 36, 0.3)',
                                borderRadius: '8px'
                            }
                        },
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '16px', flexWrap: 'wrap' }},
                                e('div', { style: { color: '#fbbf24', fontWeight: 'bold', fontSize: '12px' }}, '📐 eFG% Model Prior Strength'),
                                e('div', { style: { flex: 1, minWidth: '200px' }},
                                    e('input', { 
                                        type: 'range', 
                                        min: 10, 
                                        max: 200, 
                                        value: efgModelWeight, 
                                        onChange: ev => setEfgModelWeight(parseInt(ev.target.value)),
                                        style: { width: '100%', accentColor: '#fbbf24' }
                                    }),
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '9px', color: '#94a3b8', marginTop: '2px' }},
                                        e('span', null, '10 (Trust Data)'),
                                        e('span', { style: { color: '#fbbf24', fontWeight: 'bold' }}, 'k=' + efgModelWeight),
                                        e('span', null, '200 (Trust Prior)')
                                    )
                                ),
                                e('div', { style: { fontSize: '10px', color: '#94a3b8', maxWidth: '280px' }},
                                    'Controls Bayesian prior strength (k). Weight = poss/(poss+k). Higher k = need more possessions to trust on-off data over league avg.'
                                )
                            )
                        )
                    )
                ),
                // V5.4: Strength of Schedule Tab Content - Research-Backed Implementation
                activeTab === 'sos' && teamTotalsData.length > 0 && (() => {
                    // =======================================================================
                    // STRENGTH OF SCHEDULE ANALYSIS V2.1 - Research-Backed with Date/Game Filters
                    // Based on: KenPom methodology, Basketball-Reference, FiveThirtyEight
                    // Features:
                    // 1. Ridge Regression-style iterative SOS adjustment (additive per KenPom)
                    // 2. Empirically-derived Four Factors weights (Squared Statistics 2017)
                    // 3. Pythagorean Expectation (exponent 14 per Basketball-Reference)
                    // 4. Log5 head-to-head win probability
                    // 5. ELO-based expected wins
                    // 6. Date/Game Range Filtering with full recalculation
                    // =======================================================================
                    
                    // =====================================================
                    // STEP 0: Parse ALL games first to determine available range
                    // =====================================================
                    const allGameResults = new Map();
                    teamTotalsData.forEach(row => {
                        const gameId = row.game_id;
                        const teamName = row.team;
                        if (!gameId || !teamName) return;
                        
                        if (!allGameResults.has(gameId)) {
                            allGameResults.set(gameId, { teams: [], data: {}, date: row.game_date });
                        }
                        const game = allGameResults.get(gameId);
                        game.teams.push(teamName);
                        game.data[teamName] = {
                            pts: parseFloat(row.points) || 0,
                            fgm: parseFloat(row.fgm) || 0,
                            fga: parseFloat(row.fga) || 0,
                            fg3m: parseFloat(row.fg3m) || 0,
                            fg3a: parseFloat(row.fg3a) || 0,
                            ftm: parseFloat(row.ftm) || 0,
                            fta: parseFloat(row.fta) || 0,
                            oreb: parseFloat(row.oreb) || 0,
                            dreb: parseFloat(row.dreb) || 0,
                            tov: parseFloat(row.tov) || 0,
                            poss: parseFloat(row.poss) || 0
                        };
                    });
                    
                    // Build sorted list of all complete games
                    const allGames = [];
                    allGameResults.forEach((game, gameId) => {
                        if (game.teams.length !== 2) return;
                        allGames.push({ gameId, ...game });
                    });
                    allGames.sort((a, b) => {
                        if (!a.date || !b.date) return 0;
                        return new Date(a.date) - new Date(b.date);
                    });
                    
                    // Determine date range
                    const allDates = allGames.filter(g => g.date).map(g => g.date);
                    const minDate = allDates.length > 0 ? allDates[0] : '';
                    const maxDate = allDates.length > 0 ? allDates[allDates.length - 1] : '';
                    const totalGames = allGames.length;
                    
                    // =====================================================
                    // STEP 1: Apply filters to get subset of games
                    // =====================================================
                    let filteredGames = [...allGames];
                    let filterDescription = 'All Games';
                    
                    if (sosFilterType === 'dateRange' && sosDateStart && sosDateEnd) {
                        const startDate = new Date(sosDateStart);
                        const endDate = new Date(sosDateEnd);
                        endDate.setHours(23, 59, 59, 999); // Include full end date
                        filteredGames = allGames.filter(g => {
                            if (!g.date) return false;
                            const gameDate = new Date(g.date);
                            return gameDate >= startDate && gameDate <= endDate;
                        });
                        filterDescription = `Date Range: ${sosDateStart} to ${sosDateEnd}`;
                    } else if (sosFilterType === 'lastN' && sosLastNGames > 0) {
                        // Get last N games for each team (need to process differently)
                        // For simplicity, we'll take the last N games overall
                        filteredGames = allGames.slice(-sosLastNGames);
                        filterDescription = `Last ${sosLastNGames} Games`;
                    } else if (sosFilterType === 'gameRange' && sosGameStart > 0 && sosGameEnd >= sosGameStart) {
                        const startIdx = Math.max(0, sosGameStart - 1);
                        const endIdx = Math.min(totalGames, sosGameEnd);
                        filteredGames = allGames.slice(startIdx, endIdx);
                        filterDescription = `Games ${sosGameStart} to ${sosGameEnd}`;
                    }
                    
                    // =====================================================
                    // STEP 2: Rebuild team stats using ONLY filtered games
                    // =====================================================
                    const teamStats = new Map();
                    const processedGames = [];
                    
                    filteredGames.forEach(game => {
                        const [team1, team2] = game.teams;
                        const d1 = game.data[team1];
                        const d2 = game.data[team2];
                        
                        // Initialize team stats if needed
                        if (!teamStats.has(team1)) {
                            teamStats.set(team1, {
                                games: 0, wins: 0, losses: 0,
                                pts: 0, ptsA: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                                ftm: 0, fta: 0, oreb: 0, dreb: 0, tov: 0, poss: 0,
                                fgmA: 0, fgaA: 0, fg3mA: 0, fg3aA: 0, ftmA: 0, ftaA: 0,
                                orebA: 0, drebA: 0, tovA: 0, possA: 0,
                                opponents: [], gameData: []
                            });
                        }
                        if (!teamStats.has(team2)) {
                            teamStats.set(team2, {
                                games: 0, wins: 0, losses: 0,
                                pts: 0, ptsA: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                                ftm: 0, fta: 0, oreb: 0, dreb: 0, tov: 0, poss: 0,
                                fgmA: 0, fgaA: 0, fg3mA: 0, fg3aA: 0, ftmA: 0, ftaA: 0,
                                orebA: 0, drebA: 0, tovA: 0, possA: 0,
                                opponents: [], gameData: []
                            });
                        }
                        
                        // Update team1 stats
                        const t1 = teamStats.get(team1);
                        t1.games++; 
                        t1.pts += d1.pts; t1.ptsA += d2.pts;
                        t1.fgm += d1.fgm; t1.fga += d1.fga; t1.fg3m += d1.fg3m; t1.fg3a += d1.fg3a;
                        t1.ftm += d1.ftm; t1.fta += d1.fta; t1.oreb += d1.oreb; t1.dreb += d1.dreb;
                        t1.tov += d1.tov; t1.poss += d1.poss;
                        t1.fgmA += d2.fgm; t1.fgaA += d2.fga; t1.fg3mA += d2.fg3m; t1.fg3aA += d2.fg3a;
                        t1.ftmA += d2.ftm; t1.ftaA += d2.fta; t1.orebA += d2.oreb; t1.drebA += d2.dreb;
                        t1.tovA += d2.tov; t1.possA += d2.poss;
                        t1.opponents.push(team2);
                        t1.gameData.push({ opp: team2, ptsFor: d1.pts, ptsAg: d2.pts, possFor: d1.poss, possAg: d2.poss });
                        if (d1.pts > d2.pts) t1.wins++; else t1.losses++;
                        
                        // Update team2 stats
                        const t2 = teamStats.get(team2);
                        t2.games++;
                        t2.pts += d2.pts; t2.ptsA += d1.pts;
                        t2.fgm += d2.fgm; t2.fga += d2.fga; t2.fg3m += d2.fg3m; t2.fg3a += d2.fg3a;
                        t2.ftm += d2.ftm; t2.fta += d2.fta; t2.oreb += d2.oreb; t2.dreb += d2.dreb;
                        t2.tov += d2.tov; t2.poss += d2.poss;
                        t2.fgmA += d1.fgm; t2.fgaA += d1.fga; t2.fg3mA += d1.fg3m; t2.fg3aA += d1.fg3a;
                        t2.ftmA += d1.ftm; t2.ftaA += d1.fta; t2.orebA += d1.oreb; t2.drebA += d1.dreb;
                        t2.tovA += d1.tov; t2.possA += d1.poss;
                        t2.opponents.push(team1);
                        t2.gameData.push({ opp: team1, ptsFor: d2.pts, ptsAg: d1.pts, possFor: d2.poss, possAg: d1.poss });
                        if (d2.pts > d1.pts) t2.wins++; else t2.losses++;
                        
                        processedGames.push({ gameId: game.gameId, team1, team2, pts1: d1.pts, pts2: d2.pts, poss1: d1.poss, poss2: d2.poss, date: game.date });
                    });
                    
                    // =====================================================
                    // STEP 3: Calculate league averages from filtered data
                    // =====================================================
                    let lgPoss = 0, lgFgm = 0, lgFga = 0, lgFg3m = 0, lgFg3a = 0;
                    let lgFtm = 0, lgFta = 0, lgOreb = 0, lgDreb = 0, lgTov = 0, lgPts = 0;
                    teamStats.forEach(t => {
                        lgPoss += t.poss; lgFgm += t.fgm; lgFga += t.fga; lgFg3m += t.fg3m; lgFg3a += t.fg3a;
                        lgFtm += t.ftm; lgFta += t.fta; lgOreb += t.oreb; lgDreb += t.dreb; lgTov += t.tov; lgPts += t.pts;
                    });
                    
                    const leagueAvg = {
                        efg: lgFga > 0 ? ((lgFgm + 0.5 * lgFg3m) / lgFga) * 100 : 50,
                        ftRate: lgFga > 0 ? (lgFta / lgFga) * 100 : 25,
                        tovPct: (lgFga + 0.44 * lgFta + lgTov) > 0 ? (lgTov / (lgFga + 0.44 * lgFta + lgTov)) * 100 : 14,
                        orebPct: (lgOreb + lgDreb) > 0 ? (lgOreb / (lgOreb + lgDreb)) * 100 : 25,
                        ortg: lgPoss > 0 ? (lgPts / lgPoss) * 100 : 100,
                        ppg: teamStats.size > 0 ? lgPts / (teamStats.size * (processedGames.length / teamStats.size)) : 80
                    };
                    
                    // Step 4: Calculate raw efficiency ratings
                    const teamRawRatings = new Map();
                    teamStats.forEach((t, name) => {
                        if (t.games === 0) return;
                        const ortg = t.poss > 0 ? (t.pts / t.poss) * 100 : leagueAvg.ortg;
                        const drtg = t.possA > 0 ? (t.ptsA / t.possA) * 100 : leagueAvg.ortg;
                        teamRawRatings.set(name, { ortg, drtg, netRtg: ortg - drtg });
                    });
                    
                    // Step 4.5: Build FULL data ratings for SOS calculation (ignores date filter)
                    const teamStatsAll = new Map();
                    allGames.forEach(game => {
                        const [team1, team2] = game.teams;
                        const d1 = game.data[team1];
                        const d2 = game.data[team2];
                        
                        [{ name: team1, own: d1, opp: d2, oppName: team2 }, { name: team2, own: d2, opp: d1, oppName: team1 }].forEach(({ name, own, opp, oppName }) => {
                            if (!teamStatsAll.has(name)) {
                                teamStatsAll.set(name, { pts: 0, ptsA: 0, poss: 0, possA: 0, opponents: [] });
                            }
                            const t = teamStatsAll.get(name);
                            t.pts += own.pts; t.ptsA += opp.pts;
                            t.poss += own.poss || (own.fga - own.oreb + own.tov + 0.44 * own.fta);
                            t.possA += opp.poss || (opp.fga - opp.oreb + opp.tov + 0.44 * opp.fta);
                            t.opponents.push(oppName);
                        });
                    });
                    
                    // Calculate raw ratings from full data
                    const teamRawRatingsAll = new Map();
                    teamStatsAll.forEach((t, name) => {
                        const ortg = t.poss > 0 ? (t.pts / t.poss) * 100 : 100;
                        const drtg = t.possA > 0 ? (t.ptsA / t.possA) * 100 : 100;
                        teamRawRatingsAll.set(name, { ortg, drtg, netRtg: ortg - drtg });
                    });
                    
                    // Iterative adjustment for FULL data (for SOS calculation)
                    let adjORtgAll = new Map();
                    let adjDRtgAll = new Map();
                    teamRawRatingsAll.forEach((r, name) => { adjORtgAll.set(name, r.ortg); adjDRtgAll.set(name, r.drtg); });
                    
                    for (let iter = 0; iter < 10; iter++) {
                        const newAdjO = new Map();
                        const newAdjD = new Map();
                        teamStatsAll.forEach((t, name) => {
                            if (t.opponents.length === 0) return;
                            let sumOppD = 0, sumOppO = 0;
                            t.opponents.forEach(opp => {
                                sumOppD += adjDRtgAll.get(opp) || 100;
                                sumOppO += adjORtgAll.get(opp) || 100;
                            });
                            const avgOppD = sumOppD / t.opponents.length;
                            const avgOppO = sumOppO / t.opponents.length;
                            const raw = teamRawRatingsAll.get(name);
                            newAdjO.set(name, raw.ortg + (100 - avgOppD) * 0.8);
                            newAdjD.set(name, raw.drtg + (100 - avgOppO) * 0.8);
                        });
                        adjORtgAll = newAdjO;
                        adjDRtgAll = newAdjD;
                    }
                    
                    // Step 5: Ridge Regression-style Iterative SOS Adjustment (KenPom method)
                    // Additive adjustment per KenPom's 2014 methodology update
                    const ITERATIONS = 10;
                    const REGRESSION_FACTOR = 0.8; // Regress toward mean to avoid overfitting
                    
                    let adjORtg = new Map();
                    let adjDRtg = new Map();
                    teamRawRatings.forEach((r, name) => {
                        adjORtg.set(name, r.ortg);
                        adjDRtg.set(name, r.drtg);
                    });
                    
                    for (let iter = 0; iter < ITERATIONS; iter++) {
                        const newAdjORtg = new Map();
                        const newAdjDRtg = new Map();
                        
                        teamStats.forEach((t, name) => {
                            if (t.games === 0) return;
                            
                            // Calculate average opponent adjusted ratings
                            let sumOppAdjD = 0, sumOppAdjO = 0;
                            t.opponents.forEach(opp => {
                                sumOppAdjD += adjDRtg.get(opp) || leagueAvg.ortg;
                                sumOppAdjO += adjORtg.get(opp) || leagueAvg.ortg;
                            });
                            const avgOppAdjD = sumOppAdjD / t.opponents.length;
                            const avgOppAdjO = sumOppAdjO / t.opponents.length;
                            
                            // Additive adjustment (per KenPom): Raw + (League Avg - Opp Avg)
                            const raw = teamRawRatings.get(name);
                            const adjO = raw.ortg + (leagueAvg.ortg - avgOppAdjD) * REGRESSION_FACTOR;
                            const adjD = raw.drtg + (leagueAvg.ortg - avgOppAdjO) * REGRESSION_FACTOR;
                            
                            newAdjORtg.set(name, adjO);
                            newAdjDRtg.set(name, adjD);
                        });
                        
                        adjORtg = newAdjORtg;
                        adjDRtg = newAdjDRtg;
                    }
                    
                    // Step 6: Calculate Four Factors with EMPIRICALLY-DERIVED weights
                    // Source: Squared Statistics (2017) regression analysis
                    // eFG%: 46.3%, TOV%: 35.1%, OREB%: 11.9%, FT Rate: 6.8%
                    const EMPIRICAL_WEIGHTS = {
                        efg: 0.463,
                        tovPct: 0.351,
                        orebPct: 0.119,
                        ftRate: 0.068
                    };
                    
                    // Points per 100 possessions impact (derived from regression)
                    const POINTS_PER_PCT = {
                        efg: 2.0,       // Each 1% eFG% ≈ 2.0 pts/100
                        tovPct: 1.4,    // Each 1% TOV% ≈ 1.4 pts/100
                        orebPct: 0.7,   // Each 1% OREB% ≈ 0.7 pts/100
                        ftRate: 0.4     // Each 1% FT Rate ≈ 0.4 pts/100
                    };
                    
                    const teamFourFactors = new Map();
                    teamStats.forEach((t, name) => {
                        if (t.games === 0) return;
                        
                        const offEfg = t.fga > 0 ? ((t.fgm + 0.5 * t.fg3m) / t.fga) * 100 : 0;
                        const offFtRate = t.fga > 0 ? (t.fta / t.fga) * 100 : 0;
                        const offTovPct = (t.fga + 0.44 * t.fta + t.tov) > 0 ? (t.tov / (t.fga + 0.44 * t.fta + t.tov)) * 100 : 0;
                        const offOrebPct = (t.oreb + t.drebA) > 0 ? (t.oreb / (t.oreb + t.drebA)) * 100 : 0;
                        
                        const defEfg = t.fgaA > 0 ? ((t.fgmA + 0.5 * t.fg3mA) / t.fgaA) * 100 : 0;
                        const defFtRate = t.fgaA > 0 ? (t.ftaA / t.fgaA) * 100 : 0;
                        const defTovPct = (t.fgaA + 0.44 * t.ftaA + t.tovA) > 0 ? (t.tovA / (t.fgaA + 0.44 * t.ftaA + t.tovA)) * 100 : 0;
                        const defOrebPct = (t.orebA + t.dreb) > 0 ? (t.orebA / (t.orebA + t.dreb)) * 100 : 0;
                        
                        teamFourFactors.set(name, {
                            offEfg, offFtRate, offTovPct, offOrebPct,
                            defEfg, defFtRate, defTovPct, defOrebPct
                        });
                    });
                    
                    // Step 7: Calculate Z-scores for Four Factors
                    const calcMean = arr => arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
                    const calcStd = arr => {
                        if (arr.length < 2) return 1;
                        const mean = calcMean(arr);
                        return Math.sqrt(arr.map(v => Math.pow(v - mean, 2)).reduce((a, b) => a + b, 0) / (arr.length - 1)) || 1;
                    };
                    
                    const ffArrays = { offEfg: [], offFtRate: [], offTovPct: [], offOrebPct: [],
                                       defEfg: [], defFtRate: [], defTovPct: [], defOrebPct: [] };
                    teamFourFactors.forEach(ff => {
                        Object.keys(ffArrays).forEach(k => ffArrays[k].push(ff[k]));
                    });
                    const ffMean = {}, ffStd = {};
                    Object.keys(ffArrays).forEach(k => { ffMean[k] = calcMean(ffArrays[k]); ffStd[k] = calcStd(ffArrays[k]); });
                    
                    // Step 8: ELO Rating System with MOV adjustment (FiveThirtyEight style)
                    const K_FACTOR = 20;
                    const INITIAL_ELO = 1500;
                    const teamElo = new Map();
                    teamStats.forEach((_, name) => teamElo.set(name, INITIAL_ELO));
                    
                    const sortedGames = [...processedGames].sort((a, b) => {
                        if (!a.date || !b.date) return 0;
                        return new Date(a.date) - new Date(b.date);
                    });
                    
                    sortedGames.forEach(game => {
                        const elo1 = teamElo.get(game.team1) || INITIAL_ELO;
                        const elo2 = teamElo.get(game.team2) || INITIAL_ELO;
                        
                        const exp1 = 1 / (1 + Math.pow(10, (elo2 - elo1) / 400));
                        const actual1 = game.pts1 > game.pts2 ? 1 : 0;
                        
                        // MOV multiplier (FiveThirtyEight style)
                        const mov = Math.abs(game.pts1 - game.pts2);
                        const eloDiff = Math.abs(elo1 - elo2);
                        const movMultiplier = Math.log(mov + 1) * (2.2 / ((eloDiff * 0.001) + 2.2));
                        
                        const change = K_FACTOR * movMultiplier * (actual1 - exp1);
                        teamElo.set(game.team1, elo1 + change);
                        teamElo.set(game.team2, elo2 - change);
                    });
                    
                    // Step 9: Pythagorean Win Expectation (exponent 14 per Basketball-Reference)
                    // Win% = PF^14 / (PF^14 + PA^14)
                    const PYTH_EXP = 14;
                    
                    // Step 10: Log5 formula for head-to-head win probability
                    // P(A beats B) = (pA - pA*pB) / (pA + pB - 2*pA*pB)
                    const log5 = (pA, pB) => {
                        if (pA + pB - 2 * pA * pB === 0) return 0.5;
                        return (pA - pA * pB) / (pA + pB - 2 * pA * pB);
                    };
                    
                    // ELO to Win Probability conversion
                    const eloToWinProb = (eloA, eloB) => 1 / (1 + Math.pow(10, (eloB - eloA) / 400));
                    
                    // Net Rating to Win Probability (empirical: ~2.7 wins per +1 net rating over 82 games)
                    // This translates to approximately: WinProb = 1 / (1 + 10^(-NetRtgDiff / 10))
                    const netRtgToWinProb = (netRtgA, netRtgB) => {
                        const diff = netRtgA - netRtgB;
                        return 1 / (1 + Math.pow(10, -diff / 10));
                    };
                    
                    // Step 11: Build final team ratings array
                    const teamRatings = [];
                    const nTeams = teamStats.size;
                    const gamesPerTeam = processedGames.length * 2 / nTeams;
                    
                    // First pass: build basic ratings
                    const tempRatings = new Map();
                    teamStats.forEach((t, name) => {
                        if (t.games === 0) return;
                        const ff = teamFourFactors.get(name);
                        const raw = teamRawRatings.get(name);
                        const adjO = adjORtg.get(name) || raw.ortg;
                        const adjD = adjDRtg.get(name) || raw.drtg;
                        const elo = teamElo.get(name) || INITIAL_ELO;
                        tempRatings.set(name, { adjO, adjD, adjNet: adjO - adjD, elo, games: t.games, wins: t.wins });
                    });
                    
                    teamStats.forEach((t, name) => {
                        if (t.games === 0) return;
                        
                        const ff = teamFourFactors.get(name);
                        const raw = teamRawRatings.get(name);
                        const adjO = adjORtg.get(name) || raw.ortg;
                        const adjD = adjDRtg.get(name) || raw.drtg;
                        const adjNet = adjO - adjD;
                        const elo = teamElo.get(name) || INITIAL_ELO;
                        
                        // Z-scores with proper direction (positive = good)
                        const zOffEfg = (ff.offEfg - ffMean.offEfg) / ffStd.offEfg;
                        const zOffFtRate = (ff.offFtRate - ffMean.offFtRate) / ffStd.offFtRate;
                        const zOffTovPct = -(ff.offTovPct - ffMean.offTovPct) / ffStd.offTovPct;
                        const zOffOrebPct = (ff.offOrebPct - ffMean.offOrebPct) / ffStd.offOrebPct;
                        const zDefEfg = -(ff.defEfg - ffMean.defEfg) / ffStd.defEfg;
                        const zDefFtRate = -(ff.defFtRate - ffMean.defFtRate) / ffStd.defFtRate;
                        const zDefTovPct = (ff.defTovPct - ffMean.defTovPct) / ffStd.defTovPct;
                        const zDefOrebPct = -(ff.defOrebPct - ffMean.defOrebPct) / ffStd.defOrebPct;
                        
                        // Weighted Four Factors Z-score (using empirical weights)
                        const offFFScore = zOffEfg * EMPIRICAL_WEIGHTS.efg + zOffTovPct * EMPIRICAL_WEIGHTS.tovPct +
                                          zOffOrebPct * EMPIRICAL_WEIGHTS.orebPct + zOffFtRate * EMPIRICAL_WEIGHTS.ftRate;
                        const defFFScore = zDefEfg * EMPIRICAL_WEIGHTS.efg + zDefTovPct * EMPIRICAL_WEIGHTS.tovPct +
                                          zDefOrebPct * EMPIRICAL_WEIGHTS.orebPct + zDefFtRate * EMPIRICAL_WEIGHTS.ftRate;
                        
                        // Scoring Battle PA (eFG% + FT Rate)
                        const scoringPA = (ff.offEfg - leagueAvg.efg) * POINTS_PER_PCT.efg +
                                         (ff.offFtRate - leagueAvg.ftRate) * POINTS_PER_PCT.ftRate +
                                         (leagueAvg.efg - ff.defEfg) * POINTS_PER_PCT.efg +
                                         (leagueAvg.ftRate - ff.defFtRate) * POINTS_PER_PCT.ftRate;
                        
                        // Possession Battle PA (TOV% + OREB%)
                        const possPA = (leagueAvg.tovPct - ff.offTovPct) * POINTS_PER_PCT.tovPct +
                                      (ff.offOrebPct - leagueAvg.orebPct) * POINTS_PER_PCT.orebPct +
                                      (ff.defTovPct - leagueAvg.tovPct) * POINTS_PER_PCT.tovPct +
                                      (leagueAvg.orebPct - ff.defOrebPct) * POINTS_PER_PCT.orebPct;
                        
                        // Pythagorean Win% (Basketball-Reference exponent 14)
                        const pf14 = Math.pow(t.pts, PYTH_EXP);
                        const pa14 = Math.pow(t.ptsA, PYTH_EXP);
                        const pythWinPct = pf14 / (pf14 + pa14);
                        const pythExpWins = pythWinPct * t.games;
                        
                        // ELO-based expected wins vs AVERAGE opponent (simple)
                        const eloWinPctVsAvg = 1 / (1 + Math.pow(10, (INITIAL_ELO - elo) / 400));
                        
                        // =====================================================
                        // SCHEDULE-ADJUSTED EXPECTED WINS (Using Log5 & ELO)
                        // Calculate expected wins based on ACTUAL opponents faced
                        // =====================================================
                        let eloExpWinsSchedule = 0;
                        let log5ExpWinsSchedule = 0;
                        let netRtgExpWinsSchedule = 0;
                        
                        t.gameData.forEach(game => {
                            const oppRating = tempRatings.get(game.opp);
                            if (!oppRating) return;
                            
                            // ELO-based win probability for this specific matchup
                            const eloWinProb = eloToWinProb(elo, oppRating.elo);
                            eloExpWinsSchedule += eloWinProb;
                            
                            // Log5-based win probability (using Pythagorean win%)
                            const myPythWinPct = pythWinPct;
                            const oppPythWinPct = oppRating.wins / oppRating.games;
                            const log5WinProb = log5(myPythWinPct, oppPythWinPct);
                            log5ExpWinsSchedule += log5WinProb;
                            
                            // Net Rating-based win probability
                            const netRtgWinProb = netRtgToWinProb(adjNet, oppRating.adjNet);
                            netRtgExpWinsSchedule += netRtgWinProb;
                        });
                        
                        // ELO expected wins vs average team (for projected full season)
                        const eloExpWinsVsAvg = eloWinPctVsAvg * t.games;
                        
                        // Net Rating-based expected wins (via Pythagorean with efficiency)
                        const projPtsFor = adjO * (t.poss / t.games) / 100;
                        const projPtsAg = adjD * (t.possA / t.games) / 100;
                        const adjPf14 = Math.pow(projPtsFor, PYTH_EXP);
                        const adjPa14 = Math.pow(projPtsAg, PYTH_EXP);
                        const adjPythWinPct = (adjPf14 + adjPa14) > 0 ? adjPf14 / (adjPf14 + adjPa14) : 0.5;
                        const adjExpWins = adjPythWinPct * t.games;
                        
                        // SOS metrics - Use FULL DATA adjusted ratings (ignores date filter)
                        let sosSum = 0;
                        const tAll = teamStatsAll.get(name);
                        if (tAll) {
                            tAll.opponents.forEach(opp => {
                                const oppAdj = (adjORtgAll.get(opp) || 100) - (adjDRtgAll.get(opp) || 100);
                                sosSum += oppAdj;
                            });
                        }
                        const sosNetRtg = tAll && tAll.opponents.length > 0 ? sosSum / tAll.opponents.length : 0;
                        
                        // SOS ELO also uses full data
                        let sosEloSum = 0;
                        if (tAll) {
                            tAll.opponents.forEach(opp => sosEloSum += teamElo.get(opp) || INITIAL_ELO);
                        }
                        const sosElo = tAll && tAll.opponents.length > 0 ? sosEloSum / tAll.opponents.length : INITIAL_ELO;
                        
                        // Luck: Actual wins - Expected wins (using schedule-adjusted ELO)
                        const luck = t.wins - eloExpWinsSchedule;
                        const pythLuck = t.wins - pythExpWins;
                        
                        // =====================================================
                        // PROJECTED FULL SEASON RECORD (Round-Robin)
                        // Each team plays every other team 4 times
                        // Uses ELO win probability vs each specific opponent
                        // =====================================================
                        const GAMES_PER_MATCHUP = 4;
                        const allUniqueTeams = [...new Set([...allGames.flatMap(g => g.teams)])];
                        const nAllTeams = allUniqueTeams.length;
                        const FULL_SEASON_LENGTH = (nAllTeams - 1) * GAMES_PER_MATCHUP;
                        
                        // Calculate projected wins by summing ELO win prob vs each opponent × 4
                        let projectedWinsRoundRobin = 0;
                        allUniqueTeams.forEach(oppName => {
                            if (oppName === name) return;
                            // Get opponent's ELO (use current filtered ELO, or 1500 if not in filtered data)
                            const oppElo = teamElo.get(oppName) || INITIAL_ELO;
                            const winProbVsOpp = eloToWinProb(elo, oppElo);
                            projectedWinsRoundRobin += winProbVsOpp * GAMES_PER_MATCHUP;
                        });
                        
                        const projectedWins = Math.round(projectedWinsRoundRobin);
                        const projectedLosses = FULL_SEASON_LENGTH - projectedWins;
                        
                        // =====================================================
                        // PYTHAGOREAN PROJECTED W-L (Based on Adj Net Rating)
                        // Uses Adj Net Rating win probability vs each opponent
                        // =====================================================
                        let pythProjWinsRoundRobin = 0;
                        allUniqueTeams.forEach(oppName => {
                            if (oppName === name) return;
                            // Get opponent's adjusted net rating
                            const oppData = tempRatings.get(oppName);
                            const oppAdjNet = oppData ? (oppData.adjO - oppData.adjD) : 0;
                            // Use net rating differential to win probability
                            const winProbVsOpp = netRtgToWinProb(adjNet, oppAdjNet);
                            pythProjWinsRoundRobin += winProbVsOpp * GAMES_PER_MATCHUP;
                        });
                        
                        const pythProjWins = Math.round(pythProjWinsRoundRobin);
                        const pythProjLosses = FULL_SEASON_LENGTH - pythProjWins;
                        
                        teamRatings.push({
                            name, games: t.games, wins: t.wins, losses: t.losses,
                            pts: t.pts, ptsA: t.ptsA, poss: t.poss, possA: t.possA,
                            rawOrtg: raw.ortg, rawDrtg: raw.drtg, rawNet: raw.netRtg,
                            adjOrtg: adjO, adjDrtg: adjD, adjNet,
                            elo, sosElo, sosNetRtg,
                            ...ff,
                            zOffEfg, zOffFtRate, zOffTovPct, zOffOrebPct, offFFScore,
                            zDefEfg, zDefFtRate, zDefTovPct, zDefOrebPct, defFFScore,
                            scoringPA, possPA, totalPA: scoringPA + possPA,
                            pythWinPct, pythExpWins,
                            eloWinPct: eloWinPctVsAvg,
                            eloExpWins: eloExpWinsVsAvg,
                            eloExpWinsSchedule, // Schedule-adjusted (actual opponents)
                            log5ExpWins: log5ExpWinsSchedule,
                            netRtgExpWins: netRtgExpWinsSchedule,
                            adjExpWins,
                            luck, pythLuck,
                            projectedWins, projectedLosses,
                            pythProjWins, pythProjLosses,
                            seasonLength: FULL_SEASON_LENGTH,
                            nTeamsInLeague: nAllTeams
                        });
                    });
                    
                    // Sort by adjusted net rating
                    teamRatings.sort((a, b) => b.adjNet - a.adjNet);
                    
                    // Color helpers
                    const getValueColor = (val, threshold = 3) => {
                        if (val > threshold) return '#22c55e';
                        if (val > threshold/3) return '#86efac';
                        if (val > -threshold/3) return '#94a3b8';
                        if (val > -threshold) return '#fca5a5';
                        return '#ef4444';
                    };
                    const getEloColor = elo => {
                        if (elo >= 1580) return '#22c55e';
                        if (elo >= 1530) return '#86efac';
                        if (elo >= 1470) return '#94a3b8';
                        if (elo >= 1420) return '#fca5a5';
                        return '#ef4444';
                    };
                    const getPctColor = pct => {
                        if (pct >= 0.65) return '#22c55e';
                        if (pct >= 0.55) return '#86efac';
                        if (pct >= 0.45) return '#94a3b8';
                        if (pct >= 0.35) return '#fca5a5';
                        return '#ef4444';
                    };
                    
                    return e('div', null,
                        // Filter Controls
                        e('div', { style: { marginBottom: '20px', padding: '16px', background: 'rgba(30, 41, 59, 0.6)', borderRadius: '12px', border: '1px solid rgba(139, 92, 246, 0.3)' }},
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '12px', flexWrap: 'wrap' }},
                                e('span', { style: { fontSize: '12px', fontWeight: '600', color: '#a78bfa' }}, '📅 Game/Date Range Filter:'),
                                e('span', { style: { fontSize: '10px', color: '#64748b' }}, 
                                    'Available: ' + totalGames + ' games (' + (minDate || 'N/A') + ' to ' + (maxDate || 'N/A') + ')'
                                )
                            ),
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '16px', flexWrap: 'wrap' }},
                                // Filter Type Selector
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                    e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Filter:'),
                                    e('select', {
                                        value: sosFilterType,
                                        onChange: ev => setSosFilterType(ev.target.value),
                                        style: { 
                                            padding: '6px 10px', fontSize: '11px', borderRadius: '6px',
                                            background: 'rgba(15, 23, 42, 0.8)', border: '1px solid rgba(139, 92, 246, 0.4)',
                                            color: '#e2e8f0', cursor: 'pointer'
                                        }
                                    },
                                        e('option', { value: 'all' }, 'All Games'),
                                        e('option', { value: 'dateRange' }, 'Date Range'),
                                        e('option', { value: 'lastN' }, 'Last N Games'),
                                        e('option', { value: 'gameRange' }, 'Game Range')
                                    )
                                ),
                                // Date Range inputs
                                sosFilterType === 'dateRange' && e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                    e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'From:'),
                                    e('input', {
                                        type: 'date',
                                        value: sosDateStart,
                                        onChange: ev => setSosDateStart(ev.target.value),
                                        style: { 
                                            padding: '5px 8px', fontSize: '11px', borderRadius: '6px',
                                            background: 'rgba(15, 23, 42, 0.8)', border: '1px solid rgba(139, 92, 246, 0.4)',
                                            color: '#e2e8f0'
                                        }
                                    }),
                                    e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'To:'),
                                    e('input', {
                                        type: 'date',
                                        value: sosDateEnd,
                                        onChange: ev => setSosDateEnd(ev.target.value),
                                        style: { 
                                            padding: '5px 8px', fontSize: '11px', borderRadius: '6px',
                                            background: 'rgba(15, 23, 42, 0.8)', border: '1px solid rgba(139, 92, 246, 0.4)',
                                            color: '#e2e8f0'
                                        }
                                    })
                                ),
                                // Last N Games input
                                sosFilterType === 'lastN' && e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                    e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Last'),
                                    e('input', {
                                        type: 'number',
                                        value: sosLastNGames,
                                        onChange: ev => setSosLastNGames(Math.max(1, parseInt(ev.target.value) || 1)),
                                        min: 1,
                                        max: totalGames,
                                        style: { 
                                            width: '60px', padding: '5px 8px', fontSize: '11px', borderRadius: '6px',
                                            background: 'rgba(15, 23, 42, 0.8)', border: '1px solid rgba(139, 92, 246, 0.4)',
                                            color: '#e2e8f0', textAlign: 'center'
                                        }
                                    }),
                                    e('span', { style: { fontSize: '11px', color: '#94a3b8' }}, 'games')
                                ),
                                // Game Range inputs
                                sosFilterType === 'gameRange' && e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' }},
                                    e('label', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Games'),
                                    e('input', {
                                        type: 'number',
                                        value: sosGameStart,
                                        onChange: ev => setSosGameStart(Math.max(1, parseInt(ev.target.value) || 1)),
                                        min: 1,
                                        max: totalGames,
                                        style: { 
                                            width: '60px', padding: '5px 8px', fontSize: '11px', borderRadius: '6px',
                                            background: 'rgba(15, 23, 42, 0.8)', border: '1px solid rgba(139, 92, 246, 0.4)',
                                            color: '#e2e8f0', textAlign: 'center'
                                        }
                                    }),
                                    e('span', { style: { fontSize: '11px', color: '#94a3b8' }}, 'to'),
                                    e('input', {
                                        type: 'number',
                                        value: sosGameEnd,
                                        onChange: ev => setSosGameEnd(Math.max(sosGameStart, parseInt(ev.target.value) || sosGameStart)),
                                        min: sosGameStart,
                                        max: totalGames,
                                        style: { 
                                            width: '60px', padding: '5px 8px', fontSize: '11px', borderRadius: '6px',
                                            background: 'rgba(15, 23, 42, 0.8)', border: '1px solid rgba(139, 92, 246, 0.4)',
                                            color: '#e2e8f0', textAlign: 'center'
                                        }
                                    })
                                ),
                                // Reset button
                                sosFilterType !== 'all' && e('button', {
                                    onClick: () => setSosFilterType('all'),
                                    style: {
                                        padding: '5px 12px', fontSize: '10px', borderRadius: '6px',
                                        background: 'rgba(239, 68, 68, 0.2)', border: '1px solid rgba(239, 68, 68, 0.4)',
                                        color: '#fca5a5', cursor: 'pointer'
                                    }
                                }, '✕ Reset')
                            ),
                            // Active filter display
                            e('div', { style: { marginTop: '10px', padding: '8px 12px', background: 'rgba(139, 92, 246, 0.15)', borderRadius: '6px', display: 'flex', alignItems: 'center', gap: '12px' }},
                                e('span', { style: { fontSize: '11px', fontWeight: '600', color: '#c4b5fd' }}, '📊 Active Filter:'),
                                e('span', { style: { fontSize: '11px', color: '#e2e8f0' }}, filterDescription),
                                e('span', { style: { fontSize: '10px', color: '#64748b' }}, '(' + filteredGames.length + ' of ' + totalGames + ' games)')
                            )
                        ),
                        // Summary cards
                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(120px, 1fr))', gap: '12px', marginBottom: '24px' }},
                            e('div', { style: { background: 'rgba(139, 92, 246, 0.1)', border: '1px solid rgba(139, 92, 246, 0.3)', padding: '12px', borderRadius: '8px' }},
                                e('div', { style: { fontSize: '10px', color: '#a78bfa', textTransform: 'uppercase', marginBottom: '4px' }}, 'Teams'),
                                e('div', { style: { fontSize: '20px', fontWeight: 'bold', color: '#c4b5fd' }}, teamRatings.length)
                            ),
                            e('div', { style: { background: 'rgba(139, 92, 246, 0.1)', border: '1px solid rgba(139, 92, 246, 0.3)', padding: '12px', borderRadius: '8px' }},
                                e('div', { style: { fontSize: '10px', color: '#a78bfa', textTransform: 'uppercase', marginBottom: '4px' }}, 'Games'),
                                e('div', { style: { fontSize: '20px', fontWeight: 'bold', color: '#c4b5fd' }}, processedGames.length)
                            ),
                            e('div', { style: { background: 'rgba(139, 92, 246, 0.1)', border: '1px solid rgba(139, 92, 246, 0.3)', padding: '12px', borderRadius: '8px' }},
                                e('div', { style: { fontSize: '10px', color: '#a78bfa', textTransform: 'uppercase', marginBottom: '4px' }}, 'Lg eFG%'),
                                e('div', { style: { fontSize: '20px', fontWeight: 'bold', color: '#c4b5fd' }}, leagueAvg.efg.toFixed(1) + '%')
                            ),
                            e('div', { style: { background: 'rgba(139, 92, 246, 0.1)', border: '1px solid rgba(139, 92, 246, 0.3)', padding: '12px', borderRadius: '8px' }},
                                e('div', { style: { fontSize: '10px', color: '#a78bfa', textTransform: 'uppercase', marginBottom: '4px' }}, 'Lg ORtg'),
                                e('div', { style: { fontSize: '20px', fontWeight: 'bold', color: '#c4b5fd' }}, leagueAvg.ortg.toFixed(1))
                            )
                        ),
                        // Main ratings table
                        e('h3', { style: { fontSize: '14px', fontWeight: '600', color: '#a78bfa', marginBottom: '12px' }}, '🏆 League Table — Adjusted Ratings & Expected Wins'),
                        e('div', { style: { overflowX: 'auto', marginBottom: '32px' }},
                            e('table', { style: { width: '100%', borderCollapse: 'collapse', fontSize: '11px' }},
                                e('thead', null,
                                    e('tr', { style: { background: 'rgba(139, 92, 246, 0.2)', borderBottom: '2px solid rgba(139, 92, 246, 0.4)' }},
                                        e('th', { style: { padding: '8px 6px', textAlign: 'left', fontSize: '9px', fontWeight: '600', color: '#a78bfa' }, title: 'League ranking by adjusted net rating' }, '#'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'left', fontSize: '9px', fontWeight: '600', color: '#a78bfa' }, title: 'Team name' }, 'Team'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#94a3b8' }, title: 'Actual wins and losses' }, 'W-L'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#22d3ee' }, title: 'Projected W-L if every team played each other 4 times, based on ELO win probabilities' }, 'Proj†', e('br'), 'ELO'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#f472b6' }, title: 'Projected W-L if every team played each other 4 times, based on Pythagorean expected wins from adjusted net rating' }, 'Proj†', e('br'), 'Pyth'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#34d399', borderLeft: '1px solid rgba(139, 92, 246, 0.3)' }, title: 'Offensive rating adjusted for opponent strength (points per 100 possessions)' }, 'Adj', e('br'), 'ORtg'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#f87171' }, title: 'Defensive rating adjusted for opponent strength (points allowed per 100 possessions, lower is better)' }, 'Adj', e('br'), 'DRtg'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#a78bfa' }, title: 'Adjusted net rating (Adj ORtg - Adj DRtg), positive means team outscores opponents' }, 'Adj', e('br'), 'Net'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#fbbf24', borderLeft: '1px solid rgba(139, 92, 246, 0.3)' }, title: 'ELO rating (1500 = average, higher is better)' }, 'ELO'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#f472b6', borderLeft: '1px solid rgba(139, 92, 246, 0.3)' }, title: 'Pythagorean expected wins based on points scored vs allowed' }, 'Pyth', e('br'), 'xW'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#fbbf24' }, title: 'Schedule-adjusted expected wins using ELO win probability vs each actual opponent' }, 'ELO', e('br'), 'xW*'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#94a3b8' }, title: 'Luck factor: actual wins minus expected wins (positive = lucky, negative = unlucky)' }, 'Luck'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#94a3b8', borderLeft: '1px solid rgba(139, 92, 246, 0.3)' }, title: 'Strength of schedule based on opponents adjusted net rating (positive = harder schedule)' }, 'SOS', e('br'), 'Net'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#94a3b8' }, title: 'Strength of schedule based on opponents average ELO rating' }, 'SOS', e('br'), 'ELO')
                                    )
                                ),
                                e('tbody', null,
                                    teamRatings.map((team, idx) => 
                                        e('tr', { 
                                            key: team.name,
                                            style: { 
                                                background: idx % 2 === 0 ? 'rgba(30, 41, 59, 0.5)' : 'rgba(15, 23, 42, 0.5)',
                                                borderBottom: '1px solid rgba(71, 85, 105, 0.3)'
                                            }
                                        },
                                            e('td', { style: { padding: '6px', textAlign: 'center', fontWeight: 'bold', color: '#94a3b8' }}, idx + 1),
                                            e('td', { style: { padding: '6px', fontWeight: '600', color: '#e2e8f0', whiteSpace: 'nowrap' }}, team.name),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: team.wins > team.losses ? '#22c55e' : team.wins < team.losses ? '#ef4444' : '#94a3b8' }}, 
                                                team.wins + '-' + team.losses
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', fontWeight: '600', color: team.projectedWins > team.projectedLosses ? '#22d3ee' : team.projectedWins < team.projectedLosses ? '#f472b6' : '#94a3b8' }}, 
                                                team.projectedWins + '-' + team.projectedLosses
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', fontWeight: '600', color: team.pythProjWins > team.pythProjLosses ? '#22d3ee' : team.pythProjWins < team.pythProjLosses ? '#f472b6' : '#94a3b8' }}, 
                                                team.pythProjWins + '-' + team.pythProjLosses
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: '#34d399', borderLeft: '1px solid rgba(139, 92, 246, 0.2)' }}, team.adjOrtg.toFixed(1)),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: '#f87171' }}, team.adjDrtg.toFixed(1)),
                                            e('td', { style: { padding: '6px', textAlign: 'center', fontWeight: 'bold', color: getValueColor(team.adjNet, 5) }}, 
                                                (team.adjNet >= 0 ? '+' : '') + team.adjNet.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', fontWeight: 'bold', color: getEloColor(team.elo), borderLeft: '1px solid rgba(139, 92, 246, 0.2)' }}, 
                                                Math.round(team.elo)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: getPctColor(team.pythWinPct), borderLeft: '1px solid rgba(139, 92, 246, 0.2)' }}, 
                                                team.pythExpWins.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: getPctColor(team.eloExpWinsSchedule / team.games) }}, 
                                                team.eloExpWinsSchedule.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: getValueColor(team.luck, 2) }}, 
                                                (team.luck >= 0 ? '+' : '') + team.luck.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: getValueColor(team.sosNetRtg, 5), borderLeft: '1px solid rgba(139, 92, 246, 0.2)' }}, 
                                                (team.sosNetRtg >= 0 ? '+' : '') + team.sosNetRtg.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: getEloColor(team.sosElo) }}, 
                                                Math.round(team.sosElo)
                                            )
                                        )
                                    )
                                )
                            )
                        ),
                        e('div', { style: { fontSize: '10px', color: '#64748b', marginBottom: '24px', fontStyle: 'italic', lineHeight: '1.6' }},
                            e('div', null, '* ELO xW = Schedule-adjusted expected wins (calculated using ELO win probability vs each actual opponent faced)'),
                            e('div', { style: { marginTop: '4px' }}, 
                                '† Proj W-L = Projected record if every team plays each other 4× (' + 
                                (teamRatings.length > 0 ? teamRatings[0].seasonLength : '—') + 
                                ' games). ELO uses win probability from ELO ratings; Pyth uses Adjusted Net Rating differential.'
                            ),
                            e('div', { style: { marginTop: '4px', color: '#a78bfa' }}, 
                                '⚡ SOS Net & SOS ELO always use full season data (' + allGames.length + ' games) regardless of date filter'
                            )
                        ),
                        // Expected Wins Comparison Table
                        e('h3', { style: { fontSize: '14px', fontWeight: '600', color: '#a78bfa', marginBottom: '12px' }}, '📊 Expected Wins Analysis (Multiple Methods)'),
                        e('div', { style: { overflowX: 'auto', marginBottom: '32px' }},
                            e('table', { style: { width: '100%', borderCollapse: 'collapse', fontSize: '11px' }},
                                e('thead', null,
                                    e('tr', { style: { background: 'rgba(139, 92, 246, 0.2)', borderBottom: '2px solid rgba(139, 92, 246, 0.4)' }},
                                        e('th', { style: { padding: '8px 6px', textAlign: 'left', fontSize: '9px', fontWeight: '600', color: '#a78bfa' }, title: 'Team name' }, 'Team'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#94a3b8' }, title: 'Actual number of wins' }, 'Actual', e('br'), 'Wins'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#f472b6', borderLeft: '1px solid rgba(139, 92, 246, 0.3)' }, title: 'Pythagorean expected wins based on points scored vs points allowed' }, 'Pyth', e('br'), 'xW'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#fbbf24' }, title: 'Expected wins based on ELO rating vs league average opponent' }, 'ELO', e('br'), 'vs Avg'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#22d3ee' }, title: 'Expected wins using ELO probability vs each actual opponent faced (schedule-adjusted)' }, 'ELO', e('br'), 'Schedule'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#34d399' }, title: 'Expected wins using Bill James Log5 formula with win percentages vs actual opponents' }, 'Log5', e('br'), 'xW'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#a78bfa' }, title: 'Expected wins based on net rating differential vs opponents' }, 'Net Rtg', e('br'), 'xW'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#94a3b8', borderLeft: '1px solid rgba(139, 92, 246, 0.3)' }, title: 'Pythagorean luck: actual wins minus Pythagorean expected wins' }, 'Pyth', e('br'), 'Luck'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#94a3b8' }, title: 'ELO luck: actual wins minus ELO schedule-adjusted expected wins' }, 'ELO', e('br'), 'Luck'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#fbbf24', borderLeft: '1px solid rgba(139, 92, 246, 0.3)' }, title: 'ELO-based win probability vs average opponent' }, 'Win', e('br'), '%')
                                    )
                                ),
                                e('tbody', null,
                                    [...teamRatings].sort((a, b) => b.eloExpWinsSchedule - a.eloExpWinsSchedule).map((team, idx) => 
                                        e('tr', { 
                                            key: team.name + '-xw',
                                            style: { 
                                                background: idx % 2 === 0 ? 'rgba(30, 41, 59, 0.3)' : 'rgba(15, 23, 42, 0.3)',
                                                borderBottom: '1px solid rgba(71, 85, 105, 0.2)'
                                            }
                                        },
                                            e('td', { style: { padding: '6px', fontWeight: '600', color: '#e2e8f0', whiteSpace: 'nowrap' }}, team.name),
                                            e('td', { style: { padding: '6px', textAlign: 'center', fontWeight: 'bold', color: '#e2e8f0' }}, team.wins),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: '#f472b6', borderLeft: '1px solid rgba(139, 92, 246, 0.15)' }}, team.pythExpWins.toFixed(1)),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: '#fbbf24' }}, team.eloExpWins.toFixed(1)),
                                            e('td', { style: { padding: '6px', textAlign: 'center', fontWeight: 'bold', color: '#22d3ee' }}, team.eloExpWinsSchedule.toFixed(1)),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: '#34d399' }}, team.log5ExpWins.toFixed(1)),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: '#a78bfa' }}, team.netRtgExpWins.toFixed(1)),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: getValueColor(team.pythLuck, 2), borderLeft: '1px solid rgba(139, 92, 246, 0.15)' }}, 
                                                (team.pythLuck >= 0 ? '+' : '') + team.pythLuck.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: getValueColor(team.luck, 2) }}, 
                                                (team.luck >= 0 ? '+' : '') + team.luck.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', fontWeight: 'bold', color: getPctColor(team.eloWinPct), borderLeft: '1px solid rgba(139, 92, 246, 0.15)' }}, 
                                                (team.eloWinPct * 100).toFixed(1) + '%'
                                            )
                                        )
                                    )
                                )
                            )
                        ),
                        // Points Added Analysis
                        e('h3', { style: { fontSize: '14px', fontWeight: '600', color: '#a78bfa', marginBottom: '12px' }}, '⚔️ Points Added Analysis (Four Factors)'),
                        e('div', { style: { overflowX: 'auto', marginBottom: '32px' }},
                            e('table', { style: { width: '100%', borderCollapse: 'collapse', fontSize: '11px' }},
                                e('thead', null,
                                    e('tr', { style: { background: 'rgba(139, 92, 246, 0.2)', borderBottom: '2px solid rgba(139, 92, 246, 0.4)' }},
                                        e('th', { style: { padding: '8px 6px', textAlign: 'left', fontSize: '9px', fontWeight: '600', color: '#a78bfa' }, title: 'Team name' }, 'Team'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#34d399', borderLeft: '1px solid rgba(139, 92, 246, 0.3)' }, title: 'Points added from offensive effective field goal % vs league average' }, 'Off', e('br'), 'eFG PA'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#34d399' }, title: 'Points added from lower offensive turnover rate vs league average' }, 'Off', e('br'), 'TOV PA'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#34d399' }, title: 'Points added from offensive rebound % vs league average' }, 'Off', e('br'), 'ORB PA'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#34d399' }, title: 'Points added from free throw rate vs league average' }, 'Off', e('br'), 'FTR PA'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#22d3ee', borderLeft: '1px solid rgba(139, 92, 246, 0.3)' }, title: 'Total points added from shooting efficiency (eFG + FTR)' }, 'Scoring', e('br'), 'PA'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#22d3ee' }, title: 'Total points added from possession factors (turnovers + rebounds)' }, 'Poss', e('br'), 'PA'),
                                        e('th', { style: { padding: '8px 6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#fbbf24', borderLeft: '1px solid rgba(139, 92, 246, 0.3)' }, title: 'Total points added from all four factors combined' }, 'Total', e('br'), 'PA')
                                    )
                                ),
                                e('tbody', null,
                                    [...teamRatings].sort((a, b) => b.totalPA - a.totalPA).map((team, idx) => {
                                        // Calculate individual component PAs
                                        const offEfgPA = (team.offEfg - leagueAvg.efg) * POINTS_PER_PCT.efg;
                                        const offTovPA = (leagueAvg.tovPct - team.offTovPct) * POINTS_PER_PCT.tovPct;
                                        const offOrebPA = (team.offOrebPct - leagueAvg.orebPct) * POINTS_PER_PCT.orebPct;
                                        const offFtrPA = (team.offFtRate - leagueAvg.ftRate) * POINTS_PER_PCT.ftRate;
                                        
                                        return e('tr', { 
                                            key: team.name + '-pa',
                                            style: { 
                                                background: idx % 2 === 0 ? 'rgba(30, 41, 59, 0.3)' : 'rgba(15, 23, 42, 0.3)',
                                                borderBottom: '1px solid rgba(71, 85, 105, 0.2)'
                                            }
                                        },
                                            e('td', { style: { padding: '6px', fontWeight: '600', color: '#e2e8f0', whiteSpace: 'nowrap' }}, team.name),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: getValueColor(offEfgPA, 3), borderLeft: '1px solid rgba(139, 92, 246, 0.15)' }}, 
                                                (offEfgPA >= 0 ? '+' : '') + offEfgPA.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: getValueColor(offTovPA, 3) }}, 
                                                (offTovPA >= 0 ? '+' : '') + offTovPA.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: getValueColor(offOrebPA, 2) }}, 
                                                (offOrebPA >= 0 ? '+' : '') + offOrebPA.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', color: getValueColor(offFtrPA, 2) }}, 
                                                (offFtrPA >= 0 ? '+' : '') + offFtrPA.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', fontWeight: '600', color: getValueColor(team.scoringPA, 5), borderLeft: '1px solid rgba(139, 92, 246, 0.15)' }}, 
                                                (team.scoringPA >= 0 ? '+' : '') + team.scoringPA.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', fontWeight: '600', color: getValueColor(team.possPA, 5) }}, 
                                                (team.possPA >= 0 ? '+' : '') + team.possPA.toFixed(1)
                                            ),
                                            e('td', { style: { padding: '6px', textAlign: 'center', fontWeight: 'bold', color: getValueColor(team.totalPA, 8), borderLeft: '1px solid rgba(139, 92, 246, 0.15)' }}, 
                                                (team.totalPA >= 0 ? '+' : '') + team.totalPA.toFixed(1)
                                            )
                                        );
                                    })
                                )
                            )
                        ),
                        // Four Factors breakdown
                        e('h3', { style: { fontSize: '14px', fontWeight: '600', color: '#a78bfa', marginBottom: '12px' }}, '📈 Four Factors Analysis (Weighted Z-Scores)'),
                        e('div', { style: { overflowX: 'auto', marginBottom: '32px' }},
                            e('table', { style: { width: '100%', borderCollapse: 'collapse', fontSize: '10px' }},
                                e('thead', null,
                                    e('tr', { style: { background: 'rgba(139, 92, 246, 0.15)', borderBottom: '2px solid rgba(139, 92, 246, 0.3)' }},
                                        e('th', { style: { padding: '6px', textAlign: 'left', fontSize: '9px', fontWeight: '600', color: '#a78bfa' }}, 'Team'),
                                        e('th', { colSpan: 5, style: { padding: '6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#34d399', borderLeft: '1px solid rgba(139, 92, 246, 0.2)' }}, 'OFFENSE (Z × Weight)'),
                                        e('th', { colSpan: 5, style: { padding: '6px', textAlign: 'center', fontSize: '9px', fontWeight: '600', color: '#f87171', borderLeft: '1px solid rgba(139, 92, 246, 0.2)' }}, 'DEFENSE (Z × Weight)')
                                    ),
                                    e('tr', { style: { background: 'rgba(30, 41, 59, 0.5)' }},
                                        e('th', { style: { padding: '4px', fontSize: '8px', color: '#64748b' }}, ''),
                                        e('th', { style: { padding: '4px', textAlign: 'center', fontSize: '8px', color: '#64748b', borderLeft: '1px solid rgba(139, 92, 246, 0.2)' }}, 'eFG', e('br'), '(46%)'),
                                        e('th', { style: { padding: '4px', textAlign: 'center', fontSize: '8px', color: '#64748b' }}, 'TOV', e('br'), '(35%)'),
                                        e('th', { style: { padding: '4px', textAlign: 'center', fontSize: '8px', color: '#64748b' }}, 'OREB', e('br'), '(12%)'),
                                        e('th', { style: { padding: '4px', textAlign: 'center', fontSize: '8px', color: '#64748b' }}, 'FTR', e('br'), '(7%)'),
                                        e('th', { style: { padding: '4px', textAlign: 'center', fontSize: '8px', color: '#34d399' }}, 'Total'),
                                        e('th', { style: { padding: '4px', textAlign: 'center', fontSize: '8px', color: '#64748b', borderLeft: '1px solid rgba(139, 92, 246, 0.2)' }}, 'eFG', e('br'), '(46%)'),
                                        e('th', { style: { padding: '4px', textAlign: 'center', fontSize: '8px', color: '#64748b' }}, 'TOV', e('br'), '(35%)'),
                                        e('th', { style: { padding: '4px', textAlign: 'center', fontSize: '8px', color: '#64748b' }}, 'OREB', e('br'), '(12%)'),
                                        e('th', { style: { padding: '4px', textAlign: 'center', fontSize: '8px', color: '#64748b' }}, 'FTR', e('br'), '(7%)'),
                                        e('th', { style: { padding: '4px', textAlign: 'center', fontSize: '8px', color: '#f87171' }}, 'Total')
                                    )
                                ),
                                e('tbody', null,
                                    [...teamRatings].sort((a, b) => (b.offFFScore + b.defFFScore) - (a.offFFScore + a.defFFScore)).map((team, idx) => 
                                        e('tr', { 
                                            key: team.name + '-ff',
                                            style: { 
                                                background: idx % 2 === 0 ? 'rgba(30, 41, 59, 0.3)' : 'rgba(15, 23, 42, 0.3)',
                                                borderBottom: '1px solid rgba(71, 85, 105, 0.2)'
                                            }
                                        },
                                            e('td', { style: { padding: '5px', fontSize: '10px', fontWeight: '500', color: '#e2e8f0', whiteSpace: 'nowrap' }}, team.name),
                                            e('td', { style: { padding: '5px', textAlign: 'center', color: getValueColor(team.zOffEfg, 1.5), borderLeft: '1px solid rgba(139, 92, 246, 0.15)' }}, team.zOffEfg.toFixed(2)),
                                            e('td', { style: { padding: '5px', textAlign: 'center', color: getValueColor(team.zOffTovPct, 1.5) }}, team.zOffTovPct.toFixed(2)),
                                            e('td', { style: { padding: '5px', textAlign: 'center', color: getValueColor(team.zOffOrebPct, 1.5) }}, team.zOffOrebPct.toFixed(2)),
                                            e('td', { style: { padding: '5px', textAlign: 'center', color: getValueColor(team.zOffFtRate, 1.5) }}, team.zOffFtRate.toFixed(2)),
                                            e('td', { style: { padding: '5px', textAlign: 'center', fontWeight: 'bold', color: getValueColor(team.offFFScore, 0.5) }}, team.offFFScore.toFixed(2)),
                                            e('td', { style: { padding: '5px', textAlign: 'center', color: getValueColor(team.zDefEfg, 1.5), borderLeft: '1px solid rgba(139, 92, 246, 0.15)' }}, team.zDefEfg.toFixed(2)),
                                            e('td', { style: { padding: '5px', textAlign: 'center', color: getValueColor(team.zDefTovPct, 1.5) }}, team.zDefTovPct.toFixed(2)),
                                            e('td', { style: { padding: '5px', textAlign: 'center', color: getValueColor(team.zDefOrebPct, 1.5) }}, team.zDefOrebPct.toFixed(2)),
                                            e('td', { style: { padding: '5px', textAlign: 'center', color: getValueColor(team.zDefFtRate, 1.5) }}, team.zDefFtRate.toFixed(2)),
                                            e('td', { style: { padding: '5px', textAlign: 'center', fontWeight: 'bold', color: getValueColor(team.defFFScore, 0.5) }}, team.defFFScore.toFixed(2))
                                        )
                                    )
                                )
                            )
                        ),
                        // Methodology
                        e('div', { style: { padding: '16px', background: 'rgba(30, 41, 59, 0.5)', borderRadius: '8px', border: '1px solid rgba(71, 85, 105, 0.3)' }},
                            e('h4', { style: { fontSize: '12px', fontWeight: '600', color: '#a78bfa', marginBottom: '12px' }}, '📚 Methodology & Sources'),
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', gap: '16px', fontSize: '10px', color: '#94a3b8', lineHeight: '1.6' }},
                                e('div', null,
                                    e('strong', { style: { color: '#c4b5fd' }}, 'Adjusted Ratings (KenPom-style)'),
                                    e('br'),
                                    'Iterative ridge regression with additive adjustments per KenPom\'s 2014 methodology: AdjO = RawO + (LgAvg - AvgOppD) × ' + REGRESSION_FACTOR,
                                    e('br'), e('br'),
                                    e('strong', { style: { color: '#c4b5fd' }}, 'Four Factors Weights'),
                                    e('br'),
                                    'Empirical weights from regression analysis (Squared Statistics 2017): eFG% 46.3%, TOV% 35.1%, OREB% 11.9%, FT Rate 6.8%'
                                ),
                                e('div', null,
                                    e('strong', { style: { color: '#c4b5fd' }}, 'Pythagorean Expectation'),
                                    e('br'),
                                    'Win% = PF¹⁴ / (PF¹⁴ + PA¹⁴) per Basketball-Reference (RMSE 3.14 wins)',
                                    e('br'), e('br'),
                                    e('strong', { style: { color: '#c4b5fd' }}, 'ELO Rating'),
                                    e('br'),
                                    'FiveThirtyEight-style with MOV multiplier: Δ = K × log(MOV+1) × (2.2/(eloDiff×0.001+2.2)) × (actual - expected)'
                                ),
                                e('div', null,
                                    e('strong', { style: { color: '#c4b5fd' }}, 'Expected Wins Methods'),
                                    e('br'),
                                    '• Pyth xW: PF¹⁴ / (PF¹⁴ + PA¹⁴) × games',
                                    e('br'),
                                    '• ELO vs Avg: P = 1/(1+10^((1500-ELO)/400)) × games',
                                    e('br'),
                                    '• ELO Schedule: Σ P(win vs each opponent) using matchup ELOs',
                                    e('br'),
                                    '• Log5: P(A>B) = (pA - pA×pB) / (pA + pB - 2×pA×pB)',
                                    e('br'),
                                    '• Net Rtg: P = 1/(1+10^(-NetDiff/10))',
                                    e('br'), e('br'),
                                    e('strong', { style: { color: '#c4b5fd' }}, 'Luck'),
                                    e('br'),
                                    'Actual Wins - Schedule-Adjusted ELO Expected Wins'
                                ),
                                e('div', null,
                                    e('strong', { style: { color: '#c4b5fd' }}, 'Projected W-L'),
                                    e('br'),
                                    'ELO win% vs average opponent × estimated season length',
                                    e('br'), e('br'),
                                    e('strong', { style: { color: '#c4b5fd' }}, 'Points Added'),
                                    e('br'),
                                    'Per factor vs league avg × pts/100 impact:',
                                    e('br'),
                                    'eFG%: 2.0, TOV%: 1.4, OREB%: 0.7, FTR: 0.4'
                                )
                            )
                        )
                    );
                })(),
                // Show Analyzer tab content
                activeTab === 'analyzer' && e('div', { className: 'dataset-info', style: { padding: '10px 14px' } }, 
                    e('div', { style: { display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: '8px', justifyContent: 'space-between' }},
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' }},
                            e('span', { style: { fontSize: '11px', fontWeight: '600', color: '#94a3b8' }}, '📊 Legend'),
                            e('div', { className: 'legend-item legend-excellent', style: { fontSize: '10px', padding: '2px 8px' }}, '🌟 Elite (90th+)'), 
                            e('div', { className: 'legend-item legend-good', style: { fontSize: '10px', padding: '2px 8px' }}, '✓ Good (70-89th)'), 
                            e('div', { className: 'legend-item legend-average', style: { fontSize: '10px', padding: '2px 8px' }}, '━ Avg (30-69th)'), 
                            e('div', { className: 'legend-item legend-below', style: { fontSize: '10px', padding: '2px 8px' }}, '⚠ Below (10-29th)'), 
                            e('div', { className: 'legend-item legend-poor', style: { fontSize: '10px', padding: '2px 8px' }}, '✗ Poor (<10th)'),
                            e('span', { style: { fontSize: '10px', color: '#64748b', marginLeft: '4px' }}, 'vs ' + allTeamsAverages.length + ' teams'),
                            e('span', { className: 'pct-box pct-yours', style: { fontSize: '9px', marginLeft: '4px' }}, e('span', { className: 'pct-box-label', style: { color: '#60a5fa' }}, 'YOU'), '50th'),
                            e('span', { className: 'pct-box pct-opp', style: { fontSize: '9px' }}, e('span', { className: 'pct-box-label', style: { color: '#a78bfa' }}, 'OPP'), '50th')
                        ),
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', flexWrap: 'wrap' }},
                            matchupFile && e('span', { style: { fontSize: '10px', color: '#22d3ee' }}, '⚔️ Opp Context'),
                            matchupFile && afc === 0 && e('span', { style: { fontSize: '9px', color: '#fbbf24', background: 'rgba(251, 191, 36, 0.2)', padding: '2px 6px', borderRadius: '4px' }}, 'Team-wide'),
                            matchupFile && e('span', { style: { display: 'flex', gap: '3px' }},
                                e('span', { className: 'opp-badge opp-hard', style: { fontSize: '8px', padding: '1px 4px' }}, 'Hard'),
                                e('span', { className: 'opp-badge opp-tough', style: { fontSize: '8px', padding: '1px 4px' }}, 'Tough'),
                                e('span', { className: 'opp-badge opp-neutral', style: { fontSize: '8px', padding: '1px 4px' }}, 'Neutral'),
                                e('span', { className: 'opp-badge opp-soft', style: { fontSize: '8px', padding: '1px 4px' }}, 'Soft'),
                                e('span', { className: 'opp-badge opp-easy', style: { fontSize: '8px', padding: '1px 4px' }}, 'Easy')
                            ),
                            seasonFile && e('span', { style: { fontSize: '10px', color: '#10b981' }}, '📈 Season Stats: Green=better, Red=worse')
                        )
                    ),
                    e('div', { style: { marginTop: '6px', fontSize: '10px', color: '#64748b' }}, lineupData.length + ' lineups | ' + teams.length + ' teams | ' + seasonData.length + ' season player records')
                ), 
                activeTab === 'analyzer' && e('div', { className: 'controls' }, 
                    // V6.0: Redesigned Collapsible Team & Player Filters Section
                    e('div', { style: { marginBottom: '16px' }},
                        // Header bar (always visible) with team dropdown and player selectors inline
                        e('div', { 
                            style: { 
                                display: 'flex', 
                                alignItems: 'center',
                                gap: '12px',
                                padding: '10px 14px',
                                background: 'rgba(59, 130, 246, 0.1)',
                                border: '1px solid rgba(59, 130, 246, 0.3)',
                                borderRadius: showPlayerFiltersSection ? '8px 8px 0 0' : '8px',
                                flexWrap: 'wrap'
                            }
                        },
                            e('label', { style: { fontWeight: 'bold', fontSize: '13px', color: '#60a5fa', whiteSpace: 'nowrap' }}, '🏀 Team & Player Filters'),
                            // Team dropdown - always visible
                            e('select', {
                                value: team,
                                onChange: ev => {
                                    ev.stopPropagation();
                                    setTeam(ev.target.value);
                                    // V5.24: Auto-deselect players when team changes
                                    setSelPlayers({ p1: '', p2: '', p3: '', p4: '', p5: '' });
                                    setExPlayers({ e1: '', e2: '', e3: '', e4: '' });
                                },
                                onClick: ev => ev.stopPropagation(),
                                style: {
                                    padding: '6px 10px',
                                    background: '#0f172a',
                                    border: '1px solid #3b82f6',
                                    borderRadius: '6px',
                                    color: '#93c5fd',
                                    fontSize: '11px',
                                    fontWeight: '600',
                                    minWidth: '140px'
                                }
                            }, teams.map(t => e('option', { key: t, value: t }, t))),
                            // Player selection dropdowns - always visible
                            e('div', { style: { display: 'flex', gap: '6px', alignItems: 'center', flex: '1', minWidth: '0', flexWrap: 'wrap' }},
                                ['p1', 'p2', 'p3', 'p4', 'p5'].map((p, i) => e('select', { 
                                    key: p,
                                    value: selPlayers[p], 
                                    onChange: ev => { ev.stopPropagation(); setSelPlayers(pr => ({ ...pr, [p]: ev.target.value })); },
                                    onClick: ev => ev.stopPropagation(),
                                    style: { 
                                        padding: '5px 6px', 
                                        background: selPlayers[p] ? 'rgba(34, 197, 94, 0.2)' : '#0f172a', 
                                        border: selPlayers[p] ? '1px solid #22c55e' : '1px solid #475569', 
                                        borderRadius: '5px', 
                                        color: selPlayers[p] ? '#86efac' : '#94a3b8', 
                                        fontSize: '10px',
                                        minWidth: '80px',
                                        maxWidth: '120px',
                                        flex: '1'
                                    }
                                }, 
                                    e('option', { value: '' }, 'P' + (i + 1) + ': Any'), 
                                    teamPlayers.map(pl => e('option', { key: pl, value: pl, disabled: Object.values(selPlayers).includes(pl) && selPlayers[p] !== pl }, pl))
                                ))
                            ),
                            // Clear and Players button
                            e('div', { style: { display: 'flex', gap: '6px', alignItems: 'center' }},
                                playerData.length > 0 && e('button', { 
                                    className: 'btn btn-success', 
                                    onClick: (ev) => { ev.stopPropagation(); setShowModal(true); }, 
                                    style: { fontSize: '10px', padding: '5px 10px' }
                                }, '👤', seasonFile && ' +Season'),
                                e('button', { 
                                    className: 'btn btn-secondary', 
                                    onClick: (ev) => { ev.stopPropagation(); setSelPlayers({ p1: '', p2: '', p3: '', p4: '', p5: '' }); }, 
                                    style: { fontSize: '10px', padding: '5px 8px' }
                                }, '↻'),
                                Object.values(exPlayers).filter(p => p).length > 0 && e('span', { 
                                    style: { 
                                        background: 'rgba(239, 68, 68, 0.3)', 
                                        padding: '3px 8px', 
                                        borderRadius: '10px', 
                                        fontSize: '10px',
                                        color: '#fca5a5',
                                        fontWeight: '600'
                                    }
                                }, '✗ ' + Object.values(exPlayers).filter(p => p).length + ' excluded'),
                                afc === 0 && e('span', { 
                                    style: { 
                                        background: 'rgba(251, 191, 36, 0.2)', 
                                        padding: '3px 8px', 
                                        borderRadius: '10px', 
                                        fontSize: '9px',
                                        color: '#fcd34d'
                                    }
                                }, 'Team-wide')
                            ),
                            e('button', { 
                                className: 'btn btn-secondary',
                                style: { fontSize: '10px', padding: '4px 10px', marginLeft: 'auto' },
                                onClick: () => setShowPlayerFiltersSection(!showPlayerFiltersSection)
                            }, showPlayerFiltersSection ? '▲' : '▼ Exclude')
                        ),
                        // Content (only shows exclude section now)
                        showPlayerFiltersSection && e('div', { 
                            style: { 
                                padding: '12px 14px', 
                                background: 'rgba(30, 41, 59, 0.5)',
                                border: '1px solid rgba(59, 130, 246, 0.3)',
                                borderTop: 'none',
                                borderRadius: '0 0 8px 8px'
                            }
                        },
                            e('div', { className: 'flex-between', style: { marginBottom: '8px' }}, 
                                e('label', { style: { color: '#ef4444', fontSize: '12px', fontWeight: '600' }}, '✗ Exclude Players'), 
                                e('button', { className: 'btn btn-secondary', onClick: () => setExPlayers({ e1: '', e2: '', e3: '', e4: '' }), style: { fontSize: '10px', padding: '4px 10px' }}, 'Clear')
                            ), 
                            e('div', { className: 'grid-4', style: { gap: '8px' }}, 
                                ['e1', 'e2', 'e3', 'e4'].map((p, i) => e('div', { key: p }, 
                                    e('select', { 
                                        value: exPlayers[p], 
                                        onChange: ev => setExPlayers(pr => ({ ...pr, [p]: ev.target.value })), 
                                        style: { 
                                            width: '100%',
                                            padding: '6px 8px',
                                            background: exPlayers[p] ? 'rgba(239, 68, 68, 0.15)' : '#0f172a',
                                            border: exPlayers[p] ? '1px solid #dc2626' : '1px solid #475569',
                                            borderRadius: '6px',
                                            color: exPlayers[p] ? '#fca5a5' : 'white',
                                            fontSize: '11px'
                                        } 
                                    }, 
                                        e('option', { value: '' }, 'Exclude ' + (i + 1) + ': None'), 
                                        teamPlayers.map(pl => e('option', { key: pl, value: pl, disabled: Object.values(exPlayers).includes(pl) && exPlayers[p] !== pl }, pl))
                                    )
                                ))
                            )
                        )
                    ),
                    // V6.0: Min Matchup Poss & Bayesian Shrinkage - with slider in collapsed row
                    matchupData.length > 0 && e('div', { 
                        style: { 
                            marginTop: '12px',
                            background: 'rgba(167, 139, 250, 0.08)',
                            border: '1px solid rgba(167, 139, 250, 0.3)',
                            borderRadius: '8px'
                        }
                    },
                        // Header bar with min poss slider inline
                        e('div', { 
                            style: { 
                                display: 'flex', 
                                alignItems: 'center',
                                gap: '12px',
                                padding: '10px 14px',
                                background: 'rgba(167, 139, 250, 0.1)',
                                borderRadius: showMinPossSection ? '8px 8px 0 0' : '8px',
                                flexWrap: 'wrap'
                            }
                        },
                            e('label', { style: { color: '#c4b5fd', fontWeight: 'bold', fontSize: '13px', whiteSpace: 'nowrap' }}, '📊 Min Matchup Poss'),
                            // Min Poss Slider - always visible
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', flex: '1', minWidth: '150px', maxWidth: '250px' }},
                                e('input', {
                                    type: 'range',
                                    min: 0,
                                    max: 30,
                                    step: 1,
                                    value: minMatchupPoss,
                                    onChange: ev => { ev.stopPropagation(); setMinMatchupPoss(parseInt(ev.target.value) || 0); },
                                    onClick: ev => ev.stopPropagation(),
                                    style: { flex: 1, accentColor: '#a78bfa', height: '4px' }
                                }),
                                e('span', { 
                                    style: { 
                                        background: 'rgba(167, 139, 250, 0.3)', 
                                        padding: '2px 8px', 
                                        borderRadius: '10px', 
                                        fontSize: '11px',
                                        color: '#c4b5fd',
                                        fontWeight: '600',
                                        minWidth: '35px',
                                        textAlign: 'center'
                                    }
                                }, minMatchupPoss)
                            ),
                            // Bayesian badge
                            bayesianShrinkage && e('span', { 
                                style: { 
                                    background: 'rgba(34, 197, 94, 0.3)', 
                                    padding: '3px 10px', 
                                    borderRadius: '12px', 
                                    fontSize: '10px',
                                    color: '#86efac',
                                    fontWeight: '600'
                                }
                            }, '✓ Bayesian'),
                            e('button', { 
                                className: 'btn btn-secondary',
                                style: { fontSize: '10px', padding: '4px 10px', marginLeft: 'auto' },
                                onClick: () => setShowMinPossSection(!showMinPossSection)
                            }, showMinPossSection ? '▲' : '▼ Bayesian')
                        ),
                        showMinPossSection && e('div', { style: { padding: '12px 14px' }},
                        e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '16px', alignItems: 'flex-start' }},
                            // Bayesian Shrinkage Toggle (main content now)
                            e('div', { style: { flex: '1', minWidth: '250px' }},
                                e('label', { style: { fontSize: '12px', color: '#c4b5fd', display: 'block', marginBottom: '6px' }}, 
                                    '🎯 Bayesian Shrinkage'
                                ),
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' }},
                                    e('button', {
                                        className: bayesianShrinkage ? 'btn btn-primary' : 'btn btn-secondary',
                                        onClick: () => setBayesianShrinkage(!bayesianShrinkage),
                                        style: { fontSize: '11px', padding: '6px 12px' }
                                    }, bayesianShrinkage ? '✓ Enabled' : 'Disabled'),
                                    bayesianShrinkage && e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px' }},
                                        e('span', { style: { fontSize: '11px', color: '#94a3b8' }}, 'Prior weight:'),
                                        e('input', {
                                            type: 'number',
                                            min: 5,
                                            max: 100,
                                            value: shrinkagePriorWeight,
                                            onChange: ev => setShrinkagePriorWeight(Math.max(5, parseInt(ev.target.value) || 30)),
                                            style: { width: '45px', padding: '4px', background: '#1e293b', border: '1px solid #475569', borderRadius: '4px', color: '#f1f5f9', fontSize: '11px' }
                                        }),
                                        e('span', { style: { fontSize: '11px', color: '#94a3b8' }}, 'poss')
                                    )
                                ),
                                bayesianShrinkage && fStats && fStats.shrinkageApplied && e('div', { 
                                    style: { fontSize: '10px', color: '#86efac', marginTop: '6px', padding: '4px 8px', background: 'rgba(34, 197, 94, 0.15)', borderRadius: '4px', display: 'inline-block' }
                                }, '⚡ ' + (fStats.shrinkageFactor * 100).toFixed(1) + '% observed / ' + ((1 - fStats.shrinkageFactor) * 100).toFixed(1) + '% prior')
                            ),
                            // Info about both settings
                            e('div', { style: { flex: '1', minWidth: '200px', fontSize: '10px', color: '#64748b', padding: '8px', background: 'rgba(0,0,0,0.15)', borderRadius: '6px' }},
                                e('p', { style: { marginBottom: '4px' }}, '📊 Min Poss: Excludes low-sample matchups from Opponent Quality calculations'),
                                e('p', null, '🎯 Bayesian: Regresses lineup stats and opponent quality toward league averages based on sample size')
                            )
                        ),
                        // Status indicator for LINEUP stats
                        (minMatchupPoss > 0 || bayesianShrinkage) && fStats && e('div', { 
                            style: { 
                                marginTop: '12px', 
                                padding: '10px 12px', 
                                background: 'rgba(34, 197, 94, 0.15)', 
                                border: '1px solid rgba(34, 197, 94, 0.3)',
                                borderRadius: '6px',
                                fontSize: '11px',
                                color: '#86efac'
                            }
                        }, 
                            e('strong', null, '📈 Lineup Stats: '),
                            fStats.isFromMatchups 
                                ? [
                                    fStats.matchupCount + ' matchups',
                                    minMatchupPoss > 0 && fStats.excludedMatchups > 0 && ' (' + fStats.excludedMatchups + ' excluded < ' + minMatchupPoss + ' poss)',
                                    ' • ',
                                    Math.round(fStats.rawPoss || fStats.poss) + ' possessions',
                                    bayesianShrinkage && fStats.shrinkageApplied && ' • Bayesian adjusted'
                                ]
                                : 'Using lineup aggregates (no matchup filtering available)'
                        ),
                        // Status indicator for OPPONENT QUALITY
                        (minMatchupPoss > 0 || bayesianShrinkage) && oppQuality && e('div', { 
                            style: { 
                                marginTop: '8px', 
                                padding: '10px 12px', 
                                background: 'rgba(167, 139, 250, 0.15)', 
                                borderRadius: '6px',
                                fontSize: '11px',
                                color: '#c4b5fd'
                            }
                        }, 
                            e('strong', null, '⚔️ Opponent Quality: '),
                            oppQuality.oppCount, ' opponents, ',
                            Math.round(oppQuality.totalPoss), ' possessions',
                            minMatchupPoss > 0 && ' (min ' + minMatchupPoss + ' poss/matchup)',
                            bayesianShrinkage && oppQuality.shrinkageApplied && ' • Bayesian adjusted'
                        )
                    ) // Close showMinPossSection
                    ),
                    // V6.0: 3PT Luck Adjustment & Opponent Quality Filter - Side by side row
                    e('div', {
                        style: {
                            display: 'flex',
                            gap: '12px',
                            marginTop: '12px',
                            flexWrap: 'wrap',
                            alignItems: 'flex-start'
                        }
                    },
                        // 3PT Luck Adjustment (left side)
                        (seasonFile || playerData.length > 0) && e('div', {
                            style: {
                                flex: '1',
                                minWidth: '300px',
                                padding: '10px 14px',
                                background: 'rgba(245, 158, 11, 0.08)',
                                border: '1px solid rgba(245, 158, 11, 0.3)',
                                borderRadius: '8px'
                            }
                        },
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '16px', flexWrap: 'wrap' }},
                                e('label', { style: { color: '#f59e0b', fontWeight: 'bold', fontSize: '13px', whiteSpace: 'nowrap' }}, '🎲 3PT Luck Adjustment'),
                                // Offensive slider
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', flex: '1', minWidth: '140px', maxWidth: '200px' }},
                                    e('span', { style: { fontSize: '10px', color: '#4ade80', fontWeight: '600' }}, '🏀 Off'),
                                    e('input', {
                                        type: 'range',
                                        min: 0,
                                        max: 100,
                                        value: offLuckAdj,
                                        onChange: ev => setOffLuckAdj(parseInt(ev.target.value)),
                                        style: { flex: 1, accentColor: '#22c55e', height: '4px' }
                                    }),
                                    e('span', {
                                        style: {
                                            background: offLuckAdj > 0 ? 'rgba(34, 197, 94, 0.3)' : 'rgba(100, 116, 139, 0.2)',
                                            color: offLuckAdj > 0 ? '#4ade80' : '#94a3b8',
                                            padding: '2px 8px',
                                            borderRadius: '8px',
                                            fontWeight: '600',
                                            fontSize: '10px',
                                            minWidth: '32px',
                                            textAlign: 'center'
                                        }
                                    }, offLuckAdj + '%')
                                ),
                                // Defensive slider
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', flex: '1', minWidth: '140px', maxWidth: '200px' }},
                                    e('span', { style: { fontSize: '10px', color: '#f87171', fontWeight: '600' }}, '🛡️ Def'),
                                    e('input', {
                                        type: 'range',
                                        min: 0,
                                        max: 100,
                                        value: defLuckAdj,
                                        onChange: ev => setDefLuckAdj(parseInt(ev.target.value)),
                                        style: { flex: 1, accentColor: '#ef4444', height: '4px' }
                                    }),
                                    e('span', {
                                        style: {
                                            background: defLuckAdj > 0 ? 'rgba(239, 68, 68, 0.3)' : 'rgba(100, 116, 139, 0.2)',
                                            color: defLuckAdj > 0 ? '#f87171' : '#94a3b8',
                                            padding: '2px 8px',
                                            borderRadius: '8px',
                                            fontWeight: '600',
                                            fontSize: '10px',
                                            minWidth: '32px',
                                            textAlign: 'center'
                                        }
                                    }, defLuckAdj + '%')
                                ),
                                // Reset button
                                (offLuckAdj > 0 || defLuckAdj > 0) && e('button', {
                                    className: 'btn btn-secondary',
                                    onClick: () => { setOffLuckAdj(0); setDefLuckAdj(0); },
                                    style: { fontSize: '9px', padding: '4px 8px' }
                                }, '↻'),
                                // Info/status
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginLeft: 'auto', flexWrap: 'wrap' }},
                                    !seasonFile && e('span', { style: { fontSize: '9px', color: '#f97316' }}, '⚠️ Upload Season Stats'),
                                    seasonFile && luckAdjustedStats && luckAdjustedStats.isActive && e('span', {
                                        style: {
                                            fontSize: '10px',
                                            color: '#fbbf24',
                                            background: 'rgba(251, 191, 36, 0.15)',
                                            padding: '3px 8px',
                                            borderRadius: '6px'
                                        }
                                    }, 'Net: ' + (luckAdjustedStats.adjNet >= 0 ? '+' : '') + luckAdjustedStats.adjNet.toFixed(1))
                                )
                            )
                        ),
                        // Opponent Quality Filter (right side)
                        matchupData.length > 0 && e('div', {
                            style: {
                                flex: '1',
                                minWidth: '280px',
                                background: 'rgba(139, 92, 246, 0.08)',
                                border: '1px solid rgba(139, 92, 246, 0.3)',
                                borderRadius: '8px'
                            }
                        },
                            // Header bar with summary
                            e('div', {
                                style: {
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    padding: '10px 14px',
                                    background: 'rgba(139, 92, 246, 0.1)',
                                    borderRadius: showOppQualitySection ? '8px 8px 0 0' : '8px',
                                    cursor: 'pointer'
                                },
                                onClick: () => setShowOppQualitySection(!showOppQualitySection)
                            },
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap' }},
                                    e('label', { style: { fontWeight: 'bold', fontSize: '13px', color: '#a78bfa', cursor: 'pointer' }}, '⚔️ Opponent Quality Filter'),
                                    oppFilters.length > 0 && e('span', {
                                        style: {
                                            background: 'rgba(139, 92, 246, 0.3)',
                                            padding: '3px 10px',
                                            borderRadius: '12px',
                                            fontSize: '10px',
                                            color: '#c4b5fd',
                                            fontWeight: '600'
                                        }
                                    }, oppFilters.length + ' filter(s) • ' + (oppFilteredMatchups?.length || 0) + ' matchups'),
                                    !showOppQualitySection && oppFilters.length === 0 && e('span', {
                                        style: { fontSize: '10px', color: '#94a3b8', fontStyle: 'italic' }
                                    }, 'Filter by opponent strength')
                                ),
                                e('button', {
                                    className: 'btn btn-secondary',
                                    style: { fontSize: '10px', padding: '4px 10px' },
                                    onClick: (ev) => { ev.stopPropagation(); setShowOppQualitySection(!showOppQualitySection); }
                                }, showOppQualitySection ? '▲' : '▼')
                            ),
                            showOppQualitySection && e('div', { style: { padding: '12px 14px' }},
                            e('div', { className: 'flex-between', style: { marginBottom: '12px' }},
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' }},
                                    e('p', { style: { fontSize: '11px', color: '#94a3b8' }},
                                        'Filter stats to only show performance vs opponents meeting specific criteria'
                                    )
                                ),
                                e('div', { style: { display: 'flex', gap: '8px' }},
                                    oppFilters.length > 0 && e('button', {
                                        className: 'btn btn-secondary',
                                        onClick: () => setOppFilters([]),
                                        style: { fontSize: '11px', padding: '4px 10px' }
                                    }, 'Clear All'),
                                    e('button', {
                                        className: 'btn',
                                        style: { background: showOppFilterPanel ? '#7c3aed' : 'rgba(139, 92, 246, 0.3)', fontSize: '12px' },
                                        onClick: () => setShowOppFilterPanel(!showOppFilterPanel)
                                    }, showOppFilterPanel ? '▲ Hide' : '▼ Configure')
                                )
                            ),
                            // Active filter indicator when panel is collapsed
                            !showOppFilterPanel && oppFilters.length > 0 && fStats?.isOppFiltered && e('div', { className: 'opp-filter-active-indicator' },
                                e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: '8px' }},
                                    e('div', { style: { display: 'flex', gap: '8px', flexWrap: 'wrap' }},
                                        oppFilters.map((f, i) => {
                                            const statLabels = {
                                                off: 'Off Rtg', def: 'Def Rtg', net: 'Net Rtg',
                                                offEfg: 'Off eFG%', defEfg: 'Def eFG%',
                                                offTov: 'Off TOV%', defTov: 'Def TOV%',
                                                offOreb: 'Off OREB%', defOreb: 'Def OREB%',
                                                offFtR: 'Off FTR', defFtR: 'Def FTR',
                                                paceF: 'Pace (Off)', paceV: 'Pace (Def)',
                                                astPct: 'AST%', stlPct: 'STL%', blkPct: 'BLK%',
                                                combPoss: 'Possessions'
                                            };
                                            return e('span', {
                                                key: i,
                                                style: {
                                                    background: 'rgba(139, 92, 246, 0.2)',
                                                    padding: '4px 8px',
                                                    borderRadius: '4px',
                                                    fontSize: '11px',
                                                    color: '#c4b5fd'
                                                }
                                            }, statLabels[f.stat] + ' ' + (f.operator === 'gt' ? '>' : '<') + ' ' + f.value);
                                        })
                                    ),
                                    e('span', { style: { fontSize: '12px', color: '#a78bfa', fontWeight: 'bold' }},
                                        fStats.oppFilterMatchups + ' qualifying matchups'
                                    )
                                )
                            ),
                            // Expanded filter panel
                            showOppFilterPanel && e('div', { className: 'opp-filter-panel', style: { marginTop: '12px' }},
                                oppFilters.map((filter, idx) => e('div', { key: idx, className: 'opp-filter-row' },
                                    e('select', {
                                        className: 'opp-filter-select',
                                        value: filter.stat,
                                        onChange: ev => {
                                            const newFilters = [...oppFilters];
                                            newFilters[idx] = { ...filter, stat: ev.target.value };
                                            setOppFilters(newFilters);
                                        }
                                    },
                                        e('optgroup', { label: 'Ratings' },
                                            e('option', { value: 'off' }, 'Offensive Rating'),
                                            e('option', { value: 'def' }, 'Defensive Rating'),
                                            e('option', { value: 'net' }, 'Net Rating')
                                        ),
                                        e('optgroup', { label: 'Off Four Factors' },
                                            e('option', { value: 'offEfg' }, 'Off eFG%'),
                                            e('option', { value: 'offTov' }, 'Off TOV%'),
                                            e('option', { value: 'offOreb' }, 'Off OREB%'),
                                            e('option', { value: 'offFtR' }, 'Off FT Rate')
                                        ),
                                        e('optgroup', { label: 'Def Four Factors' },
                                            e('option', { value: 'defEfg' }, 'Def eFG%'),
                                            e('option', { value: 'defTov' }, 'Def TOV%'),
                                            e('option', { value: 'defOreb' }, 'Def OREB%'),
                                            e('option', { value: 'defFtR' }, 'Def FT Rate')
                                        ),
                                        e('optgroup', { label: 'Pace' },
                                            e('option', { value: 'paceF' }, 'Pace (Off)'),
                                            e('option', { value: 'paceV' }, 'Pace (Def)')
                                        ),
                                        e('optgroup', { label: 'Playmaking' },
                                            e('option', { value: 'astPct' }, 'AST%'),
                                            e('option', { value: 'stlPct' }, 'STL%'),
                                            e('option', { value: 'blkPct' }, 'BLK%')
                                        ),
                                        e('optgroup', { label: 'Volume' },
                                            e('option', { value: 'combPoss' }, 'Total Possessions')
                                        )
                                    ),
                                    e('select', {
                                        className: 'opp-filter-select',
                                        value: filter.operator,
                                        onChange: ev => {
                                            const newFilters = [...oppFilters];
                                            newFilters[idx] = { ...filter, operator: ev.target.value };
                                            setOppFilters(newFilters);
                                        },
                                        style: { minWidth: '100px' }
                                    },
                                        e('option', { value: 'gt' }, 'Greater than'),
                                        e('option', { value: 'lt' }, 'Less than')
                                    ),
                                    e('input', {
                                        type: 'number',
                                        className: 'opp-filter-input',
                                        value: filter.value,
                                        onChange: ev => {
                                            const newFilters = [...oppFilters];
                                            newFilters[idx] = { ...filter, value: parseFloat(ev.target.value) || 0 };
                                            setOppFilters(newFilters);
                                        },
                                        step: '0.1'
                                    }),
                                    e('button', {
                                        className: 'opp-filter-remove',
                                        onClick: () => setOppFilters(oppFilters.filter((_, i) => i !== idx))
                                    }, '×')
                                )),
                                e('button', {
                                    className: 'opp-filter-add',
                                    onClick: () => setOppFilters([...oppFilters, { stat: 'offOreb', operator: 'gt', value: 30 }])
                                }, '+ Add Filter Condition'),
                                oppFilters.length > 0 && !oppFilteredMatchups && e('div', {
                                    style: {
                                        marginTop: '12px',
                                        padding: '12px',
                                        background: 'rgba(239, 68, 68, 0.2)',
                                        border: '1px solid rgba(239, 68, 68, 0.4)',
                                        borderRadius: '8px',
                                        fontSize: '12px',
                                        color: '#fca5a5'
                                    }
                                }, '⚠️ No matchups found matching these criteria'),
                                oppFilters.length > 0 && oppFilteredMatchups && oppFilteredMatchups.length > 0 && e('div', {
                                    style: {
                                        marginTop: '12px',
                                        padding: '12px',
                                        background: 'rgba(34, 197, 94, 0.2)',
                                        border: '1px solid rgba(34, 197, 94, 0.4)',
                                        borderRadius: '8px',
                                        fontSize: '12px',
                                        color: '#86efac'
                                    }
                                }, '✓ Found ' + oppFilteredMatchups.length + ' matchups | ' + Math.round(oppFilteredStats?.combP || 0) + ' possessions • Stats filtered by opponent criteria')
                            )
                        ) // Close showOppQualitySection
                        )
                    )
                ), 
                // V4.2.1: Analyzer Subtabs
                activeTab === 'analyzer' && fStats && e('div', { className: 'analyzer-subtabs' },
                    e('button', { 
                        className: 'subtab-btn' + (analyzerSubtab === 'main' ? ' active' : ''),
                        onClick: () => setAnalyzerSubtab('main')
                    }, '📊 Main'),
                    e('button', { 
                        className: 'subtab-btn' + (analyzerSubtab === 'fourfactors' ? ' active' : ''),
                        onClick: () => setAnalyzerSubtab('fourfactors')
                    }, '📈 Four Factors'),
                    e('button', { 
                        className: 'subtab-btn' + (analyzerSubtab === 'shotdist' ? ' active' : ''),
                        onClick: () => setAnalyzerSubtab('shotdist')
                    }, '🎯 Shot Distribution + TOs'),
                    e('button', { 
                        className: 'subtab-btn' + (analyzerSubtab === 'transition' ? ' active' : ''),
                        onClick: () => setAnalyzerSubtab('transition'),
                        style: analyzerSubtab === 'transition' ? { background: 'linear-gradient(135deg, #f59e0b, #d97706)' } : {}
                    }, '⚡ Transition'),
                    e('button', { 
                        className: 'subtab-btn' + (analyzerSubtab === 'assists' ? ' active' : ''),
                        onClick: () => setAnalyzerSubtab('assists'),
                        style: analyzerSubtab === 'assists' ? { background: 'linear-gradient(135deg, #10b981, #059669)' } : {}
                    }, '🤝 Assist Combos'),
                    e('button', {
                        className: 'subtab-btn' + (analyzerSubtab === 'clutch' ? ' active' : ''),
                        onClick: () => setAnalyzerSubtab('clutch'),
                        style: analyzerSubtab === 'clutch' ? { background: 'linear-gradient(135deg, #ef4444, #dc2626)' } : {}
                    }, '⏱️ Clutch'),
                    e('button', {
                        className: 'subtab-btn' + (analyzerSubtab === 'vsstarters' ? ' active' : ''),
                        onClick: () => setAnalyzerSubtab('vsstarters'),
                        style: analyzerSubtab === 'vsstarters' ? { background: 'linear-gradient(135deg, #06b6d4, #0891b2)' } : {}
                    }, '🎯 VS. Starters'),
                    e('button', {
                        className: 'subtab-btn' + (analyzerSubtab === 'rotations' ? ' active' : ''),
                        onClick: () => setAnalyzerSubtab('rotations'),
                        style: analyzerSubtab === 'rotations' ? { background: 'linear-gradient(135deg, #f59e0b, #d97706)' } : {}
                    }, '🔄 Rotations'),
                    e('button', { 
                        className: 'subtab-btn' + (analyzerSubtab === 'playerbreakdown' ? ' active' : ''),
                        onClick: () => setAnalyzerSubtab('playerbreakdown'),
                        style: analyzerSubtab === 'playerbreakdown' ? { background: 'linear-gradient(135deg, #8b5cf6, #7c3aed)' } : {}
                    }, '👤 Player Breakdown'),
                    e('button', { 
                        className: 'subtab-btn' + (analyzerSubtab === 'lineups' ? ' active' : ''),
                        onClick: () => setAnalyzerSubtab('lineups')
                    }, '👥 Lineups'),
                    e('button', { 
                        className: 'subtab-btn' + (analyzerSubtab === 'builder' ? ' active' : ''),
                        onClick: () => setAnalyzerSubtab('builder'),
                        style: analyzerSubtab === 'builder' ? { background: 'linear-gradient(135deg, #0891b2, #22d3ee)' } : {}
                    }, '🔧 Lineup Builder')
                ),
                // V4.2.2: Opponent Filter Active Indicator
                activeTab === 'analyzer' && fStats && fStats.isOppFiltered && analyzerSubtab === 'main' && e('div', { 
                    style: { 
                        background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(168, 85, 247, 0.1))', 
                        border: '2px solid rgba(139, 92, 246, 0.5)', 
                        borderRadius: '12px', 
                        padding: '16px 20px', 
                        marginBottom: '16px',
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        flexWrap: 'wrap',
                        gap: '12px'
                    }
                },
                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' }},
                        e('span', { style: { fontSize: '20px' }}, '⚔️'),
                        e('div', null,
                            e('div', { style: { color: '#c4b5fd', fontWeight: 'bold', fontSize: '14px' }}, 'Opponent Quality Filter Active'),
                            e('div', { style: { color: '#a78bfa', fontSize: '12px' }}, 
                                'Showing stats from ' + fStats.oppFilterMatchups + ' matchups | ' + Math.round(fStats.combP) + ' possessions'
                            )
                        )
                    ),
                    e('div', { style: { display: 'flex', gap: '8px', flexWrap: 'wrap' }},
                        oppFilters.map((f, i) => {
                            const statLabels = {
                                off: 'Off Rtg', def: 'Def Rtg', net: 'Net Rtg',
                                offEfg: 'Off eFG%', defEfg: 'Def eFG%',
                                offTov: 'Off TOV%', defTov: 'Def TOV%',
                                offOreb: 'Off OREB%', defOreb: 'Def OREB%',
                                offFtR: 'Off FTR', defFtR: 'Def FTR',
                                paceF: 'Pace (Off)', paceV: 'Pace (Def)',
                                astPct: 'AST%', stlPct: 'STL%', blkPct: 'BLK%',
                                combPoss: 'Possessions'
                            };
                            return e('span', { 
                                key: i, 
                                style: { 
                                    background: 'rgba(139, 92, 246, 0.3)', 
                                    padding: '4px 10px', 
                                    borderRadius: '6px', 
                                    fontSize: '12px',
                                    color: '#e9d5ff',
                                    fontWeight: '600'
                                }
                            }, statLabels[f.stat] + ' ' + (f.operator === 'gt' ? '>' : '<') + ' ' + f.value);
                        })
                    )
                ),
                activeTab === 'analyzer' && fStats && analyzerSubtab === 'main' && e('div', { className: 'stats-grid' }, 
                    e('div', { className: 'stat-card' }, e('div', { className: 'stat-label' }, 'Lineups'), e('div', { className: 'stat-value' }, filtered.length)), 
                    e('div', { className: 'stat-card ' + getPerfFromPct(pcts.net) }, e('div', { className: 'stat-label' }, 'Net Rtg'), e(StatWithContext, { val: fStats.net, pct: pcts.net, oppVal: oppQuality?.oppNet, oppPct: oppQuality?.pcts.oppNet, oppHigherHarder: true, teamAvgVal: teamAvg.net, higherBetter: true })), 
                    e('div', { className: 'stat-card ' + getPerfFromPct(pcts.off) }, e('div', { className: 'stat-label' }, 'Off Rtg'), e(StatWithContext, { val: fStats.off, pct: pcts.off, oppVal: oppQuality?.oppDef, oppPct: oppQuality?.pcts.oppDef, oppHigherHarder: false, teamAvgVal: teamAvg.off, higherBetter: true })), 
                    e('div', { className: 'stat-card ' + getPerfFromPct(pcts.def) }, e('div', { className: 'stat-label' }, 'Def Rtg'), e(StatWithContext, { val: fStats.def, pct: pcts.def, oppVal: oppQuality?.oppOff, oppPct: oppQuality?.pcts.oppOff, oppHigherHarder: true, teamAvgVal: teamAvg.def, higherBetter: false })), 
                    e('div', { className: 'stat-card' }, e('div', { className: 'stat-label' }, 'Poss (Dean Oliver)'), e('div', { className: 'stat-value' }, Math.round(fStats.combP))),
                    afc > 0 && e('div', { className: 'stat-card' }, e('div', { className: 'stat-label' }, 'Minutes'), e('div', { className: 'stat-value' }, (fStats.time / 60).toFixed(1)))
                ), 
                // V3.9: Always-visible Team Average Summary when players are filtered
                activeTab === 'analyzer' && fStats && analyzerSubtab === 'main' && e(TeamAvgSummary),
                // CHANGED: Show opponent quality section even without player filter (teamwide)
                activeTab === 'analyzer' && oppQuality && analyzerSubtab === 'main' && e(OppQualitySection), 
                activeTab === 'analyzer' && oppQuality && showImpact && analyzerSubtab === 'main' && e(ImpactSection), 
                activeTab === 'analyzer' && showTeamAvg && analyzerSubtab === 'main' && e(TeamAvgSection), 
                activeTab === 'analyzer' && fStats && analyzerSubtab === 'shotdist' && e(ShotDist), 
                activeTab === 'analyzer' && fStats && analyzerSubtab === 'shotdist' && e(PaceSec), 
                activeTab === 'analyzer' && fStats && analyzerSubtab === 'shotdist' && e(TOSec), 
                activeTab === 'analyzer' && fStats && analyzerSubtab === 'fourfactors' && e(FourFactors),
                activeTab === 'analyzer' && fStats && analyzerSubtab === 'transition' && e(TransitionTab),
                activeTab === 'analyzer' && analyzerSubtab === 'assists' && e(AssistCombosTab),
                activeTab === 'analyzer' && analyzerSubtab === 'clutch' && e(ClutchTab),
                activeTab === 'analyzer' && analyzerSubtab === 'vsstarters' && e(VsStartersTab),
                activeTab === 'analyzer' && analyzerSubtab === 'rotations' && e(RotationsTab),
                activeTab === 'analyzer' && analyzerSubtab === 'playerbreakdown' && e(PlayerBreakdownTab),
                // V4.6.1: Player Impact Correlation Modal
                showPlayerImpactModal && playerImpactResults && e('div', { 
                    className: 'modal-overlay',
                    onClick: () => setShowPlayerImpactModal(false)
                },
                    e('div', { 
                        className: 'modal-content',
                        style: { maxWidth: '1100px', maxHeight: '90vh', overflowY: 'auto' },
                        onClick: ev => ev.stopPropagation()
                    },
                        e('div', { className: 'modal-header' },
                            e('div', null,
                                e('h2', { style: { color: '#4ade80', fontSize: '24px', marginBottom: '8px' }}, 
                                    '📊 Player Impact Correlation',
                                    playerImpactResults.filterPlayer && e('span', { style: { color: '#fbbf24', marginLeft: '12px' }}, 
                                        '- ' + playerImpactResults.filterPlayer
                                    )
                                ),
                                e('p', { style: { color: '#94a3b8', fontSize: '13px' }}, 
                                    'How do individual player stats correlate with lineup success?'
                                )
                            ),
                            e('button', { className: 'modal-close', onClick: () => setShowPlayerImpactModal(false) }, '×')
                        ),
                        playerImpactResults.error ? e('div', { 
                            style: { padding: '20px', background: 'rgba(239, 68, 68, 0.2)', borderRadius: '8px', color: '#fca5a5' }
                        }, '⚠️ ' + playerImpactResults.error) : e('div', null,
                            // Player filter dropdown inside modal
                            e('div', { style: { marginBottom: '16px', display: 'flex', gap: '16px', alignItems: 'center', flexWrap: 'wrap' }},
                                e('div', null,
                                    e('label', { style: { fontSize: '11px', color: '#86efac', marginRight: '8px' }}, 'Filter Player:'),
                                    e('select', { 
                                        value: playerImpactPlayer, 
                                        onChange: ev => { setPlayerImpactPlayer(ev.target.value); calculatePlayerImpactCorrelation(ev.target.value || null); },
                                        style: { padding: '6px 12px', background: '#0f172a', border: '1px solid #475569', borderRadius: '6px', color: 'white', fontSize: '12px' }
                                    }, 
                                        e('option', { value: '' }, '-- All Players (' + (playerImpactResults.players?.length || 0) + ') --'),
                                        (playerImpactResults.players || []).map(p => e('option', { key: p, value: p }, p))
                                    )
                                ),
                                e('div', { style: { fontSize: '11px', color: '#94a3b8' }},
                                    playerImpactResults.filterPlayer ? 
                                        'Showing correlations for ' + playerImpactResults.filterPlayer + "'s stats across different lineups" :
                                        'Showing correlations for all ' + (playerImpactResults.teamFilter || 'league') + ' players'
                                )
                            ),
                            // Summary stats
                            e('div', { 
                                style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '12px', marginBottom: '24px' }
                            },
                                e('div', { style: { background: 'rgba(59, 130, 246, 0.15)', padding: '16px', borderRadius: '10px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '4px' }}, 'Player-Lineup Records'),
                                    e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#60a5fa' }}, playerImpactResults.sampleSize)
                                ),
                                e('div', { style: { background: 'rgba(34, 197, 94, 0.15)', padding: '16px', borderRadius: '10px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '4px' }}, 'Avg Lineup ORTG'),
                                    e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#4ade80' }}, playerImpactResults.avgOffRtg.toFixed(1))
                                ),
                                e('div', { style: { background: 'rgba(239, 68, 68, 0.15)', padding: '16px', borderRadius: '10px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '4px' }}, 'Avg Lineup DRTG'),
                                    e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#f87171' }}, playerImpactResults.avgDefRtg.toFixed(1))
                                ),
                                e('div', { style: { background: 'rgba(168, 85, 247, 0.15)', padding: '16px', borderRadius: '10px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', color: '#94a3b8', marginBottom: '4px' }}, 'Avg Net Rtg'),
                                    e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: playerImpactResults.avgNetRtg >= 0 ? '#4ade80' : '#f87171' }}, 
                                        (playerImpactResults.avgNetRtg >= 0 ? '+' : '') + playerImpactResults.avgNetRtg.toFixed(1)
                                    )
                                )
                            ),
                            // Two columns: Offense and Defense Correlations
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '24px' }},
                                // OFFENSIVE CORRELATIONS
                                e('div', { 
                                    style: { 
                                        background: 'rgba(34, 197, 94, 0.08)', 
                                        border: '1px solid rgba(34, 197, 94, 0.3)', 
                                        borderRadius: '12px', 
                                        padding: '20px' 
                                    }
                                },
                                    e('h3', { style: { color: '#4ade80', marginBottom: '8px', fontSize: '16px' }}, 
                                        '📈 Correlation with Lineup ORTG'
                                    ),
                                    e('p', { style: { fontSize: '10px', color: '#94a3b8', marginBottom: '12px' }}, 
                                        'When this stat is higher, lineup scores more (+r) or less (-r)'
                                    ),
                                    e('div', { 
                                        style: { 
                                            maxHeight: playerImpactExpanded ? 'none' : '400px', 
                                            overflowY: playerImpactExpanded ? 'visible' : 'auto' 
                                        }
                                    },
                                        (playerImpactExpanded ? playerImpactResults.offenseCorrelations : playerImpactResults.offenseCorrelations.slice(0, 20)).map((stat, i) => e('div', { 
                                            key: i,
                                            style: { 
                                                background: 'rgba(0,0,0,0.2)', 
                                                borderRadius: '8px', 
                                                padding: '10px 12px', 
                                                marginBottom: '6px',
                                                borderLeft: i < 3 ? '3px solid ' + (stat.correlation > 0 ? '#4ade80' : '#f87171') : 'none'
                                            }
                                        },
                                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' }},
                                                e('div', null,
                                                    e('span', { style: { fontWeight: 'bold', color: '#e2e8f0', fontSize: '13px' }}, stat.name),
                                                    e('span', { style: { fontSize: '10px', color: '#64748b', marginLeft: '8px' }}, stat.desc)
                                                ),
                                                e('div', { style: { textAlign: 'right' }},
                                                    e('span', { 
                                                        style: { 
                                                            fontWeight: 'bold', 
                                                            fontSize: '14px',
                                                            color: stat.correlation > 0.15 ? '#4ade80' : stat.correlation < -0.15 ? '#f87171' : '#94a3b8'
                                                        }
                                                    }, 'r = ' + (stat.correlation >= 0 ? '+' : '') + stat.correlation.toFixed(3)),
                                                    e('div', { style: { fontSize: '9px', color: '#64748b' }}, 
                                                        'Avg: ' + stat.mean.toFixed(1)
                                                    )
                                                )
                                            ),
                                            // Correlation bar
                                            e('div', { style: { marginTop: '6px', height: '6px', background: 'rgba(0,0,0,0.3)', borderRadius: '3px', position: 'relative' }},
                                                e('div', { 
                                                    style: { 
                                                        position: 'absolute',
                                                        left: '50%',
                                                        width: Math.abs(stat.correlation) * 50 + '%',
                                                        height: '100%',
                                                        background: stat.correlation > 0 ? '#4ade80' : '#f87171',
                                                        borderRadius: '3px',
                                                        transform: stat.correlation > 0 ? 'none' : 'translateX(-100%)'
                                                    }
                                                })
                                            )
                                        ))
                                    )
                                ),
                                // DEFENSIVE CORRELATIONS
                                e('div', { 
                                    style: { 
                                        background: 'rgba(239, 68, 68, 0.08)', 
                                        border: '1px solid rgba(239, 68, 68, 0.3)', 
                                        borderRadius: '12px', 
                                        padding: '20px' 
                                    }
                                },
                                    e('h3', { style: { color: '#f87171', marginBottom: '8px', fontSize: '16px' }}, 
                                        '🛡️ Correlation with Lineup DRTG'
                                    ),
                                    e('p', { style: { fontSize: '10px', color: '#94a3b8', marginBottom: '12px' }}, 
                                        'When this stat is higher, opponents score more (+r) or less (-r). Negative = helps defense.'
                                    ),
                                    e('div', { 
                                        style: { 
                                            maxHeight: playerImpactExpanded ? 'none' : '400px', 
                                            overflowY: playerImpactExpanded ? 'visible' : 'auto' 
                                        }
                                    },
                                        (playerImpactExpanded ? playerImpactResults.defenseCorrelations : playerImpactResults.defenseCorrelations.slice(0, 20)).map((stat, i) => e('div', { 
                                            key: i,
                                            style: { 
                                                background: 'rgba(0,0,0,0.2)', 
                                                borderRadius: '8px', 
                                                padding: '10px 12px', 
                                                marginBottom: '6px',
                                                borderLeft: i < 3 ? '3px solid ' + (stat.correlation < 0 ? '#4ade80' : '#f87171') : 'none'
                                            }
                                        },
                                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' }},
                                                e('div', null,
                                                    e('span', { style: { fontWeight: 'bold', color: '#e2e8f0', fontSize: '13px' }}, stat.name),
                                                    e('span', { style: { fontSize: '10px', color: '#64748b', marginLeft: '8px' }}, stat.desc)
                                                ),
                                                e('div', { style: { textAlign: 'right' }},
                                                    e('span', { 
                                                        style: { 
                                                            fontWeight: 'bold', 
                                                            fontSize: '14px',
                                                            // For defense: negative correlation is GOOD (helps D)
                                                            color: stat.correlation < -0.15 ? '#4ade80' : stat.correlation > 0.15 ? '#f87171' : '#94a3b8'
                                                        }
                                                    }, 'r = ' + (stat.correlation >= 0 ? '+' : '') + stat.correlation.toFixed(3)),
                                                    e('div', { style: { fontSize: '9px', color: '#64748b' }}, 
                                                        'Avg: ' + stat.mean.toFixed(1)
                                                    )
                                                )
                                            ),
                                            // Correlation bar
                                            e('div', { style: { marginTop: '6px', height: '6px', background: 'rgba(0,0,0,0.3)', borderRadius: '3px', position: 'relative' }},
                                                e('div', { 
                                                    style: { 
                                                        position: 'absolute',
                                                        left: '50%',
                                                        width: Math.abs(stat.correlation) * 50 + '%',
                                                        height: '100%',
                                                        // For defense bar: negative is green (helps), positive is red (hurts)
                                                        background: stat.correlation < 0 ? '#4ade80' : '#f87171',
                                                        borderRadius: '3px',
                                                        transform: stat.correlation > 0 ? 'none' : 'translateX(-100%)'
                                                    }
                                                })
                                            )
                                        ))
                                    )
                                )
                            ),
                            // Expand/collapse button
                            e('div', { style: { textAlign: 'center', marginTop: '16px' }},
                                e('button', {
                                    className: 'btn btn-secondary',
                                    onClick: () => setPlayerImpactExpanded(!playerImpactExpanded),
                                    style: { fontSize: '12px' }
                                }, playerImpactExpanded ? '▲ Show Top 20 Only' : '▼ Show All Stats (' + playerImpactResults.offenseCorrelations.length + ')')
                            ),
                            // Interpretation guide
                            e('div', { 
                                style: { 
                                    marginTop: '20px', 
                                    padding: '16px', 
                                    background: 'rgba(59, 130, 246, 0.1)', 
                                    borderRadius: '8px',
                                    border: '1px solid rgba(59, 130, 246, 0.3)'
                                }
                            },
                                e('h4', { style: { color: '#60a5fa', marginBottom: '8px', fontSize: '13px' }}, '📖 How to Interpret'),
                                e('div', { style: { fontSize: '11px', color: '#94a3b8', lineHeight: '1.5' }},
                                    e('div', null, '• ', e('strong', null, 'For Offense'), ': Positive r means when player has more of this stat, lineup ORTG tends to be higher.'),
                                    e('div', null, '• ', e('strong', null, 'For Defense'), ': Negative r means when player has more of this stat, lineup DRTG tends to be ', e('em', null, 'lower'), ' (better defense).'),
                                    e('div', null, '• |r| > 0.3 = strong correlation, 0.15-0.3 = moderate, < 0.15 = weak'),
                                    e('div', { style: { marginTop: '8px' }}, '• ', e('strong', null, 'Scouting Use'), ': Filter by opponent player to see which stats most predict their lineup\'s success. Disrupt those stats!')
                                )
                            )
                        )
                    )
                ),
                // V4.3: Best Combinations Modal
                showCombosModal && combosResults && e('div', { 
                    className: 'modal-overlay',
                    onClick: () => setShowCombosModal(false)
                },
                    e('div', { 
                        className: 'modal-content',
                        style: { maxWidth: '1200px', maxHeight: '90vh', overflowY: 'auto' },
                        onClick: ev => ev.stopPropagation()
                    },
                        e('div', { className: 'modal-header' },
                            e('div', null,
                                e('h2', { style: { color: '#a855f7', fontSize: '24px', marginBottom: '8px' }}, 
                                    '🏆 Best ' + (combosResults.comboSize || combosSize) + '-Man Combinations vs ' + combosResults.oppTeam
                                ),
                                e('p', { style: { color: '#94a3b8', fontSize: '13px' }}, 
                                    'Based on ' + combosResults.matchupCount + ' matchups • Scored by weighted stat impacts'
                                )
                            ),
                            e('button', { className: 'modal-close', onClick: () => setShowCombosModal(false) }, '×')
                        ),
                        combosResults.error ? e('div', { 
                            style: { padding: '20px', background: 'rgba(239, 68, 68, 0.2)', borderRadius: '8px', color: '#fca5a5' }
                        }, '⚠️ ' + combosResults.error) : e('div', null,
                            // Stat weights used
                            e('div', { 
                                style: { 
                                    marginBottom: '20px', 
                                    padding: '12px', 
                                    background: 'rgba(168, 85, 247, 0.1)', 
                                    border: '1px solid rgba(168, 85, 247, 0.3)', 
                                    borderRadius: '8px' 
                                }
                            },
                                e('div', { style: { fontSize: '12px', color: '#c4b5fd', marginBottom: '8px', fontWeight: 'bold' }}, 
                                    '📊 Stat Impact Weights (β: expected Δrating per unit Δstat, from matchups vs ' + combosResults.oppTeam + ')'
                                ),
                                e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '8px' }},
                                    Object.entries(combosResults.statWeights || {}).map(([stat, weight]) => {
                                        const labels = { offEfg: 'Off eFG%', offTov: 'Off TOV%', offOreb: 'Off OREB%', offFtR: 'Off FTR', defEfg: 'Def eFG%', defTov: 'Def TOV%', defOreb: 'Def OREB%', defFtR: 'Def FTR', stlPct: 'STL%', blkPct: 'BLK%' };
                                        const isOff = stat.startsWith('off');
                                        // V4.6.2: Slopes can be larger than correlations, adjust threshold
                                        return e('span', { 
                                            key: stat,
                                            style: { 
                                                padding: '4px 8px', 
                                                background: isOff ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)', 
                                                borderRadius: '4px', 
                                                fontSize: '10px',
                                                color: Math.abs(weight) > 0.5 ? (isOff ? '#4ade80' : '#f87171') : '#94a3b8'
                                            }
                                        }, labels[stat] + ': ' + (weight >= 0 ? '+' : '') + weight.toFixed(2));
                                    })
                                )
                            ),
                            // Three columns: Best Offense, Defense, Net
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '16px' }},
                                // Best Offense
                                e('div', { style: { background: 'rgba(34, 197, 94, 0.08)', border: '1px solid rgba(34, 197, 94, 0.3)', borderRadius: '10px', padding: '16px' }},
                                    e('h3', { style: { color: '#4ade80', fontSize: '14px', marginBottom: '12px' }}, '📈 Best for Offense'),
                                    (combosResults.bestOffense || []).slice(0, 5).map((combo, i) => e('div', { 
                                        key: i,
                                        style: { 
                                            background: 'rgba(0,0,0,0.2)', 
                                            borderRadius: '6px', 
                                            padding: '10px', 
                                            marginBottom: '8px',
                                            borderLeft: i === 0 ? '3px solid #4ade80' : 'none'
                                        }
                                    },
                                        e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#e2e8f0', marginBottom: '4px' }},
                                            combo.players.join(', ')
                                        ),
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '11px' }},
                                            e('span', { style: { color: '#4ade80' }}, 'Off Score: +' + combo.offScore.toFixed(2)),
                                            e('span', { style: { color: '#94a3b8' }}, Math.round(combo.avgOnPoss) + ' poss avg')
                                        ),
                                        combo.sumNetDiff !== undefined && e('div', { style: { fontSize: '10px', color: combo.sumNetDiff >= 0 ? '#86efac' : '#fca5a5', marginTop: '2px' }},
                                            'Σ On/Off Net: ' + (combo.sumNetDiff >= 0 ? '+' : '') + combo.sumNetDiff.toFixed(1)
                                        ),
                                        combo.modeledOffEfg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                            'Modeled eFG: Off ' + combo.modeledOffEfg.toFixed(1) + '% / Def ' + (combo.modeledDefEfg || 0).toFixed(1) + '%'
                                        )
                                    ))
                                ),
                                // Best Defense
                                e('div', { style: { background: 'rgba(239, 68, 68, 0.08)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '10px', padding: '16px' }},
                                    e('h3', { style: { color: '#f87171', fontSize: '14px', marginBottom: '12px' }}, '🛡️ Best for Defense'),
                                    (combosResults.bestDefense || []).slice(0, 5).map((combo, i) => e('div', { 
                                        key: i,
                                        style: { 
                                            background: 'rgba(0,0,0,0.2)', 
                                            borderRadius: '6px', 
                                            padding: '10px', 
                                            marginBottom: '8px',
                                            borderLeft: i === 0 ? '3px solid #f87171' : 'none'
                                        }
                                    },
                                        e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#e2e8f0', marginBottom: '4px' }},
                                            combo.players.join(', ')
                                        ),
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '11px' }},
                                            e('span', { style: { color: '#f87171' }}, 'Def Score: +' + combo.defScore.toFixed(2)),
                                            e('span', { style: { color: '#94a3b8' }}, Math.round(combo.avgOnPoss) + ' poss avg')
                                        ),
                                        combo.sumNetDiff !== undefined && e('div', { style: { fontSize: '10px', color: combo.sumNetDiff >= 0 ? '#86efac' : '#fca5a5', marginTop: '2px' }},
                                            'Σ On/Off Net: ' + (combo.sumNetDiff >= 0 ? '+' : '') + combo.sumNetDiff.toFixed(1)
                                        ),
                                        combo.modeledDefEfg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                            'Modeled eFG: Off ' + (combo.modeledOffEfg || 0).toFixed(1) + '% / Def ' + combo.modeledDefEfg.toFixed(1) + '%'
                                        )
                                    ))
                                ),
                                // Best Net
                                e('div', { style: { background: 'rgba(168, 85, 247, 0.08)', border: '1px solid rgba(168, 85, 247, 0.3)', borderRadius: '10px', padding: '16px' }},
                                    e('h3', { style: { color: '#a855f7', fontSize: '14px', marginBottom: '12px' }}, '🎯 Best Overall (Net)'),
                                    (combosResults.bestNet || []).slice(0, 5).map((combo, i) => e('div', { 
                                        key: i,
                                        style: { 
                                            background: 'rgba(0,0,0,0.2)', 
                                            borderRadius: '6px', 
                                            padding: '10px', 
                                            marginBottom: '8px',
                                            borderLeft: i === 0 ? '3px solid #a855f7' : 'none'
                                        }
                                    },
                                        e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#e2e8f0', marginBottom: '4px' }},
                                            combo.players.join(', ')
                                        ),
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '11px' }},
                                            e('span', { style: { color: '#a855f7' }}, 'Net Score: +' + combo.netScore.toFixed(2)),
                                            e('span', { style: { color: '#4ade80' }}, 'Off: ' + (combo.offScore >= 0 ? '+' : '') + combo.offScore.toFixed(1)),
                                            e('span', { style: { color: '#f87171' }}, 'Def: ' + (combo.defScore >= 0 ? '+' : '') + combo.defScore.toFixed(1))
                                        ),
                                        combo.sumNetDiff !== undefined && e('div', { style: { fontSize: '10px', color: combo.sumNetDiff >= 0 ? '#86efac' : '#fca5a5', marginTop: '2px' }},
                                            'Σ On/Off Net: ' + (combo.sumNetDiff >= 0 ? '+' : '') + combo.sumNetDiff.toFixed(1)
                                        ),
                                        combo.modeledOffEfg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                            'Modeled eFG: Off ' + combo.modeledOffEfg.toFixed(1) + '% / Def ' + (combo.modeledDefEfg || 0).toFixed(1) + '%'
                                        )
                                    ))
                                )
                            ),
                            // Worst Net (avoid these)
                            combosResults.worstNet && combosResults.worstNet.length > 0 && e('div', { 
                                style: { 
                                    marginTop: '20px', 
                                    padding: '16px', 
                                    background: 'rgba(100, 116, 139, 0.1)', 
                                    border: '1px solid rgba(100, 116, 139, 0.3)', 
                                    borderRadius: '10px' 
                                }
                            },
                                e('h3', { style: { color: '#94a3b8', fontSize: '14px', marginBottom: '12px' }}, '⚠️ Avoid vs ' + combosResults.oppTeam),
                                e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(5, 1fr)', gap: '8px' }},
                                    combosResults.worstNet.slice(0, 5).map((combo, i) => e('div', { 
                                        key: i,
                                        style: { 
                                            background: 'rgba(239, 68, 68, 0.1)', 
                                            borderRadius: '6px', 
                                            padding: '8px', 
                                            textAlign: 'center' 
                                        }
                                    },
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8', marginBottom: '4px' }},
                                            combo.players.join(', ')
                                        ),
                                        e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#f87171' }}, 
                                            combo.netScore.toFixed(2)
                                        )
                                    ))
                                )
                            ),
                            // Methodology note
                            e('div', { 
                                style: { 
                                    marginTop: '20px', 
                                    padding: '12px', 
                                    background: 'rgba(251, 191, 36, 0.1)', 
                                    border: '1px solid rgba(251, 191, 36, 0.3)', 
                                    borderRadius: '8px',
                                    fontSize: '11px',
                                    color: '#94a3b8'
                                }
                            },
                                e('strong', { style: { color: '#fbbf24' }}, '📖 Methodology: '),
                                'Scores use player On/Off stat differentials from the Leaderboard weighted by opponent-specific correlations. ',
                                '1) Analyze which stats correlate with ORTG/DRTG vs ' + combosResults.oppTeam + ', ',
                                '2) Get each player\'s On/Off impact on those stats, ',
                                '3) Sum weighted impacts for combinations. ',
                                e('strong', null, 'Σ On/Off Net'), ' shows the sum of raw Net Rating differentials for reference.'
                            )
                        )
                    )
                ),
                // V4.3.4: Counter Lineups Modal
                showCounterModal && counterResults && e('div', { 
                    className: 'modal-overlay',
                    style: { 
                        position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                        background: 'rgba(0, 0, 0, 0.9)',
                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                        zIndex: 9999, padding: '20px'
                    },
                    onClick: () => setShowCounterModal(false)
                },
                    e('div', { 
                        style: { 
                            background: 'linear-gradient(135deg, #1e293b 0%, #0f172a 100%)',
                            border: '2px solid rgba(34, 211, 238, 0.5)',
                            borderRadius: '16px',
                            padding: '24px',
                            maxWidth: '1200px',
                            maxHeight: '85vh',
                            overflow: 'auto',
                            width: '100%'
                        },
                        onClick: ev => ev.stopPropagation()
                    },
                        e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '20px' }},
                            e('div', null,
                                e('h2', { style: { color: '#22d3ee', marginBottom: '4px', fontSize: '20px' }}, 
                                    '🎯 Best ' + (counterResults.comboSize || 2) + '-Man Combinations for ' + counterResults.counterTeam + ' vs ' + (counterResults.targetPlayers || []).join(' + ')
                                ),
                                e('p', { style: { color: '#94a3b8', fontSize: '12px' }}, 
                                    'Based on ' + counterResults.matchupCount + ' matchups • Scored by weighted stat impacts' +
                                    ((counterResults.excludedPlayers || []).length > 0 ? ' • Excluding: ' + counterResults.excludedPlayers.join(', ') : '')
                                )
                            ),
                            e('button', { 
                                onClick: () => setShowCounterModal(false),
                                style: { background: 'none', border: 'none', color: '#94a3b8', fontSize: '24px', cursor: 'pointer' }
                            }, '×')
                        ),
                        counterResults.error ? e('div', { 
                            style: { padding: '20px', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '8px', color: '#f87171' }
                        }, '⚠️ ' + counterResults.error) : e('div', null,
                            // Stat weights section
                            e('div', { 
                                style: { 
                                    marginBottom: '20px', 
                                    padding: '16px', 
                                    background: 'rgba(34, 211, 238, 0.1)', 
                                    borderRadius: '10px',
                                    border: '1px solid rgba(34, 211, 238, 0.3)'
                                }
                            },
                                e('h3', { style: { color: '#67e8f9', fontSize: '13px', marginBottom: '12px' }}, 
                                    '📊 Stat Impact Weights (β: Δrating/Δstat, from matchups vs ' + (counterResults.targetPlayers || []).join(' + ') + ')'
                                ),
                                e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '8px' }},
                                    Object.entries(counterResults.statWeights || {}).map(([stat, weight]) => {
                                        const labels = { offEfg: 'Off eFG%', offTov: 'Off TOV%', offOreb: 'Off OREB%', offFtR: 'Off FTR', defEfg: 'Def eFG%', defTov: 'Def TOV%', defOreb: 'Def OREB%', defFtR: 'Def FTR', stlPct: 'STL%', blkPct: 'BLK%' };
                                        const isPositive = weight >= 0;
                                        return e('span', { 
                                            key: stat, 
                                            style: { 
                                                padding: '4px 10px', 
                                                borderRadius: '4px', 
                                                fontSize: '11px',
                                                background: isPositive ? 'rgba(74, 222, 128, 0.2)' : 'rgba(248, 113, 113, 0.2)',
                                                color: isPositive ? '#4ade80' : '#f87171',
                                                border: '1px solid ' + (isPositive ? 'rgba(74, 222, 128, 0.4)' : 'rgba(248, 113, 113, 0.4)')
                                            }
                                        }, (labels[stat] || stat) + ': ' + (weight >= 0 ? '+' : '') + weight.toFixed(2));
                                    })
                                )
                            ),
                            // Results grid - same layout as combos modal
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '16px', marginBottom: '20px' }},
                                // Best Offense
                                e('div', { 
                                    style: { 
                                        background: 'rgba(74, 222, 128, 0.1)', 
                                        border: '1px solid rgba(74, 222, 128, 0.3)', 
                                        borderRadius: '10px', 
                                        padding: '16px' 
                                    }
                                },
                                    e('h3', { style: { color: '#4ade80', fontSize: '14px', marginBottom: '12px' }}, '🔥 Best Offense'),
                                    (counterResults.bestOffense || []).slice(0, 5).map((combo, i) => e('div', { 
                                        key: i,
                                        style: { 
                                            padding: '10px',
                                            marginBottom: '8px',
                                            background: 'rgba(0, 0, 0, 0.3)',
                                            borderRadius: '6px',
                                            borderLeft: '3px solid #4ade80'
                                        }
                                    },
                                        e('div', { style: { fontSize: '12px', color: '#e2e8f0', marginBottom: '4px', fontWeight: 'bold' }}, 
                                            (i + 1) + '. ' + combo.players.join(', ')
                                        ),
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '11px' }},
                                            e('span', { style: { color: '#4ade80' }}, 'Off: +' + combo.offScore.toFixed(2)),
                                            e('span', { style: { color: '#a855f7' }}, 'Net: ' + (combo.netScore >= 0 ? '+' : '') + combo.netScore.toFixed(2))
                                        ),
                                        combo.sumNetDiff !== undefined && e('div', { style: { fontSize: '10px', color: combo.sumNetDiff >= 0 ? '#86efac' : '#fca5a5', marginTop: '2px' }},
                                            'Σ On/Off Net: ' + (combo.sumNetDiff >= 0 ? '+' : '') + combo.sumNetDiff.toFixed(1)
                                        ),
                                        combo.modeledOffEfg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                            'Modeled eFG: Off ' + combo.modeledOffEfg.toFixed(1) + '% / Def ' + (combo.modeledDefEfg || 0).toFixed(1) + '%'
                                        )
                                    ))
                                ),
                                // Best Defense
                                e('div', { 
                                    style: { 
                                        background: 'rgba(96, 165, 250, 0.1)', 
                                        border: '1px solid rgba(96, 165, 250, 0.3)', 
                                        borderRadius: '10px', 
                                        padding: '16px' 
                                    }
                                },
                                    e('h3', { style: { color: '#60a5fa', fontSize: '14px', marginBottom: '12px' }}, '🛡️ Best Defense'),
                                    (counterResults.bestDefense || []).slice(0, 5).map((combo, i) => e('div', { 
                                        key: i,
                                        style: { 
                                            padding: '10px',
                                            marginBottom: '8px',
                                            background: 'rgba(0, 0, 0, 0.3)',
                                            borderRadius: '6px',
                                            borderLeft: '3px solid #60a5fa'
                                        }
                                    },
                                        e('div', { style: { fontSize: '12px', color: '#e2e8f0', marginBottom: '4px', fontWeight: 'bold' }}, 
                                            (i + 1) + '. ' + combo.players.join(', ')
                                        ),
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '11px' }},
                                            e('span', { style: { color: '#60a5fa' }}, 'Def: +' + combo.defScore.toFixed(2)),
                                            e('span', { style: { color: '#a855f7' }}, 'Net: ' + (combo.netScore >= 0 ? '+' : '') + combo.netScore.toFixed(2))
                                        ),
                                        combo.sumNetDiff !== undefined && e('div', { style: { fontSize: '10px', color: combo.sumNetDiff >= 0 ? '#86efac' : '#fca5a5', marginTop: '2px' }},
                                            'Σ On/Off Net: ' + (combo.sumNetDiff >= 0 ? '+' : '') + combo.sumNetDiff.toFixed(1)
                                        ),
                                        combo.modeledDefEfg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                            'Modeled eFG: Off ' + (combo.modeledOffEfg || 0).toFixed(1) + '% / Def ' + combo.modeledDefEfg.toFixed(1) + '%'
                                        )
                                    ))
                                ),
                                // Best Net
                                e('div', { 
                                    style: { 
                                        background: 'rgba(168, 85, 247, 0.1)', 
                                        border: '1px solid rgba(168, 85, 247, 0.3)', 
                                        borderRadius: '10px', 
                                        padding: '16px' 
                                    }
                                },
                                    e('h3', { style: { color: '#a855f7', fontSize: '14px', marginBottom: '12px' }}, '🏆 Best Overall'),
                                    (counterResults.bestNet || []).slice(0, 5).map((combo, i) => e('div', { 
                                        key: i,
                                        style: { 
                                            padding: '10px',
                                            marginBottom: '8px',
                                            background: 'rgba(0, 0, 0, 0.3)',
                                            borderRadius: '6px',
                                            borderLeft: '3px solid #a855f7'
                                        }
                                    },
                                        e('div', { style: { fontSize: '12px', color: '#e2e8f0', marginBottom: '4px', fontWeight: 'bold' }}, 
                                            (i + 1) + '. ' + combo.players.join(', ')
                                        ),
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '11px' }},
                                            e('span', { style: { color: '#a855f7' }}, 'Net Score: +' + combo.netScore.toFixed(2)),
                                            e('span', { style: { color: '#4ade80' }}, 'Off: ' + (combo.offScore >= 0 ? '+' : '') + combo.offScore.toFixed(1)),
                                            e('span', { style: { color: '#f87171' }}, 'Def: ' + (combo.defScore >= 0 ? '+' : '') + combo.defScore.toFixed(1))
                                        ),
                                        combo.sumNetDiff !== undefined && e('div', { style: { fontSize: '10px', color: combo.sumNetDiff >= 0 ? '#86efac' : '#fca5a5', marginTop: '2px' }},
                                            'Σ On/Off Net: ' + (combo.sumNetDiff >= 0 ? '+' : '') + combo.sumNetDiff.toFixed(1)
                                        ),
                                        combo.modeledOffEfg && e('div', { style: { fontSize: '9px', color: '#fbbf24', marginTop: '2px' }},
                                            'Modeled eFG: Off ' + combo.modeledOffEfg.toFixed(1) + '% / Def ' + (combo.modeledDefEfg || 0).toFixed(1) + '%'
                                        )
                                    ))
                                )
                            ),
                            // Worst Net (avoid these)
                            counterResults.worstNet && counterResults.worstNet.length > 0 && e('div', { 
                                style: { 
                                    marginTop: '20px', 
                                    padding: '16px', 
                                    background: 'rgba(100, 116, 139, 0.1)', 
                                    border: '1px solid rgba(100, 116, 139, 0.3)', 
                                    borderRadius: '10px' 
                                }
                            },
                                e('h3', { style: { color: '#94a3b8', fontSize: '14px', marginBottom: '12px' }}, '⚠️ Avoid vs ' + (counterResults.targetPlayers || []).join(' + ')),
                                e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(5, 1fr)', gap: '8px' }},
                                    counterResults.worstNet.slice(0, 5).map((combo, i) => e('div', { 
                                        key: i,
                                        style: { 
                                            background: 'rgba(239, 68, 68, 0.1)', 
                                            borderRadius: '6px', 
                                            padding: '8px', 
                                            textAlign: 'center' 
                                        }
                                    },
                                        e('div', { style: { fontSize: '10px', color: '#94a3b8', marginBottom: '4px' }},
                                            combo.players.join(', ')
                                        ),
                                        e('div', { style: { fontSize: '12px', fontWeight: 'bold', color: '#f87171' }}, 
                                            combo.netScore.toFixed(2)
                                        )
                                    ))
                                )
                            ),
                            // Methodology note
                            e('div', { 
                                style: { 
                                    marginTop: '20px', 
                                    padding: '12px', 
                                    background: 'rgba(34, 211, 238, 0.1)', 
                                    border: '1px solid rgba(34, 211, 238, 0.3)', 
                                    borderRadius: '8px',
                                    fontSize: '11px',
                                    color: '#94a3b8'
                                }
                            },
                                e('strong', { style: { color: '#22d3ee' }}, '📖 Methodology: '),
                                'Same approach as Best Player Combinations, but filtered to matchups where the opponent lineup includes ',
                                e('strong', null, (counterResults.targetPlayers || []).join(' + ')),
                                (counterResults.excludedPlayers || []).length > 0 ? ' (excluding ' + counterResults.excludedPlayers.join(', ') + ')' : '',
                                '. Calculates which stats correlate with ratings in those matchups, then scores ', counterResults.counterTeam, ' player combinations by their On/Off impacts weighted by those correlations. ',
                                e('strong', null, 'Σ On/Off Net'), ' shows the sum of raw Net Rating differentials for reference.'
                            )
                        )
                    )
                ),
                // V4.1: RAPM Loading Modal
                activeTab === 'analyzer' && isCalculatingRAPM && e('div', { 
                    className: 'modal-overlay',
                    style: { 
                        position: 'fixed', 
                        top: 0, left: 0, right: 0, bottom: 0,
                        background: 'rgba(0, 0, 0, 0.85)',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        zIndex: 9999
                    }
                },
                    e('div', { 
                        style: { 
                            background: 'linear-gradient(135deg, #1e293b 0%, #0f172a 100%)',
                            border: '2px solid rgba(96, 165, 250, 0.5)',
                            borderRadius: '16px',
                            padding: '40px 60px',
                            textAlign: 'center',
                            boxShadow: '0 25px 50px rgba(0, 0, 0, 0.5)'
                        }
                    },
                        e('div', { style: { fontSize: '48px', marginBottom: '20px' }}, '📊'),
                        e('h2', { style: { color: '#60a5fa', marginBottom: '16px', fontSize: '24px' }}, 'Calculating RAPM'),
                        e('p', { style: { color: '#94a3b8', marginBottom: '24px', fontSize: '14px' }}, rapmMessage),
                        e('div', { 
                            style: { 
                                width: '300px', 
                                height: '12px', 
                                background: 'rgba(96, 165, 250, 0.2)', 
                                borderRadius: '6px',
                                overflow: 'hidden',
                                marginBottom: '12px'
                            }
                        },
                            e('div', { 
                                style: { 
                                    width: rapmProgress + '%', 
                                    height: '100%', 
                                    background: 'linear-gradient(90deg, #60a5fa, #8b5cf6)',
                                    borderRadius: '6px',
                                    transition: 'width 0.3s ease'
                                }
                            })
                        ),
                        e('div', { style: { color: '#a78bfa', fontSize: '28px', fontWeight: 'bold' }}, rapmProgress + '%')
                    )
                ),
                // V4.1: RAPM Button - triggers async calculation
                activeTab === 'analyzer' && analyzerSubtab === 'main' && matchupData.length > 0 && fStats && e('div', { style: { display: 'flex', justifyContent: 'center', margin: '12px 0' }},
                    e('button', { 
                        className: 'btn', 
                        disabled: isCalculatingRAPM,
                        style: { 
                            background: rapmStats && !rapmStats.error ? 'linear-gradient(135deg, #60a5fa, #8b5cf6)' : 'rgba(96, 165, 250, 0.2)',
                            border: '2px solid rgba(96, 165, 250, 0.5)',
                            color: 'white',
                            padding: '10px 20px',
                            fontWeight: 'bold',
                            fontSize: '13px',
                            cursor: isCalculatingRAPM ? 'wait' : 'pointer',
                            opacity: isCalculatingRAPM ? 0.7 : 1
                        },
                        onClick: () => {
                            if (rapmStats && !rapmStats.error) {
                                setShowRAPM(!showRAPM);
                            } else {
                                triggerRAPMCalculation();
                            }
                        }
                    }, 
                        isCalculatingRAPM ? '⏳ Calculating...' : 
                        rapmStats && !rapmStats.error ? (showRAPM ? '📊 Hide RAPM-Adjusted Stats' : '📊 Show RAPM-Adjusted Stats') : 
                        '📊 Calculate RAPM-Adjusted Stats (V4.1)'
                    )
                ),
                activeTab === 'analyzer' && analyzerSubtab === 'main' && e(RAPMSection),
                // V4.3.5: Lineup Builder Tab
                activeTab === 'analyzer' && analyzerSubtab === 'builder' && e('div', { className: 'section' },
                    e('h2', { className: 'section-title', style: { color: '#22d3ee' } }, '🔧 Lineup Builder - Estimate Effectiveness'),
                    e('p', { style: { color: '#94a3b8', marginBottom: '16px', fontSize: '12px' }}, 
                        'Select players from any team to estimate combined lineup effectiveness based on On/Off impacts and eFG% modeling.'
                    ),
                    // Player Selection
                    e('div', { 
                        style: { 
                            display: 'grid', 
                            gridTemplateColumns: 'repeat(5, 1fr)', 
                            gap: '12px', 
                            marginBottom: '20px',
                            padding: '16px',
                            background: 'rgba(34, 211, 238, 0.1)',
                            borderRadius: '10px',
                            border: '1px solid rgba(34, 211, 238, 0.3)'
                        }
                    },
                        ['p1', 'p2', 'p3', 'p4', 'p5'].map((slot, i) => e('div', { key: slot },
                            e('label', { style: { fontSize: '11px', color: '#67e8f9', display: 'block', marginBottom: '4px' }}, 'Player ' + (i + 1)),
                            e('select', { 
                                value: builderPlayers[slot], 
                                onChange: ev => setBuilderPlayers(prev => ({ ...prev, [slot]: ev.target.value })),
                                style: { 
                                    width: '100%', 
                                    padding: '8px', 
                                    background: '#0f172a', 
                                    border: '1px solid #475569', 
                                    borderRadius: '6px', 
                                    color: 'white', 
                                    fontSize: '11px' 
                                }
                            }, 
                                e('option', { value: '' }, '-- Select --'),
                                allPlayersWithTeams.map(p => e('option', { 
                                    key: p.name, 
                                    value: p.name,
                                    disabled: Object.values(builderPlayers).includes(p.name) && builderPlayers[slot] !== p.name
                                }, p.name + ' (' + p.team + ')'))
                            )
                        ))
                    ),
                    // Calculate Button and eFG Slider
                    e('div', { style: { display: 'flex', gap: '20px', alignItems: 'center', marginBottom: '20px', flexWrap: 'wrap' }},
                        e('button', {
                            className: 'btn',
                            style: { 
                                background: Object.values(builderPlayers).filter(p => p !== '').length >= 2 
                                    ? 'linear-gradient(135deg, #0891b2, #22d3ee)' 
                                    : 'rgba(34, 211, 238, 0.3)',
                                color: 'white',
                                fontSize: '14px',
                                padding: '12px 24px',
                                border: 'none',
                                borderRadius: '8px',
                                cursor: Object.values(builderPlayers).filter(p => p !== '').length >= 2 ? 'pointer' : 'not-allowed',
                                fontWeight: 'bold'
                            },
                            onClick: calculateBuilderLineup,
                            disabled: Object.values(builderPlayers).filter(p => p !== '').length < 2
                        }, '🔧 Calculate Lineup Estimate'),
                        e('div', { style: { flex: 1, minWidth: '250px', maxWidth: '400px' }},
                            e('div', { style: { fontSize: '11px', color: '#fbbf24', marginBottom: '4px' }}, 
                                '📐 Prior Strength k=' + efgModelWeight + ' (weight = poss/(poss+k))'
                            ),
                            e('input', { 
                                type: 'range', 
                                min: 10, 
                                max: 200, 
                                value: efgModelWeight, 
                                onChange: ev => setEfgModelWeight(parseInt(ev.target.value)),
                                style: { width: '100%', accentColor: '#fbbf24' }
                            })
                        ),
                        e('button', {
                            style: { 
                                background: 'rgba(239, 68, 68, 0.2)',
                                color: '#f87171',
                                fontSize: '11px',
                                padding: '8px 16px',
                                border: '1px solid rgba(239, 68, 68, 0.3)',
                                borderRadius: '6px',
                                cursor: 'pointer'
                            },
                            onClick: () => {
                                setBuilderPlayers({ p1: '', p2: '', p3: '', p4: '', p5: '' });
                                setBuilderResults(null);
                            }
                        }, '🗑️ Clear')
                    ),
                    // Results
                    builderResults && (builderResults.error ? 
                        e('div', { 
                            style: { padding: '20px', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '8px', color: '#f87171' }
                        }, '⚠️ ' + builderResults.error) :
                        e('div', null,
                            // V4.3.7: Reliability info bar
                            e('div', { 
                                style: { 
                                    display: 'flex', 
                                    gap: '16px', 
                                    marginBottom: '12px', 
                                    padding: '10px 16px',
                                    background: 'rgba(34, 211, 238, 0.1)',
                                    border: '1px solid rgba(34, 211, 238, 0.3)',
                                    borderRadius: '8px',
                                    fontSize: '12px'
                                }
                            },
                                e('span', { style: { color: '#22d3ee' }}, '🎯 Sample: ', e('strong', null, Math.round(builderResults.totalOnPoss || 0) + ' poss')),
                                e('span', { style: { color: '#fbbf24' }}, 'Reliability: ', e('strong', null, ((builderResults.reliabilityWeight || 0) * 100).toFixed(1) + '%')),
                                e('span', { style: { color: '#94a3b8' }}, 'Formula: weight = poss/(poss+k), k=' + efgModelWeight)
                            ),
                            // Summary Cards
                            e('div', { 
                                style: { 
                                    display: 'grid', 
                                    gridTemplateColumns: 'repeat(5, 1fr)', 
                                    gap: '12px', 
                                    marginBottom: '20px' 
                                }
                            },
                                e('div', { style: { background: 'rgba(74, 222, 128, 0.1)', border: '1px solid rgba(74, 222, 128, 0.3)', borderRadius: '10px', padding: '16px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', color: '#4ade80', marginBottom: '4px' }}, 'Est. ORTG'),
                                    e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#4ade80' }}, builderResults.estimatedOrtg.toFixed(1))
                                ),
                                e('div', { style: { background: 'rgba(248, 113, 113, 0.1)', border: '1px solid rgba(248, 113, 113, 0.3)', borderRadius: '10px', padding: '16px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', color: '#f87171', marginBottom: '4px' }}, 'Est. DRTG'),
                                    e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#f87171' }}, builderResults.estimatedDefRtg.toFixed(1))
                                ),
                                e('div', { style: { background: 'rgba(168, 85, 247, 0.1)', border: '1px solid rgba(168, 85, 247, 0.3)', borderRadius: '10px', padding: '16px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', color: '#a855f7', marginBottom: '4px' }}, 'Est. Net'),
                                    e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: builderResults.estimatedNet >= 0 ? '#4ade80' : '#f87171' }}, 
                                        (builderResults.estimatedNet >= 0 ? '+' : '') + builderResults.estimatedNet.toFixed(1)
                                    )
                                ),
                                e('div', { style: { background: 'rgba(251, 191, 36, 0.1)', border: '1px solid rgba(251, 191, 36, 0.3)', borderRadius: '10px', padding: '16px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', color: '#fbbf24', marginBottom: '4px' }}, 'Modeled Off eFG%'),
                                    e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#fbbf24' }}, builderResults.modeledOffEfg.toFixed(1) + '%')
                                ),
                                e('div', { style: { background: 'rgba(96, 165, 250, 0.1)', border: '1px solid rgba(96, 165, 250, 0.3)', borderRadius: '10px', padding: '16px', textAlign: 'center' }},
                                    e('div', { style: { fontSize: '11px', color: '#60a5fa', marginBottom: '4px' }}, 'Modeled Def eFG%'),
                                    e('div', { style: { fontSize: '28px', fontWeight: 'bold', color: '#60a5fa' }}, builderResults.modeledDefEfg.toFixed(1) + '%')
                                )
                            ),
                            // Player Breakdowns
                            e('h3', { style: { color: '#e2e8f0', fontSize: '14px', marginBottom: '12px' }}, '📊 Player On/Off Impact Breakdown'),
                            e('div', { style: { overflowX: 'auto' }},
                                e('table', null,
                                    e('thead', null,
                                        e('tr', null,
                                            e('th', null, 'Player'),
                                            e('th', null, 'Team'),
                                            e('th', { style: { textAlign: 'right' }}, 'On Poss'),
                                            e('th', { style: { textAlign: 'right' }}, 'Net Diff'),
                                            e('th', { style: { textAlign: 'right' }}, 'Off Diff'),
                                            e('th', { style: { textAlign: 'right' }}, 'Def Diff'),
                                            e('th', { style: { textAlign: 'right' }}, 'Off eFG Diff'),
                                            e('th', { style: { textAlign: 'right' }}, 'Def eFG Diff'),
                                            e('th', { style: { textAlign: 'right' }}, 'Rim% Diff'),
                                            e('th', { style: { textAlign: 'right' }}, '3PT% Diff')
                                        )
                                    ),
                                    e('tbody', null,
                                        (builderResults.playerBreakdowns || []).map((p, i) => e('tr', { key: i },
                                            e('td', { style: { fontWeight: 'bold' }}, p.player),
                                            e('td', { style: { color: '#94a3b8' }}, p.team),
                                            e('td', { style: { textAlign: 'right' }}, Math.round(p.onPoss)),
                                            e('td', { style: { textAlign: 'right', color: p.net >= 0 ? '#4ade80' : '#f87171', fontWeight: 'bold' }}, 
                                                (p.net >= 0 ? '+' : '') + p.net.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: p.off >= 0 ? '#4ade80' : '#f87171' }}, 
                                                (p.off >= 0 ? '+' : '') + p.off.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: p.def <= 0 ? '#4ade80' : '#f87171' }}, 
                                                (p.def >= 0 ? '+' : '') + p.def.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: p.offEfg >= 0 ? '#4ade80' : '#f87171' }}, 
                                                (p.offEfg >= 0 ? '+' : '') + p.offEfg.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: p.defEfg <= 0 ? '#4ade80' : '#f87171' }}, 
                                                (p.defEfg >= 0 ? '+' : '') + p.defEfg.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: p.rimPct >= 0 ? '#4ade80' : '#f87171' }}, 
                                                (p.rimPct >= 0 ? '+' : '') + p.rimPct.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: p.threePct >= 0 ? '#4ade80' : '#f87171' }}, 
                                                (p.threePct >= 0 ? '+' : '') + p.threePct.toFixed(1)
                                            )
                                        )),
                                        // Totals row
                                        e('tr', { style: { borderTop: '2px solid #475569', fontWeight: 'bold', background: 'rgba(34, 211, 238, 0.1)' }},
                                            e('td', { colSpan: 3 }, 'SUMMED IMPACTS'),
                                            e('td', { style: { textAlign: 'right', color: builderResults.summedStats.net >= 0 ? '#4ade80' : '#f87171' }}, 
                                                (builderResults.summedStats.net >= 0 ? '+' : '') + builderResults.summedStats.net.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: builderResults.summedStats.off >= 0 ? '#4ade80' : '#f87171' }}, 
                                                (builderResults.summedStats.off >= 0 ? '+' : '') + builderResults.summedStats.off.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: builderResults.summedStats.def <= 0 ? '#4ade80' : '#f87171' }}, 
                                                (builderResults.summedStats.def >= 0 ? '+' : '') + builderResults.summedStats.def.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: builderResults.summedStats.offEfg >= 0 ? '#4ade80' : '#f87171' }}, 
                                                (builderResults.summedStats.offEfg >= 0 ? '+' : '') + builderResults.summedStats.offEfg.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: builderResults.summedStats.defEfg <= 0 ? '#4ade80' : '#f87171' }}, 
                                                (builderResults.summedStats.defEfg >= 0 ? '+' : '') + builderResults.summedStats.defEfg.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: builderResults.summedStats.rimPct >= 0 ? '#4ade80' : '#f87171' }}, 
                                                (builderResults.summedStats.rimPct >= 0 ? '+' : '') + builderResults.summedStats.rimPct.toFixed(1)
                                            ),
                                            e('td', { style: { textAlign: 'right', color: builderResults.summedStats.threePct >= 0 ? '#4ade80' : '#f87171' }}, 
                                                (builderResults.summedStats.threePct >= 0 ? '+' : '') + builderResults.summedStats.threePct.toFixed(1)
                                            )
                                        )
                                    )
                                )
                            ),
                            // V4.3.5: Player Box Score Stats
                            (builderResults.playerBoxStats && builderResults.playerBoxStats.length > 0) && e('div', { style: { marginTop: '24px' }},
                                e('h3', { style: { color: '#e2e8f0', fontSize: '14px', marginBottom: '12px' }}, '📋 Individual Box Score Stats (Per 40 Min)'),
                                e('div', { style: { overflowX: 'auto' }},
                                    e('table', null,
                                        e('thead', null,
                                            e('tr', null,
                                                e('th', null, 'Player'),
                                                e('th', null, 'Team'),
                                                e('th', { style: { textAlign: 'right' }}, 'Min'),
                                                e('th', { style: { textAlign: 'right' }}, 'PTS'),
                                                e('th', { style: { textAlign: 'right' }}, 'REB'),
                                                e('th', { style: { textAlign: 'right' }}, 'AST'),
                                                e('th', { style: { textAlign: 'right' }}, 'STL'),
                                                e('th', { style: { textAlign: 'right' }}, 'BLK'),
                                                e('th', { style: { textAlign: 'right' }}, 'TOV'),
                                                e('th', { style: { textAlign: 'right' }}, 'eFG%'),
                                                e('th', { style: { textAlign: 'right' }}, 'TS%'),
                                                e('th', { style: { textAlign: 'right' }}, '3PT%'),
                                                e('th', { style: { textAlign: 'right' }}, 'Rim%'),
                                                e('th', { style: { textAlign: 'right', fontSize: '10px' }}, 'Shot Profile')
                                            )
                                        ),
                                        e('tbody', null,
                                            builderResults.playerBoxStats.map((p, i) => e('tr', { key: i },
                                                e('td', { style: { fontWeight: 'bold' }}, p.player),
                                                e('td', { style: { color: '#94a3b8' }}, p.team),
                                                e('td', { style: { textAlign: 'right' }}, p.minutes.toFixed(0)),
                                                e('td', { style: { textAlign: 'right', fontWeight: 'bold' }}, p.pts40.toFixed(1)),
                                                e('td', { style: { textAlign: 'right' }}, p.reb40.toFixed(1)),
                                                e('td', { style: { textAlign: 'right' }}, p.ast40.toFixed(1)),
                                                e('td', { style: { textAlign: 'right' }}, p.stl40.toFixed(1)),
                                                e('td', { style: { textAlign: 'right' }}, p.blk40.toFixed(1)),
                                                e('td', { style: { textAlign: 'right', color: p.tov40 > 3 ? '#f87171' : '#94a3b8' }}, p.tov40.toFixed(1)),
                                                e('td', { style: { textAlign: 'right', color: p.efgPct >= 55 ? '#4ade80' : p.efgPct >= 50 ? '#fbbf24' : '#f87171' }}, p.efgPct.toFixed(1)),
                                                e('td', { style: { textAlign: 'right', color: p.tsPct >= 58 ? '#4ade80' : p.tsPct >= 54 ? '#fbbf24' : '#f87171' }}, p.tsPct.toFixed(1)),
                                                e('td', { style: { textAlign: 'right', color: p.threePct >= 38 ? '#4ade80' : p.threePct >= 33 ? '#fbbf24' : '#f87171' }}, p.threePct.toFixed(1)),
                                                e('td', { style: { textAlign: 'right', color: p.rimPct >= 65 ? '#4ade80' : p.rimPct >= 55 ? '#fbbf24' : '#f87171' }}, p.rimPct.toFixed(1)),
                                                e('td', { style: { textAlign: 'right', fontSize: '10px', color: '#94a3b8' }}, 
                                                    'R:' + p.shotProfile.rimShare.toFixed(0) + '% M:' + p.shotProfile.midShare.toFixed(0) + '% 3:' + p.shotProfile.threeShare.toFixed(0) + '%'
                                                )
                                            ))
                                        )
                                    )
                                )
                            ),
                            // Methodology note
                            e('div', { 
                                style: { 
                                    marginTop: '20px', 
                                    padding: '12px', 
                                    background: 'rgba(34, 211, 238, 0.1)', 
                                    border: '1px solid rgba(34, 211, 238, 0.3)', 
                                    borderRadius: '8px',
                                    fontSize: '11px',
                                    color: '#94a3b8'
                                }
                            },
                                e('strong', { style: { color: '#22d3ee' }}, '📖 V4.7.1 Methodology: '),
                                'Sums player On/Off differentials with gentle correlation adjustment (n^0.15). ',
                                'Reliability: w = poss/(poss + k), k = prior × √players (soft shrinkage preserves matchup effects). ',
                                'Soft clamping via logit keeps extreme projections plausible. ',
                                'Formula: E[%] = μ + (Δ_off + Δ_def + 0.02×Δ_off×Δ_def) × w. ',
                                'Volumes normalized to league FGA/100 = ' + (leagueAvgShotStats?.fgaPer100?.toFixed(1) || '80') + '. ',
                                e('strong', null, 'Note: '), 'Shows expected matchup dynamics. Actual results depend on game context.'
                            )
                        )
                    )
                ),
                activeTab === 'analyzer' && analyzerSubtab === 'lineups' && filtered.length > 0 && (() => {
                    // V4.9.8.7.21: Enhanced Lineups Tab with Four Factors, Shot Distribution, Opp Qual Adj & Luck Adj
                    
                    // Get league average 3PT% for defensive luck adjustment
                    const getLeagueAvg3Pct = () => {
                        if (allTeamsAverages && allTeamsAverages.length > 0) {
                            const totalTpm = allTeamsAverages.reduce((sum, t) => sum + (t.tpm || 0), 0);
                            const totalTpa = allTeamsAverages.reduce((sum, t) => sum + (t.tpa || 0), 0);
                            return totalTpa > 0 ? (totalTpm / totalTpa) * 100 : 35;
                        }
                        return 35; // fallback
                    };
                    const leagueAvg3Pct = getLeagueAvg3Pct();
                    
                    // Helper to calculate lineup-specific stats with percentiles and adjustments
                    const calcLineupStats = (l) => {
                        const fgm = parseFloat(l.FGM)||0, fga = parseFloat(l.FGA)||0, tpm = parseFloat(l['3PM'])||0, tpa = parseFloat(l['3PA'])||0;
                        const ftm = parseFloat(l.FTM)||0, fta = parseFloat(l.FTA)||0, oreb = parseFloat(l.OREB)||0, dreb = parseFloat(l.DREB)||0;
                        const tov = parseFloat(l.TOV)||0;
                        const fgmV = parseFloat(l.FGM_VS)||0, fgaV = parseFloat(l.FGA_VS)||0, tpmV = parseFloat(l['3PM_VS'])||0, tpaV = parseFloat(l['3PA_VS'])||0;
                        const ftmV = parseFloat(l.FTM_VS)||0, ftaV = parseFloat(l.FTA_VS)||0, orebV = parseFloat(l.OREB_VS)||0, drebV = parseFloat(l.DREB_VS)||0;
                        const tovV = parseFloat(l.TOV_VS)||0;
                        const rimA = parseFloat(l.RIM_ATT)||0, rimM = parseFloat(l.RIM_MADE)||0;
                        const midA = parseFloat(l.OTD_2PT_ATT)||0, midM = parseFloat(l.OTD_2PT_MADE)||0;
                        const threeA = parseFloat(l.OTD_3PT_ATT)||0, threeM = parseFloat(l.OTD_3PT_MADE)||0;
                        const rimAV = parseFloat(l.RIM_ATT_VS)||0, rimMV = parseFloat(l.RIM_MADE_VS)||0;
                        const midAV = parseFloat(l.OTD_2PT_ATT_VS)||0, midMV = parseFloat(l.OTD_2PT_MADE_VS)||0;
                        const threeAV = parseFloat(l.OTD_3PT_ATT_VS)||0, threeMV = parseFloat(l.OTD_3PT_MADE_VS)||0;
                        const poss = l.POSS || 0, possV = l.POSS_VS || 0;
                        
                        // V5.12: Use Basketball Reference TOV% formula for consistency
                        const offTovDenom = fga + 0.44 * fta + tov;
                        const defTovDenom = fgaV + 0.44 * ftaV + tovV;
                        
                        // Raw Four Factors
                        let offEfg = fga > 0 ? ((fgm + 0.5*tpm)/fga)*100 : 0;
                        let offTov = offTovDenom > 0 ? (tov/offTovDenom)*100 : 0;
                        let offOreb = (oreb+drebV) > 0 ? (oreb/(oreb+drebV))*100 : 0;
                        let offFtR = fga > 0 ? (fta/fga)*100 : 0;
                        let defEfg = fgaV > 0 ? ((fgmV + 0.5*tpmV)/fgaV)*100 : 0;
                        let defTov = defTovDenom > 0 ? (tovV/defTovDenom)*100 : 0;
                        let defOreb = (orebV+dreb) > 0 ? (orebV/(orebV+dreb))*100 : 0;
                        let defFtR = fgaV > 0 ? (ftaV/fgaV)*100 : 0;
                        
                        // Apply MASTER Opp Qual Adj to Four Factors
                        if (mainMasterScheduleAdj > 0 && leagueAverages) {
                            const adjFactor = mainMasterScheduleAdj / 100 * 0.5;
                            offEfg = offEfg + ((leagueAverages.offEfg || offEfg) - offEfg) * adjFactor;
                            offTov = offTov + ((leagueAverages.offTov || offTov) - offTov) * adjFactor;
                            offOreb = offOreb + ((leagueAverages.offOreb || offOreb) - offOreb) * adjFactor;
                            offFtR = offFtR + ((leagueAverages.offFtR || offFtR) - offFtR) * adjFactor;
                            defEfg = defEfg + ((leagueAverages.defEfg || defEfg) - defEfg) * adjFactor;
                            defTov = defTov + ((leagueAverages.defTov || defTov) - defTov) * adjFactor;
                            defOreb = defOreb + ((leagueAverages.defOreb || defOreb) - defOreb) * adjFactor;
                            defFtR = defFtR + ((leagueAverages.defFtR || defFtR) - defFtR) * adjFactor;
                        }
                        
                        // Calculate adjusted ratings with 3PT luck
                        let adjOff = l.OFF || 0;
                        let adjDef = l.DEF || 0;
                        let adjNet = l.NET || 0;
                        let offLuckDelta = 0;
                        let defLuckDelta = 0;
                        
                        // Offensive 3PT luck - use player season 3PT% averages
                        if (offLuckAdj > 0 && tpa > 0 && seasonStatsMap && seasonStatsMap.size > 0) {
                            // Get players in this lineup - V6.1: Apply merge rules
                            const lineupPlayers = l.Lineup ? l.Lineup.split(',').map(p => applyPlayerMerge(p.trim())) : [];
                            
                            // Calculate expected 3PT% based on players' season averages
                            let totalSeasonPct = 0;
                            let playersWithSeasonStats = 0;
                            
                            lineupPlayers.forEach(playerName => {
                                const pNorm = normalizePlayerName(playerName);
                                const seasonStats = seasonStatsMap.get(pNorm);
                                if (seasonStats && seasonStats.seasonThreePct > 0) {
                                    totalSeasonPct += seasonStats.seasonThreePct;
                                    playersWithSeasonStats++;
                                }
                            });
                            
                            // Use average of players' season 3PT% as expected rate
                            if (playersWithSeasonStats > 0) {
                                const expectedPct = (totalSeasonPct / playersWithSeasonStats) / 100;
                                const expected3pm = tpa * expectedPct;
                                const luckDelta3pm = tpm - expected3pm;
                                offLuckDelta = luckDelta3pm * (offLuckAdj / 100);
                                const offPtsDelta = -3 * offLuckDelta;
                                adjOff = adjOff + (poss > 0 ? (offPtsDelta / poss) * 100 : 0);
                            }
                        }
                        
                        // Defensive 3PT luck (regress opponent to league avg)
                        if (defLuckAdj > 0 && tpaV > 0) {
                            const actualPctV = tpmV / tpaV;
                            const expectedPctV = leagueAvg3Pct / 100;
                            const luckDelta3pmV = tpmV - (tpaV * expectedPctV);
                            defLuckDelta = luckDelta3pmV * (defLuckAdj / 100);
                            const defPtsDelta = -3 * defLuckDelta;
                            adjDef = adjDef + (possV > 0 ? (defPtsDelta / possV) * 100 : 0);
                        }
                        
                        adjNet = adjOff - adjDef;
                        
                        // Shot Distribution
                        const ts = rimA + midA + threeA;
                        const tsV = rimAV + midAV + threeAV;
                        const rimPct = rimA > 0 ? (rimM/rimA)*100 : 0;
                        const midPct = midA > 0 ? (midM/midA)*100 : 0;
                        const threePct = threeA > 0 ? (threeM/threeA)*100 : 0;
                        const rimPctV = rimAV > 0 ? (rimMV/rimAV)*100 : 0;
                        const midPctV = midAV > 0 ? (midMV/midAV)*100 : 0;
                        const threePctV = threeAV > 0 ? (threeMV/threeAV)*100 : 0;
                        const rimRate = ts > 0 ? (rimA/ts)*100 : 0;
                        const midRate = ts > 0 ? (midA/ts)*100 : 0;
                        const threeRate = ts > 0 ? (threeA/ts)*100 : 0;
                        const rimRateV = tsV > 0 ? (rimAV/tsV)*100 : 0;
                        const midRateV = tsV > 0 ? (midAV/tsV)*100 : 0;
                        const threeRateV = tsV > 0 ? (threeAV/tsV)*100 : 0;
                        
                        // Calculate percentiles using teamAvgArrays (use adjusted values)
                        const lPcts = teamAvgArrays.net && teamAvgArrays.net.length ? {
                            net: calcTeamAvgPercentile(adjNet, teamAvgArrays.net, true),
                            off: calcTeamAvgPercentile(adjOff, teamAvgArrays.off, true),
                            def: calcTeamAvgPercentile(adjDef, teamAvgArrays.def, false),
                            offEfg: calcTeamAvgPercentile(offEfg, teamAvgArrays.offEfg, true),
                            offTov: calcTeamAvgPercentile(offTov, teamAvgArrays.offTov, false),
                            offOreb: calcTeamAvgPercentile(offOreb, teamAvgArrays.offOreb, true),
                            offFtR: calcTeamAvgPercentile(offFtR, teamAvgArrays.offFtR, true),
                            defEfg: calcTeamAvgPercentile(defEfg, teamAvgArrays.defEfg, false),
                            defTov: calcTeamAvgPercentile(defTov, teamAvgArrays.defTov, true),
                            defOreb: calcTeamAvgPercentile(defOreb, teamAvgArrays.defOreb, false),
                            defFtR: calcTeamAvgPercentile(defFtR, teamAvgArrays.defFtR, false),
                            rimPct: calcTeamAvgPercentile(rimPct, teamAvgArrays.rimPct || [], true),
                            midPct: calcTeamAvgPercentile(midPct, teamAvgArrays.midPct || [], true),
                            threePct: calcTeamAvgPercentile(threePct, teamAvgArrays.threePct || [], true),
                            rimPctV: calcTeamAvgPercentile(rimPctV, teamAvgArrays.rimPctV || [], false),
                            midPctV: calcTeamAvgPercentile(midPctV, teamAvgArrays.midPctV || [], false),
                            threePctV: calcTeamAvgPercentile(threePctV, teamAvgArrays.threePctV || [], false),
                        } : {};
                        
                        return {
                            offEfg, offTov, offOreb, offFtR, defEfg, defTov, defOreb, defFtR,
                            rimPct, midPct, threePct, rimPctV, midPctV, threePctV,
                            rimRate, midRate, threeRate, rimRateV, midRateV, threeRateV,
                            rimM, rimA, midM, midA, threeM, threeA,
                            rimMV, rimAV, midMV, midAV, threeMV, threeAV,
                            adjOff, adjDef, adjNet,
                            offLuckDelta, defLuckDelta,
                            rawOff: l.OFF || 0, rawDef: l.DEF || 0, rawNet: l.NET || 0,
                            pcts: lPcts
                        };
                    };
                    
                    // Mini stat cell component with percentile coloring
                    const MiniStat = ({ label, val, pct, small = false, invert = false }) => {
                        const perfClass = pct !== undefined ? getPerfFromPct(pct) : '';
                        return e('div', { 
                            className: perfClass,
                            style: { 
                                padding: small ? '4px 6px' : '6px 8px', 
                                borderRadius: '6px', 
                                textAlign: 'center',
                                minWidth: small ? '45px' : '55px'
                            }
                        },
                            e('div', { style: { fontSize: '9px', opacity: 0.8, marginBottom: '2px' }}, label),
                            e('div', { style: { fontSize: small ? '12px' : '14px', fontWeight: 'bold' }}, 
                                typeof val === 'number' ? val.toFixed(1) : val
                            ),
                            pct !== undefined && e('div', { style: { fontSize: '8px', opacity: 0.7 }}, Math.round(pct) + '%ile')
                        );
                    };
                    
                    // Shot bar component
                    const MiniShotBar = ({ rimRate, midRate, threeRate }) => e('div', { 
                        style: { display: 'flex', height: '16px', borderRadius: '4px', overflow: 'hidden', background: 'rgba(15, 23, 42, 0.5)' }
                    },
                        rimRate > 0 && e('div', { style: { width: rimRate + '%', background: 'linear-gradient(135deg, #dc2626, #ef4444)', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '8px', fontWeight: 'bold', color: 'white' }}, rimRate >= 20 ? Math.round(rimRate) + '%' : ''),
                        midRate > 0 && e('div', { style: { width: midRate + '%', background: 'linear-gradient(135deg, #ea580c, #f97316)', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '8px', fontWeight: 'bold', color: 'white' }}, midRate >= 20 ? Math.round(midRate) + '%' : ''),
                        threeRate > 0 && e('div', { style: { width: threeRate + '%', background: 'linear-gradient(135deg, #2563eb, #3b82f6)', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '8px', fontWeight: 'bold', color: 'white' }}, threeRate >= 20 ? Math.round(threeRate) + '%' : '')
                    );
                    
                    // V5.22: BPM 2.0 coefficients for individual player BPM calculation
                    const BPM_COEFFS = {
                        a: 0.123391, b: 0.119597, c: -0.151287, d: 1.255644,
                        e: 0.531838, f: -0.305868, g: 0.921292, h: 0.711217,
                        i: 0.017022, j: 0.297639, k: 0.213485, l: 0.725930
                    };
                    const OBPM_COEFFS = {
                        a: 0.064448, b: 0.211125, c: -0.107545, d: 0.346513,
                        e: -0.052476, f: -0.041787, g: 0.932965, h: 0.687359,
                        i: 0.007952, j: 0.374706, k: -0.181891, l: 0.239862
                    };
                    const lgAvg3PAr = 0.40;

                    // V5.22: Calculate BPM for each player in a lineup
                    const getPlayerBpmInLineup = (playerName, lineup) => {
                        if (!playerData || playerData.length === 0) return null;

                        const normalizedLineup = lineup.normalizedLineup || lineup.Lineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',');
                        const playerNorm = normalizePlayerName(playerName);

                        // Find player's stats in this lineup from playerData (player_lineup_stats_enhanced)
                        const playerRow = playerData.find(pd => {
                            if (!pd.Player || normalizePlayerName(pd.Player) !== playerNorm) return false;
                            if (lineup.Team && pd.Team !== lineup.Team) return false;
                            // Construct full lineup from Player + Teammates
                            const teammates = pd.Teammates || '';
                            const fullLineup = pd.Player + ',' + teammates;
                            const pdLineupNorm = fullLineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',');
                            return pdLineupNorm === normalizedLineup;
                        });

                        if (!playerRow) return null;

                        // Get lineup totals from lineupData for percentage denominators
                        const lt = {
                            poss: parseFloat(lineup.POSS) || parseFloat(lineup.COMB_POSS) || 0,
                            possV: parseFloat(lineup.POSS_VS) || 0,
                            oreb: parseFloat(lineup.OREB) || 0,
                            dreb: parseFloat(lineup.DREB) || 0,
                            orebV: parseFloat(lineup.OREB_VS) || 0,
                            drebV: parseFloat(lineup.DREB_VS) || 0,
                            fga: parseFloat(lineup.FGA) || 0,
                            fgm: parseFloat(lineup.FGM) || 0,
                            fta: parseFloat(lineup.FTA) || 0,
                            fgaV: parseFloat(lineup.FGA_VS) || 0,
                            mins: (parseFloat(lineup.TIME) || parseFloat(lineup.TOTAL_TIME) || 0) / 60
                        };

                        if (lt.poss < 1 || lt.mins < 0.1) return null;

                        // Get all teammates' FGM for AST% calculation
                        const allPlayersInLineup = playerData.filter(pd => {
                            if (lineup.Team && pd.Team !== lineup.Team) return false;
                            const teammates = pd.Teammates || '';
                            const fullLineup = pd.Player + ',' + teammates;
                            const pdLineupNorm = fullLineup.split(',').map(p => normalizePlayerName(p.trim())).sort().join(',');
                            return pdLineupNorm === normalizedLineup;
                        });
                        const teamFgm = allPlayersInLineup.reduce((sum, pd) => sum + (parseFloat(pd.FGM) || 0), 0);

                        // Player stats
                        const pStats = {
                            pts: parseFloat(playerRow.PTS) || 0,
                            fga: parseFloat(playerRow.FGA) || 0,
                            fgm: parseFloat(playerRow.FGM) || 0,
                            tpa: parseFloat(playerRow['3PA']) || 0,
                            fta: parseFloat(playerRow.FTA) || 0,
                            oreb: parseFloat(playerRow.OREB) || 0,
                            dreb: parseFloat(playerRow.DREB) || 0,
                            ast: parseFloat(playerRow.AST) || 0,
                            stl: parseFloat(playerRow.STL) || 0,
                            blk: parseFloat(playerRow.BLK) || 0,
                            tov: parseFloat(playerRow.TOV) || 0,
                            mins: parseFloat(playerRow.Minutes) || (parseFloat(playerRow.TOTAL_TIME) || 0) / 60,
                            gp: 1
                        };

                        // Calculate percentage stats
                        const reMpg = pStats.mins / (pStats.gp + 2);
                        const orebOpps = lt.oreb + lt.drebV;
                        const orbPct = orebOpps > 0 ? (pStats.oreb / orebOpps) * 100 : 0;
                        const drebOpps = lt.dreb + lt.orebV;
                        const drbPct = drebOpps > 0 ? (pStats.dreb / drebOpps) * 100 : 0;
                        const trbPct = (orebOpps + drebOpps) > 0 ? ((pStats.oreb + pStats.dreb) / (orebOpps + drebOpps)) * 100 : 0;
                        const stlPct = lt.possV > 0 ? (pStats.stl / lt.possV) * 100 : 0;
                        const opp2pa = lt.fgaV * 0.6;
                        const blkPct = opp2pa > 0 ? (pStats.blk / opp2pa) * 100 : 0;
                        const tmFgmExcludingSelf = teamFgm - pStats.fgm;
                        const astPct = tmFgmExcludingSelf > 0 ? (pStats.ast / tmFgmExcludingSelf) * 100 : 0;
                        const playerPossUsed = pStats.fga + 0.44 * pStats.fta + pStats.tov;
                        const usgPct = lt.poss > 0 ? (playerPossUsed / lt.poss) * 100 : 0;
                        const tovPct = playerPossUsed > 0 ? (pStats.tov / playerPossUsed) * 100 : 0;
                        const tsa = 2 * (pStats.fga + 0.44 * pStats.fta);
                        const tsPct = tsa > 0 ? (pStats.pts / tsa) * 100 : 0;
                        const teamTsa = 2 * (lt.fga + 0.44 * lt.fta);
                        const teamTsPct = teamTsa > 0 ? ((lt.fgm * 2 + (lt.fga > 0 ? (lt.fgm / lt.fga) * lt.fga * 0.5 : 0)) / teamTsa) * 100 : 50;
                        const threePAr = pStats.fga > 0 ? pStats.tpa / pStats.fga : 0;

                        // Calculate BPM using BPM 2.0 formula
                        const term1 = BPM_COEFFS.a * reMpg;
                        const term2 = BPM_COEFFS.b * orbPct;
                        const term3 = BPM_COEFFS.c * drbPct;
                        const term4 = BPM_COEFFS.d * stlPct;
                        const term5 = BPM_COEFFS.e * blkPct;
                        const term6 = BPM_COEFFS.f * astPct;
                        const term7 = -BPM_COEFFS.g * (usgPct / 100) * tovPct;
                        const scoringTerm = BPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                            (2 * (tsPct - teamTsPct) / 100 + BPM_COEFFS.i * astPct / 100 + BPM_COEFFS.j * (threePAr - lgAvg3PAr) - BPM_COEFFS.k);
                        const term9 = BPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;
                        const bpm = term1 + term2 + term3 + term4 + term5 + term6 + term7 + scoringTerm + term9;

                        // Calculate OBPM
                        const oTerm1 = OBPM_COEFFS.a * reMpg;
                        const oTerm2 = OBPM_COEFFS.b * orbPct;
                        const oTerm3 = OBPM_COEFFS.c * drbPct;
                        const oTerm4 = OBPM_COEFFS.d * stlPct;
                        const oTerm5 = OBPM_COEFFS.e * blkPct;
                        const oTerm6 = OBPM_COEFFS.f * astPct;
                        const oTerm7 = -OBPM_COEFFS.g * (usgPct / 100) * tovPct;
                        const oScoringTerm = OBPM_COEFFS.h * (usgPct / 100) * (1 - tovPct / 100) *
                            (2 * (tsPct - teamTsPct) / 100 + OBPM_COEFFS.i * astPct / 100 + OBPM_COEFFS.j * (threePAr - lgAvg3PAr) - OBPM_COEFFS.k);
                        const oTerm9 = OBPM_COEFFS.l * Math.sqrt(Math.max(0, astPct * trbPct)) / 100;
                        const obpm = oTerm1 + oTerm2 + oTerm3 + oTerm4 + oTerm5 + oTerm6 + oTerm7 + oScoringTerm + oTerm9;

                        return { bpm, obpm, dbpm: bpm - obpm };
                    };

                    // V5.22: Helper to get BPM color based on value
                    const getBpmColor = (bpm) => {
                        if (bpm === null || bpm === undefined) return '#64748b';
                        if (bpm >= 5) return '#22c55e';
                        if (bpm >= 2) return '#4ade80';
                        if (bpm >= 0) return '#86efac';
                        if (bpm >= -2) return '#fca5a5';
                        if (bpm >= -5) return '#f87171';
                        return '#ef4444';
                    };

                    // V5.22: Helper to get BPM background based on value
                    const getBpmBackground = (bpm) => {
                        if (bpm === null || bpm === undefined) return 'rgba(100, 116, 139, 0.2)';
                        if (bpm >= 5) return 'rgba(34, 197, 94, 0.25)';
                        if (bpm >= 2) return 'rgba(74, 222, 128, 0.2)';
                        if (bpm >= 0) return 'rgba(134, 239, 172, 0.15)';
                        if (bpm >= -2) return 'rgba(252, 165, 165, 0.15)';
                        if (bpm >= -5) return 'rgba(248, 113, 113, 0.2)';
                        return 'rgba(239, 68, 68, 0.25)';
                    };

                    // Lineup Card component
                    const LineupCard = ({ l, i }) => {
                        const stats = calcLineupStats(l);
                        const lineupMatchups = matchupData.length > 0 ? getLineupMatchups(l.normalizedLineup) : [];
                        const isSelected = selectedLineup && selectedLineup.normalizedLineup === l.normalizedLineup;
                        // V6.1: Apply merge rules for display
                        const players = l.Lineup.split(',').map(p => applyPlayerMerge(p.trim()));
                        const hasAdjustments = mainMasterScheduleAdj > 0 || offLuckAdj > 0 || defLuckAdj > 0;

                        // V5.22: Calculate BPM for each player in this lineup
                        const playerBpms = players.map(p => ({ name: p, bpm: getPlayerBpmInLineup(p, l) }));
                        
                        return e('div', { 
                            key: i,
                            style: { 
                                background: isSelected ? 'rgba(139, 92, 246, 0.15)' : 'rgba(30, 41, 59, 0.6)',
                                border: isSelected ? '2px solid rgba(139, 92, 246, 0.5)' : '1px solid rgba(71, 85, 105, 0.5)',
                                borderRadius: '12px',
                                padding: '16px',
                                marginBottom: '12px',
                                cursor: matchupData.length > 0 ? 'pointer' : 'default',
                                transition: 'all 0.2s ease'
                            },
                            onClick: matchupData.length > 0 ? () => { setSelectedLineup(l); setShowMatchupsModal(true); } : undefined
                        },
                            // Header Row: Players + Key Stats
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '12px', flexWrap: 'wrap', gap: '12px' }},
                                // Players with BPM
                                e('div', { style: { flex: '1', minWidth: '350px' }},
                                    e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '6px', marginBottom: '6px' }},
                                        playerBpms.map((pb, pi) => e('div', {
                                            key: pi,
                                            style: {
                                                background: getBpmBackground(pb.bpm?.bpm),
                                                border: '1px solid ' + (pb.bpm ? getBpmColor(pb.bpm.bpm) + '66' : 'rgba(96, 165, 250, 0.4)'),
                                                padding: '4px 8px',
                                                borderRadius: '6px',
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'center',
                                                minWidth: '70px'
                                            }
                                        },
                                            e('div', { style: { fontSize: '11px', color: '#93c5fd', fontWeight: '500', marginBottom: '2px' }}, pb.name),
                                            pb.bpm ? e('div', { style: { fontSize: '10px', fontWeight: '700', color: getBpmColor(pb.bpm.bpm) }},
                                                (pb.bpm.bpm >= 0 ? '+' : '') + pb.bpm.bpm.toFixed(1) + ' BPM'
                                            ) : e('div', { style: { fontSize: '9px', color: '#64748b' }}, 'No data')
                                        ))
                                    ),
                                    e('div', { style: { display: 'flex', gap: '12px', fontSize: '11px', color: '#94a3b8' }},
                                        e('span', null, '⏱️ ', Math.round(l.COMB_POSS), ' poss'),
                                        e('span', null, '🕐 ', ((l.TIME || 0) / 60).toFixed(1), ' min'),
                                        matchupData.length > 0 && e('span', { style: { color: '#a78bfa' }}, '⚔️ ', lineupMatchups.length, ' matchups')
                                    )
                                ),
                                // Key Ratings (using adjusted values)
                                e('div', { style: { display: 'flex', gap: '8px' }},
                                    e(MiniStat, { label: 'OFF', val: stats.adjOff, pct: stats.pcts.off }),
                                    e(MiniStat, { label: 'DEF', val: stats.adjDef, pct: stats.pcts.def }),
                                    e('div', { 
                                        className: getPerfFromPct(stats.pcts.net),
                                        style: { 
                                            padding: '6px 12px', 
                                            borderRadius: '6px', 
                                            textAlign: 'center',
                                            minWidth: '70px'
                                        }
                                    },
                                        e('div', { style: { fontSize: '9px', opacity: 0.8, marginBottom: '2px' }}, 'NET', hasAdjustments && e('span', { style: { color: '#fbbf24', marginLeft: '2px' }}, '⚙️')),
                                        e('div', { style: { fontSize: '18px', fontWeight: 'bold', color: getNetColor(stats.adjNet) }}, 
                                            (stats.adjNet >= 0 ? '+' : '') + stats.adjNet.toFixed(1)
                                        ),
                                        hasAdjustments && Math.abs(stats.adjNet - stats.rawNet) > 0.1 && e('div', { style: { fontSize: '8px', color: '#fbbf24' }}, 
                                            'Raw: ' + (stats.rawNet >= 0 ? '+' : '') + stats.rawNet.toFixed(1)
                                        ),
                                        e('div', { style: { fontSize: '8px', opacity: 0.7 }}, Math.round(stats.pcts.net || 50) + '%ile')
                                    )
                                )
                            ),
                            
                            // Four Factors Row
                            e('div', { className: 'lineup-card-four-factors', style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px', marginBottom: '12px' }},
                                // Offensive Four Factors
                                e('div', { style: { background: 'rgba(34, 197, 94, 0.08)', border: '1px solid rgba(34, 197, 94, 0.25)', borderRadius: '8px', padding: '10px' }},
                                    e('div', { style: { fontSize: '10px', fontWeight: 'bold', color: '#4ade80', marginBottom: '8px' }}, '📈 Offensive Four Factors', mainMasterScheduleAdj > 0 && e('span', { style: { color: '#fbbf24', marginLeft: '4px', fontSize: '9px' }}, '⚙️ Adj')),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '6px' }},
                                        e(MiniStat, { label: 'eFG%', val: stats.offEfg, pct: stats.pcts.offEfg, small: true }),
                                        e(MiniStat, { label: 'TOV%', val: stats.offTov, pct: stats.pcts.offTov, small: true }),
                                        e(MiniStat, { label: 'OREB%', val: stats.offOreb, pct: stats.pcts.offOreb, small: true }),
                                        e(MiniStat, { label: 'FTR', val: stats.offFtR, pct: stats.pcts.offFtR, small: true })
                                    )
                                ),
                                // Defensive Four Factors
                                e('div', { style: { background: 'rgba(239, 68, 68, 0.08)', border: '1px solid rgba(239, 68, 68, 0.25)', borderRadius: '8px', padding: '10px' }},
                                    e('div', { style: { fontSize: '10px', fontWeight: 'bold', color: '#f87171', marginBottom: '8px' }}, '🛡️ Defensive Four Factors', mainMasterScheduleAdj > 0 && e('span', { style: { color: '#fbbf24', marginLeft: '4px', fontSize: '9px' }}, '⚙️ Adj')),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '6px' }},
                                        e(MiniStat, { label: 'eFG%', val: stats.defEfg, pct: stats.pcts.defEfg, small: true }),
                                        e(MiniStat, { label: 'TOV%', val: stats.defTov, pct: stats.pcts.defTov, small: true }),
                                        e(MiniStat, { label: 'OREB%', val: stats.defOreb, pct: stats.pcts.defOreb, small: true }),
                                        e(MiniStat, { label: 'FTR', val: stats.defFtR, pct: stats.pcts.defFtR, small: true })
                                    )
                                )
                            ),
                            
                            // Shot Distribution Row
                            e('div', { className: 'lineup-card-shot-dist', style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }},
                                // Offensive Shot Distribution
                                e('div', { style: { background: 'rgba(34, 197, 94, 0.05)', border: '1px solid rgba(34, 197, 94, 0.2)', borderRadius: '8px', padding: '10px' }},
                                    e('div', { style: { fontSize: '10px', fontWeight: 'bold', color: '#4ade80', marginBottom: '6px' }}, '🎯 Shot Distribution'),
                                    e(MiniShotBar, { rimRate: stats.rimRate, midRate: stats.midRate, threeRate: stats.threeRate }),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '4px', marginTop: '6px' }},
                                        e('div', { className: getPerfFromPct(stats.pcts.rimPct), style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#ef4444' }}, 'Rim'),
                                            e('div', { style: { fontSize: '11px', fontWeight: 'bold' }}, stats.rimPct.toFixed(1) + '%'),
                                            e('div', { style: { fontSize: '8px', opacity: 0.6 }}, Math.round(stats.rimM) + '/' + Math.round(stats.rimA))
                                        ),
                                        e('div', { className: getPerfFromPct(stats.pcts.midPct), style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#f97316' }}, 'Mid'),
                                            e('div', { style: { fontSize: '11px', fontWeight: 'bold' }}, stats.midPct.toFixed(1) + '%'),
                                            e('div', { style: { fontSize: '8px', opacity: 0.6 }}, Math.round(stats.midM) + '/' + Math.round(stats.midA))
                                        ),
                                        e('div', { className: getPerfFromPct(stats.pcts.threePct), style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#3b82f6' }}, '3PT'),
                                            e('div', { style: { fontSize: '11px', fontWeight: 'bold' }}, stats.threePct.toFixed(1) + '%'),
                                            e('div', { style: { fontSize: '8px', opacity: 0.6 }}, Math.round(stats.threeM) + '/' + Math.round(stats.threeA))
                                        )
                                    )
                                ),
                                // Defensive Shot Distribution (Allowed)
                                e('div', { style: { background: 'rgba(239, 68, 68, 0.05)', border: '1px solid rgba(239, 68, 68, 0.2)', borderRadius: '8px', padding: '10px' }},
                                    e('div', { style: { fontSize: '10px', fontWeight: 'bold', color: '#f87171', marginBottom: '6px' }}, '🚫 Opponent Shots Allowed'),
                                    e(MiniShotBar, { rimRate: stats.rimRateV, midRate: stats.midRateV, threeRate: stats.threeRateV }),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '4px', marginTop: '6px' }},
                                        e('div', { className: getPerfFromPct(stats.pcts.rimPctV), style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#ef4444' }}, 'Rim'),
                                            e('div', { style: { fontSize: '11px', fontWeight: 'bold' }}, stats.rimPctV.toFixed(1) + '%'),
                                            e('div', { style: { fontSize: '8px', opacity: 0.6 }}, Math.round(stats.rimMV) + '/' + Math.round(stats.rimAV))
                                        ),
                                        e('div', { className: getPerfFromPct(stats.pcts.midPctV), style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#f97316' }}, 'Mid'),
                                            e('div', { style: { fontSize: '11px', fontWeight: 'bold' }}, stats.midPctV.toFixed(1) + '%'),
                                            e('div', { style: { fontSize: '8px', opacity: 0.6 }}, Math.round(stats.midMV) + '/' + Math.round(stats.midAV))
                                        ),
                                        e('div', { className: getPerfFromPct(stats.pcts.threePctV), style: { padding: '4px', borderRadius: '4px', textAlign: 'center' }},
                                            e('div', { style: { fontSize: '8px', color: '#3b82f6' }}, '3PT'),
                                            e('div', { style: { fontSize: '11px', fontWeight: 'bold' }}, stats.threePctV.toFixed(1) + '%'),
                                            e('div', { style: { fontSize: '8px', opacity: 0.6 }}, Math.round(stats.threeMV) + '/' + Math.round(stats.threeAV))
                                        )
                                    )
                                )
                            )
                        );
                    };
                    
                    return e('div', { className: 'section' }, 
                        // Header
                        e('div', { className: 'flex-between', style: { marginBottom: '16px' }},
                            e('div', null,
                                e('h2', { className: 'section-title', style: { marginBottom: '4px' }}, '👥 Lineup Details'),
                                e('div', { style: { fontSize: '11px', color: '#94a3b8' }}, 
                                    filtered.length + ' lineups sorted by possessions • Includes Four Factors & Shot Distribution'
                                )
                            ),
                            e('div', { style: { display: 'flex', gap: '8px', alignItems: 'center' }},
                                e('button', { 
                                    className: 'btn btn-expand', 
                                    onClick: () => setShowAllLineups(!showAllLineups) 
                                }, showAllLineups ? '📋 Show Top 10' : '📋 Show All (' + filtered.length + ')'),
                                matchupData.length > 0 && e('span', { style: { fontSize: '10px', color: '#a78bfa' }}, 'Click card for matchups')
                            )
                        ),
                        
                        // V4.9.8.7.21: Adjustment Sliders Section
                        e('div', { 
                            style: { 
                                marginBottom: '16px',
                                padding: '14px 16px',
                                background: 'linear-gradient(135deg, rgba(251, 191, 36, 0.08), rgba(249, 115, 22, 0.05))',
                                border: '1px solid rgba(251, 191, 36, 0.25)',
                                borderRadius: '10px'
                            }
                        },
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', gap: '16px' }},
                                // MASTER Opp Qual Adj Slider
                                e('div', null,
                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '6px' }},
                                        e('span', { style: { fontSize: '14px' }}, '🎯'),
                                        e('span', { style: { fontSize: '12px', fontWeight: '700', color: '#fbbf24' }}, 'MASTER Opp Qual Adj'),
                                        e('span', { style: { 
                                            fontSize: '11px', 
                                            fontWeight: 'bold', 
                                            color: mainMasterScheduleAdj > 0 ? '#f59e0b' : '#64748b',
                                            padding: '2px 6px',
                                            background: mainMasterScheduleAdj > 0 ? 'rgba(251, 191, 36, 0.2)' : 'transparent',
                                            borderRadius: '4px'
                                        }}, mainMasterScheduleAdj + '%')
                                    ),
                                    e('input', { 
                                        type: 'range', 
                                        min: 0, 
                                        max: 100, 
                                        value: mainMasterScheduleAdj,
                                        onChange: ev => setMainMasterScheduleAdj(parseInt(ev.target.value)),
                                        style: { width: '100%', height: '6px', accentColor: '#f59e0b' }
                                    }),
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '9px', color: '#64748b', marginTop: '2px' }},
                                        e('span', null, '0% (Raw)'),
                                        e('span', null, '100% (Full Regress)')
                                    )
                                ),
                                
                                // 3PT Luck Adjustment
                                e('div', null,
                                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '6px' }},
                                        e('span', { style: { fontSize: '14px' }}, '🎲'),
                                        e('span', { style: { fontSize: '12px', fontWeight: '700', color: '#fbbf24' }}, '3PT Luck Adjustment'),
                                        (offLuckAdj > 0 || defLuckAdj > 0) && e('span', { style: { 
                                            fontSize: '10px', 
                                            padding: '2px 6px',
                                            background: 'rgba(251, 191, 36, 0.2)',
                                            borderRadius: '4px',
                                            color: '#fbbf24'
                                        }}, 'Off: ' + offLuckAdj + '% | Def: ' + defLuckAdj + '%')
                                    ),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }},
                                        // Offensive Luck
                                        e('div', null,
                                            e('div', { style: { fontSize: '10px', color: '#4ade80', marginBottom: '4px', display: 'flex', justifyContent: 'space-between' }},
                                                e('span', null, 'Offensive', seasonStatsMap && seasonStatsMap.size > 0 ? '' : e('span', { style: { color: '#f97316', marginLeft: '4px', fontSize: '8px' }}, '(needs season stats)')),
                                                e('span', { style: { 
                                                    padding: '1px 5px', 
                                                    borderRadius: '4px',
                                                    background: offLuckAdj > 0 ? 'rgba(34, 197, 94, 0.3)' : 'rgba(100, 116, 139, 0.3)',
                                                    color: offLuckAdj > 0 ? '#4ade80' : '#94a3b8'
                                                }}, offLuckAdj + '%')
                                            ),
                                            e('input', { 
                                                type: 'range', 
                                                min: 0, 
                                                max: 100, 
                                                value: offLuckAdj, 
                                                onChange: ev => setOffLuckAdj(parseInt(ev.target.value)),
                                                style: { width: '100%', height: '4px', accentColor: '#4ade80' }
                                            })
                                        ),
                                        // Defensive Luck
                                        e('div', null,
                                            e('div', { style: { fontSize: '10px', color: '#f87171', marginBottom: '4px', display: 'flex', justifyContent: 'space-between' }},
                                                e('span', null, 'Defensive'),
                                                e('span', { style: { 
                                                    padding: '1px 5px', 
                                                    borderRadius: '4px',
                                                    background: defLuckAdj > 0 ? 'rgba(239, 68, 68, 0.3)' : 'rgba(100, 116, 139, 0.3)',
                                                    color: defLuckAdj > 0 ? '#f87171' : '#94a3b8'
                                                }}, defLuckAdj + '%')
                                            ),
                                            e('input', { 
                                                type: 'range', 
                                                min: 0, 
                                                max: 100, 
                                                value: defLuckAdj, 
                                                onChange: ev => setDefLuckAdj(parseInt(ev.target.value)),
                                                style: { width: '100%', height: '4px', accentColor: '#f87171' }
                                            })
                                        )
                                    )
                                )
                            ),
                            // Reset button and info
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '10px', flexWrap: 'wrap', gap: '8px' }},
                                e('div', { style: { fontSize: '9px', color: '#94a3b8', maxWidth: '400px' }},
                                    mainMasterScheduleAdj > 0 ? 'Opp Qual: Regresses Four Factors toward league avg. ' : '',
                                    offLuckAdj > 0 ? 'Off Luck: Uses player season 3PT% averages. ' : '',
                                    defLuckAdj > 0 ? 'Def Luck: Regresses opp 3PT% to league avg (~' + leagueAvg3Pct.toFixed(1) + '%). ' : '',
                                    (mainMasterScheduleAdj === 0 && offLuckAdj === 0 && defLuckAdj === 0) && 'Adjust sliders to apply opponent quality and 3PT luck corrections.'
                                ),
                                (mainMasterScheduleAdj > 0 || offLuckAdj > 0 || defLuckAdj > 0) && e('button', {
                                    className: 'btn btn-secondary',
                                    style: { fontSize: '10px', padding: '4px 10px' },
                                    onClick: () => { setMainMasterScheduleAdj(0); setOffLuckAdj(0); setDefLuckAdj(0); }
                                }, '↻ Reset All')
                            )
                        ),
                        
                        // Color Legend
                        e('div', { style: { marginBottom: '16px', padding: '10px 14px', background: 'rgba(15, 23, 42, 0.5)', borderRadius: '8px', display: 'flex', gap: '8px', flexWrap: 'wrap', alignItems: 'center' }},
                            e('span', { style: { fontSize: '10px', color: '#64748b', marginRight: '4px' }}, 'League Rank:'),
                            e('span', { className: 'legend-item legend-excellent', style: { fontSize: '9px' }}, '90+'),
                            e('span', { className: 'legend-item legend-good', style: { fontSize: '9px' }}, '70-89'),
                            e('span', { className: 'legend-item legend-average', style: { fontSize: '9px' }}, '30-69'),
                            e('span', { className: 'legend-item legend-below', style: { fontSize: '9px' }}, '10-29'),
                            e('span', { className: 'legend-item legend-poor', style: { fontSize: '9px' }}, '<10'),
                            e('div', { style: { marginLeft: 'auto', display: 'flex', gap: '10px', fontSize: '9px' }},
                                e('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' }}, e('span', { style: { width: '12px', height: '12px', background: 'linear-gradient(135deg, #dc2626, #ef4444)', borderRadius: '2px' }}), 'Rim'),
                                e('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' }}, e('span', { style: { width: '12px', height: '12px', background: 'linear-gradient(135deg, #ea580c, #f97316)', borderRadius: '2px' }}), 'Mid'),
                                e('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' }}, e('span', { style: { width: '12px', height: '12px', background: 'linear-gradient(135deg, #2563eb, #3b82f6)', borderRadius: '2px' }}), '3PT')
                            )
                        ),
                        
                        // Scrollable Lineup Cards Container
                        e('div', { 
                            style: { 
                                maxHeight: '700px', 
                                overflowY: 'auto',
                                paddingRight: '8px'
                            }
                        },
                            (showAllLineups ? filtered : filtered.slice(0, 10)).map((l, i) => e(LineupCard, { key: i, l, i }))
                        ),
                        
                        // Footer
                        !showAllLineups && filtered.length > 10 && e('div', { 
                            style: { 
                                textAlign: 'center', 
                                marginTop: '12px', 
                                padding: '10px',
                                background: 'rgba(59, 130, 246, 0.1)',
                                borderRadius: '8px',
                                fontSize: '12px',
                                color: '#60a5fa'
                            }
                        }, 
                            'Showing top 10 of ', e('strong', null, filtered.length), ' lineups • ',
                            e('span', { 
                                style: { cursor: 'pointer', textDecoration: 'underline' },
                                onClick: () => setShowAllLineups(true)
                            }, 'Show all')
                        )
                    );
                })(),

                // ═══════════════════════════════════════════════════════════════════════════
                // V6.0: ADVANCED GAMES VIEW TAB CONTENT (Embedded GAMEVIS)
                // ═══════════════════════════════════════════════════════════════════════════
                activeTab === 'advancedgames' && e('div', { className: 'gv-container', style: { padding: '20px 0' }},
                    // Loading indicator
                    gvLoading && e('div', { className: 'gv-loading' },
                        e('div', { className: 'gv-loading-spinner' }),
                        e('div', null, 'Loading games...'),
                        gvLoadProgress.total > 0 && e('div', { className: 'gv-progress-container' },
                            e('div', { className: 'gv-progress-bar' },
                                e('div', { className: 'gv-progress-fill', style: { width: (gvLoadProgress.current / gvLoadProgress.total * 100) + '%' }})
                            ),
                            e('div', { className: 'gv-progress-text' }, gvLoadProgress.current + ' / ' + gvLoadProgress.total + ' games loaded')
                        )
                    ),

                    // Error display
                    gvError && e('div', { style: { padding: '20px', background: 'rgba(248, 113, 113, 0.2)', borderRadius: '12px', color: '#f87171', marginBottom: '20px' }},
                        '⚠️ ' + gvError
                    ),

                    // UPLOAD VIEW
                    !gvLoading && gvView === 'upload' && e('div', { className: 'gv-upload-section' },
                        e('h2', null, '🎮 Advanced Games View'),
                        e('p', { className: 'gv-splash-subtitle' },
                            'Powerful game analysis powered by FIBA LiveStats data'
                        ),

                        // Main upload area
                        e('div', { style: { padding: '28px', background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.12), rgba(0, 212, 255, 0.08))', borderRadius: '16px', border: '2px dashed rgba(139, 92, 246, 0.4)', marginBottom: '24px', position: 'relative', zIndex: 1 }},
                            gvGameHtmlFiles.length > 0 ?
                                e('div', { style: { textAlign: 'center' }},
                                    e('div', { style: { fontSize: '56px', marginBottom: '16px', animation: 'gvPulse 2s ease-in-out infinite' }}, '✅'),
                                    e('div', { style: { fontSize: '22px', fontWeight: '700', color: '#4ade80', marginBottom: '6px' }},
                                        gvFolderGames.length + ' games loaded successfully!'
                                    ),
                                    e('div', { style: { fontSize: '13px', color: 'var(--gv-text-muted)', marginBottom: '16px' }},
                                        'Ready to analyze detailed player and team statistics'
                                    ),
                                    e('button', {
                                        className: 'gv-upload-btn primary',
                                        onClick: () => setGvView('browser'),
                                        style: { marginTop: '8px', fontSize: '16px', padding: '16px 32px' }
                                    }, '🏀 Browse Game Library →')
                                ) :
                                e('div', { style: { textAlign: 'center' }},
                                    e('div', { style: { fontSize: '64px', marginBottom: '16px' }}, '📁'),
                                    e('div', { style: { fontSize: '18px', fontWeight: '600', color: 'var(--gv-text-primary)', marginBottom: '12px' }},
                                        'Drop your game folder here'
                                    ),
                                    e('div', { style: { fontSize: '13px', color: 'var(--gv-text-muted)', lineHeight: '1.6' }},
                                        'Use the ',
                                        e('span', { style: { color: 'var(--gv-accent-purple)', fontWeight: '600' }}, 'folder upload'),
                                        ' in the header to load a folder containing:',
                                        e('br'),
                                        e('code', { style: { background: 'rgba(0,0,0,0.4)', padding: '4px 8px', borderRadius: '6px', fontSize: '12px', margin: '0 4px' }}, 'game_html/'),
                                        e('br'),
                                        e('span', { style: { fontSize: '11px' }}, 'with '),
                                        e('code', { style: { background: 'rgba(0,0,0,0.4)', padding: '3px 6px', borderRadius: '4px', fontSize: '11px' }}, 'game[id]bs.html'),
                                        e('span', { style: { margin: '0 6px' }}, '+'),
                                        e('code', { style: { background: 'rgba(0,0,0,0.4)', padding: '3px 6px', borderRadius: '4px', fontSize: '11px' }}, 'game[id]pbp.html'),
                                        ' pairs'
                                    )
                                )
                        ),

                        // Feature highlights grid
                        e('div', { className: 'gv-splash-features' },
                            e('div', { className: 'gv-splash-feature' },
                                e('div', { className: 'gv-splash-feature-icon' }, '📊'),
                                e('div', { className: 'gv-splash-feature-title' }, 'Advanced Stats'),
                                e('div', { className: 'gv-splash-feature-desc' }, 'On-court metrics, Four Factors, and efficiency ratings')
                            ),
                            e('div', { className: 'gv-splash-feature' },
                                e('div', { className: 'gv-splash-feature-icon' }, '🎯'),
                                e('div', { className: 'gv-splash-feature-title' }, 'Shot Analysis'),
                                e('div', { className: 'gv-splash-feature-desc' }, 'Rim, mid-range, and 3PT breakdown by player')
                            ),
                            e('div', { className: 'gv-splash-feature' },
                                e('div', { className: 'gv-splash-feature-icon' }, '📈'),
                                e('div', { className: 'gv-splash-feature-title' }, 'Game Flow'),
                                e('div', { className: 'gv-splash-feature-desc' }, 'Scoring and possession battle visualizations')
                            ),
                            e('div', { className: 'gv-splash-feature' },
                                e('div', { className: 'gv-splash-feature-icon' }, '👥'),
                                e('div', { className: 'gv-splash-feature-title' }, 'Lineup Data'),
                                e('div', { className: 'gv-splash-feature-desc' }, 'Five-man unit performance analysis')
                            )
                        ),

                        e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)', marginTop: '24px', position: 'relative', zIndex: 1 }},
                            '💡 Tip: The folder upload in the header will automatically detect game HTML files in a game_html subfolder'
                        )
                    ),

                    // BROWSER VIEW
                    !gvLoading && gvView === 'browser' && gvFolderGames.length > 0 && e('div', { className: 'gv-browser-container' },
                        e('button', {
                            className: 'gv-nav-btn',
                            onClick: () => setGvView('upload')
                        }, '← Back to Upload'),

                        e('div', { className: 'gv-browser-header' },
                            e('h2', null, '🏀 Game Library'),
                            e('p', { style: { color: 'var(--gv-text-muted)' }}, 'Select a game to analyze')
                        ),

                        e('div', { className: 'gv-browser-controls' },
                            e('div', { className: 'gv-game-count' },
                                e('span', null, 'Games loaded:'),
                                e('span', { className: 'count-badge' }, gvFilteredGames.length)
                            ),
                            e('select', {
                                className: 'gv-filter-select',
                                value: gvTeamFilter,
                                onChange: (ev) => setGvTeamFilter(ev.target.value)
                            },
                                e('option', { value: '' }, '🏀 All Teams (' + gvFolderGames.length + ' games)'),
                                gvTeams.map(t => e('option', { key: t, value: t }, t))
                            )
                        ),

                        e('div', { className: 'gv-game-list' },
                            gvFilteredGames.map((game, idx) => {
                                const isExpanded = gvExpandedGames[game.gameId] || false;
                                const ff = game.fourFactors || { home: {}, away: {} };
                                const epa = game.epa || { home: {}, away: {} };

                                return e('div', { key: game.gameId, className: 'gv-game-card' + (isExpanded ? ' expanded' : '') },
                                    // Main row - always visible
                                    e('div', { className: 'gv-game-main' },
                                        // Expand/collapse toggle
                                        e('button', {
                                            className: 'gv-expand-btn',
                                            onClick: (ev) => {
                                                ev.stopPropagation();
                                                setGvExpandedGames(prev => ({
                                                    ...prev,
                                                    [game.gameId]: !prev[game.gameId]
                                                }));
                                            },
                                            style: {
                                                background: 'transparent',
                                                border: 'none',
                                                color: 'var(--gv-text-muted)',
                                                cursor: 'pointer',
                                                fontSize: '16px',
                                                padding: '4px 8px',
                                                marginRight: '8px',
                                                transition: 'transform 0.2s',
                                                transform: isExpanded ? 'rotate(90deg)' : 'rotate(0deg)'
                                            }
                                        }, '▶'),
                                        e('div', { className: 'gv-team home', onClick: () => loadGameForAnalysis(game.gameId) },
                                            e('div', { className: 'gv-team-name' }, game.homeTeam),
                                            game.isHomeWin && e('span', { style: { fontSize: '10px', color: 'var(--gv-positive)' }}, '🏆 WIN')
                                        ),
                                        e('div', { className: 'gv-score-block', onClick: () => loadGameForAnalysis(game.gameId) },
                                            e('span', { className: 'gv-score home' }, game.homeScore || '-'),
                                            e('div', { className: 'gv-score-divider' }),
                                            e('span', { className: 'gv-score away' }, game.awayScore || '-')
                                        ),
                                        e('div', { className: 'gv-team away', onClick: () => loadGameForAnalysis(game.gameId) },
                                            e('div', { className: 'gv-team-name' }, game.awayTeam),
                                            !game.isHomeWin && game.awayScore > 0 && e('span', { style: { fontSize: '10px', color: 'var(--gv-positive)' }}, '🏆 WIN')
                                        ),
                                        e('div', { className: 'gv-game-date' }, game.date || 'Game ' + game.gameId),
                                        e('button', {
                                            className: 'gv-load-btn',
                                            onClick: (ev) => { ev.stopPropagation(); loadGameForAnalysis(game.gameId); }
                                        }, '🔍 Analyze')
                                    ),

                                    // Expanded details - Four Factors & EPA
                                    isExpanded && e('div', { className: 'gv-game-details', style: {
                                        padding: '16px 20px',
                                        borderTop: '1px solid rgba(255,255,255,0.1)',
                                        background: 'rgba(0,0,0,0.2)',
                                        animation: 'slideDown 0.2s ease-out'
                                    }},
                                        // Four Factors comparison
                                        e('div', { style: { marginBottom: '16px' }},
                                            e('div', { style: {
                                                fontSize: '11px',
                                                fontWeight: '600',
                                                color: 'var(--gv-text-muted)',
                                                marginBottom: '10px',
                                                textTransform: 'uppercase',
                                                letterSpacing: '1px'
                                            }}, '📊 Four Factors'),
                                            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 80px 1fr', gap: '8px', alignItems: 'center' }},
                                                // Header row
                                                e('div', { style: { textAlign: 'right', fontSize: '10px', color: 'var(--gv-team-home)', fontWeight: '600' }}, game.homeTeam.substring(0, 12)),
                                                e('div', { style: { textAlign: 'center', fontSize: '10px', color: 'var(--gv-text-muted)' }}, 'Stat'),
                                                e('div', { style: { textAlign: 'left', fontSize: '10px', color: 'var(--gv-team-away)', fontWeight: '600' }}, game.awayTeam.substring(0, 12)),

                                                // eFG%
                                                e('div', { style: { textAlign: 'right', fontSize: '13px', fontWeight: '600', color: (ff.home.efg || 0) > (ff.away.efg || 0) ? 'var(--gv-positive)' : 'var(--gv-text-primary)' }}, (ff.home.efg || 0).toFixed(1) + '%'),
                                                e('div', { style: { textAlign: 'center', fontSize: '10px', color: 'var(--gv-text-muted)', background: 'rgba(255,255,255,0.05)', padding: '2px 6px', borderRadius: '4px' }}, 'eFG%'),
                                                e('div', { style: { textAlign: 'left', fontSize: '13px', fontWeight: '600', color: (ff.away.efg || 0) > (ff.home.efg || 0) ? 'var(--gv-positive)' : 'var(--gv-text-primary)' }}, (ff.away.efg || 0).toFixed(1) + '%'),

                                                // TOV%
                                                e('div', { style: { textAlign: 'right', fontSize: '13px', fontWeight: '600', color: (ff.home.tovPct || 0) < (ff.away.tovPct || 0) ? 'var(--gv-positive)' : 'var(--gv-text-primary)' }}, (ff.home.tovPct || 0).toFixed(1) + '%'),
                                                e('div', { style: { textAlign: 'center', fontSize: '10px', color: 'var(--gv-text-muted)', background: 'rgba(255,255,255,0.05)', padding: '2px 6px', borderRadius: '4px' }}, 'TOV%'),
                                                e('div', { style: { textAlign: 'left', fontSize: '13px', fontWeight: '600', color: (ff.away.tovPct || 0) < (ff.home.tovPct || 0) ? 'var(--gv-positive)' : 'var(--gv-text-primary)' }}, (ff.away.tovPct || 0).toFixed(1) + '%'),

                                                // OREB%
                                                e('div', { style: { textAlign: 'right', fontSize: '13px', fontWeight: '600', color: (ff.home.orebPct || 0) > (ff.away.orebPct || 0) ? 'var(--gv-positive)' : 'var(--gv-text-primary)' }}, (ff.home.orebPct || 0).toFixed(1) + '%'),
                                                e('div', { style: { textAlign: 'center', fontSize: '10px', color: 'var(--gv-text-muted)', background: 'rgba(255,255,255,0.05)', padding: '2px 6px', borderRadius: '4px' }}, 'OREB%'),
                                                e('div', { style: { textAlign: 'left', fontSize: '13px', fontWeight: '600', color: (ff.away.orebPct || 0) > (ff.home.orebPct || 0) ? 'var(--gv-positive)' : 'var(--gv-text-primary)' }}, (ff.away.orebPct || 0).toFixed(1) + '%'),

                                                // FT Rate
                                                e('div', { style: { textAlign: 'right', fontSize: '13px', fontWeight: '600', color: (ff.home.ftRate || 0) > (ff.away.ftRate || 0) ? 'var(--gv-positive)' : 'var(--gv-text-primary)' }}, (ff.home.ftRate || 0).toFixed(1) + '%'),
                                                e('div', { style: { textAlign: 'center', fontSize: '10px', color: 'var(--gv-text-muted)', background: 'rgba(255,255,255,0.05)', padding: '2px 6px', borderRadius: '4px' }}, 'FT Rate'),
                                                e('div', { style: { textAlign: 'left', fontSize: '13px', fontWeight: '600', color: (ff.away.ftRate || 0) > (ff.home.ftRate || 0) ? 'var(--gv-positive)' : 'var(--gv-text-primary)' }}, (ff.away.ftRate || 0).toFixed(1) + '%')
                                            )
                                        ),

                                        // EPA Battles
                                        e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px' }},
                                            // Scoring Battle EPA
                                            e('div', { style: {
                                                background: 'linear-gradient(135deg, rgba(0,212,255,0.1), rgba(0,212,255,0.02))',
                                                borderRadius: '8px',
                                                padding: '12px',
                                                border: '1px solid rgba(0,212,255,0.2)'
                                            }},
                                                e('div', { style: { fontSize: '10px', fontWeight: '600', color: 'var(--gv-accent-cyan)', marginBottom: '8px', textTransform: 'uppercase', letterSpacing: '1px' }}, '🎯 Scoring Battle EPA'),
                                                e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' }},
                                                    e('div', { style: { textAlign: 'center' }},
                                                        e('div', { style: { fontSize: '10px', color: 'var(--gv-team-home)', marginBottom: '2px' }}, game.homeTeam.substring(0, 8)),
                                                        e('div', { style: {
                                                            fontSize: '18px',
                                                            fontWeight: '700',
                                                            color: parseFloat(epa.home.scoringBattle || 0) >= 0 ? 'var(--gv-positive)' : 'var(--gv-negative)'
                                                        }}, (parseFloat(epa.home.scoringBattle || 0) >= 0 ? '+' : '') + (epa.home.scoringBattle || '0.0'))
                                                    ),
                                                    e('div', { style: { fontSize: '12px', color: 'var(--gv-text-muted)' }}, 'vs'),
                                                    e('div', { style: { textAlign: 'center' }},
                                                        e('div', { style: { fontSize: '10px', color: 'var(--gv-team-away)', marginBottom: '2px' }}, game.awayTeam.substring(0, 8)),
                                                        e('div', { style: {
                                                            fontSize: '18px',
                                                            fontWeight: '700',
                                                            color: parseFloat(epa.away.scoringBattle || 0) >= 0 ? 'var(--gv-positive)' : 'var(--gv-negative)'
                                                        }}, (parseFloat(epa.away.scoringBattle || 0) >= 0 ? '+' : '') + (epa.away.scoringBattle || '0.0'))
                                                    )
                                                ),
                                                e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)', marginTop: '6px', textAlign: 'center' }}, 'eFG% + FT Rate contribution')
                                            ),

                                            // Possession Battle EPA
                                            e('div', { style: {
                                                background: 'linear-gradient(135deg, rgba(255,0,170,0.1), rgba(255,0,170,0.02))',
                                                borderRadius: '8px',
                                                padding: '12px',
                                                border: '1px solid rgba(255,0,170,0.2)'
                                            }},
                                                e('div', { style: { fontSize: '10px', fontWeight: '600', color: 'var(--gv-accent-magenta)', marginBottom: '8px', textTransform: 'uppercase', letterSpacing: '1px' }}, '🔄 Possession Battle EPA'),
                                                e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' }},
                                                    e('div', { style: { textAlign: 'center' }},
                                                        e('div', { style: { fontSize: '10px', color: 'var(--gv-team-home)', marginBottom: '2px' }}, game.homeTeam.substring(0, 8)),
                                                        e('div', { style: {
                                                            fontSize: '18px',
                                                            fontWeight: '700',
                                                            color: parseFloat(epa.home.possessionBattle || 0) >= 0 ? 'var(--gv-positive)' : 'var(--gv-negative)'
                                                        }}, (parseFloat(epa.home.possessionBattle || 0) >= 0 ? '+' : '') + (epa.home.possessionBattle || '0.0'))
                                                    ),
                                                    e('div', { style: { fontSize: '12px', color: 'var(--gv-text-muted)' }}, 'vs'),
                                                    e('div', { style: { textAlign: 'center' }},
                                                        e('div', { style: { fontSize: '10px', color: 'var(--gv-team-away)', marginBottom: '2px' }}, game.awayTeam.substring(0, 8)),
                                                        e('div', { style: {
                                                            fontSize: '18px',
                                                            fontWeight: '700',
                                                            color: parseFloat(epa.away.possessionBattle || 0) >= 0 ? 'var(--gv-positive)' : 'var(--gv-negative)'
                                                        }}, (parseFloat(epa.away.possessionBattle || 0) >= 0 ? '+' : '') + (epa.away.possessionBattle || '0.0'))
                                                    )
                                                ),
                                                e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)', marginTop: '6px', textAlign: 'center' }}, 'TOV% + OREB% contribution')
                                            )
                                        )
                                    )
                                );
                            })
                        )
                    ),

                    // GAME VIEW - Full GAMEVIS Embedded Visualization
                    !gvLoading && gvView === 'game' && gvCurrentGame && e('div', null,
                        e('button', {
                            className: 'gv-nav-btn',
                            onClick: () => { setGvView('browser'); setGvCurrentGame(null); }
                        }, '← Back to Games'),

                        e('div', { className: 'gv-visualization' },
                            // Game Header
                            e('div', { className: 'gv-game-header' },
                                e('div', { className: 'gv-team-block' },
                                    e('div', { className: 'gv-team-logo home' }, gvCurrentGame.summary.homeTeam.substring(0, 3).toUpperCase()),
                                    e('div', { className: 'gv-team-content' },
                                        e('h3', null, gvCurrentGame.summary.homeTeam),
                                        e('span', { className: 'gv-result-tag ' + (gvCurrentGame.summary.isHomeWin ? 'win' : 'loss') },
                                            gvCurrentGame.summary.isHomeWin ? '● WIN' : '● LOSS'
                                        )
                                    )
                                ),
                                e('div', { className: 'gv-score-center' },
                                    e('div', { className: 'gv-score-display' },
                                        e('span', { className: 'gv-score-value home' }, gvCurrentGame.summary.homeScore || '-'),
                                        e('div', { className: 'gv-score-sep' }),
                                        e('span', { className: 'gv-score-value away' }, gvCurrentGame.summary.awayScore || '-')
                                    ),
                                    gvCurrentGame.summary.date && e('div', { style: { fontSize: '13px', color: 'var(--gv-text-muted)' }}, gvCurrentGame.summary.date)
                                ),
                                e('div', { className: 'gv-team-block away' },
                                    e('div', { className: 'gv-team-logo away' }, gvCurrentGame.summary.awayTeam.substring(0, 3).toUpperCase()),
                                    e('div', { className: 'gv-team-content' },
                                        e('h3', null, gvCurrentGame.summary.awayTeam),
                                        e('span', { className: 'gv-result-tag ' + (!gvCurrentGame.summary.isHomeWin ? 'win' : 'loss') },
                                            !gvCurrentGame.summary.isHomeWin ? '● WIN' : '● LOSS'
                                        )
                                    )
                                )
                            ),

                            // Tabs - All GAMEVIS tabs (including BPM, Half Stats, Connections)
                            e('div', { className: 'gv-tab-container' },
                                ['overview', 'players', 'bpm', 'shooting', 'halfstats', 'halfcompare', 'connections', 'winprob', 'flow', 'lineups'].map(tab =>
                                    e('button', {
                                        key: tab,
                                        className: 'gv-tab-btn' + (gvActiveTab === tab ? ' active' : ''),
                                        onClick: () => setGvActiveTab(tab)
                                    }, tab === 'overview' ? '📊 Overview' :
                                       tab === 'players' ? '👤 Players' :
                                       tab === 'bpm' ? '📈 BPM' :
                                       tab === 'shooting' ? '🎯 Shooting' :
                                       tab === 'halfstats' ? '📊 Half Stats' :
                                       tab === 'halfcompare' ? '📉 Half Compare' :
                                       tab === 'connections' ? '🔗 Connections' :
                                       tab === 'winprob' ? '🎲 Win Prob' :
                                       tab === 'flow' ? '📉 Game Flow' :
                                       '🔄 Lineups')
                                )
                            ),

                            // Tab Content - Overview (Summary)
                            gvActiveTab === 'overview' && gvCurrentGame.teamsData && (() => {
                                const teamKeys = Object.keys(gvCurrentGame.teamsData);
                                if (teamKeys.length < 2) return e('div', null, 'No team data available');
                                const homeTeam = teamKeys[0];
                                const awayTeam = teamKeys[1];
                                const homeTotals = gvCurrentGame.teamsData[homeTeam]?.teamTotals || {};
                                const awayTotals = gvCurrentGame.teamsData[awayTeam]?.teamTotals || {};

                                const FourFactorRow = ({ label, homeVal, awayVal, higherBetter = true, isPercent = true }) => {
                                    const homeWins = higherBetter ? homeVal > awayVal : homeVal < awayVal;
                                    return e('div', { className: 'gv-factor-block' },
                                        e('div', { className: 'gv-factor-values' },
                                            e('span', { className: 'gv-factor-val home' + (homeWins ? ' winner' : ''), style: homeWins ? { textShadow: '0 0 15px rgba(0, 212, 255, 0.5)' } : {} },
                                                isPercent ? (homeVal || 0).toFixed(1) + '%' : (homeVal || 0).toFixed(1)
                                            ),
                                            e('span', { className: 'gv-factor-val away' + (!homeWins ? ' winner' : ''), style: !homeWins ? { textShadow: '0 0 15px rgba(255, 0, 170, 0.5)' } : {} },
                                                isPercent ? (awayVal || 0).toFixed(1) + '%' : (awayVal || 0).toFixed(1)
                                            )
                                        ),
                                        e('div', { className: 'gv-factor-label' }, label)
                                    );
                                };

                                return e('div', null,
                                    // Four Factors Card
                                    e('div', { className: 'gv-stat-card full-width', style: { marginBottom: '20px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '📊 Four Factors'),
                                            e('div', { style: { display: 'flex', gap: '16px', fontSize: '12px' }},
                                                e('span', { style: { color: 'var(--gv-team-home)' }}, '● ' + homeTeam),
                                                e('span', { style: { color: 'var(--gv-team-away)' }}, '● ' + awayTeam)
                                            )
                                        ),
                                        e('div', { className: 'gv-factors-grid' },
                                            e(FourFactorRow, { label: 'eFG%', homeVal: homeTotals.efg, awayVal: awayTotals.efg }),
                                            e(FourFactorRow, { label: 'TOV%', homeVal: homeTotals.tovPct, awayVal: awayTotals.tovPct, higherBetter: false }),
                                            e(FourFactorRow, { label: 'OREB%', homeVal: homeTotals.orebPct, awayVal: awayTotals.orebPct }),
                                            e(FourFactorRow, { label: 'FT Rate', homeVal: homeTotals.ftRate, awayVal: awayTotals.ftRate }),
                                            e(FourFactorRow, { label: 'ORtg', homeVal: homeTotals.ortg, awayVal: awayTotals.ortg, isPercent: false })
                                        )
                                    ),
                                    // Key Metrics
                                    e('div', { className: 'gv-stats-grid' },
                                        e('div', { className: 'gv-stat-card' },
                                            e('div', { className: 'gv-card-header' },
                                                e('span', { className: 'gv-card-title' }, homeTeam + ' Stats')
                                            ),
                                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '12px' }},
                                                ['FGM/A', 'FG3M/A', 'FTM/A', 'REB', 'AST', 'TOV'].map((stat, i) => {
                                                    const vals = [
                                                        homeTotals.fgm + '/' + homeTotals.fga,
                                                        homeTotals.fg3m + '/' + homeTotals.fg3a,
                                                        homeTotals.ftm + '/' + homeTotals.fta,
                                                        (homeTotals.oreb + homeTotals.dreb) || homeTotals.treb || 0,
                                                        homeTotals.ast || 0,
                                                        homeTotals.tov || 0
                                                    ];
                                                    return e('div', { key: i, style: { textAlign: 'center', padding: '8px', background: 'rgba(0, 212, 255, 0.1)', borderRadius: '8px' }},
                                                        e('div', { style: { fontSize: '18px', fontWeight: '700', color: 'var(--gv-team-home)' }}, vals[i]),
                                                        e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', textTransform: 'uppercase' }}, stat)
                                                    );
                                                })
                                            )
                                        ),
                                        e('div', { className: 'gv-stat-card' },
                                            e('div', { className: 'gv-card-header' },
                                                e('span', { className: 'gv-card-title' }, awayTeam + ' Stats')
                                            ),
                                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '12px' }},
                                                ['FGM/A', 'FG3M/A', 'FTM/A', 'REB', 'AST', 'TOV'].map((stat, i) => {
                                                    const vals = [
                                                        awayTotals.fgm + '/' + awayTotals.fga,
                                                        awayTotals.fg3m + '/' + awayTotals.fg3a,
                                                        awayTotals.ftm + '/' + awayTotals.fta,
                                                        (awayTotals.oreb + awayTotals.dreb) || awayTotals.treb || 0,
                                                        awayTotals.ast || 0,
                                                        awayTotals.tov || 0
                                                    ];
                                                    return e('div', { key: i, style: { textAlign: 'center', padding: '8px', background: 'rgba(255, 0, 170, 0.1)', borderRadius: '8px' }},
                                                        e('div', { style: { fontSize: '18px', fontWeight: '700', color: 'var(--gv-team-away)' }}, vals[i]),
                                                        e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', textTransform: 'uppercase' }}, stat)
                                                    );
                                                })
                                            )
                                        )
                                    ),
                                    // Pace indicator
                                    e('div', { style: { textAlign: 'center', marginTop: '16px', padding: '12px', background: 'var(--gv-bg-elevated)', borderRadius: '8px' }},
                                        e('span', { style: { color: 'var(--gv-text-muted)', fontSize: '13px' }}, 'Pace: '),
                                        e('span', { style: { color: 'var(--gv-accent-gold)', fontWeight: '700', fontFamily: "'Space Mono', monospace" }}, (gvCurrentGame.pace || 70).toFixed(1)),
                                        e('span', { style: { color: 'var(--gv-text-muted)', fontSize: '11px', marginLeft: '8px' }}, 'possessions per team')
                                    )
                                );
                            })(),

                            // Tab Content - Players (FULL GAMEVIS-STYLE ADVANCED TABLE)
                            gvActiveTab === 'players' && gvCurrentGame.teamsData && (() => {
                                const teamKeys = Object.keys(gvCurrentGame.teamsData);
                                if (teamKeys.length < 2) return e('div', null, 'No player data available');

                                // Extract display name with suffix handling (matches GAMEVIS)
                                const extractDisplayName = (fullName) => {
                                    if (!fullName || fullName === 'Unknown') return 'UNKNOWN';
                                    const parts = fullName.trim().split(/\s+/);
                                    if (parts.length === 1) return parts[0].toUpperCase();

                                    const suffixes = ['Jr.', 'Jr', 'III', 'II', 'IV', 'V', 'VI', 'VII', 'VIII', 'Sr.', 'Sr'];
                                    const lastPart = parts[parts.length - 1];

                                    // Check if last part is a suffix
                                    const isSuffix = suffixes.some(s =>
                                        lastPart.toLowerCase() === s.toLowerCase() ||
                                        lastPart.toLowerCase().replace('.', '') === s.toLowerCase().replace('.', '')
                                    );

                                    if (isSuffix && parts.length >= 2) {
                                        // Return the part before the suffix + the suffix
                                        // e.g., "Ron Polite III" -> "POLITE III"
                                        const nameBeforeSuffix = parts[parts.length - 2];
                                        return nameBeforeSuffix.toUpperCase() + ' ' + lastPart;
                                    }

                                    // No suffix, just return last name
                                    return lastPart.toUpperCase();
                                };

                                const homeTeam = teamKeys[0];
                                const awayTeam = teamKeys[1];
                                const homeTotals = gvCurrentGame.teamsData[homeTeam]?.teamTotals || {};
                                const awayTotals = gvCurrentGame.teamsData[awayTeam]?.teamTotals || {};

                                const gameAvg = gvCurrentGame.gameAvg || {
                                    ortg: 100, drtg: 100, efg: 50, orebPct: 25, tovPct: 15
                                };

                                // Column group definitions
                                const columnGroups = [
                                    { id: 'scoring', label: 'Scoring', color: 'var(--gv-accent-emerald)', cols: ['fgm', 'ast', 'points', 'pointsAssisted', 'totalPointContribution', 'ppp'] },
                                    { id: 'usage', label: 'Usage', color: 'var(--gv-accent-coral)', cols: ['usg', 'astUsgRatio', 'minutes'] },
                                    { id: 'shotdist', label: 'Shot Dist', color: 'var(--gv-accent-purple)', cols: ['rimAtt', 'rimPct', 'midAtt', 'midPct', 'fg3a', 'threePct'] },
                                    { id: 'offcourt', label: 'Off On-Court', color: 'var(--gv-accent-cyan)', cols: ['onCourtORtg', 'onCourtEfg', 'onCourtOrebPct', 'onCourtTovPct'] },
                                    { id: 'defcourt', label: 'Def On-Court', color: 'var(--gv-accent-magenta)', cols: ['onCourtDRtg', 'defOnCourtEfg', 'defOnCourtOrebPct', 'defOnCourtTovPct', 'netRating'] },
                                    { id: 'individual', label: 'Individual', color: 'var(--gv-accent-gold)', cols: ['ts', 'astPct', 'tovPct', 'stlPct', 'blkPct', 'ftRate', 'orebPct'] }
                                ];

                                const collapsedGroups = gvCollapsedGroups;
                                const toggleGroup = (groupId) => {
                                    setGvCollapsedGroups(prev => ({ ...prev, [groupId]: !prev[groupId] }));
                                };

                                // Sorting
                                const sortKey = gvPlayerSortKey;
                                const sortAsc = gvPlayerSortAsc;
                                const handleSort = (key) => {
                                    if (sortKey === key) {
                                        setGvPlayerSortAsc(!sortAsc);
                                    } else {
                                        setGvPlayerSortKey(key);
                                        setGvPlayerSortAsc(false);
                                    }
                                };

                                // Get all players filtered and sorted
                                const getAllPlayers = () => {
                                    let players = [];
                                    if (gvPlayerTableTeam === 'all' || gvPlayerTableTeam === 'home') {
                                        players = players.concat((gvCurrentGame.teamsData[homeTeam]?.players || []).map(p => ({ ...p, teamName: homeTeam, isHome: true })));
                                    }
                                    if (gvPlayerTableTeam === 'all' || gvPlayerTableTeam === 'away') {
                                        players = players.concat((gvCurrentGame.teamsData[awayTeam]?.players || []).map(p => ({ ...p, teamName: awayTeam, isHome: false })));
                                    }
                                    players = players.filter(p => (p.minutes || 0) >= 5);

                                    // Compute derived values
                                    players = players.map(p => {
                                        const rimPct = p.rimAtt > 0 ? (p.rimMade / p.rimAtt * 100) : 0;
                                        const midAtt = p.midAtt || Math.max(0, (p.fg2a || 0) - (p.rimAtt || 0));
                                        const midMade = p.midMade || Math.max(0, (p.fg2m || 0) - (p.rimMade || 0));
                                        const midPct = midAtt > 0 ? (midMade / midAtt * 100) : 0;
                                        const threePct = p.fg3a > 0 ? (p.fg3m / p.fg3a * 100) : 0;
                                        return { ...p, rimPct, midAtt, midMade, midPct, threePct };
                                    });

                                    // Sort
                                    const sortMult = sortAsc ? 1 : -1;
                                    players.sort((a, b) => {
                                        const aVal = a[sortKey] || 0;
                                        const bVal = b[sortKey] || 0;
                                        return (bVal - aVal) * sortMult;
                                    });

                                    return players;
                                };

                                const players = getAllPlayers();

                                const formatDiff = (diff, inverted = false) => {
                                    const isGood = inverted ? diff < 0 : diff > 0;
                                    const colorClass = isGood ? 'var(--gv-positive)' : (Math.abs(diff) < 0.5 ? 'var(--gv-text-muted)' : 'var(--gv-negative)');
                                    const sign = diff >= 0 ? '+' : '';
                                    return { text: `${sign}${diff.toFixed(0)}`, color: colorClass };
                                };

                                // Scoring & Possession Battle Calculations
                                const POSS = 75;
                                const tovImpact = ((awayTotals.tov || 0) - (homeTotals.tov || 0)) * 1.1;
                                const orebImpact = ((homeTotals.oreb || 0) - (awayTotals.oreb || 0)) * 1.1;
                                const epaBattle = tovImpact + orebImpact;
                                const efgImpact = ((homeTotals.efg || 50) - (awayTotals.efg || 50)) * 1.77 * (POSS / 100);
                                const ftRateImpact = ((homeTotals.ftRate || 25) - (awayTotals.ftRate || 25)) * 0.25 * (POSS / 100);
                                const scoringBattle = efgImpact + ftRateImpact;
                                const totalProjectedMargin = epaBattle + scoringBattle;

                                // Sortable header component
                                const SortHeader = ({ label, sortKeyVal, title }) => {
                                    const isActive = sortKey === sortKeyVal;
                                    return e('th', {
                                        title,
                                        onClick: () => handleSort(sortKeyVal),
                                        style: { cursor: 'pointer', userSelect: 'none', position: 'relative' }
                                    },
                                        label,
                                        isActive && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')
                                    );
                                };

                                // Collapsed groups bar
                                const collapsedGroupsList = columnGroups.filter(g => collapsedGroups[g.id]);

                                return e('div', null,
                                    // Battle Points Summary
                                    e('div', { className: 'gv-stat-card full-width', style: { marginBottom: '16px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '⚔️ Battle Points Analysis'),
                                            e('span', { style: { fontSize: '12px', color: 'var(--gv-text-muted)' }}, 'Expected Points Added Model')
                                        ),
                                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '12px', padding: '16px' }},
                                            // EPA Battle (TO + OREB)
                                            e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '12px', textAlign: 'center' }},
                                                e('div', { style: { fontSize: '10px', color: 'var(--gv-accent-emerald)', fontWeight: '600', marginBottom: '4px' }}, '⚡ EPA Battle'),
                                                e('div', { style: { fontSize: '24px', fontWeight: '800', color: epaBattle >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    (epaBattle >= 0 ? '+' : '') + epaBattle.toFixed(1)
                                                ),
                                                e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)', marginTop: '4px' }},
                                                    `TO: ${tovImpact >= 0 ? '+' : ''}${tovImpact.toFixed(1)} | OREB: ${orebImpact >= 0 ? '+' : ''}${orebImpact.toFixed(1)}`
                                                )
                                            ),
                                            // Scoring Battle (eFG + FT Rate)
                                            e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '12px', textAlign: 'center' }},
                                                e('div', { style: { fontSize: '10px', color: 'var(--gv-accent-gold)', fontWeight: '600', marginBottom: '4px' }}, '🎯 Scoring Battle'),
                                                e('div', { style: { fontSize: '24px', fontWeight: '800', color: scoringBattle >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    (scoringBattle >= 0 ? '+' : '') + scoringBattle.toFixed(1)
                                                ),
                                                e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)', marginTop: '4px' }},
                                                    `eFG%: ${efgImpact >= 0 ? '+' : ''}${efgImpact.toFixed(1)} | FT: ${ftRateImpact >= 0 ? '+' : ''}${ftRateImpact.toFixed(1)}`
                                                )
                                            ),
                                            // Total Projected
                                            e('div', { style: { background: totalProjectedMargin >= 0 ? 'rgba(0, 212, 255, 0.15)' : 'rgba(255, 0, 170, 0.15)', borderRadius: '8px', padding: '12px', textAlign: 'center', border: `2px solid ${totalProjectedMargin >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)'}` }},
                                                e('div', { style: { fontSize: '10px', color: 'var(--gv-text-secondary)', fontWeight: '600', marginBottom: '4px' }}, '📊 Projected Margin'),
                                                e('div', { style: { fontSize: '28px', fontWeight: '800', color: totalProjectedMargin >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    (totalProjectedMargin >= 0 ? '+' : '') + totalProjectedMargin.toFixed(1)
                                                ),
                                                e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', marginTop: '4px' }},
                                                    totalProjectedMargin >= 0 ? homeTeam + ' favored' : awayTeam + ' favored'
                                                )
                                            ),
                                            // Actual Margin
                                            e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '12px', textAlign: 'center' }},
                                                e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', fontWeight: '600', marginBottom: '4px' }}, '✓ Actual Margin'),
                                                e('div', { style: { fontSize: '28px', fontWeight: '800', color: ((homeTotals.points || 0) - (awayTotals.points || 0)) >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    (((homeTotals.points || 0) - (awayTotals.points || 0)) >= 0 ? '+' : '') + ((homeTotals.points || 0) - (awayTotals.points || 0))
                                                ),
                                                e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', marginTop: '4px' }},
                                                    `${homeTotals.points || 0} - ${awayTotals.points || 0}`
                                                )
                                            )
                                        )
                                    ),

                                    // Four Factors Comparison (moved from Four Factors tab)
                                    e('div', { className: 'gv-stat-card full-width', style: { marginBottom: '16px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '⚖️ Four Factors Comparison')
                                        ),
                                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '12px', padding: '16px' }},
                                            // eFG%
                                            (() => {
                                                const homeVal = homeTotals.efg || 0;
                                                const awayVal = awayTotals.efg || 0;
                                                const homeWins = homeVal > awayVal;
                                                return e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '12px' }},
                                                    e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', textTransform: 'uppercase', marginBottom: '8px', textAlign: 'center' }}, '🎯 eFG%'),
                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' }},
                                                        e('div', { style: { textAlign: 'center', flex: 1 }},
                                                            e('div', { style: { fontSize: '18px', fontWeight: '700', color: homeWins ? 'var(--gv-team-home)' : 'var(--gv-text-muted)' }}, homeVal.toFixed(1) + '%'),
                                                            e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)' }}, homeTeam)
                                                        ),
                                                        e('div', { style: { fontSize: '12px', color: 'var(--gv-text-muted)', padding: '0 8px' }}, 'vs'),
                                                        e('div', { style: { textAlign: 'center', flex: 1 }},
                                                            e('div', { style: { fontSize: '18px', fontWeight: '700', color: !homeWins ? 'var(--gv-team-away)' : 'var(--gv-text-muted)' }}, awayVal.toFixed(1) + '%'),
                                                            e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)' }}, awayTeam)
                                                        )
                                                    )
                                                );
                                            })(),
                                            // TOV%
                                            (() => {
                                                const homeVal = homeTotals.tovPct || 0;
                                                const awayVal = awayTotals.tovPct || 0;
                                                const homeWins = homeVal < awayVal; // Lower is better
                                                return e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '12px' }},
                                                    e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', textTransform: 'uppercase', marginBottom: '8px', textAlign: 'center' }}, '🔄 TOV%'),
                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' }},
                                                        e('div', { style: { textAlign: 'center', flex: 1 }},
                                                            e('div', { style: { fontSize: '18px', fontWeight: '700', color: homeWins ? 'var(--gv-team-home)' : 'var(--gv-text-muted)' }}, homeVal.toFixed(1) + '%'),
                                                            e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)' }}, homeTeam)
                                                        ),
                                                        e('div', { style: { fontSize: '12px', color: 'var(--gv-text-muted)', padding: '0 8px' }}, 'vs'),
                                                        e('div', { style: { textAlign: 'center', flex: 1 }},
                                                            e('div', { style: { fontSize: '18px', fontWeight: '700', color: !homeWins ? 'var(--gv-team-away)' : 'var(--gv-text-muted)' }}, awayVal.toFixed(1) + '%'),
                                                            e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)' }}, awayTeam)
                                                        )
                                                    )
                                                );
                                            })(),
                                            // OREB%
                                            (() => {
                                                const homeVal = homeTotals.orebPct || 0;
                                                const awayVal = awayTotals.orebPct || 0;
                                                const homeWins = homeVal > awayVal;
                                                return e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '12px' }},
                                                    e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', textTransform: 'uppercase', marginBottom: '8px', textAlign: 'center' }}, '📥 OREB%'),
                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' }},
                                                        e('div', { style: { textAlign: 'center', flex: 1 }},
                                                            e('div', { style: { fontSize: '18px', fontWeight: '700', color: homeWins ? 'var(--gv-team-home)' : 'var(--gv-text-muted)' }}, homeVal.toFixed(1) + '%'),
                                                            e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)' }}, homeTeam)
                                                        ),
                                                        e('div', { style: { fontSize: '12px', color: 'var(--gv-text-muted)', padding: '0 8px' }}, 'vs'),
                                                        e('div', { style: { textAlign: 'center', flex: 1 }},
                                                            e('div', { style: { fontSize: '18px', fontWeight: '700', color: !homeWins ? 'var(--gv-team-away)' : 'var(--gv-text-muted)' }}, awayVal.toFixed(1) + '%'),
                                                            e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)' }}, awayTeam)
                                                        )
                                                    )
                                                );
                                            })(),
                                            // FT Rate
                                            (() => {
                                                const homeVal = homeTotals.ftRate || 0;
                                                const awayVal = awayTotals.ftRate || 0;
                                                const homeWins = homeVal > awayVal;
                                                return e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '12px' }},
                                                    e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', textTransform: 'uppercase', marginBottom: '8px', textAlign: 'center' }}, '🎁 FT Rate'),
                                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' }},
                                                        e('div', { style: { textAlign: 'center', flex: 1 }},
                                                            e('div', { style: { fontSize: '18px', fontWeight: '700', color: homeWins ? 'var(--gv-team-home)' : 'var(--gv-text-muted)' }}, homeVal.toFixed(1) + '%'),
                                                            e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)' }}, homeTeam)
                                                        ),
                                                        e('div', { style: { fontSize: '12px', color: 'var(--gv-text-muted)', padding: '0 8px' }}, 'vs'),
                                                        e('div', { style: { textAlign: 'center', flex: 1 }},
                                                            e('div', { style: { fontSize: '18px', fontWeight: '700', color: !homeWins ? 'var(--gv-team-away)' : 'var(--gv-text-muted)' }}, awayVal.toFixed(1) + '%'),
                                                            e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)' }}, awayTeam)
                                                        )
                                                    )
                                                );
                                            })()
                                        ),
                                        // Efficiency Ratings row
                                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '12px', padding: '0 16px 16px' }},
                                            [
                                                { label: 'Off Rtg', home: homeTotals.ortg, away: awayTotals.ortg, higherBetter: true },
                                                { label: 'Def Rtg', home: homeTotals.drtg, away: awayTotals.drtg, higherBetter: false },
                                                { label: 'Net Rtg', home: (homeTotals.ortg || 100) - (homeTotals.drtg || 100), away: (awayTotals.ortg || 100) - (awayTotals.drtg || 100), higherBetter: true },
                                                { label: 'Pace', home: gvCurrentGame.pace, away: gvCurrentGame.pace, higherBetter: null }
                                            ].map((stat, i) => {
                                                const homeWins = stat.higherBetter === null ? false : stat.higherBetter ? stat.home > stat.away : stat.home < stat.away;
                                                return e('div', { key: i, style: { textAlign: 'center', padding: '10px', background: 'var(--gv-bg-glass)', borderRadius: '8px' }},
                                                    e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)', textTransform: 'uppercase', marginBottom: '6px' }}, stat.label),
                                                    e('div', { style: { display: 'flex', justifyContent: 'center', gap: '8px' }},
                                                        e('span', { style: { fontSize: '14px', fontWeight: '700', color: homeWins ? 'var(--gv-team-home)' : 'var(--gv-text-secondary)' }}, (stat.home || 0).toFixed(1)),
                                                        stat.higherBetter !== null && e('span', { style: { color: 'var(--gv-text-muted)', fontSize: '12px' }}, '-'),
                                                        stat.higherBetter !== null && e('span', { style: { fontSize: '14px', fontWeight: '700', color: !homeWins ? 'var(--gv-team-away)' : 'var(--gv-text-secondary)' }}, (stat.away || 0).toFixed(1))
                                                    )
                                                );
                                            })
                                        )
                                    ),

                                    // Team Filter & Column Controls
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px', flexWrap: 'wrap', gap: '8px' }},
                                        // Team filter
                                        e('div', { style: { display: 'flex', gap: '6px' }},
                                            ['all', 'home', 'away'].map(f =>
                                                e('button', {
                                                    key: f, onClick: () => setGvPlayerTableTeam(f),
                                                    style: {
                                                        padding: '6px 12px', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '11px',
                                                        background: gvPlayerTableTeam === f ? (f === 'home' ? 'var(--gv-team-home)' : f === 'away' ? 'var(--gv-team-away)' : 'var(--gv-accent-cyan)') : 'var(--gv-bg-elevated)',
                                                        color: gvPlayerTableTeam === f ? '#000' : 'var(--gv-text-primary)'
                                                    }
                                                }, f === 'all' ? 'All Players' : f === 'home' ? homeTeam : awayTeam)
                                            )
                                        ),
                                        // Column group toggles
                                        e('div', { style: { display: 'flex', gap: '4px', flexWrap: 'wrap' }},
                                            columnGroups.map(g =>
                                                e('button', {
                                                    key: g.id, onClick: () => toggleGroup(g.id),
                                                    style: {
                                                        padding: '4px 8px', borderRadius: '4px', border: `1px solid ${g.color}`, cursor: 'pointer', fontSize: '9px',
                                                        background: collapsedGroups[g.id] ? 'transparent' : g.color,
                                                        color: collapsedGroups[g.id] ? g.color : '#000',
                                                        opacity: collapsedGroups[g.id] ? 0.6 : 1
                                                    }
                                                }, g.label)
                                            ),
                                            e('button', {
                                                onClick: () => setGvCollapsedGroups(collapsedGroupsList.length === 0 ? Object.fromEntries(columnGroups.map(g => [g.id, true])) : {}),
                                                style: { padding: '4px 8px', borderRadius: '4px', border: '1px solid var(--gv-border-subtle)', cursor: 'pointer', fontSize: '9px', background: 'var(--gv-bg-elevated)', color: 'var(--gv-text-primary)' }
                                            }, collapsedGroupsList.length === 0 ? 'Collapse All' : 'Expand All')
                                        )
                                    ),

                                    // Collapsed groups indicator
                                    collapsedGroupsList.length > 0 && e('div', { style: { display: 'flex', gap: '6px', marginBottom: '12px', flexWrap: 'wrap' }},
                                        e('span', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', alignSelf: 'center' }}, 'Hidden:'),
                                        collapsedGroupsList.map(g =>
                                            e('span', {
                                                key: g.id, onClick: () => toggleGroup(g.id),
                                                style: { padding: '3px 8px', borderRadius: '4px', fontSize: '9px', cursor: 'pointer', background: `${g.color}22`, border: `1px solid ${g.color}44`, color: g.color }
                                            }, g.label + ' ✕')
                                        )
                                    ),

                                    // Player Table with Section Borders & Colors
                                    e('div', { className: 'gv-stat-card full-width' },
                                        e('div', { className: 'gv-card-header', style: { display: 'flex', justifyContent: 'space-between' }},
                                            e('span', { className: 'gv-card-title' }, '👤 Player Stats'),
                                            e('span', { style: { fontSize: '11px', color: 'var(--gv-text-muted)' }}, players.length + ' players (≥5 min)')
                                        ),
                                        e('div', { style: { overflowX: 'auto' }},
                                            e('table', { className: 'gv-player-table', style: { fontSize: '10px' }},
                                                e('thead', null,
                                                    // Group headers row with enhanced styling
                                                    e('tr', { style: { background: 'rgba(255,255,255,0.03)' }},
                                                        e('th', { style: { textAlign: 'left', minWidth: '120px', borderRight: '1px solid var(--gv-border-subtle)' }}, ''),
                                                        !collapsedGroups.scoring && e('th', { colSpan: 6, style: { textAlign: 'center', color: 'var(--gv-accent-emerald)', borderBottom: '3px solid var(--gv-accent-emerald)', borderLeft: '2px solid var(--gv-accent-emerald)', background: 'rgba(0, 255, 136, 0.08)', cursor: 'pointer', fontWeight: '700' }, onClick: () => toggleGroup('scoring') }, '📊 SCORING ▼'),
                                                        !collapsedGroups.usage && e('th', { colSpan: 3, style: { textAlign: 'center', color: 'var(--gv-accent-coral)', borderBottom: '3px solid var(--gv-accent-coral)', borderLeft: '2px solid var(--gv-accent-coral)', background: 'rgba(255, 127, 80, 0.08)', cursor: 'pointer', fontWeight: '700' }, onClick: () => toggleGroup('usage') }, '⚡ USAGE ▼'),
                                                        !collapsedGroups.shotdist && e('th', { colSpan: 6, style: { textAlign: 'center', color: 'var(--gv-accent-purple)', borderBottom: '3px solid var(--gv-accent-purple)', borderLeft: '2px solid var(--gv-accent-purple)', background: 'rgba(167, 139, 250, 0.08)', cursor: 'pointer', fontWeight: '700' }, onClick: () => toggleGroup('shotdist') }, '🎯 SHOT DIST ▼'),
                                                        !collapsedGroups.offcourt && e('th', { colSpan: 4, style: { textAlign: 'center', color: 'var(--gv-accent-cyan)', borderBottom: '3px solid var(--gv-accent-cyan)', borderLeft: '2px solid var(--gv-accent-cyan)', background: 'rgba(0, 212, 255, 0.08)', cursor: 'pointer', fontWeight: '700' }, onClick: () => toggleGroup('offcourt') }, '🔥 OFF COURT ▼'),
                                                        !collapsedGroups.defcourt && e('th', { colSpan: 5, style: { textAlign: 'center', color: 'var(--gv-accent-magenta)', borderBottom: '3px solid var(--gv-accent-magenta)', borderLeft: '2px solid var(--gv-accent-magenta)', background: 'rgba(255, 0, 170, 0.08)', cursor: 'pointer', fontWeight: '700' }, onClick: () => toggleGroup('defcourt') }, '🛡️ DEF COURT ▼'),
                                                        !collapsedGroups.individual && e('th', { colSpan: 7, style: { textAlign: 'center', color: 'var(--gv-accent-gold)', borderBottom: '3px solid var(--gv-accent-gold)', borderLeft: '2px solid var(--gv-accent-gold)', background: 'rgba(255, 208, 0, 0.08)', cursor: 'pointer', fontWeight: '700' }, onClick: () => toggleGroup('individual') }, '👤 INDIVIDUAL ▼')
                                                    ),
                                                    // Column headers row with section border indicators
                                                    e('tr', { style: { background: 'var(--gv-bg-elevated)' }},
                                                        e(SortHeader, { label: 'Player', sortKeyVal: 'name', title: 'Player Name' }),
                                                        // Scoring - first col gets left border
                                                        !collapsedGroups.scoring && e('th', { onClick: () => handleSort('fgm'), style: { cursor: 'pointer', borderLeft: '2px solid var(--gv-accent-emerald)', background: 'rgba(0, 255, 136, 0.04)' }, title: 'Field Goals Made' }, 'FGM', sortKey === 'fgm' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.scoring && e('th', { onClick: () => handleSort('ast'), style: { cursor: 'pointer', background: 'rgba(0, 255, 136, 0.04)' }, title: 'Assists' }, 'AST', sortKey === 'ast' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.scoring && e('th', { onClick: () => handleSort('points'), style: { cursor: 'pointer', background: 'rgba(0, 255, 136, 0.04)' }, title: 'Points' }, 'PTS', sortKey === 'points' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.scoring && e('th', { onClick: () => handleSort('pointsAssisted'), style: { cursor: 'pointer', background: 'rgba(0, 255, 136, 0.04)' }, title: 'Points Assisted' }, '+AST', sortKey === 'pointsAssisted' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.scoring && e('th', { onClick: () => handleSort('totalPointContribution'), style: { cursor: 'pointer', background: 'rgba(0, 255, 136, 0.04)' }, title: 'Total Point Contribution' }, 'TPC', sortKey === 'totalPointContribution' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.scoring && e('th', { onClick: () => handleSort('ppp'), style: { cursor: 'pointer', background: 'rgba(0, 255, 136, 0.04)' }, title: 'Points Per Possession' }, 'PPP', sortKey === 'ppp' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        // Usage - first col gets left border
                                                        !collapsedGroups.usage && e('th', { onClick: () => handleSort('usg'), style: { cursor: 'pointer', borderLeft: '2px solid var(--gv-accent-coral)', background: 'rgba(255, 127, 80, 0.04)' }, title: 'Usage %' }, 'USG', sortKey === 'usg' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.usage && e('th', { onClick: () => handleSort('astUsgRatio'), style: { cursor: 'pointer', background: 'rgba(255, 127, 80, 0.04)' }, title: 'Assist/Usage Ratio' }, 'A/U', sortKey === 'astUsgRatio' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.usage && e('th', { onClick: () => handleSort('minutes'), style: { cursor: 'pointer', background: 'rgba(255, 127, 80, 0.04)' }, title: 'Minutes' }, 'MIN', sortKey === 'minutes' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        // Shot Distribution - first col gets left border
                                                        !collapsedGroups.shotdist && e('th', { onClick: () => handleSort('rimAtt'), style: { cursor: 'pointer', borderLeft: '2px solid var(--gv-accent-purple)', background: 'rgba(167, 139, 250, 0.04)' }, title: 'Rim Attempts' }, 'RIM', sortKey === 'rimAtt' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.shotdist && e('th', { onClick: () => handleSort('rimPct'), style: { cursor: 'pointer', background: 'rgba(167, 139, 250, 0.04)' }, title: 'Rim FG%' }, 'RIM%', sortKey === 'rimPct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.shotdist && e('th', { onClick: () => handleSort('midAtt'), style: { cursor: 'pointer', background: 'rgba(167, 139, 250, 0.04)' }, title: 'Mid-Range Attempts' }, 'MID', sortKey === 'midAtt' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.shotdist && e('th', { onClick: () => handleSort('midPct'), style: { cursor: 'pointer', background: 'rgba(167, 139, 250, 0.04)' }, title: 'Mid-Range FG%' }, 'MID%', sortKey === 'midPct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.shotdist && e('th', { onClick: () => handleSort('fg3a'), style: { cursor: 'pointer', background: 'rgba(167, 139, 250, 0.04)' }, title: '3-Point Attempts' }, '3PT', sortKey === 'fg3a' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.shotdist && e('th', { onClick: () => handleSort('threePct'), style: { cursor: 'pointer', background: 'rgba(167, 139, 250, 0.04)' }, title: '3-Point FG%' }, '3PT%', sortKey === 'threePct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        // Off On-Court - first col gets left border
                                                        !collapsedGroups.offcourt && e('th', { onClick: () => handleSort('onCourtORtg'), style: { cursor: 'pointer', borderLeft: '2px solid var(--gv-accent-cyan)', background: 'rgba(0, 212, 255, 0.04)' }, title: 'On-Court Offensive Rating' }, 'ORtg', sortKey === 'onCourtORtg' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.offcourt && e('th', { onClick: () => handleSort('onCourtEfg'), style: { cursor: 'pointer', background: 'rgba(0, 212, 255, 0.04)' }, title: 'On-Court eFG%' }, 'eFG', sortKey === 'onCourtEfg' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.offcourt && e('th', { onClick: () => handleSort('onCourtOrebPct'), style: { cursor: 'pointer', background: 'rgba(0, 212, 255, 0.04)' }, title: 'On-Court OREB%' }, 'ORB%', sortKey === 'onCourtOrebPct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.offcourt && e('th', { onClick: () => handleSort('onCourtTovPct'), style: { cursor: 'pointer', background: 'rgba(0, 212, 255, 0.04)' }, title: 'On-Court TOV%' }, 'TOV%', sortKey === 'onCourtTovPct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        // Def On-Court - first col gets left border
                                                        !collapsedGroups.defcourt && e('th', { onClick: () => handleSort('onCourtDRtg'), style: { cursor: 'pointer', borderLeft: '2px solid var(--gv-accent-magenta)', background: 'rgba(255, 0, 170, 0.04)' }, title: 'On-Court Defensive Rating' }, 'DRtg', sortKey === 'onCourtDRtg' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.defcourt && e('th', { onClick: () => handleSort('defOnCourtEfg'), style: { cursor: 'pointer', background: 'rgba(255, 0, 170, 0.04)' }, title: 'Opponent eFG%' }, 'Opp eFG', sortKey === 'defOnCourtEfg' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.defcourt && e('th', { onClick: () => handleSort('defOnCourtOrebPct'), style: { cursor: 'pointer', background: 'rgba(255, 0, 170, 0.04)' }, title: 'Opponent OREB%' }, 'Opp ORB', sortKey === 'defOnCourtOrebPct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.defcourt && e('th', { onClick: () => handleSort('defOnCourtTovPct'), style: { cursor: 'pointer', background: 'rgba(255, 0, 170, 0.04)' }, title: 'Turnovers Forced' }, 'TOV Frc', sortKey === 'defOnCourtTovPct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.defcourt && e('th', { onClick: () => handleSort('netRating'), style: { cursor: 'pointer', background: 'rgba(255, 0, 170, 0.04)' }, title: 'Net Rating' }, 'Net', sortKey === 'netRating' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        // Individual - first col gets left border
                                                        !collapsedGroups.individual && e('th', { onClick: () => handleSort('ts'), style: { cursor: 'pointer', borderLeft: '2px solid var(--gv-accent-gold)', background: 'rgba(255, 208, 0, 0.04)' }, title: 'True Shooting %' }, 'TS%', sortKey === 'ts' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.individual && e('th', { onClick: () => handleSort('astPct'), style: { cursor: 'pointer', background: 'rgba(255, 208, 0, 0.04)' }, title: 'Assist %' }, 'AST%', sortKey === 'astPct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.individual && e('th', { onClick: () => handleSort('tovPct'), style: { cursor: 'pointer', background: 'rgba(255, 208, 0, 0.04)' }, title: 'Turnover %' }, 'TO%', sortKey === 'tovPct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.individual && e('th', { onClick: () => handleSort('stlPct'), style: { cursor: 'pointer', background: 'rgba(255, 208, 0, 0.04)' }, title: 'Steal %' }, 'STL%', sortKey === 'stlPct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.individual && e('th', { onClick: () => handleSort('blkPct'), style: { cursor: 'pointer', background: 'rgba(255, 208, 0, 0.04)' }, title: 'Block %' }, 'BLK%', sortKey === 'blkPct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.individual && e('th', { onClick: () => handleSort('ftRate'), style: { cursor: 'pointer', background: 'rgba(255, 208, 0, 0.04)' }, title: 'Free Throw Rate' }, 'FTR', sortKey === 'ftRate' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼')),
                                                        !collapsedGroups.individual && e('th', { onClick: () => handleSort('orebPct'), style: { cursor: 'pointer', background: 'rgba(255, 208, 0, 0.04)' }, title: 'Offensive Rebound %' }, 'ORB%', sortKey === 'orebPct' && e('span', { style: { marginLeft: '4px', fontSize: '8px' }}, sortAsc ? '▲' : '▼'))
                                                    )
                                                ),
                                                e('tbody', null,
                                                    players.map((p, i) => {
                                                        const teamColor = p.isHome ? 'var(--gv-team-home)' : 'var(--gv-team-away)';
                                                        const offORtg = formatDiff((p.onCourtORtg || 100) - gameAvg.ortg);
                                                        const offEfg = formatDiff((p.onCourtEfg || 50) - gameAvg.efg);
                                                        const offOreb = formatDiff((p.onCourtOrebPct || 25) - gameAvg.orebPct);
                                                        const offTov = formatDiff((p.onCourtTovPct || 15) - gameAvg.tovPct, true);
                                                        const defDRtg = formatDiff((p.onCourtDRtg || 100) - gameAvg.drtg, true);
                                                        const defEfg = formatDiff((p.defOnCourtEfg || 50) - gameAvg.efg, true);
                                                        const defOreb = formatDiff((p.defOnCourtOrebPct || 25) - gameAvg.orebPct, true);
                                                        const defTov = formatDiff((p.defOnCourtTovPct || 15) - gameAvg.tovPct);
                                                        const netRating = p.netRating || 0;
                                                        const netColor = netRating >= 0 ? 'var(--gv-positive)' : 'var(--gv-negative)';

                                                        return e('tr', { key: i, style: p.isStarter ? { background: p.isHome ? 'rgba(0, 212, 255, 0.06)' : 'rgba(255, 0, 170, 0.06)' } : {} },
                                                            e('td', { style: { textAlign: 'left', position: 'sticky', left: 0, background: 'var(--gv-bg-card)', zIndex: 1, fontWeight: '500', whiteSpace: 'nowrap', borderRight: '1px solid var(--gv-border-subtle)' }},
                                                                e('span', { style: { width: '8px', height: '8px', borderRadius: '50%', background: teamColor, display: 'inline-block', marginRight: '6px' }}),
                                                                e('span', { style: { color: teamColor, marginRight: '4px', fontSize: '9px' }}, p.number || '-'),
                                                                extractDisplayName(p.name),
                                                                p.isStarter && e('span', { style: { fontSize: '8px', color: 'var(--gv-accent-gold)', marginLeft: '3px' }}, '★')
                                                            ),
                                                            // Scoring (first cell gets left border + section tint)
                                                            !collapsedGroups.scoring && e('td', { style: { borderLeft: '2px solid var(--gv-accent-emerald)', background: 'rgba(0, 255, 136, 0.03)' }}, p.fgm || 0),
                                                            !collapsedGroups.scoring && e('td', { style: { background: 'rgba(0, 255, 136, 0.03)' }}, p.ast || 0),
                                                            !collapsedGroups.scoring && e('td', { style: { fontWeight: '700', color: teamColor, background: 'rgba(0, 255, 136, 0.03)' }}, p.points || 0),
                                                            !collapsedGroups.scoring && e('td', { style: { color: 'var(--gv-accent-purple)', background: 'rgba(0, 255, 136, 0.03)' }}, (p.pointsAssisted || 0) > 0 ? '+' + p.pointsAssisted : '0'),
                                                            !collapsedGroups.scoring && e('td', { style: { fontWeight: '600', background: 'rgba(0, 255, 136, 0.03)' }}, p.totalPointContribution || p.points || 0),
                                                            !collapsedGroups.scoring && e('td', { style: { fontFamily: "'Space Mono', monospace", background: 'rgba(0, 255, 136, 0.03)' }}, (p.ppp || 0).toFixed(2)),
                                                            // Usage (first cell gets left border + section tint)
                                                            !collapsedGroups.usage && e('td', { style: { borderLeft: '2px solid var(--gv-accent-coral)', background: 'rgba(255, 127, 80, 0.03)' }}, (p.usg || 0).toFixed(0)),
                                                            !collapsedGroups.usage && e('td', { style: { background: 'rgba(255, 127, 80, 0.03)' }}, (p.astUsgRatio || 0).toFixed(1)),
                                                            !collapsedGroups.usage && e('td', { style: { fontWeight: '600', background: 'rgba(255, 127, 80, 0.03)' }}, Math.round(p.minutes || 0)),
                                                            // Shot Distribution (first cell gets left border + section tint)
                                                            !collapsedGroups.shotdist && e('td', { style: { borderLeft: '2px solid var(--gv-accent-purple)', background: 'rgba(167, 139, 250, 0.03)' }}, p.rimAtt || 0),
                                                            !collapsedGroups.shotdist && e('td', { style: { color: p.rimPct >= 60 ? 'var(--gv-positive)' : p.rimPct >= 45 ? 'var(--gv-text-primary)' : 'var(--gv-text-muted)', background: 'rgba(167, 139, 250, 0.03)' }}, p.rimPct.toFixed(0) + '%'),
                                                            !collapsedGroups.shotdist && e('td', { style: { background: 'rgba(167, 139, 250, 0.03)' }}, p.midAtt || 0),
                                                            !collapsedGroups.shotdist && e('td', { style: { color: p.midPct >= 45 ? 'var(--gv-positive)' : p.midPct >= 35 ? 'var(--gv-text-primary)' : 'var(--gv-text-muted)', background: 'rgba(167, 139, 250, 0.03)' }}, p.midPct.toFixed(0) + '%'),
                                                            !collapsedGroups.shotdist && e('td', { style: { background: 'rgba(167, 139, 250, 0.03)' }}, p.fg3a || 0),
                                                            !collapsedGroups.shotdist && e('td', { style: { color: p.threePct >= 40 ? 'var(--gv-positive)' : p.threePct >= 33 ? 'var(--gv-text-primary)' : 'var(--gv-text-muted)', background: 'rgba(167, 139, 250, 0.03)' }}, p.threePct.toFixed(0) + '%'),
                                                            // Off On-Court (first cell gets left border + section tint)
                                                            !collapsedGroups.offcourt && e('td', { style: { color: offORtg.color, fontWeight: '600', borderLeft: '2px solid var(--gv-accent-cyan)', background: 'rgba(0, 212, 255, 0.03)' }}, offORtg.text),
                                                            !collapsedGroups.offcourt && e('td', { style: { color: offEfg.color, background: 'rgba(0, 212, 255, 0.03)' }}, offEfg.text),
                                                            !collapsedGroups.offcourt && e('td', { style: { color: offOreb.color, background: 'rgba(0, 212, 255, 0.03)' }}, offOreb.text),
                                                            !collapsedGroups.offcourt && e('td', { style: { color: offTov.color, background: 'rgba(0, 212, 255, 0.03)' }}, offTov.text),
                                                            // Def On-Court (first cell gets left border + section tint)
                                                            !collapsedGroups.defcourt && e('td', { style: { color: defDRtg.color, fontWeight: '600', borderLeft: '2px solid var(--gv-accent-magenta)', background: 'rgba(255, 0, 170, 0.03)' }}, defDRtg.text),
                                                            !collapsedGroups.defcourt && e('td', { style: { color: defEfg.color, background: 'rgba(255, 0, 170, 0.03)' }}, defEfg.text),
                                                            !collapsedGroups.defcourt && e('td', { style: { color: defOreb.color, background: 'rgba(255, 0, 170, 0.03)' }}, defOreb.text),
                                                            !collapsedGroups.defcourt && e('td', { style: { color: defTov.color, background: 'rgba(255, 0, 170, 0.03)' }}, defTov.text),
                                                            !collapsedGroups.defcourt && e('td', { style: { fontWeight: '700', color: netColor, padding: '3px 6px', borderRadius: '4px', background: netRating >= 0 ? 'rgba(0, 255, 136, 0.15)' : 'rgba(255, 107, 107, 0.15)' }},
                                                                (netRating >= 0 ? '+' : '') + netRating.toFixed(0)
                                                            ),
                                                            // Individual (first cell gets left border + section tint)
                                                            !collapsedGroups.individual && e('td', { style: { color: (p.ts || 0) >= 55 ? 'var(--gv-positive)' : 'var(--gv-text-primary)', borderLeft: '2px solid var(--gv-accent-gold)', background: 'rgba(255, 208, 0, 0.03)' }}, (p.ts || 0).toFixed(0)),
                                                            !collapsedGroups.individual && e('td', { style: { background: 'rgba(255, 208, 0, 0.03)' }}, (p.astPct || 0).toFixed(0)),
                                                            !collapsedGroups.individual && e('td', { style: { color: (p.tovPct || 0) > 20 ? 'var(--gv-negative)' : 'var(--gv-text-primary)', background: 'rgba(255, 208, 0, 0.03)' }}, (p.tovPct || 0).toFixed(0)),
                                                            !collapsedGroups.individual && e('td', { style: { background: 'rgba(255, 208, 0, 0.03)' }}, (p.stlPct || 0).toFixed(1)),
                                                            !collapsedGroups.individual && e('td', { style: { background: 'rgba(255, 208, 0, 0.03)' }}, (p.blkPct || 0).toFixed(1)),
                                                            !collapsedGroups.individual && e('td', { style: { background: 'rgba(255, 208, 0, 0.03)' }}, (p.ftRate || 0).toFixed(0)),
                                                            !collapsedGroups.individual && e('td', { style: { background: 'rgba(255, 208, 0, 0.03)' }}, (p.orebPct || 0).toFixed(1))
                                                        );
                                                    })
                                                )
                                            )
                                        ),
                                        // Legend
                                        e('div', { style: { padding: '12px 16px', fontSize: '10px', color: 'var(--gv-text-muted)', borderTop: '1px solid var(--gv-border-subtle)' }},
                                            'Click column headers to sort. Click group headers to collapse. On-Court metrics show +/- vs game average. ',
                                            e('span', { style: { color: 'var(--gv-positive)' }}, 'Green'),
                                            ' = positive impact, ',
                                            e('span', { style: { color: 'var(--gv-negative)' }}, 'Red'),
                                            ' = negative. TPC = Points + Assisted Points.'
                                        )
                                    )
                                );
                            })(),

                            // Tab Content - Win Probability
                            gvActiveTab === 'winprob' && gvCurrentGame.teamsData && (() => {
                                const teamKeys = Object.keys(gvCurrentGame.teamsData);
                                if (teamKeys.length < 2) return e('div', null, 'No team data');
                                const homeTeam = teamKeys[0];
                                const awayTeam = teamKeys[1];
                                const homeTotals = gvCurrentGame.teamsData[homeTeam]?.teamTotals || {};
                                const awayTotals = gvCurrentGame.teamsData[awayTeam]?.teamTotals || {};

                                // Calculate Win Probability using Four Factors
                                const calcWinProb = () => {
                                    const factors = {
                                        efg: { home: homeTotals.efg || 50, away: awayTotals.efg || 50, weight: 40 },
                                        tov: { home: homeTotals.tovPct || 15, away: awayTotals.tovPct || 15, weight: 25 },
                                        oreb: { home: homeTotals.orebPct || 25, away: awayTotals.orebPct || 25, weight: 20 },
                                        ft: { home: homeTotals.ftRate || 25, away: awayTotals.ftRate || 25, weight: 15 }
                                    };

                                    // Calculate PPP estimates
                                    const homePPP = (factors.efg.home / 100) * 2 * (1 - factors.tov.home / 100) * (1 + factors.oreb.home / 100 * 0.3) + factors.ft.home / 100 * 0.25;
                                    const awayPPP = (factors.efg.away / 100) * 2 * (1 - factors.tov.away / 100) * (1 + factors.oreb.away / 100 * 0.3) + factors.ft.away / 100 * 0.25;

                                    // Expected margin per 70 possessions
                                    const pppDiff = homePPP - awayPPP;
                                    const expectedMargin = pppDiff * 70;

                                    // Convert to win probability using logistic function
                                    const zScore = expectedMargin / 11; // std dev ~11 pts
                                    const homeWinProb = 100 / (1 + Math.exp(-zScore * 0.7));

                                    return {
                                        homeWinProb,
                                        awayWinProb: 100 - homeWinProb,
                                        homePPP,
                                        awayPPP,
                                        expectedMargin,
                                        factors
                                    };
                                };

                                const wp = calcWinProb();
                                const probDiff = Math.abs(wp.homeWinProb - 50);
                                const confidenceLevel = probDiff > 40 ? 'Very High' : probDiff > 25 ? 'High' : probDiff > 12 ? 'Moderate' : 'Close';
                                const confidenceColor = probDiff > 40 ? 'var(--gv-positive)' : probDiff > 25 ? 'var(--gv-accent-emerald)' : probDiff > 12 ? 'var(--gv-accent-gold)' : 'var(--gv-accent-coral)';

                                return e('div', null,
                                    e('div', { className: 'gv-stat-card full-width', style: { marginBottom: '20px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '🎯 Win Probability'),
                                            e('span', { style: { color: confidenceColor, fontSize: '12px', fontWeight: '600' }}, 'Confidence: ' + confidenceLevel)
                                        ),
                                        // Win Prob Bar
                                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '20px', marginBottom: '20px' }},
                                            e('div', { style: { flex: 1, textAlign: 'center' }},
                                                e('div', { style: { fontSize: '14px', color: 'var(--gv-team-home)', marginBottom: '4px' }}, homeTeam),
                                                e('div', { style: { fontSize: '36px', fontWeight: '800', color: wp.homeWinProb > 50 ? 'var(--gv-team-home)' : 'var(--gv-text-muted)' }}, wp.homeWinProb.toFixed(1) + '%')
                                            ),
                                            e('div', { style: { flex: 2 }},
                                                e('div', { style: { display: 'flex', height: '24px', borderRadius: '12px', overflow: 'hidden', background: 'var(--gv-bg-base)' }},
                                                    e('div', { style: { width: wp.homeWinProb + '%', background: 'linear-gradient(90deg, var(--gv-team-home), rgba(0, 212, 255, 0.6))' }}),
                                                    e('div', { style: { width: wp.awayWinProb + '%', background: 'linear-gradient(90deg, rgba(255, 0, 170, 0.6), var(--gv-team-away))' }})
                                                ),
                                                e('div', { style: { textAlign: 'center', marginTop: '8px', fontSize: '13px' }},
                                                    e('span', { style: { color: 'var(--gv-text-muted)' }}, 'Expected Margin: '),
                                                    e('span', { style: { color: wp.expectedMargin >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)', fontWeight: '700' }},
                                                        (wp.expectedMargin >= 0 ? '+' : '') + wp.expectedMargin.toFixed(1) + ' pts'
                                                    )
                                                )
                                            ),
                                            e('div', { style: { flex: 1, textAlign: 'center' }},
                                                e('div', { style: { fontSize: '14px', color: 'var(--gv-team-away)', marginBottom: '4px' }}, awayTeam),
                                                e('div', { style: { fontSize: '36px', fontWeight: '800', color: wp.awayWinProb > 50 ? 'var(--gv-team-away)' : 'var(--gv-text-muted)' }}, wp.awayWinProb.toFixed(1) + '%')
                                            )
                                        ),
                                        // PPP Display
                                        e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', padding: '16px', background: 'var(--gv-bg-glass)', borderRadius: '12px' }},
                                            e('div', { style: { textAlign: 'center' }},
                                                e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', textTransform: 'uppercase', marginBottom: '4px' }}, 'Home PPP'),
                                                e('div', { style: { fontSize: '24px', fontWeight: '700', color: 'var(--gv-team-home)', fontFamily: "'Space Mono', monospace" }}, wp.homePPP.toFixed(3))
                                            ),
                                            e('div', { style: { textAlign: 'center' }},
                                                e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', textTransform: 'uppercase', marginBottom: '4px' }}, 'Away PPP'),
                                                e('div', { style: { fontSize: '24px', fontWeight: '700', color: 'var(--gv-team-away)', fontFamily: "'Space Mono', monospace" }}, wp.awayPPP.toFixed(3))
                                            )
                                        )
                                    ),
                                    // Factor Breakdown
                                    e('div', { className: 'gv-stat-card full-width' },
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '⚖️ Factor Breakdown')
                                        ),
                                        e('div', { className: 'gv-factors-grid' },
                                            Object.entries(wp.factors).map(([key, f]) => {
                                                const labels = { efg: 'eFG%', tov: 'TOV%', oreb: 'OREB%', ft: 'FT Rate' };
                                                const higherBetter = key !== 'tov';
                                                const homeWins = higherBetter ? f.home > f.away : f.home < f.away;
                                                return e('div', { key, className: 'gv-factor-block', style: { background: homeWins ? 'rgba(0, 212, 255, 0.1)' : 'rgba(255, 0, 170, 0.1)' }},
                                                    e('div', { className: 'gv-factor-values' },
                                                        e('span', { className: 'gv-factor-val home', style: homeWins ? { textShadow: '0 0 10px var(--gv-team-home)' } : {} }, f.home.toFixed(1)),
                                                        e('span', { className: 'gv-factor-val away', style: !homeWins ? { textShadow: '0 0 10px var(--gv-team-away)' } : {} }, f.away.toFixed(1))
                                                    ),
                                                    e('div', { className: 'gv-factor-label' }, labels[key]),
                                                    e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)', marginTop: '4px' }}, f.weight + '% weight')
                                                );
                                            })
                                        )
                                    )
                                );
                            })(),

                            // Tab Content - Shooting
                            gvActiveTab === 'shooting' && gvCurrentGame.teamsData && (() => {
                                const teamKeys = Object.keys(gvCurrentGame.teamsData);
                                if (teamKeys.length < 2) return e('div', null, 'No data');

                                const ShootingCard = ({ teamName, totals, isHome }) => {
                                    const teamColor = isHome ? 'var(--gv-team-home)' : 'var(--gv-team-away)';
                                    const fg2m = totals.fg2m || (totals.fgm - totals.fg3m) || 0;
                                    const fg2a = totals.fg2a || (totals.fga - totals.fg3a) || 0;
                                    const fg2Pct = fg2a > 0 ? (fg2m / fg2a * 100) : 0;
                                    const fg3Pct = totals.fg3a > 0 ? (totals.fg3m / totals.fg3a * 100) : 0;
                                    const fgPct = totals.fga > 0 ? (totals.fgm / totals.fga * 100) : 0;
                                    const ftPct = totals.fta > 0 ? (totals.ftm / totals.fta * 100) : 0;

                                    return e('div', { className: 'gv-stat-card' },
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title', style: { color: teamColor }}, teamName)
                                        ),
                                        e('div', { style: { padding: '16px' }},
                                            // Shot breakdown
                                            [
                                                { label: 'Overall FG', made: totals.fgm, att: totals.fga, pct: fgPct },
                                                { label: '2-Pointers', made: fg2m, att: fg2a, pct: fg2Pct },
                                                { label: '3-Pointers', made: totals.fg3m, att: totals.fg3a, pct: fg3Pct },
                                                { label: 'Free Throws', made: totals.ftm, att: totals.fta, pct: ftPct }
                                            ].map((shot, i) => e('div', { key: i, style: { marginBottom: '16px' }},
                                                e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }},
                                                    e('span', { style: { fontSize: '12px', color: 'var(--gv-text-secondary)' }}, shot.label),
                                                    e('span', { style: { fontSize: '12px', fontWeight: '600' }}, shot.made + '/' + shot.att + ' (' + shot.pct.toFixed(1) + '%)')
                                                ),
                                                e('div', { style: { height: '8px', background: 'var(--gv-bg-base)', borderRadius: '4px', overflow: 'hidden' }},
                                                    e('div', { style: { height: '100%', width: shot.pct + '%', background: teamColor, transition: 'width 0.3s' }})
                                                )
                                            )),
                                            // Points breakdown
                                            e('div', { style: { marginTop: '20px', paddingTop: '16px', borderTop: '1px solid var(--gv-border-subtle)' }},
                                                e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)', textTransform: 'uppercase', marginBottom: '12px' }}, 'Points Distribution'),
                                                e('div', { style: { display: 'flex', justifyContent: 'space-around' }},
                                                    e('div', { style: { textAlign: 'center' }},
                                                        e('div', { style: { fontSize: '20px', fontWeight: '700', color: teamColor }}, fg2m * 2),
                                                        e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, '2PT PTS')
                                                    ),
                                                    e('div', { style: { textAlign: 'center' }},
                                                        e('div', { style: { fontSize: '20px', fontWeight: '700', color: teamColor }}, totals.fg3m * 3),
                                                        e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, '3PT PTS')
                                                    ),
                                                    e('div', { style: { textAlign: 'center' }},
                                                        e('div', { style: { fontSize: '20px', fontWeight: '700', color: teamColor }}, totals.ftm),
                                                        e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, 'FT PTS')
                                                    )
                                                )
                                            )
                                        )
                                    );
                                };

                                return e('div', { className: 'gv-stats-grid' },
                                    e(ShootingCard, { teamName: teamKeys[0], totals: gvCurrentGame.teamsData[teamKeys[0]]?.teamTotals || {}, isHome: true }),
                                    e(ShootingCard, { teamName: teamKeys[1], totals: gvCurrentGame.teamsData[teamKeys[1]]?.teamTotals || {}, isHome: false })
                                );
                            })(),

                            // Tab Content - BPM (Box Plus/Minus)
                            gvActiveTab === 'bpm' && gvCurrentGame.teamsData && (() => {
                                const teamKeys = Object.keys(gvCurrentGame.teamsData);
                                if (teamKeys.length < 2) return e('div', null, 'No data');
                                const homeTeam = teamKeys[0];
                                const awayTeam = teamKeys[1];
                                const homePlayers = gvCurrentGame.teamsData[homeTeam]?.players || [];
                                const awayPlayers = gvCurrentGame.teamsData[awayTeam]?.players || [];
                                const homeTotals = gvCurrentGame.teamsData[homeTeam]?.teamTotals || {};
                                const awayTotals = gvCurrentGame.teamsData[awayTeam]?.teamTotals || {};
                                const pace = gvCurrentGame.pace || 70;

                                // Calculate BPM for a player
                                const calcBPM = (p, teamTotals, oppTotals, isHome) => {
                                    if (!p.minutes || p.minutes < 1) return { obpm: 0, dbpm: 0, bpm: 0, tpa: 0 };

                                    const mins = p.minutes;
                                    const per36 = 36 / mins;

                                    // Per 36 stats
                                    const pts36 = (p.points || 0) * per36;
                                    const ast36 = (p.ast || 0) * per36;
                                    const orb36 = (p.oreb || 0) * per36;
                                    const drb36 = (p.dreb || 0) * per36;
                                    const stl36 = (p.stl || 0) * per36;
                                    const blk36 = (p.blk || 0) * per36;
                                    const tov36 = (p.tov || 0) * per36;
                                    const fga36 = (p.fga || 0) * per36;
                                    const fta36 = (p.fta || 0) * per36;
                                    const fg3m36 = (p.fg3m || 0) * per36;
                                    const pf36 = (p.pf || 0) * per36;

                                    // Position estimate (1-5 scale based on rebounding ratio)
                                    const totalReb = (p.oreb || 0) + (p.dreb || 0);
                                    const pos = totalReb > 0 ? Math.min(5, Math.max(1, 1 + ((p.dreb || 0) / totalReb) * 4 + (blk36 > 3 ? 1 : 0))) : 2.5;

                                    // Simplified BPM coefficients
                                    const ptsAdj = pts36 - 0.92 * fga36 - 0.44 * fta36 + 0.1 * fg3m36;
                                    const obpm = 0.86 * ptsAdj + 0.58 * ast36 + 0.4 * orb36 - 0.96 * tov36 - 0.2 * pf36;
                                    const dbpm = 0.5 * stl36 + 0.7 * blk36 + 0.15 * drb36 - 0.2 * pf36;
                                    const rawBpm = obpm + dbpm;

                                    // Team adjustment
                                    const teamNetRtg = ((teamTotals.ortg || 100) - (teamTotals.drtg || 100));
                                    const teamAdj = teamNetRtg * 0.1 * (mins / 40);

                                    const bpm = (rawBpm / 5) + teamAdj; // Scale down and add team adjustment
                                    const poss = mins * pace / 40;
                                    const tpa = bpm * poss / 100;

                                    return { obpm: obpm / 5, dbpm: dbpm / 5, bpm, tpa, pos };
                                };

                                // Calculate for all players
                                const homeBPM = homePlayers
                                    .filter(p => p.minutes > 0)
                                    .map(p => ({ ...p, ...calcBPM(p, homeTotals, awayTotals, true) }))
                                    .sort((a, b) => b.bpm - a.bpm);

                                const awayBPM = awayPlayers
                                    .filter(p => p.minutes > 0)
                                    .map(p => ({ ...p, ...calcBPM(p, awayTotals, homeTotals, false) }))
                                    .sort((a, b) => b.bpm - a.bpm);

                                const homeAvgBPM = homeBPM.length > 0 ? homeBPM.reduce((sum, p) => sum + p.bpm * (p.minutes || 0), 0) / homeBPM.reduce((sum, p) => sum + (p.minutes || 0), 0) : 0;
                                const awayAvgBPM = awayBPM.length > 0 ? awayBPM.reduce((sum, p) => sum + p.bpm * (p.minutes || 0), 0) / awayBPM.reduce((sum, p) => sum + (p.minutes || 0), 0) : 0;
                                const homeTPA = homeBPM.reduce((sum, p) => sum + p.tpa, 0);
                                const awayTPA = awayBPM.reduce((sum, p) => sum + p.tpa, 0);

                                const BPMTable = ({ teamName, players, avgBPM, totalTPA, isHome }) => {
                                    const teamColor = isHome ? 'var(--gv-team-home)' : 'var(--gv-team-away)';
                                    const formatBPM = (val) => val >= 0 ? '+' + val.toFixed(1) : val.toFixed(1);
                                    const bpmColor = (val) => val > 0 ? 'var(--gv-positive)' : val < 0 ? 'var(--gv-negative)' : 'var(--gv-text-muted)';

                                    return e('div', { className: 'gv-stat-card', style: { marginBottom: '20px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title', style: { color: teamColor }}, teamName)
                                        ),
                                        e('div', { style: { overflowX: 'auto' }},
                                            e('table', { className: 'gv-player-table' },
                                                e('thead', null,
                                                    e('tr', null,
                                                        ['#', 'Player', 'MIN', 'POS', 'OBPM', 'DBPM', 'BPM', 'TPA'].map((h, i) =>
                                                            e('th', { key: i, style: i === 1 ? { textAlign: 'left', minWidth: '120px' } : { textAlign: 'center' } }, h)
                                                        )
                                                    )
                                                ),
                                                e('tbody', null,
                                                    players.map((p, i) =>
                                                        e('tr', { key: i },
                                                            e('td', { style: { color: teamColor, fontWeight: '600' }}, p.number || '-'),
                                                            e('td', { style: { textAlign: 'left' }}, p.name || 'Unknown'),
                                                            e('td', { style: { textAlign: 'center' }}, Math.round(p.minutes || 0)),
                                                            e('td', { style: { textAlign: 'center', color: 'var(--gv-text-muted)' }}, (p.pos || 3).toFixed(1)),
                                                            e('td', { style: { textAlign: 'center', color: bpmColor(p.obpm), fontWeight: '600' }}, formatBPM(p.obpm)),
                                                            e('td', { style: { textAlign: 'center', color: bpmColor(p.dbpm), fontWeight: '600' }}, formatBPM(p.dbpm)),
                                                            e('td', { style: { textAlign: 'center', color: bpmColor(p.bpm), fontWeight: '700', fontSize: '14px' }}, formatBPM(p.bpm)),
                                                            e('td', { style: { textAlign: 'center', color: bpmColor(p.tpa), fontWeight: '600' }}, formatBPM(p.tpa))
                                                        )
                                                    )
                                                )
                                            )
                                        ),
                                        e('div', { style: { marginTop: '12px', padding: '10px', background: 'var(--gv-bg-glass)', borderRadius: '8px', display: 'flex', justifyContent: 'space-between' }},
                                            e('span', { style: { fontSize: '12px' }},
                                                e('span', { style: { color: 'var(--gv-text-muted)' }}, 'Team Avg BPM: '),
                                                e('span', { style: { color: bpmColor(avgBPM), fontWeight: '700' }}, formatBPM(avgBPM))
                                            ),
                                            e('span', { style: { fontSize: '12px' }},
                                                e('span', { style: { color: 'var(--gv-text-muted)' }}, 'Team TPA: '),
                                                e('span', { style: { color: bpmColor(totalTPA), fontWeight: '700' }}, formatBPM(totalTPA))
                                            )
                                        )
                                    );
                                };

                                return e('div', null,
                                    e(BPMTable, { teamName: homeTeam, players: homeBPM, avgBPM: homeAvgBPM, totalTPA: homeTPA, isHome: true }),
                                    e(BPMTable, { teamName: awayTeam, players: awayBPM, avgBPM: awayAvgBPM, totalTPA: awayTPA, isHome: false }),
                                    // Methodology
                                    e('div', { className: 'gv-stat-card full-width', style: { marginTop: '16px' }},
                                        e('div', { style: { padding: '16px', fontSize: '12px', color: 'var(--gv-text-secondary)' }},
                                            e('div', { style: { fontWeight: '700', marginBottom: '8px', color: 'var(--gv-accent-cyan)' }}, '📐 Single-Game BPM (gBPM) Methodology'),
                                            e('p', null, 'Game Box Plus/Minus estimates a player\'s contribution per 100 possessions using box score statistics. TPA (Total Points Added) converts this rate to a counting stat: BPM × (Player Possessions / 100).'),
                                            e('p', { style: { marginTop: '8px', color: 'var(--gv-text-muted)', fontSize: '11px' }}, 'Note: Single-game BPM has higher variance than season BPM. DBPM especially unreliable with limited defensive box stats.')
                                        )
                                    )
                                );
                            })(),

                            // Tab Content - Half Stats (Real period data with player tables)
                            gvActiveTab === 'halfstats' && gvCurrentGame.teamsData && (() => {
                                const teamKeys = Object.keys(gvCurrentGame.teamsData);
                                if (teamKeys.length < 2) return e('div', null, 'No data');

                                // Extract display name with suffix handling (matches GAMEVIS)
                                const extractDisplayName = (fullName) => {
                                    if (!fullName || fullName === 'Unknown') return 'UNKNOWN';
                                    const parts = fullName.trim().split(/\s+/);
                                    if (parts.length === 1) return parts[0].toUpperCase();

                                    const suffixes = ['Jr.', 'Jr', 'III', 'II', 'IV', 'V', 'VI', 'VII', 'VIII', 'Sr.', 'Sr'];
                                    const lastPart = parts[parts.length - 1];

                                    // Check if last part is a suffix
                                    const isSuffix = suffixes.some(s =>
                                        lastPart.toLowerCase() === s.toLowerCase() ||
                                        lastPart.toLowerCase().replace('.', '') === s.toLowerCase().replace('.', '')
                                    );

                                    if (isSuffix && parts.length >= 2) {
                                        // Return the part before the suffix + the suffix
                                        const nameBeforeSuffix = parts[parts.length - 2];
                                        return nameBeforeSuffix.toUpperCase() + ' ' + lastPart;
                                    }

                                    // No suffix, just return last name
                                    return lastPart.toUpperCase();
                                };

                                const teamPeriodTotals = gvCurrentGame.teamPeriodTotals || {};
                                const periodStats = gvCurrentGame.periodStats || {};
                                const playerPeriodMinutes = gvCurrentGame.playerPeriodMinutes || {};
                                const playerRoster = gvCurrentGame.playerRoster || {};
                                const homeTeam = teamKeys[0];
                                const awayTeam = teamKeys[1];
                                const maxPeriod = gvCurrentGame.maxPeriod || 4;
                                const halfStatsView = gvHalfStatsView;
                                const setHalfStatsView = setGvHalfStatsView;

                                // Calculate half totals for teams
                                const calcHalfTotals = (teamName, periods, oppTeamName) => {
                                    const totals = { points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, rimAtt: 0, rimMade: 0, midAtt: 0, midMade: 0 };
                                    let oppDreb = 0;
                                    periods.forEach(p => {
                                        const pt = teamPeriodTotals[teamName]?.[p] || {};
                                        Object.keys(totals).forEach(k => totals[k] += (pt[k] || 0));
                                        oppDreb += teamPeriodTotals[oppTeamName]?.[p]?.dreb || 0;
                                    });
                                    totals.efg = totals.fga > 0 ? ((totals.fgm + 0.5 * totals.fg3m) / totals.fga * 100) : 0;
                                    totals.ts = (totals.fga + 0.44 * totals.fta) > 0 ? (totals.points / (2 * (totals.fga + 0.44 * totals.fta)) * 100) : 0;
                                    totals.tovPct = (totals.fga + 0.44 * totals.fta + totals.tov) > 0 ? (totals.tov / (totals.fga + 0.44 * totals.fta + totals.tov) * 100) : 0;
                                    totals.orebPct = (totals.oreb + oppDreb) > 0 ? (totals.oreb / (totals.oreb + oppDreb) * 100) : 0;
                                    totals.ftRate = totals.fga > 0 ? (totals.fta / totals.fga * 100) : 0;
                                    const poss = totals.fga + 0.44 * totals.fta - totals.oreb + totals.tov;
                                    totals.ortg = poss > 0 ? (totals.points / poss * 100) : 0;
                                    return totals;
                                };

                                // Aggregate player stats for specific periods
                                const aggregatePlayerStats = (teamName, periods, oppTeamName) => {
                                    const playerMap = {};
                                    const players = gvCurrentGame.teamsData[teamName]?.players || [];

                                    // Initialize from roster
                                    players.forEach(p => {
                                        playerMap[p.number] = {
                                            number: p.number,
                                            name: p.name || playerRoster[teamName]?.[p.number] || `#${p.number}`,
                                            isStarter: p.isStarter,
                                            minutes: 0, points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                                            ftm: 0, fta: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, pf: 0,
                                            rimAtt: 0, rimMade: 0, midAtt: 0, midMade: 0
                                        };
                                    });

                                    // Aggregate minutes from period tracking
                                    periods.forEach(period => {
                                        const periodMins = playerPeriodMinutes[teamName]?.[period];
                                        if (periodMins) {
                                            Object.entries(periodMins).forEach(([playerNum, seconds]) => {
                                                if (playerMap[playerNum]) {
                                                    playerMap[playerNum].minutes += seconds / 60;
                                                }
                                            });
                                        }
                                    });

                                    // Aggregate stats from period stats
                                    periods.forEach(period => {
                                        const periodData = periodStats[teamName]?.[period];
                                        if (!periodData) return;

                                        Object.entries(periodData).forEach(([playerNum, stats]) => {
                                            if (!playerMap[playerNum]) {
                                                playerMap[playerNum] = {
                                                    number: playerNum,
                                                    name: playerRoster[teamName]?.[playerNum] || `#${playerNum}`,
                                                    isStarter: false,
                                                    minutes: 0, points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0,
                                                    ftm: 0, fta: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0, pf: 0,
                                                    rimAtt: 0, rimMade: 0, midAtt: 0, midMade: 0
                                                };
                                            }
                                            const p = playerMap[playerNum];
                                            p.points += stats.points || 0;
                                            p.fgm += stats.fgm || 0;
                                            p.fga += stats.fga || 0;
                                            p.fg3m += stats.fg3m || 0;
                                            p.fg3a += stats.fg3a || 0;
                                            p.ftm += stats.ftm || 0;
                                            p.fta += stats.fta || 0;
                                            p.oreb += stats.oreb || 0;
                                            p.dreb += stats.dreb || 0;
                                            p.ast += stats.ast || 0;
                                            p.stl += stats.stl || 0;
                                            p.blk += stats.blk || 0;
                                            p.tov += stats.tov || 0;
                                            p.pf += stats.pf || 0;
                                            p.rimAtt += stats.rimAtt || 0;
                                            p.rimMade += stats.rimMade || 0;
                                            p.midAtt += stats.midAtt || 0;
                                            p.midMade += stats.midMade || 0;
                                        });
                                    });

                                    // Calculate derived stats
                                    return Object.values(playerMap)
                                        .filter(p => p.minutes > 0 || p.points > 0 || p.fga > 0)
                                        .map(p => {
                                            p.fg2m = p.fgm - p.fg3m;
                                            p.fg2a = p.fga - p.fg3a;
                                            p.efg = p.fga > 0 ? ((p.fgm + 0.5 * p.fg3m) / p.fga * 100) : 0;
                                            p.ts = (p.fga + 0.44 * p.fta) > 0 ? (p.points / (2 * (p.fga + 0.44 * p.fta)) * 100) : 0;
                                            p.tovPct = (p.fga + 0.44 * p.fta + p.tov) > 0 ? (p.tov / (p.fga + 0.44 * p.fta + p.tov) * 100) : 0;
                                            return p;
                                        })
                                        .sort((a, b) => b.minutes - a.minutes);
                                };

                                const home1H = calcHalfTotals(homeTeam, [1, 2], awayTeam);
                                const home2H = calcHalfTotals(homeTeam, [3, 4], awayTeam);
                                const away1H = calcHalfTotals(awayTeam, [1, 2], homeTeam);
                                const away2H = calcHalfTotals(awayTeam, [3, 4], homeTeam);

                                // Determine periods based on selected view
                                const getPeriodsForView = (view) => {
                                    if (view === 'first') return [1, 2];
                                    if (view === 'second') return [3, 4];
                                    if (view.startsWith('ot')) {
                                        const otNum = parseInt(view.replace('ot', ''));
                                        return [4 + otNum];
                                    }
                                    return [1, 2];
                                };

                                const selectedPeriods = getPeriodsForView(halfStatsView);
                                const homePlayers = aggregatePlayerStats(homeTeam, selectedPeriods, awayTeam);
                                const awayPlayers = aggregatePlayerStats(awayTeam, selectedPeriods, homeTeam);
                                const homeHalfTotals = halfStatsView === 'first' ? home1H : home2H;
                                const awayHalfTotals = halfStatsView === 'first' ? away1H : away2H;

                                // Four Factors display
                                const FourFactorRow = ({ label, homeVal, awayVal, higherBetter = true, isPercent = true }) => {
                                    const homeWins = higherBetter ? homeVal > awayVal : homeVal < awayVal;
                                    return e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 100px 1fr', gap: '8px', padding: '8px 0', borderBottom: '1px solid var(--gv-border-subtle)' }},
                                        e('div', { style: { textAlign: 'right', color: homeWins ? 'var(--gv-team-home)' : 'var(--gv-text-muted)', fontWeight: homeWins ? '700' : '400' }},
                                            isPercent ? homeVal.toFixed(1) + '%' : homeVal.toFixed(1)
                                        ),
                                        e('div', { style: { textAlign: 'center', color: 'var(--gv-text-secondary)', fontSize: '11px' }}, label),
                                        e('div', { style: { textAlign: 'left', color: !homeWins ? 'var(--gv-team-away)' : 'var(--gv-text-muted)', fontWeight: !homeWins ? '700' : '400' }},
                                            isPercent ? awayVal.toFixed(1) + '%' : awayVal.toFixed(1)
                                        )
                                    );
                                };

                                // Player table for half stats with extended stats
                                const HalfPlayerTable = ({ teamName, players, teamTotals, isHome }) => {
                                    const teamColor = isHome ? 'var(--gv-team-home)' : 'var(--gv-team-away)';
                                    const isWin = teamTotals.points > (isHome ? awayHalfTotals : homeHalfTotals).points;
                                    const collapsedGroups = gvCollapsedGroups;

                                    if (players.length === 0) {
                                        return e('div', { className: 'gv-stat-card', style: { marginBottom: '16px' }},
                                            e('div', { className: 'gv-card-header' },
                                                e('span', { className: 'gv-card-title', style: { color: teamColor }}, teamName)
                                            ),
                                            e('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--gv-text-muted)' }},
                                                'No player data for this period'
                                            )
                                        );
                                    }

                                    // Calculate derived stats for each player
                                    const enhancedPlayers = players.map(p => {
                                        const rimPct = (p.rimAtt || 0) > 0 ? ((p.rimMade || 0) / p.rimAtt * 100) : 0;
                                        const midAtt = p.midAtt || Math.max(0, (p.fg2a || (p.fga - p.fg3a)) - (p.rimAtt || 0));
                                        const midMade = p.midMade || Math.max(0, (p.fg2m || (p.fgm - p.fg3m)) - (p.rimMade || 0));
                                        const midPct = midAtt > 0 ? (midMade / midAtt * 100) : 0;
                                        const threePct = p.fg3a > 0 ? (p.fg3m / p.fg3a * 100) : 0;
                                        const ppp = (p.fga + 0.44 * p.fta + p.tov) > 0 ? (p.points / (p.fga + 0.44 * p.fta + p.tov)) : 0;
                                        return { ...p, rimPct, midAtt, midMade, midPct, threePct, ppp };
                                    });

                                    return e('div', { className: 'gv-stat-card', style: { marginBottom: '16px' }},
                                        e('div', { className: 'gv-card-header', style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' }},
                                            e('span', { className: 'gv-card-title', style: { color: teamColor }}, teamName),
                                            e('div', { style: { display: 'flex', gap: '8px', alignItems: 'center' }},
                                                e('span', { style: { fontSize: '13px', padding: '4px 12px', borderRadius: '12px', fontWeight: '700',
                                                    background: isWin ? 'var(--gv-positive-bg)' : 'var(--gv-negative-bg)',
                                                    color: isWin ? 'var(--gv-positive)' : 'var(--gv-negative)'
                                                }}, `${teamTotals.points} PTS`),
                                                e('span', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, enhancedPlayers.length + ' players')
                                            )
                                        ),
                                        e('div', { style: { overflowX: 'auto' }},
                                            e('table', { className: 'gv-player-table', style: { fontSize: '10px' }},
                                                e('thead', null,
                                                    // Group header row
                                                    e('tr', { style: { background: 'rgba(255,255,255,0.03)' }},
                                                        e('th', { style: { minWidth: '100px' }}, ''),
                                                        !collapsedGroups.scoring && e('th', { colSpan: 5, style: { textAlign: 'center', color: 'var(--gv-accent-emerald)', borderBottom: '2px solid var(--gv-accent-emerald)' }}, 'Scoring'),
                                                        !collapsedGroups.shotdist && e('th', { colSpan: 6, style: { textAlign: 'center', color: 'var(--gv-accent-purple)', borderBottom: '2px solid var(--gv-accent-purple)' }}, 'Shot Dist'),
                                                        !collapsedGroups.individual && e('th', { colSpan: 5, style: { textAlign: 'center', color: 'var(--gv-accent-gold)', borderBottom: '2px solid var(--gv-accent-gold)' }}, 'Other')
                                                    ),
                                                    // Column header row
                                                    e('tr', null,
                                                        e('th', { style: { textAlign: 'left', position: 'sticky', left: 0, background: 'var(--gv-bg-card)', zIndex: 2 }}, 'Player'),
                                                        // Scoring
                                                        !collapsedGroups.scoring && e('th', null, 'MIN'),
                                                        !collapsedGroups.scoring && e('th', null, 'PTS'),
                                                        !collapsedGroups.scoring && e('th', null, 'FG'),
                                                        !collapsedGroups.scoring && e('th', null, 'PPP'),
                                                        !collapsedGroups.scoring && e('th', null, 'eFG%'),
                                                        // Shot Distribution
                                                        !collapsedGroups.shotdist && e('th', null, 'RIM'),
                                                        !collapsedGroups.shotdist && e('th', null, 'RIM%'),
                                                        !collapsedGroups.shotdist && e('th', null, 'MID'),
                                                        !collapsedGroups.shotdist && e('th', null, 'MID%'),
                                                        !collapsedGroups.shotdist && e('th', null, '3PT'),
                                                        !collapsedGroups.shotdist && e('th', null, '3PT%'),
                                                        // Individual
                                                        !collapsedGroups.individual && e('th', null, 'REB'),
                                                        !collapsedGroups.individual && e('th', null, 'AST'),
                                                        !collapsedGroups.individual && e('th', null, 'TO'),
                                                        !collapsedGroups.individual && e('th', null, 'STL'),
                                                        !collapsedGroups.individual && e('th', null, 'TS%')
                                                    )
                                                ),
                                                e('tbody', null,
                                                    enhancedPlayers.map((p, i) =>
                                                        e('tr', { key: i, style: p.isStarter ? { background: isHome ? 'rgba(0, 212, 255, 0.06)' : 'rgba(255, 0, 170, 0.06)' } : {} },
                                                            e('td', { style: { textAlign: 'left', position: 'sticky', left: 0, background: 'var(--gv-bg-card)', zIndex: 1, whiteSpace: 'nowrap' }},
                                                                e('span', { style: { color: teamColor, marginRight: '4px', fontSize: '9px' }}, p.number || '-'),
                                                                extractDisplayName(p.name),
                                                                p.isStarter && e('span', { style: { fontSize: '8px', color: 'var(--gv-accent-gold)', marginLeft: '3px' }}, '★')
                                                            ),
                                                            // Scoring
                                                            !collapsedGroups.scoring && e('td', { style: { fontWeight: '600' }}, p.minutes.toFixed(1)),
                                                            !collapsedGroups.scoring && e('td', { style: { fontWeight: '700', color: teamColor }}, p.points),
                                                            !collapsedGroups.scoring && e('td', null, `${p.fgm}-${p.fga}`),
                                                            !collapsedGroups.scoring && e('td', { style: { fontFamily: "'Space Mono', monospace" }}, p.ppp.toFixed(2)),
                                                            !collapsedGroups.scoring && e('td', { style: { color: p.efg >= 50 ? 'var(--gv-positive)' : p.efg < 40 ? 'var(--gv-negative)' : 'inherit' }}, p.efg.toFixed(0) + '%'),
                                                            // Shot Distribution
                                                            !collapsedGroups.shotdist && e('td', null, p.rimAtt || 0),
                                                            !collapsedGroups.shotdist && e('td', { style: { color: p.rimPct >= 60 ? 'var(--gv-positive)' : p.rimPct >= 45 ? 'inherit' : 'var(--gv-text-muted)' }}, p.rimPct.toFixed(0) + '%'),
                                                            !collapsedGroups.shotdist && e('td', null, p.midAtt || 0),
                                                            !collapsedGroups.shotdist && e('td', { style: { color: p.midPct >= 45 ? 'var(--gv-positive)' : p.midPct >= 35 ? 'inherit' : 'var(--gv-text-muted)' }}, p.midPct.toFixed(0) + '%'),
                                                            !collapsedGroups.shotdist && e('td', { style: { color: 'var(--gv-accent-purple)' }}, p.fg3a || 0),
                                                            !collapsedGroups.shotdist && e('td', { style: { color: p.threePct >= 40 ? 'var(--gv-positive)' : p.threePct >= 33 ? 'inherit' : 'var(--gv-text-muted)' }}, p.threePct.toFixed(0) + '%'),
                                                            // Individual
                                                            !collapsedGroups.individual && e('td', null, (p.oreb || 0) + (p.dreb || 0)),
                                                            !collapsedGroups.individual && e('td', null, p.ast || 0),
                                                            !collapsedGroups.individual && e('td', { style: { color: (p.tov || 0) > 3 ? 'var(--gv-negative)' : 'inherit' }}, p.tov || 0),
                                                            !collapsedGroups.individual && e('td', null, p.stl || 0),
                                                            !collapsedGroups.individual && e('td', { style: { color: p.ts >= 55 ? 'var(--gv-positive)' : p.ts < 45 ? 'var(--gv-negative)' : 'inherit' }}, p.ts.toFixed(0) + '%')
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    );
                                };

                                const hasData = home1H.points > 0 || away1H.points > 0;

                                if (!hasData) {
                                    return e('div', { className: 'gv-stat-card full-width' },
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '📊 Half Stats')
                                        ),
                                        e('div', { style: { padding: '40px', textAlign: 'center', color: 'var(--gv-text-muted)' }},
                                            'No period data available. PBP parsing may not have detected period markers.'
                                        )
                                    );
                                }

                                // Battle calculations for selected half
                                const POSS = 75;
                                const halfTovImpact = ((awayHalfTotals.tov || 0) - (homeHalfTotals.tov || 0)) * 1.1;
                                const halfOrebImpact = ((homeHalfTotals.oreb || 0) - (awayHalfTotals.oreb || 0)) * 1.1;
                                const halfEpaBattle = halfTovImpact + halfOrebImpact;
                                const halfEfgImpact = ((homeHalfTotals.efg || 50) - (awayHalfTotals.efg || 50)) * 1.77 * (POSS / 100) / 2;
                                const halfFtRateImpact = ((homeHalfTotals.ftRate || 25) - (awayHalfTotals.ftRate || 25)) * 0.25 * (POSS / 100) / 2;
                                const halfScoringBattle = halfEfgImpact + halfFtRateImpact;
                                const halfProjectedMargin = halfEpaBattle + halfScoringBattle;
                                const halfActualMargin = (homeHalfTotals.points || 0) - (awayHalfTotals.points || 0);

                                return e('div', null,
                                    // Half selector tabs
                                    e('div', { style: { display: 'flex', gap: '8px', marginBottom: '16px' }},
                                        ['first', 'second'].concat(maxPeriod > 4 ? Array.from({length: maxPeriod - 4}, (_, i) => `ot${i+1}`) : []).map(view =>
                                            e('button', {
                                                key: view,
                                                onClick: () => setHalfStatsView(view),
                                                style: {
                                                    padding: '8px 16px', borderRadius: '8px', border: 'none', cursor: 'pointer',
                                                    background: halfStatsView === view ? 'var(--gv-accent-cyan)' : 'var(--gv-bg-elevated)',
                                                    color: halfStatsView === view ? '#000' : 'var(--gv-text-primary)',
                                                    fontWeight: halfStatsView === view ? '700' : '400', fontSize: '12px'
                                                }
                                            }, view === 'first' ? '1st Half' : view === 'second' ? '2nd Half' : view.toUpperCase())
                                        )
                                    ),

                                    // Half Battle Points Summary
                                    e('div', { className: 'gv-stat-card full-width', style: { marginBottom: '16px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '⚔️ ' + (halfStatsView === 'first' ? '1st Half' : halfStatsView === 'second' ? '2nd Half' : halfStatsView.toUpperCase()) + ' Battle Analysis')
                                        ),
                                        e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '10px', padding: '12px' }},
                                            e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '10px', textAlign: 'center' }},
                                                e('div', { style: { fontSize: '9px', color: 'var(--gv-accent-emerald)', fontWeight: '600', marginBottom: '2px' }}, '⚡ EPA'),
                                                e('div', { style: { fontSize: '20px', fontWeight: '800', color: halfEpaBattle >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    (halfEpaBattle >= 0 ? '+' : '') + halfEpaBattle.toFixed(1)
                                                ),
                                                e('div', { style: { fontSize: '8px', color: 'var(--gv-text-muted)' }}, `TO: ${halfTovImpact >= 0 ? '+' : ''}${halfTovImpact.toFixed(1)} OREB: ${halfOrebImpact >= 0 ? '+' : ''}${halfOrebImpact.toFixed(1)}`)
                                            ),
                                            e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '10px', textAlign: 'center' }},
                                                e('div', { style: { fontSize: '9px', color: 'var(--gv-accent-gold)', fontWeight: '600', marginBottom: '2px' }}, '🎯 Scoring'),
                                                e('div', { style: { fontSize: '20px', fontWeight: '800', color: halfScoringBattle >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    (halfScoringBattle >= 0 ? '+' : '') + halfScoringBattle.toFixed(1)
                                                ),
                                                e('div', { style: { fontSize: '8px', color: 'var(--gv-text-muted)' }}, `eFG: ${halfEfgImpact >= 0 ? '+' : ''}${halfEfgImpact.toFixed(1)} FT: ${halfFtRateImpact >= 0 ? '+' : ''}${halfFtRateImpact.toFixed(1)}`)
                                            ),
                                            e('div', { style: { background: halfProjectedMargin >= 0 ? 'rgba(0, 212, 255, 0.12)' : 'rgba(255, 0, 170, 0.12)', borderRadius: '8px', padding: '10px', textAlign: 'center', border: `1px solid ${halfProjectedMargin >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)'}` }},
                                                e('div', { style: { fontSize: '9px', color: 'var(--gv-text-secondary)', fontWeight: '600', marginBottom: '2px' }}, '📊 Expected'),
                                                e('div', { style: { fontSize: '20px', fontWeight: '800', color: halfProjectedMargin >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    (halfProjectedMargin >= 0 ? '+' : '') + halfProjectedMargin.toFixed(1)
                                                )
                                            ),
                                            e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '10px', textAlign: 'center' }},
                                                e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)', fontWeight: '600', marginBottom: '2px' }}, '✓ Actual'),
                                                e('div', { style: { fontSize: '20px', fontWeight: '800', color: halfActualMargin >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    (halfActualMargin >= 0 ? '+' : '') + halfActualMargin
                                                ),
                                                e('div', { style: { fontSize: '8px', color: 'var(--gv-text-muted)' }}, `${homeHalfTotals.points || 0} - ${awayHalfTotals.points || 0}`)
                                            )
                                        )
                                    ),

                                    // Team Four Factors for selected half
                                    e('div', { className: 'gv-stat-card full-width', style: { marginBottom: '20px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '📊 Four Factors - ' + (halfStatsView === 'first' ? '1st Half' : halfStatsView === 'second' ? '2nd Half' : halfStatsView.toUpperCase())),
                                            e('div', { style: { display: 'flex', gap: '16px', fontSize: '12px' }},
                                                e('span', { style: { color: 'var(--gv-team-home)' }}, '● ' + homeTeam),
                                                e('span', { style: { color: 'var(--gv-team-away)' }}, '● ' + awayTeam)
                                            )
                                        ),
                                        e('div', { style: { padding: '16px' }},
                                            // Score display
                                            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr auto 1fr', gap: '20px', marginBottom: '20px', padding: '16px', background: 'var(--gv-bg-glass)', borderRadius: '12px' }},
                                                e('div', { style: { textAlign: 'center' }},
                                                    e('div', { style: { fontSize: '36px', fontWeight: '800', color: 'var(--gv-team-home)' }}, homeHalfTotals.points),
                                                    e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)' }}, homeTeam)
                                                ),
                                                e('div', { style: { fontSize: '20px', color: 'var(--gv-text-muted)', alignSelf: 'center' }}, 'vs'),
                                                e('div', { style: { textAlign: 'center' }},
                                                    e('div', { style: { fontSize: '36px', fontWeight: '800', color: 'var(--gv-team-away)' }}, awayHalfTotals.points),
                                                    e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)' }}, awayTeam)
                                                )
                                            ),
                                            e(FourFactorRow, { label: 'eFG%', homeVal: homeHalfTotals.efg, awayVal: awayHalfTotals.efg }),
                                            e(FourFactorRow, { label: 'TOV%', homeVal: homeHalfTotals.tovPct, awayVal: awayHalfTotals.tovPct, higherBetter: false }),
                                            e(FourFactorRow, { label: 'OREB%', homeVal: homeHalfTotals.orebPct, awayVal: awayHalfTotals.orebPct }),
                                            e(FourFactorRow, { label: 'FT Rate', homeVal: homeHalfTotals.ftRate, awayVal: awayHalfTotals.ftRate }),
                                            e(FourFactorRow, { label: 'ORtg', homeVal: homeHalfTotals.ortg, awayVal: awayHalfTotals.ortg, isPercent: false })
                                        )
                                    ),

                                    // Player tables for selected half
                                    e(HalfPlayerTable, { teamName: homeTeam, players: homePlayers, teamTotals: homeHalfTotals, isHome: true }),
                                    e(HalfPlayerTable, { teamName: awayTeam, players: awayPlayers, teamTotals: awayHalfTotals, isHome: false }),

                                    // Quarter breakdown
                                    e('div', { className: 'gv-stat-card full-width', style: { marginTop: '20px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '📋 Quarter Breakdown')
                                        ),
                                        e('table', { className: 'gv-player-table' },
                                            e('thead', null,
                                                e('tr', null,
                                                    e('th', { style: { textAlign: 'left' }}, 'Team'),
                                                    e('th', null, 'Q1'),
                                                    e('th', null, 'Q2'),
                                                    e('th', null, 'Q3'),
                                                    e('th', null, 'Q4'),
                                                    maxPeriod > 4 && e('th', null, 'OT'),
                                                    e('th', { style: { fontWeight: '700' }}, 'Total')
                                                )
                                            ),
                                            e('tbody', null,
                                                [homeTeam, awayTeam].map((team, i) => {
                                                    const isHome = i === 0;
                                                    const teamColor = isHome ? 'var(--gv-team-home)' : 'var(--gv-team-away)';
                                                    const qPts = [1, 2, 3, 4].map(q => teamPeriodTotals[team]?.[q]?.points || 0);
                                                    const otPts = maxPeriod > 4 ? (teamPeriodTotals[team]?.[5]?.points || 0) : 0;
                                                    const total = qPts.reduce((a, b) => a + b, 0) + otPts;

                                                    return e('tr', { key: team },
                                                        e('td', { style: { textAlign: 'left', color: teamColor, fontWeight: '600' }}, team),
                                                        ...qPts.map((pts, j) => e('td', { key: j }, pts)),
                                                        maxPeriod > 4 && e('td', null, otPts),
                                                        e('td', { style: { fontWeight: '700', color: teamColor }}, total)
                                                    );
                                                })
                                            )
                                        )
                                    )
                                );
                            })(),

                            // Tab Content - Half Comparison (Tug of war style)
                            gvActiveTab === 'halfcompare' && gvCurrentGame.teamsData && (() => {
                                const teamKeys = Object.keys(gvCurrentGame.teamsData);
                                if (teamKeys.length < 2) return e('div', null, 'No data');

                                const teamPeriodTotals = gvCurrentGame.teamPeriodTotals || {};
                                const homeTeam = teamKeys[0];
                                const awayTeam = teamKeys[1];

                                // Calculate half totals
                                const calcHalfTotals = (teamName, periods) => {
                                    const totals = { points: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0, ast: 0, stl: 0, blk: 0, tov: 0 };
                                    periods.forEach(p => {
                                        const pt = teamPeriodTotals[teamName]?.[p] || {};
                                        Object.keys(totals).forEach(k => totals[k] += (pt[k] || 0));
                                    });
                                    totals.efg = totals.fga > 0 ? ((totals.fgm + 0.5 * totals.fg3m) / totals.fga * 100) : 0;
                                    totals.tovPct = totals.fga > 0 ? (totals.tov / (totals.fga + 0.44 * totals.fta + totals.tov) * 100) : 0;
                                    totals.orebPct = (totals.oreb + totals.dreb) > 0 ? (totals.oreb / (totals.oreb + totals.dreb) * 100) : 0;
                                    return totals;
                                };

                                const home1H = calcHalfTotals(homeTeam, [1, 2]);
                                const home2H = calcHalfTotals(homeTeam, [3, 4]);
                                const away1H = calcHalfTotals(awayTeam, [1, 2]);
                                const away2H = calcHalfTotals(awayTeam, [3, 4]);

                                const CompareBar = ({ label, home1, home2, away1, away2, higherBetter = true, format = 'num' }) => {
                                    const formatVal = (v) => format === 'pct' ? v.toFixed(1) + '%' : v.toFixed(0);
                                    const h1Wins = higherBetter ? home1 > away1 : home1 < away1;
                                    const h2Wins = higherBetter ? home2 > away2 : home2 < away2;

                                    return e('div', { style: { marginBottom: '16px' }},
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px', fontSize: '11px' }},
                                            e('span', { style: { color: 'var(--gv-text-muted)' }}, label),
                                            e('span', { style: { color: 'var(--gv-text-muted)' }}, '1H / 2H')
                                        ),
                                        e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 60px 60px 1fr', gap: '8px', alignItems: 'center' }},
                                            e('div', { style: { display: 'flex', gap: '8px', justifyContent: 'flex-end' }},
                                                e('span', { style: { color: h1Wins ? 'var(--gv-team-home)' : 'var(--gv-text-muted)', fontWeight: h1Wins ? '700' : '400' }}, formatVal(home1)),
                                                e('span', { style: { color: h2Wins ? 'var(--gv-team-home)' : 'var(--gv-text-muted)', fontWeight: h2Wins ? '700' : '400' }}, formatVal(home2))
                                            ),
                                            e('div', { style: { height: '8px', background: 'var(--gv-team-home)', borderRadius: '4px', opacity: h1Wins ? 1 : 0.3 }}),
                                            e('div', { style: { height: '8px', background: 'var(--gv-team-away)', borderRadius: '4px', opacity: !h1Wins ? 1 : 0.3 }}),
                                            e('div', { style: { display: 'flex', gap: '8px' }},
                                                e('span', { style: { color: !h1Wins ? 'var(--gv-team-away)' : 'var(--gv-text-muted)', fontWeight: !h1Wins ? '700' : '400' }}, formatVal(away1)),
                                                e('span', { style: { color: !h2Wins ? 'var(--gv-team-away)' : 'var(--gv-text-muted)', fontWeight: !h2Wins ? '700' : '400' }}, formatVal(away2))
                                            )
                                        )
                                    );
                                };

                                const hasData = home1H.points > 0 || away1H.points > 0;

                                if (!hasData) {
                                    return e('div', { className: 'gv-stat-card full-width' },
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '📉 Half Comparison')
                                        ),
                                        e('div', { style: { padding: '40px', textAlign: 'center', color: 'var(--gv-text-muted)' }},
                                            'No period data available.'
                                        )
                                    );
                                }

                                return e('div', null,
                                    e('div', { className: 'gv-stat-card full-width' },
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '⚖️ Half-by-Half Comparison'),
                                            e('div', { style: { display: 'flex', gap: '16px', fontSize: '11px' }},
                                                e('span', { style: { color: 'var(--gv-team-home)' }}, homeTeam),
                                                e('span', { style: { color: 'var(--gv-text-muted)' }}, 'vs'),
                                                e('span', { style: { color: 'var(--gv-team-away)' }}, awayTeam)
                                            )
                                        ),
                                        e('div', { style: { padding: '16px' }},
                                            e(CompareBar, { label: 'Points', home1: home1H.points, home2: home2H.points, away1: away1H.points, away2: away2H.points }),
                                            e(CompareBar, { label: 'eFG%', home1: home1H.efg, home2: home2H.efg, away1: away1H.efg, away2: away2H.efg, format: 'pct' }),
                                            e(CompareBar, { label: '3-Pointers Made', home1: home1H.fg3m, home2: home2H.fg3m, away1: away1H.fg3m, away2: away2H.fg3m }),
                                            e(CompareBar, { label: 'Assists', home1: home1H.ast, home2: home2H.ast, away1: away1H.ast, away2: away2H.ast }),
                                            e(CompareBar, { label: 'Turnovers', home1: home1H.tov, home2: home2H.tov, away1: away1H.tov, away2: away2H.tov, higherBetter: false }),
                                            e(CompareBar, { label: 'Offensive Rebounds', home1: home1H.oreb, home2: home2H.oreb, away1: away1H.oreb, away2: away2H.oreb })
                                        )
                                    ),
                                    // Momentum swing indicator
                                    e('div', { className: 'gv-stat-card full-width', style: { marginTop: '20px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '📊 Half Scoring Swing')
                                        ),
                                        e('div', { style: { padding: '20px', textAlign: 'center' }},
                                            e('div', { style: { display: 'flex', justifyContent: 'center', gap: '40px' }},
                                                e('div', null,
                                                    e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)', marginBottom: '4px' }}, '1st Half Margin'),
                                                    e('div', { style: { fontSize: '28px', fontWeight: '800', color: (home1H.points - away1H.points) >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                        ((home1H.points - away1H.points) >= 0 ? '+' : '') + (home1H.points - away1H.points)
                                                    )
                                                ),
                                                e('div', { style: { fontSize: '24px', color: 'var(--gv-text-muted)', alignSelf: 'center' }}, '→'),
                                                e('div', null,
                                                    e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)', marginBottom: '4px' }}, '2nd Half Margin'),
                                                    e('div', { style: { fontSize: '28px', fontWeight: '800', color: (home2H.points - away2H.points) >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                        ((home2H.points - away2H.points) >= 0 ? '+' : '') + (home2H.points - away2H.points)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                );
                            })(),

                            // Tab Content - Connections (Assist Combinations) - REAL DATA
                            gvActiveTab === 'connections' && gvCurrentGame.teamsData && (() => {
                                const teamKeys = Object.keys(gvCurrentGame.teamsData);
                                if (teamKeys.length < 2) return e('div', null, 'No data');

                                const assistCombos = gvCurrentGame.assistCombinations || {};
                                const comboList = Object.values(assistCombos).sort((a, b) => b.points - a.points);

                                if (comboList.length === 0) {
                                    return e('div', { className: 'gv-stat-card full-width' },
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '🔗 Assist Connections')
                                        ),
                                        e('div', { style: { padding: '40px', textAlign: 'center', color: 'var(--gv-text-muted)' }},
                                            'No assist combinations found. PBP data may not contain assist information.'
                                        )
                                    );
                                }

                                // Group by team
                                const homeTeam = teamKeys[0];
                                const awayTeam = teamKeys[1];
                                const homeCombos = comboList.filter(c => c.team === homeTeam);
                                const awayCombos = comboList.filter(c => c.team === awayTeam);

                                const ConnectionsTable = ({ teamName, combos, isHome }) => {
                                    const teamColor = isHome ? 'var(--gv-team-home)' : 'var(--gv-team-away)';
                                    const totalPoints = combos.reduce((sum, c) => sum + c.points, 0);
                                    const totalAssists = combos.reduce((sum, c) => sum + c.count, 0);

                                    return e('div', { className: 'gv-stat-card', style: { marginBottom: '20px' }},
                                        e('div', { className: 'gv-card-header', style: { display: 'flex', justifyContent: 'space-between' }},
                                            e('span', { className: 'gv-card-title', style: { color: teamColor }}, teamName),
                                            e('span', { style: { fontSize: '12px', color: 'var(--gv-text-muted)' }},
                                                totalAssists + ' assists • ' + totalPoints + ' pts generated'
                                            )
                                        ),
                                        combos.length === 0 ?
                                            e('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--gv-text-muted)' }}, 'No assist combinations') :
                                            e('div', { style: { overflowX: 'auto' }},
                                                e('table', { className: 'gv-player-table' },
                                                    e('thead', null,
                                                        e('tr', null,
                                                            e('th', { style: { textAlign: 'left' }}, 'Passer'),
                                                            e('th', null, '→'),
                                                            e('th', { style: { textAlign: 'left' }}, 'Scorer'),
                                                            e('th', null, 'AST'),
                                                            e('th', null, 'PTS'),
                                                            e('th', null, '3s'),
                                                            e('th', null, 'PPP')
                                                        )
                                                    ),
                                                    e('tbody', null,
                                                        combos.slice(0, 15).map((c, i) =>
                                                            e('tr', { key: i },
                                                                e('td', { style: { textAlign: 'left' }},
                                                                    e('span', { style: { color: teamColor, marginRight: '6px', fontSize: '10px' }}, '#' + c.assisterNum),
                                                                    c.assisterName
                                                                ),
                                                                e('td', { style: { color: 'var(--gv-accent-purple)' }}, '→'),
                                                                e('td', { style: { textAlign: 'left' }},
                                                                    e('span', { style: { color: teamColor, marginRight: '6px', fontSize: '10px' }}, '#' + c.scorerNum),
                                                                    c.scorerName
                                                                ),
                                                                e('td', { style: { fontWeight: '600' }}, c.count),
                                                                e('td', { style: { fontWeight: '700', color: teamColor }}, c.points),
                                                                e('td', { style: { color: 'var(--gv-accent-purple)' }}, c.threes || 0),
                                                                e('td', { style: { fontFamily: "'Space Mono', monospace", fontSize: '10px' }}, (c.points / c.count).toFixed(2))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                    );
                                };

                                return e('div', null,
                                    // Summary stats
                                    e('div', { className: 'gv-stat-card full-width', style: { marginBottom: '20px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '🔗 Assist Connections Summary')
                                        ),
                                        e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px', padding: '16px' }},
                                            e('div', { style: { textAlign: 'center' }},
                                                e('div', { style: { fontSize: '32px', fontWeight: '800', color: 'var(--gv-team-home)' }}, homeCombos.length),
                                                e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)' }}, homeTeam + ' unique combos')
                                            ),
                                            e('div', { style: { textAlign: 'center' }},
                                                e('div', { style: { fontSize: '32px', fontWeight: '800', color: 'var(--gv-team-away)' }}, awayCombos.length),
                                                e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)' }}, awayTeam + ' unique combos')
                                            )
                                        )
                                    ),
                                    e(ConnectionsTable, { teamName: homeTeam, combos: homeCombos, isHome: true }),
                                    e(ConnectionsTable, { teamName: awayTeam, combos: awayCombos, isHome: false })
                                );
                            })(),

                            // Tab Content - Flow (Game Flow with SVG charts)
                            gvActiveTab === 'flow' && gvCurrentGame.teamsData && (() => {
                                const teamKeys = Object.keys(gvCurrentGame.teamsData);
                                if (teamKeys.length < 2) return e('div', null, 'No data');

                                const gameFlowData = gvCurrentGame.gameFlowData || [];
                                const teamMomentumRuns = gvCurrentGame.teamMomentumRuns || [];
                                const homeTeam = teamKeys[0];
                                const awayTeam = teamKeys[1];
                                const maxPeriod = gvCurrentGame.maxPeriod || 4;

                                // Get final scores
                                const lastFlow = gameFlowData[gameFlowData.length - 1] || { homePoints: 0, awayPoints: 0, homePPP: 0, awayPPP: 0 };
                                const maxMargin = Math.max(...gameFlowData.map(d => Math.abs(d.margin || 0)), 1);
                                const maxPoints = Math.max(...gameFlowData.map(d => Math.max(d.homePoints || 0, d.awayPoints || 0)), 1);

                                // Calculate game duration based on periods
                                const totalGameTime = maxPeriod <= 4 ? 2400 : 2400 + (maxPeriod - 4) * 300;

                                // SVG dimensions
                                const chartWidth = 800;
                                const chartHeight = 200;
                                const padding = { left: 50, right: 20, top: 20, bottom: 30 };

                                // Scale functions
                                const xScale = (elapsed) => padding.left + ((elapsed || 0) / totalGameTime) * (chartWidth - padding.left - padding.right);
                                const yScaleMargin = (margin) => padding.top + ((maxMargin - margin) / (2 * maxMargin)) * (chartHeight - padding.top - padding.bottom);
                                const yScaleScore = (score) => padding.top + ((maxPoints - score) / maxPoints) * (chartHeight - padding.top - padding.bottom);

                                // Create SVG path for margin chart
                                const createMarginPath = () => {
                                    if (gameFlowData.length === 0) return '';
                                    const points = gameFlowData.map(d => `${xScale(d.elapsed)},${yScaleMargin(d.margin || 0)}`);
                                    return `M${points.join(' L')}`;
                                };

                                // Create SVG paths for score chart
                                const createScorePath = (isHome) => {
                                    if (gameFlowData.length === 0) return '';
                                    const points = gameFlowData.map(d => `${xScale(d.elapsed)},${yScaleScore(isHome ? (d.homePoints || 0) : (d.awayPoints || 0))}`);
                                    return `M${points.join(' L')}`;
                                };

                                // Create SVG area fill for margin chart
                                const createMarginArea = () => {
                                    if (gameFlowData.length === 0) return '';
                                    const zeroY = yScaleMargin(0);
                                    const points = gameFlowData.map(d => `${xScale(d.elapsed)},${yScaleMargin(d.margin || 0)}`);
                                    const lastX = xScale(gameFlowData[gameFlowData.length - 1]?.elapsed || 0);
                                    const firstX = xScale(gameFlowData[0]?.elapsed || 0);
                                    return `M${firstX},${zeroY} L${points.join(' L')} L${lastX},${zeroY} Z`;
                                };

                                // Period markers
                                const periodMarkers = [];
                                for (let i = 1; i <= maxPeriod; i++) {
                                    const periodEnd = i <= 4 ? i * 600 : 2400 + (i - 4) * 300;
                                    periodMarkers.push({ x: xScale(periodEnd), label: i <= 4 ? `Q${i}` : `OT${i - 4}` });
                                }

                                // Find lead changes
                                let leadChanges = 0;
                                let timesTied = 0;
                                let prevMargin = 0;
                                gameFlowData.forEach((d, i) => {
                                    if (i > 0 && d.margin !== undefined) {
                                        if ((prevMargin > 0 && d.margin < 0) || (prevMargin < 0 && d.margin > 0)) leadChanges++;
                                        if (d.margin === 0 && prevMargin !== 0) timesTied++;
                                    }
                                    prevMargin = d.margin || 0;
                                });

                                // Find largest lead for each team
                                let maxHomeLead = 0, maxAwayLead = 0, maxHomeLeadTime = 0, maxAwayLeadTime = 0;
                                gameFlowData.forEach(d => {
                                    if ((d.margin || 0) > maxHomeLead) {
                                        maxHomeLead = d.margin;
                                        maxHomeLeadTime = d.elapsed;
                                    }
                                    if ((d.margin || 0) < maxAwayLead) {
                                        maxAwayLead = d.margin;
                                        maxAwayLeadTime = d.elapsed;
                                    }
                                });

                                const formatTime = (elapsed) => {
                                    const period = elapsed <= 2400 ? Math.floor(elapsed / 600) + 1 : 5 + Math.floor((elapsed - 2400) / 300);
                                    const periodTime = elapsed <= 2400 ? elapsed % 600 : (elapsed - 2400) % 300;
                                    const mins = Math.floor(periodTime / 60);
                                    const secs = periodTime % 60;
                                    return `Q${Math.min(period, 4)} ${mins}:${secs.toString().padStart(2, '0')}`;
                                };

                                return e('div', null,
                                    // Summary stats row
                                    e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '12px', marginBottom: '20px' }},
                                        e('div', { className: 'gv-stat-card', style: { textAlign: 'center', padding: '12px' }},
                                            e('div', { style: { fontSize: '24px', fontWeight: '800', color: 'var(--gv-text-bright)' }}, leadChanges),
                                            e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, 'Lead Changes')
                                        ),
                                        e('div', { className: 'gv-stat-card', style: { textAlign: 'center', padding: '12px' }},
                                            e('div', { style: { fontSize: '24px', fontWeight: '800', color: 'var(--gv-text-bright)' }}, timesTied),
                                            e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, 'Times Tied')
                                        ),
                                        e('div', { className: 'gv-stat-card', style: { textAlign: 'center', padding: '12px' }},
                                            e('div', { style: { fontSize: '24px', fontWeight: '800', color: 'var(--gv-team-home)' }}, '+' + maxHomeLead),
                                            e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, homeTeam + ' Largest Lead')
                                        ),
                                        e('div', { className: 'gv-stat-card', style: { textAlign: 'center', padding: '12px' }},
                                            e('div', { style: { fontSize: '24px', fontWeight: '800', color: 'var(--gv-team-away)' }}, '+' + Math.abs(maxAwayLead)),
                                            e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, awayTeam + ' Largest Lead')
                                        )
                                    ),

                                    // Score Margin SVG Chart
                                    e('div', { className: 'gv-stat-card full-width', style: { marginBottom: '20px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '📉 Score Margin Over Time'),
                                            e('div', { style: { display: 'flex', gap: '16px', fontSize: '11px' }},
                                                e('span', { style: { color: 'var(--gv-team-home)' }}, '▲ ' + homeTeam + ' leading'),
                                                e('span', { style: { color: 'var(--gv-team-away)' }}, '▼ ' + awayTeam + ' leading')
                                            )
                                        ),
                                        gameFlowData.length === 0 ?
                                            e('div', { style: { padding: '40px', textAlign: 'center', color: 'var(--gv-text-muted)' }}, 'No game flow data available') :
                                            e('div', { style: { padding: '16px', overflowX: 'auto' }},
                                                e('svg', { width: chartWidth, height: chartHeight, style: { display: 'block', margin: '0 auto' }},
                                                    // Background gradient definitions
                                                    e('defs', null,
                                                        e('linearGradient', { id: 'marginGradient', x1: '0%', y1: '0%', x2: '0%', y2: '100%' },
                                                            e('stop', { offset: '0%', stopColor: '#00d4ff', stopOpacity: 0.3 }),
                                                            e('stop', { offset: '50%', stopColor: 'transparent', stopOpacity: 0 }),
                                                            e('stop', { offset: '100%', stopColor: '#ff00aa', stopOpacity: 0.3 })
                                                        )
                                                    ),
                                                    // Grid lines
                                                    e('g', { className: 'grid-lines' },
                                                        // Horizontal grid
                                                        [-maxMargin, -maxMargin/2, 0, maxMargin/2, maxMargin].map((v, i) =>
                                                            e('line', { key: 'h'+i, x1: padding.left, x2: chartWidth - padding.right,
                                                                y1: yScaleMargin(v), y2: yScaleMargin(v),
                                                                stroke: v === 0 ? 'var(--gv-border-primary)' : 'var(--gv-border-subtle)',
                                                                strokeWidth: v === 0 ? 2 : 1, strokeDasharray: v === 0 ? '' : '4,4'
                                                            })
                                                        ),
                                                        // Period dividers
                                                        periodMarkers.map((p, i) =>
                                                            e('line', { key: 'v'+i, x1: p.x, x2: p.x, y1: padding.top, y2: chartHeight - padding.bottom,
                                                                stroke: 'var(--gv-border-subtle)', strokeWidth: 1, strokeDasharray: '4,4'
                                                            })
                                                        )
                                                    ),
                                                    // Y-axis labels
                                                    e('g', { className: 'y-labels', style: { fontSize: '10px', fill: 'var(--gv-text-muted)' }},
                                                        e('text', { x: padding.left - 8, y: yScaleMargin(maxMargin), textAnchor: 'end', dominantBaseline: 'middle' }, '+' + maxMargin),
                                                        e('text', { x: padding.left - 8, y: yScaleMargin(0), textAnchor: 'end', dominantBaseline: 'middle' }, '0'),
                                                        e('text', { x: padding.left - 8, y: yScaleMargin(-maxMargin), textAnchor: 'end', dominantBaseline: 'middle' }, '-' + maxMargin)
                                                    ),
                                                    // X-axis labels (periods)
                                                    e('g', { className: 'x-labels', style: { fontSize: '10px', fill: 'var(--gv-text-muted)' }},
                                                        periodMarkers.map((p, i) =>
                                                            e('text', { key: i, x: p.x - 30, y: chartHeight - 10, textAnchor: 'middle' }, p.label)
                                                        )
                                                    ),
                                                    // Area fill
                                                    e('path', { d: createMarginArea(), fill: 'url(#marginGradient)', opacity: 0.5 }),
                                                    // Margin line
                                                    e('path', { d: createMarginPath(), fill: 'none', stroke: 'var(--gv-accent-cyan)', strokeWidth: 2.5 })
                                                ),
                                                // Final score display
                                                e('div', { style: { display: 'flex', justifyContent: 'center', gap: '40px', marginTop: '16px' }},
                                                    e('div', { style: { textAlign: 'center' }},
                                                        e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)' }}, 'Final Score'),
                                                        e('div', { style: { fontSize: '24px', fontWeight: '800' }},
                                                            e('span', { style: { color: 'var(--gv-team-home)' }}, lastFlow.homePoints || 0),
                                                            e('span', { style: { color: 'var(--gv-text-muted)', margin: '0 8px' }}, '-'),
                                                            e('span', { style: { color: 'var(--gv-team-away)' }}, lastFlow.awayPoints || 0)
                                                        )
                                                    ),
                                                    e('div', { style: { textAlign: 'center' }},
                                                        e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)' }}, 'Final Margin'),
                                                        e('div', { style: { fontSize: '24px', fontWeight: '800', color: (lastFlow.margin || 0) >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                            ((lastFlow.margin || 0) >= 0 ? '+' : '') + (lastFlow.margin || 0)
                                                        )
                                                    )
                                                )
                                            )
                                    ),

                                    // Cumulative Score Chart
                                    e('div', { className: 'gv-stat-card full-width', style: { marginBottom: '20px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '📈 Cumulative Score'),
                                            e('div', { style: { display: 'flex', gap: '16px', fontSize: '11px' }},
                                                e('span', { style: { color: 'var(--gv-team-home)' }}, '━ ' + homeTeam),
                                                e('span', { style: { color: 'var(--gv-team-away)' }}, '━ ' + awayTeam)
                                            )
                                        ),
                                        gameFlowData.length === 0 ?
                                            e('div', { style: { padding: '40px', textAlign: 'center', color: 'var(--gv-text-muted)' }}, 'No game flow data available') :
                                            e('div', { style: { padding: '16px', overflowX: 'auto' }},
                                                e('svg', { width: chartWidth, height: chartHeight, style: { display: 'block', margin: '0 auto' }},
                                                    // Grid lines
                                                    e('g', { className: 'grid-lines' },
                                                        // Horizontal grid
                                                        [0, maxPoints/4, maxPoints/2, maxPoints*3/4, maxPoints].map((v, i) =>
                                                            e('line', { key: 'h'+i, x1: padding.left, x2: chartWidth - padding.right,
                                                                y1: yScaleScore(v), y2: yScaleScore(v),
                                                                stroke: 'var(--gv-border-subtle)', strokeWidth: 1, strokeDasharray: '4,4'
                                                            })
                                                        ),
                                                        // Period dividers
                                                        periodMarkers.map((p, i) =>
                                                            e('line', { key: 'v'+i, x1: p.x, x2: p.x, y1: padding.top, y2: chartHeight - padding.bottom,
                                                                stroke: 'var(--gv-border-subtle)', strokeWidth: 1, strokeDasharray: '4,4'
                                                            })
                                                        )
                                                    ),
                                                    // Y-axis labels
                                                    e('g', { className: 'y-labels', style: { fontSize: '10px', fill: 'var(--gv-text-muted)' }},
                                                        e('text', { x: padding.left - 8, y: yScaleScore(maxPoints), textAnchor: 'end', dominantBaseline: 'middle' }, maxPoints),
                                                        e('text', { x: padding.left - 8, y: yScaleScore(maxPoints/2), textAnchor: 'end', dominantBaseline: 'middle' }, Math.round(maxPoints/2)),
                                                        e('text', { x: padding.left - 8, y: yScaleScore(0), textAnchor: 'end', dominantBaseline: 'middle' }, '0')
                                                    ),
                                                    // X-axis labels
                                                    e('g', { className: 'x-labels', style: { fontSize: '10px', fill: 'var(--gv-text-muted)' }},
                                                        periodMarkers.map((p, i) =>
                                                            e('text', { key: i, x: p.x - 30, y: chartHeight - 10, textAnchor: 'middle' }, p.label)
                                                        )
                                                    ),
                                                    // Score lines
                                                    e('path', { d: createScorePath(true), fill: 'none', stroke: 'var(--gv-team-home)', strokeWidth: 2.5 }),
                                                    e('path', { d: createScorePath(false), fill: 'none', stroke: 'var(--gv-team-away)', strokeWidth: 2.5 })
                                                )
                                            )
                                    ),

                                    // Scoring Runs
                                    e('div', { className: 'gv-stat-card full-width', style: { marginBottom: '20px' }},
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '🔥 Scoring Runs (6+ pts)'),
                                            e('span', { style: { fontSize: '11px', color: 'var(--gv-text-muted)' }}, teamMomentumRuns.length + ' runs detected')
                                        ),
                                        teamMomentumRuns.length === 0 ?
                                            e('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--gv-text-muted)' }}, 'No major scoring runs detected') :
                                            e('div', { style: { maxHeight: '300px', overflowY: 'auto' }},
                                                teamMomentumRuns.sort((a, b) => b.points - a.points).slice(0, 15).map((run, i) => {
                                                    const isHome = run.teamIdx === 0;
                                                    const teamColor = isHome ? 'var(--gv-team-home)' : 'var(--gv-team-away)';
                                                    const period = run.startElapsed < 600 ? 'Q1' : run.startElapsed < 1200 ? 'Q2' : run.startElapsed < 1800 ? 'Q3' : run.startElapsed < 2400 ? 'Q4' : 'OT';
                                                    const swingAmount = run.points;

                                                    return e('div', { key: i, style: {
                                                        display: 'flex', alignItems: 'center', gap: '12px', padding: '10px 16px',
                                                        borderBottom: '1px solid var(--gv-border-subtle)',
                                                        background: i < 3 ? (isHome ? 'rgba(0, 212, 255, 0.08)' : 'rgba(255, 0, 170, 0.08)') : 'transparent'
                                                    }},
                                                        e('div', { style: { fontSize: '12px', fontWeight: '700', color: 'var(--gv-text-muted)', minWidth: '32px' }}, '#' + (i + 1)),
                                                        e('div', { style: { fontSize: '24px', fontWeight: '800', color: teamColor, minWidth: '60px' }}, run.points + '-0'),
                                                        e('div', { style: { flex: 1 }},
                                                            e('div', { style: { fontWeight: '600', color: teamColor }}, run.team),
                                                            e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)' }},
                                                                period + ' • Score: ' + run.startHomeScore + '-' + run.startAwayScore + ' → ' + run.endHomeScore + '-' + run.endAwayScore
                                                            )
                                                        ),
                                                        e('div', { style: { textAlign: 'right', minWidth: '80px' }},
                                                            e('div', { style: { fontSize: '14px', fontWeight: '700', color: teamColor }}, '+' + swingAmount + ' swing'),
                                                            run.topScorerName && e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }},
                                                                run.topScorerName + ' (' + run.topScorerPoints + 'pts)'
                                                            )
                                                        )
                                                    );
                                                })
                                            )
                                    ),

                                    // PPP Development with chart
                                    gameFlowData.length > 0 && e('div', { className: 'gv-stat-card full-width' },
                                        e('div', { className: 'gv-card-header' },
                                            e('span', { className: 'gv-card-title' }, '📊 Points Per Possession (PPP)')
                                        ),
                                        e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px', padding: '16px' }},
                                            e('div', { style: { textAlign: 'center', padding: '20px', background: 'var(--gv-bg-glass)', borderRadius: '12px' }},
                                                e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)', marginBottom: '8px' }}, homeTeam),
                                                e('div', { style: { fontSize: '36px', fontWeight: '800', color: 'var(--gv-team-home)', fontFamily: "'Space Mono', monospace" }},
                                                    (lastFlow.homePPP || 0).toFixed(3)
                                                ),
                                                e('div', { style: { fontSize: '11px', color: (lastFlow.homePPP || 0) >= 1.0 ? 'var(--gv-positive)' : 'var(--gv-negative)', marginTop: '4px' }},
                                                    (lastFlow.homePPP || 0) >= 1.0 ? '● Above average' : '● Below average'
                                                )
                                            ),
                                            e('div', { style: { textAlign: 'center', padding: '20px', background: 'var(--gv-bg-glass)', borderRadius: '12px' }},
                                                e('div', { style: { fontSize: '11px', color: 'var(--gv-text-muted)', marginBottom: '8px' }}, awayTeam),
                                                e('div', { style: { fontSize: '36px', fontWeight: '800', color: 'var(--gv-team-away)', fontFamily: "'Space Mono', monospace" }},
                                                    (lastFlow.awayPPP || 0).toFixed(3)
                                                ),
                                                e('div', { style: { fontSize: '11px', color: (lastFlow.awayPPP || 0) >= 1.0 ? 'var(--gv-positive)' : 'var(--gv-negative)', marginTop: '4px' }},
                                                    (lastFlow.awayPPP || 0) >= 1.0 ? '● Above average' : '● Below average'
                                                )
                                            )
                                        )
                                    ),

                                    // Scoring Battle Chart (eFG% + FT Rate) - matches GAMEVIS
                                    gameFlowData.length > 1 && (() => {
                                        // Buffer the chart until both teams have scored
                                        const firstBothScoredIndex = gameFlowData.findIndex(d => d.homePoints > 0 && d.awayPoints > 0);
                                        const data = firstBothScoredIndex >= 0 ? gameFlowData.slice(firstBothScoredIndex) : gameFlowData;
                                        if (data.length < 2) return null;

                                        // Use actual max elapsed from data like GAMEVIS does
                                        const maxElapsed = Math.max(...gameFlowData.map(d => d.elapsed || 0), 1);

                                        const maxSB = Math.max(...data.map(d => Math.abs(d.scoringBattle || 0)), 5);
                                        const sbYMax = Math.max(5, Math.ceil(maxSB) + 2);
                                        const finalSB = data[data.length - 1].scoringBattle || 0;
                                        const finalEfgMargin = data[data.length - 1].efgMargin || 0;
                                        const finalFtRateMargin = data[data.length - 1].ftRateMargin || 0;

                                        // Chart dimensions matching GAMEVIS
                                        const sbWidth = 800;
                                        const sbHeight = 240;
                                        const sbPadding = { top: 20, right: 60, bottom: 40, left: 50 };
                                        const sbChartWidth = sbWidth - sbPadding.left - sbPadding.right;
                                        const sbChartHeight = sbHeight - sbPadding.top - sbPadding.bottom;
                                        const sbZeroY = sbPadding.top + sbChartHeight / 2;

                                        // Generate segmented line paths (color changes when crossing zero)
                                        const generateSegmentedPaths = (points, valueKey) => {
                                            const paths = [];
                                            let currentPath = '';
                                            let currentClass = null;

                                            for (let i = 0; i < points.length; i++) {
                                                const p = points[i];
                                                const value = p[valueKey];
                                                const newClass = value >= 0 ? 'home' : 'away';

                                                if (i === 0) {
                                                    currentPath = `M ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                                                    currentClass = newClass;
                                                } else {
                                                    const prevP = points[i - 1];
                                                    const prevValue = prevP[valueKey];

                                                    if ((prevValue >= 0 && value < 0) || (prevValue < 0 && value >= 0)) {
                                                        const ratio = Math.abs(prevValue) / (Math.abs(prevValue) + Math.abs(value));
                                                        const crossX = prevP.x + ratio * (p.x - prevP.x);
                                                        const crossY = prevP.y + ratio * (p.y - prevP.y);

                                                        currentPath += ` L ${crossX.toFixed(1)} ${crossY.toFixed(1)}`;
                                                        paths.push({ d: currentPath, className: currentClass });

                                                        currentPath = `M ${crossX.toFixed(1)} ${crossY.toFixed(1)} L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                                                        currentClass = newClass;
                                                    } else {
                                                        currentPath += ` L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                                                    }
                                                }
                                            }

                                            if (currentPath) {
                                                paths.push({ d: currentPath, className: currentClass });
                                            }

                                            return paths;
                                        };

                                        const sbPoints = data.map(d => {
                                            const x = sbPadding.left + ((d.elapsed || 0) / maxElapsed) * sbChartWidth;
                                            const sb = d.scoringBattle || 0;
                                            const y = sbPadding.top + sbChartHeight / 2 - (sb / sbYMax) * (sbChartHeight / 2);
                                            return { x, y, scoringBattle: sb };
                                        });

                                        const sbLinePaths = generateSegmentedPaths(sbPoints, 'scoringBattle');

                                        // Period markers for this chart
                                        const sbPeriodMarkers = [];
                                        for (let i = 1; i <= maxPeriod; i++) {
                                            const periodEnd = i <= 4 ? i * 600 : 2400 + (i - 4) * 300;
                                            if (periodEnd < maxElapsed) {
                                                sbPeriodMarkers.push({
                                                    x: sbPadding.left + (periodEnd / maxElapsed) * sbChartWidth,
                                                    label: i <= 4 ? `Q${i}` : `OT${i - 4}`
                                                });
                                            }
                                        }

                                        return e('div', { className: 'gv-stat-card full-width', style: { marginTop: '20px' }},
                                            e('div', { className: 'gv-card-header' },
                                                e('span', { className: 'gv-card-title' }, '🎯 Scoring Battle (eFG% + FT Rate)'),
                                                e('div', { style: { display: 'flex', gap: '16px', fontSize: '11px' }},
                                                    e('span', { style: { color: 'var(--gv-team-home)' }}, '▲ ' + homeTeam + ' Advantage'),
                                                    e('span', { style: { color: 'var(--gv-team-away)' }}, '▼ ' + awayTeam + ' Advantage')
                                                )
                                            ),
                                            e('div', { style: { fontSize: '11px', color: 'var(--gv-text-secondary)', marginBottom: '8px', padding: '0 16px' }},
                                                'SB = (eFG% Margin × 1.77 + FT Rate Margin × 0.25) × Pace/100 | ',
                                                e('span', { style: { color: finalEfgMargin >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    'eFG%: ' + (finalEfgMargin >= 0 ? '+' : '') + finalEfgMargin.toFixed(1)
                                                ),
                                                ' | ',
                                                e('span', { style: { color: finalFtRateMargin >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    'FT Rate: ' + (finalFtRateMargin >= 0 ? '+' : '') + finalFtRateMargin.toFixed(1)
                                                )
                                            ),
                                            e('div', { style: { padding: '16px', overflowX: 'auto' }},
                                                e('svg', { width: sbWidth, height: sbHeight, style: { display: 'block', margin: '0 auto' }},
                                                    // Grid lines
                                                    e('g', { className: 'grid-lines' },
                                                        [-sbYMax, -sbYMax/2, 0, sbYMax/2, sbYMax].map((v, i) =>
                                                            e('line', { key: 'h'+i, x1: sbPadding.left, x2: sbWidth - sbPadding.right,
                                                                y1: sbPadding.top + sbChartHeight / 2 - (v / sbYMax) * (sbChartHeight / 2),
                                                                y2: sbPadding.top + sbChartHeight / 2 - (v / sbYMax) * (sbChartHeight / 2),
                                                                stroke: v === 0 ? 'var(--gv-border-primary)' : 'var(--gv-border-subtle)',
                                                                strokeWidth: v === 0 ? 2 : 1, strokeDasharray: v === 0 ? '' : '4,4'
                                                            })
                                                        ),
                                                        sbPeriodMarkers.map((p, i) =>
                                                            e('line', { key: 'v'+i, x1: p.x, x2: p.x, y1: sbPadding.top, y2: sbHeight - sbPadding.bottom,
                                                                stroke: 'var(--gv-border-subtle)', strokeWidth: 1, strokeDasharray: '4,4'
                                                            })
                                                        )
                                                    ),
                                                    // Y-axis labels
                                                    e('g', { style: { fontSize: '10px', fill: 'var(--gv-text-muted)' }},
                                                        e('text', { x: sbPadding.left - 8, y: sbPadding.top + 4, textAnchor: 'end' }, '+' + sbYMax.toFixed(0)),
                                                        e('text', { x: sbPadding.left - 8, y: sbZeroY + 4, textAnchor: 'end' }, '0'),
                                                        e('text', { x: sbPadding.left - 8, y: sbHeight - sbPadding.bottom + 4, textAnchor: 'end' }, '-' + sbYMax.toFixed(0))
                                                    ),
                                                    // X-axis labels
                                                    e('g', { style: { fontSize: '10px', fill: 'var(--gv-text-muted)' }},
                                                        sbPeriodMarkers.map((p, i) =>
                                                            e('text', { key: i, x: p.x, y: sbHeight - 8, textAnchor: 'middle' }, p.label)
                                                        )
                                                    ),
                                                    // Zero line
                                                    e('line', { x1: sbPadding.left, x2: sbWidth - sbPadding.right, y1: sbZeroY, y2: sbZeroY,
                                                        stroke: 'var(--gv-border-primary)', strokeWidth: 2 }),
                                                    // Line paths (segmented by positive/negative)
                                                    sbLinePaths.map((path, i) =>
                                                        e('path', { key: i, d: path.d, fill: 'none',
                                                            stroke: path.className === 'home' ? 'var(--gv-team-home)' : 'var(--gv-team-away)',
                                                            strokeWidth: 2.5
                                                        })
                                                    ),
                                                    // End value label
                                                    e('text', {
                                                        x: sbPoints[sbPoints.length - 1].x + 8,
                                                        y: sbPoints[sbPoints.length - 1].y + 4,
                                                        fill: finalSB >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)',
                                                        fontSize: '11', fontWeight: '600'
                                                    }, (finalSB >= 0 ? '+' : '') + finalSB.toFixed(1))
                                                )
                                            )
                                        );
                                    })(),

                                    // Possession Battle (EPA) Chart - matches GAMEVIS
                                    gameFlowData.length > 1 && (() => {
                                        const data = gameFlowData;
                                        if (data.length < 2) return null;

                                        // Use actual max elapsed from data like GAMEVIS does
                                        const maxElapsed = Math.max(...data.map(d => d.elapsed || 0), 1);

                                        const maxEPA = Math.max(...data.map(d => Math.abs(d.epa || 0)), 5);
                                        const epaYMax = Math.max(5, Math.ceil(maxEPA) + 2);
                                        const finalEPA = data[data.length - 1].epa || 0;
                                        const finalToMargin = data[data.length - 1].toMargin || 0;
                                        const finalOrebMargin = data[data.length - 1].orebMargin || 0;

                                        // Chart dimensions matching GAMEVIS
                                        const epaWidth = 800;
                                        const epaHeight = 240;
                                        const epaPadding = { top: 20, right: 60, bottom: 40, left: 50 };
                                        const epaChartWidth = epaWidth - epaPadding.left - epaPadding.right;
                                        const epaChartHeight = epaHeight - epaPadding.top - epaPadding.bottom;
                                        const epaZeroY = epaPadding.top + epaChartHeight / 2;

                                        const generateSegmentedPaths = (points, valueKey) => {
                                            const paths = [];
                                            let currentPath = '';
                                            let currentClass = null;

                                            for (let i = 0; i < points.length; i++) {
                                                const p = points[i];
                                                const value = p[valueKey];
                                                const newClass = value >= 0 ? 'home' : 'away';

                                                if (i === 0) {
                                                    currentPath = `M ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                                                    currentClass = newClass;
                                                } else {
                                                    const prevP = points[i - 1];
                                                    const prevValue = prevP[valueKey];

                                                    if ((prevValue >= 0 && value < 0) || (prevValue < 0 && value >= 0)) {
                                                        const ratio = Math.abs(prevValue) / (Math.abs(prevValue) + Math.abs(value));
                                                        const crossX = prevP.x + ratio * (p.x - prevP.x);
                                                        const crossY = prevP.y + ratio * (p.y - prevP.y);

                                                        currentPath += ` L ${crossX.toFixed(1)} ${crossY.toFixed(1)}`;
                                                        paths.push({ d: currentPath, className: currentClass });

                                                        currentPath = `M ${crossX.toFixed(1)} ${crossY.toFixed(1)} L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                                                        currentClass = newClass;
                                                    } else {
                                                        currentPath += ` L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`;
                                                    }
                                                }
                                            }

                                            if (currentPath) {
                                                paths.push({ d: currentPath, className: currentClass });
                                            }

                                            return paths;
                                        };

                                        const epaPoints = data.map(d => {
                                            const x = epaPadding.left + ((d.elapsed || 0) / maxElapsed) * epaChartWidth;
                                            const epa = d.epa || 0;
                                            const y = epaPadding.top + epaChartHeight / 2 - (epa / epaYMax) * (epaChartHeight / 2);
                                            return { x, y, epa: epa };
                                        });

                                        const epaLinePaths = generateSegmentedPaths(epaPoints, 'epa');

                                        // Period markers for this chart
                                        const epaPeriodMarkers = [];
                                        for (let i = 1; i <= maxPeriod; i++) {
                                            const periodEnd = i <= 4 ? i * 600 : 2400 + (i - 4) * 300;
                                            if (periodEnd < maxElapsed) {
                                                epaPeriodMarkers.push({
                                                    x: epaPadding.left + (periodEnd / maxElapsed) * epaChartWidth,
                                                    label: i <= 4 ? `Q${i}` : `OT${i - 4}`
                                                });
                                            }
                                        }

                                        return e('div', { className: 'gv-stat-card full-width', style: { marginTop: '20px' }},
                                            e('div', { className: 'gv-card-header' },
                                                e('span', { className: 'gv-card-title' }, '⚔️ Possession Battle (EPA)'),
                                                e('div', { style: { display: 'flex', gap: '16px', fontSize: '11px' }},
                                                    e('span', { style: { color: 'var(--gv-team-home)' }}, '▲ ' + homeTeam + ' Advantage'),
                                                    e('span', { style: { color: 'var(--gv-team-away)' }}, '▼ ' + awayTeam + ' Advantage')
                                                )
                                            ),
                                            e('div', { style: { fontSize: '11px', color: 'var(--gv-text-secondary)', marginBottom: '8px', padding: '0 16px' }},
                                                'EPA = (TO Margin + OREB Margin) × 1.05 PPP | ',
                                                e('span', { style: { color: finalToMargin >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    'TO: ' + (finalToMargin >= 0 ? '+' : '') + finalToMargin
                                                ),
                                                ' | ',
                                                e('span', { style: { color: finalOrebMargin >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)' }},
                                                    'OREB: ' + (finalOrebMargin >= 0 ? '+' : '') + finalOrebMargin
                                                )
                                            ),
                                            e('div', { style: { padding: '16px', overflowX: 'auto' }},
                                                e('svg', { width: epaWidth, height: epaHeight, style: { display: 'block', margin: '0 auto' }},
                                                    // Grid lines
                                                    e('g', { className: 'grid-lines' },
                                                        [-epaYMax, -epaYMax/2, 0, epaYMax/2, epaYMax].map((v, i) =>
                                                            e('line', { key: 'h'+i, x1: epaPadding.left, x2: epaWidth - epaPadding.right,
                                                                y1: epaPadding.top + epaChartHeight / 2 - (v / epaYMax) * (epaChartHeight / 2),
                                                                y2: epaPadding.top + epaChartHeight / 2 - (v / epaYMax) * (epaChartHeight / 2),
                                                                stroke: v === 0 ? 'var(--gv-border-primary)' : 'var(--gv-border-subtle)',
                                                                strokeWidth: v === 0 ? 2 : 1, strokeDasharray: v === 0 ? '' : '4,4'
                                                            })
                                                        ),
                                                        epaPeriodMarkers.map((p, i) =>
                                                            e('line', { key: 'v'+i, x1: p.x, x2: p.x, y1: epaPadding.top, y2: epaHeight - epaPadding.bottom,
                                                                stroke: 'var(--gv-border-subtle)', strokeWidth: 1, strokeDasharray: '4,4'
                                                            })
                                                        )
                                                    ),
                                                    // Y-axis labels
                                                    e('g', { style: { fontSize: '10px', fill: 'var(--gv-text-muted)' }},
                                                        e('text', { x: epaPadding.left - 8, y: epaPadding.top + 4, textAnchor: 'end' }, '+' + epaYMax.toFixed(0)),
                                                        e('text', { x: epaPadding.left - 8, y: epaZeroY + 4, textAnchor: 'end' }, '0'),
                                                        e('text', { x: epaPadding.left - 8, y: epaHeight - epaPadding.bottom + 4, textAnchor: 'end' }, '-' + epaYMax.toFixed(0))
                                                    ),
                                                    // X-axis labels
                                                    e('g', { style: { fontSize: '10px', fill: 'var(--gv-text-muted)' }},
                                                        epaPeriodMarkers.map((p, i) =>
                                                            e('text', { key: i, x: p.x, y: epaHeight - 8, textAnchor: 'middle' }, p.label)
                                                        )
                                                    ),
                                                    // Zero line
                                                    e('line', { x1: epaPadding.left, x2: epaWidth - epaPadding.right, y1: epaZeroY, y2: epaZeroY,
                                                        stroke: 'var(--gv-border-primary)', strokeWidth: 2 }),
                                                    // Line paths (segmented by positive/negative)
                                                    epaLinePaths.map((path, i) =>
                                                        e('path', { key: i, d: path.d, fill: 'none',
                                                            stroke: path.className === 'home' ? 'var(--gv-team-home)' : 'var(--gv-team-away)',
                                                            strokeWidth: 2.5
                                                        })
                                                    ),
                                                    // End value label
                                                    e('text', {
                                                        x: epaPoints[epaPoints.length - 1].x + 8,
                                                        y: epaPoints[epaPoints.length - 1].y + 4,
                                                        fill: finalEPA >= 0 ? 'var(--gv-team-home)' : 'var(--gv-team-away)',
                                                        fontSize: '11', fontWeight: '600'
                                                    }, (finalEPA >= 0 ? '+' : '') + finalEPA.toFixed(1))
                                                )
                                            )
                                        );
                                    })()
                                );
                            })(),

                            // Tab Content - Lineups (Real lineup tracking data with Four Factors)
                            gvActiveTab === 'lineups' && gvCurrentGame.teamsData && (() => {
                                const teamKeys = Object.keys(gvCurrentGame.teamsData);
                                if (teamKeys.length < 2) return e('div', null, 'No data');

                                const lineupStats = gvCurrentGame.lineupStats || {};
                                const playerRoster = gvCurrentGame.playerRoster || {};
                                const homeTeam = teamKeys[0];
                                const awayTeam = teamKeys[1];
                                const lineupTeamFilter = gvLineupTeamFilter;
                                const setLineupTeamFilter = setGvLineupTeamFilter;
                                const lineupSortBy = gvLineupSortBy;
                                const setLineupSortBy = setGvLineupSortBy;
                                const lineupViewMode = gvLineupViewMode;
                                const setLineupViewMode = setGvLineupViewMode;

                                // Process lineups with full Four Factors
                                const processLineups = (teamIdx) => {
                                    const teamName = teamIdx === 0 ? homeTeam : awayTeam;
                                    return Object.entries(lineupStats)
                                        .filter(([key]) => key.startsWith(teamIdx + '|'))
                                        .map(([key, stats]) => {
                                            const playerNums = key.split('|')[1].split(',');
                                            const playerNames = playerNums.map(n => playerRoster[teamName]?.[n] || '#' + n);
                                            const minutes = stats.seconds / 60;

                                            // Offensive Four Factors
                                            const poss = 0.96 * ((stats.fga || 0) + (stats.tov || 0) + 0.44 * (stats.fta || 0) - (stats.oreb || 0));
                                            const offEfg = (stats.fga || 0) > 0 ? (((stats.fgm || 0) + 0.5 * (stats.fg3m || 0)) / (stats.fga || 0) * 100) : 0;
                                            const offTovPct = ((stats.fga || 0) + 0.44 * (stats.fta || 0) + (stats.tov || 0)) > 0 ?
                                                ((stats.tov || 0) / ((stats.fga || 0) + 0.44 * (stats.fta || 0) + (stats.tov || 0)) * 100) : 0;
                                            const offOrebPct = ((stats.oreb || 0) + (stats.defOrebAllowed || 0)) > 0 ?
                                                ((stats.oreb || 0) / ((stats.oreb || 0) + (stats.defOrebAllowed || 0)) * 100) : 0;
                                            const offFtRate = (stats.fga || 0) > 0 ? ((stats.fta || 0) / (stats.fga || 0) * 100) : 0;
                                            const ortg = poss > 0 ? ((stats.points || 0) / poss * 100) : 0;

                                            // Defensive Four Factors
                                            const defPoss = 0.96 * ((stats.defFga || 0) + (stats.forcedTov || 0) + 0.44 * (stats.defFta || 0) - (stats.defOrebAllowed || 0));
                                            const defEfg = (stats.defFga || 0) > 0 ?
                                                (((stats.defFgm || 0) + 0.5 * (stats.defFg3m || 0)) / (stats.defFga || 0) * 100) : 0;
                                            const defTovPct = ((stats.defFga || 0) + 0.44 * (stats.defFta || 0) + (stats.forcedTov || 0)) > 0 ?
                                                ((stats.forcedTov || 0) / ((stats.defFga || 0) + 0.44 * (stats.defFta || 0) + (stats.forcedTov || 0)) * 100) : 0;
                                            const defOrebPctAllowed = ((stats.defOrebAllowed || 0) + (stats.dreb || 0)) > 0 ?
                                                ((stats.defOrebAllowed || 0) / ((stats.defOrebAllowed || 0) + (stats.dreb || 0)) * 100) : 0;
                                            const defFtRate = (stats.defFga || 0) > 0 ? ((stats.defFta || 0) / (stats.defFga || 0) * 100) : 0;
                                            const drtg = defPoss > 0 ? ((stats.pointsAllowed || 0) / defPoss * 100) : 0;

                                            const netRtg = ortg - drtg;
                                            const plusMinus = (stats.points || 0) - (stats.pointsAllowed || 0);

                                            return {
                                                key, playerNums, playerNames, stats, teamName, teamIdx, minutes, poss, defPoss,
                                                ortg, drtg, netRtg, plusMinus,
                                                offEfg, offTovPct, offOrebPct, offFtRate,
                                                defEfg, defTovPct, defOrebPctAllowed, defFtRate
                                            };
                                        })
                                        .filter(l => l.minutes >= 1);
                                };

                                const homeLineups = processLineups(0);
                                const awayLineups = processLineups(1);
                                const allLineups = [...homeLineups, ...awayLineups];

                                // Apply filters and sorting
                                let filteredLineups = lineupTeamFilter === 'all' ? allLineups :
                                    lineupTeamFilter === 'home' ? homeLineups : awayLineups;

                                filteredLineups = [...filteredLineups].sort((a, b) => {
                                    if (lineupSortBy === 'minutes') return b.minutes - a.minutes;
                                    if (lineupSortBy === 'netRtg') return b.netRtg - a.netRtg;
                                    if (lineupSortBy === 'plusMinus') return b.plusMinus - a.plusMinus;
                                    if (lineupSortBy === 'ortg') return b.ortg - a.ortg;
                                    if (lineupSortBy === 'drtg') return a.drtg - b.drtg;
                                    return b.minutes - a.minutes;
                                });

                                // Helper for coloring values
                                const getValueClass = (val, goodThreshold, badThreshold, lowerBetter = false) => {
                                    if (lowerBetter) {
                                        return val <= goodThreshold ? 'var(--gv-positive)' : val >= badThreshold ? 'var(--gv-negative)' : 'var(--gv-text-secondary)';
                                    } else {
                                        return val >= goodThreshold ? 'var(--gv-positive)' : val <= badThreshold ? 'var(--gv-negative)' : 'var(--gv-text-secondary)';
                                    }
                                };

                                // Net rating background gradient
                                const getNetRatingBackground = (netRtg) => {
                                    const clampedRtg = Math.max(-30, Math.min(30, netRtg));
                                    const intensity = Math.abs(clampedRtg) / 30;
                                    if (netRtg >= 0) {
                                        return `rgba(0, 255, 136, ${(intensity * 0.18).toFixed(2)})`;
                                    } else {
                                        return `rgba(255, 107, 107, ${(intensity * 0.18).toFixed(2)})`;
                                    }
                                };

                                // Lineup Card Component
                                const LineupCard = ({ lineup }) => {
                                    const isHome = lineup.teamIdx === 0;
                                    const teamColor = isHome ? 'var(--gv-team-home)' : 'var(--gv-team-away)';
                                    const netClass = lineup.netRtg >= 0 ? 'var(--gv-positive)' : 'var(--gv-negative)';

                                    return e('div', { style: {
                                        background: `linear-gradient(135deg, ${getNetRatingBackground(lineup.netRtg)}, var(--gv-bg-elevated))`,
                                        borderRadius: 'var(--gv-radius-md)', padding: '16px', border: '1px solid var(--gv-border-subtle)'
                                    }},
                                        // Header
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '12px' }},
                                            e('div', null,
                                                e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '4px', marginBottom: '8px' }},
                                                    lineup.playerNames.map((name, j) =>
                                                        e('span', { key: j, style: { fontSize: '10px', padding: '3px 8px', background: 'var(--gv-bg-glass)', borderRadius: '4px', border: '1px solid var(--gv-border-subtle)', color: 'var(--gv-text-primary)' }},
                                                            name.split(' ').pop() || name
                                                        )
                                                    )
                                                ),
                                                e('div', { style: { fontSize: '11px', color: teamColor, display: 'flex', alignItems: 'center', gap: '8px' }},
                                                    e('span', { style: { width: '8px', height: '8px', borderRadius: '50%', background: teamColor, display: 'inline-block' }}),
                                                    lineup.teamName,
                                                    e('span', { style: { color: 'var(--gv-text-muted)' }}, ' • ' + lineup.minutes.toFixed(1) + ' min')
                                                )
                                            ),
                                            e('div', { style: { textAlign: 'right' }},
                                                e('div', { style: { fontSize: '28px', fontWeight: '800', color: netClass }},
                                                    (lineup.netRtg >= 0 ? '+' : '') + lineup.netRtg.toFixed(1)
                                                ),
                                                e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, 'Net Rating')
                                            )
                                        ),
                                        // Four Factors Grid
                                        e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }},
                                            // Offense
                                            e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '10px' }},
                                                e('div', { style: { fontSize: '10px', fontWeight: '700', color: 'var(--gv-accent-emerald)', marginBottom: '8px' }}, '⚔️ OFFENSE'),
                                                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px', fontSize: '10px' }},
                                                    e('div', { style: { color: 'var(--gv-text-muted)' }}, 'ORtg'),
                                                    e('div', { style: { textAlign: 'right', fontWeight: '600', color: getValueClass(lineup.ortg, 110, 95) }}, lineup.ortg.toFixed(1)),
                                                    e('div', { style: { color: 'var(--gv-text-muted)' }}, 'eFG%'),
                                                    e('div', { style: { textAlign: 'right', fontWeight: '600', color: getValueClass(lineup.offEfg, 52, 45) }}, lineup.offEfg.toFixed(1) + '%'),
                                                    e('div', { style: { color: 'var(--gv-text-muted)' }}, 'TOV%'),
                                                    e('div', { style: { textAlign: 'right', fontWeight: '600', color: getValueClass(lineup.offTovPct, 12, 18, true) }}, lineup.offTovPct.toFixed(1) + '%'),
                                                    e('div', { style: { color: 'var(--gv-text-muted)' }}, 'OREB%'),
                                                    e('div', { style: { textAlign: 'right', fontWeight: '600', color: getValueClass(lineup.offOrebPct, 30, 20) }}, lineup.offOrebPct.toFixed(1) + '%')
                                                )
                                            ),
                                            // Defense
                                            e('div', { style: { background: 'var(--gv-bg-glass)', borderRadius: '8px', padding: '10px' }},
                                                e('div', { style: { fontSize: '10px', fontWeight: '700', color: 'var(--gv-accent-gold)', marginBottom: '8px' }}, '🛡️ DEFENSE'),
                                                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px', fontSize: '10px' }},
                                                    e('div', { style: { color: 'var(--gv-text-muted)' }}, 'DRtg'),
                                                    e('div', { style: { textAlign: 'right', fontWeight: '600', color: getValueClass(lineup.drtg, 100, 115, true) }}, lineup.drtg.toFixed(1)),
                                                    e('div', { style: { color: 'var(--gv-text-muted)' }}, 'Opp eFG%'),
                                                    e('div', { style: { textAlign: 'right', fontWeight: '600', color: getValueClass(lineup.defEfg, 45, 52, true) }}, lineup.defEfg.toFixed(1) + '%'),
                                                    e('div', { style: { color: 'var(--gv-text-muted)' }}, 'TOV Forced'),
                                                    e('div', { style: { textAlign: 'right', fontWeight: '600', color: getValueClass(lineup.defTovPct, 18, 12) }}, lineup.defTovPct.toFixed(1) + '%'),
                                                    e('div', { style: { color: 'var(--gv-text-muted)' }}, 'OREB Alwd'),
                                                    e('div', { style: { textAlign: 'right', fontWeight: '600', color: getValueClass(lineup.defOrebPctAllowed, 20, 30, true) }}, lineup.defOrebPctAllowed.toFixed(1) + '%')
                                                )
                                            )
                                        ),
                                        // Bottom stats
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', marginTop: '12px', padding: '8px 12px', background: 'var(--gv-bg-base)', borderRadius: '6px' }},
                                            e('div', { style: { textAlign: 'center' }},
                                                e('div', { style: { fontSize: '14px', fontWeight: '700', color: teamColor }}, lineup.stats.points || 0),
                                                e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)' }}, 'PTS')
                                            ),
                                            e('div', { style: { textAlign: 'center' }},
                                                e('div', { style: { fontSize: '14px', fontWeight: '700', color: 'var(--gv-text-secondary)' }}, lineup.stats.pointsAllowed || 0),
                                                e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)' }}, 'PTS ALWD')
                                            ),
                                            e('div', { style: { textAlign: 'center' }},
                                                e('div', { style: { fontSize: '14px', fontWeight: '700', color: lineup.plusMinus >= 0 ? 'var(--gv-positive)' : 'var(--gv-negative)' }},
                                                    (lineup.plusMinus >= 0 ? '+' : '') + lineup.plusMinus
                                                ),
                                                e('div', { style: { fontSize: '9px', color: 'var(--gv-text-muted)' }}, '+/-')
                                            )
                                        )
                                    );
                                };

                                // Find best/worst lineups for summary
                                const bestHomeLineup = homeLineups.length > 0 ? homeLineups.reduce((a, b) => a.netRtg > b.netRtg ? a : b) : null;
                                const worstHomeLineup = homeLineups.length > 0 ? homeLineups.reduce((a, b) => a.netRtg < b.netRtg ? a : b) : null;
                                const bestAwayLineup = awayLineups.length > 0 ? awayLineups.reduce((a, b) => a.netRtg > b.netRtg ? a : b) : null;
                                const worstAwayLineup = awayLineups.length > 0 ? awayLineups.reduce((a, b) => a.netRtg < b.netRtg ? a : b) : null;

                                return e('div', null,
                                    // Filters and view toggle
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px', flexWrap: 'wrap', gap: '12px' }},
                                        e('div', { style: { display: 'flex', gap: '8px' }},
                                            ['all', 'home', 'away'].map(f =>
                                                e('button', {
                                                    key: f, onClick: () => setLineupTeamFilter(f),
                                                    style: {
                                                        padding: '6px 12px', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '11px',
                                                        background: lineupTeamFilter === f ? (f === 'home' ? 'var(--gv-team-home)' : f === 'away' ? 'var(--gv-team-away)' : 'var(--gv-accent-cyan)') : 'var(--gv-bg-elevated)',
                                                        color: lineupTeamFilter === f ? '#000' : 'var(--gv-text-primary)'
                                                    }
                                                }, f === 'all' ? 'All Teams' : f === 'home' ? homeTeam : awayTeam)
                                            )
                                        ),
                                        e('div', { style: { display: 'flex', gap: '8px', alignItems: 'center' }},
                                            e('span', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, 'Sort:'),
                                            e('select', {
                                                value: lineupSortBy,
                                                onChange: (ev) => setLineupSortBy(ev.target.value),
                                                style: { padding: '4px 8px', borderRadius: '4px', background: 'var(--gv-bg-elevated)', border: '1px solid var(--gv-border-subtle)', color: 'var(--gv-text-primary)', fontSize: '11px' }
                                            },
                                                e('option', { value: 'minutes' }, 'Minutes'),
                                                e('option', { value: 'netRtg' }, 'Net Rating'),
                                                e('option', { value: 'plusMinus' }, '+/-'),
                                                e('option', { value: 'ortg' }, 'ORtg'),
                                                e('option', { value: 'drtg' }, 'DRtg')
                                            ),
                                            e('button', {
                                                onClick: () => setLineupViewMode(lineupViewMode === 'cards' ? 'table' : 'cards'),
                                                style: { padding: '4px 8px', borderRadius: '4px', background: 'var(--gv-bg-elevated)', border: '1px solid var(--gv-border-subtle)', color: 'var(--gv-text-primary)', fontSize: '11px', cursor: 'pointer' }
                                            }, lineupViewMode === 'cards' ? '📋 Table' : '🎴 Cards')
                                        )
                                    ),

                                    // Summary row
                                    e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '12px', marginBottom: '20px' }},
                                        e('div', { className: 'gv-stat-card', style: { textAlign: 'center', padding: '12px' }},
                                            e('div', { style: { fontSize: '28px', fontWeight: '800', color: 'var(--gv-team-home)' }}, homeLineups.length),
                                            e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, homeTeam + ' lineups')
                                        ),
                                        e('div', { className: 'gv-stat-card', style: { textAlign: 'center', padding: '12px' }},
                                            e('div', { style: { fontSize: '28px', fontWeight: '800', color: 'var(--gv-team-away)' }}, awayLineups.length),
                                            e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, awayTeam + ' lineups')
                                        ),
                                        e('div', { className: 'gv-stat-card', style: { textAlign: 'center', padding: '12px' }},
                                            e('div', { style: { fontSize: '20px', fontWeight: '800', color: 'var(--gv-positive)' }},
                                                bestHomeLineup ? '+' + bestHomeLineup.netRtg.toFixed(0) : '-'
                                            ),
                                            e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, 'Best ' + homeTeam.split(' ').pop())
                                        ),
                                        e('div', { className: 'gv-stat-card', style: { textAlign: 'center', padding: '12px' }},
                                            e('div', { style: { fontSize: '20px', fontWeight: '800', color: 'var(--gv-positive)' }},
                                                bestAwayLineup ? '+' + bestAwayLineup.netRtg.toFixed(0) : '-'
                                            ),
                                            e('div', { style: { fontSize: '10px', color: 'var(--gv-text-muted)' }}, 'Best ' + awayTeam.split(' ').pop())
                                        )
                                    ),

                                    // Lineup display (cards or table)
                                    filteredLineups.length === 0 ?
                                        e('div', { className: 'gv-stat-card full-width', style: { padding: '40px', textAlign: 'center', color: 'var(--gv-text-muted)' }},
                                            'No lineup data available'
                                        ) :
                                        lineupViewMode === 'cards' ?
                                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(320px, 1fr))', gap: '16px' }},
                                                filteredLineups.slice(0, 20).map((l, i) =>
                                                    e(LineupCard, { key: i, lineup: l })
                                                )
                                            ) :
                                            e('div', { className: 'gv-stat-card full-width' },
                                                e('div', { style: { overflowX: 'auto' }},
                                                    e('table', { className: 'gv-player-table', style: { fontSize: '10px' }},
                                                        e('thead', null,
                                                            e('tr', null,
                                                                ['Team', 'Lineup', 'MIN', 'PTS', 'ORtg', 'DRtg', 'Net', 'eFG%', 'TOV%', 'OREB%', '+/-'].map((h, i) =>
                                                                    e('th', { key: i, style: i <= 1 ? { textAlign: 'left' } : {} }, h)
                                                                )
                                                            )
                                                        ),
                                                        e('tbody', null,
                                                            filteredLineups.slice(0, 25).map((l, i) => {
                                                                const isHome = l.teamIdx === 0;
                                                                const teamColor = isHome ? 'var(--gv-team-home)' : 'var(--gv-team-away)';
                                                                return e('tr', { key: i, style: { background: getNetRatingBackground(l.netRtg) }},
                                                                    e('td', { style: { textAlign: 'left' }},
                                                                        e('span', { style: { width: '8px', height: '8px', borderRadius: '50%', background: teamColor, display: 'inline-block', marginRight: '6px' }})
                                                                    ),
                                                                    e('td', { style: { textAlign: 'left' }},
                                                                        e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '3px' }},
                                                                            l.playerNames.map((name, j) =>
                                                                                e('span', { key: j, style: { fontSize: '9px', padding: '2px 4px', background: 'var(--gv-bg-glass)', borderRadius: '3px' }},
                                                                                    name.split(' ').pop() || name
                                                                                )
                                                                            )
                                                                        )
                                                                    ),
                                                                    e('td', { style: { fontWeight: '600' }}, l.minutes.toFixed(1)),
                                                                    e('td', null, l.stats.points || 0),
                                                                    e('td', { style: { color: getValueClass(l.ortg, 110, 95) }}, l.ortg.toFixed(0)),
                                                                    e('td', { style: { color: getValueClass(l.drtg, 100, 115, true) }}, l.drtg.toFixed(0)),
                                                                    e('td', { style: { fontWeight: '700', color: l.netRtg >= 0 ? 'var(--gv-positive)' : 'var(--gv-negative)' }},
                                                                        (l.netRtg >= 0 ? '+' : '') + l.netRtg.toFixed(0)
                                                                    ),
                                                                    e('td', { style: { color: getValueClass(l.offEfg, 52, 45) }}, l.offEfg.toFixed(0) + '%'),
                                                                    e('td', { style: { color: getValueClass(l.offTovPct, 12, 18, true) }}, l.offTovPct.toFixed(0) + '%'),
                                                                    e('td', { style: { color: getValueClass(l.offOrebPct, 30, 20) }}, l.offOrebPct.toFixed(0) + '%'),
                                                                    e('td', { style: { fontWeight: '700', color: l.plusMinus >= 0 ? 'var(--gv-positive)' : 'var(--gv-negative)', padding: '4px 8px', borderRadius: '4px', background: l.plusMinus >= 0 ? 'rgba(0, 255, 136, 0.15)' : 'rgba(255, 107, 107, 0.15)' }},
                                                                        (l.plusMinus >= 0 ? '+' : '') + l.plusMinus
                                                                    )
                                                                );
                                                            })
                                                        )
                                                    )
                                                )
                                            )
                                );
                            })(),

                        )
                    ),

                    // No games loaded state
                    !gvLoading && gvView === 'browser' && gvFolderGames.length === 0 && e('div', { style: { textAlign: 'center', padding: '40px' }},
                        e('div', { style: { fontSize: '48px', marginBottom: '16px' }}, '📂'),
                        e('div', { style: { color: 'var(--gv-text-muted)' }}, 'No games loaded. Use the folder upload to load game HTML files.')
                    )
                ),

                // ═══════════════════════════════════════════════════════════════════════════
                // V6.1: SETTINGS TAB CONTENT
                // ═══════════════════════════════════════════════════════════════════════════
                activeTab === 'settings' && e('div', { className: 'section', style: { maxWidth: '1200px' }},
                    e('h2', { className: 'section-title', style: { marginBottom: '24px' }}, '⚙️ Settings'),

                    // Theme Color Selection Section - V6.2 with Primary (Background) and Secondary (Accent)
                    e('div', {
                        style: {
                            background: 'rgba(15, 23, 42, 0.5)',
                            border: '1px solid #475569',
                            borderRadius: '12px',
                            padding: '24px',
                            marginBottom: '24px'
                        }
                    },
                        e('h3', { style: { fontSize: '16px', fontWeight: '600', marginBottom: '16px', color: 'var(--theme-primary)' }}, '🎨 Theme Colors'),

                        // Primary Color (Background)
                        e('div', { style: { marginBottom: '24px' }},
                            e('label', { style: { display: 'block', fontSize: '13px', fontWeight: '600', color: '#e2e8f0', marginBottom: '8px' }},
                                '🖼️ Primary Color (Background)'
                            ),
                            e('p', { style: { fontSize: '12px', color: '#94a3b8', marginBottom: '12px' }},
                                'Changes the app background gradient and primary UI elements.'
                            ),
                            e('div', {
                                style: {
                                    display: 'flex',
                                    gap: '10px',
                                    flexWrap: 'wrap'
                                }
                            },
                                [
                                    { id: 'blue', label: 'Blue', color: '#60a5fa' },
                                    { id: 'purple', label: 'Purple', color: '#a78bfa' },
                                    { id: 'green', label: 'Green', color: '#4ade80' },
                                    { id: 'orange', label: 'Orange', color: '#fb923c' },
                                    { id: 'cyan', label: 'Cyan', color: '#22d3ee' },
                                    { id: 'pink', label: 'Pink', color: '#f472b6' },
                                    { id: 'red', label: 'Red', color: '#f87171' },
                                    // V6.3: White and Black themes
                                    { id: 'white', label: 'White', color: '#f8fafc', border: '#d1d5db' },
                                    { id: 'black', label: 'Black', color: '#0a0a0a', border: '#374151' }
                                ].map(theme =>
                                    e('button', {
                                        key: theme.id,
                                        onClick: () => setThemeColor(theme.id),
                                        style: {
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '6px',
                                            padding: '10px 16px',
                                            borderRadius: '8px',
                                            border: themeColor === theme.id ? '2px solid ' + (theme.border || theme.color) : '2px solid transparent',
                                            background: themeColor === theme.id ? 'rgba(255,255,255,0.08)' : 'rgba(30, 41, 59, 0.5)',
                                            color: 'white',
                                            cursor: 'pointer',
                                            transition: 'all 0.2s'
                                        }
                                    },
                                        e('div', {
                                            style: {
                                                width: '18px',
                                                height: '18px',
                                                borderRadius: '50%',
                                                background: theme.color,
                                                border: theme.id === 'white' ? '1px solid #d1d5db' : (theme.id === 'black' ? '1px solid #374151' : 'none'),
                                                boxShadow: themeColor === theme.id ? '0 0 10px ' + (theme.border || theme.color) : 'none'
                                            }
                                        }),
                                        e('span', { style: { fontSize: '13px', fontWeight: themeColor === theme.id ? '600' : '400' }}, theme.label),
                                        themeColor === theme.id && e('span', { style: { marginLeft: '2px', fontSize: '12px' }}, '✓')
                                    )
                                )
                            )
                        ),

                        // Secondary Color (Accent)
                        e('div', null,
                            e('label', { style: { display: 'block', fontSize: '13px', fontWeight: '600', color: '#e2e8f0', marginBottom: '8px' }},
                                '✨ Secondary Color (Accent)'
                            ),
                            e('p', { style: { fontSize: '12px', color: '#94a3b8', marginBottom: '12px' }},
                                'Changes accent colors for highlights, buttons, and decorative elements.'
                            ),
                            e('div', {
                                style: {
                                    display: 'flex',
                                    gap: '10px',
                                    flexWrap: 'wrap'
                                }
                            },
                                [
                                    { id: 'blue', label: 'Blue', color: '#60a5fa' },
                                    { id: 'purple', label: 'Purple', color: '#a78bfa' },
                                    { id: 'green', label: 'Green', color: '#4ade80' },
                                    { id: 'orange', label: 'Orange', color: '#fb923c' },
                                    { id: 'cyan', label: 'Cyan', color: '#22d3ee' },
                                    { id: 'pink', label: 'Pink', color: '#f472b6' },
                                    { id: 'red', label: 'Red', color: '#f87171' },
                                    // V6.3: Gold and Silver accents for white/black themes
                                    { id: 'gold', label: 'Gold', color: '#fbbf24' },
                                    { id: 'silver', label: 'Silver', color: '#9ca3af' }
                                ].map(theme =>
                                    e('button', {
                                        key: 'sec-' + theme.id,
                                        onClick: () => setSecondaryThemeColor(theme.id),
                                        style: {
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '6px',
                                            padding: '10px 16px',
                                            borderRadius: '8px',
                                            border: secondaryThemeColor === theme.id ? '2px solid ' + theme.color : '2px solid transparent',
                                            background: secondaryThemeColor === theme.id ? 'rgba(255,255,255,0.08)' : 'rgba(30, 41, 59, 0.5)',
                                            color: 'white',
                                            cursor: 'pointer',
                                            transition: 'all 0.2s'
                                        }
                                    },
                                        e('div', {
                                            style: {
                                                width: '18px',
                                                height: '18px',
                                                borderRadius: '50%',
                                                background: theme.color,
                                                boxShadow: secondaryThemeColor === theme.id ? '0 0 10px ' + theme.color : 'none'
                                            }
                                        }),
                                        e('span', { style: { fontSize: '13px', fontWeight: secondaryThemeColor === theme.id ? '600' : '400' }}, theme.label),
                                        secondaryThemeColor === theme.id && e('span', { style: { marginLeft: '2px', fontSize: '12px' }}, '✓')
                                    )
                                )
                            )
                        ),

                        // Preview swatch
                        e('div', { style: { marginTop: '20px', padding: '16px', borderRadius: '8px', background: 'rgba(0,0,0,0.3)', display: 'flex', alignItems: 'center', gap: '16px' }},
                            e('span', { style: { fontSize: '12px', color: '#94a3b8' }}, 'Preview:'),
                            e('div', { style: { display: 'flex', gap: '8px', alignItems: 'center' }},
                                e('div', { style: { width: '40px', height: '24px', borderRadius: '4px', background: 'var(--theme-primary)' }}),
                                e('span', { style: { fontSize: '11px', color: '#64748b' }}, '+'),
                                e('div', { style: { width: '40px', height: '24px', borderRadius: '4px', background: 'var(--theme-accent)' }})
                            ),
                            e('span', { style: { fontSize: '12px', color: 'var(--theme-primary)', fontWeight: '600' }}, 'Primary'),
                            e('span', { style: { fontSize: '12px', color: 'var(--theme-accent)', fontWeight: '600' }}, 'Accent')
                        )
                    ),

                    // VS Starters Settings Section
                    e('div', {
                        style: {
                            background: 'rgba(15, 23, 42, 0.5)',
                            border: '1px solid rgba(6, 182, 212, 0.3)',
                            borderRadius: '12px',
                            padding: '24px',
                            marginBottom: '24px'
                        }
                    },
                        e('h3', { style: { fontSize: '16px', fontWeight: '600', marginBottom: '8px', color: '#06b6d4' }}, '🎯 VS. Starters Settings'),
                        e('p', { style: { fontSize: '13px', color: '#94a3b8', marginBottom: '16px' }},
                            'Configure how "regular starters" are identified for VS. Starters analysis in the Full Table. A player is considered a regular starter if they started at least this many games.'
                        ),

                        // Min Games Started Slider
                        e('div', { style: { marginBottom: '16px' }},
                            e('label', { style: { display: 'block', fontSize: '13px', fontWeight: '600', color: '#e2e8f0', marginBottom: '8px' }},
                                '📊 Minimum Games Started for Regular Starter'
                            ),
                            e('div', { style: { display: 'flex', alignItems: 'center', gap: '16px' }},
                                e('input', {
                                    type: 'range',
                                    min: 1,
                                    max: 20,
                                    value: leaderboardTableVsStartersMinGames,
                                    onChange: (ev) => setLeaderboardTableVsStartersMinGames(parseInt(ev.target.value)),
                                    style: {
                                        flex: 1,
                                        height: '8px',
                                        borderRadius: '4px',
                                        background: 'linear-gradient(to right, #06b6d4 0%, #06b6d4 ' + ((leaderboardTableVsStartersMinGames - 1) / 19 * 100) + '%, #334155 ' + ((leaderboardTableVsStartersMinGames - 1) / 19 * 100) + '%, #334155 100%)',
                                        appearance: 'none',
                                        cursor: 'pointer'
                                    }
                                }),
                                e('span', {
                                    style: {
                                        fontSize: '18px',
                                        fontWeight: 'bold',
                                        color: '#06b6d4',
                                        minWidth: '40px',
                                        textAlign: 'center',
                                        background: 'rgba(6, 182, 212, 0.15)',
                                        padding: '6px 12px',
                                        borderRadius: '6px',
                                        border: '1px solid rgba(6, 182, 212, 0.3)'
                                    }
                                }, leaderboardTableVsStartersMinGames)
                            ),
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '10px', color: '#64748b', marginTop: '4px' }},
                                e('span', null, '1 game'),
                                e('span', null, '20 games')
                            )
                        ),

                        // Explanation
                        e('div', {
                            style: {
                                padding: '12px',
                                background: 'rgba(6, 182, 212, 0.1)',
                                border: '1px solid rgba(6, 182, 212, 0.2)',
                                borderRadius: '8px',
                                fontSize: '12px',
                                color: '#94a3b8'
                            }
                        },
                            e('div', { style: { marginBottom: '6px' }},
                                '💡 VS. Starters = facing lineups with 4+ regular starters OR 4+ of that game\'s starting 5'
                            ),
                            e('div', null,
                                '📊 Current setting: A player needs ',
                                e('strong', { style: { color: '#06b6d4' }}, leaderboardTableVsStartersMinGames + '+ game starts'),
                                ' to be considered a "regular starter"'
                            ),
                            e('div', { style: { marginTop: '6px', fontSize: '11px', color: '#64748b' }},
                                '🔄 Changes take effect immediately in the Full Table VS★ columns when VS. Starters mode is enabled'
                            )
                        )
                    ),

                    // Player Data Merging Section
                    e('div', {
                        style: {
                            background: 'rgba(15, 23, 42, 0.5)',
                            border: '1px solid #475569',
                            borderRadius: '12px',
                            padding: '24px'
                        }
                    },
                        e('h3', { style: { fontSize: '16px', fontWeight: '600', marginBottom: '8px', color: 'var(--theme-primary)' }}, '🔗 Player Data Merging'),
                        e('p', { style: { fontSize: '13px', color: '#94a3b8', marginBottom: '8px' }},
                            'Merge player name variations so they are treated as the same player across all data. This is useful when player names are inconsistently formatted (e.g., "M. Felletti O\'Donnell" vs "M. Felletti O\'donnell").'
                        ),
                        e('div', {
                            style: {
                                padding: '12px',
                                background: 'rgba(251, 191, 36, 0.1)',
                                border: '1px solid rgba(251, 191, 36, 0.3)',
                                borderRadius: '8px',
                                marginBottom: '20px',
                                fontSize: '12px',
                                color: '#fbbf24'
                            }
                        },
                            '⚠️ Important: Merging affects all tabs and functions including stats, lineups, WOWY analysis, and matchups. Changes are saved to your browser and persist across sessions.'
                        ),

                        // Current merge rules
                        playerMergeRules.length > 0 && e('div', { style: { marginBottom: '20px' }},
                            e('h4', { style: { fontSize: '14px', fontWeight: '600', marginBottom: '12px', color: '#e2e8f0' }}, 'Active Merge Rules (' + playerMergeRules.length + ')'),
                            e('div', { style: { display: 'flex', flexDirection: 'column', gap: '8px' }},
                                playerMergeRules.map((rule, idx) =>
                                    e('div', {
                                        key: idx,
                                        style: {
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '12px',
                                            padding: '12px 16px',
                                            background: 'rgba(30, 41, 59, 0.6)',
                                            borderRadius: '8px',
                                            flexWrap: 'wrap'
                                        }
                                    },
                                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', flex: '1 1 auto', minWidth: '200px' }},
                                            e('span', { style: { fontSize: '13px', fontWeight: '600', color: 'var(--theme-primary)' }}, rule.primary),
                                            e('span', { style: { fontSize: '11px', color: '#64748b' }}, '←'),
                                            e('span', { style: { fontSize: '12px', color: '#94a3b8' }}, rule.aliases.join(', '))
                                        ),
                                        e('button', {
                                            onClick: () => {
                                                setPlayerMergeRules(playerMergeRules.filter((_, i) => i !== idx));
                                            },
                                            style: {
                                                padding: '6px 12px',
                                                borderRadius: '6px',
                                                border: 'none',
                                                background: 'rgba(239, 68, 68, 0.2)',
                                                color: '#f87171',
                                                cursor: 'pointer',
                                                fontSize: '12px',
                                                fontWeight: '600'
                                            }
                                        }, '✕ Remove')
                                    )
                                )
                            )
                        ),

                        // Add new merge rule - V6.2 with team filters
                        e('div', {
                            style: {
                                background: 'rgba(30, 41, 59, 0.4)',
                                borderRadius: '10px',
                                padding: '20px'
                            }
                        },
                            e('h4', { style: { fontSize: '14px', fontWeight: '600', marginBottom: '16px', color: '#e2e8f0' }}, '+ Add New Merge Rule'),

                            // V6.2: Team filters row
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '16px', marginBottom: '16px' }},
                                e('div', null,
                                    e('label', { style: { display: 'block', fontSize: '12px', color: 'var(--theme-primary)', marginBottom: '6px', fontWeight: '600' }}, '🏀 Primary Player Team'),
                                    e('select', {
                                        value: mergePrimaryTeam,
                                        onChange: (ev) => setMergePrimaryTeam(ev.target.value),
                                        style: {
                                            width: '100%',
                                            padding: '10px 12px',
                                            background: '#1e293b',
                                            border: '1px solid var(--theme-primary)',
                                            borderRadius: '6px',
                                            color: 'white',
                                            fontSize: '13px'
                                        }
                                    },
                                        e('option', { value: '' }, '-- All Teams (' + allUniquePlayerNames.length + ' players) --'),
                                        playersByTeam.teams.map(team =>
                                            e('option', { key: team, value: team }, team + ' (' + (playersByTeam.byTeam[team]?.length || 0) + ')')
                                        )
                                    )
                                ),
                                e('div', null,
                                    e('label', { style: { display: 'block', fontSize: '12px', color: 'var(--theme-accent)', marginBottom: '6px', fontWeight: '600' }}, '🏀 Alias Player Team'),
                                    e('select', {
                                        value: mergeAliasTeam,
                                        onChange: (ev) => setMergeAliasTeam(ev.target.value),
                                        style: {
                                            width: '100%',
                                            padding: '10px 12px',
                                            background: '#1e293b',
                                            border: '1px solid var(--theme-accent)',
                                            borderRadius: '6px',
                                            color: 'white',
                                            fontSize: '13px'
                                        }
                                    },
                                        e('option', { value: '' }, '-- All Teams (' + allUniquePlayerNames.length + ' players) --'),
                                        playersByTeam.teams.map(team =>
                                            e('option', { key: team, value: team }, team + ' (' + (playersByTeam.byTeam[team]?.length || 0) + ')')
                                        )
                                    )
                                )
                            ),

                            // Player selection row (filtered by team)
                            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '16px', marginBottom: '16px' }},
                                e('div', null,
                                    e('label', { style: { display: 'block', fontSize: '12px', color: '#94a3b8', marginBottom: '6px' }},
                                        'Primary Name (canonical)' + (mergePrimaryTeam ? ' - ' + mergePrimaryTeam : '')
                                    ),
                                    e('select', {
                                        id: 'mergePrimarySelect',
                                        style: {
                                            width: '100%',
                                            padding: '10px 12px',
                                            background: '#1e293b',
                                            border: '1px solid #475569',
                                            borderRadius: '6px',
                                            color: 'white',
                                            fontSize: '13px'
                                        }
                                    },
                                        e('option', { value: '' }, '-- Select primary name --'),
                                        (mergePrimaryTeam && playersByTeam.byTeam[mergePrimaryTeam]
                                            ? playersByTeam.byTeam[mergePrimaryTeam]
                                            : allUniquePlayerNames
                                        ).map(name =>
                                            e('option', { key: name, value: name }, name)
                                        )
                                    )
                                ),
                                e('div', null,
                                    e('label', { style: { display: 'block', fontSize: '12px', color: '#94a3b8', marginBottom: '6px' }},
                                        'Alias (will be merged into primary)' + (mergeAliasTeam ? ' - ' + mergeAliasTeam : '')
                                    ),
                                    e('select', {
                                        id: 'mergeAliasSelect',
                                        style: {
                                            width: '100%',
                                            padding: '10px 12px',
                                            background: '#1e293b',
                                            border: '1px solid #475569',
                                            borderRadius: '6px',
                                            color: 'white',
                                            fontSize: '13px'
                                        }
                                    },
                                        e('option', { value: '' }, '-- Select alias to merge --'),
                                        (mergeAliasTeam && playersByTeam.byTeam[mergeAliasTeam]
                                            ? playersByTeam.byTeam[mergeAliasTeam]
                                            : allUniquePlayerNames
                                        ).map(name =>
                                            e('option', { key: name, value: name }, name)
                                        )
                                    )
                                )
                            ),
                            e('button', {
                                onClick: () => {
                                    const primarySelect = document.getElementById('mergePrimarySelect');
                                    const aliasSelect = document.getElementById('mergeAliasSelect');
                                    const primary = primarySelect?.value;
                                    const alias = aliasSelect?.value;

                                    if (!primary || !alias) {
                                        alert('Please select both a primary name and an alias');
                                        return;
                                    }
                                    if (primary === alias) {
                                        alert('Primary name and alias cannot be the same');
                                        return;
                                    }

                                    // Check if this alias is already used
                                    const existingRule = playerMergeRules.find(r => r.primary === alias || r.aliases.includes(alias));
                                    if (existingRule) {
                                        alert('This alias is already part of another merge rule. Remove that rule first.');
                                        return;
                                    }

                                    // Check if primary already exists as a rule
                                    const existingPrimaryRule = playerMergeRules.find(r => r.primary === primary);
                                    if (existingPrimaryRule) {
                                        // Add alias to existing rule
                                        setPlayerMergeRules(playerMergeRules.map(r =>
                                            r.primary === primary
                                                ? { ...r, aliases: [...r.aliases, alias] }
                                                : r
                                        ));
                                    } else {
                                        // Create new rule
                                        setPlayerMergeRules([...playerMergeRules, { primary, aliases: [alias] }]);
                                    }

                                    // Reset selects
                                    if (primarySelect) primarySelect.value = '';
                                    if (aliasSelect) aliasSelect.value = '';
                                },
                                style: {
                                    padding: '10px 20px',
                                    borderRadius: '8px',
                                    border: 'none',
                                    background: 'linear-gradient(135deg, var(--theme-primary) 0%, var(--theme-accent) 100%)',
                                    color: 'white',
                                    fontWeight: '600',
                                    fontSize: '13px',
                                    cursor: 'pointer'
                                }
                            }, '+ Add Merge Rule')
                        ),

                        // Clear all rules button
                        playerMergeRules.length > 0 && e('div', { style: { marginTop: '16px', textAlign: 'right' }},
                            e('button', {
                                onClick: () => {
                                    if (confirm('Are you sure you want to remove all merge rules?')) {
                                        setPlayerMergeRules([]);
                                    }
                                },
                                style: {
                                    padding: '8px 16px',
                                    borderRadius: '6px',
                                    border: '1px solid rgba(239, 68, 68, 0.3)',
                                    background: 'transparent',
                                    color: '#f87171',
                                    fontSize: '12px',
                                    cursor: 'pointer'
                                }
                            }, '🗑️ Clear All Merge Rules')
                        )
                    )
                ),

                // ═══════════════════════════════════════════════════════════════════════════
                // MOBILE BOTTOM NAVIGATION BAR
                // Shows on mobile devices only - provides quick access to main sections
                // ═══════════════════════════════════════════════════════════════════════════
                isMobileView && (lineupData.length > 0 || stintsData.length > 0) && e('div', {
                    className: 'mobile-tab-bar',
                    style: {
                        display: 'flex',
                        position: 'fixed',
                        bottom: 0,
                        left: 0,
                        right: 0,
                        background: 'rgba(15, 23, 42, 0.98)',
                        borderTop: '1px solid #334155',
                        padding: '8px 4px',
                        paddingBottom: 'calc(8px + env(safe-area-inset-bottom, 0px))',
                        zIndex: 999,
                        backdropFilter: 'blur(10px)',
                        justifyContent: 'space-around'
                    }
                },
                    // Analyzer tab
                    lineupData.length > 0 && e('button', {
                        onClick: () => setActiveTab('analyzer'),
                        style: {
                            display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px',
                            padding: '8px 12px', border: 'none', borderRadius: '8px',
                            background: activeTab === 'analyzer' ? 'rgba(96, 165, 250, 0.15)' : 'transparent',
                            color: activeTab === 'analyzer' ? '#60a5fa' : '#64748b',
                            cursor: 'pointer'
                        }
                    },
                        e('span', { style: { fontSize: '20px' }}, '📊'),
                        e('span', { style: { fontSize: '9px' }}, 'Analyzer')
                    ),

                    // Leaderboard tab
                    lineupData.length > 0 && e('button', {
                        onClick: () => setActiveTab('leaderboard'),
                        style: {
                            display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px',
                            padding: '8px 12px', border: 'none', borderRadius: '8px',
                            background: activeTab === 'leaderboard' ? 'rgba(96, 165, 250, 0.15)' : 'transparent',
                            color: activeTab === 'leaderboard' ? '#60a5fa' : '#64748b',
                            cursor: 'pointer'
                        }
                    },
                        e('span', { style: { fontSize: '20px' }}, '🏆'),
                        e('span', { style: { fontSize: '9px' }}, 'Leaders')
                    ),

                    // Games tab
                    e('button', {
                        onClick: () => setActiveTab('games'),
                        style: {
                            display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px',
                            padding: '8px 12px', border: 'none', borderRadius: '8px',
                            background: activeTab === 'games' ? 'rgba(96, 165, 250, 0.15)' : 'transparent',
                            color: activeTab === 'games' ? '#60a5fa' : '#64748b',
                            cursor: 'pointer'
                        }
                    },
                        e('span', { style: { fontSize: '20px' }}, '🎮'),
                        e('span', { style: { fontSize: '9px' }}, 'Games')
                    ),

                    // Export tab
                    lineupData.length > 0 && e('button', {
                        onClick: () => setActiveTab('export'),
                        style: {
                            display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px',
                            padding: '8px 12px', border: 'none', borderRadius: '8px',
                            background: activeTab === 'export' ? 'rgba(96, 165, 250, 0.15)' : 'transparent',
                            color: activeTab === 'export' ? '#60a5fa' : '#64748b',
                            cursor: 'pointer'
                        }
                    },
                        e('span', { style: { fontSize: '20px' }}, '📤'),
                        e('span', { style: { fontSize: '9px' }}, 'Export')
                    ),

                    // Menu button (for settings/file uploads)
                    e('button', {
                        onClick: () => setHeaderExpanded(!headerExpanded),
                        style: {
                            display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px',
                            padding: '8px 12px', border: 'none', borderRadius: '8px',
                            background: headerExpanded ? 'rgba(96, 165, 250, 0.15)' : 'transparent',
                            color: headerExpanded ? '#60a5fa' : '#64748b',
                            cursor: 'pointer'
                        }
                    },
                        e('span', { style: { fontSize: '20px' }}, '⚙️'),
                        e('span', { style: { fontSize: '9px' }}, 'Settings')
                    )
                ),

                // ═══════════════════════════════════════════════════════════════════════════
                // PLAYER RADAR CHART MODAL
                // ═══════════════════════════════════════════════════════════════════════════
                showRadarModal && radarPlayer && (() => {
                    const player = radarPlayer;
                    const stats = player.allStats || player;

                    // Check if RAPM is available, otherwise use BPM
                    const hasRapm = stats.rapmNet !== undefined && stats.rapmNet !== null && !isNaN(stats.rapmNet);
                    const hasBpm = stats.bpm !== undefined && stats.bpm !== null && !isNaN(stats.bpm);
                    const impactLabel = hasRapm ? 'RAPM' : (hasBpm ? 'BPM' : null);
                    const impactValue = hasRapm ? stats.rapmNet : (hasBpm ? stats.bpm : null);
                    const offImpactLabel = hasRapm ? 'O-RAPM' : (hasBpm ? 'OBPM' : null);
                    const offImpactValue = hasRapm ? stats.rapmOff : (hasBpm ? stats.obpm : null);
                    const defImpactLabel = hasRapm ? 'D-RAPM' : (hasBpm ? 'DBPM' : null);
                    const defImpactValue = hasRapm ? stats.rapmDef : (hasBpm ? stats.dbpm : null);

                    // V6.4: Define stat groups with colors for visual categorization
                    const statGroups = {
                        impact: { name: 'Impact', color: '#a855f7', bgColor: 'rgba(168, 85, 247, 0.15)', borderColor: 'rgba(168, 85, 247, 0.4)' },
                        playmaking: { name: 'Playmaking', color: '#3b82f6', bgColor: 'rgba(59, 130, 246, 0.15)', borderColor: 'rgba(59, 130, 246, 0.4)' },
                        efficiency: { name: 'Efficiency', color: '#22c55e', bgColor: 'rgba(34, 197, 94, 0.15)', borderColor: 'rgba(34, 197, 94, 0.4)' },
                        rebounding: { name: 'Rebounding', color: '#f97316', bgColor: 'rgba(249, 115, 22, 0.15)', borderColor: 'rgba(249, 115, 22, 0.4)' },
                        defense: { name: 'Defense', color: '#dc2626', bgColor: 'rgba(220, 38, 38, 0.15)', borderColor: 'rgba(220, 38, 38, 0.4)' },
                        threePoint: { name: '3-Point', color: '#06b6d4', bgColor: 'rgba(6, 182, 212, 0.15)', borderColor: 'rgba(6, 182, 212, 0.4)' },
                        rim: { name: 'Rim', color: '#ef4444', bgColor: 'rgba(239, 68, 68, 0.15)', borderColor: 'rgba(239, 68, 68, 0.4)' },
                        midRange: { name: 'Mid-Range', color: '#eab308', bgColor: 'rgba(234, 179, 8, 0.15)', borderColor: 'rgba(234, 179, 8, 0.4)' },
                        transition: { name: 'Transition', color: '#ec4899', bgColor: 'rgba(236, 72, 153, 0.15)', borderColor: 'rgba(236, 72, 153, 0.4)' }
                    };

                    // V6.4: Individual stats for radar (percentile-based) - grouped logically with color coding
                    // V6.5: Always show all stats bars, even when data is missing (hasData flag)
                    const individualStats = [
                        // Impact - overall player value
                        impactLabel && { key: 'impact', label: impactLabel, value: impactValue, group: 'impact' },
                        // Usage & Playmaking - ball handling metrics together
                        { key: 'usgPct', label: 'USG%', value: stats.usgPct, group: 'playmaking' },
                        { key: 'astPctIndiv', label: 'AST%', value: stats.astPctIndiv, group: 'playmaking' },
                        { key: 'tovPct', label: 'TOV%', value: stats.tovPct, lowerBetter: true, group: 'playmaking' },
                        // Scoring Efficiency - shooting metrics together
                        { key: 'tsPct', label: 'TS%', value: stats.tsPct, group: 'efficiency' },
                        { key: 'efgPct', label: 'eFG%', value: stats.efgPct, group: 'efficiency' },
                        { key: 'ftPct', label: 'FT%', value: stats.ftPct, group: 'efficiency' },
                        // Rebounding - board metrics together
                        { key: 'orebPct', label: 'OREB%', value: stats.orebPct, group: 'rebounding' },
                        { key: 'drebPct', label: 'DREB%', value: stats.drebPct, group: 'rebounding' },
                        // Defense - steals and blocks
                        { key: 'stlPctIndiv', label: 'STL%', value: stats.stlPctIndiv, group: 'defense' },
                        { key: 'blkPctIndiv', label: 'BLK%', value: stats.blkPctIndiv, group: 'defense' },
                        // 3PT Location - three-point metrics together
                        { key: 'tpa100', label: '3PA/100', value: stats.tpa100, group: 'threePoint' },
                        { key: 'threePctIndiv', label: '3P%', value: stats.threePctIndiv, group: 'threePoint' },
                        // Rim Location - rim metrics together
                        { key: 'rima100', label: 'RIMA/100', value: stats.rima100, group: 'rim' },
                        { key: 'rimfgPct', label: 'RIMFG%', value: stats.rimfgPct, group: 'rim' },
                        // Mid-Range Location - mid-range metrics together
                        { key: 'mida100', label: 'MIDA/100', value: stats.mida100, group: 'midRange' },
                        { key: 'midfgPct', label: 'MIDFG%', value: stats.midfgPct, group: 'midRange' },
                        // Transition
                        { key: 'fbp40', label: 'FBP/40', value: stats.fbp40, group: 'transition' }
                    ].filter(s => s).map(s => ({
                        ...s,
                        hasData: s.value !== undefined && s.value !== null && !isNaN(s.value)
                    }));

                    // On-Off stats for radar
                    // V6.5: Always show all stats bars, even when data is missing (hasData flag)
                    const onOffStats = [
                        impactLabel && { key: 'impact', label: impactLabel, value: impactValue },
                        offImpactLabel && { key: 'offImpact', label: offImpactLabel, value: offImpactValue },
                        defImpactLabel && { key: 'defImpact', label: defImpactLabel, value: defImpactValue },
                        { key: 'offEfg', label: 'eFG%±', value: stats.offEfg },
                        { key: 'defEfg', label: 'Opp eFG%±', value: stats.defEfg },
                        { key: 'offTov', label: 'TOV%±', value: stats.offTov },
                        { key: 'defTov', label: 'Frc TOV%±', value: stats.defTov },
                        { key: 'offOreb', label: 'OREB%±', value: stats.offOreb },
                        { key: 'defOreb', label: 'Opp OREB%±', value: stats.defOreb },
                        { key: 'offFtR', label: 'FTR±', value: stats.offFtR },
                        { key: 'defFtR', label: 'Opp FTR±', value: stats.defFtR }
                    ].filter(s => s).map(s => ({
                        ...s,
                        hasData: s.value !== undefined && s.value !== null && !isNaN(s.value)
                    }));

                    const activeStats = radarMode === 'individual' ? individualStats : onOffStats;

                    // Calculate percentiles for radar values
                    // V6.4: Map stat keys to leaguePlayerAverages.statArrays keys for percentile lookup
                    // Fixed: Now using proper percentage pools instead of per-75 counting stats
                    const statKeyToPoolKey = {
                        'impact': 'bpm', // Use BPM pool for impact stats
                        'usgPct': 'usgPct', // V6.9: Match table column key
                        'astPctIndiv': 'astPctIndiv', // V6.9: Use matching Indiv key for consistency
                        'tovPct': 'tovPct', // V6.4: Use proper TOV% pool (not tov75)
                        'tsPct': 'tsPct',
                        'efgPct': 'efgPct', // V6.4: Now has proper pool
                        'ftPct': 'ftPct', // V6.4: Now has proper pool
                        'orebPct': 'orebPct', // V6.4: Use proper OREB% pool (not oreb75)
                        'drebPct': 'drebPct', // V6.4: Use proper DREB% pool (not dreb75)
                        'stlPctIndiv': 'stlPctIndiv', // V6.9: Use matching Indiv key for consistency
                        'blkPctIndiv': 'blkPctIndiv', // V6.9: Use matching Indiv key for consistency
                        'tpa100': 'tpa100', // V6.9: Match table column key
                        'threePctIndiv': 'threePctIndiv', // V6.9: Match table column key
                        'rima100': 'rima100', // V6.9: Match table column key
                        'rimfgPct': 'rimfgPct', // V6.9: Match table column key
                        'mida100': 'mida100', // V6.9: Match table column key
                        'midfgPct': 'midfgPct', // V6.9: Match table column key
                        'fbp40': 'fbp40' // V6.9: Match table column key
                    };

                    // V6.9: Helper to calculate actual percentile from the SAME data source as the full table
                    // This ensures percentiles in modal match the table's color-coded percentiles exactly
                    const calcPercentileFromPool = (value, poolKey, higherBetter, usePositionPool = false) => {
                        // V6.9: PRIMARY SOURCE - Use full table's percentile data for consistency
                        // This is the exact same data used for the table's color coding
                        const tablePercentileData = fullTableDataRef.current?.percentileData;
                        if (tablePercentileData && tablePercentileData[poolKey] && tablePercentileData[poolKey].length >= 5) {
                            const sortedArr = [...tablePercentileData[poolKey]].sort((a, b) => a - b);
                            const rank = sortedArr.filter(v => v < value).length;
                            const pct = (rank / sortedArr.length) * 100;
                            return higherBetter ? pct : 100 - pct;
                        }

                        // Fallback to leaguePlayerAverages if fullTableData not available
                        let sortedArr;
                        const allPlayers = leaguePlayerAverages?.players || [];
                        const filteredPlayers = allPlayers.filter(p => (p.seasonMin || 0) >= 100);

                        if (usePositionPool && stats.positionRange?.shortLabel && filteredPlayers.length >= 5) {
                            const playersInRange = filteredPlayers.filter(p =>
                                p.position !== null && p.position !== undefined &&
                                p.position >= stats.positionRange.min &&
                                p.position <= stats.positionRange.max
                            );
                            if (playersInRange.length >= 5) {
                                const poolValues = playersInRange
                                    .map(p => p[poolKey])
                                    .filter(v => v !== null && v !== undefined && !isNaN(v) && v > 0);
                                if (poolValues.length >= 5) {
                                    sortedArr = poolValues.sort((a, b) => a - b);
                                }
                            }
                        }

                        if (!sortedArr) {
                            const poolValues = filteredPlayers
                                .map(p => p[poolKey])
                                .filter(v => v !== null && v !== undefined && !isNaN(v) && v > 0);
                            if (poolValues.length >= 5) {
                                sortedArr = poolValues.sort((a, b) => a - b);
                            } else if (leaguePlayerAverages?.statArrays?.[poolKey]) {
                                sortedArr = leaguePlayerAverages.statArrays[poolKey];
                            }
                        }

                        if (!sortedArr || sortedArr.length === 0) {
                            return null;
                        }
                        const rank = sortedArr.filter(v => v < value).length;
                        const pct = (rank / sortedArr.length) * 100;
                        return higherBetter ? pct : 100 - pct;
                    };

                    // DEBUG: Log player stats and pool sources
                    const tableData = fullTableDataRef.current;
                    console.log('[MODAL DEBUG] Player stats:', {
                        player: player.player,
                        team: player.team,
                        orebPct: stats.orebPct,
                        drebPct: stats.drebPct,
                        astPctIndiv: stats.astPctIndiv,
                        usingFullTableData: !!tableData?.percentileData,
                        fullTablePoolSize: tableData?.data?.length || 0,
                        orebPctPoolSize: tableData?.percentileData?.orebPct?.length || 'N/A',
                        astPctIndivPoolSize: tableData?.percentileData?.astPctIndiv?.length || 'N/A'
                    });

                    const radarData = activeStats.map(stat => {
                        // V6.5: Handle stats without data - show N/A state
                        if (!stat.hasData) {
                            return { ...stat, pct: null };
                        }
                        // V6.9: Use actual percentile ranks from qualified player pool (100+ total minutes)
                        // V6.6: Support position-based percentiles
                        let pct = 50;
                        if (radarMode === 'individual') {
                            const poolKey = statKeyToPoolKey[stat.key];
                            const usePositionPool = percentileMode === 'position';
                            const poolPct = poolKey ? calcPercentileFromPool(stat.value, poolKey, !stat.lowerBetter, usePositionPool) : null;

                            if (poolPct !== null) {
                                // Use actual percentile from qualified player pool
                                pct = poolPct;
                            } else {
                                // Fallback to fixed-range scaling for stats without a pool
                                if (stat.key === 'impact') {
                                    // RAPM/BPM impact stats: typically -5 to +5, map to 0-100
                                    pct = Math.min(100, Math.max(0, (stat.value + 5) * 10));
                                } else if (stat.key === 'efgPct' || stat.key === 'ftPct') {
                                    // Percentages 0-100
                                    pct = Math.min(100, Math.max(0, stat.value));
                                } else if (stat.key.includes('Pct') || stat.key.includes('%')) {
                                    pct = Math.min(100, Math.max(0, stat.value));
                                } else {
                                    // Per-possession stats fallback
                                    pct = Math.min(100, Math.max(0, stat.value * 5));
                                }
                                if (stat.lowerBetter) pct = 100 - pct;
                            }
                        } else {
                            // On-off mode: map +/- values to percentile
                            // Typical range is -10 to +10
                            pct = Math.min(100, Math.max(0, (stat.value + 10) * 5));
                        }
                        return { ...stat, pct };
                    });

                    // V6.2: Percentile bar chart color helper
                    const getPercentileBarColor = (pct) => {
                        if (pct >= 80) return { bg: 'rgba(34, 197, 94, 0.8)', border: '#22c55e' };
                        if (pct >= 60) return { bg: 'rgba(132, 204, 22, 0.7)', border: '#84cc16' };
                        if (pct >= 40) return { bg: 'rgba(234, 179, 8, 0.7)', border: '#eab308' };
                        if (pct >= 20) return { bg: 'rgba(249, 115, 22, 0.7)', border: '#f97316' };
                        return { bg: 'rgba(239, 68, 68, 0.7)', border: '#ef4444' };
                    };

                    return e('div', {
                        className: 'modal-overlay',
                        onClick: () => setShowRadarModal(false),
                        style: { zIndex: 2000 }
                    },
                        e('div', {
                            onClick: ev => ev.stopPropagation(),
                            style: {
                                background: 'linear-gradient(145deg, #0f172a 0%, #1e293b 100%)',
                                border: '2px solid rgba(var(--theme-primary-rgb), 0.4)',
                                borderRadius: '24px',
                                padding: '28px',
                                maxWidth: '1000px',
                                width: '95%',
                                height: '90vh',
                                maxHeight: '90vh',
                                display: 'flex',
                                flexDirection: 'column',
                                boxShadow: '0 25px 80px rgba(0, 0, 0, 0.6), 0 0 40px rgba(var(--theme-primary-rgb), 0.15)',
                                position: 'relative'
                            }
                        },
                            // Header with player name - V6.2: Compact header for bar chart focus
                            e('div', { style: { textAlign: 'center', marginBottom: '16px', flexShrink: 0 }},
                                e('h2', {
                                    style: {
                                        fontSize: '26px',
                                        fontWeight: '800',
                                        background: 'linear-gradient(90deg, var(--theme-primary), var(--theme-accent), #f472b6)',
                                        WebkitBackgroundClip: 'text',
                                        WebkitTextFillColor: 'transparent',
                                        marginBottom: '4px'
                                    }
                                }, player.player),
                                e('div', { style: { fontSize: '14px', color: '#94a3b8' }}, player.team),
                                // Show warning if using BPM instead of RAPM
                                !hasRapm && hasBpm && e('div', {
                                    style: {
                                        marginTop: '8px',
                                        padding: '6px 12px',
                                        background: 'rgba(251, 191, 36, 0.15)',
                                        border: '1px solid rgba(251, 191, 36, 0.3)',
                                        borderRadius: '8px',
                                        fontSize: '10px',
                                        color: '#fbbf24'
                                    }
                                }, '⚠️ RAPM unavailable - using BPM. Calculate RAPM from stints for better accuracy.'),
                                // Show warning if neither RAPM nor BPM available
                                !hasRapm && !hasBpm && e('div', {
                                    style: {
                                        marginTop: '8px',
                                        padding: '6px 12px',
                                        background: 'rgba(239, 68, 68, 0.15)',
                                        border: '1px solid rgba(239, 68, 68, 0.3)',
                                        borderRadius: '8px',
                                        fontSize: '10px',
                                        color: '#f87171'
                                    }
                                }, '⚠️ No impact metric available. Load stints.csv to calculate RAPM.')
                            ),

                            // Mode toggle buttons - V6.2: More compact
                            e('div', {
                                style: {
                                    display: 'flex',
                                    justifyContent: 'center',
                                    gap: '8px',
                                    marginBottom: '16px',
                                    flexShrink: 0
                                }
                            },
                                e('button', {
                                    onClick: () => setRadarMode('individual'),
                                    style: {
                                        padding: '8px 18px',
                                        borderRadius: '10px',
                                        border: 'none',
                                        cursor: 'pointer',
                                        fontWeight: '600',
                                        fontSize: '12px',
                                        background: radarMode === 'individual' ? 'linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%)' : 'rgba(71, 85, 105, 0.5)',
                                        color: radarMode === 'individual' ? 'white' : '#94a3b8',
                                        boxShadow: radarMode === 'individual' ? '0 4px 15px rgba(59, 130, 246, 0.4)' : 'none',
                                        transition: 'all 0.2s ease'
                                    }
                                }, '📊 Individual'),
                                e('button', {
                                    onClick: () => setRadarMode('onoff'),
                                    style: {
                                        padding: '8px 18px',
                                        borderRadius: '10px',
                                        border: 'none',
                                        cursor: 'pointer',
                                        fontWeight: '600',
                                        fontSize: '12px',
                                        background: radarMode === 'onoff' ? 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)' : 'rgba(71, 85, 105, 0.5)',
                                        color: radarMode === 'onoff' ? 'white' : '#94a3b8',
                                        boxShadow: radarMode === 'onoff' ? '0 4px 15px rgba(34, 197, 94, 0.4)' : 'none',
                                        transition: 'all 0.2s ease'
                                    }
                                }, '📈 On-Off'),
                                // V6.6: Position percentile toggle - separator
                                radarMode === 'individual' && e('div', { style: { width: '1px', height: '24px', background: 'rgba(71, 85, 105, 0.5)', margin: '0 4px' }}),
                                // V6.6: Position percentile toggle
                                radarMode === 'individual' && e('button', {
                                    onClick: () => setPercentileMode(percentileMode === 'league' ? 'position' : 'league'),
                                    style: {
                                        padding: '8px 12px',
                                        borderRadius: '10px',
                                        border: percentileMode === 'position' ? '2px solid #c084fc' : '2px solid rgba(71, 85, 105, 0.5)',
                                        cursor: 'pointer',
                                        fontWeight: '600',
                                        fontSize: '10px',
                                        background: percentileMode === 'position' ? 'rgba(192, 132, 252, 0.2)' : 'rgba(71, 85, 105, 0.3)',
                                        color: percentileMode === 'position' ? '#c084fc' : '#94a3b8',
                                        transition: 'all 0.2s ease'
                                    },
                                    title: percentileMode === 'position'
                                        ? `Comparing to ${stats.positionRange?.label || 'same position'} (${stats.positionLabel || stats.position?.toFixed(1) || '-'})`
                                        : 'Click to compare against players at same position'
                                }, percentileMode === 'position' ? `📍 vs ${stats.positionRange?.shortLabel || 'Pos'}` : '📍 Position')
                            ),

                            // V6.2: Full-width Percentile Bar Charts (main focus - replaces radar)
                            e('div', {
                                style: {
                                    background: 'linear-gradient(180deg, rgba(15, 23, 42, 0.6) 0%, rgba(30, 41, 59, 0.4) 100%)',
                                    borderRadius: '20px',
                                    padding: '24px',
                                    border: '1px solid rgba(71, 85, 105, 0.3)',
                                    flex: 1,
                                    display: 'flex',
                                    flexDirection: 'column',
                                    minHeight: 0,
                                    overflow: 'hidden'
                                }
                            },
                                // Section header with legends
                                e('div', {
                                    style: {
                                        marginBottom: '16px',
                                        flexShrink: 0
                                    }
                                },
                                    // Title and percentile legend row
                                    e('div', {
                                        style: {
                                            display: 'flex',
                                            justifyContent: 'space-between',
                                            alignItems: 'center',
                                            flexWrap: 'wrap',
                                            gap: '12px',
                                            marginBottom: '12px'
                                        }
                                    },
                                        e('div', {
                                            style: {
                                                fontSize: '16px',
                                                fontWeight: '700',
                                                color: '#e2e8f0',
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: '8px'
                                            }
                                        },
                                            radarMode === 'individual' ? '📊' : '📈',
                                            radarMode === 'individual' ? 'Individual Stats Percentiles' : 'On-Off Impact Percentiles'
                                        ),
                                        // Percentile legend
                                        e('div', {
                                            style: {
                                                display: 'flex',
                                                gap: '8px',
                                                flexWrap: 'wrap'
                                            }
                                        },
                                            [
                                                { label: '80+', color: '#22c55e', name: 'Elite' },
                                                { label: '60+', color: '#84cc16', name: 'Good' },
                                                { label: '40+', color: '#eab308', name: 'Avg' },
                                                { label: '20+', color: '#f97316', name: 'Below' },
                                                { label: '<20', color: '#ef4444', name: 'Poor' }
                                            ].map(item =>
                                                e('div', {
                                                    key: item.label,
                                                    style: {
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: '4px',
                                                        fontSize: '9px',
                                                        color: '#94a3b8',
                                                        padding: '3px 8px',
                                                        background: 'rgba(15, 23, 42, 0.5)',
                                                        borderRadius: '6px',
                                                        border: '1px solid ' + item.color + '40'
                                                    }
                                                },
                                                    e('div', {
                                                        style: {
                                                            width: '8px',
                                                            height: '8px',
                                                            borderRadius: '2px',
                                                            background: item.color,
                                                            boxShadow: '0 0 6px ' + item.color + '80'
                                                        }
                                                    }),
                                                    item.name
                                                )
                                            )
                                        )
                                    ),
                                    // V6.4: Category legend row (only show in individual mode)
                                    radarMode === 'individual' && e('div', {
                                        style: {
                                            display: 'flex',
                                            gap: '6px',
                                            flexWrap: 'wrap',
                                            justifyContent: 'center'
                                        }
                                    },
                                        Object.entries(statGroups).map(([key, group]) =>
                                            e('div', {
                                                key: key,
                                                style: {
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: '4px',
                                                    fontSize: '9px',
                                                    color: group.color,
                                                    padding: '3px 8px',
                                                    background: group.bgColor,
                                                    borderRadius: '6px',
                                                    border: `1px solid ${group.borderColor}`,
                                                    borderLeft: `3px solid ${group.color}`
                                                }
                                            }, group.name)
                                        )
                                    )
                                ),
                                // Stats grid - larger bars filling the space
                                e('div', {
                                    style: {
                                        display: 'grid',
                                        gridTemplateColumns: 'repeat(auto-fit, minmax(320px, 1fr))',
                                        gap: '16px',
                                        flex: 1,
                                        overflowY: 'auto',
                                        padding: '8px 4px',
                                        scrollbarWidth: 'thin',
                                        scrollbarColor: 'rgba(100, 116, 139, 0.5) transparent'
                                    }
                                },
                                    radarData.map((d, idx) => {
                                        // V6.5: Handle no data case - use gray colors
                                        const noData = d.pct === null || !d.hasData;
                                        const barColor = noData
                                            ? { bg: 'rgba(71, 85, 105, 0.5)', border: '#64748b' }
                                            : getPercentileBarColor(d.pct);
                                        const isHighlight = !noData && (d.pct >= 80 || d.pct < 20);
                                        // V6.4: Get group color for visual categorization
                                        const groupInfo = d.group && statGroups[d.group] ? statGroups[d.group] : null;
                                        const groupColor = groupInfo ? groupInfo.color : null;

                                        // DEBUG: Log bar rendering data
                                        const barWidth = noData ? '0%' : (Math.min(100, Math.max(0, d.pct)) + '%');
                                        if (idx === 0 || d.key === 'orebPct' || d.key === 'drebPct') {
                                            console.log(`[BAR DEBUG] ${d.key}: value=${d.value}, pct=${d.pct}, hasData=${d.hasData}, noData=${noData}, barWidth=${barWidth}, barColorBg=${barColor.bg}, barColorBorder=${barColor.border}`);
                                        }
                                        return e('div', {
                                            key: d.key,
                                            style: {
                                                background: groupInfo
                                                    ? `linear-gradient(135deg, ${groupInfo.bgColor} 0%, rgba(15, 23, 42, 0.7) 100%)`
                                                    : (isHighlight
                                                        ? `linear-gradient(135deg, rgba(15, 23, 42, 0.8) 0%, ${barColor.bg.replace('0.7', '0.15').replace('0.8', '0.15')} 100%)`
                                                        : 'rgba(15, 23, 42, 0.6)'),
                                                borderRadius: '14px',
                                                padding: '16px 20px',
                                                border: groupInfo
                                                    ? `1px solid ${groupInfo.borderColor}`
                                                    : (isHighlight ? `1px solid ${barColor.border}40` : '1px solid rgba(71, 85, 105, 0.2)'),
                                                borderLeft: groupInfo ? `4px solid ${groupInfo.color}` : undefined,
                                                transition: 'all 0.2s ease',
                                                position: 'relative',
                                                overflow: 'visible',
                                                opacity: noData ? 0.6 : 1,
                                                minHeight: '100px'
                                            }
                                        },
                                            // Subtle glow for highlight stats
                                            isHighlight && e('div', {
                                                style: {
                                                    position: 'absolute',
                                                    top: 0,
                                                    right: 0,
                                                    width: '60px',
                                                    height: '60px',
                                                    background: `radial-gradient(circle, ${barColor.border}20 0%, transparent 70%)`,
                                                    pointerEvents: 'none'
                                                }
                                            }),
                                            // Label row with value and percentile
                                            e('div', {
                                                style: {
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center',
                                                    marginBottom: '12px',
                                                    position: 'relative',
                                                    zIndex: 1
                                                }
                                            },
                                                e('div', {
                                                    style: {
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: '10px'
                                                    }
                                                },
                                                    e('span', {
                                                        style: {
                                                            fontSize: '14px',
                                                            fontWeight: '700',
                                                            color: noData ? '#64748b' : '#f1f5f9',
                                                            letterSpacing: '0.3px'
                                                        }
                                                    }, d.label),
                                                    d.lowerBetter && e('span', {
                                                        style: {
                                                            fontSize: '8px',
                                                            color: '#f87171',
                                                            background: 'rgba(239, 68, 68, 0.15)',
                                                            padding: '2px 5px',
                                                            borderRadius: '4px'
                                                        }
                                                    }, '↓ lower better')
                                                ),
                                                e('div', {
                                                    style: {
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: '12px'
                                                    }
                                                },
                                                    // Actual value
                                                    e('span', {
                                                        style: {
                                                            fontSize: '18px',
                                                            fontWeight: '800',
                                                            color: noData ? '#475569' : '#e2e8f0',
                                                            fontFamily: 'monospace'
                                                        }
                                                    },
                                                        noData ? '-' : (
                                                            typeof d.value === 'number'
                                                                ? (d.value >= 0 && radarMode === 'onoff' ? '+' : '') + d.value.toFixed(1)
                                                                : '-'
                                                        )
                                                    ),
                                                    // Percentile badge
                                                    e('div', {
                                                        style: {
                                                            fontSize: '12px',
                                                            fontWeight: '700',
                                                            padding: '4px 10px',
                                                            borderRadius: '8px',
                                                            background: noData
                                                                ? 'rgba(71, 85, 105, 0.4)'
                                                                : `linear-gradient(135deg, ${barColor.bg}, ${barColor.border})`,
                                                            color: noData ? '#64748b' : 'white',
                                                            boxShadow: noData ? 'none' : `0 2px 8px ${barColor.bg}`,
                                                            minWidth: '50px',
                                                            textAlign: 'center'
                                                        }
                                                    }, noData ? 'N/A' : Math.round(d.pct) + 'th')
                                                )
                                            ),
                                            // Large percentile bar container - HIGHLY VISIBLE VERSION
                                            e('div', {
                                                className: 'percentile-bar-container',
                                                style: {
                                                    display: 'block',
                                                    width: '100%',
                                                    height: '20px',
                                                    minHeight: '20px',
                                                    background: '#1e293b',
                                                    borderRadius: '10px',
                                                    overflow: 'hidden',
                                                    position: 'relative',
                                                    marginTop: '12px',
                                                    border: '2px solid #475569',
                                                    zIndex: 2,
                                                    boxShadow: 'inset 0 2px 4px rgba(0,0,0,0.3)'
                                                }
                                            },
                                                // Bar fill - SOLID BRIGHT COLORS
                                                e('div', {
                                                    className: 'percentile-bar-fill',
                                                    style: {
                                                        display: 'block',
                                                        position: 'absolute',
                                                        top: '2px',
                                                        left: '2px',
                                                        bottom: '2px',
                                                        width: `calc(${barWidth} - 4px)`,
                                                        minWidth: noData ? '0px' : '8px',
                                                        background: noData ? 'transparent' : barColor.border,
                                                        borderRadius: '8px',
                                                        transition: 'width 0.5s ease-out',
                                                        boxShadow: noData ? 'none' : `0 0 12px ${barColor.border}, 0 0 4px ${barColor.border}`,
                                                        zIndex: 1
                                                    }
                                                }),
                                                // 50% marker
                                                e('div', {
                                                    style: {
                                                        position: 'absolute',
                                                        left: '50%',
                                                        top: '2px',
                                                        bottom: '2px',
                                                        width: '2px',
                                                        background: 'rgba(255, 255, 255, 0.4)',
                                                        zIndex: 5,
                                                        borderRadius: '1px'
                                                    }
                                                })
                                            ),
                                            // Scale labels
                                            e('div', {
                                                style: {
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    marginTop: '4px',
                                                    fontSize: '9px',
                                                    color: '#64748b',
                                                    padding: '0 4px'
                                                }
                                            },
                                                e('span', null, '0'),
                                                e('span', null, '50'),
                                                e('span', null, '100')
                                            )
                                        );
                                    })
                                )
                            ),

                            // Close button
                            e('button', {
                                onClick: () => setShowRadarModal(false),
                                style: {
                                    position: 'absolute',
                                    top: '12px',
                                    right: '12px',
                                    width: '32px',
                                    height: '32px',
                                    borderRadius: '50%',
                                    background: 'rgba(239, 68, 68, 0.8)',
                                    border: 'none',
                                    color: 'white',
                                    fontSize: '16px',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }
                            }, '×')
                        )
                    );
                })()
                // ═══════════════════════════════════════════════════════════════════════════
            );
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // FINAL INTEGRITY VERIFICATION - Application bootstrap requires valid state
        // ═══════════════════════════════════════════════════════════════════════════
        (function _ΞBootstrap() {
            'use strict';

            // Verify all critical components exist
            const _Ξ_BOOT_CHECKS = [
                typeof _ΞCore === 'object',
                typeof _ΞCore.π === 'function',
                typeof _ΞCore.ρ === 'function',
                typeof _ΞCore.α === 'number',
                typeof _ΞCore.δ === 'number',
                typeof _ΞCore.ν === 'string',
                typeof _ΞCore.κ === 'object',
                typeof _ΞCore.ξ === 'object',
                typeof calcPoss === 'function',
                typeof parseCSV === 'function',
                typeof calcSimulatedRatings === 'function',
                typeof RAPMEngine === 'object',
                typeof RAPMEngine._validateLicense === 'function',
                _ΞCore.α === 0.4,
                _ΞCore.δ === 100
            ];

            const _Ξ_BOOT_VALID = _Ξ_BOOT_CHECKS.every(c => c === true);

            if(!_Ξ_BOOT_VALID) {
                document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0f172a;color:#f87171;font-family:sans-serif;flex-direction:column;text-align:center;padding:20px;"><h1 style="margin-bottom:16px;">Application Integrity Error</h1><p style="color:#94a3b8;max-width:500px;">Critical application components are missing or have been modified. The application cannot start. Please ensure you are using an unmodified version of this software.</p></div>';
                return;
            }

            // Verify function integrity through test calculation
            const _Ξ_TEST_RESULT = calcPoss(10, 2, 3, 4);
            const _Ξ_EXPECTED = 10 - 2 + 3 + 0.4 * 4; // Should be 12.6

            // Only proceed if result is valid OR license hasn't been validated yet
            if(isNaN(_Ξ_TEST_RESULT) && _ΞCore.ν !== 'UNVALIDATED') {
                document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0f172a;color:#f87171;font-family:sans-serif;flex-direction:column;"><h1>Calculation Engine Error</h1><p style="color:#94a3b8;margin-top:16px;">Core calculation functions have been compromised.</p></div>';
                return;
            }

            // Add watchdog for post-load tampering
            let _Ξ_tamperCount = 0;
            const _Ξ_watchdog = setInterval(() => {
                const checks = [
                    typeof _ΞCore !== 'undefined',
                    typeof _ΞCore.π === 'function',
                    _ΞCore.α === 0.4,
                    _ΞCore.δ === 100
                ];

                if(!checks.every(c => c === true)) {
                    _Ξ_tamperCount++;
                    if(_Ξ_tamperCount >= 2) {
                        clearInterval(_Ξ_watchdog);
                        document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0f172a;color:#f87171;font-family:sans-serif;"><h1>Runtime Tampering Detected</h1></div>';
                    }
                } else {
                    _Ξ_tamperCount = 0;
                }
            }, 45000);

            // Initialize React application
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(e(App));
        })();
    </script>
</body>
</html>
