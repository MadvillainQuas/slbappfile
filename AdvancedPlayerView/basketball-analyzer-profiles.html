<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basketball Player Breakdown Analyzer V9.0</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=JetBrains+Mono:wght@400;600&family=Sora:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* ============================================
           CSS VARIABLES & RESET
           ============================================ */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            /* Background Colors */
            --bg-primary: #0a0c10;
            --bg-secondary: #12151c;
            --bg-tertiary: #1a1e28;
            --bg-card: rgba(26, 30, 40, 0.7);
            --bg-card-hover: rgba(35, 40, 52, 0.85);
            --bg-glass: rgba(255, 255, 255, 0.03);
            
            /* Border Colors */
            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-default: rgba(255, 255, 255, 0.1);
            --border-accent: rgba(99, 102, 241, 0.4);
            
            /* Text Colors */
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --text-dim: #475569;
            
            /* Accent Colors */
            --accent-indigo: #6366f1;
            --accent-violet: #8b5cf6;
            --accent-blue: #3b82f6;
            --accent-cyan: #06b6d4;
            --accent-emerald: #10b981;
            --accent-amber: #f59e0b;
            --accent-rose: #f43f5e;
            --accent-orange: #f97316;
            
            /* Percentile Colors - More saturated */
            --pct-elite-bg: rgba(16, 185, 129, 0.2);
            --pct-elite-border: rgba(16, 185, 129, 0.5);
            --pct-elite-text: #34d399;
            
            --pct-good-bg: rgba(132, 204, 22, 0.18);
            --pct-good-border: rgba(132, 204, 22, 0.45);
            --pct-good-text: #a3e635;
            
            --pct-avg-bg: rgba(250, 204, 21, 0.15);
            --pct-avg-border: rgba(250, 204, 21, 0.4);
            --pct-avg-text: #fde047;
            
            --pct-below-bg: rgba(251, 146, 60, 0.18);
            --pct-below-border: rgba(251, 146, 60, 0.45);
            --pct-below-text: #fb923c;
            
            --pct-poor-bg: rgba(248, 113, 113, 0.2);
            --pct-poor-border: rgba(248, 113, 113, 0.5);
            --pct-poor-text: #f87171;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
            --shadow-glow: 0 0 40px rgba(99, 102, 241, 0.15);
            
            /* Transitions */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.25s ease;
            --transition-slow: 0.4s ease;
        }
        
        /* ============================================
           BASE STYLES
           ============================================ */
        body {
            font-family: 'Sora', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            zoom: 1.1;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(ellipse 80% 50% at 20% -10%, rgba(99, 102, 241, 0.12) 0%, transparent 50%),
                radial-gradient(ellipse 60% 40% at 80% 110%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse 50% 30% at 50% 50%, rgba(6, 182, 212, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* ============================================
           HEADER STYLES
           ============================================ */
        .header {
            text-align: center;
            padding: 32px 24px;
            margin-bottom: 24px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.08) 0%, rgba(139, 92, 246, 0.06) 50%, rgba(6, 182, 212, 0.04) 100%);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.5), rgba(139, 92, 246, 0.5), transparent);
        }
        
        .header h1 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(2.5rem, 5vw, 4rem);
            letter-spacing: 6px;
            background: linear-gradient(135deg, #818cf8 0%, #c4b5fd 30%, #67e8f9 70%, #a5f3fc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
            text-shadow: 0 0 60px rgba(99, 102, 241, 0.3);
        }
        
        .header-subtitle {
            color: var(--text-secondary);
            font-size: 0.95rem;
            font-weight: 400;
        }
        
        .header-meta {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-top: 16px;
            flex-wrap: wrap;
        }
        
        .header-meta-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 100px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .header-meta-item .value {
            color: var(--text-primary);
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* ============================================
           UPLOAD SCREEN
           ============================================ */
        .upload-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 70vh;
        }
        
        .upload-box {
            background: var(--bg-card);
            border: 2px dashed var(--border-default);
            border-radius: 24px;
            padding: 60px 80px;
            text-align: center;
            max-width: 600px;
            transition: var(--transition-normal);
            backdrop-filter: blur(10px);
        }
        
        .upload-box:hover {
            border-color: var(--accent-indigo);
            box-shadow: var(--shadow-glow);
        }
        
        .upload-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            filter: grayscale(0.3);
        }
        
        .upload-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 12px;
        }
        
        .upload-desc {
            color: var(--text-secondary);
            margin-bottom: 32px;
            font-size: 0.95rem;
        }
        
        .upload-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .upload-btn {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 14px 28px;
            border-radius: 12px;
            border: none;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: var(--transition-fast);
            font-family: inherit;
        }
        
        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .upload-btn.primary {
            background: linear-gradient(135deg, var(--accent-indigo), var(--accent-violet));
            color: white;
        }
        
        .upload-btn.secondary {
            background: linear-gradient(135deg, var(--accent-emerald), var(--accent-cyan));
            color: white;
        }
        
        .file-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 100px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 8px;
            background: var(--pct-elite-bg);
            color: var(--pct-elite-text);
            border: 1px solid var(--pct-elite-border);
        }
        
        /* ============================================
           CONTROLS
           ============================================ */
        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            align-items: flex-end;
        }
        
        .control-group {
            flex: 1;
            min-width: 280px;
        }
        
        .control-label {
            display: block;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }
        
        .control-select {
            width: 100%;
            padding: 14px 18px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-family: inherit;
            cursor: pointer;
            transition: var(--transition-fast);
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%2394a3b8'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'%3E%3C/path%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 20px;
        }
        
        .control-select:hover, .control-select:focus {
            border-color: var(--accent-indigo);
            outline: none;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
        }
        
        .control-buttons {
            display: flex;
            gap: 8px;
        }
        
        .control-btn {
            padding: 14px 18px;
            border-radius: 12px;
            border: 1px solid var(--border-default);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-fast);
            font-family: inherit;
        }
        
        .control-btn:hover {
            border-color: var(--accent-indigo);
            color: var(--text-primary);
            background: var(--bg-card-hover);
        }
        
        /* ============================================
           MAIN GRID LAYOUT
           ============================================ */
        .main-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 16px;
        }
        
        .section {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
            transition: var(--transition-normal);
        }
        
        .section:hover {
            border-color: var(--border-default);
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .section-icon {
            font-size: 1.2rem;
        }
        
        .section-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            letter-spacing: 2px;
            color: var(--text-primary);
        }
        
        .section-subtitle {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-left: auto;
        }
        
        /* Grid span utilities */
        .span-12 { grid-column: span 12; }
        .span-8 { grid-column: span 8; }
        .span-6 { grid-column: span 6; }
        .span-4 { grid-column: span 4; }
        .span-3 { grid-column: span 3; }
        
        @media (max-width: 1400px) {
            .span-8, .span-6 { grid-column: span 12; }
            .span-4, .span-3 { grid-column: span 6; }
        }
        
        @media (max-width: 900px) {
            .span-4, .span-3 { grid-column: span 12; }
        }
        
        /* ============================================
           STAT GRID
           ============================================ */
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
        }
        
        .stat-grid.compact {
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
        }
        
        .stat-card {
            background: rgba(0, 0, 0, 0.25);
            border-radius: 10px;
            padding: 12px 10px;
            text-align: center;
            border: 1px solid transparent;
            transition: var(--transition-fast);
        }
        
        .stat-card:hover {
            border-color: var(--border-default);
            transform: translateY(-1px);
        }
        
        .stat-card.pct-elite {
            background: var(--pct-elite-bg);
            border-color: var(--pct-elite-border);
        }
        .stat-card.pct-good {
            background: var(--pct-good-bg);
            border-color: var(--pct-good-border);
        }
        .stat-card.pct-avg {
            background: var(--pct-avg-bg);
            border-color: var(--pct-avg-border);
        }
        .stat-card.pct-below {
            background: var(--pct-below-bg);
            border-color: var(--pct-below-border);
        }
        .stat-card.pct-poor {
            background: var(--pct-poor-bg);
            border-color: var(--pct-poor-border);
        }
        
        .stat-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            line-height: 1.2;
        }
        
        .stat-value.pct-elite { color: var(--pct-elite-text); }
        .stat-value.pct-good { color: var(--pct-good-text); }
        .stat-value.pct-avg { color: var(--pct-avg-text); }
        .stat-value.pct-below { color: var(--pct-below-text); }
        .stat-value.pct-poor { color: var(--pct-poor-text); }
        
        .stat-percentile {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-top: 4px;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.6rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .stat-percentile.pct-elite {
            background: var(--pct-elite-bg);
            color: var(--pct-elite-text);
        }
        .stat-percentile.pct-good {
            background: var(--pct-good-bg);
            color: var(--pct-good-text);
        }
        .stat-percentile.pct-avg {
            background: var(--pct-avg-bg);
            color: var(--pct-avg-text);
        }
        .stat-percentile.pct-below {
            background: var(--pct-below-bg);
            color: var(--pct-below-text);
        }
        .stat-percentile.pct-poor {
            background: var(--pct-poor-bg);
            color: var(--pct-poor-text);
        }
        
        .stat-sub {
            font-size: 0.6rem;
            color: var(--text-dim);
            margin-top: 2px;
        }
        
        /* ============================================
           PLAY TYPE DISTRIBUTION BAR
           ============================================ */
        .playtype-bar-wrapper {
            margin: 12px 0;
        }
        
        .playtype-bar {
            display: flex;
            height: 36px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .playtype-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.55rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition: var(--transition-fast);
            overflow: hidden;
            white-space: nowrap;
            padding: 0 4px;
        }
        
        .playtype-segment:hover {
            filter: brightness(1.2);
        }
        
        /* Play type colors */
        .pt-transition { background: linear-gradient(135deg, #f59e0b, #fbbf24); }
        .pt-spot-up { background: linear-gradient(135deg, #3b82f6, #60a5fa); }
        .pt-pnr-bh { background: linear-gradient(135deg, #8b5cf6, #a78bfa); }
        .pt-isolation { background: linear-gradient(135deg, #ef4444, #f87171); }
        .pt-post-up { background: linear-gradient(135deg, #f97316, #fb923c); }
        .pt-cut { background: linear-gradient(135deg, #10b981, #34d399); }
        .pt-offscreen { background: linear-gradient(135deg, #06b6d4, #22d3ee); }
        .pt-pnr-rm { background: linear-gradient(135deg, #ec4899, #f472b6); }
        .pt-handoffs { background: linear-gradient(135deg, #84cc16, #a3e635); }
        .pt-putbacks { background: linear-gradient(135deg, #6366f1, #818cf8); }
        .pt-misc { background: linear-gradient(135deg, #6b7280, #9ca3af); }
        
        .playtype-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }
        
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 3px;
        }
        
        /* ============================================
           SPLIT CARDS (On/Off Ball, Half Court/Transition)
           ============================================ */
        .split-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        @media (max-width: 600px) {
            .split-container { grid-template-columns: 1fr; }
        }
        
        .split-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 16px;
            border-left: 3px solid transparent;
        }
        
        .split-card.type-onball { border-left-color: var(--accent-rose); }
        .split-card.type-offball { border-left-color: var(--accent-emerald); }
        .split-card.type-halfcourt { border-left-color: var(--accent-blue); }
        .split-card.type-transition { border-left-color: var(--accent-amber); }
        .split-card.type-left { border-left-color: var(--accent-rose); }
        .split-card.type-right { border-left-color: var(--accent-blue); }
        
        .split-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .split-icon { font-size: 1.1rem; }
        
        .split-title {
            font-weight: 700;
            font-size: 0.9rem;
        }
        
        .split-title.type-onball { color: var(--accent-rose); }
        .split-title.type-offball { color: var(--accent-emerald); }
        .split-title.type-halfcourt { color: var(--accent-blue); }
        .split-title.type-transition { color: var(--accent-amber); }
        .split-title.type-left { color: var(--accent-rose); }
        .split-title.type-right { color: var(--accent-blue); }
        
        .split-badge {
            margin-left: auto;
            padding: 3px 8px;
            border-radius: 100px;
            font-size: 0.65rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .split-desc {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-bottom: 12px;
        }
        
        /* ============================================
           HAND VISUALIZATION
           ============================================ */
        .hands-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }
        
        .hand-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 14px;
            padding: 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .hand-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.08;
            pointer-events: none;
        }
        
        .hand-card.left::before {
            background: linear-gradient(135deg, var(--accent-rose), transparent);
        }
        
        .hand-card.right::before {
            background: linear-gradient(135deg, transparent, var(--accent-blue));
        }
        
        .hand-icon {
            font-size: 2.5rem;
            margin-bottom: 8px;
        }
        
        .hand-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
        }
        
        /* ============================================
           SCOUT REPORT STYLES
           ============================================ */
        .scout-report-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
        }
        
        .scout-header-row {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 20px;
            align-items: stretch;
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid var(--border-subtle);
        }
        
        /* Expanded header row with radar */
        .scout-header-row-expanded {
            display: grid;
            grid-template-columns: 260px 1fr;
            gap: 20px;
            align-items: start;
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid var(--border-subtle);
            min-height: 620px;
        }
        
        .scout-header-left {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .player-info-compact {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .scout-header-radar {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 0;
        }
        
        .radar-title-inline {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            letter-spacing: 2px;
            color: var(--accent-cyan);
            margin-bottom: 4px;
            text-align: center;
        }
        
        .radar-subtitle-inline {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 8px;
            text-align: center;
        }
        
        .season-dropdown-container {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }
        
        .season-dropdown-wrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .season-chip {
            display: inline-block;
            padding: 3px 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            font-size: 0.65rem;
            color: var(--text-muted);
            cursor: pointer;
            transition: var(--transition-fast);
        }
        
        .season-chip:hover {
            border-color: var(--accent-indigo);
            color: var(--text-primary);
        }
        
        .season-chip.selected {
            background: var(--accent-indigo);
            border-color: var(--accent-indigo);
            color: white;
        }
        
        .play-type-distribution-mini {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }
        
        @media (max-width: 1100px) {
            .scout-header-row-expanded {
                grid-template-columns: 1fr;
                min-height: auto;
            }
            .scout-header-radar {
                order: -1;
            }
        }
        
        @media (max-width: 900px) {
            .scout-header-row {
                grid-template-columns: 1fr;
            }
        }
        
        /* Full-width radar section */
        .scout-radar-row {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 24px;
            border: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .radar-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            letter-spacing: 3px;
            color: var(--accent-cyan);
            margin-bottom: 8px;
            text-align: center;
        }
        
        .radar-subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 16px;
            text-align: center;
        }
        
        .player-photo-box {
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed var(--border-default);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 180px;
            max-height: 220px;
            color: var(--text-muted);
            font-size: 0.8rem;
            text-align: center;
            cursor: pointer;
            transition: var(--transition-normal);
            position: relative;
            overflow: hidden;
        }
        
        .player-photo-box:hover {
            border-color: var(--accent-indigo);
            background: rgba(99, 102, 241, 0.1);
        }
        
        .player-photo-box img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .player-info-center {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 12px;
        }
        
        .player-name-display {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2rem;
            letter-spacing: 2px;
            color: var(--text-primary);
            line-height: 1;
        }
        
        .player-role-badge {
            display: inline-block;
            padding: 4px 12px;
            background: linear-gradient(135deg, var(--accent-indigo), var(--accent-purple));
            border-radius: 16px;
            font-family: 'Inter', sans-serif;
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            color: white;
            text-transform: uppercase;
            cursor: help;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
            max-width: fit-content;
        }
        
        .dist-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            min-width: 50px;
        }
        
        .dist-label {
            font-size: 0.55rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .dist-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--accent-cyan);
        }
        
        .player-team-display {
            font-size: 0.95rem;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .season-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }
        
        .season-checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition-fast);
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .season-checkbox-item:hover {
            background: rgba(99, 102, 241, 0.2);
        }
        
        .season-checkbox-item.selected {
            background: rgba(99, 102, 241, 0.3);
            border: 1px solid var(--accent-indigo);
            color: var(--text-primary);
        }
        
        .season-checkbox-item input {
            accent-color: var(--accent-indigo);
        }
        
        /* Scout Sections */
        .scout-section-row {
            display: grid;
            grid-template-columns: 180px 1fr 300px;
            gap: 16px;
            align-items: stretch;
        }
        
        @media (max-width: 900px) {
            .scout-section-row {
                grid-template-columns: 1fr;
            }
        }
        
        .scout-section-box {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border-subtle);
        }
        
        /* Collapsible Section Wrapper */
        .scout-collapsible-section {
            margin-bottom: 16px;
        }
        
        .scout-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.8));
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .scout-section-header:hover {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(51, 65, 85, 0.8));
            border-color: var(--accent-cyan);
        }
        
        .scout-section-header-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 3px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .scout-section-header-title.on-ball { color: #f97316; }
        .scout-section-header-title.spacing { color: #06b6d4; }
        .scout-section-header-title.finishing { color: #facc15; }
        .scout-section-header-title.defense { color: #ef4444; }
        
        /* ============================================
           SCOUTING KEYS STYLES
           ============================================ */
        .scouting-keys-section {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.08) 0%, rgba(139, 92, 246, 0.05) 100%);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }
        
        .scouting-keys-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            letter-spacing: 2px;
            color: var(--accent-indigo);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .scouting-keys-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
            align-items: start;
        }
        
        .scout-key-card {
            background: rgba(0, 0, 0, 0.25);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 0;
        }
        
        .scout-key-card-expanded {
            background: rgba(0, 0, 0, 0.25);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 0;
        }
        
        .scout-key-header {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .scout-key-content {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
        }
        
        .scout-key-bar-container {
            display: flex;
            height: 20px;
            border-radius: 4px;
            overflow: hidden;
            background: rgba(0,0,0,0.3);
        }
        
        .scout-key-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.55rem;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            min-width: 20px;
        }
        
        .scout-key-stats {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .scout-key-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            min-width: 45px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            padding: 6px;
        }
        
        .scout-key-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 700;
        }
        
        .scout-key-stat-label {
            font-size: 0.5rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        .scout-key-duo {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        
        .scout-key-duo-item {
            text-align: center;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            padding: 6px 8px;
        }
        
        .scout-key-duo-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            font-weight: 700;
        }
        
        .scout-key-duo-label {
            font-size: 0.5rem;
            color: var(--text-muted);
        }
        
        .scout-key-mini-bar {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.55rem;
        }
        
        .scout-key-mini-bar-fill {
            height: 4px;
            border-radius: 2px;
            flex: 1;
            background: rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
        }
        
        .scout-key-mini-bar-fill::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            border-radius: 2px;
        }
        
        .scout-section-header-stats {
            display: flex;
            gap: 24px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }
        
        .scout-section-header-stat {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .scout-section-header-stat-label {
            color: var(--text-muted);
            font-size: 0.65rem;
        }
        
        .scout-section-header-stat-value {
            font-weight: 600;
        }
        
        .scout-section-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 0.7rem;
        }
        
        .scout-section-toggle-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }
        
        .scout-section-toggle-icon.expanded {
            transform: rotate(180deg);
        }
        
        .scout-section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, opacity 0.3s ease, margin 0.3s ease;
            opacity: 0;
            margin-top: 0;
        }
        
        .scout-section-content.expanded {
            max-height: 2000px;
            opacity: 1;
            margin-top: 12px;
            transition: max-height 0.5s ease-in, opacity 0.3s ease, margin 0.3s ease;
        }
        
        .scout-section-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1rem;
            letter-spacing: 2px;
            color: var(--accent-cyan);
            margin-bottom: 8px;
        }
        
        .scout-section-subtitle {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 12px;
        }
        
        /* Bar Chart Container */
        .scout-bar-chart {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .scout-bar-item {
            display: flex;
            align-items: center;
            height: 24px;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .scout-bar-fill {
            height: 100%;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 0.65rem;
            font-weight: 600;
            color: white;
            min-width: 30px;
        }
        
        .scout-bar-fill.red { background: linear-gradient(90deg, #ef4444, #f87171); }
        .scout-bar-fill.yellow { background: linear-gradient(90deg, #f59e0b, #fbbf24); }
        .scout-bar-fill.green { background: linear-gradient(90deg, #10b981, #34d399); }
        
        /* Hexagon Radar Chart */
        .radar-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        
        .radar-svg {
            max-width: 100%;
            height: auto;
        }
        
        /* Scout Report Text Area */
        .scout-notes-section {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-subtle);
        }
        
        .scout-notes-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            letter-spacing: 2px;
            color: var(--text-primary);
            margin-bottom: 12px;
        }
        
        .scout-notes-textarea {
            width: 100%;
            min-height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-default);
            border-radius: 8px;
            padding: 12px;
            color: var(--text-primary);
            font-family: 'Sora', sans-serif;
            font-size: 0.85rem;
            resize: vertical;
        }
        
        .scout-notes-textarea:focus {
            outline: none;
            border-color: var(--accent-indigo);
        }
        
        .scout-notes-textarea::placeholder {
            color: var(--text-dim);
        }
        
        /* On-Off Framework Box */
        .onoff-placeholder {
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed var(--border-default);
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
        }
        
        /* Hands Compact View */
        .hands-compact {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        .hand-compact {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            min-width: 80px;
        }
        
        .hand-compact-icon {
            font-size: 2rem;
            margin-bottom: 4px;
        }
        
        .hand-compact-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        
        .hand-compact-pct {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            font-weight: 700;
        }
        
        .hand-compact-ppp {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        
        .hand-compact-per75 {
            font-size: 0.65rem;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .hand-shot-types {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
        }
        
        .shot-type-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            padding: 2px 0;
        }
        
        .shot-type-label {
            color: var(--text-muted);
        }
        
        .shot-type-value {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
        }
        
        /* Shot Distribution Chart */
        .shot-dist-chart {
            padding: 12px;
        }
        
        .shot-dist-bars {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .shot-dist-row {
            display: grid;
            grid-template-columns: 50px 1fr 45px 55px;
            align-items: center;
            gap: 8px;
        }
        
        .shot-dist-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
        }
        
        .shot-dist-bar-container {
            height: 18px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .shot-dist-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .shot-dist-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--text-primary);
            text-align: right;
        }
        
        .shot-dist-fg {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-align: right;
        }
        
        .shot-dist-volume {
            margin-top: 12px;
            text-align: center;
            font-size: 0.65rem;
            color: var(--text-dim);
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .hand-title {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }
        
        .hand-pct {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 12px;
        }
        
        .hand-stats {
            display: grid;
            gap: 6px;
        }
        
        .hand-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.25);
            border-radius: 6px;
            font-size: 0.75rem;
        }
        
        .hand-stat-label { color: var(--text-secondary); }
        .hand-stat-value { font-weight: 600; font-family: 'JetBrains Mono', monospace; }
        
        /* ============================================
           SHOT ZONES
           ============================================ */
        .shot-zones {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .shot-zone {
            background: rgba(0, 0, 0, 0.25);
            border-radius: 10px;
            padding: 14px;
            text-align: center;
            border: 1px solid transparent;
            transition: var(--transition-fast);
        }
        
        .shot-zone:hover {
            border-color: var(--border-default);
        }
        
        .shot-zone-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        .shot-zone-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.4rem;
            font-weight: 700;
        }
        
        .shot-zone-sub {
            font-size: 0.6rem;
            color: var(--text-dim);
            margin-top: 2px;
        }
        
        /* ============================================
           ROLL MAN TYPES
           ============================================ */
        .rollman-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }
        
        .rollman-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            border: 1px solid transparent;
            transition: var(--transition-fast);
        }
        
        .rollman-card:hover {
            border-color: var(--accent-violet);
            transform: translateY(-2px);
        }
        
        .rollman-icon { font-size: 1.8rem; margin-bottom: 8px; }
        .rollman-name { font-weight: 600; font-size: 0.8rem; margin-bottom: 8px; }
        
        .rollman-pct {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.6rem;
            font-weight: 800;
            margin-bottom: 8px;
        }
        
        /* ============================================
           POST BLOCKS
           ============================================ */
        .post-blocks {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }
        
        .post-block {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 18px;
            position: relative;
        }
        
        .post-block::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            border-radius: 0 0 12px 12px;
        }
        
        .post-block.left::after {
            background: linear-gradient(90deg, var(--accent-rose), transparent);
        }
        
        .post-block.right::after {
            background: linear-gradient(90deg, transparent, var(--accent-blue));
        }
        
        .post-block-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .post-block-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1rem;
            letter-spacing: 1px;
        }
        
        .post-block-pct {
            margin-left: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        .post-moves {
            display: grid;
            gap: 6px;
        }
        
        .post-move {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.25);
            border-radius: 6px;
            font-size: 0.75rem;
        }
        
        /* ============================================
           TRANSITION ROLES
           ============================================ */
        .trans-roles {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
            gap: 8px;
        }
        
        .trans-role {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 12px 8px;
            text-align: center;
        }
        
        .trans-role-icon { font-size: 1.3rem; margin-bottom: 4px; }
        .trans-role-name { font-size: 0.6rem; color: var(--text-muted); text-transform: uppercase; margin-bottom: 4px; }
        .trans-role-pct { font-family: 'JetBrains Mono', monospace; font-size: 1rem; font-weight: 700; }
        
        /* ============================================
           SUBSECTION
           ============================================ */
        .subsection {
            background: rgba(0, 0, 0, 0.15);
            border-radius: 10px;
            padding: 14px;
            margin-top: 14px;
        }
        
        .subsection-title {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--accent-cyan);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        /* ============================================
           MINI STATS
           ============================================ */
        .mini-stats {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .mini-stat {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.7rem;
        }
        
        .mini-stat-label { color: var(--text-muted); }
        .mini-stat-value { font-weight: 600; font-family: 'JetBrains Mono', monospace; }
        
        /* ============================================
           SPACING METER
           ============================================ */
        .spacing-meter {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.12), rgba(99, 102, 241, 0.08));
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 16px;
            padding: 24px;
            text-align: center;
        }
        
        .spacing-label {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.9rem;
            letter-spacing: 2px;
            color: var(--accent-violet);
            margin-bottom: 8px;
        }
        
        .spacing-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 3rem;
            font-weight: 800;
        }
        
        .spacing-desc {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 8px;
        }
        
        /* ============================================
           DATA TABLE
           ============================================ */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }
        
        .data-table th {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 8px;
            text-align: left;
            font-size: 0.6rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .data-table td {
            padding: 10px 8px;
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .data-table tr:hover {
            background: rgba(99, 102, 241, 0.05);
        }
        
        /* ============================================
           LOADING STATE
           ============================================ */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 80px;
            color: var(--text-muted);
        }
        
        .loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border-default);
            border-top-color: var(--accent-indigo);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 12px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* ============================================
           EMPTY STATE
           ============================================ */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }
        
        .empty-icon { font-size: 2.5rem; margin-bottom: 12px; opacity: 0.5; }
        .empty-text { font-size: 0.85rem; }
        
        /* ============================================
           TABS NAVIGATION
           ============================================ */
        .tabs-container {
            margin-bottom: 24px;
        }
        
        .tabs-nav {
            display: flex;
            gap: 4px;
            padding: 6px;
            background: var(--bg-tertiary);
            border-radius: 14px;
            border: 1px solid var(--border-subtle);
        }
        
        .tab-btn {
            flex: 1;
            padding: 12px 24px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 10px;
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .tab-btn:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }
        
        .tab-btn.active {
            background: linear-gradient(135deg, var(--accent-indigo), var(--accent-violet));
            color: white;
            box-shadow: var(--shadow-md);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Tab fade transition animation */
        @keyframes tabFadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .tab-fade-in {
            animation: tabFadeIn 0.3s ease-out forwards;
        }
        
        /* Smooth transitions for tab content */
        .tab-transition-wrapper {
            animation: tabFadeIn 0.25s ease-out;
        }
        
        /* ============================================
           PIE CHART
           ============================================ */
        .pie-charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }
        
        .pie-chart-wrapper {
            text-align: center;
        }
        
        .pie-chart-title {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }
        
        .pie-chart-svg {
            width: 180px;
            height: 180px;
            margin: 0 auto;
        }
        
        .pie-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-top: 12px;
        }
        
        .pie-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.6rem;
            color: var(--text-secondary);
            padding: 3px 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        .pie-legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }
        
        @media (max-width: 768px) {
            .pie-charts-container {
                grid-template-columns: 1fr;
            }
        }
        
        /* Screenshot Modal Styles - Enhanced for Social Media Export */
        .screenshot-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 100000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        .screenshot-modal-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            align-items: center;
        }
        
        .screenshot-modal-btn {
            padding: 12px 24px;
            border-radius: 10px;
            border: none;
            font-family: 'Sora', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .screenshot-modal-btn.capture {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            font-size: 1rem;
        }
        
        .screenshot-modal-btn.capture:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(34, 197, 94, 0.4);
        }
        
        .screenshot-modal-btn.capture:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .screenshot-modal-btn.close {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .screenshot-modal-btn.close:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .screenshot-modal-info {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.85rem;
            margin-left: 16px;
        }
        
        .screenshot-viewfinder {
            width: 1920px;
            height: 1080px;
            background: linear-gradient(145deg, #0a0c10 0%, #0f1218 50%, #12151c 100%);
            border-radius: 0;
            overflow: hidden;
            transform-origin: center center;
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.3), 0 30px 80px rgba(0, 0, 0, 0.7);
            position: relative;
        }
        
        .screenshot-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .screenshot-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 24px 40px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.25), rgba(139, 92, 246, 0.2), rgba(236, 72, 153, 0.1));
            border-bottom: 2px solid rgba(99, 102, 241, 0.4);
            flex-shrink: 0;
        }
        
        .screenshot-player-info {
            display: flex;
            align-items: center;
            gap: 24px;
        }
        
        .screenshot-player-photo {
            width: 100px;
            height: 115px;
            border-radius: 10px;
            object-fit: cover;
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }
        
        .screenshot-player-name {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 3.5rem;
            letter-spacing: 4px;
            background: linear-gradient(135deg, #ffffff 0%, #a5b4fc 50%, #c4b5fd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(165, 180, 252, 0.3);
            line-height: 1;
        }
        
        .screenshot-badges {
            display: flex;
            gap: 12px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .screenshot-badge {
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .screenshot-section-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.2rem;
            letter-spacing: 3px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .screenshot-body {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 40px;
            overflow: hidden;
            position: relative;
            min-height: 900px;
        }
        
        .screenshot-preview-wrapper {
            box-shadow: 0 25px 100px rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .screenshot-capture-container {
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.3);
        }
        
        .screenshot-clone {
            /* Ensure cloned content renders properly */
            position: absolute !important;
        }
        
        .ss-body-area {
            overflow: hidden;
        }
        
        .screenshot-watermark {
            position: absolute;
            bottom: 16px;
            right: 24px;
            font-family: 'Sora', sans-serif;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.25);
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .screenshot-watermark::before {
            content: '';
            font-size: 0.9rem;
        }
        
        .screenshot-date {
            position: absolute;
            bottom: 16px;
            left: 24px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.2);
        }
        
        /* Screenshot content grid layouts */
        .ss-grid-2col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            width: 100%;
            height: 100%;
        }
        
        .ss-grid-3col {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 24px;
            width: 100%;
            height: 100%;
        }
        
        .ss-card {
            background: rgba(26, 30, 40, 0.8);
            border-radius: 16px;
            padding: 24px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }
        
        .ss-card-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            letter-spacing: 2px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ss-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .ss-stat-row:last-child {
            border-bottom: none;
        }
        
        .ss-stat-label {
            font-size: 1rem;
            color: var(--text-secondary);
        }
        
        .ss-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.4rem;
            font-weight: 700;
        }
        
        .ss-big-stat {
            text-align: center;
            padding: 20px;
        }
        
        .ss-big-stat-value {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 4rem;
            line-height: 1;
        }
        
        .ss-big-stat-label {
            font-size: 1rem;
            color: var(--text-muted);
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .ss-radar-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .ss-bar-chart {
            width: 100%;
        }
        
        .ss-bar-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .ss-bar-label {
            width: 120px;
            font-size: 1rem;
            color: var(--text-secondary);
        }
        
        .ss-bar-track {
            flex: 1;
            height: 28px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        
        .ss-bar-fill {
            height: 100%;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
            min-width: 50px;
        }
        
        .ss-bar-value {
            margin-left: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            min-width: 60px;
        }
        
        .ss-ppp-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .ss-percentile-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 10px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .camera-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.6);
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
            z-index: 10;
            backdrop-filter: blur(4px);
        }
        
        .camera-btn:hover {
            background: rgba(99, 102, 241, 0.6);
            border-color: rgba(99, 102, 241, 0.8);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }
        
        /* Leaderboard styles */
        .leaderboard-toggle:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        
        .leaderboard-panel select:focus,
        .leaderboard-panel input:focus {
            outline: none;
            border-color: var(--accent-indigo);
        }
        
        .leaderboard-panel > div > div:hover {
            background: rgba(255, 255, 255, 0.1) !important;
        }
        
        .radar-leaderboard-container {
            margin-bottom: 16px;
        }
        
        /* ============================================
           PROFILES TAB STYLES
           ============================================ */
        .profiles-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .profiles-controls {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid var(--border-subtle);
        }
        
        .profiles-controls-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            cursor: pointer;
            user-select: none;
        }
        
        .profiles-controls-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 2px;
            color: var(--accent-cyan);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .profiles-controls-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 0.75rem;
        }
        
        .profiles-controls-toggle-icon {
            font-size: 1rem;
            transition: transform 0.3s ease;
        }
        
        .profiles-controls-toggle-icon.expanded {
            transform: rotate(180deg);
        }
        
        .profiles-filters-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, opacity 0.3s ease;
            opacity: 0;
        }
        
        .profiles-filters-content.expanded {
            max-height: 800px;
            opacity: 1;
            transition: max-height 0.5s ease-in, opacity 0.3s ease;
        }
        
        .profiles-filter-row {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: flex-end;
            margin-bottom: 16px;
        }
        
        .profiles-filter-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .profiles-filter-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .profiles-filter-select,
        .profiles-filter-input {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-default);
            border-radius: 8px;
            padding: 8px 12px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: 'Sora', sans-serif;
            min-width: 140px;
        }
        
        .profiles-filter-select:focus,
        .profiles-filter-input:focus {
            outline: none;
            border-color: var(--accent-indigo);
        }
        
        .profiles-filter-input {
            width: 100px;
        }
        
        .profiles-stat-filters {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-subtle);
        }
        
        .profiles-stat-filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            border: 1px solid var(--border-subtle);
        }
        
        .profiles-stat-filter-name {
            font-size: 0.75rem;
            color: var(--text-secondary);
            flex: 1;
            min-width: 80px;
        }
        
        .profiles-stat-filter-inputs {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        .profiles-stat-filter-inputs input {
            width: 60px;
            padding: 4px 6px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .profiles-stat-filter-inputs span {
            font-size: 0.7rem;
            color: var(--text-dim);
        }
        
        /* Profiles Table */
        .profiles-table-container {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid var(--border-subtle);
            overflow: hidden;
        }
        
        .profiles-table-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        
        .profiles-table-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            letter-spacing: 3px;
            color: var(--text-primary);
        }
        
        .profiles-table-info {
            display: flex;
            gap: 16px;
            align-items: center;
        }
        
        .profiles-table-count {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .profiles-table-scroll {
            overflow-x: auto;
            overflow-y: auto;
            max-height: 75vh;
        }
        
        .profiles-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 0.8rem;
        }
        
        .profiles-table thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--bg-secondary);
        }
        
        .profiles-table th {
            padding: 10px 12px;
            text-align: left;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-default);
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .profiles-table th:hover {
            color: var(--text-primary);
            background: rgba(99, 102, 241, 0.1);
        }
        
        .profiles-table th.sorted {
            color: var(--accent-cyan);
        }
        
        .profiles-table th.sorted::after {
            content: ' ';
        }
        
        .profiles-table th.sorted.asc::after {
            content: ' ';
        }
        
        .profiles-table th.sticky-col {
            position: sticky;
            z-index: 11;
            background: var(--bg-secondary);
            box-shadow: 2px 0 8px rgba(0,0,0,0.3);
        }
        
        .profiles-table th.sticky-col:first-child {
            left: 0;
            min-width: 45px;
        }
        
        .profiles-table th.sticky-col:nth-child(2) {
            left: 45px;
            min-width: 160px;
            border-right: 2px solid var(--border-accent);
        }
        
        .profiles-table td {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-subtle);
            white-space: nowrap;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }
        
        .profiles-table td.sticky-col {
            position: sticky;
            background: var(--bg-card);
            z-index: 5;
            font-family: 'Sora', sans-serif;
            font-weight: 500;
            box-shadow: 2px 0 8px rgba(0,0,0,0.2);
        }
        
        .profiles-table td.sticky-col:first-child {
            left: 0;
            min-width: 45px;
        }
        
        .profiles-table td.sticky-col:nth-child(2) {
            left: 45px;
            min-width: 160px;
            border-right: 2px solid var(--border-accent);
        }
        
        .profiles-table tbody tr:hover {
            background: rgba(99, 102, 241, 0.08);
        }
        
        .profiles-table tbody tr:hover td.sticky-col {
            background: rgba(99, 102, 241, 0.15);
        }
        
        .profiles-table tbody tr.selected {
            background: rgba(99, 102, 241, 0.2);
        }
        
        .profiles-table tbody tr.selected td.sticky-col {
            background: rgba(99, 102, 241, 0.3);
        }
        
        /* Category Headers */
        .profiles-category-header {
            background: linear-gradient(90deg, rgba(99, 102, 241, 0.15) 0%, transparent 100%);
        }
        
        .profiles-category-header th {
            padding: 6px 12px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.85rem;
            letter-spacing: 2px;
            border-bottom: none;
            cursor: pointer;
        }
        
        .profiles-category-collapse-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: none;
            border: none;
            color: inherit;
            cursor: pointer;
            font: inherit;
            padding: 0;
        }
        
        .profiles-category-collapse-icon {
            font-size: 0.8rem;
            transition: transform 0.2s ease;
        }
        
        .profiles-category-collapse-icon.collapsed {
            transform: rotate(-90deg);
        }
        
        /* Percentile cell colors */
        .pct-cell {
            border-radius: 4px;
            padding: 4px 8px !important;
            text-align: center;
        }
        
        .pct-elite { background: var(--pct-elite-bg); color: var(--pct-elite-text); }
        .pct-good { background: var(--pct-good-bg); color: var(--pct-good-text); }
        .pct-avg { background: var(--pct-avg-bg); color: var(--pct-avg-text); }
        .pct-below { background: var(--pct-below-bg); color: var(--pct-below-text); }
        .pct-poor { background: var(--pct-poor-bg); color: var(--pct-poor-text); }
        
        /* Rank column */
        .rank-cell {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.85rem;
        }
        
        .rank-1 { background: linear-gradient(135deg, #ffd700, #ffb700); color: #000; }
        .rank-2 { background: linear-gradient(135deg, #c0c0c0, #a8a8a8); color: #000; }
        .rank-3 { background: linear-gradient(135deg, #cd7f32, #b87333); color: #000; }
        .rank-default { background: rgba(255, 255, 255, 0.1); color: var(--text-secondary); }
        
        /* Player name in table */
        .player-name-cell {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        
        .player-name-cell:hover {
            color: var(--accent-cyan);
        }
        
        .player-team-badge {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
        }
        
        /* Reset filters button */
        .profiles-reset-btn {
            padding: 8px 16px;
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.4);
            border-radius: 8px;
            color: #f87171;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .profiles-reset-btn:hover {
            background: rgba(239, 68, 68, 0.3);
        }
        
        /* Player Profile Tab Styles */
        .player-profile-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .player-profile-header {
            margin-bottom: 24px;
        }
        
        .player-profile-section {
            transition: all 0.3s ease;
        }
        
        .player-profile-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }
        
        .player-profile-stats-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 0.75rem;
        }
        
        .player-profile-stats-table th {
            padding: 6px 10px;
            text-align: left;
            font-weight: 600;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border-subtle);
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .player-profile-stats-table td {
            padding: 8px 10px;
            font-family: 'JetBrains Mono', monospace;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .player-profile-stats-table tr:hover td {
            background: rgba(255,255,255,0.03);
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script>
        // ============================================
        // REACT SETUP
        // ============================================
        const e = React.createElement;
        const { useState, useMemo, useEffect, useCallback } = React;

        // ============================================
        // CONSTANTS
        // ============================================
        
        const MAIN_PLAY_TYPES = [
            'P&R Ball Handler', 'Transition', 'Spot Up', 'Isolation', 
            'Miscellaneous Plays', 'Cut', 'Offensive Rebounds (Put Backs)', 
            'Post-Up', 'Off Screen', 'Handoffs', 'P&R Roll Man'
        ];
        
        const ONBALL_PLAYTYPES = ['Isolation', 'P&R Ball Handler', 'Post-Up'];
        const OFFBALL_PLAYTYPES = ['Spot Up', 'Offensive Rebounds (Put Backs)', 'Cut', 'Off Screen', 'P&R Roll Man', 'Handoffs'];

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        
        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = [];
            let cur = '', inQ = false;
            
            for (let c of lines[0]) {
                if (c === '"') inQ = !inQ;
                else if (c === ',' && !inQ) { headers.push(cur.trim().replace(/\r/g, '')); cur = ''; }
                else cur += c;
            }
            headers.push(cur.trim().replace(/\r/g, ''));
            
            return lines.slice(1).map(line => {
                const vals = []; cur = ''; inQ = false;
                for (let c of line) {
                    if (c === '"') inQ = !inQ;
                    else if (c === ',' && !inQ) { vals.push(cur.trim().replace(/\r/g, '')); cur = ''; }
                    else cur += c;
                }
                vals.push(cur.trim().replace(/\r/g, ''));
                const obj = {};
                headers.forEach((h, i) => obj[h] = vals[i] || '');
                return obj;
            });
        }
        
        function parsePct(val) {
            if (!val || val === '-' || val === 'N/A') return 0;
            return parseFloat(String(val).replace('%', '').trim()) || 0;
        }
        
        function parseNum(val) {
            if (!val || val === '-' || val === 'N/A') return 0;
            return parseFloat(val) || 0;
        }
        
        // Format number to max 3 decimal places, removing trailing zeros
        function fmt(val, decimals = 3) {
            if (val === undefined || val === null || isNaN(val)) return '0';
            const num = parseFloat(val.toFixed(decimals));
            return num.toString();
        }
        
        function fmtPct(val) {
            if (val === undefined || val === null || isNaN(val)) return '0%';
            return parseFloat(val.toFixed(1)) + '%';
        }
        
        function fmtPpp(val) {
            if (val === undefined || val === null || isNaN(val)) return '0.000';
            return val.toFixed(3);
        }
        
        // Calculate eFG%
        function calcEfg(fgMade, fgAtt, fg3Made) {
            const fga = parseNum(fgAtt);
            if (fga === 0) return 0;
            return ((parseNum(fgMade) + 0.5 * parseNum(fg3Made)) / fga) * 100;
        }
        
        // Calculate TO%
        function calcToPct(turnovers, poss) {
            const p = parseNum(poss);
            if (p === 0) return 0;
            return (parseNum(turnovers) / p) * 100;
        }
        
        // Calculate FT Rate (FTA/FGA)
        function calcFtRate(fta, fga) {
            const att = parseNum(fga);
            if (att === 0) return 0;
            return (parseNum(fta) / att) * 100;
        }
        
        // Calculate turnovers from TO% and possessions
        function calcTurnovers(toPct, poss) {
            return (parsePct(toPct) * parseNum(poss)) / 100;
        }
        
        // Calculate FTA from FTA/FGA ratio and FGA
        function calcFTA(ftaPerFga, fga) {
            return parseNum(ftaPerFga) * parseNum(fga);
        }
        
        // Get percentile class for styling
        function getPctClass(p) {
            if (p === undefined || p === null) return '';
            if (p >= 80) return 'pct-elite';
            if (p >= 60) return 'pct-good';
            if (p >= 40) return 'pct-avg';
            if (p >= 20) return 'pct-below';
            return 'pct-poor';
        }
        
        // Get percentile color for inline styling
        // -1 = partial threshold met (gray text, no percentile number)
        // null/undefined = below threshold (dimmed)
        function getPercentileColor(pct) {
            if (pct === null || pct === undefined) return 'rgba(100, 116, 139, 0.6)';
            if (pct === -1) return 'rgba(148, 163, 184, 0.9)'; // Gray for partial threshold
            if (pct >= 90) return '#22c55e';
            if (pct >= 75) return '#4ade80';
            if (pct >= 50) return '#a3e635';
            if (pct >= 25) return '#fbbf24';
            return '#ef4444';
        }
        
        // Calculate percentile rank (supports weighted data)
        // Pool can be array of numbers OR array of {value, weight} objects
        function calcPercentile(val, allValues, higherIsBetter = true) {
            if (!allValues || !allValues.length) return 50;
            if (val === undefined || val === null || isNaN(val)) return 50;
            
            // Check if weighted data
            const isWeighted = allValues[0] && typeof allValues[0] === 'object' && 'value' in allValues[0];
            
            if (isWeighted) {
                // Weighted percentile calculation
                const validItems = allValues.filter(item => 
                    !isNaN(item.value) && isFinite(item.value) && item.weight > 0
                );
                if (!validItems.length) return 50;
                
                const totalWeight = validItems.reduce((sum, item) => sum + item.weight, 0);
                if (totalWeight === 0) return 50;
                
                let weightBelow = 0;
                for (const item of validItems) {
                    if (higherIsBetter) {
                        if (item.value < val) weightBelow += item.weight;
                    } else {
                        if (item.value > val) weightBelow += item.weight;
                    }
                }
                return Math.round((weightBelow / totalWeight) * 100);
            } else {
                // Unweighted percentile calculation (legacy support)
                const validVals = allValues.filter(v => !isNaN(v) && isFinite(v) && v !== 0);
                if (!validVals.length) return 50;
                const sorted = [...validVals].sort((a, b) => a - b);
                let countBelow = 0;
                for (const v of sorted) {
                    if (higherIsBetter) { if (v < val) countBelow++; }
                    else { if (v > val) countBelow++; }
                }
                return Math.round((countBelow / sorted.length) * 100);
            }
        }
        
        // Get play type color class
        function getPlayTypeColorClass(playType) {
            const pt = playType.toLowerCase();
            if (pt.includes('transition')) return 'pt-transition';
            if (pt.includes('spot up')) return 'pt-spot-up';
            if (pt.includes('p&r ball handler') || pt.includes('pnr bh')) return 'pt-pnr-bh';
            if (pt.includes('isolation') || pt.includes('iso')) return 'pt-isolation';
            if (pt.includes('post-up') || pt.includes('post up')) return 'pt-post-up';
            if (pt.includes('cut')) return 'pt-cut';
            if (pt.includes('off screen')) return 'pt-offscreen';
            if (pt.includes('p&r roll') || pt.includes('pnr roll')) return 'pt-pnr-rm';
            if (pt.includes('handoff')) return 'pt-handoffs';
            if (pt.includes('putback') || pt.includes('offensive rebound')) return 'pt-putbacks';
            return 'pt-misc';
        }
        
        // Check if row is a main play type (all sub categories are N/A)
        function isMainPlayType(row) {
            // Support both column naming conventions
            const subCols = [
                'Play Type (Sub)', 'Play Type (Sub 2)', 'Play Type (Sub 3)', 
                'Play Type (Sub 4)', 'Play Type (Sub 5)', 'Play Type (Sub 6)',
                'Sub Category 1', 'Sub Category 2', 'Sub Category 3',
                'Sub Category 4', 'Sub Category 5', 'Sub Category 6'
            ];
            return subCols.every(col => !row[col] || row[col] === 'N/A' || row[col] === '');
        }
        
        // Get the correct column name for sub-category level (tries both conventions)
        function getSubCategoryCol(level) {
            // Returns array of possible column names to check
            if (level === 1) return ['Play Type (Sub)', 'Sub Category 1'];
            return [`Play Type (Sub ${level})`, `Sub Category ${level}`];
        }
        
        // Get value from sub category (trying both column conventions)
        function getSubCategoryValue(row, level) {
            const cols = getSubCategoryCol(level);
            for (const col of cols) {
                if (row[col] && row[col] !== 'N/A' && row[col] !== '') {
                    return row[col];
                }
            }
            return null;
        }
        
        // Check if sub category contains value
        function hasSubCategory(row, level, value) {
            const val = getSubCategoryValue(row, level);
            return val && val.toLowerCase().includes(value.toLowerCase());
        }
        
        // Check if sub category equals value exactly
        function subCategoryEquals(row, level, value) {
            const val = getSubCategoryValue(row, level);
            if (!val) return value === 'N/A' || value === '';
            return val.trim().toLowerCase() === value.toLowerCase();
        }
        
        // Check if sub category starts with value
        function subCategoryStartsWith(row, level, value) {
            const val = getSubCategoryValue(row, level);
            return val && val.trim().toLowerCase().startsWith(value.toLowerCase());
        }
        
        // Get sub category value (legacy function name)
        function getSubCategory(row, level) {
            return getSubCategoryValue(row, level) || 'N/A';
        }
        
        // Check if ANY sub-category contains value (searches all levels 1-6)
        function anySubCategory(row, value) {
            for (let level = 1; level <= 6; level++) {
                if (hasSubCategory(row, level, value)) return true;
            }
            return false;
        }
        
        // Check if ANY sub-category contains value AND another sub-category contains second value
        function anySubCategoryPair(row, value1, value2) {
            return anySubCategory(row, value1) && anySubCategory(row, value2);
        }
        
        // Check if a subcategory value is followed by N/A (summary row)
        // This identifies summary rows like "Dribble Jumper > N/A" vs detail rows like "Dribble Jumper > Short"
        // Use exactMatch=true for values that could be substrings of others (e.g. "Dribble Jumper" vs "No Dribble Jumper")
        function isSubCategorySummary(row, value, exactMatch = false) {
            for (let level = 1; level <= 5; level++) {
                const subVal = getSubCategoryValue(row, level);
                if (!subVal) continue;
                
                const matches = exactMatch ? (subVal === value) : subVal.includes(value);
                if (matches) {
                    // For "Dribble Jumper", make sure it's not "No Dribble Jumper"
                    if (value === 'Dribble Jumper' && subVal.includes('No Dribble')) continue;
                    
                    // Found the value, check if next level is N/A or empty
                    const nextVal = getSubCategoryValue(row, level + 1);
                    return !nextVal || nextVal === 'N/A' || nextVal === '';
                }
            }
            return false;
        }

        // Aggregate rows helper
        function aggregateRows(rows) {
            return rows.reduce((acc, row) => ({
                poss: acc.poss + parseNum(row['POSS']),
                pts: acc.pts + parseNum(row['PTS']),
                fgAtt: acc.fgAtt + parseNum(row['FG ATT']),
                fgMade: acc.fgMade + parseNum(row['FG MADE']),
                fg3Att: acc.fg3Att + parseNum(row['3FG ATT']),
                fg3Made: acc.fg3Made + parseNum(row['3 FG MADE']),
                fg2Att: acc.fg2Att + parseNum(row['2 FG ATT']),
                fg2Made: acc.fg2Made + parseNum(row['2 FG MADE']),
                turnovers: acc.turnovers + calcTurnovers(row['TO%'], row['POSS']),
                ftAttempts: acc.ftAttempts + calcFTA(row['FTA/FGA'], row['FG ATT'])
            }), { poss: 0, pts: 0, fgAtt: 0, fgMade: 0, fg3Att: 0, fg3Made: 0, fg2Att: 0, fg2Made: 0, turnovers: 0, ftAttempts: 0 });
        }
        
        // Calculate stats from aggregated data
        function calcStats(data) {
            const tsa = data.fgAtt + 0.44 * data.ftAttempts; // True shooting attempts
            return {
                ...data,
                ppp: data.poss > 0 ? data.pts / data.poss : 0,
                efg: calcEfg(data.fgMade, data.fgAtt, data.fg3Made),
                ts: tsa > 0 ? (data.pts / (2 * tsa)) * 100 : 0,
                toPct: calcToPct(data.turnovers, data.poss),
                ftRate: calcFtRate(data.ftAttempts, data.fgAtt),
                fg2Pct: data.fg2Att > 0 ? (data.fg2Made / data.fg2Att) * 100 : 0,
                fg3Pct: data.fg3Att > 0 ? (data.fg3Made / data.fg3Att) * 100 : 0
            };
        }

        // PLACEHOLDER - Will be continued in Part 2
        console.log('Part 1 loaded successfully - Core utilities ready');

// ============================================
// MERGING PARTS 2, 3, 4, 5
// ============================================

// ============================================
// PART 2: PLAYER DATA AGGREGATION
// ============================================

// Main function to aggregate all player data
function aggregatePlayerData(offenseData, utilitiesData, playerName) {
    const playerRows = offenseData.filter(row => row['Player Name'] === playerName);
    const playerUtils = utilitiesData.filter(row => row['Player Name'] === playerName);
    
    if (playerRows.length === 0) return null;
    
    const totalGames = playerUtils.reduce((sum, row) => sum + parseNum(row['Games Played']), 0);
    const seasons = [...new Set(playerRows.map(r => r['Season']))];
    const team = playerRows[0]['Team'] || '';
    
    // Aggregate main play types
    const playTypeStats = {};
    
    MAIN_PLAY_TYPES.forEach(pt => {
        const rows = playerRows.filter(row => 
            row['Play Type'] === pt && isMainPlayType(row)
        );
        
        if (rows.length > 0) {
            const agg = aggregateRows(rows);
            playTypeStats[pt] = {
                ...calcStats(agg),
                possPerGame: totalGames > 0 ? agg.poss / totalGames : 0,
                ptsPerGame: totalGames > 0 ? agg.pts / totalGames : 0
            };
        }
    });
    
    // Calculate totals
    const totalPoss = Object.values(playTypeStats).reduce((sum, pt) => sum + pt.poss, 0);
    const totalPts = Object.values(playTypeStats).reduce((sum, pt) => sum + pt.pts, 0);
    const totalFgAtt = Object.values(playTypeStats).reduce((sum, pt) => sum + pt.fgAtt, 0);
    const totalFgMade = Object.values(playTypeStats).reduce((sum, pt) => sum + pt.fgMade, 0);
    const totalFg3Att = Object.values(playTypeStats).reduce((sum, pt) => sum + pt.fg3Att, 0);
    const totalFg3Made = Object.values(playTypeStats).reduce((sum, pt) => sum + pt.fg3Made, 0);
    const totalFg2Att = Object.values(playTypeStats).reduce((sum, pt) => sum + pt.fg2Att, 0);
    const totalFg2Made = Object.values(playTypeStats).reduce((sum, pt) => sum + pt.fg2Made, 0);
    const totalTurnovers = Object.values(playTypeStats).reduce((sum, pt) => sum + pt.turnovers, 0);
    const totalFTA = Object.values(playTypeStats).reduce((sum, pt) => sum + pt.ftAttempts, 0);
    
    // Add percentages to each play type
    Object.keys(playTypeStats).forEach(pt => {
        playTypeStats[pt].pctOfPoss = totalPoss > 0 ? (playTypeStats[pt].poss / totalPoss) * 100 : 0;
        playTypeStats[pt].pctOfPts = totalPts > 0 ? (playTypeStats[pt].pts / totalPts) * 100 : 0;
    });
    
    // On-ball aggregation
    const onBall = ONBALL_PLAYTYPES.reduce((acc, pt) => {
        const stats = playTypeStats[pt] || { poss: 0, pts: 0, fgAtt: 0, fgMade: 0, fg3Made: 0, turnovers: 0, ftAttempts: 0 };
        return {
            poss: acc.poss + stats.poss,
            pts: acc.pts + stats.pts,
            fgAtt: acc.fgAtt + stats.fgAtt,
            fgMade: acc.fgMade + stats.fgMade,
            fg3Made: acc.fg3Made + stats.fg3Made,
            turnovers: acc.turnovers + stats.turnovers,
            ftAttempts: acc.ftAttempts + stats.ftAttempts
        };
    }, { poss: 0, pts: 0, fgAtt: 0, fgMade: 0, fg3Made: 0, turnovers: 0, ftAttempts: 0 });
    
    // Off-ball aggregation
    const offBall = OFFBALL_PLAYTYPES.reduce((acc, pt) => {
        const stats = playTypeStats[pt] || { poss: 0, pts: 0, fgAtt: 0, fgMade: 0, fg3Made: 0, turnovers: 0, ftAttempts: 0 };
        return {
            poss: acc.poss + stats.poss,
            pts: acc.pts + stats.pts,
            fgAtt: acc.fgAtt + stats.fgAtt,
            fgMade: acc.fgMade + stats.fgMade,
            fg3Made: acc.fg3Made + stats.fg3Made,
            turnovers: acc.turnovers + stats.turnovers,
            ftAttempts: acc.ftAttempts + stats.ftAttempts
        };
    }, { poss: 0, pts: 0, fgAtt: 0, fgMade: 0, fg3Made: 0, turnovers: 0, ftAttempts: 0 });
    
    const onBallStats = {
        ...onBall,
        ppp: onBall.poss > 0 ? onBall.pts / onBall.poss : 0,
        efg: calcEfg(onBall.fgMade, onBall.fgAtt, onBall.fg3Made),
        toPct: calcToPct(onBall.turnovers, onBall.poss),
        ftRate: calcFtRate(onBall.ftAttempts, onBall.fgAtt),
        pctOfPoss: totalPoss > 0 ? (onBall.poss / totalPoss) * 100 : 0,
        possPerGame: totalGames > 0 ? onBall.poss / totalGames : 0,
        ptsPerGame: totalGames > 0 ? onBall.pts / totalGames : 0
    };
    
    const offBallStats = {
        ...offBall,
        ppp: offBall.poss > 0 ? offBall.pts / offBall.poss : 0,
        efg: calcEfg(offBall.fgMade, offBall.fgAtt, offBall.fg3Made),
        toPct: calcToPct(offBall.turnovers, offBall.poss),
        ftRate: calcFtRate(offBall.ftAttempts, offBall.fgAtt),
        pctOfPoss: totalPoss > 0 ? (offBall.poss / totalPoss) * 100 : 0,
        possPerGame: totalGames > 0 ? offBall.poss / totalGames : 0,
        ptsPerGame: totalGames > 0 ? offBall.pts / totalGames : 0
    };
    
    return {
        playerName,
        team,
        seasons,
        totalGames,
        totalPoss,
        totalPts,
        totalFgAtt,
        totalFgMade,
        totalFg3Att,
        totalFg3Made,
        totalFg2Att,
        totalFg2Made,
        totalTurnovers,
        totalFTA,
        possPerGame: totalGames > 0 ? totalPoss / totalGames : 0,
        ptsPerGame: totalGames > 0 ? totalPts / totalGames : 0,
        ppp: totalPoss > 0 ? totalPts / totalPoss : 0,
        efg: calcEfg(totalFgMade, totalFgAtt, totalFg3Made),
        toPct: calcToPct(totalTurnovers, totalPoss),
        ftRate: calcFtRate(totalFTA, totalFgAtt),
        playTypeStats,
        onBall: onBallStats,
        offBall: offBallStats,
        rawRows: playerRows
    };
}

// ============================================
// C&S (CATCH & SHOOT) DATA EXTRACTOR
// ============================================

function getShootingCnSData(playerRows, totalGames, totalPoss) {
    // C&S 3PT specific rows - look for "No Dribble" anywhere (more flexible matching)
    const cns3ptRows = playerRows.filter(row =>
        row['Play Type'] === 'Spot Up' &&
        (anySubCategory(row, 'No Dribble') || anySubCategory(row, 'Catch')) &&
        anySubCategory(row, 'Long/3pt')
    );
    
    // Fallback: if no C&S 3PT found with above criteria, try just Spot Up + Long/3pt without drives
    const fallbackCns3ptRows = cns3ptRows.length === 0 ? playerRows.filter(row =>
        row['Play Type'] === 'Spot Up' &&
        anySubCategory(row, 'Long/3pt') &&
        !anySubCategory(row, 'Drive')
    ) : [];
    
    const effectiveCns3ptRows = cns3ptRows.length > 0 ? cns3ptRows : fallbackCns3ptRows;
    
    // Open shots
    const openRows = effectiveCns3ptRows.filter(row =>
        anySubCategory(row, 'Open')
    );
    
    // Guarded shots
    const guardedRows = effectiveCns3ptRows.filter(row =>
        anySubCategory(row, 'Guarded')
    );
    
    const cns3pt = aggregateRows(effectiveCns3ptRows);
    const openData = aggregateRows(openRows);
    const guardedData = aggregateRows(guardedRows);
    
    const attemptsPerGame = totalGames > 0 ? cns3pt.fg3Att / totalGames : 0;
    const attemptsPer100 = totalPoss > 0 ? (cns3pt.fg3Att / totalPoss) * 100 : 0;
    const fg3Pct = cns3pt.fg3Att > 0 ? (cns3pt.fg3Made / cns3pt.fg3Att) * 100 : 0;
    const open3Pct = openData.fg3Att > 0 ? (openData.fg3Made / openData.fg3Att) * 100 : 0;
    const guarded3Pct = guardedData.fg3Att > 0 ? (guardedData.fg3Made / guardedData.fg3Att) * 100 : 0;
    
    const totalContest = openData.fg3Att + guardedData.fg3Att;
    const contestedPct = totalContest > 0 ? (guardedData.fg3Att / totalContest) * 100 : 0;
    
    // IMPROVED Spacing Value Calculation V2
    // A player who stretches the floor has: 1) volume, 2) accuracy, 3) defenders respecting them (contested %)
    // V2: Increased weight on volume to penalize low-volume shooters more
    
    // Volume component (0-40 pts): More attempts = more gravity, scales up to ~5 3PA per 100 poss
    // Using logarithmic scaling to reward moderate volume more than nothing, but still reward high volume
    const volumeRaw = Math.min(attemptsPer100 / 5, 1.5); // Allow overshoot for high volume bonus
    const volumeScore = Math.min(40, volumeRaw * 30 + (attemptsPer100 > 3 ? 5 : 0) + (attemptsPer100 > 5 ? 5 : 0));
    
    // Minimum volume threshold - players under 1.5 3PA/100 get heavily penalized
    const volumePenalty = attemptsPer100 < 1.5 ? (1.5 - attemptsPer100) * 15 : 0;
    
    // Accuracy component (0-30 pts): Higher % = defenders must close out harder
    const accuracyScore = Math.min(fg3Pct / 45, 1) * 30;
    
    // Gravity/Respect component (0-20 pts): Higher contested % = defenders are glued to you
    // If defenders leave you open, you're not stretching the floor as much
    // V2: Weighted more heavily - if you're always open, you're not really a threat
    const gravityScore = (contestedPct / 100) * 20;
    
    // Efficiency under pressure bonus (0-10 pts): Can you make them when contested?
    const pressureBonus = guarded3Pct > 30 ? Math.min((guarded3Pct - 30) / 15, 1) * 10 : 0;
    
    const spacingValue = Math.max(0, Math.min(100, volumeScore + accuracyScore + gravityScore + pressureBonus - volumePenalty));
    
    return {
        attemptsPerGame,
        attemptsPer100,
        fg3Pct,
        open3Pct,
        guarded3Pct,
        openAttempts: openData.fg3Att,
        guardedAttempts: guardedData.fg3Att,
        contestedPct,
        spacingValue,
        total3Att: cns3pt.fg3Att,
        total3Made: cns3pt.fg3Made,
        // Add breakdown for display
        spacingBreakdown: {
            volume: volumeScore,
            accuracy: accuracyScore,
            gravity: gravityScore,
            pressure: pressureBonus,
            volumePenalty: volumePenalty
        }
    };
}

// ============================================
// P&R BALL HANDLER DATA EXTRACTOR (FIXED)
// ============================================

function getPnRBHData(playerRows, totalGames, totalPoss) {
    // P&R Including Passes (main)
    const pnrIncludingRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Including Passes' && isMainPlayType(row)
    );
    
    // P&R Ball Handler (main)
    const pnrBHRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Ball Handler' && isMainPlayType(row)
    );
    
    // Defense Commits and Traps
    const defenseCommitsRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R BH - Defense Commits' && isMainPlayType(row)
    );
    
    const trapsRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R BH - Traps' && isMainPlayType(row)
    );
    
    const pnrIncluding = aggregateRows(pnrIncludingRows);
    const pnrBH = aggregateRows(pnrBHRows);
    const defCommits = aggregateRows(defenseCommitsRows);
    const traps = aggregateRows(trapsRows);
    
    // Pressure handling
    const pressurePoss = defCommits.poss + traps.poss;
    const pressureTurnovers = defCommits.turnovers + traps.turnovers;
    const pressureToPct = pressurePoss > 0 ? (pressureTurnovers / pressurePoss) * 100 : 0;
    
    // Pass percentage - handle case where Including Passes data might not exist
    // or might be reported differently
    let passPct = 0;
    if (pnrIncluding.poss > 0 && pnrIncluding.poss >= pnrBH.poss) {
        const passPoss = pnrIncluding.poss - pnrBH.poss;
        passPct = (passPoss / pnrIncluding.poss) * 100;
    } else if (pnrBH.poss > 0) {
        // If no Including Passes data or it's less than BH, can't calculate pass %
        passPct = null;
    }
    
    // Screen location data - find top-level location breakdowns
    const getLocationData = (location) => {
        // Look for rows where the location appears at sub-category level 2 (after P&R Ball Handler)
        // with N/A at level 3 to get the summary row
        const rows = playerRows.filter(row =>
            row['Play Type'] === 'P&R Ball Handler' &&
            hasSubCategory(row, 2, location) &&
            subCategoryEquals(row, 3, 'N/A')
        );
        return aggregateRows(rows);
    };
    
    const highPnR = getLocationData('High P&R');
    const rightPnR = getLocationData('Right P&R');
    const leftPnR = getLocationData('Left P&R');
    
    const totalLocationPoss = highPnR.poss + rightPnR.poss + leftPnR.poss;
    
    // FIXED: Shot Types - Properly combine all screen locations (High, Left, Right)
    // and look for 'To Basket' and 'Dribble Jumper' subcategories
    
    // Rim Attacks = all rows with 'To Basket' at any level, from any screen location
    const rimAttackRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Ball Handler' &&
        anySubCategory(row, 'To Basket') &&
        // Ensure we're getting leaf nodes (not intermediate)
        (anySubCategory(row, 'Make') || anySubCategory(row, 'Miss') || 
         // Or the direct summary row before make/miss breakdown
         (anySubCategory(row, 'To Basket') && 
          !anySubCategory(row, 'Make') && !anySubCategory(row, 'Miss') &&
          getSubCategoryValue(row, 4) === null))
    );
    
    // Get summary rows for To Basket (before make/miss split)
    const rimSummaryRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Ball Handler' &&
        anySubCategory(row, 'To Basket') &&
        !anySubCategory(row, 'Make') && !anySubCategory(row, 'Miss')
    );
    const rimAttacks = aggregateRows(rimSummaryRows);
    
    // Mid-Range = Dribble Jumper + (Short or Medium) - get summary rows
    const midRangeRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Ball Handler' &&
        anySubCategory(row, 'Dribble Jumper') &&
        (anySubCategory(row, 'Short') || anySubCategory(row, 'Medium')) &&
        !anySubCategory(row, 'Make') && !anySubCategory(row, 'Miss')
    );
    const midRange = aggregateRows(midRangeRows);
    
    // Pull-up 3PT = Dribble Jumper + Long/3pt - get summary rows
    const pullUp3ptRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Ball Handler' &&
        anySubCategory(row, 'Dribble Jumper') &&
        anySubCategory(row, 'Long/3pt') &&
        !anySubCategory(row, 'Make') && !anySubCategory(row, 'Miss')
    );
    const pullUp3pt = aggregateRows(pullUp3ptRows);
    
    const totalShotTypePoss = rimAttacks.poss + midRange.poss + pullUp3pt.poss;
    
    // Screen usage - get summary rows
    const dribbleOffRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Ball Handler' &&
        anySubCategory(row, 'Dribble Off Pick') &&
        !anySubCategory(row, 'Dribble Jumper') &&
        !anySubCategory(row, 'To Basket') &&
        !anySubCategory(row, 'Defense Commits')
    );
    
    const goAwayRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Ball Handler' &&
        anySubCategory(row, 'Go Away from Pick') &&
        !anySubCategory(row, 'Dribble Jumper') &&
        !anySubCategory(row, 'To Basket')
    );
    
    const dribbleOff = aggregateRows(dribbleOffRows);
    const goAway = aggregateRows(goAwayRows);
    const screenUsageTotal = dribbleOff.poss + goAway.poss;
    
    return {
        including: {
            ...calcStats(pnrIncluding),
            possPerGame: totalGames > 0 ? pnrIncluding.poss / totalGames : 0,
            ptsPerGame: totalGames > 0 ? pnrIncluding.pts / totalGames : 0,
            possPer100: totalPoss > 0 ? (pnrIncluding.poss / totalPoss) * 100 : 0
        },
        scoring: {
            ...calcStats(pnrBH),
            possPerGame: totalGames > 0 ? pnrBH.poss / totalGames : 0,
            ptsPerGame: totalGames > 0 ? pnrBH.pts / totalGames : 0,
            possPer100: totalPoss > 0 ? (pnrBH.poss / totalPoss) * 100 : 0
        },
        passPct,
        pressureToPct,
        locations: {
            high: { ...highPnR, pct: totalLocationPoss > 0 ? (highPnR.poss / totalLocationPoss) * 100 : 0 },
            right: { ...rightPnR, pct: totalLocationPoss > 0 ? (rightPnR.poss / totalLocationPoss) * 100 : 0 },
            left: { ...leftPnR, pct: totalLocationPoss > 0 ? (leftPnR.poss / totalLocationPoss) * 100 : 0 }
        },
        screenUsage: {
            usesScreen: screenUsageTotal > 0 ? (dribbleOff.poss / screenUsageTotal) * 100 : 0,
            rejectsScreen: screenUsageTotal > 0 ? (goAway.poss / screenUsageTotal) * 100 : 0
        },
        shotTypes: {
            rim: { 
                ...calcStats(rimAttacks), 
                pct: totalShotTypePoss > 0 ? (rimAttacks.poss / totalShotTypePoss) * 100 : 0 
            },
            midRange: { 
                ...calcStats(midRange), 
                pct: totalShotTypePoss > 0 ? (midRange.poss / totalShotTypePoss) * 100 : 0,
                fg2Pct: midRange.fg2Att > 0 ? (midRange.fg2Made / midRange.fg2Att) * 100 : 0
            },
            pullUp3: { 
                ...calcStats(pullUp3pt), 
                pct: totalShotTypePoss > 0 ? (pullUp3pt.poss / totalShotTypePoss) * 100 : 0,
                fg3Pct: pullUp3pt.fg3Att > 0 ? (pullUp3pt.fg3Made / pullUp3pt.fg3Att) * 100 : 0
            }
        }
    };
}

// ============================================
// TRANSITION DATA EXTRACTOR
// ============================================

function getTransitionData(playerRows, totalGames, totalPoss, playerData) {
    const transMainRows = playerRows.filter(row =>
        row['Play Type'] === 'Transition' && isMainPlayType(row)
    );
    
    const transMain = aggregateRows(transMainRows);
    
    // Role breakdown
    const roles = ['Ballhandler', 'Right Wing', 'Left Wing', 'Leak Outs', 'First Middle', 'Trailer'];
    const roleData = {};
    
    roles.forEach(role => {
        const roleRows = playerRows.filter(row =>
            row['Play Type'] === 'Transition' &&
            hasSubCategory(row, 2, role) &&
            subCategoryEquals(row, 3, 'N/A')
        );
        const data = aggregateRows(roleRows);
        roleData[role] = {
            ...calcStats(data),
            pct: transMain.poss > 0 ? (data.poss / transMain.poss) * 100 : 0
        };
    });
    
    // Shot types in transition
    const toBasketRows = playerRows.filter(row =>
        row['Play Type'] === 'Transition' &&
        hasSubCategory(row, 3, 'To Basket') &&
        subCategoryEquals(row, 4, 'N/A')
    );
    
    const noDribbleRows = playerRows.filter(row =>
        row['Play Type'] === 'Transition' &&
        hasSubCategory(row, 3, 'No Dribble Jumper') &&
        subCategoryEquals(row, 4, 'N/A')
    );
    
    const dribbleJumperRows = playerRows.filter(row =>
        row['Play Type'] === 'Transition' &&
        hasSubCategory(row, 3, 'Dribble Jumper') &&
        subCategoryEquals(row, 4, 'N/A')
    );
    
    const toBasket = aggregateRows(toBasketRows);
    const noDribble = aggregateRows(noDribbleRows);
    const dribbleJumper = aggregateRows(dribbleJumperRows);
    
    const shotTotal = toBasket.poss + noDribble.poss + dribbleJumper.poss;
    
    // Half court calculations
    const halfCourtPoss = totalPoss - transMain.poss;
    const halfCourtPts = playerData.totalPts - transMain.pts;
    const halfCourtFgAtt = playerData.totalFgAtt - transMain.fgAtt;
    const halfCourtFgMade = playerData.totalFgMade - transMain.fgMade;
    const halfCourtFg3Made = playerData.totalFg3Made - transMain.fg3Made;
    const halfCourtTurnovers = playerData.totalTurnovers - transMain.turnovers;
    const halfCourtFTA = playerData.totalFTA - transMain.ftAttempts;
    
    return {
        main: {
            ...calcStats(transMain),
            pctOfPoss: totalPoss > 0 ? (transMain.poss / totalPoss) * 100 : 0,
            pctOfPts: playerData.totalPts > 0 ? (transMain.pts / playerData.totalPts) * 100 : 0
        },
        halfCourt: {
            poss: halfCourtPoss,
            pts: halfCourtPts,
            ppp: halfCourtPoss > 0 ? halfCourtPts / halfCourtPoss : 0,
            efg: calcEfg(halfCourtFgMade, halfCourtFgAtt, halfCourtFg3Made),
            toPct: calcToPct(halfCourtTurnovers, halfCourtPoss),
            ftRate: calcFtRate(halfCourtFTA, halfCourtFgAtt),
            pctOfPoss: totalPoss > 0 ? (halfCourtPoss / totalPoss) * 100 : 0,
            pctOfPts: playerData.totalPts > 0 ? (halfCourtPts / playerData.totalPts) * 100 : 0
        },
        roles: roleData,
        shotTypes: {
            rim: { ...calcStats(toBasket), pct: shotTotal > 0 ? (toBasket.poss / shotTotal) * 100 : 0 },
            catchShoot: { ...calcStats(noDribble), pct: shotTotal > 0 ? (noDribble.poss / shotTotal) * 100 : 0 },
            pullUp: { ...calcStats(dribbleJumper), pct: shotTotal > 0 ? (dribbleJumper.poss / shotTotal) * 100 : 0 }
        }
    };
}

// ============================================
// SPOT UP DATA EXTRACTOR (FIXED)
// ============================================

function getSpotUpData(playerRows, totalGames) {
    // Main Spot Up
    const mainRows = playerRows.filter(row =>
        row['Play Type'] === 'Spot Up' && isMainPlayType(row)
    );
    const main = aggregateRows(mainRows);
    
    // No Dribble Jumper (C&S) - use isSubCategorySummary to get only summary row
    const cnsRows = playerRows.filter(row =>
        row['Play Type'] === 'Spot Up' &&
        isSubCategorySummary(row, 'No Dribble Jumper')
    );
    const cns = aggregateRows(cnsRows);
    
    // Drives Left - use isSubCategorySummary to get only summary row
    const drivesLeftRows = playerRows.filter(row =>
        row['Play Type'] === 'Spot Up' &&
        isSubCategorySummary(row, 'Drives Left')
    );
    const drivesLeft = aggregateRows(drivesLeftRows);
    
    // Drives Right - use isSubCategorySummary to get only summary row
    const drivesRightRows = playerRows.filter(row =>
        row['Play Type'] === 'Spot Up' &&
        isSubCategorySummary(row, 'Drives Right')
    );
    const drivesRight = aggregateRows(drivesRightRows);
    
    // FIXED: Calculate drive percentages based on total drives only
    const totalDrives = drivesLeft.poss + drivesRight.poss;
    const totalActions = cns.poss + totalDrives;
    
    // Shot types for each drive direction
    const getDriveShotTypes = (direction) => {
        const toBasket = playerRows.filter(row =>
            row['Play Type'] === 'Spot Up' &&
            anySubCategory(row, direction) &&
            anySubCategory(row, 'To Basket')
        );
        
        const dribbleJumper2 = playerRows.filter(row =>
            row['Play Type'] === 'Spot Up' &&
            anySubCategory(row, direction) &&
            anySubCategory(row, 'Dribble Jumper') &&
            (anySubCategory(row, 'Short') || anySubCategory(row, 'Medium'))
        );
        
        const dribbleJumper3 = playerRows.filter(row =>
            row['Play Type'] === 'Spot Up' &&
            anySubCategory(row, direction) &&
            anySubCategory(row, 'Dribble Jumper') &&
            anySubCategory(row, 'Long/3pt')
        );
        
        const rim = aggregateRows(toBasket);
        const mid = aggregateRows(dribbleJumper2);
        const three = aggregateRows(dribbleJumper3);
        const total = rim.poss + mid.poss + three.poss;
        
        return {
            rim: { ...calcStats(rim), pct: total > 0 ? (rim.poss / total) * 100 : 0 },
            mid: { ...calcStats(mid), pct: total > 0 ? (mid.poss / total) * 100 : 0 },
            three: { ...calcStats(three), pct: total > 0 ? (three.poss / total) * 100 : 0 }
        };
    };
    
    return {
        main: calcStats(main),
        cns: calcStats(cns), // Add the full cns stats object
        cnsPct: totalActions > 0 ? (cns.poss / totalActions) * 100 : 0,
        drivePct: totalActions > 0 ? (totalDrives / totalActions) * 100 : 0,
        drivesLeft: {
            ...calcStats(drivesLeft),
            pct: totalDrives > 0 ? (drivesLeft.poss / totalDrives) * 100 : 0, // FIXED: % of drives, not all actions
            shotTypes: getDriveShotTypes('Drives Left')
        },
        drivesRight: {
            ...calcStats(drivesRight),
            pct: totalDrives > 0 ? (drivesRight.poss / totalDrives) * 100 : 0, // FIXED: % of drives, not all actions
            shotTypes: getDriveShotTypes('Drives Right')
        }
    };
}

// ============================================
// P&R ROLL MAN DATA EXTRACTOR (FIXED)
// ============================================

function getPnRRollManData(playerRows, totalGames) {
    // Main P&R Roll Man
    const mainRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Roll Man' && isMainPlayType(row)
    );
    const main = aggregateRows(mainRows);
    
    // Pick and Pops - use flexible matching
    const popRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Roll Man' &&
        anySubCategory(row, 'Pick and Pop')
    );
    const pops = aggregateRows(popRows);
    
    // Slips the Pick - use flexible matching
    const slipRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Roll Man' &&
        anySubCategory(row, 'Slip')
    );
    const slips = aggregateRows(slipRows);
    
    // Rolls to Basket - use flexible matching
    const rollRows = playerRows.filter(row =>
        row['Play Type'] === 'P&R Roll Man' &&
        anySubCategory(row, 'Roll')
    );
    const rolls = aggregateRows(rollRows);
    
    const totalTypePoss = pops.poss + slips.poss + rolls.poss;
    
    return {
        main: calcStats(main),
        pickAndPop: { 
            ...calcStats(pops), 
            pct: totalTypePoss > 0 ? (pops.poss / totalTypePoss) * 100 : 0 
        },
        slip: { 
            ...calcStats(slips), 
            pct: totalTypePoss > 0 ? (slips.poss / totalTypePoss) * 100 : 0 
        },
        roll: { 
            ...calcStats(rolls), 
            pct: totalTypePoss > 0 ? (rolls.poss / totalTypePoss) * 100 : 0 
        }
    };
}

// ============================================
// OFF SCREEN DATA EXTRACTOR (FIXED)
// ============================================

function getOffScreenData(playerRows, totalGames) {
    const mainRows = playerRows.filter(row =>
        row['Play Type'] === 'Off Screen' && isMainPlayType(row)
    );
    const main = aggregateRows(mainRows);
    
    // Get direction data - use isSubCategorySummary to get only summary row
    const getDirectionData = (direction) => {
        // Get only the summary row for this direction (direction > N/A)
        const dirSummaryRows = playerRows.filter(row =>
            row['Play Type'] === 'Off Screen' &&
            isSubCategorySummary(row, direction)
        );
        const dir = aggregateRows(dirSummaryRows);
        
        // Cut types - use flexible matching for breakdown
        const getCutData = (cutType) => {
            // Look for direction > cutType > N/A (summary of cut type within direction)
            const cutRows = playerRows.filter(row =>
                row['Play Type'] === 'Off Screen' &&
                hasSubCategory(row, 2, direction) &&
                isSubCategorySummary(row, cutType)
            );
            return aggregateRows(cutRows);
        };
        
        const straight = getCutData('Straight');
        const flare = getCutData('Flare');
        const curl = getCutData('Curl');
        const cutTotal = straight.poss + flare.poss + curl.poss;
        
        // Shot types for direction - look for leaf rows with specific shot types
        const toBasketRows = playerRows.filter(row =>
            row['Play Type'] === 'Off Screen' &&
            hasSubCategory(row, 2, direction) &&
            anySubCategory(row, 'To Basket')
        );
        
        const noDribbleRows = playerRows.filter(row =>
            row['Play Type'] === 'Off Screen' &&
            hasSubCategory(row, 2, direction) &&
            anySubCategory(row, 'No Dribble')
        );
        
        const dribbleRows = playerRows.filter(row =>
            row['Play Type'] === 'Off Screen' &&
            hasSubCategory(row, 2, direction) &&
            anySubCategory(row, 'Dribble Jumper')
        );
        
        const basket = aggregateRows(toBasketRows);
        const catchShoot = aggregateRows(noDribbleRows);
        const pullUp = aggregateRows(dribbleRows);
        const shotTotal = basket.poss + catchShoot.poss + pullUp.poss;
        
        return {
            ...calcStats(dir),
            pct: main.poss > 0 ? (dir.poss / main.poss) * 100 : 0,
            cuts: {
                straight: { ...calcStats(straight), pct: cutTotal > 0 ? (straight.poss / cutTotal) * 100 : 0 },
                flare: { ...calcStats(flare), pct: cutTotal > 0 ? (flare.poss / cutTotal) * 100 : 0 },
                curl: { ...calcStats(curl), pct: cutTotal > 0 ? (curl.poss / cutTotal) * 100 : 0 }
            },
            shots: {
                rim: { pct: shotTotal > 0 ? (basket.poss / shotTotal) * 100 : 0 },
                catchShoot: { pct: shotTotal > 0 ? (catchShoot.poss / shotTotal) * 100 : 0 },
                pullUp: { pct: shotTotal > 0 ? (pullUp.poss / shotTotal) * 100 : 0 }
            }
        };
    };
    
    return {
        main: calcStats(main),
        left: getDirectionData("To Shooter's Left"),
        right: getDirectionData("To Shooter's Right")
    };
}

// ============================================
// POST UP DATA EXTRACTOR (ENHANCED WITH MOVE OUTCOMES)
// ============================================

function getPostUpData(playerRows, totalGames) {
    // Main Post-Up
    const mainRows = playerRows.filter(row =>
        row['Play Type'] === 'Post-Up' && isMainPlayType(row)
    );
    const main = aggregateRows(mainRows);
    
    // Post-Ups Including Passes
    const includingRows = playerRows.filter(row =>
        row['Play Type'] === 'Post-Ups Including Passes' && isMainPlayType(row)
    );
    const including = aggregateRows(includingRows);
    
    // Defense Commits and Hard Double
    const defCommitsRows = playerRows.filter(row =>
        row['Play Type'] === 'Post-Up - Defense Commits' && isMainPlayType(row)
    );
    const hardDoubleRows = playerRows.filter(row =>
        row['Play Type'] === 'Post-Up - Hard Double' && isMainPlayType(row)
    );
    const defCommits = aggregateRows(defCommitsRows);
    const hardDouble = aggregateRows(hardDoubleRows);
    
    const pressurePoss = defCommits.poss + hardDouble.poss;
    const pressureTurnovers = defCommits.turnovers + hardDouble.turnovers;
    const pressureToPct = pressurePoss > 0 ? (pressureTurnovers / pressurePoss) * 100 : 0;
    
    // Pass percentage - handle edge cases
    let passPct = 0;
    if (including.poss > 0 && including.poss >= main.poss) {
        const passPoss = including.poss - main.poss;
        passPct = (passPoss / including.poss) * 100;
    } else if (main.poss > 0) {
        passPct = null; // Can't calculate
    }
    
    // Shot outcome types for post moves
    const shotOutcomeTypes = [
        { key: 'toHook', label: 'To Hook', search: 'To Hook' },
        { key: 'toBasket', label: 'To Basket', search: 'To Basket' },
        { key: 'toJumper', label: 'To Jumper', search: 'To Jumper' },
        { key: 'toDropStep', label: 'To Drop Step', search: 'To Drop Step' },
        { key: 'toUpAndUnder', label: 'To Up & Under', search: 'To Up and Under' }
    ];
    
    // Helper to get shot outcome data for a given block and shoulder
    const getShotOutcomeData = (block, shoulder) => {
        const outcomes = {};
        let totalPoss = 0;
        
        shotOutcomeTypes.forEach(outcome => {
            const outcomeRows = playerRows.filter(row =>
                row['Play Type'] === 'Post-Up' &&
                anySubCategory(row, block) &&
                anySubCategory(row, shoulder) &&
                anySubCategory(row, outcome.search)
            );
            const data = aggregateRows(outcomeRows);
            outcomes[outcome.key] = {
                ...calcStats(data),
                rawPoss: data.poss
            };
            totalPoss += data.poss;
        });
        
        // Calculate percentages
        shotOutcomeTypes.forEach(outcome => {
            outcomes[outcome.key].pct = totalPoss > 0 ? (outcomes[outcome.key].rawPoss / totalPoss) * 100 : 0;
        });
        
        return outcomes;
    };
    
    // Helper to get shoulder data with shot outcomes
    const getShoulderData = (block, shoulder) => {
        const moveRows = playerRows.filter(row =>
            row['Play Type'] === 'Post-Up' &&
            anySubCategory(row, block) &&
            anySubCategory(row, shoulder) &&
            !anySubCategory(row, 'Post Pin')
        );
        const data = aggregateRows(moveRows);
        const shotOutcomes = getShotOutcomeData(block, shoulder);
        
        return {
            ...calcStats(data),
            rawPoss: data.poss,
            shotOutcomes
        };
    };
    
    // Block data - use flexible matching
    const getBlockData = (block) => {
        const blockRows = playerRows.filter(row =>
            row['Play Type'] === 'Post-Up' &&
            anySubCategory(row, block)
        );
        const blockData = aggregateRows(blockRows);
        
        // Get shoulder data with shot outcomes
        const leftShoulder = getShoulderData(block, 'Left Shoulder');
        const rightShoulder = getShoulderData(block, 'Right Shoulder');
        
        const faceUpRows = playerRows.filter(row =>
            row['Play Type'] === 'Post-Up' &&
            anySubCategory(row, block) &&
            anySubCategory(row, 'Face-up')
        );
        const faceUp = aggregateRows(faceUpRows);
        
        const moveTotal = leftShoulder.rawPoss + rightShoulder.rawPoss + faceUp.poss;
        
        return {
            ...calcStats(blockData),
            // pct will be calculated later based on total blocks
            rawPoss: blockData.poss,
            moves: {
                leftShoulder: { 
                    ...leftShoulder, 
                    pct: moveTotal > 0 ? (leftShoulder.rawPoss / moveTotal) * 100 : 0 
                },
                rightShoulder: { 
                    ...rightShoulder, 
                    pct: moveTotal > 0 ? (rightShoulder.rawPoss / moveTotal) * 100 : 0 
                },
                faceUp: { 
                    ...calcStats(faceUp), 
                    pct: moveTotal > 0 ? (faceUp.poss / moveTotal) * 100 : 0 
                }
            }
        };
    };
    
    const leftBlockData = getBlockData('Left Block');
    const rightBlockData = getBlockData('Right Block');
    
    // FIXED: Calculate block percentages based on total block possessions (so they sum to 100%)
    const totalBlockPoss = leftBlockData.rawPoss + rightBlockData.rawPoss;
    leftBlockData.pct = totalBlockPoss > 0 ? (leftBlockData.rawPoss / totalBlockPoss) * 100 : 0;
    rightBlockData.pct = totalBlockPoss > 0 ? (rightBlockData.rawPoss / totalBlockPoss) * 100 : 0;
    
    // Overall move effectiveness (regardless of block) - use flexible matching
    const getAllMoveData = (shoulder) => {
        const moveRows = playerRows.filter(row =>
            row['Play Type'] === 'Post-Up' &&
            anySubCategory(row, shoulder) &&
            !anySubCategory(row, 'Post Pin')
        );
        return aggregateRows(moveRows);
    };
    
    // Get shot outcomes for overall shoulders (regardless of block)
    const getOverallShoulderOutcomes = (shoulder) => {
        const outcomes = {};
        let totalPoss = 0;
        
        shotOutcomeTypes.forEach(outcome => {
            const outcomeRows = playerRows.filter(row =>
                row['Play Type'] === 'Post-Up' &&
                anySubCategory(row, shoulder) &&
                anySubCategory(row, outcome.search)
            );
            const data = aggregateRows(outcomeRows);
            outcomes[outcome.key] = {
                ...calcStats(data),
                rawPoss: data.poss
            };
            totalPoss += data.poss;
        });
        
        // Calculate percentages
        shotOutcomeTypes.forEach(outcome => {
            outcomes[outcome.key].pct = totalPoss > 0 ? (outcomes[outcome.key].rawPoss / totalPoss) * 100 : 0;
        });
        
        return outcomes;
    };
    
    const allLeftShoulder = getAllMoveData('Left Shoulder');
    const allRightShoulder = getAllMoveData('Right Shoulder');
    const allFaceUpRows = playerRows.filter(row =>
        row['Play Type'] === 'Post-Up' &&
        anySubCategory(row, 'Face-up')
    );
    const allFaceUp = aggregateRows(allFaceUpRows);
    const totalMovesPoss = allLeftShoulder.poss + allRightShoulder.poss + allFaceUp.poss;
    
    return {
        main: calcStats(main),
        including: calcStats(including),
        passPct,
        pressureToPct,
        leftBlock: leftBlockData,
        rightBlock: rightBlockData,
        // Overall move effectiveness
        overallMoves: {
            leftShoulder: { 
                ...calcStats(allLeftShoulder), 
                pct: totalMovesPoss > 0 ? (allLeftShoulder.poss / totalMovesPoss) * 100 : 0,
                shotOutcomes: getOverallShoulderOutcomes('Left Shoulder')
            },
            rightShoulder: { 
                ...calcStats(allRightShoulder), 
                pct: totalMovesPoss > 0 ? (allRightShoulder.poss / totalMovesPoss) * 100 : 0,
                shotOutcomes: getOverallShoulderOutcomes('Right Shoulder')
            },
            faceUp: { 
                ...calcStats(allFaceUp), 
                pct: totalMovesPoss > 0 ? (allFaceUp.poss / totalMovesPoss) * 100 : 0 
            }
        },
        // Shot outcome type definitions for UI
        shotOutcomeTypes
    };
}

// ============================================
// SLASHING DATA EXTRACTOR
// ============================================

function getSlashingData(playerRows, totalGames, totalPoss) {
    // Overall drives
    const overallRows = playerRows.filter(row =>
        row['Play Type'] === 'Overall' && isMainPlayType(row)
    );
    const overall = aggregateRows(overallRows);
    
    // Drives Left - use isSubCategorySummary to get only summary row (Drives Left > N/A)
    const leftRows = playerRows.filter(row =>
        row['Play Type'] === 'Overall' &&
        isSubCategorySummary(row, 'Drives Left')
    );
    const left = aggregateRows(leftRows);
    
    // Drives Right - use isSubCategorySummary to get only summary row
    const rightRows = playerRows.filter(row =>
        row['Play Type'] === 'Overall' &&
        isSubCategorySummary(row, 'Drives Right')
    );
    const right = aggregateRows(rightRows);
    
    // Drives Straight - use isSubCategorySummary to get only summary row
    const straightRows = playerRows.filter(row =>
        row['Play Type'] === 'Overall' &&
        isSubCategorySummary(row, 'Drives Straight')
    );
    const straight = aggregateRows(straightRows);
    
    const totalDrives = left.poss + right.poss + straight.poss;
    
    // ========== SHOT TYPE BREAKDOWN PER HAND ==========
    // Helper to get shot types for a drive direction using proper subcategory logic
    const getShotTypes = (driveDirection) => {
        // Rim: driveDirection > To Basket > N/A (summary row)
        const rimRows = playerRows.filter(row =>
            anySubCategory(row, driveDirection) &&
            isSubCategorySummary(row, 'To Basket')
        );
        const rim = aggregateRows(rimRows);
        const rimAtt = rimRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
        const rimMade = rimRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
        
        // Mid-range and 3PT: Use Dribble Jumper summary row with '2 FG ATT' and '3FG ATT' columns
        const dribbleJumperRows = playerRows.filter(row =>
            anySubCategory(row, driveDirection) &&
            isSubCategorySummary(row, 'Dribble Jumper')
        );
        const midAtt = dribbleJumperRows.reduce((s, r) => s + parseNum(r['2 FG ATT']), 0);
        const midMade = dribbleJumperRows.reduce((s, r) => s + parseNum(r['2 FG MADE']), 0);
        const threeAtt = dribbleJumperRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0);
        const threeMade = dribbleJumperRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
        
        const shotTotal = rimAtt + midAtt + threeAtt;
        
        return {
            rim: { 
                att: rimAtt, 
                made: rimMade,
                fgPct: rimAtt > 0 ? (rimMade / rimAtt) * 100 : 0,
                pct: shotTotal > 0 ? (rimAtt / shotTotal) * 100 : 0
            },
            mid: { 
                att: midAtt, 
                made: midMade,
                fgPct: midAtt > 0 ? (midMade / midAtt) * 100 : 0,
                pct: shotTotal > 0 ? (midAtt / shotTotal) * 100 : 0
            },
            three: { 
                att: threeAtt, 
                made: threeMade,
                fgPct: threeAtt > 0 ? (threeMade / threeAtt) * 100 : 0,
                pct: shotTotal > 0 ? (threeAtt / shotTotal) * 100 : 0
            },
            total: shotTotal
        };
    };
    
    const leftShotTypes = getShotTypes('Drives Left');
    const rightShotTypes = getShotTypes('Drives Right');
    
    return {
        overall: {
            ...calcStats(overall),
            drivesPer100: totalPoss > 0 ? (overall.poss / totalPoss) * 100 : 0,
            drivesPerGame: totalGames > 0 ? overall.poss / totalGames : 0
        },
        left: {
            ...calcStats(left),
            pct: totalDrives > 0 ? (left.poss / totalDrives) * 100 : 0,
            shotTypes: leftShotTypes
        },
        right: {
            ...calcStats(right),
            pct: totalDrives > 0 ? (right.poss / totalDrives) * 100 : 0,
            shotTypes: rightShotTypes
        },
        straight: {
            ...calcStats(straight),
            pct: totalDrives > 0 ? (straight.poss / totalDrives) * 100 : 0
        }
    };
}

// ============================================
// ISOLATION DATA EXTRACTOR
// ============================================

function getIsolationData(playerRows, totalGames, totalPoss) {
    const mainRows = playerRows.filter(row =>
        row['Play Type'] === 'Isolation' && isMainPlayType(row)
    );
    const main = aggregateRows(mainRows);
    
    // ISO Including Passes
    const includingRows = playerRows.filter(row =>
        row['Play Type'] === 'ISO Including Passes' && isMainPlayType(row)
    );
    const including = aggregateRows(includingRows);
    
    // Drives Left - use isSubCategorySummary to get only summary row
    const drivesLeftRows = playerRows.filter(row =>
        row['Play Type'] === 'Isolation' &&
        isSubCategorySummary(row, 'Drives Left')
    );
    const drivesLeft = aggregateRows(drivesLeftRows);
    
    // Drives Right - use isSubCategorySummary to get only summary row
    const drivesRightRows = playerRows.filter(row =>
        row['Play Type'] === 'Isolation' &&
        isSubCategorySummary(row, 'Drives Right')
    );
    const drivesRight = aggregateRows(drivesRightRows);
    
    // Dribble Jumper - use isSubCategorySummary to get only summary row
    const dribbleJumperRows = playerRows.filter(row =>
        row['Play Type'] === 'Isolation' &&
        isSubCategorySummary(row, 'Dribble Jumper')
    );
    const dribbleJumper = aggregateRows(dribbleJumperRows);
    
    const totalActions = drivesLeft.poss + drivesRight.poss + dribbleJumper.poss;
    const totalDrives = drivesLeft.poss + drivesRight.poss;
    
    return {
        main: {
            ...calcStats(main),
            possPer100: totalPoss > 0 ? (main.poss / totalPoss) * 100 : 0,
            possPerGame: totalGames > 0 ? main.poss / totalGames : 0
        },
        including: calcStats(including),
        drivesLeft: {
            ...calcStats(drivesLeft),
            pct: totalDrives > 0 ? (drivesLeft.poss / totalDrives) * 100 : 0
        },
        drivesRight: {
            ...calcStats(drivesRight),
            pct: totalDrives > 0 ? (drivesRight.poss / totalDrives) * 100 : 0
        },
        dribbleJumper: {
            ...calcStats(dribbleJumper),
            pct: totalActions > 0 ? (dribbleJumper.poss / totalActions) * 100 : 0
        },
        drivePct: totalActions > 0 ? (totalDrives / totalActions) * 100 : 0,
        jumperPct: totalActions > 0 ? (dribbleJumper.poss / totalActions) * 100 : 0
    };
}

// ============================================
// LEAGUE PERCENTILE CALCULATOR
// ============================================

function calculateLeaguePercentiles(allPlayersData) {
    // Weighted pools: store {value, weight} objects for possession-weighted percentiles
    const pools = {
        ppp: [], efg: [], toPct: [], ftRate: [],
        possPerGame: [], ptsPerGame: [],
        onBallPpp: [], onBallEfg: [], onBallToPct: [],
        offBallPpp: [], offBallEfg: [], offBallToPct: [],
        spacingValue: [], attemptsPer100: [], fg3Pct: [],
        pnrPpp: [], pnrToPct: [], pnrPassPct: [],
        transPpp: [], transEfg: [],
        isoPpp: [], isoEfg: [],
        postPpp: [], postEfg: [],
        drivesPer100: []
    };
    
    const playTypePools = {};
    MAIN_PLAY_TYPES.forEach(pt => {
        playTypePools[pt] = { ppp: [], efg: [], toPct: [], ftRate: [], pctOfPoss: [], pctOfPts: [] };
    });
    
    allPlayersData.forEach(p => {
        if (p.totalPoss < 20) return;
        
        const weight = p.totalPoss; // Use total possessions as weight
        
        pools.ppp.push({ value: p.ppp, weight });
        pools.efg.push({ value: p.efg, weight });
        pools.toPct.push({ value: p.toPct, weight });
        pools.ftRate.push({ value: p.ftRate, weight });
        pools.possPerGame.push({ value: p.possPerGame, weight });
        pools.ptsPerGame.push({ value: p.ptsPerGame, weight });
        
        if (p.onBall.poss > 10) {
            pools.onBallPpp.push({ value: p.onBall.ppp, weight: p.onBall.poss });
            pools.onBallEfg.push({ value: p.onBall.efg, weight: p.onBall.poss });
            pools.onBallToPct.push({ value: p.onBall.toPct, weight: p.onBall.poss });
        }
        
        if (p.offBall.poss > 10) {
            pools.offBallPpp.push({ value: p.offBall.ppp, weight: p.offBall.poss });
            pools.offBallEfg.push({ value: p.offBall.efg, weight: p.offBall.poss });
            pools.offBallToPct.push({ value: p.offBall.toPct, weight: p.offBall.poss });
        }
        
        Object.entries(p.playTypeStats).forEach(([pt, stats]) => {
            if (stats.poss >= 10 && playTypePools[pt]) {
                playTypePools[pt].ppp.push({ value: stats.ppp, weight: stats.poss });
                playTypePools[pt].efg.push({ value: stats.efg, weight: stats.poss });
                playTypePools[pt].toPct.push({ value: stats.toPct, weight: stats.poss });
                playTypePools[pt].ftRate.push({ value: stats.ftRate, weight: stats.poss });
                playTypePools[pt].pctOfPoss.push({ value: stats.pctOfPoss, weight: stats.poss });
                playTypePools[pt].pctOfPts.push({ value: stats.pctOfPts, weight: stats.poss });
            }
        });
    });
    
    return { pools, playTypePools };
}

console.log('Part 2 loaded successfully - Data aggregation functions ready');

// ============================================
// PART 3: UI COMPONENTS
// ============================================

// Stat Card Component with percentile coloring
function StatCard({ label, value, format = 'number', percentile, sub, compact = false }) {
    const pctClass = getPctClass(percentile);
    
    let displayValue = value;
    if (value === undefined || value === null || isNaN(value)) {
        displayValue = '-';
    } else if (format === 'pct') {
        displayValue = fmtPct(value);
    } else if (format === 'ppp') {
        displayValue = fmtPpp(value);
    } else if (format === 'dec') {
        displayValue = fmt(value, 1);
    } else if (format === 'dec3') {
        displayValue = fmt(value, 3);
    } else {
        displayValue = Math.round(value);
    }
    
    return e('div', { className: `stat-card ${pctClass}` },
        e('div', { className: 'stat-label' }, label),
        e('div', { className: `stat-value ${pctClass}` }, displayValue),
        percentile !== undefined && percentile !== null && 
            e('div', { className: `stat-percentile ${pctClass}` }, Math.round(percentile)),
        sub && e('div', { className: 'stat-sub' }, sub)
    );
}

// Possession Badge - shows % of total offense this play type represents
function PossBadge({ pct, label = 'of offense' }) {
    if (!pct && pct !== 0) return null;
    return e('div', { 
        className: 'poss-badge',
        style: {
            display: 'inline-flex',
            alignItems: 'center',
            gap: '4px',
            padding: '4px 10px',
            background: 'rgba(99, 102, 241, 0.15)',
            border: '1px solid rgba(99, 102, 241, 0.3)',
            borderRadius: '100px',
            fontSize: '0.7rem',
            color: '#a5b4fc'
        }
    },
        e('span', { style: { fontFamily: 'JetBrains Mono', fontWeight: 700 } }, fmtPct(pct)),
        e('span', { style: { color: 'var(--text-muted)' } }, label)
    );
}

// Horizontal Bar Chart Component - for showing distributions that add to 100%
function HorizBarChart({ data, height = 32, showLabels = true, showValues = true }) {
    // data = [{ label, value, color, subValue }]
    if (!data || data.length === 0) return null;
    
    const total = data.reduce((sum, d) => sum + (d.value || 0), 0);
    if (total === 0) return null;
    
    const colorMap = {
        indigo: 'linear-gradient(135deg, #6366f1, #818cf8)',
        violet: 'linear-gradient(135deg, #8b5cf6, #a78bfa)',
        blue: 'linear-gradient(135deg, #3b82f6, #60a5fa)',
        cyan: 'linear-gradient(135deg, #06b6d4, #22d3ee)',
        emerald: 'linear-gradient(135deg, #10b981, #34d399)',
        amber: 'linear-gradient(135deg, #f59e0b, #fbbf24)',
        rose: 'linear-gradient(135deg, #f43f5e, #fb7185)',
        orange: 'linear-gradient(135deg, #f97316, #fb923c)',
        pink: 'linear-gradient(135deg, #ec4899, #f472b6)',
        lime: 'linear-gradient(135deg, #84cc16, #a3e635)',
        slate: 'linear-gradient(135deg, #64748b, #94a3b8)'
    };
    
    return e('div', { className: 'horiz-bar-wrapper' },
        e('div', { 
            className: 'horiz-bar',
            style: { 
                display: 'flex', 
                height: height + 'px', 
                borderRadius: '8px', 
                overflow: 'hidden',
                background: 'rgba(0,0,0,0.3)'
            }
        },
            data.map((d, i) => {
                const pct = total > 0 ? (d.value / total) * 100 : 0;
                if (pct < 1) return null; // Don't show tiny segments
                return e('div', {
                    key: i,
                    style: {
                        width: pct + '%',
                        background: colorMap[d.color] || colorMap.slate,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        fontSize: pct > 15 ? '0.7rem' : '0.55rem',
                        fontWeight: 700,
                        color: 'white',
                        textShadow: '0 1px 2px rgba(0,0,0,0.5)',
                        padding: '0 4px',
                        overflow: 'hidden',
                        whiteSpace: 'nowrap',
                        cursor: 'default',
                        transition: 'filter 0.15s ease'
                    },
                    title: `${d.label}: ${fmtPct(pct)}${d.subValue ? ' (' + d.subValue + ')' : ''}`
                }, pct > 8 ? fmtPct(pct) : '');
            })
        ),
        showLabels && e('div', { 
            style: { 
                display: 'flex', 
                flexWrap: 'wrap', 
                gap: '10px', 
                marginTop: '8px' 
            }
        },
            data.filter(d => d.value > 0).map((d, i) => 
                e('div', { 
                    key: i, 
                    style: { 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: '6px',
                        fontSize: '0.7rem',
                        color: 'var(--text-secondary)'
                    }
                },
                    e('div', { 
                        style: { 
                            width: '12px', 
                            height: '12px', 
                            borderRadius: '3px',
                            background: colorMap[d.color] || colorMap.slate
                        }
                    }),
                    e('span', null, d.label),
                    showValues && e('span', { 
                        style: { 
                            fontFamily: 'JetBrains Mono', 
                            fontWeight: 600,
                            color: 'var(--text-primary)'
                        }
                    }, fmtPct((d.value / total) * 100)),
                    d.subValue && e('span', { 
                        style: { 
                            fontSize: '0.6rem',
                            color: 'var(--text-muted)'
                        }
                    }, `(${d.subValue})`)
                )
            )
        )
    );
}

// Vertical Bar Chart for comparing values
function VertBarChart({ data, maxHeight = 120, showValues = true }) {
    if (!data || data.length === 0) return null;
    
    const maxVal = Math.max(...data.map(d => d.value || 0));
    if (maxVal === 0) return null;
    
    const colorMap = {
        indigo: '#6366f1',
        violet: '#8b5cf6',
        blue: '#3b82f6',
        cyan: '#06b6d4',
        emerald: '#10b981',
        amber: '#f59e0b',
        rose: '#f43f5e',
        orange: '#f97316'
    };
    
    return e('div', { 
        style: { 
            display: 'flex', 
            alignItems: 'flex-end', 
            justifyContent: 'space-around',
            gap: '8px',
            padding: '12px 0'
        }
    },
        data.map((d, i) => {
            const height = maxVal > 0 ? (d.value / maxVal) * maxHeight : 0;
            const pctClass = d.percentile !== undefined ? getPctClass(d.percentile) : '';
            
            return e('div', { 
                key: i, 
                style: { 
                    display: 'flex', 
                    flexDirection: 'column', 
                    alignItems: 'center',
                    gap: '6px',
                    flex: 1,
                    minWidth: '50px'
                }
            },
                showValues && e('div', { 
                    className: pctClass,
                    style: { 
                        fontSize: '0.8rem', 
                        fontFamily: 'JetBrains Mono',
                        fontWeight: 700
                    }
                }, d.format === 'pct' ? fmtPct(d.value) : d.format === 'ppp' ? fmtPpp(d.value) : fmt(d.value, 1)),
                e('div', { 
                    style: { 
                        width: '100%',
                        maxWidth: '60px',
                        height: Math.max(height, 4) + 'px',
                        background: `linear-gradient(180deg, ${colorMap[d.color] || colorMap.indigo}, ${colorMap[d.color] || colorMap.indigo}99)`,
                        borderRadius: '4px 4px 0 0',
                        transition: 'height 0.3s ease'
                    }
                }),
                e('div', { 
                    style: { 
                        fontSize: '0.65rem', 
                        color: 'var(--text-muted)',
                        textAlign: 'center',
                        marginTop: '4px'
                    }
                }, d.label)
            );
        })
    );
}

// Play Type Row Bars - Each play type as a separate horizontal bar
function PlayTypeRowBars({ data, maxValue = null, valueFormat = 'pct' }) {
    if (!data || data.length === 0) return null;
    
    // Filter out zero/null values and sort by value descending
    const filteredData = data.filter(d => d.value !== null && d.value !== undefined && d.value > 0).sort((a, b) => b.value - a.value);
    if (filteredData.length === 0) return e('div', { style: { fontSize: '0.65rem', color: 'var(--text-muted)', textAlign: 'center', padding: '8px' } }, 'No qualifying data');
    
    // Use item-specific maxValue if provided, otherwise calculate from data
    const max = maxValue || Math.max(...filteredData.map(d => d.maxValue || d.value));
    
    const colorMap = {
        indigo: 'linear-gradient(90deg, #6366f1, #818cf8)',
        violet: 'linear-gradient(90deg, #8b5cf6, #a78bfa)',
        blue: 'linear-gradient(90deg, #3b82f6, #60a5fa)',
        cyan: 'linear-gradient(90deg, #06b6d4, #22d3ee)',
        emerald: 'linear-gradient(90deg, #10b981, #34d399)',
        amber: 'linear-gradient(90deg, #f59e0b, #fbbf24)',
        rose: 'linear-gradient(90deg, #f43f5e, #fb7185)',
        orange: 'linear-gradient(90deg, #f97316, #fb923c)',
        pink: 'linear-gradient(90deg, #ec4899, #f472b6)',
        lime: 'linear-gradient(90deg, #84cc16, #a3e635)',
        slate: 'linear-gradient(90deg, #64748b, #94a3b8)'
    };
    
    // Format value based on format type
    const formatValue = (val) => {
        if (valueFormat === 'ppp') return val.toFixed(2);
        if (valueFormat === 'pct') return fmtPct(val);
        return fmtPct(val);
    };
    
    return e('div', { 
        style: { 
            display: 'flex', 
            flexDirection: 'column', 
            gap: '4px'
        }
    },
        filteredData.map((d, i) => {
            // For PPP, use individual maxValue if provided
            const itemMax = d.maxValue || max;
            const barWidth = itemMax > 0 ? (d.value / itemMax) * 100 : 0;
            return e('div', { 
                key: i, 
                style: { 
                    display: 'flex', 
                    alignItems: 'center', 
                    gap: '8px'
                }
            },
                // Label
                e('div', { 
                    style: { 
                        width: '55px', 
                        fontSize: '0.65rem', 
                        color: 'var(--text-secondary)',
                        textAlign: 'right',
                        flexShrink: 0
                    }
                }, d.label),
                // Bar container
                e('div', { 
                    style: { 
                        flex: 1, 
                        height: '14px', 
                        background: 'rgba(0,0,0,0.3)', 
                        borderRadius: '3px',
                        overflow: 'hidden'
                    }
                },
                    e('div', { 
                        style: { 
                            width: Math.min(barWidth, 100) + '%', 
                            height: '100%', 
                            background: colorMap[d.color] || colorMap.slate,
                            borderRadius: '3px',
                            transition: 'width 0.3s ease'
                        }
                    })
                ),
                // Value
                e('div', { 
                    style: { 
                        width: '38px', 
                        fontSize: '0.65rem', 
                        fontFamily: 'JetBrains Mono',
                        fontWeight: 600,
                        color: 'var(--text-primary)',
                        textAlign: 'right',
                        flexShrink: 0
                    }
                }, formatValue(d.value))
            );
        })
    );
}

// Play Type Distribution Bar
function PlayTypeBar({ distribution }) {
    if (!distribution || distribution.length === 0) return null;
    
    const colors = {
        'Transition': 'pt-transition',
        'Spot Up': 'pt-spot-up',
        'P&R Ball Handler': 'pt-pnr-bh',
        'Isolation': 'pt-isolation',
        'Post-Up': 'pt-post-up',
        'Cut': 'pt-cut',
        'Off Screen': 'pt-offscreen',
        'P&R Roll Man': 'pt-pnr-rm',
        'Handoffs': 'pt-handoffs',
        'Offensive Rebounds (Put Backs)': 'pt-putbacks',
        'Miscellaneous Plays': 'pt-misc'
    };
    
    return e('div', { className: 'playtype-bar-wrapper' },
        e('div', { className: 'playtype-bar' },
            distribution.filter(pt => pt.pct >= 2).map((pt, i) =>
                e('div', {
                    key: i,
                    className: `playtype-segment ${colors[pt.name] || 'pt-misc'}`,
                    style: { width: `${pt.pct}%` },
                    title: `${pt.name}: ${fmtPct(pt.pct)}`
                }, pt.pct >= 8 ? pt.name.substring(0, 10) : '')
            )
        ),
        e('div', { className: 'playtype-legend' },
            distribution.slice(0, 6).map((pt, i) =>
                e('div', { key: i, className: 'legend-item' },
                    e('div', { className: `legend-dot ${colors[pt.name] || 'pt-misc'}` }),
                    e('span', null, `${pt.name.substring(0, 12)}: ${fmtPct(pt.pct)}`)
                )
            )
        )
    );
}

// Split Card (On/Off Ball, Half Court/Transition)
function SplitCard({ type, title, icon, desc, badge, children }) {
    return e('div', { className: `split-card type-${type}` },
        e('div', { className: 'split-header' },
            e('span', { className: 'split-icon' }, icon),
            e('span', { className: `split-title type-${type}` }, title),
            badge && e('span', { className: 'split-badge' }, badge)
        ),
        desc && e('div', { className: 'split-desc' }, desc),
        children
    );
}

// Hand Visualization Component with PPP-based color coding
function HandVisualization({ leftData, rightData, title, pools }) {
    // Get background color based on PPP percentile
    const getPPPBackgroundStyle = (ppp, pools) => {
        const pppPct = pools ? calcPercentile(ppp, pools.ppp || [], true) : 50;
        
        // Define color stops based on percentile
        if (pppPct >= 80) {
            return {
                background: 'linear-gradient(135deg, rgba(16, 185, 129, 0.25), rgba(16, 185, 129, 0.15))',
                borderColor: 'rgba(16, 185, 129, 0.5)'
            };
        } else if (pppPct >= 60) {
            return {
                background: 'linear-gradient(135deg, rgba(132, 204, 22, 0.22), rgba(132, 204, 22, 0.12))',
                borderColor: 'rgba(132, 204, 22, 0.45)'
            };
        } else if (pppPct >= 40) {
            return {
                background: 'linear-gradient(135deg, rgba(250, 204, 21, 0.18), rgba(250, 204, 21, 0.1))',
                borderColor: 'rgba(250, 204, 21, 0.4)'
            };
        } else if (pppPct >= 20) {
            return {
                background: 'linear-gradient(135deg, rgba(251, 146, 60, 0.22), rgba(251, 146, 60, 0.12))',
                borderColor: 'rgba(251, 146, 60, 0.45)'
            };
        } else {
            return {
                background: 'linear-gradient(135deg, rgba(248, 113, 113, 0.25), rgba(248, 113, 113, 0.15))',
                borderColor: 'rgba(248, 113, 113, 0.5)'
            };
        }
    };
    
    const renderHand = (data, side) => {
        const isLeft = side === 'left';
        const pppPct = pools ? calcPercentile(data.ppp, pools.ppp || [], true) : null;
        const efgPct = pools ? calcPercentile(data.efg, pools.efg || [], true) : null;
        const colorStyle = getPPPBackgroundStyle(data.ppp, pools);
        
        return e('div', { 
            className: `hand-card ${side}`,
            style: {
                background: colorStyle.background,
                border: `1px solid ${colorStyle.borderColor}`
            }
        },
            e('div', { className: 'hand-icon', style: isLeft ? { transform: 'scaleX(-1)' } : {} }, ''),
            e('div', { className: 'hand-title' }, isLeft ? 'LEFT HAND' : 'RIGHT HAND'),
            e('div', { className: `hand-pct ${getPctClass(pppPct)}` }, fmtPct(data.pct)),
            // Per75 rate if available
            data.per75 !== null && data.per75 !== undefined && e('div', { 
                style: { 
                    fontSize: '0.7rem', 
                    color: 'var(--text-secondary)', 
                    marginTop: '-4px',
                    marginBottom: '4px'
                } 
            }, `${data.per75.toFixed(1)}/75`),
            e('div', { className: 'hand-stats' },
                e('div', { className: 'hand-stat-row' },
                    e('span', { className: 'hand-stat-label' }, 'PPP'),
                    e('span', { className: `hand-stat-value ${getPctClass(pppPct)}` }, fmtPpp(data.ppp))
                ),
                e('div', { className: 'hand-stat-row' },
                    e('span', { className: 'hand-stat-label' }, 'eFG%'),
                    e('span', { className: `hand-stat-value ${getPctClass(efgPct)}` }, fmtPct(data.efg))
                ),
                e('div', { className: 'hand-stat-row' },
                    e('span', { className: 'hand-stat-label' }, 'TO%'),
                    e('span', { className: 'hand-stat-value' }, fmtPct(data.toPct))
                ),
                data.shotTypes && e('div', { style: { marginTop: '8px', paddingTop: '8px', borderTop: '1px solid rgba(255,255,255,0.1)' } },
                    e('div', { className: 'hand-stat-row' },
                        e('span', { className: 'hand-stat-label' }, ' Rim'),
                        e('span', { className: 'hand-stat-value' }, fmtPct(data.shotTypes.rim?.pct || 0))
                    ),
                    e('div', { className: 'hand-stat-row' },
                        e('span', { className: 'hand-stat-label' }, ' Mid'),
                        e('span', { className: 'hand-stat-value' }, fmtPct(data.shotTypes.mid?.pct || 0))
                    ),
                    e('div', { className: 'hand-stat-row' },
                        e('span', { className: 'hand-stat-label' }, ' 3PT'),
                        e('span', { className: 'hand-stat-value' }, fmtPct(data.shotTypes.three?.pct || 0))
                    )
                )
            )
        );
    };
    
    return e('div', null,
        title && e('div', { className: 'subsection-title' }, title),
        e('div', { className: 'hands-container' },
            renderHand(leftData, 'left'),
            renderHand(rightData, 'right')
        )
    );
}

// Shot Zone Grid
function ShotZones({ zones }) {
    return e('div', { className: 'shot-zones' },
        zones.map((zone, i) =>
            e('div', { key: i, className: 'shot-zone' },
                e('div', { className: 'shot-zone-label' }, zone.label),
                e('div', { className: `shot-zone-value ${getPctClass(zone.percentile)}` }, 
                    zone.format === 'pct' ? fmtPct(zone.value) : fmt(zone.value, 1)
                ),
                zone.sub && e('div', { className: 'shot-zone-sub' }, zone.sub)
            )
        )
    );
}

// Roll Man Types Grid
function RollManTypes({ data, pools }) {
    const types = [
        { key: 'pickAndPop', name: 'Pick & Pop', icon: '' },
        { key: 'slip', name: 'Slip', icon: '' },
        { key: 'roll', name: 'Roll', icon: '' }
    ];
    
    return e('div', { className: 'rollman-grid' },
        types.map(type => {
            const typeData = data[type.key] || { pct: 0, ppp: 0, efg: 0 };
            const pppPct = pools ? calcPercentile(typeData.ppp, pools.ppp || [], true) : null;
            const efgPct = pools ? calcPercentile(typeData.efg, pools.efg || [], true) : null;
            
            return e('div', { key: type.key, className: 'rollman-card' },
                e('div', { className: 'rollman-icon' }, type.icon),
                e('div', { className: 'rollman-name' }, type.name),
                e('div', { className: `rollman-pct ${getPctClass(pppPct)}` }, fmtPct(typeData.pct)),
                e('div', { className: 'mini-stats', style: { justifyContent: 'center' } },
                    e('div', { className: 'mini-stat' },
                        e('span', { className: 'mini-stat-label' }, 'PPP:'),
                        e('span', { className: `mini-stat-value ${getPctClass(pppPct)}` }, fmtPpp(typeData.ppp))
                    )
                ),
                e('div', { className: 'mini-stats', style: { justifyContent: 'center' } },
                    e('div', { className: 'mini-stat' },
                        e('span', { className: 'mini-stat-label' }, 'eFG:'),
                        e('span', { className: `mini-stat-value ${getPctClass(efgPct)}` }, fmtPct(typeData.efg))
                    )
                )
            );
        })
    );
}

// Transition Roles Grid
function TransitionRoles({ roles }) {
    const roleIcons = {
        'Ballhandler': '',
        'Right Wing': '',
        'Left Wing': '',
        'Leak Outs': '',
        'First Middle': '',
        'Trailer': ''
    };
    
    return e('div', { className: 'trans-roles' },
        Object.entries(roles).filter(([_, data]) => data.poss > 0).map(([role, data]) =>
            e('div', { key: role, className: 'trans-role' },
                e('div', { className: 'trans-role-icon' }, roleIcons[role] || ''),
                e('div', { className: 'trans-role-name' }, role),
                e('div', { className: 'trans-role-pct' }, fmtPct(data.pct))
            )
        )
    );
}

// Post Block Card with shot outcome breakdown
function PostBlockCard({ data, side, pools }) {
    const pppPct = pools ? calcPercentile(data.ppp, pools.ppp || [], true) : null;
    const efgPct = pools ? calcPercentile(data.efg, pools.efg || [], true) : null;
    
    // Shot outcome labels
    const outcomeLabels = {
        toHook: ' Hook',
        toBasket: ' Basket',
        toJumper: ' Jumper',
        toDropStep: ' Drop Step',
        toUpAndUnder: ' Up&Under'
    };
    
    // Render shot outcomes for a shoulder
    const renderShotOutcomes = (shoulder, shoulderData) => {
        if (!shoulderData?.shotOutcomes) return null;
        
        const outcomes = shoulderData.shotOutcomes;
        const hasData = Object.values(outcomes).some(o => o.rawPoss > 0);
        if (!hasData) return null;
        
        return e('div', { 
            style: { 
                marginTop: '8px', 
                padding: '8px', 
                background: 'rgba(0,0,0,0.25)', 
                borderRadius: '6px',
                fontSize: '0.65rem'
            }
        },
            e('div', { style: { 
                fontWeight: 600, 
                color: 'var(--text-secondary)', 
                marginBottom: '6px',
                fontSize: '0.6rem',
                textTransform: 'uppercase'
            }}, shoulder),
            Object.entries(outcomes).filter(([_, o]) => o.rawPoss > 0).map(([key, outcome]) =>
                e('div', { 
                    key,
                    style: { 
                        display: 'flex', 
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        padding: '3px 0',
                        borderBottom: '1px solid rgba(255,255,255,0.05)'
                    }
                },
                    e('span', { style: { color: 'var(--text-muted)' } }, outcomeLabels[key] || key),
                    e('div', { style: { display: 'flex', gap: '8px', fontFamily: 'JetBrains Mono' } },
                        e('span', { style: { color: 'var(--text-secondary)' } }, fmtPct(outcome.pct)),
                        e('span', { className: getPctClass(calcPercentile(outcome.efg, pools?.efg || [], true)) }, fmtPct(outcome.efg)),
                        e('span', { className: getPctClass(calcPercentile(outcome.ppp, pools?.ppp || [], true)) }, fmtPpp(outcome.ppp))
                    )
                )
            ),
            e('div', { 
                style: { 
                    display: 'flex', 
                    justifyContent: 'flex-end',
                    gap: '8px',
                    marginTop: '4px',
                    paddingTop: '4px',
                    fontSize: '0.55rem',
                    color: 'var(--text-dim)'
                }
            },
                e('span', null, 'FREQ'),
                e('span', null, 'FG%'),
                e('span', null, 'PPP')
            )
        );
    };
    
    return e('div', { className: `post-block ${side}` },
        e('div', { className: 'post-block-header' },
            e('span', null, side === 'left' ? '' : ''),
            e('span', { className: 'post-block-title' }, side === 'left' ? 'LEFT BLOCK' : 'RIGHT BLOCK'),
            e('span', { className: 'post-block-pct' }, fmtPct(data.pct))
        ),
        e('div', { className: 'mini-stats', style: { marginBottom: '12px' } },
            e('div', { className: 'mini-stat' },
                e('span', { className: 'mini-stat-label' }, 'PPP:'),
                e('span', { className: `mini-stat-value ${getPctClass(pppPct)}` }, fmtPpp(data.ppp))
            ),
            e('div', { className: 'mini-stat' },
                e('span', { className: 'mini-stat-label' }, 'eFG:'),
                e('span', { className: `mini-stat-value ${getPctClass(efgPct)}` }, fmtPct(data.efg))
            )
        ),
        e('div', { className: 'post-moves' },
            e('div', { className: 'post-move' },
                e('span', null, 'Left Shoulder'),
                e('span', { style: { fontWeight: '600' } }, fmtPct(data.moves?.leftShoulder?.pct || 0))
            ),
            e('div', { className: 'post-move' },
                e('span', null, 'Right Shoulder'),
                e('span', { style: { fontWeight: '600' } }, fmtPct(data.moves?.rightShoulder?.pct || 0))
            ),
            e('div', { className: 'post-move' },
                e('span', null, 'Face-Up'),
                e('span', { style: { fontWeight: '600' } }, fmtPct(data.moves?.faceUp?.pct || 0))
            )
        ),
        // Shot outcomes for each shoulder
        renderShotOutcomes('Left Shoulder Outcomes', data.moves?.leftShoulder),
        renderShotOutcomes('Right Shoulder Outcomes', data.moves?.rightShoulder)
    );
}

// Post Move Effectiveness Table with Shot Outcomes
function PostMoveTable({ moves, pools }) {
    const moveTypes = [
        { key: 'leftShoulder', name: 'Left Shoulder', icon: '' },
        { key: 'rightShoulder', name: 'Right Shoulder', icon: '' },
        { key: 'faceUp', name: 'Face-Up', icon: '' }
    ];
    
    // Shot outcome labels
    const outcomeLabels = {
        toHook: ' Hook',
        toBasket: ' Basket',
        toJumper: ' Jumper',
        toDropStep: ' Drop Step',
        toUpAndUnder: ' Up & Under'
    };
    
    const [expandedMove, setExpandedMove] = React.useState(null);
    
    const renderOutcomesRow = (moveKey, outcomes) => {
        if (!outcomes) return null;
        const hasData = Object.values(outcomes).some(o => o.rawPoss > 0);
        if (!hasData) return null;
        
        return e('tr', { key: `${moveKey}-outcomes` },
            e('td', { colSpan: 6, style: { padding: 0 } },
                e('div', { 
                    style: { 
                        background: 'rgba(99, 102, 241, 0.08)', 
                        padding: '10px 12px',
                        borderLeft: '3px solid var(--accent-indigo)'
                    }
                },
                    e('div', { 
                        style: { 
                            fontSize: '0.6rem', 
                            color: 'var(--text-muted)', 
                            marginBottom: '8px',
                            textTransform: 'uppercase'
                        }
                    }, 'Shot Outcome Breakdown'),
                    e('table', { style: { width: '100%', fontSize: '0.7rem' } },
                        e('thead', null,
                            e('tr', null,
                                e('th', { style: { textAlign: 'left', padding: '4px', fontWeight: 600, color: 'var(--text-dim)' } }, 'OUTCOME'),
                                e('th', { style: { textAlign: 'right', padding: '4px', fontWeight: 600, color: 'var(--text-dim)' } }, 'FREQ'),
                                e('th', { style: { textAlign: 'right', padding: '4px', fontWeight: 600, color: 'var(--text-dim)' } }, 'FG%'),
                                e('th', { style: { textAlign: 'right', padding: '4px', fontWeight: 600, color: 'var(--text-dim)' } }, 'PPP')
                            )
                        ),
                        e('tbody', null,
                            Object.entries(outcomes)
                                .filter(([_, o]) => o.rawPoss > 0)
                                .sort((a, b) => b[1].rawPoss - a[1].rawPoss)
                                .map(([key, outcome]) => {
                                    const fgPct = outcome.fg2Att > 0 ? (outcome.fg2Made / outcome.fg2Att) * 100 : 
                                                  outcome.fgAtt > 0 ? (outcome.fgMade / outcome.fgAtt) * 100 : outcome.efg;
                                    const effPct = calcPercentile(fgPct, pools?.efg || [], true);
                                    const pppPctile = calcPercentile(outcome.ppp, pools?.ppp || [], true);
                                    
                                    return e('tr', { key },
                                        e('td', { style: { padding: '4px', color: 'var(--text-secondary)' } }, outcomeLabels[key] || key),
                                        e('td', { style: { textAlign: 'right', padding: '4px', fontFamily: 'JetBrains Mono' } }, fmtPct(outcome.pct)),
                                        e('td', { style: { textAlign: 'right', padding: '4px', fontFamily: 'JetBrains Mono' }, className: getPctClass(effPct) }, fmtPct(fgPct)),
                                        e('td', { style: { textAlign: 'right', padding: '4px', fontFamily: 'JetBrains Mono' }, className: getPctClass(pppPctile) }, fmtPpp(outcome.ppp))
                                    );
                                })
                        )
                    )
                )
            )
        );
    };
    
    return e('div', null,
        e('table', { className: 'data-table' },
            e('thead', null,
                e('tr', null,
                    e('th', null, 'MOVE'),
                    e('th', null, 'FREQ'),
                    e('th', null, 'PPP'),
                    e('th', null, 'eFG%'),
                    e('th', null, 'TO%'),
                    e('th', null, 'DETAIL')
                )
            ),
            e('tbody', null,
                moveTypes.flatMap(move => {
                    const data = moves[move.key] || {};
                    const pppPct = pools ? calcPercentile(data.ppp, pools.ppp || [], true) : null;
                    const efgPct = pools ? calcPercentile(data.efg, pools.efg || [], true) : null;
                    const toPct = pools ? calcPercentile(data.toPct, pools.toPct || [], false) : null;
                    const hasOutcomes = data.shotOutcomes && Object.values(data.shotOutcomes).some(o => o.rawPoss > 0);
                    const isExpanded = expandedMove === move.key;
                    
                    const rows = [
                        e('tr', { 
                            key: move.key,
                            style: hasOutcomes ? { cursor: 'pointer' } : {},
                            onClick: hasOutcomes ? () => setExpandedMove(isExpanded ? null : move.key) : undefined
                        },
                            e('td', null, move.icon + ' ' + move.name),
                            e('td', null, fmtPct(data.pct || 0)),
                            e('td', null, e('span', { className: getPctClass(pppPct) }, fmtPpp(data.ppp || 0))),
                            e('td', null, e('span', { className: getPctClass(efgPct) }, fmtPct(data.efg || 0))),
                            e('td', null, e('span', { className: getPctClass(toPct) }, fmtPct(data.toPct || 0))),
                            e('td', null, hasOutcomes ? 
                                e('span', { 
                                    style: { 
                                        fontSize: '0.65rem', 
                                        color: 'var(--accent-indigo)',
                                        cursor: 'pointer'
                                    }
                                }, isExpanded ? ' Hide' : ' Show') : 
                                e('span', { style: { color: 'var(--text-dim)' } }, '-')
                            )
                        )
                    ];
                    
                    if (isExpanded && hasOutcomes) {
                        rows.push(renderOutcomesRow(move.key, data.shotOutcomes));
                    }
                    
                    return rows;
                })
            )
        )
    );
}

// Off Screen Direction Card
function OffScreenDirectionCard({ data, direction, pools }) {
    const pppPct = pools ? calcPercentile(data.ppp, pools.ppp || [], true) : null;
    const efgPct = pools ? calcPercentile(data.efg, pools.efg || [], true) : null;
    
    return e('div', { className: `split-card type-${direction === 'left' ? 'left' : 'right'}` },
        e('div', { className: 'split-header' },
            e('span', { className: 'split-icon' }, direction === 'left' ? '' : ''),
            e('span', { className: `split-title type-${direction === 'left' ? 'left' : 'right'}` }, 
                direction === 'left' ? "Shooter's Left" : "Shooter's Right"),
            e('span', { className: 'split-badge' }, fmtPct(data.pct))
        ),
        
        e('div', { className: 'mini-stats', style: { marginBottom: '12px' } },
            e('div', { className: 'mini-stat' },
                e('span', { className: 'mini-stat-label' }, 'PPP:'),
                e('span', { className: `mini-stat-value ${getPctClass(pppPct)}` }, fmtPpp(data.ppp))
            ),
            e('div', { className: 'mini-stat' },
                e('span', { className: 'mini-stat-label' }, 'eFG:'),
                e('span', { className: `mini-stat-value ${getPctClass(efgPct)}` }, fmtPct(data.efg))
            ),
            e('div', { className: 'mini-stat' },
                e('span', { className: 'mini-stat-label' }, 'TO:'),
                e('span', { className: 'mini-stat-value' }, fmtPct(data.toPct))
            )
        ),
        
        e('div', { style: { marginBottom: '12px' } },
            e('div', { style: { fontSize: '0.65rem', color: 'var(--text-muted)', marginBottom: '6px', textTransform: 'uppercase' } }, 'Cut Type'),
            e('div', { className: 'mini-stats' },
                e('div', { className: 'mini-stat' },
                    e('span', { className: 'mini-stat-label' }, 'Straight:'),
                    e('span', { className: 'mini-stat-value' }, fmtPct(data.cuts?.straight?.pct || 0))
                ),
                e('div', { className: 'mini-stat' },
                    e('span', { className: 'mini-stat-label' }, 'Flare:'),
                    e('span', { className: 'mini-stat-value' }, fmtPct(data.cuts?.flare?.pct || 0))
                ),
                e('div', { className: 'mini-stat' },
                    e('span', { className: 'mini-stat-label' }, 'Curl:'),
                    e('span', { className: 'mini-stat-value' }, fmtPct(data.cuts?.curl?.pct || 0))
                )
            )
        ),
        
        e('div', null,
            e('div', { style: { fontSize: '0.65rem', color: 'var(--text-muted)', marginBottom: '6px', textTransform: 'uppercase' } }, 'Shot Type'),
            e('div', { className: 'mini-stats' },
                e('div', { className: 'mini-stat' },
                    e('span', { className: 'mini-stat-label' }, ' Rim:'),
                    e('span', { className: 'mini-stat-value' }, fmtPct(data.shots?.rim?.pct || 0))
                ),
                e('div', { className: 'mini-stat' },
                    e('span', { className: 'mini-stat-label' }, ' C&S:'),
                    e('span', { className: 'mini-stat-value' }, fmtPct(data.shots?.catchShoot?.pct || 0))
                ),
                e('div', { className: 'mini-stat' },
                    e('span', { className: 'mini-stat-label' }, ' Pull:'),
                    e('span', { className: 'mini-stat-value' }, fmtPct(data.shots?.pullUp?.pct || 0))
                )
            )
        )
    );
}

// Spacing Meter
function SpacingMeter({ value }) {
    const getColor = (val) => {
        if (val >= 70) return 'pct-elite';
        if (val >= 55) return 'pct-good';
        if (val >= 40) return 'pct-avg';
        if (val >= 25) return 'pct-below';
        return 'pct-poor';
    };
    
    const getLabel = (val) => {
        if (val >= 80) return 'ELITE SPACER';
        if (val >= 65) return 'EXCELLENT';
        if (val >= 50) return 'GOOD';
        if (val >= 35) return 'AVERAGE';
        if (val >= 20) return 'BELOW AVG';
        return 'LIMITED';
    };
    
    return e('div', { className: 'spacing-meter' },
        e('div', { className: 'spacing-label' }, ' SPACING VALUE'),
        e('div', { className: `spacing-value ${getColor(value)}` }, Math.round(value)),
        e('div', { className: 'spacing-desc' }, getLabel(value))
    );
}

// Empty State
function EmptyState({ icon, text }) {
    return e('div', { className: 'empty-state' },
        e('div', { className: 'empty-icon' }, icon || ''),
        e('div', { className: 'empty-text' }, text || 'No data available')
    );
}

// Loading State
function LoadingState() {
    return e('div', { className: 'loading' },
        e('div', { className: 'loading-spinner' }),
        'Loading data...'
    );
}

// Mini Stats Row
function MiniStats({ stats }) {
    return e('div', { className: 'mini-stats' },
        stats.map((stat, i) =>
            e('div', { key: i, className: 'mini-stat' },
                e('span', { className: 'mini-stat-label' }, stat.label + ':'),
                e('span', { className: `mini-stat-value ${stat.pctClass || ''}` }, stat.value)
            )
        )
    );
}

// Subsection wrapper
function Subsection({ title, children }) {
    return e('div', { className: 'subsection' },
        title && e('div', { className: 'subsection-title' }, title),
        children
    );
}

console.log('Part 3 loaded successfully - UI Components ready');

// ============================================
// PART 4: SECTION COMPONENTS
// ============================================

// Pie Chart Component
function PieChart({ data, title }) {
    const colors = {
        'Transition': '#f59e0b',
        'Spot Up': '#3b82f6',
        'P&R Ball Handler': '#8b5cf6',
        'Isolation': '#ef4444',
        'Post-Up': '#f97316',
        'Cut': '#10b981',
        'Off Screen': '#06b6d4',
        'P&R Roll Man': '#ec4899',
        'Handoffs': '#84cc16',
        'Offensive Rebounds (Put Backs)': '#6366f1',
        'Miscellaneous Plays': '#6b7280'
    };
    
    const getColor = (name) => colors[name] || '#6b7280';
    
    // Calculate pie slices
    let cumulativePercent = 0;
    const slices = data.filter(d => d.pct > 0).map((d, i) => {
        const startPercent = cumulativePercent;
        cumulativePercent += d.pct;
        return {
            ...d,
            startPercent,
            endPercent: cumulativePercent,
            color: getColor(d.name)
        };
    });
    
    // Create SVG path for each slice
    const getSlicePath = (slice) => {
        const startAngle = (slice.startPercent / 100) * 360 - 90;
        const endAngle = (slice.endPercent / 100) * 360 - 90;
        
        const startRad = (startAngle * Math.PI) / 180;
        const endRad = (endAngle * Math.PI) / 180;
        
        const cx = 90, cy = 90, r = 70;
        
        const x1 = cx + r * Math.cos(startRad);
        const y1 = cy + r * Math.sin(startRad);
        const x2 = cx + r * Math.cos(endRad);
        const y2 = cy + r * Math.sin(endRad);
        
        const largeArc = (slice.endPercent - slice.startPercent) > 50 ? 1 : 0;
        
        return `M ${cx} ${cy} L ${x1} ${y1} A ${r} ${r} 0 ${largeArc} 1 ${x2} ${y2} Z`;
    };
    
    // Short labels for legend
    const shortLabels = {
        'Transition': 'Trans',
        'Spot Up': 'Spot Up',
        'P&R Ball Handler': 'P&R BH',
        'Isolation': 'ISO',
        'Post-Up': 'Post',
        'Cut': 'Cut',
        'Off Screen': 'Off Scr',
        'P&R Roll Man': 'Roll Man',
        'Handoffs': 'HO',
        'Offensive Rebounds (Put Backs)': 'OREB',
        'Miscellaneous Plays': 'Misc'
    };
    
    return e('div', { className: 'pie-chart-wrapper' },
        e('div', { className: 'pie-chart-title' }, title),
        e('svg', { className: 'pie-chart-svg', viewBox: '0 0 180 180' },
            slices.map((slice, i) => 
                e('path', {
                    key: i,
                    d: getSlicePath(slice),
                    fill: slice.color,
                    stroke: 'var(--bg-primary)',
                    strokeWidth: 2,
                    style: { transition: 'all 0.2s' }
                })
            ),
            // Center circle for donut effect
            e('circle', { cx: 90, cy: 90, r: 40, fill: 'var(--bg-card)' })
        ),
        e('div', { className: 'pie-legend' },
            slices.slice(0, 6).map((slice, i) => 
                e('div', { key: i, className: 'pie-legend-item' },
                    e('div', { 
                        className: 'pie-legend-dot',
                        style: { backgroundColor: slice.color }
                    }),
                    e('span', null, `${shortLabels[slice.name] || slice.name} ${fmt(slice.pct, 1)}%`)
                )
            )
        )
    );
}

// Overview Section
function OverviewSection({ playerData, pools }) {
    const distribution = Object.entries(playerData.playTypeStats)
        .map(([name, stats]) => ({ name, pct: stats.pctOfPoss, ...stats }))
        .filter(pt => pt.poss > 0)
        .sort((a, b) => b.pct - a.pct);
    
    const ptDistribution = Object.entries(playerData.playTypeStats)
        .map(([name, stats]) => ({ name, pct: stats.pctOfPts, ...stats }))
        .filter(pt => pt.pts > 0)
        .sort((a, b) => b.pct - a.pct);
    
    const pppPct = calcPercentile(playerData.ppp, pools?.ppp || [], true);
    const efgPct = calcPercentile(playerData.efg, pools?.efg || [], true);
    const toPctile = calcPercentile(playerData.toPct, pools?.toPct || [], false);
    const ftRatePct = calcPercentile(playerData.ftRate, pools?.ftRate || [], true);
    
    return e('div', { className: 'section span-12' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'PLAYER OVERVIEW'),
            e('span', { className: 'section-subtitle' }, `${playerData.totalGames} GAMES`)
        ),
        
        e('div', { className: 'stat-grid', style: { marginBottom: '16px' } },
            e(StatCard, { label: 'POSS', value: playerData.totalPoss }),
            e(StatCard, { label: 'POSS/G', value: playerData.possPerGame, format: 'dec' }),
            e(StatCard, { label: 'PTS', value: playerData.totalPts }),
            e(StatCard, { label: 'PTS/G', value: playerData.ptsPerGame, format: 'dec' }),
            e(StatCard, { label: 'PPP', value: playerData.ppp, format: 'ppp', percentile: pppPct }),
            e(StatCard, { label: 'eFG%', value: playerData.efg, format: 'pct', percentile: efgPct }),
            e(StatCard, { label: 'TO%', value: playerData.toPct, format: 'pct', percentile: toPctile }),
            e(StatCard, { label: 'FT RATE', value: playerData.ftRate, format: 'pct', percentile: ftRatePct })
        ),
        
        // Pie Charts for distribution
        e('div', { className: 'pie-charts-container' },
            e(PieChart, { 
                data: distribution,
                title: '% of Possessions by Play Type'
            }),
            e(PieChart, { 
                data: ptDistribution,
                title: '% of Points by Play Type'
            })
        )
    );
}

// On/Off Ball Section with Spacing/Finishing breakdown
function OnOffBallSection({ playerData, pools }) {
    const { onBall, offBall, playTypeStats } = playerData;
    
    // Spacing play types: Spot Up, Handoffs, Off Screen
    const spacingTypes = ['Spot Up', 'Handoffs', 'Off Screen'];
    const spacingStats = spacingTypes.reduce((acc, pt) => {
        const stats = playTypeStats[pt] || { poss: 0, pts: 0, fgAtt: 0, fgMade: 0, fg3Made: 0, turnovers: 0, ftAttempts: 0 };
        return {
            poss: acc.poss + stats.poss,
            pts: acc.pts + stats.pts,
            fgAtt: acc.fgAtt + stats.fgAtt,
            fgMade: acc.fgMade + stats.fgMade,
            fg3Made: acc.fg3Made + stats.fg3Made,
            turnovers: acc.turnovers + stats.turnovers,
            ftAttempts: acc.ftAttempts + stats.ftAttempts
        };
    }, { poss: 0, pts: 0, fgAtt: 0, fgMade: 0, fg3Made: 0, turnovers: 0, ftAttempts: 0 });
    
    const spacing = {
        ...spacingStats,
        ppp: spacingStats.poss > 0 ? spacingStats.pts / spacingStats.poss : 0,
        efg: calcEfg(spacingStats.fgMade, spacingStats.fgAtt, spacingStats.fg3Made),
        toPct: calcToPct(spacingStats.turnovers, spacingStats.poss),
        ftRate: calcFtRate(spacingStats.ftAttempts, spacingStats.fgAtt),
        pctOfPoss: playerData.totalPoss > 0 ? (spacingStats.poss / playerData.totalPoss) * 100 : 0,
        possPerGame: playerData.totalGames > 0 ? spacingStats.poss / playerData.totalGames : 0
    };
    
    // Finishing play types: Cut, P&R Roll Man, Offensive Rebounds, Miscellaneous Plays
    const finishingTypes = ['Cut', 'P&R Roll Man', 'Offensive Rebounds (Put Backs)', 'Miscellaneous Plays'];
    const finishingStats = finishingTypes.reduce((acc, pt) => {
        const stats = playTypeStats[pt] || { poss: 0, pts: 0, fgAtt: 0, fgMade: 0, fg3Made: 0, turnovers: 0, ftAttempts: 0 };
        return {
            poss: acc.poss + stats.poss,
            pts: acc.pts + stats.pts,
            fgAtt: acc.fgAtt + stats.fgAtt,
            fgMade: acc.fgMade + stats.fgMade,
            fg3Made: acc.fg3Made + stats.fg3Made,
            turnovers: acc.turnovers + stats.turnovers,
            ftAttempts: acc.ftAttempts + stats.ftAttempts
        };
    }, { poss: 0, pts: 0, fgAtt: 0, fgMade: 0, fg3Made: 0, turnovers: 0, ftAttempts: 0 });
    
    const finishing = {
        ...finishingStats,
        ppp: finishingStats.poss > 0 ? finishingStats.pts / finishingStats.poss : 0,
        efg: calcEfg(finishingStats.fgMade, finishingStats.fgAtt, finishingStats.fg3Made),
        toPct: calcToPct(finishingStats.turnovers, finishingStats.poss),
        ftRate: calcFtRate(finishingStats.ftAttempts, finishingStats.fgAtt),
        pctOfPoss: playerData.totalPoss > 0 ? (finishingStats.poss / playerData.totalPoss) * 100 : 0,
        possPerGame: playerData.totalGames > 0 ? finishingStats.poss / playerData.totalGames : 0
    };
    
    const renderSplitStats = (data, type) => {
        const pppPct = calcPercentile(data.ppp, pools?.[type + 'Ppp'] || pools?.ppp || [], true);
        const efgPct = calcPercentile(data.efg, pools?.[type + 'Efg'] || pools?.efg || [], true);
        const toPctile = calcPercentile(data.toPct, pools?.[type + 'ToPct'] || pools?.toPct || [], false);
        
        return e('div', { className: 'stat-grid compact' },
            e(StatCard, { label: 'POSS', value: data.poss, sub: fmtPct(data.pctOfPoss) }),
            e(StatCard, { label: 'POSS/G', value: data.possPerGame, format: 'dec' }),
            e(StatCard, { label: 'PPP', value: data.ppp, format: 'ppp', percentile: pppPct }),
            e(StatCard, { label: 'eFG%', value: data.efg, format: 'pct', percentile: efgPct }),
            e(StatCard, { label: 'TO%', value: data.toPct, format: 'pct', percentile: toPctile }),
            e(StatCard, { label: 'FT RATE', value: data.ftRate, format: 'pct' })
        );
    };
    
    const renderOffBallBreakdown = (stats, title, types) => {
        return e('div', { style: { marginTop: '8px' } },
            e('div', { style: { fontSize: '0.6rem', color: 'var(--text-dim)', marginBottom: '4px' } }, title),
            types.map(pt => {
                const ptStats = playTypeStats[pt];
                if (!ptStats || ptStats.poss === 0) return null;
                return e('div', { 
                    key: pt,
                    style: { 
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        alignItems: 'center',
                        padding: '3px 6px',
                        background: 'rgba(0,0,0,0.2)',
                        borderRadius: '4px',
                        marginBottom: '2px',
                        fontSize: '0.65rem'
                    }
                },
                    e('span', { style: { color: 'var(--text-secondary)' } }, 
                        pt === 'Offensive Rebounds (Put Backs)' ? 'OREB' : 
                        pt === 'P&R Roll Man' ? 'Roll Man' : 
                        pt === 'Miscellaneous Plays' ? 'Misc' : pt),
                    e('span', { style: { fontFamily: 'JetBrains Mono', fontWeight: 600 } }, 
                        fmtPct(ptStats.pctOfPoss) + ' | ' + fmtPpp(ptStats.ppp))
                );
            })
        );
    };
    
    return e('div', { className: 'section span-6' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'ON-BALL vs OFF-BALL')
        ),
        
        // On-Ball vs Off-Ball split
        e('div', { className: 'split-container' },
            e(SplitCard, { 
                type: 'onball', 
                title: 'ON-BALL', 
                icon: '',
                desc: 'ISO, P&R BH, Post-Up',
                badge: fmtPct(onBall.pctOfPoss)
            }, renderSplitStats(onBall, 'onBall')),
            
            e(SplitCard, { 
                type: 'offball', 
                title: 'OFF-BALL', 
                icon: '',
                desc: 'Spacing + Finishing',
                badge: fmtPct(offBall.pctOfPoss)
            }, renderSplitStats(offBall, 'offBall'))
        ),
        
        // Off-Ball Breakdown: Spacing vs Finishing
        e(Subsection, { title: ' Off-Ball Breakdown' },
            e('div', { className: 'split-container' },
                e('div', { className: 'split-card', style: { borderLeftColor: 'var(--accent-cyan)' } },
                    e('div', { className: 'split-header' },
                        e('span', { className: 'split-icon' }, ''),
                        e('span', { className: 'split-title', style: { color: 'var(--accent-cyan)' } }, 'SPACING'),
                        e('span', { className: 'split-badge' }, fmtPct(spacing.pctOfPoss))
                    ),
                    e('div', { className: 'split-desc' }, 'Spot Up, Handoffs, Off Screen'),
                    e('div', { className: 'mini-stats', style: { marginBottom: '6px' } },
                        e('div', { className: 'mini-stat' },
                            e('span', { className: 'mini-stat-label' }, 'PPP:'),
                            e('span', { className: `mini-stat-value ${getPctClass(calcPercentile(spacing.ppp, pools?.ppp || [], true))}` }, fmtPpp(spacing.ppp))
                        ),
                        e('div', { className: 'mini-stat' },
                            e('span', { className: 'mini-stat-label' }, 'eFG:'),
                            e('span', { className: 'mini-stat-value' }, fmtPct(spacing.efg))
                        )
                    ),
                    renderOffBallBreakdown(spacing, 'BREAKDOWN', spacingTypes)
                ),
                
                e('div', { className: 'split-card', style: { borderLeftColor: 'var(--accent-emerald)' } },
                    e('div', { className: 'split-header' },
                        e('span', { className: 'split-icon' }, ''),
                        e('span', { className: 'split-title', style: { color: 'var(--accent-emerald)' } }, 'FINISHING'),
                        e('span', { className: 'split-badge' }, fmtPct(finishing.pctOfPoss))
                    ),
                    e('div', { className: 'split-desc' }, 'Cuts, Roll Man, OREB, Misc'),
                    e('div', { className: 'mini-stats', style: { marginBottom: '6px' } },
                        e('div', { className: 'mini-stat' },
                            e('span', { className: 'mini-stat-label' }, 'PPP:'),
                            e('span', { className: `mini-stat-value ${getPctClass(calcPercentile(finishing.ppp, pools?.ppp || [], true))}` }, fmtPpp(finishing.ppp))
                        ),
                        e('div', { className: 'mini-stat' },
                            e('span', { className: 'mini-stat-label' }, 'eFG:'),
                            e('span', { className: 'mini-stat-value' }, fmtPct(finishing.efg))
                        )
                    ),
                    renderOffBallBreakdown(finishing, 'BREAKDOWN', finishingTypes)
                )
            )
        )
    );
}

// Transition Section
function TransHalfCourtSection({ transData, pools }) {
    const renderSplitStats = (data) => {
        const pppPct = calcPercentile(data.ppp, pools?.ppp || [], true);
        const efgPct = calcPercentile(data.efg, pools?.efg || [], true);
        const toPctile = calcPercentile(data.toPct, pools?.toPct || [], false);
        
        return e('div', { className: 'stat-grid compact' },
            e(StatCard, { label: '% POSS', value: data.pctOfPoss, format: 'pct' }),
            e(StatCard, { label: '% PTS', value: data.pctOfPts, format: 'pct' }),
            e(StatCard, { label: 'PPP', value: data.ppp, format: 'ppp', percentile: pppPct }),
            e(StatCard, { label: 'eFG%', value: data.efg, format: 'pct', percentile: efgPct }),
            e(StatCard, { label: 'TO%', value: data.toPct, format: 'pct', percentile: toPctile }),
            e(StatCard, { label: 'FT RATE', value: data.ftRate, format: 'pct' })
        );
    };
    
    return e('div', { className: 'section span-6' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'TRANSITION vs HALF COURT')
        ),
        
        e('div', { className: 'split-container' },
            e(SplitCard, { 
                type: 'transition', 
                title: 'TRANSITION', 
                icon: '',
                badge: fmtPct(transData.main.pctOfPoss)
            }, renderSplitStats(transData.main)),
            
            e(SplitCard, { 
                type: 'halfcourt', 
                title: 'HALF COURT', 
                icon: '',
                badge: fmtPct(transData.halfCourt.pctOfPoss)
            }, renderSplitStats(transData.halfCourt))
        ),
        
        transData.roles && e(Subsection, { title: ' Transition Roles' },
            e(TransitionRoles, { roles: transData.roles })
        )
    );
}

// Shooting C&S Section
function ShootingSection({ cnsData, pools }) {
    const fg3Pctile = calcPercentile(cnsData.fg3Pct, pools?.fg3Pct || [], true);
    const openPctile = calcPercentile(cnsData.open3Pct, pools?.fg3Pct || [], true);
    const guardedPctile = calcPercentile(cnsData.guarded3Pct, pools?.fg3Pct || [], true);
    
    return e('div', { className: 'section span-6' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'C&S SHOOTING'),
            e(PossBadge, { pct: cnsData.attemptsPer100, label: '3PA/100' })
        ),
        
        e('div', { className: 'stat-grid compact', style: { marginBottom: '12px' } },
            e(StatCard, { label: '3PA/G', value: cnsData.attemptsPerGame, format: 'dec' }),
            e(StatCard, { label: '3PT%', value: cnsData.fg3Pct, format: 'pct', percentile: fg3Pctile }),
            e(StatCard, { label: 'OPEN 3PT%', value: cnsData.open3Pct, format: 'pct', percentile: openPctile }),
            e(StatCard, { label: 'GUARD 3PT%', value: cnsData.guarded3Pct, format: 'pct', percentile: guardedPctile })
        ),
        
        // Open vs Guarded distribution bar
        e(Subsection, { title: ' Shot Contest Distribution' },
            e(HorizBarChart, { 
                data: [
                    { label: 'Open', value: cnsData.openAttempts, color: 'emerald', subValue: fmtPct(cnsData.open3Pct) },
                    { label: 'Guarded', value: cnsData.guardedAttempts, color: 'rose', subValue: fmtPct(cnsData.guarded3Pct) }
                ],
                height: 24
            })
        ),
        
        // Spacing Value with breakdown
        e(Subsection, { title: ' Spacing Value' },
            e('div', { 
                style: { 
                    display: 'flex', 
                    alignItems: 'center', 
                    gap: '12px',
                    marginBottom: '12px'
                }
            },
                e('div', { 
                    style: { 
                        fontSize: '2rem', 
                        fontFamily: 'JetBrains Mono',
                        fontWeight: 800,
                        color: cnsData.spacingValue >= 70 ? 'var(--pct-elite-text)' : 
                               cnsData.spacingValue >= 50 ? 'var(--pct-good-text)' :
                               cnsData.spacingValue >= 30 ? 'var(--pct-avg-text)' : 'var(--pct-poor-text)'
                    }
                }, Math.round(cnsData.spacingValue)),
                e('div', { style: { fontSize: '0.75rem', color: 'var(--text-muted)' } }, '/ 100')
            ),
            cnsData.spacingBreakdown && e('div', { 
                style: { 
                    display: 'grid', 
                    gridTemplateColumns: 'repeat(2, 1fr)', 
                    gap: '6px',
                    fontSize: '0.7rem'
                }
            },
                e('div', { style: { display: 'flex', justifyContent: 'space-between', padding: '4px 8px', background: 'rgba(0,0,0,0.2)', borderRadius: '4px' } },
                    e('span', { style: { color: 'var(--text-muted)' } }, 'Volume'),
                    e('span', { style: { fontFamily: 'JetBrains Mono', fontWeight: 600 } }, fmt(cnsData.spacingBreakdown.volume, 1))
                ),
                e('div', { style: { display: 'flex', justifyContent: 'space-between', padding: '4px 8px', background: 'rgba(0,0,0,0.2)', borderRadius: '4px' } },
                    e('span', { style: { color: 'var(--text-muted)' } }, 'Accuracy'),
                    e('span', { style: { fontFamily: 'JetBrains Mono', fontWeight: 600 } }, fmt(cnsData.spacingBreakdown.accuracy, 1))
                ),
                e('div', { style: { display: 'flex', justifyContent: 'space-between', padding: '4px 8px', background: 'rgba(0,0,0,0.2)', borderRadius: '4px' } },
                    e('span', { style: { color: 'var(--text-muted)' } }, 'Gravity'),
                    e('span', { style: { fontFamily: 'JetBrains Mono', fontWeight: 600 } }, fmt(cnsData.spacingBreakdown.gravity, 1))
                ),
                e('div', { style: { display: 'flex', justifyContent: 'space-between', padding: '4px 8px', background: 'rgba(0,0,0,0.2)', borderRadius: '4px' } },
                    e('span', { style: { color: 'var(--text-muted)' } }, 'Pressure'),
                    e('span', { style: { fontFamily: 'JetBrains Mono', fontWeight: 600 } }, fmt(cnsData.spacingBreakdown.pressure, 1))
                ),
                cnsData.spacingBreakdown.volumePenalty > 0 && e('div', { 
                    style: { 
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        padding: '4px 8px', 
                        background: 'rgba(248, 113, 113, 0.15)', 
                        borderRadius: '4px',
                        gridColumn: 'span 2'
                    } 
                },
                    e('span', { style: { color: 'var(--pct-poor-text)' } }, ' Low Volume Penalty'),
                    e('span', { style: { fontFamily: 'JetBrains Mono', fontWeight: 600, color: 'var(--pct-poor-text)' } }, '-' + fmt(cnsData.spacingBreakdown.volumePenalty, 1))
                )
            )
        )
    );
}

// P&R Ball Handler Section
function PnRBHSection({ pnrData, pools }) {
    // Including passes stats
    const incPppPct = calcPercentile(pnrData.including.ppp, pools?.ppp || [], true);
    const incEfgPct = calcPercentile(pnrData.including.efg, pools?.efg || [], true);
    const incToPctile = calcPercentile(pnrData.including.toPct, pools?.toPct || [], false);
    
    // Direct scoring stats
    const scorePppPct = calcPercentile(pnrData.scoring.ppp, pools?.ppp || [], true);
    const scoreEfgPct = calcPercentile(pnrData.scoring.efg, pools?.efg || [], true);
    const scoreToPctile = calcPercentile(pnrData.scoring.toPct, pools?.toPct || [], false);
    
    // Shot type percentiles
    const rimPppPct = calcPercentile(pnrData.shotTypes.rim.ppp, pools?.ppp || [], true);
    const midPppPct = calcPercentile(pnrData.shotTypes.midRange.ppp, pools?.ppp || [], true);
    const pull3PppPct = calcPercentile(pnrData.shotTypes.pullUp3.ppp, pools?.ppp || [], true);
    
    return e('div', { className: 'section span-12' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'P&R BALL HANDLER'),
            e(PossBadge, { pct: pnrData.including.possPer100 })
        ),
        
        // P&R Including Passes (overall)
        e(Subsection, { title: ' Including Passes' },
            e('div', { className: 'stat-grid', style: { marginBottom: '12px' } },
                e(StatCard, { label: 'PPP', value: pnrData.including.ppp, format: 'ppp', percentile: incPppPct }),
                e(StatCard, { label: 'eFG%', value: pnrData.including.efg, format: 'pct', percentile: incEfgPct }),
                e(StatCard, { label: 'TO%', value: pnrData.including.toPct, format: 'pct', percentile: incToPctile }),
                e(StatCard, { label: 'PASS %', value: pnrData.passPct, format: 'pct' }),
                e(StatCard, { label: 'POSS/G', value: pnrData.including.possPerGame, format: 'dec' }),
                e(StatCard, { label: 'PRESSURE TO%', value: pnrData.pressureToPct, format: 'pct', sub: 'vs Traps/Commits' })
            )
        ),
        
        // Direct P&R Scoring
        e(Subsection, { title: ' Direct Scoring (excl. passes)' },
            e('div', { className: 'stat-grid', style: { marginBottom: '12px' } },
                e(StatCard, { label: 'PPP', value: pnrData.scoring.ppp, format: 'ppp', percentile: scorePppPct }),
                e(StatCard, { label: 'eFG%', value: pnrData.scoring.efg, format: 'pct', percentile: scoreEfgPct }),
                e(StatCard, { label: 'TO%', value: pnrData.scoring.toPct, format: 'pct', percentile: scoreToPctile }),
                e(StatCard, { label: 'FT RATE', value: pnrData.scoring.ftRate, format: 'pct' }),
                e(StatCard, { label: 'POSS/G', value: pnrData.scoring.possPerGame, format: 'dec' }),
                e(StatCard, { label: 'PTS/G', value: pnrData.scoring.ptsPerGame, format: 'dec' })
            )
        ),
        
        e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginTop: '16px' } },
            // Screen Location with visual bar
            e(Subsection, { title: ' Screen Location' },
                e(HorizBarChart, { 
                    data: [
                        { label: 'High', value: pnrData.locations.high.poss, color: 'indigo', subValue: `${Math.round(pnrData.locations.high.poss)} poss` },
                        { label: 'Right', value: pnrData.locations.right.poss, color: 'blue', subValue: `${Math.round(pnrData.locations.right.poss)} poss` },
                        { label: 'Left', value: pnrData.locations.left.poss, color: 'rose', subValue: `${Math.round(pnrData.locations.left.poss)} poss` }
                    ],
                    height: 28
                })
            ),
            
            // Shot Types with visual bar
            e(Subsection, { title: ' Shot Distribution' },
                e(HorizBarChart, { 
                    data: [
                        { label: 'Rim', value: pnrData.shotTypes.rim.poss, color: 'emerald', subValue: fmtPpp(pnrData.shotTypes.rim.ppp) + ' PPP' },
                        { label: 'Mid', value: pnrData.shotTypes.midRange.poss, color: 'amber', subValue: fmtPct(pnrData.shotTypes.midRange.fg2Pct) + ' FG' },
                        { label: '3PT', value: pnrData.shotTypes.pullUp3.poss, color: 'violet', subValue: fmtPct(pnrData.shotTypes.pullUp3.fg3Pct) + ' 3PT' }
                    ],
                    height: 28
                })
            )
        ),
        
        // Shot Type Efficiency bars
        e(Subsection, { title: ' Shot Type Efficiency (PPP)' },
            e(VertBarChart, {
                data: [
                    { label: 'Rim Attacks', value: pnrData.shotTypes.rim.ppp, color: 'emerald', format: 'ppp', percentile: rimPppPct },
                    { label: 'Mid-Range', value: pnrData.shotTypes.midRange.ppp, color: 'amber', format: 'ppp', percentile: midPppPct },
                    { label: 'Pull-Up 3', value: pnrData.shotTypes.pullUp3.ppp, color: 'violet', format: 'ppp', percentile: pull3PppPct }
                ],
                maxHeight: 80
            })
        ),
        
        // Screen Usage with visual bar
        e(Subsection, { title: ' Screen Usage' },
            e(HorizBarChart, { 
                data: [
                    { label: 'Uses Screen', value: pnrData.screenUsage.usesScreen, color: 'cyan' },
                    { label: 'Rejects', value: pnrData.screenUsage.rejectsScreen, color: 'orange' }
                ],
                height: 24
            })
        )
    );
}

// Spot Up Section
function SpotUpSection({ spotUpData, pools }) {
    if (!spotUpData || !spotUpData.main) {
        return e('div', { className: 'section span-6' },
            e('div', { className: 'section-header' },
                e('span', { className: 'section-icon' }, ''),
                e('span', { className: 'section-title' }, 'SPOT UP')
            ),
            e(EmptyState, { text: 'No Spot Up data' })
        );
    }
    
    const cnsPppPct = calcPercentile(spotUpData.cns?.ppp, pools?.ppp || [], true);
    const drivesPppPct = calcPercentile(spotUpData.drivesLeft?.ppp, pools?.ppp || [], true);
    
    return e('div', { className: 'section span-6' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'SPOT UP'),
            e(PossBadge, { pct: spotUpData.main?.possPer100 || 0 })
        ),
        
        // C&S vs Drives distribution bar
        e(Subsection, { title: ' Action Type' },
            e(HorizBarChart, { 
                data: [
                    { label: 'Catch & Shoot', value: spotUpData.cnsPct, color: 'blue' },
                    { label: 'Drives', value: spotUpData.drivePct, color: 'orange' }
                ],
                height: 24
            })
        ),
        
        // Stats grid
        e('div', { className: 'stat-grid compact', style: { marginTop: '12px', marginBottom: '16px' } },
            e(StatCard, { label: 'C&S PPP', value: spotUpData.cns?.ppp, format: 'ppp', percentile: cnsPppPct }),
            e(StatCard, { label: 'C&S eFG%', value: spotUpData.cns?.efg, format: 'pct' }),
            e(StatCard, { label: 'DRIVE PPP', value: spotUpData.drivesLeft?.ppp || spotUpData.drivesRight?.ppp, format: 'ppp', percentile: drivesPppPct }),
            e(StatCard, { label: 'DRIVE TO%', value: spotUpData.drivesLeft?.toPct || spotUpData.drivesRight?.toPct, format: 'pct' })
        ),
        
        e(HandVisualization, {
            leftData: {
                pct: spotUpData.drivesLeft?.pct || 0,
                ppp: spotUpData.drivesLeft?.ppp || 0,
                efg: spotUpData.drivesLeft?.efg || 0,
                toPct: spotUpData.drivesLeft?.toPct || 0,
                shotTypes: spotUpData.drivesLeft?.shotTypes
            },
            rightData: {
                pct: spotUpData.drivesRight?.pct || 0,
                ppp: spotUpData.drivesRight?.ppp || 0,
                efg: spotUpData.drivesRight?.efg || 0,
                toPct: spotUpData.drivesRight?.toPct || 0,
                shotTypes: spotUpData.drivesRight?.shotTypes
            },
            title: ' Drive Direction (% of drives)',
            pools
        })
    );
}

// P&R Roll Man Section
function RollManSection({ rollManData, pools }) {
    if (!rollManData || rollManData.main.poss === 0) {
        return e('div', { className: 'section span-6' },
            e('div', { className: 'section-header' },
                e('span', { className: 'section-icon' }, ''),
                e('span', { className: 'section-title' }, 'P&R ROLL MAN')
            ),
            e(EmptyState, { text: 'No Roll Man data' })
        );
    }
    
    const pppPct = calcPercentile(rollManData.main.ppp, pools?.ppp || [], true);
    const efgPct = calcPercentile(rollManData.main.efg, pools?.efg || [], true);
    
    return e('div', { className: 'section span-6' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'P&R ROLL MAN'),
            e(PossBadge, { pct: rollManData.main.possPer100 || 0 })
        ),
        
        e('div', { className: 'stat-grid compact', style: { marginBottom: '16px' } },
            e(StatCard, { label: 'PPP', value: rollManData.main.ppp, format: 'ppp', percentile: pppPct }),
            e(StatCard, { label: 'eFG%', value: rollManData.main.efg, format: 'pct', percentile: efgPct }),
            e(StatCard, { label: 'TO%', value: rollManData.main.toPct, format: 'pct' }),
            e(StatCard, { label: 'FT RATE', value: rollManData.main.ftRate, format: 'pct' })
        ),
        
        // Roll Type Distribution Bar
        e(Subsection, { title: ' Roll Type Distribution' },
            e(HorizBarChart, { 
                data: [
                    { label: 'Pop', value: rollManData.pickAndPop?.poss || 0, color: 'violet', subValue: fmtPpp(rollManData.pickAndPop?.ppp || 0) + ' PPP' },
                    { label: 'Slip', value: rollManData.slip?.poss || 0, color: 'cyan', subValue: fmtPpp(rollManData.slip?.ppp || 0) + ' PPP' },
                    { label: 'Roll', value: rollManData.roll?.poss || 0, color: 'emerald', subValue: fmtPpp(rollManData.roll?.ppp || 0) + ' PPP' }
                ],
                height: 28
            })
        ),
        
        e(RollManTypes, { data: rollManData, pools })
    );
}

// Off Screen Section
function OffScreenSection({ offScreenData, pools }) {
    if (!offScreenData || offScreenData.main.poss === 0) {
        return e('div', { className: 'section span-6' },
            e('div', { className: 'section-header' },
                e('span', { className: 'section-icon' }, ''),
                e('span', { className: 'section-title' }, 'OFF SCREEN')
            ),
            e(EmptyState, { text: 'No Off Screen data' })
        );
    }
    
    const pppPct = calcPercentile(offScreenData.main.ppp, pools?.ppp || [], true);
    const efgPct = calcPercentile(offScreenData.main.efg, pools?.efg || [], true);
    
    return e('div', { className: 'section span-6' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'OFF SCREEN'),
            e(PossBadge, { pct: offScreenData.main.possPer100 || 0 })
        ),
        
        e('div', { className: 'stat-grid compact', style: { marginBottom: '16px' } },
            e(StatCard, { label: 'PPP', value: offScreenData.main.ppp, format: 'ppp', percentile: pppPct }),
            e(StatCard, { label: 'eFG%', value: offScreenData.main.efg, format: 'pct', percentile: efgPct }),
            e(StatCard, { label: 'TO%', value: offScreenData.main.toPct, format: 'pct' }),
            e(StatCard, { label: 'FT RATE', value: offScreenData.main.ftRate, format: 'pct' })
        ),
        
        // Direction Distribution Bar
        e(Subsection, { title: ' Screen Direction' },
            e(HorizBarChart, { 
                data: [
                    { label: 'Left', value: offScreenData.left?.poss || 0, color: 'rose', subValue: fmtPpp(offScreenData.left?.ppp || 0) + ' PPP' },
                    { label: 'Right', value: offScreenData.right?.poss || 0, color: 'blue', subValue: fmtPpp(offScreenData.right?.ppp || 0) + ' PPP' }
                ],
                height: 24
            })
        ),
        
        e('div', { className: 'split-container', style: { marginTop: '12px' } },
            e(OffScreenDirectionCard, { data: offScreenData.left, direction: 'left', pools }),
            e(OffScreenDirectionCard, { data: offScreenData.right, direction: 'right', pools })
        )
    );
}

// Post Up Section
function PostUpSection({ postUpData, pools }) {
    if (!postUpData || (postUpData.main.poss === 0 && postUpData.including.poss === 0)) {
        return e('div', { className: 'section span-6' },
            e('div', { className: 'section-header' },
                e('span', { className: 'section-icon' }, ''),
                e('span', { className: 'section-title' }, 'POST-UP')
            ),
            e(EmptyState, { text: 'No Post-Up data' })
        );
    }
    
    const pppPct = calcPercentile(postUpData.main.ppp, pools?.ppp || [], true);
    const efgPct = calcPercentile(postUpData.main.efg, pools?.efg || [], true);
    
    return e('div', { className: 'section span-6' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'POST-UP'),
            e(PossBadge, { pct: postUpData.main.possPer100 || 0 })
        ),
        
        e('div', { className: 'stat-grid compact', style: { marginBottom: '16px' } },
            e(StatCard, { label: 'PPP', value: postUpData.main.ppp, format: 'ppp', percentile: pppPct }),
            e(StatCard, { label: 'PPP (INC)', value: postUpData.including.ppp, format: 'ppp' }),
            e(StatCard, { label: 'eFG%', value: postUpData.main.efg, format: 'pct', percentile: efgPct }),
            e(StatCard, { label: 'PASS %', value: postUpData.passPct, format: 'pct' }),
            e(StatCard, { label: 'TO%', value: postUpData.main.toPct, format: 'pct' }),
            e(StatCard, { label: 'PRESSURE TO%', value: postUpData.pressureToPct, format: 'pct' })
        ),
        
        // Block Location Distribution
        e(Subsection, { title: ' Block Location' },
            e(HorizBarChart, { 
                data: [
                    { label: 'Left Block', value: postUpData.leftBlock?.poss || 0, color: 'rose', subValue: fmtPpp(postUpData.leftBlock?.ppp || 0) + ' PPP' },
                    { label: 'Right Block', value: postUpData.rightBlock?.poss || 0, color: 'blue', subValue: fmtPpp(postUpData.rightBlock?.ppp || 0) + ' PPP' }
                ],
                height: 24
            }),
            e('div', { className: 'post-blocks', style: { marginTop: '12px' } },
                e(PostBlockCard, { data: postUpData.leftBlock, side: 'left', pools }),
                e(PostBlockCard, { data: postUpData.rightBlock, side: 'right', pools })
            )
        ),
        
        e(Subsection, { title: ' Move Effectiveness (All Blocks)' },
            e(PostMoveTable, { moves: postUpData.overallMoves, pools })
        )
    );
}

// Isolation Section
function IsolationSection({ isoData, pools }) {
    if (!isoData || isoData.main.poss === 0) {
        return e('div', { className: 'section span-6' },
            e('div', { className: 'section-header' },
                e('span', { className: 'section-icon' }, ''),
                e('span', { className: 'section-title' }, 'ISOLATION')
            ),
            e(EmptyState, { text: 'No Isolation data' })
        );
    }
    
    const pppPct = calcPercentile(isoData.main.ppp, pools?.ppp || [], true);
    const efgPct = calcPercentile(isoData.main.efg, pools?.efg || [], true);
    const toPctile = calcPercentile(isoData.main.toPct, pools?.toPct || [], false);
    
    return e('div', { className: 'section span-6' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'ISOLATION'),
            e(PossBadge, { pct: isoData.main.possPer100 || 0 })
        ),
        
        e('div', { className: 'stat-grid compact', style: { marginBottom: '16px' } },
            e(StatCard, { label: 'POSS/100', value: isoData.main.possPer100, format: 'dec3' }),
            e(StatCard, { label: 'PPP', value: isoData.main.ppp, format: 'ppp', percentile: pppPct }),
            e(StatCard, { label: 'eFG%', value: isoData.main.efg, format: 'pct', percentile: efgPct }),
            e(StatCard, { label: 'TO%', value: isoData.main.toPct, format: 'pct' }),
            e(StatCard, { label: 'DRIVE %', value: isoData.drivePct, format: 'pct' }),
            e(StatCard, { label: 'JUMPER %', value: isoData.jumperPct, format: 'pct' })
        ),
        
        e(HandVisualization, {
            leftData: {
                pct: isoData.drivesLeft.pct,
                ppp: isoData.drivesLeft.ppp,
                efg: isoData.drivesLeft.efg,
                toPct: isoData.drivesLeft.toPct
            },
            rightData: {
                pct: isoData.drivesRight.pct,
                ppp: isoData.drivesRight.ppp,
                efg: isoData.drivesRight.efg,
                toPct: isoData.drivesRight.toPct
            },
            title: ' Drive Direction',
            pools
        })
    );
}

// Slashing Section
function SlashingSection({ slashingData, pools, matchedPoss }) {
    const pppPct = calcPercentile(slashingData.overall.ppp, pools?.ppp || [], true);
    const efgPct = calcPercentile(slashingData.overall.efg, pools?.efg || [], true);
    
    // Calculate per75 helper
    const calcPer75 = (poss) => {
        if (!matchedPoss || !matchedPoss.totalPlayerMin || !matchedPoss.totalTeamMin || !matchedPoss.totalTeamPoss) {
            return null;
        }
        return (poss * 75 * matchedPoss.totalTeamMin) / (matchedPoss.totalPlayerMin * matchedPoss.totalTeamPoss);
    };
    
    const leftPer75 = calcPer75(slashingData.left.poss);
    const rightPer75 = calcPer75(slashingData.right.poss);
    
    return e('div', { className: 'section span-6' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'SLASHING (OVERALL DRIVES)')
        ),
        
        e('div', { className: 'stat-grid compact', style: { marginBottom: '16px' } },
            e(StatCard, { label: 'DRIVES/100', value: slashingData.overall.drivesPer100, format: 'dec3' }),
            e(StatCard, { label: 'DRIVES/G', value: slashingData.overall.drivesPerGame, format: 'dec' }),
            e(StatCard, { label: 'PPP', value: slashingData.overall.ppp, format: 'ppp', percentile: pppPct }),
            e(StatCard, { label: 'eFG%', value: slashingData.overall.efg, format: 'pct', percentile: efgPct }),
            e(StatCard, { label: 'TO%', value: slashingData.overall.toPct, format: 'pct' }),
            e(StatCard, { label: 'FT RATE', value: slashingData.overall.ftRate, format: 'pct' })
        ),
        
        e(HandVisualization, {
            leftData: {
                pct: slashingData.left.pct,
                ppp: slashingData.left.ppp,
                efg: slashingData.left.efg,
                toPct: slashingData.left.toPct,
                shotTypes: slashingData.left.shotTypes,
                per75: leftPer75
            },
            rightData: {
                pct: slashingData.right.pct,
                ppp: slashingData.right.ppp,
                efg: slashingData.right.efg,
                toPct: slashingData.right.toPct,
                shotTypes: slashingData.right.shotTypes,
                per75: rightPer75
            },
            title: ' Drive Direction',
            pools
        }),
        
        slashingData.straight.poss > 0 && e('div', { 
            style: { 
                marginTop: '12px', 
                textAlign: 'center', 
                padding: '12px', 
                background: 'rgba(0,0,0,0.2)', 
                borderRadius: '10px' 
            } 
        },
            e('div', { style: { fontSize: '0.65rem', color: 'var(--text-muted)', marginBottom: '4px' } }, 'STRAIGHT DRIVES'),
            e('div', { style: { fontSize: '1.2rem', fontWeight: '700' } }, fmtPct(slashingData.straight.pct)),
            e('div', { className: 'mini-stats', style: { justifyContent: 'center', marginTop: '6px' } },
                e('div', { className: 'mini-stat' },
                    e('span', { className: 'mini-stat-label' }, 'PPP:'),
                    e('span', { className: 'mini-stat-value' }, fmtPpp(slashingData.straight.ppp))
                )
            )
        )
    );
}



// Possession Sunburst Component - Zoomable D3 Visualization with Player/Season Filtering
function PossessionSunburst({ offenseData, selectedPlayer, availableSeasons }) {
    const containerRef = React.useRef(null);
    const zoomRef = React.useRef(null);
    const svgRef = React.useRef(null);
    const [hoveredData, setHoveredData] = React.useState(null);
    const [sunburstSeasons, setSunburstSeasons] = React.useState([]);
    const [currentZoom, setCurrentZoom] = React.useState(100);
    
    // Initialize seasons when availableSeasons changes
    React.useEffect(() => {
        if (availableSeasons && availableSeasons.length > 0 && sunburstSeasons.length === 0) {
            setSunburstSeasons([...availableSeasons]);
        }
    }, [availableSeasons]);
    
    const toggleSeason = (season) => {
        setSunburstSeasons(prev => prev.includes(season) ? prev.filter(s => s !== season) : [...prev, season]);
    };
    
    const filteredData = React.useMemo(() => {
        if (!offenseData || !selectedPlayer) return [];
        return offenseData.filter(row => {
            const matchesPlayer = row['Player Name'] === selectedPlayer;
            const matchesSeason = sunburstSeasons.length === 0 || sunburstSeasons.includes(row['Season']);
            return matchesPlayer && matchesSeason;
        });
    }, [offenseData, selectedPlayer, sunburstSeasons]);
    
    // Zoom control functions
    const handleZoomIn = () => {
        if (svgRef.current && zoomRef.current) {
            d3.select(svgRef.current).transition().duration(300).call(zoomRef.current.scaleBy, 1.3);
        }
    };
    
    const handleZoomOut = () => {
        if (svgRef.current && zoomRef.current) {
            d3.select(svgRef.current).transition().duration(300).call(zoomRef.current.scaleBy, 0.7);
        }
    };
    
    const handleResetZoom = () => {
        if (svgRef.current && zoomRef.current) {
            d3.select(svgRef.current).transition().duration(500).call(zoomRef.current.transform, d3.zoomIdentity);
        }
    };
    
    React.useEffect(() => {
        if (!filteredData || filteredData.length === 0 || !containerRef.current) return;
        
        const buildHierarchy = () => {
            const root = { name: 'Possessions', children: [] };
            const sub1Map = new Map();
            
            filteredData.forEach(row => {
                const poss = parseFloat(row['POSS']) || 0;
                const ppp = parseFloat(row['PPP']) || 0;
                const pts = parseFloat(row['PTS']) || 0;
                const fgPct = row['FG%'] ? parseFloat(row['FG%'].replace('%', '')) : null;
                const toPct = row['TO%'] ? parseFloat(row['TO%'].replace('%', '')) : null;
                const sub1 = row['Sub Category 1'];
                const sub2 = row['Sub Category 2'];
                const sub3 = row['Sub Category 3'];
                const sub4 = row['Sub Category 4'];
                const sub5 = row['Sub Category 5'];
                
                if (poss <= 0 || sub1 === 'N/A') return;
                
                const isLevel1 = sub2 === 'N/A';
                const isLevel2 = sub2 !== 'N/A' && sub3 === 'N/A';
                const isLevel3 = sub3 !== 'N/A' && sub4 === 'N/A';
                const isLevel4 = sub4 !== 'N/A' && sub5 === 'N/A';
                const isLevel5 = sub5 !== 'N/A';
                
                const ensureNode = (map, key) => {
                    if (!map.has(key)) {
                        map.set(key, { name: key, poss: 0, ppp: 0, pts: 0, fgPct: null, toPct: null, children: new Map() });
                    }
                    return map.get(key);
                };
                
                const sub1Node = ensureNode(sub1Map, sub1);
                
                if (isLevel1) {
                    sub1Node.poss = poss; sub1Node.ppp = ppp; sub1Node.pts = pts; sub1Node.fgPct = fgPct; sub1Node.toPct = toPct;
                } else if (isLevel2) {
                    const sub2Node = ensureNode(sub1Node.children, sub2);
                    sub2Node.poss = poss; sub2Node.ppp = ppp; sub2Node.pts = pts; sub2Node.fgPct = fgPct; sub2Node.toPct = toPct;
                } else if (isLevel3) {
                    const sub2Node = ensureNode(sub1Node.children, sub2);
                    const sub3Node = ensureNode(sub2Node.children, sub3);
                    sub3Node.poss = poss; sub3Node.ppp = ppp; sub3Node.pts = pts; sub3Node.fgPct = fgPct; sub3Node.toPct = toPct;
                } else if (isLevel4) {
                    const sub2Node = ensureNode(sub1Node.children, sub2);
                    const sub3Node = ensureNode(sub2Node.children, sub3);
                    const sub4Node = ensureNode(sub3Node.children, sub4);
                    sub4Node.poss = poss; sub4Node.ppp = ppp; sub4Node.pts = pts; sub4Node.fgPct = fgPct; sub4Node.toPct = toPct;
                } else if (isLevel5) {
                    const sub2Node = ensureNode(sub1Node.children, sub2);
                    const sub3Node = ensureNode(sub2Node.children, sub3);
                    const sub4Node = ensureNode(sub3Node.children, sub4);
                    const sub5Node = ensureNode(sub4Node.children, sub5);
                    sub5Node.poss = poss; sub5Node.ppp = ppp; sub5Node.pts = pts; sub5Node.fgPct = fgPct; sub5Node.toPct = toPct;
                }
            });
            
            const convertToArray = (node) => {
                if (node.children && node.children.size > 0) {
                    const childrenArray = Array.from(node.children.values()).map(convertToArray).sort((a, b) => (b.value || b.poss || 0) - (a.value || a.poss || 0));
                    let aggPoss = 0, aggPts = 0, aggFgm = 0, aggFga = 0;
                    childrenArray.forEach(c => {
                        const cPoss = c.value || c.poss || 0;
                        const cPts = c.pts || 0;
                        aggPoss += cPoss; aggPts += cPts;
                        if (c.fgPct !== null && cPoss > 0) { aggFga += cPoss * 0.8; aggFgm += (c.fgPct / 100) * cPoss * 0.8; }
                    });
                    return {
                        name: node.name, poss: node.poss || aggPoss, ppp: node.ppp || (aggPoss > 0 ? aggPts / aggPoss : 0),
                        pts: node.pts || aggPts, fgPct: node.fgPct !== null ? node.fgPct : (aggFga > 0 ? (aggFgm / aggFga) * 100 : null),
                        toPct: node.toPct, children: childrenArray
                    };
                } else {
                    return { name: node.name, value: node.poss, ppp: node.ppp, pts: node.pts, fgPct: node.fgPct, toPct: node.toPct };
                }
            };
            
            root.children = Array.from(sub1Map.values()).filter(n => n.poss > 0 || n.children.size > 0).map(convertToArray).sort((a, b) => (b.value || b.poss || 0) - (a.value || a.poss || 0));
            return root;
        };
        
        const data = buildHierarchy();
        containerRef.current.innerHTML = '';
        
        const size = Math.min(window.innerWidth - 350, window.innerHeight - 100, 1000);
        const width = size, height = size, radius = width / 6;
        
        const color = d3.scaleOrdinal().domain(data.children.map(d => d.name)).range([
            '#818cf8', '#f472b6', '#22d3ee', '#fb923c', '#facc15', '#34d399', '#a78bfa', '#f87171', '#84cc16', '#06b6d4',
            '#ec4899', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444', '#14b8a6', '#6366f1', '#e879f9', '#38bdf8', '#fbbf24'
        ]);
        
        // Function to adjust color based on depth and percentage of parent
        const getAdjustedColor = (d) => {
            // Get base color from root ancestor
            let node = d;
            while (node.depth > 1) node = node.parent;
            const baseColor = color(node.data.name);
            
            // Parse the base color to HSL
            const hex = baseColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16) / 255;
            const g = parseInt(hex.substr(2, 2), 16) / 255;
            const b = parseInt(hex.substr(4, 2), 16) / 255;
            
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const diff = max - min;
                s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);
                switch (max) {
                    case r: h = ((g - b) / diff + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / diff + 2) / 6; break;
                    case b: h = ((r - g) / diff + 4) / 6; break;
                }
            }
            
            // Calculate percentage of parent (for saturation)
            let pctOfParent = 1;
            if (d.parent && d.parent.value > 0) {
                pctOfParent = d.value / d.parent.value;
            }
            
            // INVERTED: Adjust lightness based on depth (DARKER at center, LIGHTER further out)
            // depth 1 = darkest (0.35), depth 5 = lightest (0.65)
            const depthFactor = Math.min(d.depth, 5);
            const baseLightness = 0.30 + (depthFactor - 1) * 0.10; // 0.30 -> 0.70
            
            // ENHANCED: Adjust saturation based on percentage (higher % = MUCH more saturated)
            // Very strong difference: low % = 0.3 saturation, high % = 1.0 saturation
            const satMultiplier = 0.25 + (pctOfParent * 0.75); // Range 0.25 to 1.0
            const adjustedSat = Math.min(s * satMultiplier * 1.5, 1); // Boost saturation more
            
            // Final lightness - outer rings lighter, also slightly boosted by high percentage
            const adjustedLight = Math.max(0.25, Math.min(0.75, baseLightness + (pctOfParent * 0.05)));
            
            // Convert back to RGB
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            
            let rOut, gOut, bOut;
            if (adjustedSat === 0) {
                rOut = gOut = bOut = adjustedLight;
            } else {
                const q = adjustedLight < 0.5 ? adjustedLight * (1 + adjustedSat) : adjustedLight + adjustedSat - adjustedLight * adjustedSat;
                const p = 2 * adjustedLight - q;
                rOut = hue2rgb(p, q, h + 1/3);
                gOut = hue2rgb(p, q, h);
                bOut = hue2rgb(p, q, h - 1/3);
            }
            
            const toHex = (c) => {
                const hex = Math.round(c * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            
            return `#${toHex(rOut)}${toHex(gOut)}${toHex(bOut)}`;
        };
        
        const hierarchy = d3.hierarchy(data).sum(d => d.value || 0).sort((a, b) => b.value - a.value);
        const root = d3.partition().size([2 * Math.PI, hierarchy.height + 1])(hierarchy);
        root.each(d => d.current = d);
        
        // Calculate the outer radius of the chart (depth 4 or max visible)
        const maxDepth = 4;
        const outerRadius = maxDepth * radius;
        
        const arc = d3.arc().startAngle(d => d.x0).endAngle(d => d.x1).padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.003))
            .padRadius(radius * 0.5).innerRadius(d => d.y0 * radius).outerRadius(d => Math.max(d.y0 * radius, d.y1 * radius - 1));
        
        // Create SVG with larger viewBox for zoom headroom
        const svg = d3.create('svg')
            .attr('viewBox', [-width, -height, width * 2, height * 2])
            .style('font', '11px Sora, sans-serif')
            .style('width', '100%')
            .style('height', '100%')
            .style('cursor', 'grab')
            .style('background', 'transparent');
        
        svgRef.current = svg.node();
        
        // Create defs for clipPath
        const defs = svg.append('defs');
        
        // Circular clip path to hide anything outside the chart boundary
        defs.append('clipPath')
            .attr('id', 'chart-clip')
            .append('circle')
            .attr('cx', 0)
            .attr('cy', 0)
            .attr('r', outerRadius + 2);
        
        // Create a container group for all chart elements that will be zoomed/panned
        const chartGroup = svg.append('g').attr('class', 'chart-content');
        
        // Clipped group for arcs (hides lines extending beyond chart)
        const clippedGroup = chartGroup.append('g')
            .attr('clip-path', 'url(#chart-clip)');
        
        // D3 Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.5, 4])
            .on('zoom', (event) => {
                chartGroup.attr('transform', event.transform);
                setCurrentZoom(Math.round(event.transform.k * 100));
            })
            .on('start', () => svg.style('cursor', 'grabbing'))
            .on('end', () => svg.style('cursor', 'grab'));
        
        zoomRef.current = zoom;
        svg.call(zoom);
        
        // Add arcs to clipped group
        const path = clippedGroup.append('g')
            .selectAll('path')
            .data(root.descendants().slice(1))
            .join('path')
            .attr('fill', d => getAdjustedColor(d))
            .attr('fill-opacity', d => arcVisible(d.current) ? 0.95 : 0)
            .attr('pointer-events', d => arcVisible(d.current) ? 'auto' : 'none')
            .attr('d', d => arc(d.current))
            .style('cursor', 'pointer')
            .style('transition', 'fill-opacity 0.15s, stroke 0.15s')
            .attr('stroke', 'rgba(0,0,0,0.4)')
            .attr('stroke-width', 0.5);
        
        // Add outer border ring
        chartGroup.append('circle')
            .attr('cx', 0)
            .attr('cy', 0)
            .attr('r', outerRadius)
            .attr('fill', 'none')
            .attr('stroke', 'rgba(0,0,0,0.6)')
            .attr('stroke-width', 3);
        
        path.on('mouseenter', function(event, d) {
            d3.select(this).attr('fill-opacity', 1).attr('stroke', '#ffffff').attr('stroke-width', 1.5);
            const ancestors = d.ancestors().map(a => a.data.name).reverse().slice(1);
            setHoveredData({
                name: d.data.name, path: ancestors, poss: d.value, ppp: d.data.ppp, pts: d.data.pts, fgPct: d.data.fgPct, toPct: d.data.toPct,
                color: color(d.ancestors().find(a => a.depth === 1)?.data.name || d.data.name), x: event.clientX, y: event.clientY
            });
        }).on('mousemove', function(event) {
            setHoveredData(prev => prev ? { ...prev, x: event.clientX, y: event.clientY } : null);
        }).on('mouseleave', function(event, d) {
            d3.select(this).attr('fill-opacity', arcVisible(d.current) ? 0.95 : 0).attr('stroke', 'rgba(0,0,0,0.4)').attr('stroke-width', 0.5);
            setHoveredData(null);
        });
        
        path.on('click', clicked);
        
        // Add labels to chart group
        const label = chartGroup.append('g')
            .attr('pointer-events', 'none')
            .attr('text-anchor', 'middle')
            .style('user-select', 'none')
            .selectAll('text')
            .data(root.descendants().slice(1))
            .join('text')
            .attr('dy', '0.35em')
            .attr('fill', '#ffffff')
            .attr('font-weight', '500')
            .attr('fill-opacity', d => +labelVisible(d.current))
            .attr('transform', d => labelTransform(d.current))
            .text(d => d.data.name.length > 14 ? d.data.name.slice(0, 14) + '' : d.data.name);
        
        // Add center circle to chart group
        const parent = chartGroup.append('circle')
            .datum(root)
            .attr('r', radius)
            .attr('fill', 'rgba(10, 12, 16, 0.95)')
            .attr('stroke', 'rgba(255, 255, 255, 0.2)')
            .attr('stroke-width', 2)
            .attr('pointer-events', 'all')
            .style('cursor', 'pointer')
            .on('click', clicked);
        
        // Add center text to chart group
        const centerGroup = chartGroup.append('g').attr('pointer-events', 'none');
        const centerText = centerGroup.append('text').attr('text-anchor', 'middle').attr('fill', '#ffffff').attr('font-size', '16px').attr('font-weight', '700').attr('dy', '-0.3em').text('POSSESSIONS');
        const centerSubtext = centerGroup.append('text').attr('text-anchor', 'middle').attr('fill', 'rgba(255, 255, 255, 0.5)').attr('font-size', '12px').attr('dy', '1.3em').text('Click to zoom');
        
        function clicked(event, p) {
            // Stop zoom from triggering
            event.stopPropagation();
            
            parent.datum(p.parent || root);
            centerText.text(p.data.name === 'Possessions' ? 'POSSESSIONS' : (p.data.name.length > 16 ? p.data.name.slice(0, 16) + '' : p.data.name.toUpperCase()));
            centerSubtext.text(p.data.name === 'Possessions' ? 'Click to zoom' : (p.parent ? ' Back' : 'Click to zoom'));
            root.each(d => d.target = {
                x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                y0: Math.max(0, d.y0 - p.depth), y1: Math.max(0, d.y1 - p.depth)
            });
            const t = chartGroup.transition().duration(event && event.altKey ? 2500 : 750);
            path.transition(t).tween('data', d => { const i = d3.interpolate(d.current, d.target); return t => d.current = i(t); })
                .filter(function(d) { return +this.getAttribute('fill-opacity') || arcVisible(d.target); })
                .attr('fill-opacity', d => arcVisible(d.target) ? 0.95 : 0)
                .attr('pointer-events', d => arcVisible(d.target) ? 'auto' : 'none').attrTween('d', d => () => arc(d.current));
            label.filter(function(d) { return +this.getAttribute('fill-opacity') || labelVisible(d.target); }).transition(t)
                .attr('fill-opacity', d => +labelVisible(d.target)).attrTween('transform', d => () => labelTransform(d.current));
        }
        
        function arcVisible(d) { return d.y1 <= 4 && d.y0 >= 1 && d.x1 > d.x0; }
        function labelVisible(d) { return d.y1 <= 4 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.025; }
        function labelTransform(d) { const x = (d.x0 + d.x1) / 2 * 180 / Math.PI; const y = (d.y0 + d.y1) / 2 * radius; return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`; }
        
        containerRef.current.appendChild(svg.node());
    }, [filteredData]);
    
    const playerSeasons = React.useMemo(() => {
        if (!offenseData || !selectedPlayer) return [];
        return [...new Set(offenseData.filter(row => row['Player Name'] === selectedPlayer).map(row => row['Season']))].filter(Boolean).sort();
    }, [offenseData, selectedPlayer]);
    
    if (!offenseData || offenseData.length === 0) {
        return e('div', { style: { display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', minHeight: 'calc(100vh - 100px)', color: 'var(--text-muted)' } },
            e('div', { style: { fontSize: '64px', marginBottom: '20px' } }, ''),
            e('h2', { style: { color: 'var(--text-primary)', marginBottom: '12px', fontSize: '24px' } }, 'No Offense Data'),
            e('p', { style: { fontSize: '14px' } }, 'Upload offense data to view the possession breakdown.'));
    }
    
    if (!selectedPlayer) {
        return e('div', { style: { display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', minHeight: 'calc(100vh - 100px)', color: 'var(--text-muted)' } },
            e('div', { style: { fontSize: '64px', marginBottom: '20px' } }, ''),
            e('h2', { style: { color: 'var(--text-primary)', marginBottom: '12px', fontSize: '24px' } }, 'Select a Player'),
            e('p', { style: { fontSize: '14px' } }, 'Choose a player from the dropdown to view their possession breakdown.'));
    }
    
    if (filteredData.length === 0) {
        return e('div', { style: { display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', minHeight: 'calc(100vh - 100px)', color: 'var(--text-muted)' } },
            e('div', { style: { fontSize: '64px', marginBottom: '20px' } }, ''),
            e('h2', { style: { color: 'var(--text-primary)', marginBottom: '12px', fontSize: '24px' } }, 'No Data for Selection'),
            e('p', { style: { fontSize: '14px' } }, 'No possession data found for the selected player and seasons.'));
    }
    
    const getPPPColor = (ppp) => {
        if (ppp === null || ppp === undefined) return '#666';
        if (ppp >= 1.15) return '#22c55e'; if (ppp >= 1.0) return '#84cc16'; if (ppp >= 0.9) return '#fbbf24'; if (ppp >= 0.8) return '#fb923c'; return '#ef4444';
    };
    
    return e('div', { style: { display: 'flex', flexDirection: 'row', width: '100%', minHeight: 'calc(100vh - 140px)', position: 'relative' } },
        // Left sidebar - Season selector
        e('div', { style: { width: '280px', padding: '20px', borderRight: '1px solid rgba(255,255,255,0.1)', background: 'rgba(0,0,0,0.2)', overflowY: 'auto', flexShrink: 0 } },
            e('h3', { style: { fontSize: '14px', fontWeight: '700', color: '#fff', marginBottom: '16px', letterSpacing: '1px' } }, ' SEASONS'),
            e('div', { style: { display: 'flex', flexDirection: 'column', gap: '8px' } },
                playerSeasons.map(season => e('label', { key: season, style: { display: 'flex', alignItems: 'center', gap: '10px', padding: '10px 12px', background: sunburstSeasons.includes(season) ? 'rgba(99, 102, 241, 0.3)' : 'rgba(255,255,255,0.05)', borderRadius: '8px', cursor: 'pointer', border: sunburstSeasons.includes(season) ? '1px solid rgba(99, 102, 241, 0.5)' : '1px solid transparent', transition: 'all 0.2s' } },
                    e('input', { type: 'checkbox', checked: sunburstSeasons.includes(season), onChange: () => toggleSeason(season), style: { width: '16px', height: '16px', accentColor: '#818cf8' } }),
                    e('span', { style: { fontSize: '12px', color: sunburstSeasons.includes(season) ? '#fff' : '#aaa', fontWeight: sunburstSeasons.includes(season) ? '600' : '400' } }, season)
                ))
            ),
            playerSeasons.length > 1 && e('div', { style: { marginTop: '16px', display: 'flex', gap: '8px' } },
                e('button', { onClick: () => setSunburstSeasons([...playerSeasons]), style: { flex: 1, padding: '8px', fontSize: '11px', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '6px', color: '#aaa', cursor: 'pointer' } }, 'Select All'),
                e('button', { onClick: () => setSunburstSeasons([]), style: { flex: 1, padding: '8px', fontSize: '11px', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '6px', color: '#aaa', cursor: 'pointer' } }, 'Clear All')
            ),
            e('div', { style: { marginTop: '30px', paddingTop: '20px', borderTop: '1px solid rgba(255,255,255,0.1)' } },
                e('h3', { style: { fontSize: '14px', fontWeight: '700', color: '#fff', marginBottom: '16px', letterSpacing: '1px' } }, ' VIEW'),
                e('div', { style: { display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '12px' } },
                    e('button', { onClick: handleZoomOut, style: { width: '36px', height: '36px', fontSize: '18px', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '8px', color: '#fff', cursor: 'pointer' } }, ''),
                    e('span', { style: { flex: 1, textAlign: 'center', fontSize: '13px', color: '#aaa' } }, currentZoom + '%'),
                    e('button', { onClick: handleZoomIn, style: { width: '36px', height: '36px', fontSize: '18px', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '8px', color: '#fff', cursor: 'pointer' } }, '+')
                ),
                e('button', { onClick: handleResetZoom, style: { width: '100%', padding: '10px', fontSize: '12px', background: 'rgba(255,255,255,0.1)', border: 'none', borderRadius: '6px', color: '#aaa', cursor: 'pointer' } }, 'Reset View'),
                e('p', { style: { fontSize: '10px', color: '#666', marginTop: '12px', lineHeight: '1.4' } }, 'Tip: Drag to pan. Scroll to zoom. Click segments to drill down.')
            )
        ),
        // Main chart area with bright sunny window scene
        e('div', { 
            style: { 
                flex: 1, 
                overflow: 'hidden', 
                display: 'flex', 
                alignItems: 'center', 
                justifyContent: 'center', 
                position: 'relative',
                // Bright sky/garden background
                background: 'linear-gradient(180deg, #87CEEB 0%, #98D8C8 40%, #7CB342 70%, #558B2F 100%)'
            } 
        },
            // Sun glow
            e('div', {
                style: {
                    position: 'absolute',
                    top: '-5%',
                    right: '15%',
                    width: '200px',
                    height: '200px',
                    background: 'radial-gradient(circle, rgba(255,248,220,1) 0%, rgba(255,236,179,0.8) 30%, rgba(255,223,128,0.4) 50%, transparent 70%)',
                    borderRadius: '50%',
                    filter: 'blur(10px)',
                    pointerEvents: 'none'
                }
            }),
            // Soft clouds
            e('div', {
                style: {
                    position: 'absolute',
                    top: '8%',
                    left: '10%',
                    width: '180px',
                    height: '60px',
                    background: 'radial-gradient(ellipse at 30% 50%, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.6) 40%, transparent 70%)',
                    borderRadius: '50%',
                    filter: 'blur(8px)',
                    pointerEvents: 'none'
                }
            }),
            e('div', {
                style: {
                    position: 'absolute',
                    top: '5%',
                    left: '25%',
                    width: '120px',
                    height: '45px',
                    background: 'radial-gradient(ellipse, rgba(255,255,255,0.7) 0%, transparent 70%)',
                    borderRadius: '50%',
                    filter: 'blur(6px)',
                    pointerEvents: 'none'
                }
            }),
            // Wooden table surface with 3D perspective
            e('div', {
                style: {
                    position: 'absolute',
                    width: '140%',
                    height: '55%',
                    bottom: '-5%',
                    left: '-20%',
                    background: `
                        linear-gradient(180deg, 
                            rgba(255,250,240,0.3) 0%,
                            rgba(255,250,240,0.1) 5%,
                            transparent 15%
                        ),
                        linear-gradient(180deg,
                            #8B7355 0%,
                            #7A6548 20%,
                            #6B5A3E 50%,
                            #5C4E35 100%
                        )
                    `,
                    transform: 'perspective(800px) rotateX(55deg)',
                    transformOrigin: 'center top',
                    borderRadius: '4px 4px 0 0',
                    boxShadow: `
                        inset 0 2px 4px rgba(255,255,255,0.3),
                        inset 0 -15px 40px rgba(0,0,0,0.2)
                    `
                }
            },
                // Table edge highlight
                e('div', {
                    style: {
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        height: '3px',
                        background: 'linear-gradient(90deg, transparent 5%, rgba(255,250,240,0.5) 20%, rgba(255,250,240,0.6) 50%, rgba(255,250,240,0.5) 80%, transparent 95%)',
                        borderRadius: '4px 4px 0 0'
                    }
                })
            ),
            // Sunlight reflection on table
            e('div', {
                style: {
                    position: 'absolute',
                    bottom: '25%',
                    right: '20%',
                    width: '300px',
                    height: '150px',
                    background: 'radial-gradient(ellipse, rgba(255,250,230,0.25) 0%, transparent 60%)',
                    transform: 'perspective(500px) rotateX(60deg)',
                    pointerEvents: 'none'
                }
            }),
            // Chart shadow on table (softer for bright scene)
            e('div', {
                style: {
                    position: 'absolute',
                    bottom: '12%',
                    left: '50%',
                    transform: 'translateX(-50%) perspective(500px) rotateX(60deg)',
                    width: '450px',
                    height: '450px',
                    background: 'radial-gradient(ellipse, rgba(0,0,0,0.25) 0%, rgba(0,0,0,0.15) 30%, transparent 55%)',
                    borderRadius: '50%',
                    filter: 'blur(15px)',
                    pointerEvents: 'none',
                    zIndex: 0
                }
            }),
            // Chart container with subtle lift and warm lighting
            e('div', { 
                ref: containerRef, 
                style: { 
                    width: '100%', 
                    height: '100%', 
                    maxWidth: '1000px', 
                    maxHeight: '1000px', 
                    position: 'relative', 
                    zIndex: 1,
                    filter: 'drop-shadow(0 6px 20px rgba(0,0,0,0.2)) drop-shadow(0 2px 6px rgba(0,0,0,0.15))'
                } 
            })
        ),
        // Tooltip
        hoveredData && e('div', { style: { position: 'fixed', left: Math.min(hoveredData.x + 20, window.innerWidth - 300), top: Math.max(hoveredData.y, 120), backgroundColor: '#0f1219', border: `2px solid ${hoveredData.color}`, borderRadius: '12px', padding: '16px 20px', pointerEvents: 'none', zIndex: 999999, minWidth: '240px', maxWidth: '340px', boxShadow: `0 12px 40px rgba(0,0,0,0.8), 0 0 30px ${hoveredData.color}55`, transform: 'translateY(-50%)' } },
            hoveredData.path.length > 1 && e('div', { style: { fontSize: '11px', color: '#888', marginBottom: '10px', display: 'flex', flexWrap: 'wrap', gap: '4px', alignItems: 'center' } },
                hoveredData.path.slice(0, -1).map((p, i) => e(React.Fragment, { key: i }, e('span', { style: { color: '#aaa' } }, p), e('span', { style: { color: hoveredData.color, margin: '0 3px' } }, '')))
            ),
            e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '14px' } },
                e('div', { style: { width: '16px', height: '16px', borderRadius: '4px', backgroundColor: hoveredData.color, boxShadow: `0 0 10px ${hoveredData.color}` } }),
                e('span', { style: { fontSize: '16px', fontWeight: '700', color: '#ffffff' } }, hoveredData.name)
            ),
            e('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '10px' } },
                e('div', { style: { backgroundColor: '#1a1d24', borderRadius: '8px', padding: '12px', textAlign: 'center' } },
                    e('div', { style: { fontSize: '10px', color: '#888', marginBottom: '4px', letterSpacing: '1px' } }, 'POSS'),
                    e('div', { style: { fontSize: '20px', fontWeight: '700', color: hoveredData.color, fontFamily: 'JetBrains Mono, monospace' } }, hoveredData.poss?.toLocaleString() || '-')
                ),
                e('div', { style: { backgroundColor: '#1a1d24', borderRadius: '8px', padding: '12px', textAlign: 'center' } },
                    e('div', { style: { fontSize: '10px', color: '#888', marginBottom: '4px', letterSpacing: '1px' } }, 'PPP'),
                    e('div', { style: { fontSize: '20px', fontWeight: '700', color: getPPPColor(hoveredData.ppp), fontFamily: 'JetBrains Mono, monospace' } }, hoveredData.ppp ? hoveredData.ppp.toFixed(2) : '-')
                ),
                e('div', { style: { backgroundColor: '#1a1d24', borderRadius: '8px', padding: '12px', textAlign: 'center' } },
                    e('div', { style: { fontSize: '10px', color: '#888', marginBottom: '4px', letterSpacing: '1px' } }, 'PTS'),
                    e('div', { style: { fontSize: '20px', fontWeight: '700', color: '#fbbf24', fontFamily: 'JetBrains Mono, monospace' } }, hoveredData.pts?.toLocaleString() || '-')
                ),
                e('div', { style: { backgroundColor: '#1a1d24', borderRadius: '8px', padding: '12px', textAlign: 'center' } },
                    e('div', { style: { fontSize: '10px', color: '#888', marginBottom: '4px', letterSpacing: '1px' } }, 'FG%'),
                    e('div', { style: { fontSize: '20px', fontWeight: '700', color: '#22d3ee', fontFamily: 'JetBrains Mono, monospace' } }, hoveredData.fgPct !== null && hoveredData.fgPct !== undefined ? hoveredData.fgPct.toFixed(0) + '%' : '-')
                )
            )
        )
    );
}

// Cuts & Putbacks Section
function CutsPutbacksSection({ playerData }) {
    const cutStats = playerData.playTypeStats['Cut'] || { poss: 0, pts: 0, pctOfPts: 0 };
    const putbackStats = playerData.playTypeStats['Offensive Rebounds (Put Backs)'] || { poss: 0, pts: 0, pctOfPts: 0 };
    
    return e('div', { className: 'section span-6' },
        e('div', { className: 'section-header' },
            e('span', { className: 'section-icon' }, ''),
            e('span', { className: 'section-title' }, 'CUTS & PUTBACKS')
        ),
        
        e('div', { className: 'split-container' },
            e('div', { className: 'split-card' },
                e('div', { style: { textAlign: 'center', padding: '16px 0' } },
                    e('div', { style: { fontSize: '0.7rem', color: 'var(--text-muted)', marginBottom: '4px' } }, ' CUTS'),
                    e('div', { style: { fontSize: '2rem', fontWeight: '800', color: 'var(--accent-emerald)' } }, 
                        fmtPct(cutStats.pctOfPts)),
                    e('div', { style: { fontSize: '0.65rem', color: 'var(--text-dim)' } }, 'of total points'),
                    cutStats.poss > 0 && e('div', { className: 'mini-stats', style: { justifyContent: 'center', marginTop: '8px' } },
                        e('div', { className: 'mini-stat' },
                            e('span', { className: 'mini-stat-label' }, 'PPP:'),
                            e('span', { className: 'mini-stat-value' }, fmtPpp(cutStats.ppp || 0))
                        ),
                        e('div', { className: 'mini-stat' },
                            e('span', { className: 'mini-stat-label' }, 'eFG:'),
                            e('span', { className: 'mini-stat-value' }, fmtPct(cutStats.efg || 0))
                        )
                    )
                )
            ),
            
            e('div', { className: 'split-card' },
                e('div', { style: { textAlign: 'center', padding: '16px 0' } },
                    e('div', { style: { fontSize: '0.7rem', color: 'var(--text-muted)', marginBottom: '4px' } }, ' PUTBACKS'),
                    e('div', { style: { fontSize: '2rem', fontWeight: '800', color: 'var(--accent-violet)' } }, 
                        fmtPct(putbackStats.pctOfPts)),
                    e('div', { style: { fontSize: '0.65rem', color: 'var(--text-dim)' } }, 'of total points'),
                    putbackStats.poss > 0 && e('div', { className: 'mini-stats', style: { justifyContent: 'center', marginTop: '8px' } },
                        e('div', { className: 'mini-stat' },
                            e('span', { className: 'mini-stat-label' }, 'PPP:'),
                            e('span', { className: 'mini-stat-value' }, fmtPpp(putbackStats.ppp || 0))
                        ),
                        e('div', { className: 'mini-stat' },
                            e('span', { className: 'mini-stat-label' }, 'eFG:'),
                            e('span', { className: 'mini-stat-value' }, fmtPct(putbackStats.efg || 0))
                        )
                    )
                )
            )
        )
    );
}

console.log('Part 4 loaded successfully - Section Components ready');

// ============================================
// OFFENSIVE ROLE CLASSIFICATION SYSTEM
// ============================================

// Minimum possessions required for role classification
const MIN_POSS_FOR_ROLE = 50;

// Role definitions with priority order (first match wins)
// Uses involvement-based metrics (ballHandlingIncl, postIncl use Including Passes; others use direct but same denominator)
const ROLE_DEFINITIONS = [
    {
        id: 'primary_handler',
        name: 'Primary Ball Handler',
        description: 'Primary initiator - high P&R/ISO usage (55% ball handling)',
        check: (dist) => dist.ballHandlingIncl >= 55
    },
    {
        id: 'post_big',
        name: 'Post-Up Big',
        description: 'Post-focused big man (35% post-ups)',
        check: (dist) => dist.postIncl >= 35
    },
    {
        id: 'secondary_handler',
        name: 'Secondary Ball Handler',
        description: 'Secondary initiator (45% ball handling)',
        check: (dist) => dist.ballHandlingIncl >= 45
    },
    {
        id: 'tertiary_wing',
        name: 'Tertiary Wing',
        description: 'Ball handler with secondary creation (25-45% ball handling)',
        check: (dist) => dist.ballHandlingIncl >= 25 && dist.ballHandlingIncl < 45
    },
    {
        id: 'rim_big',
        name: 'Rim Finishing Big',
        description: 'Roll man and cutter - rim finisher (30% rim finishing, <15% spot up, <20% post)',
        check: (dist) => dist.rimFinishingInv >= 30 && dist.spotUpInv < 15 && dist.postIncl < 20
    },
    {
        id: 'stretch_big',
        name: 'Stretch Big',
        description: 'Spacing big with roll/post presence (10% spot up, 8% roll man, 12% post)',
        check: (dist) => dist.spotUpInv >= 10 && dist.rollManInv >= 8 && dist.postIncl >= 12 && dist.ballHandlingIncl < 25
    },
    {
        id: 'spot_wing',
        name: 'Spot-Up Wing',
        description: 'Perimeter spacer - catch and shoot focus (35% spot up, limited other usage)',
        check: (dist) => dist.spotUpInv >= 35 && dist.postIncl < 15 && dist.rollManInv < 15 && dist.ballHandlingIncl < 25
    },
    {
        id: 'slashing_wing',
        name: 'Slashing Wing',
        description: 'Cutting and transition focused (18% cutting, limited shooting)',
        check: (dist) => dist.cuttingInv >= 18 && dist.spotUpInv < 25 && dist.ballHandlingIncl < 25
    },
    {
        id: 'traditional_big',
        name: 'Traditional Big',
        description: 'Post and roll man balance (15% post, 15% roll man)',
        check: (dist) => dist.postIncl >= 15 && dist.rollManInv >= 15
    },
    {
        id: 'versatile_forward',
        name: 'Versatile Forward',
        description: 'Balanced offensive profile',
        check: (dist) => true // Default fallback
    }
];

// Calculate play type distribution percentages for a player
function calculatePlayTypeDistribution(rawRows, totalPoss) {
    if (!rawRows || rawRows.length === 0 || totalPoss <= 0) {
        return null;
    }
    
    // Helper to sum possessions for play types (main rows only - all Sub Categories = N/A)
    const sumMainPoss = (playTypes) => {
        let total = 0;
        playTypes.forEach(pt => {
            rawRows.forEach(row => {
                const rowPT = row['Play Type'];
                if (rowPT === pt && isMainPlayType(row)) {
                    total += parseNum(row['POSS'] || row['Poss']);
                }
            });
        });
        return total;
    };
    
    // Direct play types
    const pnrBHPoss = sumMainPoss(['P&R Ball Handler']);
    const isoPoss = sumMainPoss(['Isolation']);
    const postUpPoss = sumMainPoss(['Post-Up']);
    const spotUpPoss = sumMainPoss(['Spot Up']);
    const rollManPoss = sumMainPoss(['P&R Roll Man']);
    const cutPoss = sumMainPoss(['Cut']);
    const transPoss = sumMainPoss(['Transition']);
    const handOffPoss = sumMainPoss(['Handoffs', 'Hand Off']);
    const offScreenPoss = sumMainPoss(['Off Screen']);
    const orebPoss = sumMainPoss(['Offensive Rebounds (Put Backs)']);
    const miscPoss = sumMainPoss(['Miscellaneous Plays']);
    
    // "Including Passes" variants (only these 3 exist)
    const pnrInclPoss = sumMainPoss(['P&R Including Passes']);
    const isoInclPoss = sumMainPoss(['ISO Including Passes']);
    const postInclPoss = sumMainPoss(['Post-Ups Including Passes']);
    
    // Calculate "total involvement" - replaces direct P&R/ISO/Post with Including Passes versions
    // This gives a proper denominator for role classification
    const totalInvolvement = pnrInclPoss + isoInclPoss + postInclPoss + 
                             spotUpPoss + rollManPoss + cutPoss + transPoss + 
                             handOffPoss + offScreenPoss + orebPoss + miscPoss;
    
    // Calculate percentages
    return {
        // Direct play type percentages (based on totalPoss - these add up to ~100%)
        ballHandling: ((pnrBHPoss + isoPoss) / totalPoss) * 100,
        pnrBH: (pnrBHPoss / totalPoss) * 100,
        isolation: (isoPoss / totalPoss) * 100,
        postUp: (postUpPoss / totalPoss) * 100,
        spotUp: (spotUpPoss / totalPoss) * 100,
        rollMan: (rollManPoss / totalPoss) * 100,
        cutting: (cutPoss / totalPoss) * 100,
        transition: (transPoss / totalPoss) * 100,
        handOff: (handOffPoss / totalPoss) * 100,
        offScreen: (offScreenPoss / totalPoss) * 100,
        oreb: (orebPoss / totalPoss) * 100,
        
        // Derived categories (direct)
        rimFinishing: ((rollManPoss + cutPoss) / totalPoss) * 100,
        offBall: ((spotUpPoss + cutPoss + offScreenPoss + handOffPoss) / totalPoss) * 100,
        
        // Involvement-based percentages for ROLE CLASSIFICATION ONLY
        // Uses totalInvolvement as denominator so these add up to ~100%
        ballHandlingIncl: totalInvolvement > 0 ? ((pnrInclPoss + isoInclPoss) / totalInvolvement) * 100 : 0,
        postIncl: totalInvolvement > 0 ? (postInclPoss / totalInvolvement) * 100 : 0,
        spotUpInv: totalInvolvement > 0 ? (spotUpPoss / totalInvolvement) * 100 : 0,
        rollManInv: totalInvolvement > 0 ? (rollManPoss / totalInvolvement) * 100 : 0,
        cuttingInv: totalInvolvement > 0 ? (cutPoss / totalInvolvement) * 100 : 0,
        rimFinishingInv: totalInvolvement > 0 ? ((rollManPoss + cutPoss) / totalInvolvement) * 100 : 0,
        
        totalPoss,
        totalInvolvement
    };
}

// Classify a player into a role based on their play type distribution
function classifyPlayerRole(distribution) {
    if (!distribution || distribution.totalPoss < MIN_POSS_FOR_ROLE) {
        return { id: 'unknown', name: 'Insufficient Data', description: 'Not enough possessions' };
    }
    
    for (const role of ROLE_DEFINITIONS) {
        if (role.check(distribution)) {
            return { id: role.id, name: role.name, description: role.description };
        }
    }
    
    // Should never reach here due to versatile_forward fallback
    return ROLE_DEFINITIONS[ROLE_DEFINITIONS.length - 1];
}

// Build role-based pools from all offense data
function buildRoleBasedPools(offenseData) {
    if (!offenseData || offenseData.length === 0) return {};
    
    // Group data by player + season
    const playerSeasons = {};
    offenseData.forEach(row => {
        const player = row['Player Name'];
        const season = row['Season'];
        const team = row['Team'];
        const playType = row['Play Type'];
        if (!player || !season) return;
        
        const key = `${player}|${season}|${team}`;
        if (!playerSeasons[key]) {
            playerSeasons[key] = {
                player,
                season,
                team,
                rows: [],
                totalPoss: 0
            };
        }
        playerSeasons[key].rows.push(row);
        
        // Only count possessions from MAIN_PLAY_TYPES (not Including Passes, Overall, etc.)
        if (isMainPlayType(row) && MAIN_PLAY_TYPES.includes(playType)) {
            playerSeasons[key].totalPoss += parseNum(row['POSS'] || row['Poss']);
        }
    });
    
    // Classify each player-season and build role pools
    const rolePools = {};
    ROLE_DEFINITIONS.forEach(role => {
        rolePools[role.id] = {
            name: role.name,
            players: [],
            metrics: {} // Will store arrays of metric values for percentile calculation
        };
    });
    
    Object.values(playerSeasons).forEach(ps => {
        if (ps.totalPoss < MIN_POSS_FOR_ROLE) return;
        
        const dist = calculatePlayTypeDistribution(ps.rows, ps.totalPoss);
        const role = classifyPlayerRole(dist);
        
        if (rolePools[role.id]) {
            rolePools[role.id].players.push({
                player: ps.player,
                season: ps.season,
                team: ps.team,
                totalPoss: ps.totalPoss,
                distribution: dist
            });
        }
    });
    
    return rolePools;
}

// Calculate percentile within a role pool
function calculateRolePercentile(value, rolePool, metricKey, inverse = false) {
    if (!rolePool || !rolePool.metrics || !rolePool.metrics[metricKey]) {
        return null;
    }
    
    const values = rolePool.metrics[metricKey].filter(v => v !== null && v !== undefined && !isNaN(v));
    if (values.length < 3) return null; // Need at least 3 players for meaningful percentile
    
    const sorted = [...values].sort((a, b) => inverse ? b - a : a - b);
    const rank = sorted.filter(v => inverse ? v > value : v < value).length;
    return (rank / sorted.length) * 100;
}

// Calculate dynamic radar scales from population data
// Uses 95th percentile for max values, with role-specific data if available (10+ players)
function calculateRadarScales(allRadarMetrics, roleRadarMetrics = null, minRoleSamples = 10) {
    // Use role-specific data if we have enough samples, otherwise use all players
    const metricsToUse = (roleRadarMetrics && roleRadarMetrics.length >= minRoleSamples) 
        ? roleRadarMetrics 
        : allRadarMetrics;
    
    if (!metricsToUse || metricsToUse.length === 0) return null;
    
    // Helper to calculate percentile value from array
    const getPercentile = (arr, p) => {
        const sorted = [...arr].sort((a, b) => a - b);
        if (sorted.length === 0) return 0;
        const index = Math.ceil((p / 100) * sorted.length) - 1;
        return sorted[Math.max(0, Math.min(index, sorted.length - 1))];
    };
    
    // Helper to calculate mean and std dev
    const getStats = (arr) => {
        if (arr.length === 0) return { mean: 0, std: 0 };
        const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
        const variance = arr.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / arr.length;
        return { mean, std: Math.sqrt(variance) };
    };
    
    // All metric keys for radar chart
    const metricKeys = [
        'totalPPP', 'tsPct', 'ftRate', 'usagePct', 'onBallVol75', 'onBallPPP',
        'shootingValue', 'rimPressure', 'fg3Att75', 'rimToMidRatio',
        'onBallPassPct', 'astUsgRatio', 'toPct',
        'spacingVol75', 'spacingPPP',
        'drives75', 'drivesPPP', 'finishingVol75', 'finishingPPP',
        'onBallDef75', 'onBallDefPPP', 'postDef75', 'postDefPPP', 'defTOPct',
        'stl75', 'blk75', 'oreb75', 'dreb75'
    ];
    
    const scales = {};
    
    metricKeys.forEach(key => {
        // Filter out null, undefined, NaN, and zero values (except for metrics where 0 is valid)
        const zeroValidMetrics = ['toPct', 'onBallDefPPP', 'postDefPPP']; // Metrics where 0 could be valid
        const values = metricsToUse
            .map(m => m[key])
            .filter(v => v !== null && v !== undefined && !isNaN(v) && (zeroValidMetrics.includes(key) || v > 0));
        
        // Need at least 5 data points for meaningful scale
        if (values.length < 5) {
            return; // Will use default scale
        }
        
        // Use 95th percentile as max, with some padding
        const p95 = getPercentile(values, 95);
        const stats = getStats(values);
        
        // Choose the larger of: 95th percentile or mean + 2*std
        const statMax = stats.mean + (2 * stats.std);
        const dynamicMax = Math.max(p95, statMax);
        
        // Round to nice numbers for cleaner display
        let roundedMax;
        if (dynamicMax <= 0) {
            return; // Invalid, use default
        } else if (dynamicMax < 1) {
            roundedMax = Math.ceil(dynamicMax * 20) / 20; // Round to nearest 0.05
        } else if (dynamicMax < 5) {
            roundedMax = Math.ceil(dynamicMax * 10) / 10; // Round to nearest 0.1
        } else if (dynamicMax < 20) {
            roundedMax = Math.ceil(dynamicMax); // Round to nearest 1
        } else if (dynamicMax < 100) {
            roundedMax = Math.ceil(dynamicMax / 5) * 5; // Round to nearest 5
        } else {
            roundedMax = Math.ceil(dynamicMax / 10) * 10; // Round to nearest 10
        }
        
        scales[key] = {
            max: roundedMax,
            p50: getPercentile(values, 50),
            p25: getPercentile(values, 25),
            p75: getPercentile(values, 75),
            sampleSize: values.length
        };
    });
    
    return scales;
}

// Calculate radar metrics for all players (for scale calculation)
// Uses all available data sources: offense, defense, utilities
function calculateAllPlayersRadarMetrics(offenseData, defenseData, teamUtilitiesData, playerUtilitiesData, selectedSeasons) {
    if (!offenseData.length) return { allRadarMetrics: [], roleGroupedMetrics: {} };
    
    // Helper to parse minutes
    const parseMinutes = (minStr) => {
        if (!minStr) return 0;
        let str = String(minStr).trim().replace(/^['"]/, '');
        if (str.includes(':')) {
            const parts = str.split(':');
            return parseFloat(parts[0]) + (parseFloat(parts[1] || 0) / 60);
        }
        return parseFloat(str) || 0;
    };
    
    // Helper to normalize dates
    const normalizeDate = (dateStr) => {
        if (!dateStr) return '';
        const str = String(dateStr).trim();
        const datePart = str.split(' ')[0];
        const parts = datePart.split('/');
        if (parts.length !== 3) return str;
        return `${parseInt(parts[0], 10)}/${parseInt(parts[1], 10)}/${parts[2]}`;
    };
    
    // Helper to get season year
    const getSeasonYear = (season) => {
        if (!season) return '';
        return season.split(' ')[0];
    };
    
    // Build player utilities lookup: player -> season year -> date -> data
    const playerUtilsLookup = {};
    playerUtilitiesData.forEach(row => {
        const player = row['Player Name'];
        const season = row['Season'];
        const seasonYear = getSeasonYear(season);
        const date = normalizeDate(row['DATE'] || row['Date']);
        if (!player || !date) return;
        
        if (!playerUtilsLookup[player]) playerUtilsLookup[player] = {};
        if (!playerUtilsLookup[player][seasonYear]) playerUtilsLookup[player][seasonYear] = {};
        
        playerUtilsLookup[player][seasonYear][date] = {
            poss: parseNum(row['POSS'] || row['Poss']),
            min: parseMinutes(row['MIN']),
            fgAtt: parseNum(row['FG ATT']),
            fgMade: parseNum(row['FG MADE']),
            ftAtt: parseNum(row['FT ATT']),
            stl: parseNum(row['STL']),
            blk: parseNum(row['BLK']),
            oreb: parseNum(row['OFF REB']),
            dreb: parseNum(row['DEF REB']),
            ast: parseNum(row['AST']),
            to: parseNum(row['TO']),
            pts: parseNum(row['PTS']),
            teamName: row['Team Name'] || row['Team'],
            season: season  // Store full season for fallback matching
        };
    });
    
    // Build team utilities lookups:
    // 1. Primary: team -> season year -> date -> data
    // 2. Fallback: full season -> date -> data (handles team name mismatches)
    const teamUtilsLookup = {};
    const seasonDateLookup = {};  // Fallback for team name mismatches
    
    teamUtilitiesData.forEach(row => {
        const team = row['Team Name'] || row['Team'];
        const season = row['Season'];
        const seasonYear = getSeasonYear(season);
        const date = normalizeDate(row['DATE'] || row['Date']);
        const gameNum = row['GAME #'];
        const poss = parseNum(row['POSS'] || row['Poss']);
        
        // Skip empty indicator rows
        if (!team || !date || (!gameNum && !poss)) return;
        
        const teamData = {
            poss: poss,
            fgAtt: parseNum(row['FG ATT']),
            fgMade: parseNum(row['FG MADE']),
            ftAtt: parseNum(row['FT ATT']),
            to: parseNum(row['TO'])
        };
        
        // Primary lookup: team -> seasonYear -> date
        if (!teamUtilsLookup[team]) teamUtilsLookup[team] = {};
        if (!teamUtilsLookup[team][seasonYear]) teamUtilsLookup[team][seasonYear] = {};
        if (!teamUtilsLookup[team][seasonYear][date]) {
            teamUtilsLookup[team][seasonYear][date] = teamData;
        }
        
        // Fallback lookup: full season -> date (for team name mismatches)
        if (!seasonDateLookup[season]) seasonDateLookup[season] = {};
        if (!seasonDateLookup[season][date]) {
            seasonDateLookup[season][date] = teamData;
        }
    });
    
    // Get unique players from offense data
    // Create SEPARATE entries for each player-season combination (not aggregated)
    // This allows filtering by season while showing all eligible player-season combos
    const playerSeasonMap = {};
    offenseData.forEach(row => {
        const player = row['Player Name'];
        const season = row['Season'];
        const team = row['Team'];
        
        if (!player || !season) return;
        
        const key = `${player}|${season}`;
        if (!playerSeasonMap[key]) {
            playerSeasonMap[key] = {
                player,
                team,
                season,
                rows: []
            };
        }
        playerSeasonMap[key].rows.push(row);
    });
    
    console.log(`Precompute: ${Object.keys(playerSeasonMap).length} unique player-season combinations in offense data`);
    
    // ============================================
    // DUPLICATE DATA DETECTION
    // Compares each player's seasons to find duplicates based on play type data
    // ============================================
    
    // Helper: Extract play type fingerprint from rows for comparison
    // Only uses main play type rows (N/A subcategories) for cleaner comparison
    const extractPlayTypeFingerprint = (rows) => {
        const fingerprint = {};
        rows.forEach(row => {
            const playType = row['Play Type'] || '';
            const subCat1 = row['Sub Category 1'] || 'N/A';
            const subCat2 = row['Sub Category 2'] || 'N/A';
            const subCat3 = row['Sub Category 3'] || 'N/A';
            
            // Only use main play type rows for fingerprint (all subcategories are N/A)
            // This gives cleaner comparison and catches the most obvious duplicates
            if (subCat1 === 'N/A' && subCat2 === 'N/A' && subCat3 === 'N/A') {
                const key = playType;
                
                fingerprint[key] = {
                    poss: parseNum(row['POSS']),
                    pts: parseNum(row['PTS']),
                    ppp: parseNum(row['PPP']),
                    fgAtt: parseNum(row['FG ATT']),
                    fgMade: parseNum(row['FG MADE']),
                    fg3Att: parseNum(row['3FG ATT']),
                    fg2Att: parseNum(row['2 FG ATT']),
                    toPct: parseNum(row['TO%'])
                };
            }
        });
        return fingerprint;
    };
    
    // Helper: Extract utilities fingerprint for a player-season
    const extractUtilitiesFingerprint = (player, season) => {
        const seasonYear = getSeasonYear(season);
        const utilsData = playerUtilsLookup[player]?.[seasonYear];
        if (!utilsData) return null;
        
        const fingerprint = {
            dates: [],
            totalMin: 0,
            totalPts: 0,
            totalPoss: 0
        };
        
        Object.entries(utilsData).forEach(([date, data]) => {
            fingerprint.dates.push(date);
            fingerprint.totalMin += data.min || 0;
            fingerprint.totalPts += data.pts || 0;
            fingerprint.totalPoss += data.poss || 0;
        });
        
        fingerprint.dates.sort();
        return fingerprint;
    };
    
    // Helper: Calculate similarity between two play type fingerprints (0-100%)
    const calculatePlayTypeSimilarity = (fp1, fp2) => {
        const allKeys = new Set([...Object.keys(fp1), ...Object.keys(fp2)]);
        if (allKeys.size === 0) return 0;
        
        let matchCount = 0;
        let totalComparisons = 0;
        
        allKeys.forEach(key => {
            const d1 = fp1[key];
            const d2 = fp2[key];
            
            if (d1 && d2) {
                // Both have this play type - compare values
                const fields = ['poss', 'pts', 'ppp', 'fgAtt', 'fgMade', 'fg3Att', 'fg2Att', 'toPct'];
                fields.forEach(field => {
                    const v1 = d1[field] || 0;
                    const v2 = d2[field] || 0;
                    totalComparisons++;
                    
                    // Consider match if values are EXACTLY equal or within 1% (for rounding)
                    if (v1 === v2) {
                        matchCount++;
                    } else if (v1 > 0 && v2 > 0) {
                        const ratio = Math.min(v1, v2) / Math.max(v1, v2);
                        if (ratio >= 0.99) matchCount++;
                    } else if (v1 === 0 && v2 === 0) {
                        matchCount++;
                    }
                });
            } else {
                // Only one has this play type - count as non-match
                totalComparisons += 8; // 8 fields now
            }
        });
        
        return totalComparisons > 0 ? (matchCount / totalComparisons) * 100 : 0;
    };
    
    // Helper: Calculate utilities similarity
    const calculateUtilitiesSimilarity = (uf1, uf2) => {
        if (!uf1 || !uf2) return { similar: false, reason: 'missing data' };
        
        // Compare dates
        const dates1 = new Set(uf1.dates);
        const dates2 = new Set(uf2.dates);
        const commonDates = [...dates1].filter(d => dates2.has(d));
        const dateOverlap = commonDates.length / Math.max(dates1.size, dates2.size);
        
        // Compare totals
        const minSimilar = uf1.totalMin > 0 && uf2.totalMin > 0 
            ? Math.min(uf1.totalMin, uf2.totalMin) / Math.max(uf1.totalMin, uf2.totalMin) >= 0.95
            : uf1.totalMin === uf2.totalMin;
        const ptsSimilar = uf1.totalPts > 0 && uf2.totalPts > 0
            ? Math.min(uf1.totalPts, uf2.totalPts) / Math.max(uf1.totalPts, uf2.totalPts) >= 0.95
            : uf1.totalPts === uf2.totalPts;
        
        return {
            similar: dateOverlap >= 0.8 && minSimilar && ptsSimilar,
            dateOverlap: (dateOverlap * 100).toFixed(1),
            minSimilar,
            ptsSimilar
        };
    };
    
    // Group player-seasons by player for duplicate comparison
    const playerGroups = {};
    Object.entries(playerSeasonMap).forEach(([key, data]) => {
        const { player } = data;
        if (!playerGroups[player]) playerGroups[player] = [];
        playerGroups[player].push({ key, ...data });
    });
    
    // Detect duplicates for each player
    const duplicateInfo = {}; // key -> { isDuplicate, duplicateOf, similarity, utilitiesDuplicate }
    let duplicateCount = 0;
    let utilitiesDuplicateCount = 0;
    let dupeDebugCounter = 0;
    
    Object.entries(playerGroups).forEach(([player, seasons]) => {
        if (seasons.length < 2) {
            // Only one season - no duplicates possible
            seasons.forEach(s => {
                duplicateInfo[s.key] = { isDuplicate: false, duplicateOf: null, similarity: 0, utilitiesDuplicate: false };
            });
            return;
        }
        
        // Extract fingerprints for all seasons
        const fingerprints = seasons.map(s => ({
            key: s.key,
            season: s.season,
            playType: extractPlayTypeFingerprint(s.rows),
            utilities: extractUtilitiesFingerprint(player, s.season),
            totalPoss: s.rows.filter(r => MAIN_PLAY_TYPES.includes(r['Play Type']) && isMainPlayType(r))
                           .reduce((sum, r) => sum + parseNum(r['POSS']), 0)
        }));
        
        // Sort by total possessions descending (keep the one with most data as "original")
        fingerprints.sort((a, b) => b.totalPoss - a.totalPoss);
        
        // Debug: Log seasons being compared for first player with multiple seasons
        if (seasons.length >= 2 && dupeDebugCounter <= 1) {
            console.log(`\nDuplicate check for ${player}:`);
            fingerprints.forEach((fp, i) => {
                const playTypeCount = Object.keys(fp.playType).length;
                console.log(`  ${i}: ${fp.season} (${fp.totalPoss} poss, ${playTypeCount} play types)`);
            });
        }
        
        // Compare each season against earlier (higher-poss) seasons
        fingerprints.forEach((fp, idx) => {
            duplicateInfo[fp.key] = { isDuplicate: false, duplicateOf: null, similarity: 0, utilitiesDuplicate: false };
            
            // Skip the first one (highest poss = original)
            if (idx === 0) return;
            
            // Check utilities duplicate (informational only)
            for (let i = 0; i < idx; i++) {
                const otherFp = fingerprints[i];
                
                const utilsSim = calculateUtilitiesSimilarity(fp.utilities, otherFp.utilities);
                if (utilsSim.similar) {
                    duplicateInfo[fp.key].utilitiesDuplicate = true;
                    duplicateInfo[fp.key].utilitiesDuplicateOf = otherFp.season;
                    break;
                }
            }
            
            // Check play type duplicate (determines exclusion)
            for (let i = 0; i < idx; i++) {
                const otherFp = fingerprints[i];
                
                const similarity = calculatePlayTypeSimilarity(fp.playType, otherFp.playType);
                
                // Debug: Log similarity for first few players
                if (seasons.length >= 2 && dupeDebugCounter <= 1) {
                    console.log(`  Comparing ${fp.season} vs ${otherFp.season}: ${similarity.toFixed(1)}% similar`);
                }
                
                if (similarity >= 95) {
                    // This is a duplicate - mark it
                    duplicateInfo[fp.key].isDuplicate = true;
                    duplicateInfo[fp.key].duplicateOf = otherFp.season;
                    duplicateInfo[fp.key].similarity = similarity;
                    duplicateCount++;
                    
                    console.log(`Duplicate detected: ${player} ${fp.season} is ${similarity.toFixed(1)}% similar to ${otherFp.season}`);
                    break;
                }
            }
            
            if (duplicateInfo[fp.key].utilitiesDuplicate && !duplicateInfo[fp.key].isDuplicate) {
                utilitiesDuplicateCount++;
                console.log(`Utilities duplicate (not excluded): ${player} ${fp.season} has similar utilities to ${duplicateInfo[fp.key].utilitiesDuplicateOf}`);
            }
        });
        
        dupeDebugCounter++;
    });
    
    // Summary of duplicate detection
    if (duplicateCount > 0 || utilitiesDuplicateCount > 0) {
        console.log('\n');
        console.log('            DUPLICATE DETECTION RESULTS                  ');
        console.log('');
        console.log(`  Play type duplicates (will be excluded): ${duplicateCount}`);
        console.log(`  Utilities-only duplicates (flagged only): ${utilitiesDuplicateCount}`);
        console.log('\n');
    } else {
        console.log('Duplicate detection complete: No duplicates found');
    }
    
    // ============================================
    // END DUPLICATE DETECTION
    // ============================================
    
    // Calculate radar metrics for each player-season combination
    const allRadarMetrics = [];
    const roleGroupedMetrics = {};
    
    ROLE_DEFINITIONS.forEach(role => {
        roleGroupedMetrics[role.id] = [];
    });
    
    // Track skip reasons for diagnostics
    let skippedNoData = 0;
    let skippedNoMinutes = 0;
    let includedCount = 0;
    let debugCounter = 0;
    
    Object.values(playerSeasonMap).forEach(pd => {
        const { player, team, season, rows } = pd;
        const playerSeasonKey = `${player}|${season}`;
        
        // Get duplicate info for this player-season
        const dupInfo = duplicateInfo[playerSeasonKey] || { isDuplicate: false, duplicateOf: null, similarity: 0, utilitiesDuplicate: false };
        
        // Calculate total possessions (used later for filtering)
        const mainRows = rows.filter(r => MAIN_PLAY_TYPES.includes(r['Play Type']) && isMainPlayType(r));
        const totalPoss = mainRows.reduce((sum, r) => sum + parseNum(r['POSS']), 0);
        
        // Build playerData structure for this season
        const playerData = aggregatePlayerData(rows, [], player);
        if (!playerData) {
            skippedNoData++;
            return;
        }
        
        // Get defense data for this player and season
        const defRows = defenseData.filter(r => 
            r['Player Name'] === player && r['Season'] === season
        );
        
        // Debug: Log defense data for first few players
        debugCounter++;
        if (debugCounter <= 3) {
            console.log(`Precompute player ${player} (${season}): defRows.length=${defRows.length}`);
        }
        
        // Get season year for utilities matching
        const seasonYear = season ? season.split(' ')[0] : '';
        
        // Calculate matched utilities data for this specific season
        let totalTeamPoss = 0, totalPlayerPoss = 0, totalPlayerMin = 0, totalTeamMin = 0;
        let totalStl = 0, totalBlk = 0, totalOreb = 0, totalDreb = 0, totalAst = 0, totalPlayerTo = 0;
        let totalPlayerFgAtt = 0, totalPlayerFgMade = 0, totalPlayerFtAtt = 0;
        let totalTeamFgAtt = 0, totalTeamFgMade = 0, totalTeamFtAtt = 0, totalTeamTo = 0;
        let matchedGames = 0;
        
        // Get utilities for this player and specific season
        const playerSeasonUtils = playerUtilsLookup[player]?.[seasonYear];
        if (playerSeasonUtils) {
            Object.entries(playerSeasonUtils).forEach(([date, pData]) => {
                // Find matching team data
                // Primary: Team Name + Season Year + Date
                const teamName = pData.teamName;
                let tData = teamUtilsLookup[teamName]?.[seasonYear]?.[date];
                
                // Fallback: Full Season + Date (handles team name mismatches)
                if (!tData && pData.season) {
                    tData = seasonDateLookup[pData.season]?.[date];
                }
                
                if (tData) {
                    totalTeamPoss += tData.poss;
                    totalPlayerPoss += pData.poss;
                    totalPlayerMin += pData.min;
                    totalTeamMin += 40;
                    
                    totalPlayerFgAtt += pData.fgAtt;
                    totalPlayerFgMade += pData.fgMade || 0;
                    totalPlayerFtAtt += pData.ftAtt;
                    totalPlayerTo += pData.to;
                    totalTeamFgAtt += tData.fgAtt;
                    totalTeamFgMade += tData.fgMade || 0;
                    totalTeamFtAtt += tData.ftAtt;
                    totalTeamTo += tData.to;
                    
                    totalStl += pData.stl;
                    totalBlk += pData.blk;
                    totalOreb += pData.oreb;
                    totalDreb += pData.dreb;
                    totalAst += pData.ast;
                    matchedGames++;
                }
            });
        }
        
        // Calculate usage%
        const playerPossEst = totalPlayerFgAtt + (0.44 * totalPlayerFtAtt) + totalPlayerTo;
        const teamPossEst = totalTeamFgAtt + (0.44 * totalTeamFtAtt) + totalTeamTo;
        const usagePct = (teamPossEst > 0 && totalPlayerMin > 0) 
            ? 100 * (playerPossEst * totalTeamMin) / (teamPossEst * totalPlayerMin)
            : null;
        
        // Calculate AST% = AST / (TeamFGMade - PlayerFGMade) * 100
        const teammatesFgMade = totalTeamFgMade - totalPlayerFgMade;
        const astPct = teammatesFgMade > 0 ? (totalAst / teammatesFgMade) * 100 : null;
        
        // Calculate TO% = TO / (FGA + 0.44*FTA + TO) * 100
        const toPctVal = playerPossEst > 0 ? (totalPlayerTo / playerPossEst) * 100 : null;
        
        // Per-75 helper - must match display calculation logic exactly
        // Check for data mismatch: if synergy poss significantly exceeds matched poss, use fallback
        // This matches the display's hasReliableMinutes check
        const matchedPossRatio = totalPlayerPoss > 0 ? totalPoss / totalPlayerPoss : 999;
        const hasReliableMinutes = totalPlayerMin > 0 && totalTeamMin > 0 && matchedPossRatio < 1.5;
        
        // Track players without reliable minutes but still include them with fallback calculation
        if (!hasReliableMinutes) {
            skippedNoMinutes++;
            // DON'T return - we'll use fallback per-75 calculation
        }
        
        includedCount++;
        
        // Per-75 calculation with fallback for players without utilities data
        const per75 = (value) => {
            if (hasReliableMinutes && totalTeamPoss > 0) {
                return (value * 75 * totalTeamMin) / (totalPlayerMin * totalTeamPoss);
            }
            // Fallback: estimate based on possessions (assumes ~75 poss per 75 possessions played)
            return totalPoss > 0 ? (value / totalPoss) * 75 : 0;
        };
        
        // Calculate offense metrics from Synergy
        const mainPlayTypeRows = rows.filter(row => 
            MAIN_PLAY_TYPES.includes(row['Play Type']) && isMainPlayType(row)
        );
        
        // On-ball volume
        const pnrBHRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'P&R Ball Handler');
        const isoRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Isolation');
        const postRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Post-Up');
        const onBallPoss = [...pnrBHRows, ...isoRows, ...postRows].reduce((s, r) => s + parseNum(r['POSS']), 0);
        const onBallPts = [...pnrBHRows, ...isoRows, ...postRows].reduce((s, r) => s + parseNum(r['PTS']), 0);
        
        // Spacing volume
        const spotUpRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Spot Up');
        const handoffRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Handoffs');
        const offScreenRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Off Screen');
        const spacingPoss = [...spotUpRows, ...handoffRows, ...offScreenRows].reduce((s, r) => s + parseNum(r['POSS']), 0);
        const spacingPts = [...spotUpRows, ...handoffRows, ...offScreenRows].reduce((s, r) => s + parseNum(r['PTS']), 0);
        
        // ===== SPACING RADAR PRECOMPUTATION =====
        // Spacing TO% and FT Rate
        const spacingTOs = [...spotUpRows, ...handoffRows, ...offScreenRows].reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0);
        const spacingFgAtt = [...spotUpRows, ...handoffRows, ...offScreenRows].reduce((s, r) => s + parseNum(r['FG ATT']), 0);
        const spacingFTAs = [...spotUpRows, ...handoffRows, ...offScreenRows].reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
        
        // Individual spacing play types
        const spotUpPoss = spotUpRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const spotUpPts = spotUpRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        const handoffsPoss = handoffRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const handoffsPts = handoffRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        const offScreenPoss = offScreenRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const offScreenPts = offScreenRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        
        // Spot Up C&S (No Dribble Jumper)
        const spotUpNoDribbleRows = rows.filter(r =>
            r['Play Type'] === 'Spot Up' &&
            isSubCategorySummary(r, 'No Dribble Jumper')
        );
        const spotUpCnSPoss = spotUpNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        
        // Spot Up Guarded vs Open (No Dribble Jumper)
        const spotUpGuardedRows = rows.filter(r =>
            r['Play Type'] === 'Spot Up' &&
            anySubCategory(r, 'No Dribble Jumper') &&
            isSubCategorySummary(r, 'Guarded')
        );
        const spotUpOpenRows = rows.filter(r =>
            r['Play Type'] === 'Spot Up' &&
            anySubCategory(r, 'No Dribble Jumper') &&
            isSubCategorySummary(r, 'Open')
        );
        const spGuarded3Att = spotUpGuardedRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0);
        const spGuarded3Made = spotUpGuardedRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
        const spOpen3Att = spotUpOpenRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0);
        const spOpen3Made = spotUpOpenRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
        const spGuarded3Pct = spGuarded3Att > 0 ? (spGuarded3Made / spGuarded3Att) * 100 : 0;
        const spOpen3Pct = spOpen3Att > 0 ? (spOpen3Made / spOpen3Att) * 100 : 0;
        const spTotal3Att = spGuarded3Att + spOpen3Att;
        const spGuardedPct = spTotal3Att > 0 ? (spGuarded3Att / spTotal3Att) * 100 : 0;
        const spAdjusted3Pct = (spOpen3Att > 0 || spGuarded3Att > 0) ? (0.5 * spOpen3Pct + 0.5 * spGuarded3Pct) : 0;
        
        // Moving shots (Handoffs + Off Screen No Dribble Jumper)
        const handoffsNoDribbleRows = rows.filter(r =>
            r['Play Type'] === 'Handoffs' &&
            isSubCategorySummary(r, 'No Dribble Jumper')
        );
        const offScreenNoDribbleRows = rows.filter(r =>
            r['Play Type'] === 'Off Screen' &&
            isSubCategorySummary(r, 'No Dribble Jumper')
        );
        const movingPoss = handoffsNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                          offScreenNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const movingPts = handoffsNoDribbleRows.reduce((s, r) => s + parseNum(r['PTS']), 0) +
                         offScreenNoDribbleRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        const moving3Att = handoffsNoDribbleRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0) +
                          offScreenNoDribbleRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0);
        const moving3Made = handoffsNoDribbleRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0) +
                           offScreenNoDribbleRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
        
        // Spot Up Drives
        const spotUpDrivesRows = rows.filter(r =>
            r['Play Type'] === 'Spot Up' &&
            (isSubCategorySummary(r, 'Drives Left') || 
             isSubCategorySummary(r, 'Drives Right') || 
             isSubCategorySummary(r, 'Drives Straight'))
        );
        const spotUpDrivesPoss = spotUpDrivesRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const spotUpDrivesPts = spotUpDrivesRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        const spotUpDrivesFgAtt = spotUpDrivesRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
        const spotUpDrivesFTAs = spotUpDrivesRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
        const spotUpDrivesTOs = spotUpDrivesRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0);
        const spotUpNoDribblePoss = spotUpNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const spotUpDrivePct = (spotUpDrivesPoss + spotUpNoDribblePoss) > 0 
            ? (spotUpDrivesPoss / (spotUpDrivesPoss + spotUpNoDribblePoss)) * 100 
            : 0;
        
        // Off Screen Drive%
        const offScreenToBasketRows = rows.filter(r =>
            r['Play Type'] === 'Off Screen' &&
            isSubCategorySummary(r, 'To Basket')
        );
        const offScreenDribbleJumperRows = rows.filter(r =>
            r['Play Type'] === 'Off Screen' &&
            isSubCategorySummary(r, 'Dribble Jumper')
        );
        const offScreenDrivesPoss = offScreenToBasketRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                                   offScreenDribbleJumperRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const offScreenNoDribblePoss = offScreenNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const offScreenDrivePct = (offScreenDrivesPoss + offScreenNoDribblePoss) > 0
            ? (offScreenDrivesPoss / (offScreenDrivesPoss + offScreenNoDribblePoss)) * 100
            : 0;
        
        // Handoffs Drive%
        const handoffsToBasketRows = rows.filter(r =>
            r['Play Type'] === 'Handoffs' &&
            isSubCategorySummary(r, 'To Basket')
        );
        const handoffsDribbleJumperRows = rows.filter(r =>
            r['Play Type'] === 'Handoffs' &&
            isSubCategorySummary(r, 'Dribble Jumper')
        );
        const handoffsDrivesPoss = handoffsToBasketRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                                  handoffsDribbleJumperRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const handoffsNoDribblePoss = handoffsNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const handoffsDrivePct = (handoffsDrivesPoss + handoffsNoDribblePoss) > 0
            ? (handoffsDrivesPoss / (handoffsDrivesPoss + handoffsNoDribblePoss)) * 100
            : 0;
        
        // Drives volume (from Overall play type) - use isSubCategorySummary to get only summary rows
        // This prevents double-counting from nested hierarchy rows
        const drivesLeftRows = rows.filter(r => r['Play Type'] === 'Overall' && isSubCategorySummary(r, 'Drives Left'));
        const drivesRightRows = rows.filter(r => r['Play Type'] === 'Overall' && isSubCategorySummary(r, 'Drives Right'));
        const drivesStraightRows = rows.filter(r => r['Play Type'] === 'Overall' && isSubCategorySummary(r, 'Drives Straight'));
        const allDrivesRows = [...drivesLeftRows, ...drivesRightRows, ...drivesStraightRows];
        const drivesPoss = allDrivesRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const drivesPts = allDrivesRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        
        // Finishing volume
        const cutRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Cut');
        const rollManRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'P&R Roll Man');
        const putbackRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Offensive Rebounds (Put Backs)');
        const finishingPoss = [...cutRows, ...rollManRows, ...putbackRows].reduce((s, r) => s + parseNum(r['POSS']), 0);
        const finishingPts = [...cutRows, ...rollManRows, ...putbackRows].reduce((s, r) => s + parseNum(r['PTS']), 0);
        
        // ===== DETAILED FINISHING METRICS =====
        // Finishing TOs
        const finishingTOs = cutRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0) + rollManRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0) + putbackRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0);
        
        // Finishing FT Rate
        const finishingFgAtt = cutRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0) +
                               rollManRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0) +
                               putbackRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
        const finishingFTAs = cutRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0) +
                              rollManRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0) +
                              putbackRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
        
        // P&R Rolls to Basket
        const rollsToBasketRows = rows.filter(r =>
            r['Play Type'] === 'P&R Roll Man' &&
            isSubCategorySummary(r, 'Rolls to Basket')
        );
        const rollsToBasketPoss = rollsToBasketRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const rollsToBasketPts = rollsToBasketRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        const rollsFgAtt = rollsToBasketRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
        const rollsFTAs = rollsToBasketRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
        const rollsTOs = rollsToBasketRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0);
        
        // P&R Pops (Pick and Pops + Slips the Pick > No Dribble Jumper)
        const pickAndPopsRows = rows.filter(r =>
            r['Play Type'] === 'P&R Roll Man' &&
            isSubCategorySummary(r, 'Pick and Pops')
        );
        const slipsNoDribbleRows = rows.filter(r =>
            r['Play Type'] === 'P&R Roll Man' &&
            anySubCategory(r, 'Slips the Pick') &&
            isSubCategorySummary(r, 'No Dribble Jumper')
        );
        const popsPoss = pickAndPopsRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                         slipsNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const popsPts = pickAndPopsRows.reduce((s, r) => s + parseNum(r['PTS']), 0) +
                        slipsNoDribbleRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        
        // Self Cuts (Cut > Basket/Flash summary rows)
        const cutBasketRows = rows.filter(r =>
            r['Play Type'] === 'Cut' &&
            isSubCategorySummary(r, 'Basket')
        );
        const cutFlashRows = rows.filter(r =>
            r['Play Type'] === 'Cut' &&
            isSubCategorySummary(r, 'Flash')
        );
        const selfCutPoss = cutBasketRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                            cutFlashRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const selfCutPts = cutBasketRows.reduce((s, r) => s + parseNum(r['PTS']), 0) +
                           cutFlashRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        const selfCutTOs = cutBasketRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0) + cutFlashRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0);
        
        // Putback volume (for finishing radar)
        const putbackPoss = putbackRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        
        // 3PA
        const total3Att = mainPlayTypeRows.reduce((sum, row) => sum + parseNum(row['3FG ATT']), 0);
        const total3Made = mainPlayTypeRows.reduce((sum, row) => sum + parseNum(row['3 FG MADE']), 0);
        const fg3Pct = total3Att > 0 ? (total3Made / total3Att) * 100 : 0;
        
        // Guarded vs Open 3PT data (for shooting value calculation)
        // Look for rows with Guarded/Open in subcategories and Long/3pt following
        const hasSubCategory = (row, term) => 
            [row['Sub Category 1'], row['Sub Category 2'], row['Sub Category 3'], 
             row['Sub Category 4'], row['Sub Category 5'], row['Sub Category 6']]
            .some(s => s && s.includes(term));
        
        const guarded3Rows = rows.filter(row => 
            hasSubCategory(row, 'Guarded') && hasSubCategory(row, 'Long/3pt') &&
            (row['Sub Category 5'] === 'N/A' || row['Sub Category 6'] === 'N/A')
        );
        const open3Rows = rows.filter(row => 
            hasSubCategory(row, 'Open') && hasSubCategory(row, 'Long/3pt') &&
            (row['Sub Category 5'] === 'N/A' || row['Sub Category 6'] === 'N/A')
        );
        
        const guarded3Att = guarded3Rows.reduce((sum, row) => sum + parseNum(row['3FG ATT']), 0);
        const guarded3Made = guarded3Rows.reduce((sum, row) => sum + parseNum(row['3 FG MADE']), 0);
        const open3Att = open3Rows.reduce((sum, row) => sum + parseNum(row['3FG ATT']), 0);
        const open3Made = open3Rows.reduce((sum, row) => sum + parseNum(row['3 FG MADE']), 0);
        
        const guarded3Pct = guarded3Att > 0 ? (guarded3Made / guarded3Att) * 100 : 0;
        const totalTracked = guarded3Att + open3Att;
        const guardedRate = totalTracked > 0 ? (guarded3Att / totalTracked) * 100 : 50;
        
        // Off-screen 3PA for difficulty calculation
        const offScreenMainRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Off Screen');
        const offScreen3Att = offScreenMainRows.reduce((sum, row) => sum + parseNum(row['3FG ATT']), 0);
        const offScreenRate = total3Att > 0 ? (offScreen3Att / total3Att) * 100 : 0;
        
        // ========== ACTUAL RIM vs MID-RANGE CALCULATION (matching display) ==========
        // Helper to check for rim finish subcategories (summary rows only)
        const isRimFinish = (row) => 
            isSubCategorySummary(row, 'To Basket') || 
            isSubCategorySummary(row, 'To Drop Step') || 
            isSubCategorySummary(row, 'To Up and Under');
        
        // P&R Ball Handler rim finishes
        const pnrRimRows = rows.filter(row =>
            row['Play Type'] === 'P&R Ball Handler' && isRimFinish(row)
        );
        
        // Isolation rim finishes
        const isoRimRows = rows.filter(row =>
            row['Play Type'] === 'Isolation' && isRimFinish(row)
        );
        
        // Post-Up rim finishes
        const postRimRows = rows.filter(row =>
            row['Play Type'] === 'Post-Up' && isRimFinish(row)
        );
        
        // Spot Up drives to basket
        const spotUpRimRows = rows.filter(row =>
            row['Play Type'] === 'Spot Up' &&
            anySubCategory(row, 'Drives') &&
            isSubCategorySummary(row, 'To Basket')
        );
        
        // Handoffs rim finishes
        const handoffsRimRows = rows.filter(row =>
            row['Play Type'] === 'Handoffs' && isSubCategorySummary(row, 'To Basket')
        );
        
        // Off Screen rim finishes
        const offScreenRimRows = rows.filter(row =>
            row['Play Type'] === 'Off Screen' && isSubCategorySummary(row, 'To Basket')
        );
        
        const allRimRows = [...pnrRimRows, ...isoRimRows, ...postRimRows, ...spotUpRimRows, ...handoffsRimRows, ...offScreenRimRows];
        const rimPoss = allRimRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const rimPts = allRimRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        const actualRimPPP = rimPoss > 0 ? rimPts / rimPoss : 0;
        
        // HC Rim FG% calculation using 2FG columns
        const hcRim2FgAtt = allRimRows.reduce((s, r) => s + parseNum(r['2 FG ATT']), 0);
        const hcRim2FgMade = allRimRows.reduce((s, r) => s + parseNum(r['2 FG MADE']), 0);
        const hcRimFgPct = hcRim2FgAtt > 0 ? (hcRim2FgMade / hcRim2FgAtt) * 100 : 0;
        
        // MID-RANGE CALCULATION (Dribble Jumper summary rows + Post-Up To Jumper)
        // P&R Ball Handler mid-range
        const pnrMidRows = rows.filter(row =>
            row['Play Type'] === 'P&R Ball Handler' && isSubCategorySummary(row, 'Dribble Jumper')
        );
        
        // Isolation mid-range
        const isoMidRows = rows.filter(row =>
            row['Play Type'] === 'Isolation' && isSubCategorySummary(row, 'Dribble Jumper')
        );
        
        // Post-Up mid-range (To Jumper)
        const postMidRows = rows.filter(row =>
            row['Play Type'] === 'Post-Up' && isSubCategorySummary(row, 'To Jumper')
        );
        
        // Spot Up drives mid-range
        const spotUpMidRows = rows.filter(row =>
            row['Play Type'] === 'Spot Up' &&
            anySubCategory(row, 'Drives') &&
            isSubCategorySummary(row, 'Dribble Jumper')
        );
        
        // Handoffs mid-range
        const handoffsMidRows = rows.filter(row =>
            row['Play Type'] === 'Handoffs' && isSubCategorySummary(row, 'Dribble Jumper')
        );
        
        // Off Screen mid-range
        const offScreenMidRows = rows.filter(row =>
            row['Play Type'] === 'Off Screen' && isSubCategorySummary(row, 'Dribble Jumper')
        );
        
        const allMidRows = [...pnrMidRows, ...isoMidRows, ...postMidRows, ...spotUpMidRows, ...handoffsMidRows, ...offScreenMidRows];
        const midPoss = allMidRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        
        // Actual rim to mid ratio
        const totalFgAtt = mainPlayTypeRows.reduce((sum, row) => sum + parseNum(row['FG ATT']), 0);
        const total2FgAtt = totalFgAtt - total3Att;
        const rimToMidRatio = midPoss > 0 ? rimPoss / midPoss : (rimPoss > 0 ? 10 : 0);
        
        // Pass percentage (matching display: P&R + ISO + Post-Up including passes)
        const pnrInclRows = rows.filter(r => r['Play Type'] === 'P&R Including Passes' && isMainPlayType(r));
        const pnrDirectRows = rows.filter(r => r['Play Type'] === 'P&R Ball Handler' && isMainPlayType(r));
        const isoInclRows = rows.filter(r => r['Play Type'] === 'ISO Including Passes' && isMainPlayType(r));
        const isoDirectRows = rows.filter(r => r['Play Type'] === 'Isolation' && isMainPlayType(r));
        const postInclRows = rows.filter(r => r['Play Type'] === 'Post-Ups Including Passes' && isMainPlayType(r));
        const postDirectRows = rows.filter(r => r['Play Type'] === 'Post-Up' && isMainPlayType(r));
        
        const totalInclPoss = pnrInclRows.reduce((s, r) => s + parseNum(r['POSS']), 0) + 
                             isoInclRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                             postInclRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const totalDirectPoss = pnrDirectRows.reduce((s, r) => s + parseNum(r['POSS']), 0) + 
                               isoDirectRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                               postDirectRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const passPoss = Math.max(0, totalInclPoss - totalDirectPoss);
        const onBallPassPct = totalInclPoss > 0 ? (passPoss / totalInclPoss) * 100 : 0;
        
        // TS%
        const totalPts = playerData.totalPts || 0;
        const totalFgAttPlayer = playerData.totalFgAtt || 0;
        const totalFTA = playerData.totalFTA || 0;
        const tsPct = (totalFgAttPlayer + 0.44 * totalFTA) > 0 
            ? (totalPts / (2 * (totalFgAttPlayer + 0.44 * totalFTA))) * 100 
            : 0;
        
        // ========== SHOOTING VALUE WITH PULL-UP 3s (matching display) ==========
        // Pull-up 3PT data: Dribble Jumper > Long/3pt summary rows (NOT No Dribble Jumper)
        const pullUp3Rows = rows.filter(row => 
            anySubCategory(row, 'Dribble Jumper') &&
            !anySubCategory(row, 'No Dribble') &&
            isSubCategorySummary(row, 'Long/3pt')
        );
        const pullUp3Att = pullUp3Rows.reduce((sum, row) => sum + parseNum(row['3FG ATT']), 0);
        const pullUp3Made = pullUp3Rows.reduce((sum, row) => sum + parseNum(row['3 FG MADE'] || row['3 FG MADE']), 0);
        const pullUp3Pct = pullUp3Att > 0 ? (pullUp3Made / pullUp3Att) * 100 : 0;
        
        // C&S 3PT data: No Dribble Jumper > Long/3pt summary rows
        const cns3Rows = rows.filter(row =>
            anySubCategory(row, 'No Dribble') &&
            isSubCategorySummary(row, 'Long/3pt')
        );
        const cns3Att = cns3Rows.reduce((sum, row) => sum + parseNum(row['3FG ATT']), 0);
        const cns3Made = cns3Rows.reduce((sum, row) => sum + parseNum(row['3 FG MADE'] || row['3 FG MADE']), 0);
        const cns3Pct = cns3Att > 0 ? (cns3Made / cns3Att) * 100 : 0;
        
        // Total shooting 3PT (C&S + pull-up for volume calculation)
        const shooting3Att = cns3Att + pullUp3Att;
        const shooting3Made = cns3Made + pullUp3Made;
        const combined3Pct = shooting3Att > 0 ? (shooting3Made / shooting3Att) * 100 : 0;
        
        // SHOOTING VALUE - ENHANCED FORMULA WITH PULL-UP 3s
        // Formula: Weighted combination of C&S and pull-up components
        const fg3Att75 = per75(total3Att);
        
        // Volume Factor (0-1): 8 3PA/75 = 1.0 (uses all 3PA from main play types)
        const svVolFactor = Math.min(1.0, Math.pow(fg3Att75 / 8, 0.8));
        
        // C&S Efficiency Factor (0-1): 38% = 1.0, 25% = 0
        const cnsEffRaw = (cns3Pct - 25) / (42 - 25);
        const cnsEffFactor = cns3Att > 0 ? Math.max(0, Math.min(1.0, cnsEffRaw)) : 0;
        
        // Pull-up Efficiency Factor (0-1): 35% = 1.0, 22% = 0 (lower bar because harder shots)
        const pullUpEffRaw = (pullUp3Pct - 22) / (38 - 22);
        const pullUpEffFactor = pullUp3Att > 0 ? Math.max(0, Math.min(1.0, pullUpEffRaw)) : 0;
        
        // Combined efficiency weighted by attempts (pull-up gets 1.15x bonus for difficulty)
        const totalWeightedAtts = cns3Att + (pullUp3Att * 1.15);
        const svEffFactor = totalWeightedAtts > 0 
            ? ((cnsEffFactor * cns3Att) + (pullUpEffFactor * pullUp3Att * 1.15)) / totalWeightedAtts
            : 0;
        
        // Difficulty Factor (0-1): Guarded eff (35%) + Guarded rate (30%) + Off-screen (20%) + Pull-up rate (15%)
        const svGrdEffFactor = Math.min(1.0, guarded3Pct / 38);
        const svGrdRateFactor = Math.min(1.0, guardedRate / 70);
        const svOffScrFactor = Math.min(1.0, offScreenRate / 25);
        const pullUpRate = total3Att > 0 ? (pullUp3Att / total3Att) * 100 : 0;
        const svPullUpFactor = Math.min(1.0, pullUpRate / 40); // 40% pull-up rate = max difficulty credit
        const svDiffFactor = (svGrdEffFactor * 0.35) + (svGrdRateFactor * 0.30) + (svOffScrFactor * 0.20) + (svPullUpFactor * 0.15);
        
        // Multiplicative combination with power scaling for spread
        const svRaw = svVolFactor * svEffFactor * svDiffFactor;
        const shootingValue = Math.pow(svRaw, 0.55) * 100;
        
        // RIM PRESSURE - MULTIPLICATIVE FORMULA (using actual rim data)
        // Formula: (Vol^0.8  Eff)^0.5  100
        const rimAttempts75 = per75(rimPoss);
        
        // Volume Factor (0-1): 8 rim/75 = 1.0
        const rpVolFactor = Math.min(1.0, Math.pow(rimAttempts75 / 8, 0.8));
        
        // Efficiency Factor (0-1): 1.25 PPP = 1.0, 0.70 = 0
        const rpEffRaw = (actualRimPPP - 0.70) / (1.25 - 0.70);
        const rpEffFactor = Math.max(0, Math.min(1.0, rpEffRaw));
        
        // Multiplicative combination
        const rpRaw = rpVolFactor * rpEffFactor;
        const rimPressure = Math.pow(rpRaw, 0.5) * 100;
        
        // Defense metrics (matching display exactly)
        let onBallDefPoss = 0, onBallDefPts = 0;
        let postDefPoss = 0, postDefPts = 0;
        let defTO = 0, defFgAtt = 0, totalDefPoss = 0;
        
        // Detailed defense metrics
        let pnrDefPoss = 0, pnrDefPts = 0, pnrDefTOs = 0, pnrDefFgAtt = 0, pnrDefFTAs = 0;
        let drivesDefPoss = 0, drivesDefPts = 0, drivesDefTOs = 0, drivesDefFgAtt = 0, drivesDefFTAs = 0;
        let postDefTOs = 0, postDefFgAtt = 0, postDefFTAs = 0;
        let onBallDefTOs = 0, onBallDefFgAtt = 0, onBallDefFTAs = 0;
        
        if (defRows.length > 0) {
            const defMainRows = defRows.filter(r => isMainPlayType(r));
            const isoDefRows = defMainRows.filter(r => r['Play Type'] === 'Isolation');
            const pnrDefRows = defMainRows.filter(r => r['Play Type'] === 'P&R Ball Handler');
            const postDefRows = defMainRows.filter(r => r['Play Type'] === 'Post-Up');
            
            // Overall drives defense (from Overall play type)
            const drivesLeftDefRows = defRows.filter(r => r['Play Type'] === 'Overall' && isSubCategorySummary(r, 'Drives Left'));
            const drivesRightDefRows = defRows.filter(r => r['Play Type'] === 'Overall' && isSubCategorySummary(r, 'Drives Right'));
            const drivesStraightDefRows = defRows.filter(r => r['Play Type'] === 'Overall' && isSubCategorySummary(r, 'Drives Straight'));
            const allDrivesDefRows = [...drivesLeftDefRows, ...drivesRightDefRows, ...drivesStraightDefRows];
            
            // Spot Up drives defense (matching display: Drives Left/Right/Straight with Sub Cat 4 = N/A)
            const spotUpDriveDefRows = defRows.filter(r =>
                r['Play Type'] === 'Spot Up' &&
                (anySubCategory(r, 'Drives Left') || anySubCategory(r, 'Drives Right') || anySubCategory(r, 'Drives Straight')) &&
                (r['Sub Category 4'] === 'N/A' || !r['Sub Category 4'])
            );
            
            // P&R Defense metrics
            pnrDefPoss = pnrDefRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
            pnrDefPts = pnrDefRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
            pnrDefTOs = pnrDefRows.reduce((s, r) => {
                const poss = parseNum(r['POSS']);
                const toPct = parseNum(r['TO%']);
                return s + (poss * toPct / 100);
            }, 0);
            pnrDefFgAtt = pnrDefRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
            pnrDefFTAs = pnrDefRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
            
            // Drives Defense metrics (from Overall)
            drivesDefPoss = allDrivesDefRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
            drivesDefPts = allDrivesDefRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
            drivesDefTOs = allDrivesDefRows.reduce((s, r) => {
                const poss = parseNum(r['POSS']);
                const toPct = parseNum(r['TO%']);
                return s + (poss * toPct / 100);
            }, 0);
            drivesDefFgAtt = allDrivesDefRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
            drivesDefFTAs = allDrivesDefRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
            
            // Post Defense metrics
            postDefPoss = postDefRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
            postDefPts = postDefRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
            postDefTOs = postDefRows.reduce((s, r) => {
                const poss = parseNum(r['POSS']);
                const toPct = parseNum(r['TO%']);
                return s + (poss * toPct / 100);
            }, 0);
            postDefFgAtt = postDefRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
            postDefFTAs = postDefRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
            
            // On-ball defense includes P&R BH + ISO + Spot Up Drives
            const allOnBallDefRows = [...isoDefRows, ...pnrDefRows, ...spotUpDriveDefRows];
            onBallDefPoss = allOnBallDefRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
            onBallDefPts = allOnBallDefRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
            onBallDefTOs = allOnBallDefRows.reduce((s, r) => {
                const poss = parseNum(r['POSS']);
                const toPct = parseNum(r['TO%']);
                return s + (poss * toPct / 100);
            }, 0);
            onBallDefFgAtt = allOnBallDefRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
            onBallDefFTAs = allOnBallDefRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
            
            // All defensive rows for TO% calculation
            const allDefensiveRows = [...isoDefRows, ...pnrDefRows, ...postDefRows, ...spotUpDriveDefRows];
            // Calculate turnovers from TO% * POSS / 100 (same as calcTurnovers function)
            defTO = allDefensiveRows.reduce((s, r) => {
                const toPct = parsePct(r['TO%']);
                const poss = parseNum(r['POSS']);
                return s + (toPct * poss / 100);
            }, 0);
            defFgAtt = allDefensiveRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
            totalDefPoss = allDefensiveRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
            
            // Debug logging for defTOPct
            if (debugCounter <= 3) {
                const calcDefTOPct = (defTO + defFgAtt) > 0 ? (defTO / (defTO + defFgAtt)) * 100 : null;
                console.log(`  ${player} defense: allDefRows=${allDefensiveRows.length}, defTO=${defTO.toFixed(2)}, defFgAtt=${defFgAtt}, defTOPct=${calcDefTOPct?.toFixed(2)}`);
            }
        }
        
        // ========== ON-BALL RADAR METRICS ==========
        // Use the already-defined pnrInclRows, postInclRows from above
        // FIXED: Use 'ISO Including Passes' (correct play type name)
        const isoInclRowsFixed = rows.filter(r => r['Play Type'] === 'ISO Including Passes' && isMainPlayType(r));
        
        const pnrInclPoss = pnrInclRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const pnrInclPts = pnrInclRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        // FIXED: Accumulate raw TOs from TO% * POSS for each row, then recalculate TO%
        const pnrInclTOs = pnrInclRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0);
        
        const isoInclPoss = isoInclRowsFixed.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const isoInclPts = isoInclRowsFixed.reduce((s, r) => s + parseNum(r['PTS']), 0);
        const postInclPoss = postInclRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const postInclPts = postInclRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        
        // On-ball including passes totals (for PPP)
        const onBallInclPoss = pnrInclPoss + isoInclPoss + postInclPoss;
        const onBallInclPts = pnrInclPts + isoInclPts + postInclPts;
        
        // Direct on-ball possessions (for % and volume metrics)
        const pnrBHPoss = pnrBHRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const isoPoss = isoRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const postDirectPoss = postRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const onBallDirectPoss = pnrBHPoss + isoPoss + postDirectPoss;
        
        // P&R Passing metrics
        const pnrPassPoss = Math.max(0, pnrInclPoss - pnrBHPoss);
        
        // P&R Pressure metrics (Defense Commits + Traps)
        const pnrDefCommitsRows = rows.filter(r => r['Play Type'] === 'P&R BH - Defense Commits' && isMainPlayType(r));
        const pnrTrapsRows = rows.filter(r => r['Play Type'] === 'P&R BH - Traps' && isMainPlayType(r));
        const pnrPressurePoss = pnrDefCommitsRows.reduce((s, r) => s + parseNum(r['POSS']), 0) + 
                               pnrTrapsRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const pnrPressurePts = pnrDefCommitsRows.reduce((s, r) => s + parseNum(r['PTS']), 0) + 
                              pnrTrapsRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        const pnrPressureTOs = pnrDefCommitsRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0) + pnrTrapsRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0);
        
        // Post Pressure metrics (Defense Commits + Hard Double)
        const postDefCommitsRows = rows.filter(r => r['Play Type'] === 'Post-Up - Defense Commits' && isMainPlayType(r));
        const postHardDoubleRows = rows.filter(r => r['Play Type'] === 'Post-Up - Hard Double' && isMainPlayType(r));
        const postPressurePoss = postDefCommitsRows.reduce((s, r) => s + parseNum(r['POSS']), 0) + 
                                postHardDoubleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const postPressurePts = postDefCommitsRows.reduce((s, r) => s + parseNum(r['PTS']), 0) + 
                               postHardDoubleRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        const postPressureTOs = postDefCommitsRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0) + postHardDoubleRows.reduce((s, r) => {
            const poss = parseNum(r['POSS']);
            const toPct = parseNum(r['TO%']);
            return s + (poss * toPct / 100);
        }, 0);
        
        // P&R Roll Assist PTS
        const pnrRollAstRows = rows.filter(r => 
            r['Play Type'] === 'P&R Including Passes' && isSubCategorySummary(r, 'P&R Roll Man')
        );
        const pnrRollAstPts = pnrRollAstRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        
        // P&R Spot Up Assist PTS
        const pnrSpotUpAstRows = rows.filter(r => 
            r['Play Type'] === 'P&R Including Passes' && isSubCategorySummary(r, 'Spot-Up')
        );
        const pnrSpotUpAstPts = pnrSpotUpAstRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        
        // Handling Shot Distribution - FIXED: P&R BH with High/Left/Right P&R and Dribble Jumper SUMMARY rows
        const hasPnrDirection = (r) => 
            anySubCategory(r, 'Left P&R') || anySubCategory(r, 'Right P&R') || anySubCategory(r, 'High P&R');
        const hasDribbleJumperSummary = (r) => isSubCategorySummary(r, 'Dribble Jumper');
        
        // P&R BH handling dribble jumpers - SUMMARY rows only to avoid double-counting
        const pnrDribbleJumperRows = rows.filter(r =>
            r['Play Type'] === 'P&R Ball Handler' &&
            hasPnrDirection(r) &&
            hasDribbleJumperSummary(r)
        );
        
        // FIXED: Use '2 FG ATT' (with space) for mid-range, '3FG ATT' (no space) for 3PT
        const handlingMidAtt = pnrDribbleJumperRows.reduce((s, r) => s + parseNum(r['2 FG ATT']), 0);
        const handlingMidMade = pnrDribbleJumperRows.reduce((s, r) => s + parseNum(r['2 FG MADE']), 0);
        const handling3Att = pnrDribbleJumperRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0);
        const handling3Made = pnrDribbleJumperRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
        
        // Rim: P&R BH with direction > To Basket
        const handlingRimRows = rows.filter(r =>
            r['Play Type'] === 'P&R Ball Handler' &&
            hasPnrDirection(r) &&
            isSubCategorySummary(r, 'To Basket')
        );
        const handlingRimAtt = handlingRimRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
        const handlingRimMade = handlingRimRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
        
        // Post L vs R
        const postLeftRows = rows.filter(r => r['Play Type'] === 'Post-Up' && isSubCategorySummary(r, 'Left Shoulder'));
        const postLeftPoss = postLeftRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const postLeftPts = postLeftRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        
        const postRightRows = rows.filter(r => r['Play Type'] === 'Post-Up' && isSubCategorySummary(r, 'Right Shoulder'));
        const postRightPoss = postRightRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const postRightPts = postRightRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        
        const totalPostShoulderPoss = postLeftPoss + postRightPoss;
        
        const radarMetrics = {
            player,
            team,
            season,  // Single season string (not array)
            totalPoss,
            
            // Duplicate detection flags
            _isDuplicate: dupInfo.isDuplicate,
            _duplicateOf: dupInfo.duplicateOf,
            _duplicateSimilarity: dupInfo.similarity,
            _utilitiesDuplicate: dupInfo.utilitiesDuplicate,
            _utilitiesDuplicateOf: dupInfo.utilitiesDuplicateOf,
            
            // Volume data for weighted percentiles
            _onBallPoss: onBallPoss,
            _spacingPoss: spacingPoss,
            _drivesPoss: drivesPoss,
            _finishingPoss: finishingPoss,
            _total3Att: total3Att,
            _shooting3Att: shooting3Att, // C&S + pull-up 3PT attempts for shootingValue weighting
            _total2FgAtt: total2FgAtt,
            _totalDefPoss: totalDefPoss,
            _onBallDefPoss: onBallDefPoss,
            _postDefPoss: postDefPoss,
            
            // Core metrics
            totalPPP: playerData.ppp || 0,
            tsPct,
            ftRate: playerData.ftRate || 0,
            usagePct: usagePct !== null ? usagePct : 20, // Fallback for no utilities
            
            // Volume metrics - use minutes-based per75 for consistency with display
            onBallVol75: per75(onBallPoss),
            onBallPPP: onBallPoss > 0 ? onBallPts / onBallPoss : 0,
            // OnBall% using Including Passes versions (P&R Incl + ISO Incl + Post-Ups Incl)
            onBallPct: totalPoss > 0 ? (onBallInclPoss / totalPoss) * 100 : 0,
            onBallIncl75: per75(onBallInclPoss), // For Pass% volume threshold in main radar
            // OffBall% (Spot Up + P&R Roll Man + Off Screen + Handoffs + Cut + OREB)
            offBallPct: totalPoss > 0 ? ((spacingPoss + finishingPoss) / totalPoss) * 100 : 0,
            spacingVol75: per75(spacingPoss),
            spacingPPP: spacingPoss > 0 ? spacingPts / spacingPoss : 0,
            drives75: per75(drivesPoss),
            drivesPPP: drivesPoss > 0 ? drivesPts / drivesPoss : 0,
            finishingVol75: per75(finishingPoss),
            finishingPPP: finishingPoss > 0 ? finishingPts / finishingPoss : 0,
            
            // Shooting
            shootingValue,
            rimPressure,
            fg3Att75: per75(total3Att),
            rimToMidRatio,
            hcRim75: per75(rimPoss),
            hcRimPPP: actualRimPPP,
            hcRimFgPct: hcRimFgPct,
            _hcRimAtt: rimPoss,
            
            // Playmaking
            onBallPassPct,
            astUsgRatio: (matchedGames > 0 && usagePct > 0) ? (astPct / usagePct) : null,
            toPct: matchedGames > 0 ? toPctVal : null,
            
            // Defense (defTOPct formula matches display: TO / (TO + FGA))
            onBallDef75: totalDefPoss > 0 ? per75(onBallDefPoss) : null,
            onBallDefPPP: onBallDefPoss > 0 ? onBallDefPts / onBallDefPoss : null,
            postDef75: totalDefPoss > 0 ? per75(postDefPoss) : null,
            postDefPPP: postDefPoss > 0 ? postDefPts / postDefPoss : null,
            defTOPct: (defTO + defFgAtt) > 0 ? (defTO / (defTO + defFgAtt)) * 100 : null,
            
            // Box score
            stl75: matchedGames > 0 ? per75(totalStl) : null,
            blk75: matchedGames > 0 ? per75(totalBlk) : null,
            oreb75: matchedGames > 0 ? per75(totalOreb) : null,
            dreb75: matchedGames > 0 ? per75(totalDreb) : null,
            
            // ===== ON-BALL RADAR METRICS =====
            // Overall on-ball (Including Passes for %, direct for volume/75)
            ob_onBall75: per75(onBallDirectPoss),
            ob_onBallPPP: onBallInclPoss > 0 ? onBallInclPts / onBallInclPoss : 0,
            ob_onBallPct: totalPoss > 0 ? (onBallInclPoss / totalPoss) * 100 : 0,
            // NEW: Including Passes for Creation/75
            ob_onBallIncl75: per75(onBallInclPoss),
            ob_onBallInclPPP: onBallInclPoss > 0 ? onBallInclPts / onBallInclPoss : 0,
            _onBallDirectPoss: onBallDirectPoss,
            _onBallInclPoss: onBallInclPoss,
            
            // Self-Creation Breakdown (direct play types only)
            ob_pnrBH75: per75(pnrBHPoss),
            ob_pnrBHPPP: pnrBHPoss > 0 ? pnrBHRows.reduce((s, r) => s + parseNum(r['PTS']), 0) / pnrBHPoss : 0,
            _pnrBHPoss: pnrBHPoss,
            ob_isoDirect75: per75(isoPoss),
            ob_isoDirectPPP: isoPoss > 0 ? isoRows.reduce((s, r) => s + parseNum(r['PTS']), 0) / isoPoss : 0,
            _isoDirectPoss: isoPoss,
            ob_postDirect75: per75(postDirectPoss),
            ob_postDirectPPP: postDirectPoss > 0 ? postRows.reduce((s, r) => s + parseNum(r['PTS']), 0) / postDirectPoss : 0,
            _postDirectPoss: postDirectPoss,
            
            // P&R Overall
            ob_pnrIncl75: per75(pnrInclPoss),
            ob_pnrInclPPP: pnrInclPoss > 0 ? pnrInclPts / pnrInclPoss : 0,
            ob_pnrPressurePPP: pnrPressurePoss > 0 ? pnrPressurePts / pnrPressurePoss : 0,
            ob_pnrPressureTOPct: pnrPressurePoss > 0 ? (pnrPressureTOs / pnrPressurePoss) * 100 : 0,
            _pnrInclPoss: pnrInclPoss,
            _pnrPressurePoss: pnrPressurePoss,
            
            // P&R Passing (FIXED: TO% recalculated from accumulated TOs)
            ob_pnrPassPct: pnrInclPoss > 0 ? (pnrPassPoss / pnrInclPoss) * 100 : 0,
            ob_pnrTOPct: pnrInclPoss > 0 ? (pnrInclTOs / pnrInclPoss) * 100 : 0,
            ob_pnrRollAst75: per75(pnrRollAstPts),
            ob_pnrSpotUpAst75: per75(pnrSpotUpAstPts),
            _pnrRollAstPts: pnrRollAstPts,
            _pnrSpotUpAstPts: pnrSpotUpAstPts,
            
            // Handling Shot Distribution
            ob_handlingRim75: per75(handlingRimAtt),
            ob_handlingRimPct: handlingRimAtt > 0 ? (handlingRimMade / handlingRimAtt) * 100 : 0,
            ob_handlingMid75: per75(handlingMidAtt),
            ob_handlingMidPct: handlingMidAtt > 0 ? (handlingMidMade / handlingMidAtt) * 100 : 0,
            ob_handling3P75: per75(handling3Att),
            ob_handling3PPct: handling3Att > 0 ? (handling3Made / handling3Att) * 100 : 0,
            _handlingRimAtt: handlingRimAtt,
            _handlingMidAtt: handlingMidAtt,
            _handling3Att: handling3Att,
            
            // ISO
            ob_iso75: per75(isoInclPoss),
            ob_isoPPP: isoInclPoss > 0 ? isoInclPts / isoInclPoss : 0,
            _isoInclPoss: isoInclPoss,
            
            // Post Overall
            ob_post75: per75(postInclPoss),
            ob_postPPP: postInclPoss > 0 ? postInclPts / postInclPoss : 0,
            ob_postPassPct: postInclPoss > 0 ? ((postInclPoss - postDirectPoss) / postInclPoss) * 100 : 0,
            ob_postPressurePPP: postPressurePoss > 0 ? postPressurePts / postPressurePoss : 0,
            ob_postPressureTOPct: postPressurePoss > 0 ? (postPressureTOs / postPressurePoss) * 100 : 0,
            _postInclPoss: postInclPoss,
            _postPressurePoss: postPressurePoss,
            
            // Post L vs R
            ob_postLeftPPP: postLeftPoss > 0 ? postLeftPts / postLeftPoss : 0,
            ob_postLeftPct: totalPostShoulderPoss > 0 ? (postLeftPoss / totalPostShoulderPoss) * 100 : 0,
            ob_postRightPPP: postRightPoss > 0 ? postRightPts / postRightPoss : 0,
            ob_postRightPct: totalPostShoulderPoss > 0 ? (postRightPoss / totalPostShoulderPoss) * 100 : 0,
            _postLeftPoss: postLeftPoss,
            _postRightPoss: postRightPoss,
            
            // ===== SPACING RADAR METRICS =====
            // Overall Spacing
            sp_spacing75: per75(spacingPoss),
            sp_spacingPct: totalPoss > 0 ? (spacingPoss / totalPoss) * 100 : 0,
            sp_spacingPPP: spacingPoss > 0 ? spacingPts / spacingPoss : 0,
            sp_spacingTOPct: spacingPoss > 0 ? (spacingTOs / spacingPoss) * 100 : 0,
            sp_spacingFtRate: spacingFgAtt > 0 ? (spacingFTAs / spacingFgAtt) * 100 : 0,
            _spacingPoss: spacingPoss,
            
            // Spot Up C&S
            sp_spotUpCnS75: per75(spotUpCnSPoss),
            sp_guardedPct: spGuardedPct,
            sp_guarded3Pct: spGuarded3Pct,
            sp_open3Pct: spOpen3Pct,
            sp_adjusted3Pct: spAdjusted3Pct,
            _spotUpCnSPoss: spotUpCnSPoss,
            _spGuarded3Att: spGuarded3Att,
            _spOpen3Att: spOpen3Att,
            
            // Moving Shots
            sp_moving75: per75(movingPoss),
            sp_movingPPP: movingPoss > 0 ? movingPts / movingPoss : 0,
            sp_moving3Pct: moving3Att > 0 ? (moving3Made / moving3Att) * 100 : 0,
            _movingPoss: movingPoss,
            _moving3Att: moving3Att,
            
            // Spot Up Drives
            sp_spotUpDrivePct: spotUpDrivePct,
            sp_spotUpDrives75: per75(spotUpDrivesPoss),
            sp_spotUpDrivesPPP: spotUpDrivesPoss > 0 ? spotUpDrivesPts / spotUpDrivesPoss : 0,
            sp_spotUpDrivesFtRate: spotUpDrivesFgAtt > 0 ? (spotUpDrivesFTAs / spotUpDrivesFgAtt) * 100 : 0,
            sp_spotUpDrivesTOPct: spotUpDrivesPoss > 0 ? (spotUpDrivesTOs / spotUpDrivesPoss) * 100 : 0,
            _spotUpDrivesPoss: spotUpDrivesPoss,
            _spotUpDrivesFgAtt: spotUpDrivesFgAtt,
            
            // Off Screen
            sp_offScreen75: per75(offScreenPoss),
            sp_offScreenPPP: offScreenPoss > 0 ? offScreenPts / offScreenPoss : 0,
            sp_offScreenDrivePct: offScreenDrivePct,
            _offScreenPoss: offScreenPoss,
            
            // Handoffs
            sp_handoffs75: per75(handoffsPoss),
            sp_handoffsPPP: handoffsPoss > 0 ? handoffsPts / handoffsPoss : 0,
            sp_handoffsDrivePct: handoffsDrivePct,
            _handoffsPoss: handoffsPoss,
            
            // ===== FINISHING RADAR METRICS =====
            // Overall Finishing
            fn_finishing75: per75(finishingPoss),
            fn_finishingPct: totalPoss > 0 ? (finishingPoss / totalPoss) * 100 : 0,
            fn_finishingPPP: finishingPoss > 0 ? finishingPts / finishingPoss : 0,
            fn_finishingTOPct: finishingPoss > 0 ? (finishingTOs / finishingPoss) * 100 : 0,
            fn_finishingFtRate: finishingFgAtt > 0 ? (finishingFTAs / finishingFgAtt) * 100 : 0,
            
            // P&R Rolls to Basket
            fn_rolls75: per75(rollsToBasketPoss),
            fn_rollsPPP: rollsToBasketPoss > 0 ? rollsToBasketPts / rollsToBasketPoss : 0,
            fn_rollsFtRate: rollsFgAtt > 0 ? (rollsFTAs / rollsFgAtt) * 100 : 0,
            fn_rollsTOPct: rollsToBasketPoss > 0 ? (rollsTOs / rollsToBasketPoss) * 100 : 0,
            _rollsPoss: rollsToBasketPoss,
            
            // P&R Pops
            fn_pops75: per75(popsPoss),
            fn_popsPPP: popsPoss > 0 ? popsPts / popsPoss : 0,
            _popsPoss: popsPoss,
            
            // Self Cuts
            fn_selfCut75: per75(selfCutPoss),
            fn_selfCutPPP: selfCutPoss > 0 ? selfCutPts / selfCutPoss : 0,
            fn_selfCutTOPct: selfCutPoss > 0 ? (selfCutTOs / selfCutPoss) * 100 : 0,
            _selfCutPoss: selfCutPoss,
            
            // Put Backs
            fn_putbacks75: per75(putbackPoss),
            _putbacksPoss: putbackPoss,
            
            // ===== DEFENSE RADAR METRICS =====
            // OnBall Defense
            df_onBallDef75: per75(onBallDefPoss),
            df_onBallDefPPP: onBallDefPoss > 0 ? onBallDefPts / onBallDefPoss : null,
            df_onBallDefTOPct: onBallDefPoss > 0 ? (onBallDefTOs / onBallDefPoss) * 100 : null,
            df_onBallDefFtRate: onBallDefFgAtt > 0 ? (onBallDefFTAs / onBallDefFgAtt) * 100 : null,
            _onBallDefPoss: onBallDefPoss,
            _onBallDefFgAtt: onBallDefFgAtt,
            
            // P&R Defense
            df_pnrDef75: per75(pnrDefPoss),
            df_pnrDefPPP: pnrDefPoss > 0 ? pnrDefPts / pnrDefPoss : null,
            df_pnrDefTOPct: pnrDefPoss > 0 ? (pnrDefTOs / pnrDefPoss) * 100 : null,
            df_pnrDefFtRate: pnrDefFgAtt > 0 ? (pnrDefFTAs / pnrDefFgAtt) * 100 : null,
            _pnrDefPoss: pnrDefPoss,
            _pnrDefFgAtt: pnrDefFgAtt,
            
            // Drives Defense
            df_drivesDef75: per75(drivesDefPoss),
            df_drivesDefPPP: drivesDefPoss > 0 ? drivesDefPts / drivesDefPoss : null,
            df_drivesDefTOPct: drivesDefPoss > 0 ? (drivesDefTOs / drivesDefPoss) * 100 : null,
            df_drivesDefFtRate: drivesDefFgAtt > 0 ? (drivesDefFTAs / drivesDefFgAtt) * 100 : null,
            _drivesDefPoss: drivesDefPoss,
            _drivesDefFgAtt: drivesDefFgAtt,
            
            // Post Defense
            df_postDef75: per75(postDefPoss),
            df_postDefPPP: postDefPoss > 0 ? postDefPts / postDefPoss : null,
            df_postDefTOPct: postDefPoss > 0 ? (postDefTOs / postDefPoss) * 100 : null,
            df_postDefFtRate: postDefFgAtt > 0 ? (postDefFTAs / postDefFgAtt) * 100 : null,
            _postDefPoss: postDefPoss,
            _postDefFgAtt: postDefFgAtt,
            
            // Box Score Defense
            df_stl75: matchedGames > 0 ? per75(totalStl) : null,
            df_blk75: matchedGames > 0 ? per75(totalBlk) : null
        };
        
        allRadarMetrics.push(radarMetrics);
        
        // Classify role and add to role group
        const dist = calculatePlayTypeDistribution(rows, totalPoss);
        const role = classifyPlayerRole(dist);
        if (roleGroupedMetrics[role.id]) {
            roleGroupedMetrics[role.id].push(radarMetrics);
        }
    });
    
    // Post-processing: Apply minimum possessions filter AFTER all players processed
    // This ensures all calculations complete before filtering
    const MIN_POSS_THRESHOLD = 1; // Very low threshold - let UI control actual filtering
    const filteredMetrics = allRadarMetrics.filter(m => m.totalPoss >= MIN_POSS_THRESHOLD);
    const skippedLowPoss = allRadarMetrics.length - filteredMetrics.length;
    
    // Also filter roleGroupedMetrics
    Object.keys(roleGroupedMetrics).forEach(roleId => {
        roleGroupedMetrics[roleId] = roleGroupedMetrics[roleId].filter(m => m.totalPoss >= MIN_POSS_THRESHOLD);
    });
    
    // Count duplicates in final set
    const duplicatesInPool = filteredMetrics.filter(m => m._isDuplicate).length;
    const utilitiesDupesInPool = filteredMetrics.filter(m => m._utilitiesDuplicate && !m._isDuplicate).length;
    
    // Diagnostic logging for pool building
    console.log(`Precompute pool building: ${Object.keys(playerSeasonMap).length} player-season combinations in data`);
    console.log(`  - Processed successfully: ${includedCount}`);
    console.log(`  - Skipped (no data): ${skippedNoData}`);
    console.log(`  - Without reliable minutes (fallback per75): ${skippedNoMinutes}`);
    console.log(`  - Skipped (low poss <${MIN_POSS_THRESHOLD}): ${skippedLowPoss}`);
    console.log(`  - Play type duplicates in pool: ${duplicatesInPool}`);
    console.log(`  - Utilities-only duplicates in pool: ${utilitiesDupesInPool}`);
    console.log(`  - Final allRadarMetrics count: ${filteredMetrics.length}`);
    
    return { allRadarMetrics: filteredMetrics, roleGroupedMetrics, duplicateInfo };
}

// ============================================
// COMPREHENSIVE PRECOMPUTATION FUNCTION
// Calculates all metrics, scales, and percentiles upfront
// ============================================

function precomputeAllPlayerData(offenseData, defenseData, teamUtilitiesData, playerUtilitiesData, selectedSeasons) {
    if (!offenseData.length) {
        return {
            allRadarMetrics: [],
            roleGroupedMetrics: {},
            scales: { leagueWide: null, byRole: {} },
            playerLookup: {},
            duplicateInfo: {},
            ready: false
        };
    }
    
    // Step 1: Calculate all radar metrics (includes duplicate detection)
    const { allRadarMetrics, roleGroupedMetrics, duplicateInfo } = calculateAllPlayersRadarMetrics(
        offenseData, defenseData, teamUtilitiesData, playerUtilitiesData, selectedSeasons
    );
    
    if (allRadarMetrics.length === 0) {
        return {
            allRadarMetrics: [],
            roleGroupedMetrics: {},
            scales: { leagueWide: null, byRole: {} },
            playerLookup: {},
            duplicateInfo: {},
            ready: false
        };
    }
    
    // Step 2: Calculate league-wide scales
    const leagueWideScales = calculateRadarScales(allRadarMetrics, null, 10);
    
    // Step 3: Calculate role-specific scales
    const roleScales = {};
    ROLE_DEFINITIONS.forEach(role => {
        const roleMetrics = roleGroupedMetrics[role.id] || [];
        if (roleMetrics.length >= 10) {
            roleScales[role.id] = calculateRadarScales(allRadarMetrics, roleMetrics, 10);
        }
    });
    
    // Step 4: Define metric keys with weighting info and minimum thresholds
    // Pro-level physics: Each metric weighted by relevant volume to prevent low-sample outliers
    // volumeKey + minVolume: additional per-75 threshold that must be met for this metric
    // useCombinedThreshold: for shot selection metrics using P&R/75 + ISO/75 combined threshold
    const radarMetricKeys = [
        // Core metrics - weight by total possessions
        { key: 'totalPPP', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'tsPct', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'ftRate', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'usagePct', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        
        // On-ball metrics - weight by on-ball possessions, PPP requires volume
        { key: 'onBallVol75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'onBallPPP', inverse: false, weightKey: '_onBallPoss', minWeight: 20, volumeKey: 'onBallVol75', minVolume: 2 },
        { key: 'onBallPct', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'offBallPct', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        
        // Shooting metrics - weight by 3PA (shooting attempts matter most)
        { key: 'shootingValue', inverse: false, weightKey: '_shooting3Att', minWeight: 15 },
        { key: 'rimPressure', inverse: false, weightKey: '_onBallPoss', minWeight: 20, volumeKey: 'onBallVol75', minVolume: 2 },
        { key: 'fg3Att75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'rimToMidRatio', inverse: false, weightKey: '_total2FgAtt', minWeight: 15 },
        { key: 'hcRim75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'hcRimPPP', inverse: false, weightKey: '_hcRimAtt', minWeight: 15, volumeKey: 'hcRim75', minVolume: 2 },
        { key: 'hcRimFgPct', inverse: false, weightKey: '_hcRimAtt', minWeight: 15, volumeKey: 'hcRim75', minVolume: 2 },
        
        // Playmaking - weight by on-ball possessions
        { key: 'onBallPassPct', inverse: false, weightKey: '_onBallPoss', minWeight: 20, volumeKey: 'onBallVol75', minVolume: 2 },
        { key: 'astUsgRatio', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'toPct', inverse: true, weightKey: 'totalPoss', minWeight: 50 },
        
        // Spacing - weight by spacing possessions, PPP requires volume
        { key: 'spacingVol75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'spacingPPP', inverse: false, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'spacingVol75', minVolume: 2 },
        
        // Drives & Finishing - weight by possessions, PPP requires volume
        { key: 'drives75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'drivesPPP', inverse: false, weightKey: '_drivesPoss', minWeight: 15, volumeKey: 'drives75', minVolume: 1 },
        { key: 'finishingVol75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'finishingPPP', inverse: false, weightKey: '_finishingPoss', minWeight: 15, volumeKey: 'finishingVol75', minVolume: 1 },
        
        // Defense - weight by defensive possessions, PPP requires volume
        { key: 'onBallDef75', inverse: false, weightKey: '_totalDefPoss', minWeight: 20 },
        { key: 'onBallDefPPP', inverse: true, weightKey: '_onBallDefPoss', minWeight: 15, volumeKey: 'onBallDef75', minVolume: 1.5 },
        { key: 'postDef75', inverse: false, weightKey: '_totalDefPoss', minWeight: 20 },
        { key: 'postDefPPP', inverse: true, weightKey: '_postDefPoss', minWeight: 10, volumeKey: 'postDef75', minVolume: 0.5 },
        { key: 'defTOPct', inverse: false, weightKey: '_totalDefPoss', minWeight: 20 },
        
        // Box score - weight by total possessions
        { key: 'stl75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'blk75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'oreb75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'dreb75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        
        // ===== ON-BALL RADAR METRICS =====
        // Overall on-ball
        { key: 'ob_onBall75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'ob_onBallPPP', inverse: false, weightKey: '_onBallDirectPoss', minWeight: 20 },
        
        // P&R Overall - PPP metrics require P&R/75 >= 2
        { key: 'ob_pnrIncl75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'ob_pnrInclPPP', inverse: false, weightKey: '_pnrInclPoss', minWeight: 15, volumeKey: 'ob_pnrIncl75', minVolume: 2 },
        { key: 'ob_pnrPressurePPP', inverse: false, weightKey: '_pnrPressurePoss', minWeight: 10, volumeKey: 'ob_pnrIncl75', minVolume: 2 },
        { key: 'ob_pnrPressureTOPct', inverse: true, weightKey: '_pnrPressurePoss', minWeight: 10, volumeKey: 'ob_pnrIncl75', minVolume: 2 },
        
        // P&R Passing - require P&R/75 >= 2
        { key: 'ob_pnrPassPct', inverse: false, weightKey: '_pnrInclPoss', minWeight: 15, volumeKey: 'ob_pnrIncl75', minVolume: 2 },
        { key: 'ob_pnrTOPct', inverse: true, weightKey: '_pnrInclPoss', minWeight: 15, volumeKey: 'ob_pnrIncl75', minVolume: 2 },
        { key: 'ob_pnrRollAst75', inverse: false, weightKey: '_pnrInclPoss', minWeight: 15 },
        { key: 'ob_pnrSpotUpAst75', inverse: false, weightKey: '_pnrInclPoss', minWeight: 15 },
        
        // Handling Shot Distribution - use combined P&R/75 + ISO/75 >= 2.5 threshold
        { key: 'ob_handlingRim75', inverse: false, weightKey: '_onBallDirectPoss', minWeight: 20, useCombinedThreshold: true, combinedMinVolume: 2.5 },
        { key: 'ob_handlingRimPct', inverse: false, weightKey: '_handlingRimAtt', minWeight: 10, useCombinedThreshold: true, combinedMinVolume: 2.5 },
        { key: 'ob_handlingMid75', inverse: false, weightKey: '_onBallDirectPoss', minWeight: 20, useCombinedThreshold: true, combinedMinVolume: 2.5 },
        { key: 'ob_handlingMidPct', inverse: false, weightKey: '_handlingMidAtt', minWeight: 10, useCombinedThreshold: true, combinedMinVolume: 2.5 },
        { key: 'ob_handling3P75', inverse: false, weightKey: '_onBallDirectPoss', minWeight: 20, useCombinedThreshold: true, combinedMinVolume: 2.5 },
        { key: 'ob_handling3PPct', inverse: false, weightKey: '_handling3Att', minWeight: 10, useCombinedThreshold: true, combinedMinVolume: 2.5 },
        
        // ISO - PPP requires ISO/75 >= 0.8
        { key: 'ob_iso75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'ob_isoPPP', inverse: false, weightKey: '_isoInclPoss', minWeight: 15, volumeKey: 'ob_iso75', minVolume: 0.8 },
        
        // Post Overall - PPP/Pass% metrics require Post/75 >= 0.8
        { key: 'ob_post75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'ob_postPPP', inverse: false, weightKey: '_postInclPoss', minWeight: 10, volumeKey: 'ob_post75', minVolume: 0.8 },
        { key: 'ob_postPassPct', inverse: false, weightKey: '_postInclPoss', minWeight: 10, volumeKey: 'ob_post75', minVolume: 0.8 },
        { key: 'ob_postPressurePPP', inverse: false, weightKey: '_postPressurePoss', minWeight: 5, volumeKey: 'ob_post75', minVolume: 0.8 },
        { key: 'ob_postPressureTOPct', inverse: true, weightKey: '_postPressurePoss', minWeight: 5, volumeKey: 'ob_post75', minVolume: 0.8 },
        
        // Post L vs R - require Post/75 >= 0.8
        { key: 'ob_postLeftPPP', inverse: false, weightKey: '_postLeftPoss', minWeight: 5, volumeKey: 'ob_post75', minVolume: 0.8 },
        { key: 'ob_postLeftPct', inverse: false, weightKey: '_postInclPoss', minWeight: 10, volumeKey: 'ob_post75', minVolume: 0.8 },
        { key: 'ob_postRightPPP', inverse: false, weightKey: '_postRightPoss', minWeight: 5, volumeKey: 'ob_post75', minVolume: 0.8 },
        { key: 'ob_postRightPct', inverse: false, weightKey: '_postInclPoss', minWeight: 10, volumeKey: 'ob_post75', minVolume: 0.8 },
        
        // Self-Creation Breakdown (Including Passes overall, direct play types individual)
        { key: 'ob_onBallIncl75', inverse: false, weightKey: '_onBallInclPoss', minWeight: 20 },
        { key: 'ob_onBallInclPPP', inverse: false, weightKey: '_onBallInclPoss', minWeight: 20 },
        { key: 'ob_pnrBH75', inverse: false, weightKey: '_pnrBHPoss', minWeight: 10 },
        { key: 'ob_pnrBHPPP', inverse: false, weightKey: '_pnrBHPoss', minWeight: 10 },
        { key: 'ob_isoDirect75', inverse: false, weightKey: '_isoDirectPoss', minWeight: 10 },
        { key: 'ob_isoDirectPPP', inverse: false, weightKey: '_isoDirectPoss', minWeight: 10 },
        { key: 'ob_postDirect75', inverse: false, weightKey: '_postDirectPoss', minWeight: 5 },
        { key: 'ob_postDirectPPP', inverse: false, weightKey: '_postDirectPoss', minWeight: 5 },
        
        // ===== SPACING RADAR METRICS =====
        { key: 'sp_spacing75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'sp_spacingPPP', inverse: false, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'sp_spacing75', minVolume: 1.5 },
        { key: 'sp_spotUpCnS75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'sp_guardedPct', inverse: false, weightKey: '_spGuarded3Att', minWeight: 10 },
        { key: 'sp_guarded3Pct', inverse: false, weightKey: '_spGuarded3Att', minWeight: 10 },
        { key: 'sp_open3Pct', inverse: false, weightKey: '_spOpen3Att', minWeight: 10 },
        { key: 'sp_adjusted3Pct', inverse: false, weightKey: '_spotUpCnSPoss', minWeight: 15 },
        { key: 'sp_moving75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'sp_movingPPP', inverse: false, weightKey: '_movingPoss', minWeight: 10, volumeKey: 'sp_moving75', minVolume: 0.5 },
        { key: 'sp_moving3Pct', inverse: false, weightKey: '_moving3Att', minWeight: 10 },
        { key: 'sp_spotUpDrives75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'sp_spotUpDrivesPPP', inverse: false, weightKey: '_spotUpDrivesPoss', minWeight: 10 },
        { key: 'sp_spotUpDrivesFtRate', inverse: false, weightKey: '_spotUpDrivesFgAtt', minWeight: 10, volumeKey: 'sp_spotUpDrives75', minVolume: 0.5 },
        { key: 'sp_spotUpDrivesTOPct', inverse: true, weightKey: '_spotUpDrivesPoss', minWeight: 10, volumeKey: 'sp_spotUpDrives75', minVolume: 0.5 },
        { key: 'sp_offScreen75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'sp_offScreenPPP', inverse: false, weightKey: '_offScreenPoss', minWeight: 10, volumeKey: 'sp_offScreen75', minVolume: 0.5 },
        { key: 'sp_handoffs75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'sp_handoffsPPP', inverse: false, weightKey: '_handoffsPoss', minWeight: 5, volumeKey: 'sp_handoffs75', minVolume: 0.3 },
        
        // ===== FINISHING RADAR METRICS =====
        { key: 'fn_finishing75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'fn_finishingPPP', inverse: false, weightKey: '_finishingPoss', minWeight: 15, volumeKey: 'fn_finishing75', minVolume: 1 },
        { key: 'fn_rolls75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'fn_rollsPPP', inverse: false, weightKey: '_rollsPoss', minWeight: 10, volumeKey: 'fn_rolls75', minVolume: 0.5 },
        { key: 'fn_pops75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'fn_popsPPP', inverse: false, weightKey: '_popsPoss', minWeight: 5, volumeKey: 'fn_pops75', minVolume: 0.3 },
        { key: 'fn_selfCut75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'fn_selfCutPPP', inverse: false, weightKey: '_selfCutPoss', minWeight: 10, volumeKey: 'fn_selfCut75', minVolume: 0.5 },
        { key: 'fn_putbacks75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        
        // ===== DEFENSE RADAR METRICS =====
        { key: 'df_onBallDef75', inverse: false, weightKey: '_totalDefPoss', minWeight: 20 },
        { key: 'df_onBallDefPPP', inverse: true, weightKey: '_onBallDefPoss', minWeight: 15, volumeKey: 'df_onBallDef75', minVolume: 1.5 },
        { key: 'df_onBallDefTOPct', inverse: false, weightKey: '_onBallDefPoss', minWeight: 15, volumeKey: 'df_onBallDef75', minVolume: 1.5 },
        { key: 'df_onBallDefFtRate', inverse: true, weightKey: '_onBallDefFgAtt', minWeight: 15, volumeKey: 'df_onBallDef75', minVolume: 1.5 },
        { key: 'df_pnrDef75', inverse: false, weightKey: '_totalDefPoss', minWeight: 20 },
        { key: 'df_pnrDefPPP', inverse: true, weightKey: '_pnrDefPoss', minWeight: 10, volumeKey: 'df_pnrDef75', minVolume: 0.5 },
        { key: 'df_pnrDefTOPct', inverse: false, weightKey: '_pnrDefPoss', minWeight: 10, volumeKey: 'df_pnrDef75', minVolume: 0.5 },
        { key: 'df_pnrDefFtRate', inverse: true, weightKey: '_pnrDefFgAtt', minWeight: 10, volumeKey: 'df_pnrDef75', minVolume: 0.5 },
        { key: 'df_drivesDef75', inverse: false, weightKey: '_totalDefPoss', minWeight: 20 },
        { key: 'df_drivesDefPPP', inverse: true, weightKey: '_drivesDefPoss', minWeight: 10, volumeKey: 'df_drivesDef75', minVolume: 0.5 },
        { key: 'df_drivesDefTOPct', inverse: false, weightKey: '_drivesDefPoss', minWeight: 10, volumeKey: 'df_drivesDef75', minVolume: 0.5 },
        { key: 'df_drivesDefFtRate', inverse: true, weightKey: '_drivesDefFgAtt', minWeight: 10, volumeKey: 'df_drivesDef75', minVolume: 0.5 },
        { key: 'df_postDef75', inverse: false, weightKey: '_totalDefPoss', minWeight: 20 },
        { key: 'df_postDefPPP', inverse: true, weightKey: '_postDefPoss', minWeight: 10, volumeKey: 'df_postDef75', minVolume: 0.5 },
        { key: 'df_postDefTOPct', inverse: false, weightKey: '_postDefPoss', minWeight: 10, volumeKey: 'df_postDef75', minVolume: 0.5 },
        { key: 'df_postDefFtRate', inverse: true, weightKey: '_postDefFgAtt', minWeight: 10, volumeKey: 'df_postDef75', minVolume: 0.5 },
        { key: 'df_stl75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'df_blk75', inverse: false, weightKey: 'totalPoss', minWeight: 50 }
    ];
    
    // Step 5: Pre-calculate WEIGHTED percentiles for each player-season
    const playerLookup = {};
    let playersWithAllCorePercentiles = 0;
    let playersWithSomeNullPercentiles = 0;
    let duplicateKeyCount = 0;
    
    allRadarMetrics.forEach(playerMetrics => {
        // Use player name + season as key
        const key = `${playerMetrics.player}|${playerMetrics.season || ''}`;
        
        // Check for duplicate keys
        if (playerLookup[key]) {
            duplicateKeyCount++;
            console.warn(`Duplicate key detected: ${key}`);
        }
        
        // Find player's role
        let playerRoleId = null;
        for (const roleId in roleGroupedMetrics) {
            if (roleGroupedMetrics[roleId].some(m => m.player === playerMetrics.player && m.season === playerMetrics.season)) {
                playerRoleId = roleId;
                break;
            }
        }
        
        // Calculate league-wide WEIGHTED percentiles
        const leaguePercentiles = {};
        let nullCount = 0;
        radarMetricKeys.forEach(({ key: metricKey, inverse, weightKey, minWeight, volumeKey, minVolume, useCombinedThreshold, combinedMinVolume }) => {
            const playerValue = playerMetrics[metricKey];
            const playerWeight = playerMetrics[weightKey] || playerMetrics.totalPoss;
            
            // Helper: Check if a player meets volume threshold
            const meetsVolumeThreshold = (m) => {
                if (useCombinedThreshold) {
                    // Combined threshold: P&R/75 + ISO/75 >= combinedMinVolume
                    const pnr75 = m.ob_pnrIncl75 || 0;
                    const iso75 = m.ob_iso75 || 0;
                    return (pnr75 + iso75) >= combinedMinVolume;
                } else if (volumeKey && minVolume !== undefined) {
                    // Standard volume threshold
                    const volumeValue = m[volumeKey];
                    return volumeValue !== null && volumeValue !== undefined && volumeValue >= minVolume;
                }
                return true; // No volume threshold
            };
            
            // Build weighted data array with minimum threshold filter
            // This filters the COMPARISON POOL, not the player being evaluated
            const weightedData = allRadarMetrics
                .filter(m => {
                    const w = m[weightKey] || m.totalPoss;
                    const v = m[metricKey];
                    return w >= minWeight && v !== null && v !== undefined && !isNaN(v) && meetsVolumeThreshold(m);
                })
                .map(m => ({
                    value: m[metricKey],
                    weight: m[weightKey] || m.totalPoss
                }));
            
            // Check if player meets all thresholds
            const playerMeetsMinWeight = playerWeight >= minWeight;
            const playerMeetsVolume = meetsVolumeThreshold(playerMetrics);
            const playerHasValue = playerValue !== null && playerValue !== undefined;
            
            // If player doesn't meet thresholds, they get null percentile
            if (!playerMeetsMinWeight || !playerHasValue || !playerMeetsVolume) {
                leaguePercentiles[metricKey] = null;
                nullCount++;
            } else {
                leaguePercentiles[metricKey] = calculateWeightedPercentile(
                    playerValue, playerWeight, weightedData, inverse
                );
            }
        });
        
        if (nullCount === 0) {
            playersWithAllCorePercentiles++;
        } else {
            playersWithSomeNullPercentiles++;
        }
        
        // Calculate role-specific WEIGHTED percentiles if enough players in role
        let rolePercentiles = null;
        const roleMetrics = playerRoleId ? roleGroupedMetrics[playerRoleId] : null;
        if (roleMetrics && roleMetrics.length >= 10) {
            rolePercentiles = {};
            radarMetricKeys.forEach(({ key: metricKey, inverse, weightKey, minWeight, volumeKey, minVolume, useCombinedThreshold, combinedMinVolume }) => {
                const playerValue = playerMetrics[metricKey];
                const playerWeight = playerMetrics[weightKey] || playerMetrics.totalPoss;
                
                // Helper: Check if a player meets volume threshold
                const meetsVolumeThreshold = (m) => {
                    if (useCombinedThreshold) {
                        const pnr75 = m.ob_pnrIncl75 || 0;
                        const iso75 = m.ob_iso75 || 0;
                        return (pnr75 + iso75) >= combinedMinVolume;
                    } else if (volumeKey && minVolume !== undefined) {
                        const volumeValue = m[volumeKey];
                        return volumeValue !== null && volumeValue !== undefined && volumeValue >= minVolume;
                    }
                    return true;
                };
                
                // Build weighted data array from role pool
                const weightedData = roleMetrics
                    .filter(m => {
                        const w = m[weightKey] || m.totalPoss;
                        const v = m[metricKey];
                        return w >= minWeight && v !== null && v !== undefined && !isNaN(v) && meetsVolumeThreshold(m);
                    })
                    .map(m => ({
                        value: m[metricKey],
                        weight: m[weightKey] || m.totalPoss
                    }));
                
                const playerMeetsMinWeight = playerWeight >= minWeight;
                const playerMeetsVolume = meetsVolumeThreshold(playerMetrics);
                const playerHasValue = playerValue !== null && playerValue !== undefined;
                
                if (!playerMeetsMinWeight || !playerHasValue || !playerMeetsVolume || weightedData.length < 5) {
                    rolePercentiles[metricKey] = null;
                } else {
                    rolePercentiles[metricKey] = calculateWeightedPercentile(
                        playerValue, playerWeight, weightedData, inverse
                    );
                }
            });
        }
        
        // ALL players get added to playerLookup - no filtering here
        playerLookup[key] = {
            metrics: playerMetrics,
            percentiles: {
                leagueWide: leaguePercentiles,
                roleSpecific: rolePercentiles
            },
            roleId: playerRoleId,
            useRolePercentiles: rolePercentiles !== null
        };
    });
    
    console.log(`Percentile calculation complete:`);
    console.log(`  - Total player-seasons processed: ${allRadarMetrics.length}`);
    console.log(`  - Added to playerLookup: ${Object.keys(playerLookup).length}`);
    console.log(`  - Duplicate keys (overwritten): ${duplicateKeyCount}`);
    console.log(`  - Players with all core percentiles: ${playersWithAllCorePercentiles}`);
    console.log(`  - Players with some null percentiles (low volume): ${playersWithSomeNullPercentiles}`);
    console.log(`Precomputed weighted percentiles for ${allRadarMetrics.length} player-seasons`);
    
    // Diagnostic: Check drives75 distribution
    const drives75Values = allRadarMetrics.map(m => m.drives75).filter(v => v !== null && v !== undefined && !isNaN(v));
    const drives75NonZero = drives75Values.filter(v => v > 0);
    console.log(`Drives/75 pool: ${drives75Values.length} total, ${drives75NonZero.length} non-zero, range: ${Math.min(...drives75Values).toFixed(1)} - ${Math.max(...drives75Values).toFixed(1)}`);
    if (drives75NonZero.length > 0) {
        const sorted = [...drives75NonZero].sort((a, b) => a - b);
        const p50 = sorted[Math.floor(sorted.length * 0.5)];
        const p80 = sorted[Math.floor(sorted.length * 0.8)];
        const p95 = sorted[Math.floor(sorted.length * 0.95)];
        console.log(`Drives/75 percentiles (non-zero): 50th=${p50?.toFixed(1)}, 80th=${p80?.toFixed(1)}, 95th=${p95?.toFixed(1)}`);
    }
    
    // Diagnostic: Check spacingVol75 distribution
    const spacing75Values = allRadarMetrics.map(m => m.spacingVol75).filter(v => v !== null && v !== undefined && !isNaN(v));
    if (spacing75Values.length > 0) {
        const sorted = [...spacing75Values].sort((a, b) => a - b);
        const p50 = sorted[Math.floor(sorted.length * 0.5)];
        const p80 = sorted[Math.floor(sorted.length * 0.8)];
        console.log(`Spacing/75 pool: ${spacing75Values.length} total, range: ${Math.min(...spacing75Values).toFixed(1)} - ${Math.max(...spacing75Values).toFixed(1)}, 50th=${p50?.toFixed(1)}, 80th=${p80?.toFixed(1)}`);
    }
    
    // Diagnostic: Check totalPoss distribution  
    const totalPossValues = allRadarMetrics.map(m => m.totalPoss).filter(v => v > 0);
    if (totalPossValues.length > 0) {
        const sorted = [...totalPossValues].sort((a, b) => a - b);
        const minPoss = Math.min(...totalPossValues);
        const maxPoss = Math.max(...totalPossValues);
        const p50Poss = sorted[Math.floor(sorted.length * 0.5)];
        console.log(`TotalPoss pool: ${totalPossValues.length} players, range: ${minPoss.toFixed(0)} - ${maxPoss.toFixed(0)}, median: ${p50Poss?.toFixed(0)}`);
    }
    
    // Diagnostic: Check how many players pass minimum threshold
    const playersWithMinPoss = allRadarMetrics.filter(m => m.totalPoss >= 50).length;
    console.log(`Players with 50+ poss: ${playersWithMinPoss} of ${allRadarMetrics.length}`);
    
    // Validation: Ensure all players were processed
    const lookupCount = Object.keys(playerLookup).length;
    if (lookupCount !== allRadarMetrics.length) {
        console.warn(`WARNING: Mismatch! allRadarMetrics has ${allRadarMetrics.length} but playerLookup has ${lookupCount}`);
    }
    
    // Count duplicates
    const duplicatesTotal = allRadarMetrics.filter(m => m._isDuplicate).length;
    const nonDuplicates = allRadarMetrics.filter(m => !m._isDuplicate).length;
    const duplicatesList = allRadarMetrics.filter(m => m._isDuplicate);
    
    // Final summary
    console.log(`\n`);
    console.log(`               PRECOMPUTE COMPLETE                          `);
    console.log(``);
    console.log(`  Total player-seasons in pool: ${allRadarMetrics.length}`);
    console.log(`     Active (non-duplicate): ${nonDuplicates}`);
    console.log(`     Excluded duplicates: ${duplicatesTotal}`);
    if (duplicatesTotal > 0) {
        console.log(``);
        console.log(`  EXCLUDED DUPLICATE SEASONS:`);
        duplicatesList.forEach(d => {
            console.log(`     ${d.player} - ${d.season}`);
            console.log(`      (${d._duplicateSimilarity?.toFixed(0)}% match with ${d._duplicateOf})`);
        });
    }
    console.log(``);
    console.log(`  PlayerLookup entries: ${lookupCount}`);
    console.log(`  Ready for ProfilesTab:  YES`);
    console.log(`\n`);
    
    return {
        allRadarMetrics,
        roleGroupedMetrics,
        scales: {
            leagueWide: leagueWideScales,
            byRole: roleScales
        },
        playerLookup,
        radarMetricKeys,
        duplicateInfo,
        ready: true
    };
}

// ============================================
// SCOUT REPORT FUNCTIONS AND COMPONENTS
// ============================================

// Calculate comprehensive Radar 1 metrics
function calculateRadar1Metrics(playerData, sectionData, matchedPoss, defenseData, enhancedStats, pools) {
    if (!playerData) return null;
    
    const totalTeamPoss = matchedPoss?.totalTeamPoss || playerData.totalPoss;
    const totalPlayerPoss = matchedPoss?.totalPlayerPoss || playerData.totalPoss;
    const totalPlayerMin = matchedPoss?.totalPlayerMin || 0;
    const totalTeamMin = matchedPoss?.totalTeamMin || 0;
    
    // Check for data mismatch: if synergy poss significantly exceeds matched poss, use simple calc
    // This prevents inflated per-75 values when utilities data doesn't cover all games
    const synergyPoss = playerData.totalPoss || 0;
    const matchedPossRatio = totalPlayerPoss > 0 ? synergyPoss / totalPlayerPoss : 999;
    const hasReliableMinutes = totalPlayerMin > 0 && totalTeamMin > 0 && matchedPossRatio < 1.5;
    
    // Log per75 calculation method for debugging
    console.log(`Display per75: hasReliableMinutes=${hasReliableMinutes}, totalPlayerMin=${totalPlayerMin?.toFixed(1)}, totalTeamMin=${totalTeamMin}, totalTeamPoss=${totalTeamPoss}, synergyPoss=${synergyPoss}, ratio=${matchedPossRatio.toFixed(2)}`);
    
    // Per-75 calculation helper
    // Formula: stat * 75 * teamMin / (playerMin * teamPoss)
    // This normalizes for playing time, then adjusts for pace
    // Falls back to simple ratio if data is mismatched
    const per75 = (value, teamPoss) => {
        if (hasReliableMinutes && teamPoss > 0) {
            return (value * 75 * totalTeamMin) / (totalPlayerMin * teamPoss);
        }
        // Fallback to simple ratio based on synergy possessions
        return synergyPoss > 0 ? (value / synergyPoss) * 75 : 0;
    };
    
    const rawRows = playerData.rawRows || [];
    
    // Filter for main play type rows only (all Sub Categories = N/A)
    const mainPlayTypeRows = rawRows.filter(row => 
        MAIN_PLAY_TYPES.includes(row['Play Type']) && isMainPlayType(row)
    );
    
    // Calculate total 3PT attempts early (needed for shootingValue and fg3Att75)
    const total3Att = mainPlayTypeRows.reduce((sum, row) => sum + parseNum(row['3FG ATT']), 0);
    
    // ==========================================
    // 1. Total PPP (from all main play types)
    // ==========================================
    const totalPPP = playerData.ppp || 0;
    
    // ==========================================
    // 2. Total TS% calculation 
    // ==========================================
    const totalFgAtt = playerData.totalFgAtt || 0;
    const totalFgMade = playerData.totalFgMade || 0;
    const totalFTA = playerData.totalFTA || 0;
    const totalPts = playerData.totalPts || 0;
    const tsa = totalFgAtt + (0.44 * totalFTA);
    const tsPct = tsa > 0 ? (totalPts / (2 * tsa)) * 100 : 0;
    
    // ==========================================
    // 3. Total FT Rate (FTA/FGA)
    // ==========================================
    const ftRate = playerData.ftRate || 0;
    
    // ==========================================
    // 4. Usage%
    // ==========================================
    const usagePct = matchedPoss?.usagePct || 0;
    
    // ==========================================
    // 5. On-Ball Volume/75 (ISO + P&R BH + Post-Up main category possessions)
    // ==========================================
    const onBallPoss = (playerData.playTypeStats['Isolation']?.poss || 0) +
                       (playerData.playTypeStats['P&R Ball Handler']?.poss || 0) +
                       (playerData.playTypeStats['Post-Up']?.poss || 0);
    const onBallVol75 = per75(onBallPoss, totalTeamPoss);
    
    // ==========================================
    // 5b. On-Ball % and Off-Ball % using INVOLVEMENT-BASED totals
    // 
    // Problem: Standard totalPoss uses direct play types (P&R BH, Isolation, Post-Up)
    // but "Including Passes" versions count MORE possessions (includes passes out).
    // This causes OnBall% > 100% when dividing Including Passes by direct totals.
    //
    // Solution: Create involvement-based denominator that uses "Including Passes"
    // for on-ball categories, ensuring OnBall% + OffBall%  100%
    //
    // Formula:
    // - On-Ball Poss = P&R Incl + Iso Incl + Post-Ups Incl (ball originates with player)
    // - Off-Ball Poss = Spot Up + Roll Man + Off Screen + Handoffs + Cut + OREB
    // - Total Involvement = On-Ball Poss + Off-Ball Poss
    // ==========================================
    
    // Get Including Passes rows for on-ball categories
    const pnrInclRowsForPct = rawRows.filter(row => 
        row['Play Type'] === 'P&R Including Passes' && isMainPlayType(row)
    );
    const isoInclRowsForPct = rawRows.filter(row => 
        row['Play Type'] === 'Iso Including Passes' && isMainPlayType(row)
    );
    const postInclRowsForPct = rawRows.filter(row => 
        row['Play Type'] === 'Post-Ups Including Passes' && isMainPlayType(row)
    );
    
    // Sum Including Passes possessions
    const pnrInclPossForPct = pnrInclRowsForPct.reduce((sum, row) => sum + parseNum(row['POSS']), 0);
    const isoInclPossForPct = isoInclRowsForPct.reduce((sum, row) => sum + parseNum(row['POSS']), 0);
    const postInclPossForPct = postInclRowsForPct.reduce((sum, row) => sum + parseNum(row['POSS']), 0);
    const onBallInclPossTotal = pnrInclPossForPct + isoInclPossForPct + postInclPossForPct;
    
    // Off-ball possessions (these don't have "Including Passes" variants)
    const offBallPoss = (playerData.playTypeStats['Spot Up']?.poss || 0) +
                        (playerData.playTypeStats['P&R Roll Man']?.poss || 0) +
                        (playerData.playTypeStats['Off Screen']?.poss || 0) +
                        (playerData.playTypeStats['Handoffs']?.poss || 0) +
                        (playerData.playTypeStats['Cut']?.poss || 0) +
                        (playerData.playTypeStats['Offensive Rebounds (Put Backs)']?.poss || 0);
    
    // Total involvement = on-ball (including passes) + off-ball
    // This ensures the denominator matches the numerator methodology
    const totalInvolvementPoss = onBallInclPossTotal + offBallPoss;
    
    // Calculate percentages using consistent denominator
    const onBallPct = totalInvolvementPoss > 0 ? (onBallInclPossTotal / totalInvolvementPoss) * 100 : 0;
    const offBallPct = totalInvolvementPoss > 0 ? (offBallPoss / totalInvolvementPoss) * 100 : 0;
    
    // ==========================================
    // 6. On-Ball PPP
    // ==========================================
    const onBallPPP = playerData.onBall?.ppp || 0;
    
    // ==========================================
    // 7. Shooting Value (advanced 3PT shooting metric with pull-up 3s)
    // ENHANCED FORMULA: Weighted combination of C&S and pull-up components
    // ==========================================
    
    // Pull-up 3PT data: Dribble Jumper > Long/3pt summary rows (NOT No Dribble Jumper)
    const pullUp3Rows = rawRows.filter(row => 
        anySubCategory(row, 'Dribble Jumper') &&
        !anySubCategory(row, 'No Dribble') &&
        isSubCategorySummary(row, 'Long/3pt')
    );
    const pullUp3Att = pullUp3Rows.reduce((sum, row) => sum + parseNum(row['3FG ATT']), 0);
    const pullUp3Made = pullUp3Rows.reduce((sum, row) => sum + parseNum(row['3 FG MADE'] || row['3 FG MADE']), 0);
    const pullUp3Pct = pullUp3Att > 0 ? (pullUp3Made / pullUp3Att) * 100 : 0;
    
    // C&S 3PT data from cnsData
    const cnsData = sectionData?.cns || {};
    const cns3Att = cnsData.total3Att || 0;
    const cns3Made = cnsData.total3Made || 0;
    const cns3Pct = cnsData.fg3Pct || 0;
    
    // Guarded/Open data from cnsData
    const guarded3Pct = cnsData.guarded3Pct || 0;
    const guardedRate = cnsData.contestedPct || 50;
    
    // Off-screen rate
    const offScreen3Att = sectionData?.offScreen?.main?.fg3Att || 0;
    const offScreenRate = (cns3Att + pullUp3Att) > 0 ? (offScreen3Att / (cns3Att + pullUp3Att)) * 100 : 0;
    
    let shootingValue = 0;
    if ((cns3Att + pullUp3Att) > 0) {
        const fg3Att75 = per75(total3Att, totalTeamPoss);
        
        // Volume Factor (0-1): 8 3PA/75 = 1.0 (uses all 3PA from main play types)
        const svVolFactor = Math.min(1.0, Math.pow(fg3Att75 / 8, 0.8));
        
        // C&S Efficiency Factor (0-1): 38% = 1.0, 25% = 0
        const cnsEffRaw = (cns3Pct - 25) / (42 - 25);
        const cnsEffFactor = cns3Att > 0 ? Math.max(0, Math.min(1.0, cnsEffRaw)) : 0;
        
        // Pull-up Efficiency Factor (0-1): 35% = 1.0, 22% = 0 (lower bar because harder shots)
        const pullUpEffRaw = (pullUp3Pct - 22) / (38 - 22);
        const pullUpEffFactor = pullUp3Att > 0 ? Math.max(0, Math.min(1.0, pullUpEffRaw)) : 0;
        
        // Combined efficiency weighted by attempts (pull-up gets 1.15x bonus for difficulty)
        const totalWeightedAtts = cns3Att + (pullUp3Att * 1.15);
        const svEffFactor = totalWeightedAtts > 0 
            ? ((cnsEffFactor * cns3Att) + (pullUpEffFactor * pullUp3Att * 1.15)) / totalWeightedAtts
            : 0;
        
        // Difficulty Factor (0-1): Guarded eff (35%) + Guarded rate (30%) + Off-screen (20%) + Pull-up rate (15%)
        const svGrdEffFactor = Math.min(1.0, guarded3Pct / 38);
        const svGrdRateFactor = Math.min(1.0, guardedRate / 70);
        const svOffScrFactor = Math.min(1.0, offScreenRate / 25);
        const pullUpRate = total3Att > 0 ? (pullUp3Att / total3Att) * 100 : 0;
        const svPullUpFactor = Math.min(1.0, pullUpRate / 40); // 40% pull-up rate = max difficulty credit
        const svDiffFactor = (svGrdEffFactor * 0.35) + (svGrdRateFactor * 0.30) + (svOffScrFactor * 0.20) + (svPullUpFactor * 0.15);
        
        // Multiplicative combination with power scaling for spread
        const svRaw = svVolFactor * svEffFactor * svDiffFactor;
        shootingValue = Math.pow(svRaw, 0.55) * 100;
    }
    
    // ==========================================
    // 8. Rim Pressure (on-ball rim finishing ability)
    // Formula: Volume at rim per 75  10 + PPP at rim  30
    // ==========================================
    // RIM FINISHES: To Basket, To Drop Step, To Up and Under
    // Excluded: "Including Passes" play types (they duplicate the same data)
    
    // Helper to check for rim finish subcategories (summary rows only)
    const isRimFinish = (row) => 
        isSubCategorySummary(row, 'To Basket') || 
        isSubCategorySummary(row, 'To Drop Step') || 
        isSubCategorySummary(row, 'To Up and Under');
    
    // P&R Ball Handler rim finishes
    const pnrRimRows = rawRows.filter(row =>
        row['Play Type'] === 'P&R Ball Handler' &&
        isRimFinish(row)
    );
    
    // Isolation rim finishes
    const isoRimRows = rawRows.filter(row =>
        row['Play Type'] === 'Isolation' &&
        isRimFinish(row)
    );
    
    // Post-Up rim finishes
    const postRimRows = rawRows.filter(row =>
        row['Play Type'] === 'Post-Up' &&
        isRimFinish(row)
    );
    
    // Spot Up drives to basket (Drives Left/Right/Straight > To Basket)
    const spotUpRimRows = rawRows.filter(row =>
        row['Play Type'] === 'Spot Up' &&
        anySubCategory(row, 'Drives') &&
        isSubCategorySummary(row, 'To Basket')
    );
    
    // Handoffs rim finishes
    const handoffsRimRows = rawRows.filter(row =>
        row['Play Type'] === 'Handoffs' &&
        isSubCategorySummary(row, 'To Basket')
    );
    
    // Off Screen rim finishes
    const offScreenRimRows = rawRows.filter(row =>
        row['Play Type'] === 'Off Screen' &&
        isSubCategorySummary(row, 'To Basket')
    );
    
    const rimRows = [...pnrRimRows, ...isoRimRows, ...postRimRows, ...spotUpRimRows, ...handoffsRimRows, ...offScreenRimRows];
    const rimAgg = aggregateRows(rimRows);
    const rimAttempts = rimAgg.poss;
    const rimPts = rimAgg.pts;
    const rimPPP = rimAgg.poss > 0 ? rimAgg.pts / rimAgg.poss : 0;
    
    // HC Rim FG% calculation using 2FG columns
    const hcRim2FgAtt = rimRows.reduce((s, r) => s + parseNum(r['2 FG ATT']), 0);
    const hcRim2FgMade = rimRows.reduce((s, r) => s + parseNum(r['2 FG MADE']), 0);
    const hcRimFgPct = hcRim2FgAtt > 0 ? (hcRim2FgMade / hcRim2FgAtt) * 100 : 0;
    
    const rimAttempts75 = per75(rimAttempts, totalTeamPoss);
    
    // RIM PRESSURE - MULTIPLICATIVE FORMULA
    // Formula: (Vol^0.8  Eff)^0.6  100
    // Creates natural variance across full 0-100 scale
    
    // Volume Factor (0-1): 8 rim/75 = 1.0
    const rpVolFactor = Math.min(1.0, Math.pow(rimAttempts75 / 8, 0.8));
    
    // Efficiency Factor (0-1): 1.15 PPP = 1.0, 0.70 = 0
    const rpEffRaw = (rimPPP - 0.70) / (1.25 - 0.70);
    const rpEffFactor = Math.max(0, Math.min(1.0, rpEffRaw));
    
    // Multiplicative combination
    const rpRaw = rpVolFactor * rpEffFactor;
    const rimPressure = Math.pow(rpRaw, 0.5) * 100;
    
    // ==========================================
    // 8b. 3PA/75 (total 3PT attempts per 75 possessions)
    // total3Att already calculated at top of function
    // ==========================================
    const fg3Att75 = per75(total3Att, totalTeamPoss);
    
    // ==========================================
    // 8c. RIM to MID Ratio
    // Mid-range = Dribble Jumper summary rows (where next subcategory is N/A) + Post-Up To Jumper
    // Excluded: "Including Passes" play types, "No Dribble Jumper" (catch-and-shoot)
    // ==========================================
    
    // P&R Ball Handler mid-range (High/Left/Right P&R > ... > Dribble Jumper > N/A)
    const pnrMidRows = rawRows.filter(row =>
        row['Play Type'] === 'P&R Ball Handler' &&
        isSubCategorySummary(row, 'Dribble Jumper')
    );
    
    // Isolation mid-range (Top/Right/Left > ... > Dribble Jumper > N/A)
    const isoMidRows = rawRows.filter(row =>
        row['Play Type'] === 'Isolation' &&
        isSubCategorySummary(row, 'Dribble Jumper')
    );
    
    // Post-Up mid-range (To Jumper)
    const postMidRows = rawRows.filter(row =>
        row['Play Type'] === 'Post-Up' &&
        isSubCategorySummary(row, 'To Jumper')
    );
    
    // Spot Up drives mid-range (Drives Left/Right/Straight > Dribble Jumper > N/A)
    const spotUpMidRows = rawRows.filter(row =>
        row['Play Type'] === 'Spot Up' &&
        anySubCategory(row, 'Drives') &&
        isSubCategorySummary(row, 'Dribble Jumper')
    );
    
    // Handoffs mid-range (Dribble Jumper > N/A)
    const handoffsMidRows = rawRows.filter(row =>
        row['Play Type'] === 'Handoffs' &&
        isSubCategorySummary(row, 'Dribble Jumper')
    );
    
    // Off Screen mid-range (Dribble Jumper > N/A)
    const offScreenMidRows = rawRows.filter(row =>
        row['Play Type'] === 'Off Screen' &&
        isSubCategorySummary(row, 'Dribble Jumper')
    );
    
    const midRangeRows = [...pnrMidRows, ...isoMidRows, ...postMidRows, ...spotUpMidRows, ...handoffsMidRows, ...offScreenMidRows];
    const midRangeAgg = aggregateRows(midRangeRows);
    const midRangeAttempts = midRangeAgg.fg2Att || midRangeAgg.poss || 0;
    
    // RIM to MID ratio: higher = more rim attacks relative to mid-range
    // If no mid-range, use a high ratio (rim-dominant)
    const rimToMidRatio = midRangeAttempts > 0 ? rimAttempts / midRangeAttempts : (rimAttempts > 0 ? 10 : 0);
    
    // ==========================================
    // 9. % of passes on-ball (P&R BH + Post-Up + Isolation including passes)
    // ==========================================
    // Get P&R Including Passes main row
    const pnrInclRows = rawRows.filter(row =>
        row['Play Type'] === 'P&R Including Passes' && isMainPlayType(row)
    );
    const pnrInclAgg = aggregateRows(pnrInclRows);
    
    // Get P&R Ball Handler main row  
    const pnrBHRows = rawRows.filter(row =>
        row['Play Type'] === 'P&R Ball Handler' && isMainPlayType(row)
    );
    const pnrBHAgg = aggregateRows(pnrBHRows);
    
    // Get Post-Ups Including Passes main row
    const postInclRows = rawRows.filter(row =>
        row['Play Type'] === 'Post-Ups Including Passes' && isMainPlayType(row)
    );
    const postInclAgg = aggregateRows(postInclRows);
    
    // Get Post-Up main row
    const postRows = rawRows.filter(row =>
        row['Play Type'] === 'Post-Up' && isMainPlayType(row)
    );
    const postAgg = aggregateRows(postRows);
    
    // Get Iso Including Passes main row
    const isoInclRows = rawRows.filter(row =>
        row['Play Type'] === 'Iso Including Passes' && isMainPlayType(row)
    );
    const isoInclAgg = aggregateRows(isoInclRows);
    
    // Get Isolation main row
    const isoRows = rawRows.filter(row =>
        row['Play Type'] === 'Isolation' && isMainPlayType(row)
    );
    const isoAgg = aggregateRows(isoRows);
    
    // Calculate total passes: (Including Passes poss) - (Direct scoring poss)
    const pnrPasses = Math.max(0, pnrInclAgg.poss - pnrBHAgg.poss);
    const postPasses = Math.max(0, postInclAgg.poss - postAgg.poss);
    const isoPasses = Math.max(0, isoInclAgg.poss - isoAgg.poss);
    const totalOnBallPasses = pnrPasses + postPasses + isoPasses;
    const totalOnBallInclPoss = pnrInclAgg.poss + postInclAgg.poss + isoInclAgg.poss;
    
    const onBallPassPct = totalOnBallInclPoss > 0 ? (totalOnBallPasses / totalOnBallInclPoss) * 100 : 0;
    
    // ==========================================
    // 10. Assist% to Usage% ratio
    // ==========================================
    const astUsageRatio = (enhancedStats?.astPct && enhancedStats?.usagePct && enhancedStats.usagePct > 0) ?
        enhancedStats.astPct / enhancedStats.usagePct : null;
    
    // ==========================================
    // 11. Spacing Volume/75
    // ==========================================
    const spacingPoss = (playerData.playTypeStats['Spot Up']?.poss || 0) +
                        (playerData.playTypeStats['Handoffs']?.poss || 0) +
                        (playerData.playTypeStats['Off Screen']?.poss || 0);
    const spacingVol75 = per75(spacingPoss, totalTeamPoss);
    
    // ==========================================
    // 12. Spacing PPP
    // ==========================================
    const spacingStats = ['Spot Up', 'Handoffs', 'Off Screen'].reduce((acc, pt) => {
        const stats = playerData.playTypeStats[pt] || { poss: 0, pts: 0 };
        return { poss: acc.poss + stats.poss, pts: acc.pts + stats.pts };
    }, { poss: 0, pts: 0 });
    const spacingPPP = spacingStats.poss > 0 ? spacingStats.pts / spacingStats.poss : 0;
    
    // ==========================================
    // 12b. Drives/75 (total drives from Overall play type)
    // ==========================================
    // Get drives from slashing data - use isSubCategorySummary to get only summary rows
    // This prevents double-counting from nested hierarchy rows
    const drivesLeftRows = rawRows.filter(row =>
        row['Play Type'] === 'Overall' &&
        isSubCategorySummary(row, 'Drives Left')
    );
    const drivesRightRows = rawRows.filter(row =>
        row['Play Type'] === 'Overall' &&
        isSubCategorySummary(row, 'Drives Right')
    );
    const drivesStraightRows = rawRows.filter(row =>
        row['Play Type'] === 'Overall' &&
        isSubCategorySummary(row, 'Drives Straight')
    );
    const allDrivesRows = [...drivesLeftRows, ...drivesRightRows, ...drivesStraightRows];
    const drivesAgg = aggregateRows(allDrivesRows);
    const drivesTotalPoss = drivesAgg.poss;
    const drivesTotalPts = drivesAgg.pts;
    const drives75 = per75(drivesTotalPoss, totalTeamPoss);
    const drivesPPP = drivesTotalPoss > 0 ? drivesTotalPts / drivesTotalPoss : 0;
    
    // ==========================================
    // 13. Finishing Volume/75
    // ==========================================
    const finishingPoss = (playerData.playTypeStats['Cut']?.poss || 0) +
                          (playerData.playTypeStats['P&R Roll Man']?.poss || 0) +
                          (playerData.playTypeStats['Offensive Rebounds (Put Backs)']?.poss || 0);
    const finishingVol75 = per75(finishingPoss, totalTeamPoss);
    
    // ==========================================
    // 14. Finishing PPP
    // ==========================================
    const finishingStats = ['Cut', 'P&R Roll Man', 'Offensive Rebounds (Put Backs)'].reduce((acc, pt) => {
        const stats = playerData.playTypeStats[pt] || { poss: 0, pts: 0 };
        return { poss: acc.poss + stats.poss, pts: acc.pts + stats.pts };
    }, { poss: 0, pts: 0 });
    const finishingPPP = finishingStats.poss > 0 ? finishingStats.pts / finishingStats.poss : 0;
    
    // ==========================================
    // DEFENSE METRICS (from PLAYER_DEFENSE.csv)
    // ==========================================
    let onBallDef75 = 0, onBallDefPPP = 0, postDef75 = 0, postDefPPP = 0, defTOPct = 0;
    let totalDefPoss = 0, onBallDefPossVal = 0, postDefPossVal = 0;
    
    if (defenseData && defenseData.length > 0) {
        // ==========================================
        // 15. On-Ball Defense/75 (P&R BH + ISO + Spot Up Drives main categories)
        // ==========================================
        const pnrDefRows = defenseData.filter(row => 
            row['Play Type'] === 'P&R Ball Handler' && isMainPlayType(row)
        );
        const isoDefRows = defenseData.filter(row =>
            row['Play Type'] === 'Isolation' && isMainPlayType(row)
        );
        // Spot Up drives defense: Drives Left/Right/Straight with N/A subcategory
        const spotUpDriveDefRows = defenseData.filter(row =>
            row['Play Type'] === 'Spot Up' &&
            (anySubCategory(row, 'Drives Left') || anySubCategory(row, 'Drives Right') || anySubCategory(row, 'Drives Straight')) &&
            subCategoryEquals(row, 4, 'N/A')
        );
        
        const onBallDefAgg = aggregateRows([...pnrDefRows, ...isoDefRows, ...spotUpDriveDefRows]);
        onBallDef75 = per75(onBallDefAgg.poss, totalTeamPoss);
        onBallDefPossVal = onBallDefAgg.poss;
        
        // ==========================================
        // 16. On-Ball Defense PPP (lower is better)
        // ==========================================
        onBallDefPPP = onBallDefAgg.poss > 0 ? onBallDefAgg.pts / onBallDefAgg.poss : 0;
        
        // ==========================================
        // 17. Post Defense/75 (Post-Up defense main category)
        // ==========================================
        const postDefRows = defenseData.filter(row =>
            row['Play Type'] === 'Post-Up' && isMainPlayType(row)
        );
        const postDefAgg = aggregateRows(postDefRows);
        postDef75 = per75(postDefAgg.poss, totalTeamPoss);
        postDefPossVal = postDefAgg.poss;
        
        // ==========================================
        // 18. Post Defense PPP (lower is better)
        // ==========================================
        postDefPPP = postDefAgg.poss > 0 ? postDefAgg.pts / postDefAgg.poss : 0;
        
        // ==========================================
        // 19. Defense TO% (turnovers forced / FG ATT defended)
        // From: Post-Up, P&R BH, ISO, and Spot Up Drives
        // ==========================================
        const allDefensiveRows = [
            ...pnrDefRows, 
            ...isoDefRows, 
            ...postDefRows,
            ...spotUpDriveDefRows
        ];
        const defTotalAgg = aggregateRows(allDefensiveRows);
        // TO% = Turnovers / (Poss - FG ATT is not right, use standard: TO / Poss)
        // But user says "using poss against FG ATT" - this likely means TO / (TO + FGA)
        const defTurnovers = defTotalAgg.turnovers || 0;
        const defFgAtt = defTotalAgg.fgAtt || 0;
        defTOPct = (defTurnovers + defFgAtt) > 0 ? (defTurnovers / (defTurnovers + defFgAtt)) * 100 : 0;
        totalDefPoss = defTotalAgg.poss;
    }
    
    // ==========================================
    // 20-23. Box Score Stats/75 (from utilities_player.csv via matchedPoss)
    // Falls back to enhancedStats if matchedPoss not available
    // ==========================================
    const stl75 = matchedPoss?.stl75 ?? (enhancedStats ? per75(enhancedStats.stlPerGame * (enhancedStats.games || 1), totalTeamPoss) : null);
    const blk75 = matchedPoss?.blk75 ?? (enhancedStats ? per75(enhancedStats.blkPerGame * (enhancedStats.games || 1), totalTeamPoss) : null);
    const oreb75 = matchedPoss?.oreb75 ?? (enhancedStats ? per75(enhancedStats.orebPerGame * (enhancedStats.games || 1), totalTeamPoss) : null);
    const dreb75 = matchedPoss?.dreb75 ?? (enhancedStats ? per75(enhancedStats.drebPerGame * (enhancedStats.games || 1), totalTeamPoss) : null);
    
    // Get ast75 and to75 from matchedPoss
    // const ast75 = matchedPoss?.ast75 ?? null;
    // const to75 = matchedPoss?.to75 ?? null;
    
    // Calculate AST/USG% = AST% / USG%
    // AST% measures what % of teammate FGs the player assisted
    // Dividing by USG% normalizes for how much the player uses possessions
    const astPct = matchedPoss?.astPct ?? null;
    const astUsgRatio = (astPct !== null && usagePct > 0) ? astPct / usagePct : null;
    
    // Get TO% from matchedPoss (% of possessions used that end in turnover)
    const toPct = matchedPoss?.toPct ?? null;
    
    // Calculate 2FG attempts for weighting (total3Att already calculated above)
    const total2FgAtt = totalFgAtt - total3Att;
    
    // Shooting 3PT attempts (C&S + pull-up) for shootingValue weighting
    const shooting3Att = cns3Att + pullUp3Att;
    
    return {
        // Internal volume fields for weighted percentile calculation
        totalPoss: playerData.totalPoss || 0,
        _onBallPoss: onBallPoss,
        _spacingPoss: spacingPoss,
        _drivesPoss: drivesTotalPoss,
        _finishingPoss: finishingPoss,
        _total3Att: total3Att,
        _shooting3Att: shooting3Att, // C&S + pull-up 3PT attempts for shootingValue weighting
        _total2FgAtt: total2FgAtt,
        _totalDefPoss: totalDefPoss,
        _onBallDefPoss: onBallDefPossVal,
        _postDefPoss: postDefPossVal,
        _hcRimAtt: rimAttempts,
        
        // Offense
        totalPPP,
        tsPct,
        ftRate,
        usagePct,
        onBallVol75,
        onBallPPP,
        onBallPct,
        offBallPct,
        onBallIncl75: per75(onBallInclPossTotal, totalTeamPoss), // For Pass% volume threshold
        shootingValue,
        rimPressure,
        fg3Att75,
        rimToMidRatio,
        onBallPassPct,
        astUsgRatio,
        toPct: toPct,
        spacingVol75,
        spacingPPP,
        drives75,
        drivesPPP,
        finishingVol75,
        finishingPPP,
        // HC Rim (Half-Court Rim Attacks)
        hcRim75: rimAttempts75,
        hcRimPPP: rimPPP,
        hcRimFgPct: hcRimFgPct,
        // Defense
        onBallDef75,
        onBallDefPPP,
        postDef75,
        postDefPPP,
        defTOPct,
        // Enhanced
        stl75,
        blk75,
        oreb75,
        dreb75
    };
}

// ============================================
// RADAR STATS TABLE COMPONENT
// Expandable table with sortable stats by percentile
// ============================================
function RadarStatsTable({ metrics, percentiles, categories, title, compact = false }) {
    const [expandedCategories, setExpandedCategories] = React.useState(new Set(categories.map(c => c.name)));
    const [sortBy, setSortBy] = React.useState('category'); // 'category', 'percentile-asc', 'percentile-desc'
    const [isTableCollapsed, setIsTableCollapsed] = React.useState(false); // Vertical collapse state
    
    // Toggle category expansion
    const toggleCategory = (catName) => {
        setExpandedCategories(prev => {
            const next = new Set(prev);
            if (next.has(catName)) {
                next.delete(catName);
            } else {
                next.add(catName);
            }
            return next;
        });
    };
    
    // Expand/collapse all
    const expandAll = () => setExpandedCategories(new Set(categories.map(c => c.name)));
    const collapseAll = () => setExpandedCategories(new Set());
    
    // Get color based on percentile (same as barplot)
    const getPercentileColor = (pct) => {
        if (pct === null || pct === undefined) return '#64748b';
        if (pct === -1) return '#94a3b8';
        if (pct >= 90) return '#22c55e';
        if (pct >= 75) return '#84cc16';
        if (pct >= 60) return '#a3e635';
        if (pct >= 40) return '#fbbf24';
        if (pct >= 25) return '#fb923c';
        return '#ef4444';
    };
    
    // Get background color (more subtle)
    const getPercentileBg = (pct) => {
        if (pct === null || pct === undefined) return 'rgba(100, 116, 139, 0.1)';
        if (pct === -1) return 'rgba(148, 163, 184, 0.1)';
        if (pct >= 90) return 'rgba(34, 197, 94, 0.15)';
        if (pct >= 75) return 'rgba(132, 204, 22, 0.15)';
        if (pct >= 60) return 'rgba(163, 230, 53, 0.12)';
        if (pct >= 40) return 'rgba(251, 191, 36, 0.12)';
        if (pct >= 25) return 'rgba(251, 146, 60, 0.12)';
        return 'rgba(239, 68, 68, 0.15)';
    };
    
    // Format value based on type
    const formatValue = (value, format) => {
        if (value === null || value === undefined) return '-';
        switch(format) {
            case 'ppp': return value.toFixed(2);
            case 'pct': return value.toFixed(0) + '%';
            case 'dec': return value.toFixed(1);
            case 'int': return Math.round(value).toString();
            default: return value.toFixed(1);
        }
    };
    
    // Build flat list of all metrics with category info
    const allMetrics = [];
    categories.forEach(cat => {
        cat.metricDefs.forEach(m => {
            const pct = percentiles?.[m.key];
            allMetrics.push({
                ...m,
                category: cat.name,
                categoryColor: cat.color,
                value: metrics?.[m.key],
                percentile: pct
            });
        });
    });
    
    // Sort metrics if needed
    let sortedMetrics = [...allMetrics];
    if (sortBy === 'percentile-desc') {
        sortedMetrics.sort((a, b) => {
            const pctA = a.percentile ?? -999;
            const pctB = b.percentile ?? -999;
            return pctB - pctA;
        });
    } else if (sortBy === 'percentile-asc') {
        sortedMetrics.sort((a, b) => {
            const pctA = a.percentile ?? 999;
            const pctB = b.percentile ?? 999;
            return pctA - pctB;
        });
    }
    
    // Group by category for display (if sorting by category)
    const groupedByCategory = sortBy === 'category';
    
    return e('div', { 
        style: { 
            width: isTableCollapsed ? '40px' : (compact ? '240px' : '280px'),
            maxHeight: isTableCollapsed ? 'auto' : (compact ? '460px' : '580px'),
            overflowY: isTableCollapsed ? 'visible' : 'auto',
            background: 'rgba(0, 0, 0, 0.3)',
            borderRadius: '12px',
            border: '1px solid rgba(255, 255, 255, 0.1)',
            padding: isTableCollapsed ? '8px' : '12px',
            transition: 'width 0.3s ease, padding 0.3s ease'
        }
    },
        // Collapse/Expand Toggle Button (always visible)
        e('button', {
            onClick: () => setIsTableCollapsed(!isTableCollapsed),
            title: isTableCollapsed ? 'Expand table' : 'Collapse table',
            style: {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                width: isTableCollapsed ? '24px' : '100%',
                padding: isTableCollapsed ? '8px 0' : '4px 8px',
                marginBottom: isTableCollapsed ? '0' : '8px',
                fontSize: '10px',
                fontWeight: '600',
                background: 'rgba(99, 102, 241, 0.2)',
                border: '1px solid rgba(99, 102, 241, 0.3)',
                borderRadius: '6px',
                color: '#818cf8',
                cursor: 'pointer',
                transition: 'all 0.2s ease'
            }
        }, isTableCollapsed ? '' : e('span', null, ' ', title || 'STATS')),
        
        // Table content (hidden when collapsed)
        !isTableCollapsed && e('div', null,
            // Header
            e('div', { style: { marginBottom: '12px' } },
                
                // Controls row
                e('div', { style: { display: 'flex', gap: '4px', marginBottom: '8px' } },
                    e('button', { 
                        onClick: expandAll,
                        style: { 
                            flex: 1, 
                            padding: '4px 6px', 
                            fontSize: '9px', 
                            background: 'rgba(255,255,255,0.1)', 
                            border: 'none', 
                            borderRadius: '4px', 
                            color: '#aaa', 
                            cursor: 'pointer' 
                        } 
                    }, 'Expand'),
                    e('button', { 
                        onClick: collapseAll,
                        style: { 
                            flex: 1, 
                            padding: '4px 6px', 
                            fontSize: '9px', 
                            background: 'rgba(255,255,255,0.1)', 
                            border: 'none', 
                            borderRadius: '4px', 
                            color: '#aaa', 
                            cursor: 'pointer' 
                        } 
                    }, 'Collapse')
                ),
                
                // Sort dropdown
                e('select', {
                    value: sortBy,
                    onChange: (ev) => setSortBy(ev.target.value),
                    style: {
                        width: '100%',
                        padding: '5px 8px',
                    fontSize: '10px',
                    background: 'rgba(255, 255, 255, 0.1)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    borderRadius: '6px',
                    color: '#fff',
                    cursor: 'pointer'
                }
            },
                e('option', { value: 'category', style: { background: '#1a1d24' } }, 'Sort: By Category'),
                e('option', { value: 'percentile-desc', style: { background: '#1a1d24' } }, 'Sort: Percentile '),
                e('option', { value: 'percentile-asc', style: { background: '#1a1d24' } }, 'Sort: Percentile ')
            )
        ),
        
        // Content
        groupedByCategory ? (
            // Grouped by category with expandable sections
            e('div', { style: { display: 'flex', flexDirection: 'column', gap: '6px' } },
                categories.map(cat => {
                    const isExpanded = expandedCategories.has(cat.name);
                    const catMetrics = allMetrics.filter(m => m.category === cat.name);
                    
                    return e('div', { 
                        key: cat.name,
                        style: { 
                            background: 'rgba(0, 0, 0, 0.2)',
                            borderRadius: '8px',
                            overflow: 'hidden'
                        }
                    },
                        // Category header
                        e('div', {
                            onClick: () => toggleCategory(cat.name),
                            style: {
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px',
                                padding: '8px 10px',
                                cursor: 'pointer',
                                background: `linear-gradient(90deg, ${cat.color}22 0%, transparent 100%)`,
                                borderLeft: `3px solid ${cat.color}`
                            }
                        },
                            e('span', { 
                                style: { 
                                    fontSize: '10px', 
                                    color: '#888',
                                    transform: isExpanded ? 'rotate(90deg)' : 'rotate(0deg)',
                                    transition: 'transform 0.2s'
                                } 
                            }, ''),
                            e('span', { 
                                style: { 
                                    fontSize: '10px', 
                                    fontWeight: '700', 
                                    color: cat.color,
                                    letterSpacing: '0.5px'
                                } 
                            }, cat.name),
                            e('span', { 
                                style: { 
                                    marginLeft: 'auto', 
                                    fontSize: '9px', 
                                    color: '#666' 
                                } 
                            }, catMetrics.length)
                        ),
                        
                        // Category metrics
                        isExpanded && e('div', { style: { padding: '4px 6px 8px 6px' } },
                            catMetrics.map((m, idx) => e('div', {
                                key: m.key,
                                style: {
                                    display: 'flex',
                                    alignItems: 'center',
                                    padding: '6px 8px',
                                    marginBottom: idx < catMetrics.length - 1 ? '2px' : 0,
                                    background: getPercentileBg(m.percentile),
                                    borderRadius: '6px',
                                    borderLeft: `2px solid ${getPercentileColor(m.percentile)}`
                                }
                            },
                                // Metric name
                                e('span', { 
                                    style: { 
                                        flex: 1, 
                                        fontSize: '10px', 
                                        color: '#ccc',
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    } 
                                }, m.label),
                                // Value
                                e('span', { 
                                    style: { 
                                        fontSize: '11px', 
                                        fontWeight: '600', 
                                        color: '#fff',
                                        fontFamily: 'JetBrains Mono, monospace',
                                        minWidth: '40px',
                                        textAlign: 'right',
                                        marginRight: '8px'
                                    } 
                                }, formatValue(m.value, m.format)),
                                // Percentile badge
                                e('span', {
                                    style: {
                                        fontSize: '9px',
                                        fontWeight: '700',
                                        color: getPercentileColor(m.percentile),
                                        background: 'rgba(0,0,0,0.3)',
                                        padding: '2px 5px',
                                        borderRadius: '4px',
                                        minWidth: '28px',
                                        textAlign: 'center'
                                    }
                                }, m.percentile !== null && m.percentile !== undefined && m.percentile !== -1 
                                    ? m.percentile.toFixed(0) 
                                    : '-')
                            ))
                        )
                    );
                })
            )
        ) : (
            // Flat sorted list
            e('div', { style: { display: 'flex', flexDirection: 'column', gap: '2px' } },
                sortedMetrics.map((m, idx) => e('div', {
                    key: m.key + idx,
                    style: {
                        display: 'flex',
                        alignItems: 'center',
                        padding: '6px 8px',
                        background: getPercentileBg(m.percentile),
                        borderRadius: '6px',
                        borderLeft: `2px solid ${getPercentileColor(m.percentile)}`
                    }
                },
                    // Category dot
                    e('div', {
                        style: {
                            width: '6px',
                            height: '6px',
                            borderRadius: '50%',
                            background: m.categoryColor,
                            marginRight: '6px',
                            flexShrink: 0
                        }
                    }),
                    // Metric name
                    e('span', { 
                        style: { 
                            flex: 1, 
                            fontSize: '10px', 
                            color: '#ccc',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            whiteSpace: 'nowrap'
                        } 
                    }, m.label),
                    // Value
                    e('span', { 
                        style: { 
                            fontSize: '11px', 
                            fontWeight: '600', 
                            color: '#fff',
                            fontFamily: 'JetBrains Mono, monospace',
                            minWidth: '40px',
                            textAlign: 'right',
                            marginRight: '8px'
                        } 
                    }, formatValue(m.value, m.format)),
                    // Percentile badge
                    e('span', {
                        style: {
                            fontSize: '9px',
                            fontWeight: '700',
                            color: getPercentileColor(m.percentile),
                            background: 'rgba(0,0,0,0.3)',
                            padding: '2px 5px',
                            borderRadius: '4px',
                            minWidth: '28px',
                            textAlign: 'center'
                        }
                    }, m.percentile !== null && m.percentile !== undefined && m.percentile !== -1 
                        ? m.percentile.toFixed(0) 
                        : '-')
                ))
            )
        ))
    );
}

// Comprehensive Circular Barplot Component - Category-Grouped Radial Bars
function HexRadarChart({ metrics, size = 580, roleInfo = null, rolePools = null, dynamicScales = null, radarPercentiles = null }) {
    if (!metrics) return e('div', { className: 'radar-container' }, 'Loading metrics...');
    
    // Large canvas for clean label spacing
    const actualSize = 950;
    const centerX = actualSize / 2;
    const centerY = actualSize / 2;
    const innerRadius = actualSize * 0.025;  // Much smaller inner hole
    const maxBarLength = actualSize * 0.28;  // Longer bars to compensate
    const outerRadius = innerRadius + maxBarLength;
    
    // Category definitions with colors - metrics ordered by category
    const categories = [
        { name: 'OVERALL', color: '#818cf8', metrics: ['totalPPP', 'tsPct', 'ftRate', 'usagePct'] },
        { name: 'CREATION', color: '#f472b6', metrics: ['onBallVol75', 'onBallPPP', 'rimPressure', 'rimToMidRatio', 'onBallPassPct'] },
        { name: 'PLAYMAKING', color: '#a78bfa', metrics: ['astUsgRatio', 'toPct'] },
        { name: 'SPACING', color: '#22d3ee', metrics: ['shootingValue', 'fg3Att75', 'spacingVol75', 'spacingPPP'] },
        { name: 'SLASHING', color: '#fb923c', metrics: ['drives75', 'drivesPPP'] },
        { name: 'FINISHING', color: '#facc15', metrics: ['finishingVol75', 'finishingPPP'] },
        { name: 'PERIMETER D', color: '#34d399', metrics: ['onBallDef75', 'onBallDefPPP'] },
        { name: 'POST D', color: '#4ade80', metrics: ['postDef75', 'postDefPPP'] },
        { name: 'DISRUPTION', color: '#f87171', metrics: ['defTOPct', 'stl75', 'blk75'] },
        { name: 'REBOUNDING', color: '#94a3b8', metrics: ['oreb75', 'dreb75'] }
    ];
    
    // Build ordered metrics list from categories
    const radarMetricsBase = [];
    const categoryArcs = []; // Track where each category starts/ends
    let currentIndex = 0;
    
    categories.forEach(cat => {
        const startIdx = currentIndex;
        cat.metrics.forEach(key => {
            const metricDef = {
                'totalPPP': { label: 'PPP', format: 'ppp', inverse: false },
                'tsPct': { label: 'TS%', format: 'pct', inverse: false },
                'ftRate': { label: 'FT Rate', format: 'pct', inverse: false },
                'usagePct': { label: 'Usage', format: 'pct', inverse: false },
                'onBallVol75': { label: 'Creation/75', format: 'dec', inverse: false },
                'onBallPPP': { label: 'Creation PPP', format: 'ppp', inverse: false },
                'onBallPct': { label: 'OnBall%', format: 'pct', inverse: false },
                'offBallPct': { label: 'OffBall%', format: 'pct', inverse: false },
                'rimPressure': { label: 'Rim Press', format: 'int', inverse: false },
                'rimToMidRatio': { label: 'Rim:Mid', format: 'dec', inverse: false },
                'onBallPassPct': { label: 'Pass%', format: 'pct', inverse: false },
                'astUsgRatio': { label: 'AST/USG', format: 'dec', inverse: false },
                'toPct': { label: 'TO%', format: 'pct', inverse: true },
                'shootingValue': { label: 'Shot Val', format: 'int', inverse: false },
                'fg3Att75': { label: '3PA/75', format: 'dec', inverse: false },
                'spacingVol75': { label: 'Space/75', format: 'dec', inverse: false },
                'spacingPPP': { label: 'Space PPP', format: 'ppp', inverse: false },
                'drives75': { label: 'Drives/75', format: 'dec', inverse: false },
                'drivesPPP': { label: 'Drives PPP', format: 'ppp', inverse: false },
                'finishingVol75': { label: 'Finish/75', format: 'dec', inverse: false },
                'finishingPPP': { label: 'Finish PPP', format: 'ppp', inverse: false },
                'onBallDef75': { label: 'OnBallD/75', format: 'dec', inverse: false },
                'onBallDefPPP': { label: 'OnBallD PPP', format: 'ppp', inverse: true },
                'postDef75': { label: 'PostD/75', format: 'dec', inverse: false },
                'postDefPPP': { label: 'PostD PPP', format: 'ppp', inverse: true },
                'defTOPct': { label: 'Def TO%', format: 'pct', inverse: false },
                'stl75': { label: 'STL/75', format: 'dec', inverse: false },
                'blk75': { label: 'BLK/75', format: 'dec', inverse: false },
                'oreb75': { label: 'OREB/75', format: 'dec', inverse: false },
                'dreb75': { label: 'DREB/75', format: 'dec', inverse: false }
            }[key];
            
            radarMetricsBase.push({
                key,
                ...metricDef,
                category: cat.name,
                categoryColor: cat.color
            });
            currentIndex++;
        });
        categoryArcs.push({
            name: cat.name,
            color: cat.color,
            startIdx,
            endIdx: currentIndex - 1,
            count: cat.metrics.length
        });
    });
    
    const numPoints = radarMetricsBase.length;
    const angleStep = (Math.PI * 2) / numPoints;
    const barWidth = angleStep * 0.7; // Bar width as portion of angle step
    const gapWidth = angleStep * 0.3; // Gap between bars
    
    // Format value based on type
    const formatValue = (value, format) => {
        if (value === null || value === undefined) return '-';
        switch(format) {
            case 'ppp': return value.toFixed(2);
            case 'pct': return value.toFixed(0) + '%';
            case 'dec': return value.toFixed(1);
            case 'int': return Math.round(value).toString();
            default: return value.toFixed(1);
        }
    };
    
    // Get color based on percentile
    const getPercentileColor = (pct) => {
        if (pct === null || pct === undefined) return 'rgba(100, 116, 139, 0.6)';
        if (pct === -1) return 'rgba(148, 163, 184, 0.9)';
        if (pct >= 90) return '#22c55e';
        if (pct >= 75) return '#84cc16';
        if (pct >= 60) return '#a3e635';
        if (pct >= 40) return '#fbbf24';
        if (pct >= 25) return '#fb923c';
        return '#ef4444';
    };
    
    // Get glow color based on percentile
    const getGlowColor = (pct) => {
        if (pct === null || pct === undefined) return 'rgba(100, 116, 139, 0.3)';
        if (pct === -1) return 'rgba(148, 163, 184, 0.3)';
        if (pct >= 90) return 'rgba(34, 197, 94, 0.5)';
        if (pct >= 75) return 'rgba(132, 204, 22, 0.5)';
        if (pct >= 60) return 'rgba(163, 230, 53, 0.4)';
        if (pct >= 40) return 'rgba(251, 191, 36, 0.4)';
        if (pct >= 25) return 'rgba(251, 146, 60, 0.4)';
        return 'rgba(239, 68, 68, 0.4)';
    };
    
    // Calculate bar data
    const barData = radarMetricsBase.map((m, i) => {
        let value = metrics[m.key];
        if (value === null || value === undefined) value = 0;
        
        const pct = radarPercentiles?.[m.key];
        
        let normalizedValue;
        if (pct !== null && pct !== undefined && !isNaN(pct) && pct >= 0) {
            normalizedValue = Math.max(0.08, pct / 100); // Minimum bar length for visibility
        } else if (pct === -1) {
            normalizedValue = 0.5;
        } else {
            normalizedValue = 0.15; // Low value for null percentiles
        }
        
        const barLength = normalizedValue * maxBarLength;
        const angle = i * angleStep - Math.PI / 2;
        
        return {
            key: m.key,
            label: m.label,
            format: m.format,
            rawValue: metrics[m.key],
            normalizedValue,
            barLength,
            angle,
            percentile: pct,
            color: getPercentileColor(pct),
            glowColor: getGlowColor(pct),
            categoryColor: m.categoryColor,
            category: m.category
        };
    });
    
    // Create arc path for a bar
    const createBarPath = (startAngle, barLength, barWidthAngle) => {
        const halfWidth = barWidthAngle / 2;
        const innerR = innerRadius;
        const outerR = innerRadius + barLength;
        
        const x1 = centerX + Math.cos(startAngle - halfWidth) * innerR;
        const y1 = centerY + Math.sin(startAngle - halfWidth) * innerR;
        const x2 = centerX + Math.cos(startAngle + halfWidth) * innerR;
        const y2 = centerY + Math.sin(startAngle + halfWidth) * innerR;
        const x3 = centerX + Math.cos(startAngle + halfWidth) * outerR;
        const y3 = centerY + Math.sin(startAngle + halfWidth) * outerR;
        const x4 = centerX + Math.cos(startAngle - halfWidth) * outerR;
        const y4 = centerY + Math.sin(startAngle - halfWidth) * outerR;
        
        const largeArc = barWidthAngle > Math.PI ? 1 : 0;
        
        return `M ${x1} ${y1} 
                A ${innerR} ${innerR} 0 ${largeArc} 1 ${x2} ${y2}
                L ${x3} ${y3}
                A ${outerR} ${outerR} 0 ${largeArc} 0 ${x4} ${y4}
                Z`;
    };
    
    // Create category arc at outer edge
    const createCategoryArc = (cat) => {
        const startAngle = cat.startIdx * angleStep - Math.PI / 2 - angleStep * 0.4;
        const endAngle = (cat.endIdx + 1) * angleStep - Math.PI / 2 - angleStep * 0.6;
        const arcRadius = outerRadius + 15;
        
        const x1 = centerX + Math.cos(startAngle) * arcRadius;
        const y1 = centerY + Math.sin(startAngle) * arcRadius;
        const x2 = centerX + Math.cos(endAngle) * arcRadius;
        const y2 = centerY + Math.sin(endAngle) * arcRadius;
        
        const largeArc = (endAngle - startAngle) > Math.PI ? 1 : 0;
        
        return `M ${x1} ${y1} A ${arcRadius} ${arcRadius} 0 ${largeArc} 1 ${x2} ${y2}`;
    };
    
    // Create translucent category background wedge
    const createCategoryBackground = (cat) => {
        const startAngle = cat.startIdx * angleStep - Math.PI / 2 - angleStep * 0.35;
        const endAngle = (cat.endIdx + 1) * angleStep - Math.PI / 2 - angleStep * 0.65;
        const innerR = innerRadius;
        const outerR = outerRadius + 8;
        
        const x1 = centerX + Math.cos(startAngle) * innerR;
        const y1 = centerY + Math.sin(startAngle) * innerR;
        const x2 = centerX + Math.cos(endAngle) * innerR;
        const y2 = centerY + Math.sin(endAngle) * innerR;
        const x3 = centerX + Math.cos(endAngle) * outerR;
        const y3 = centerY + Math.sin(endAngle) * outerR;
        const x4 = centerX + Math.cos(startAngle) * outerR;
        const y4 = centerY + Math.sin(startAngle) * outerR;
        
        const largeArc = (endAngle - startAngle) > Math.PI ? 1 : 0;
        
        return `M ${x1} ${y1} 
                A ${innerR} ${innerR} 0 ${largeArc} 1 ${x2} ${y2}
                L ${x3} ${y3}
                A ${outerR} ${outerR} 0 ${largeArc} 0 ${x4} ${y4}
                Z`;
    };
    
    return e('div', { 
        className: 'radar-container',
        style: { 
            width: '100%', 
            display: 'flex', 
            flexDirection: 'column',
            alignItems: 'center',
            padding: '16px 0',
            background: 'rgba(0, 0, 0, 0.4)',
            borderRadius: '12px'
        }
    },
        // Legend at top
        e('div', {
            style: {
                display: 'flex',
                flexWrap: 'wrap',
                justifyContent: 'center',
                gap: '8px',
                marginBottom: '12px',
                padding: '8px 16px'
            }
        },
            categories.map(cat => e('div', {
                key: cat.name,
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '4px',
                    padding: '3px 8px',
                    background: `${cat.color}22`,
                    borderRadius: '4px',
                    border: `1px solid ${cat.color}44`
                }
            },
                e('div', {
                    style: {
                        width: '8px',
                        height: '8px',
                        borderRadius: '2px',
                        background: cat.color
                    }
                }),
                e('span', {
                    style: {
                        fontSize: '9px',
                        fontWeight: '600',
                        color: cat.color,
                        letterSpacing: '0.3px'
                    }
                }, cat.name)
            ))
        ),
        
        // Circular Barplot SVG
        e('svg', { 
            className: 'radar-svg',
            viewBox: `0 0 ${actualSize} ${actualSize}`,
            width: '100%',
            preserveAspectRatio: 'xMidYMid meet',
            style: { maxWidth: actualSize + 'px', height: 'auto' }
        },
            // Gradient and filter definitions
            e('defs', null,
                // Individual bar gradients for each percentile tier
                e('linearGradient', { id: 'barGradElite', x1: '0%', y1: '0%', x2: '100%', y2: '0%' },
                    e('stop', { offset: '0%', stopColor: 'rgba(34, 197, 94, 0.9)' }),
                    e('stop', { offset: '100%', stopColor: 'rgba(34, 197, 94, 0.6)' })
                ),
                e('linearGradient', { id: 'barGradGreat', x1: '0%', y1: '0%', x2: '100%', y2: '0%' },
                    e('stop', { offset: '0%', stopColor: 'rgba(132, 204, 22, 0.9)' }),
                    e('stop', { offset: '100%', stopColor: 'rgba(132, 204, 22, 0.6)' })
                ),
                e('linearGradient', { id: 'barGradGood', x1: '0%', y1: '0%', x2: '100%', y2: '0%' },
                    e('stop', { offset: '0%', stopColor: 'rgba(163, 230, 53, 0.9)' }),
                    e('stop', { offset: '100%', stopColor: 'rgba(163, 230, 53, 0.6)' })
                ),
                e('linearGradient', { id: 'barGradAvg', x1: '0%', y1: '0%', x2: '100%', y2: '0%' },
                    e('stop', { offset: '0%', stopColor: 'rgba(251, 191, 36, 0.9)' }),
                    e('stop', { offset: '100%', stopColor: 'rgba(251, 191, 36, 0.6)' })
                ),
                e('linearGradient', { id: 'barGradBelow', x1: '0%', y1: '0%', x2: '100%', y2: '0%' },
                    e('stop', { offset: '0%', stopColor: 'rgba(251, 146, 60, 0.9)' }),
                    e('stop', { offset: '100%', stopColor: 'rgba(251, 146, 60, 0.6)' })
                ),
                e('linearGradient', { id: 'barGradPoor', x1: '0%', y1: '0%', x2: '100%', y2: '0%' },
                    e('stop', { offset: '0%', stopColor: 'rgba(239, 68, 68, 0.9)' }),
                    e('stop', { offset: '100%', stopColor: 'rgba(239, 68, 68, 0.6)' })
                ),
                // Glow filter for bars
                e('filter', { id: 'barGlow', x: '-50%', y: '-50%', width: '200%', height: '200%' },
                    e('feGaussianBlur', { stdDeviation: '3', result: 'coloredBlur' }),
                    e('feMerge', null,
                        e('feMergeNode', { in: 'coloredBlur' }),
                        e('feMergeNode', { in: 'SourceGraphic' })
                    )
                ),
                // Stronger glow for high percentiles
                e('filter', { id: 'strongGlow', x: '-50%', y: '-50%', width: '200%', height: '200%' },
                    e('feGaussianBlur', { stdDeviation: '5', result: 'coloredBlur' }),
                    e('feMerge', null,
                        e('feMergeNode', { in: 'coloredBlur' }),
                        e('feMergeNode', { in: 'SourceGraphic' })
                    )
                )
            ),
            
            // Background circle (outer)
            e('circle', {
                cx: centerX,
                cy: centerY,
                r: outerRadius + 20,
                fill: 'rgba(0, 0, 0, 0.3)'
            }),
            
            // Percentile reference rings
            [0.25, 0.5, 0.75, 1].map((pct, i) => {
                const r = innerRadius + (pct * maxBarLength);
                return e('circle', {
                    key: `ring-${i}`,
                    cx: centerX,
                    cy: centerY,
                    r: r,
                    fill: 'none',
                    stroke: i === 3 ? 'rgba(255, 255, 255, 0.25)' : 'rgba(255, 255, 255, 0.1)',
                    strokeWidth: i === 3 ? 1.5 : 1,
                    strokeDasharray: i < 3 ? '4,8' : 'none'
                });
            }),
            
            // Tiny inner circle
            e('circle', {
                cx: centerX,
                cy: centerY,
                r: innerRadius,
                fill: 'rgba(10, 12, 16, 0.95)',
                stroke: 'rgba(255, 255, 255, 0.15)',
                strokeWidth: 1
            }),
            
            // Translucent category background wedges
            categoryArcs.map((cat, i) =>
                e('path', {
                    key: `cat-bg-${i}`,
                    d: createCategoryBackground(cat),
                    fill: cat.color,
                    opacity: 0.08
                })
            ),
            
            // Category arc segments (outer colored ring)
            categoryArcs.map((cat, i) =>
                e('path', {
                    key: `cat-arc-${i}`,
                    d: createCategoryArc(cat),
                    fill: 'none',
                    stroke: cat.color,
                    strokeWidth: 6,
                    strokeLinecap: 'round',
                    opacity: 0.7
                })
            ),
            
            // Bars
            barData.map((bar, i) => {
                const pct = bar.percentile;
                const useStrongGlow = pct !== null && pct >= 75;
                
                return e('path', {
                    key: `bar-${i}`,
                    d: createBarPath(bar.angle, bar.barLength, barWidth),
                    fill: bar.color,
                    stroke: 'rgba(255, 255, 255, 0.3)',
                    strokeWidth: 0.5,
                    filter: useStrongGlow ? 'url(#strongGlow)' : 'url(#barGlow)',
                    style: { transition: 'all 0.3s ease' }
                });
            }),
            
            // Labels around the outside
            barData.map((bar, i) => {
                const angle = bar.angle;
                const angleDeg = (angle * 180 / Math.PI + 360) % 360;
                const value = bar.rawValue;
                const displayValue = formatValue(value, bar.format);
                const pct = bar.percentile;
                const color = bar.color;
                
                // Label position (outside the bars)
                const labelR = outerRadius + 45;
                const labelX = centerX + Math.cos(angle) * labelR;
                const labelY = centerY + Math.sin(angle) * labelR;
                
                // Text alignment based on angle
                let textAnchor;
                if (angleDeg >= 350 || angleDeg < 10) {
                    textAnchor = 'middle';
                } else if (angleDeg >= 10 && angleDeg < 170) {
                    textAnchor = 'start';
                } else if (angleDeg >= 170 && angleDeg < 190) {
                    textAnchor = 'middle';
                } else {
                    textAnchor = 'end';
                }
                
                // Rotate text to follow the radial direction
                const textRotation = angleDeg > 90 && angleDeg < 270 ? angleDeg + 180 : angleDeg;
                
                return e('g', { key: `label-${i}` },
                    // Connector line
                    e('line', {
                        x1: centerX + Math.cos(angle) * (innerRadius + bar.barLength + 3),
                        y1: centerY + Math.sin(angle) * (innerRadius + bar.barLength + 3),
                        x2: centerX + Math.cos(angle) * (labelR - 15),
                        y2: centerY + Math.sin(angle) * (labelR - 15),
                        stroke: bar.categoryColor,
                        strokeWidth: 1,
                        opacity: 0.4
                    }),
                    
                    // Label text
                    e('text', {
                        x: labelX,
                        y: labelY - 6,
                        textAnchor,
                        dominantBaseline: 'middle',
                        fill: bar.categoryColor,
                        fontSize: '10px',
                        fontWeight: '600',
                        fontFamily: 'Sora, sans-serif'
                    }, bar.label),
                    
                    // Value + Percentile
                    e('text', {
                        x: labelX,
                        y: labelY + 8,
                        textAnchor,
                        dominantBaseline: 'middle',
                        fill: color,
                        fontSize: '9px',
                        fontWeight: '700',
                        fontFamily: 'JetBrains Mono, monospace'
                    }, pct !== null && pct !== undefined && pct >= 0 ? 
                        `${displayValue} (${Math.round(pct)})` : 
                        displayValue
                    )
                );
            })
        ),
        
        // Percentile scale legend at bottom
        e('div', {
            style: {
                display: 'flex',
                justifyContent: 'center',
                gap: '16px',
                marginTop: '12px',
                padding: '8px 16px',
                background: 'rgba(0, 0, 0, 0.2)',
                borderRadius: '6px'
            }
        },
            [
                { label: 'Elite 90+', color: '#22c55e' },
                { label: 'Great 75+', color: '#84cc16' },
                { label: 'Good 60+', color: '#a3e635' },
                { label: 'Avg 40+', color: '#fbbf24' },
                { label: 'Below 25+', color: '#fb923c' },
                { label: 'Poor <25', color: '#ef4444' }
            ].map(item => e('div', {
                key: item.label,
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '4px'
                }
            },
                e('div', {
                    style: {
                        width: '10px',
                        height: '10px',
                        borderRadius: '2px',
                        background: item.color
                    }
                }),
                e('span', {
                    style: {
                        fontSize: '9px',
                        color: 'var(--text-secondary)',
                        fontWeight: '500'
                    }
                }, item.label)
            ))
        )
    );
}

// Simple Bar Chart Component for scout sections
function ScoutBarChart({ data }) {
    const maxVal = Math.max(...data.map(d => d.value), 1);
    
    return e('div', { className: 'scout-bar-chart' },
        data.map((item, i) =>
            e('div', { 
                key: i, 
                className: 'scout-bar-item',
                style: { background: 'rgba(0,0,0,0.3)' }
            },
                e('div', {
                    className: `scout-bar-fill ${item.color || 'yellow'}`,
                    style: { width: `${(item.value / maxVal) * 100}%` }
                }, item.label)
            )
        )
    );
}

// Calculate percentile for a value within an array
// Calculate possession/attempt-weighted percentile
// Uses pro-level physics: higher volume players have more influence on distribution
// Prevents low-volume outliers from skewing percentiles
function calculateWeightedPercentile(playerValue, playerWeight, allData, inverse = false) {
    // allData = [{value, weight}, ...]
    if (playerValue === null || playerValue === undefined || !allData || allData.length < 3) return null;
    
    // Filter valid data with positive weights
    const validData = allData.filter(d => 
        d.value !== null && d.value !== undefined && !isNaN(d.value) && d.weight > 0
    );
    
    if (validData.length < 3) return null;
    
    // Sort by value (ascending for normal, descending for inverse)
    const sorted = [...validData].sort((a, b) => 
        inverse ? b.value - a.value : a.value - b.value
    );
    
    // Calculate total weight and cumulative weight below player's value
    const totalWeight = sorted.reduce((sum, d) => sum + d.weight, 0);
    if (totalWeight === 0) return null;
    
    let weightBelow = 0;
    let weightEqual = 0;
    
    for (const d of sorted) {
        if (inverse) {
            if (d.value > playerValue) weightBelow += d.weight;
            else if (d.value === playerValue) weightEqual += d.weight;
        } else {
            if (d.value < playerValue) weightBelow += d.weight;
            else if (d.value === playerValue) weightEqual += d.weight;
        }
    }
    
    // Use midpoint of equal values for more accurate percentile
    const percentile = ((weightBelow + (weightEqual / 2)) / totalWeight) * 100;
    return Math.min(100, Math.max(0, percentile));
}

// Simple unweighted percentile (fallback)
function calculateRadarPercentile(value, allValues, inverse = false) {
    if (value === null || value === undefined || !allValues || allValues.length < 3) return null;
    
    const validValues = allValues.filter(v => v !== null && v !== undefined && !isNaN(v));
    if (validValues.length < 3) return null;
    
    const sorted = [...validValues].sort((a, b) => inverse ? b - a : a - b);
    const rank = sorted.filter(v => inverse ? v > value : v < value).length;
    return (rank / sorted.length) * 100;
}

// Calculate all radar percentiles for a player (with weighted percentiles)
function calculateAllRadarPercentiles(playerMetrics, allRadarMetrics, roleMetrics = null, minRoleSamples = 10) {
    if (!playerMetrics || !allRadarMetrics || allRadarMetrics.length === 0) return {};
    
    // Use role-specific data if available (10+ players), otherwise league-wide
    const metricsPool = (roleMetrics && roleMetrics.length >= minRoleSamples) ? roleMetrics : allRadarMetrics;
    
    // Same weighting scheme as precomputeAllPlayerData
    // volumeKey + minVolume: the per-75 metric that must meet minimum for this metric to count
    // If player is at 80%+ of threshold but below threshold, they get 0th percentile
    // If player is below 80% of threshold, they get null (dimmed)
    const radarMetricKeys = [
        { key: 'totalPPP', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'tsPct', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'ftRate', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'usagePct', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'onBallVol75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'onBallPPP', inverse: false, weightKey: '_onBallPoss', minWeight: 20, volumeKey: 'onBallVol75', minVolume: 3 },
        { key: 'onBallPct', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'offBallPct', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'shootingValue', inverse: false, weightKey: '_shooting3Att', minWeight: 15, volumeKey: 'fg3Att75', minVolume: 2 },
        { key: 'rimPressure', inverse: false, weightKey: '_onBallPoss', minWeight: 20 },
        { key: 'fg3Att75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'rimToMidRatio', inverse: false, weightKey: '_total2FgAtt', minWeight: 15 },
        { key: 'onBallPassPct', inverse: false, weightKey: '_onBallPoss', minWeight: 20, volumeKey: 'onBallIncl75', minVolume: 4 },
        { key: 'astUsgRatio', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'toPct', inverse: true, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'spacingVol75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'spacingPPP', inverse: false, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'spacingVol75', minVolume: 3 },
        { key: 'drives75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'drivesPPP', inverse: false, weightKey: '_drivesPoss', minWeight: 15 },
        { key: 'finishingVol75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'finishingPPP', inverse: false, weightKey: '_finishingPoss', minWeight: 15, volumeKey: 'finishingVol75', minVolume: 1 },
        { key: 'onBallDef75', inverse: false, weightKey: '_totalDefPoss', minWeight: 20 },
        { key: 'onBallDefPPP', inverse: true, weightKey: '_onBallDefPoss', minWeight: 15, volumeKey: 'onBallDef75', minVolume: 3 },
        { key: 'postDef75', inverse: false, weightKey: '_totalDefPoss', minWeight: 20 },
        { key: 'postDefPPP', inverse: true, weightKey: '_postDefPoss', minWeight: 10, volumeKey: 'postDef75', minVolume: 1 },
        { key: 'defTOPct', inverse: false, weightKey: '_totalDefPoss', minWeight: 20 },
        { key: 'stl75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'blk75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'oreb75', inverse: false, weightKey: 'totalPoss', minWeight: 50 },
        { key: 'dreb75', inverse: false, weightKey: 'totalPoss', minWeight: 50 }
    ];
    
    const percentiles = {};
    
    radarMetricKeys.forEach(({ key, inverse, weightKey, minWeight, volumeKey, minVolume }) => {
        const playerValue = playerMetrics[key];
        const playerWeight = playerMetrics[weightKey] || playerMetrics.totalPoss || 100;
        
        // Check volume threshold for dependent metrics
        // Three states: meets threshold (normal), 80%+ of threshold (gray, no pct), below 80% (null/dimmed)
        const playerVolumeValue = volumeKey ? playerMetrics[volumeKey] : null;
        const meetsVolumeThreshold = !volumeKey || (playerVolumeValue !== null && playerVolumeValue >= minVolume);
        const meetsPartialThreshold = !volumeKey || (playerVolumeValue !== null && playerVolumeValue >= minVolume * 0.8);
        
        // Build weighted data array with minimum threshold AND volume threshold
        const weightedData = metricsPool
            .filter(m => {
                const w = m[weightKey] || m.totalPoss || 0;
                const v = m[key];
                // Also check volume threshold for pool members
                const poolVolumeValue = volumeKey ? m[volumeKey] : null;
                const poolMeetsVolume = !volumeKey || (poolVolumeValue !== null && poolVolumeValue >= minVolume);
                return w >= minWeight && v !== null && v !== undefined && !isNaN(v) && poolMeetsVolume;
            })
            .map(m => ({
                value: m[key],
                weight: m[weightKey] || m.totalPoss || 100
            }));
        
        // Debug logging for finishingPPP
        if (key === 'finishingPPP') {
            console.log(`finishingPPP check: playerValue=${playerValue?.toFixed(2)}, volumeKey=${volumeKey}, volumeValue=${playerVolumeValue?.toFixed(2)}, minVolume=${minVolume}, meetsThreshold=${meetsVolumeThreshold}, meetsPartial=${meetsPartialThreshold}, poolSize=${weightedData.length}`);
        }
        
        // Debug logging for defTOPct
        if (key === 'defTOPct') {
            const sortedPool = weightedData.map(d => d.value).sort((a,b) => a-b);
            console.log(`defTOPct check: playerValue=${playerValue?.toFixed(2)}, playerWeight=${playerWeight}, poolSize=${weightedData.length}`);
            if (sortedPool.length > 0) {
                console.log(`  Pool range: ${sortedPool[0]?.toFixed(2)} - ${sortedPool[sortedPool.length-1]?.toFixed(2)}, median=${sortedPool[Math.floor(sortedPool.length/2)]?.toFixed(2)}`);
            }
        }
        
        if (playerWeight < minWeight || playerValue === null || playerValue === undefined || weightedData.length < 3) {
            percentiles[key] = null;
        } else if (!meetsPartialThreshold) {
            // Below 80% of volume threshold - dim completely
            percentiles[key] = null;
        } else if (!meetsVolumeThreshold) {
            // Between 80% and 100% of threshold - show gray text, no percentile number
            percentiles[key] = -1;
        } else {
            percentiles[key] = calculateWeightedPercentile(playerValue, playerWeight, weightedData, inverse);
        }
    });
    
    return percentiles;
}

// Radar Leaderboard Component
function RadarLeaderboard({ 
    allRadarMetrics, 
    roleGroupedMetrics,
    playerLookup, // Precomputed player data
    selectedPlayer, 
    onPlayerSelect, 
    playerRoleInfo 
}) {
    const [selectedStat, setSelectedStat] = useState('totalPPP');
    const [minPoss, setMinPoss] = useState(100);
    const [showLeaderboard, setShowLeaderboard] = useState(false);
    const [useRoleFilter, setUseRoleFilter] = useState(false);
    
    const statOptions = [
        { key: 'totalPPP', label: 'Total PPP', format: 'ppp', inverse: false },
        { key: 'tsPct', label: 'TS%', format: 'pct', inverse: false },
        { key: 'ftRate', label: 'FT Rate', format: 'pct', inverse: false },
        { key: 'usagePct', label: 'Usage%', format: 'pct', inverse: false },
        { key: 'onBallVol75', label: 'Creation/75', format: 'dec', inverse: false },
        { key: 'onBallPPP', label: 'Creation PPP', format: 'ppp', inverse: false },
        { key: 'onBallPct', label: 'OnBall%', format: 'pct', inverse: false },
        { key: 'offBallPct', label: 'OffBall%', format: 'pct', inverse: false },
        { key: 'shootingValue', label: 'Shoot Value', format: 'int', inverse: false },
        { key: 'rimPressure', label: 'Rim Pressure', format: 'int', inverse: false },
        { key: 'fg3Att75', label: '3PA/75', format: 'dec', inverse: false },
        { key: 'rimToMidRatio', label: 'Rim:Mid', format: 'dec', inverse: false },
        { key: 'onBallPassPct', label: 'Pass%', format: 'pct', inverse: false },
        { key: 'astUsgRatio', label: 'AST/USG', format: 'dec', inverse: false },
        { key: 'toPct', label: 'TO%', format: 'pct', inverse: true },
        { key: 'spacingVol75', label: 'Space/75', format: 'dec', inverse: false },
        { key: 'spacingPPP', label: 'Space PPP', format: 'ppp', inverse: false },
        { key: 'drives75', label: 'Drives/75', format: 'dec', inverse: false },
        { key: 'drivesPPP', label: 'Drives PPP', format: 'ppp', inverse: false },
        { key: 'finishingVol75', label: 'Finish/75', format: 'dec', inverse: false },
        { key: 'finishingPPP', label: 'Finish PPP', format: 'ppp', inverse: false },
        { key: 'onBallDef75', label: 'OnBallD/75', format: 'dec', inverse: false },
        { key: 'onBallDefPPP', label: 'OnBallD PPP', format: 'ppp', inverse: true },
        { key: 'postDef75', label: 'PostD/75', format: 'dec', inverse: false },
        { key: 'postDefPPP', label: 'PostD PPP', format: 'ppp', inverse: true },
        { key: 'defTOPct', label: 'Def TO%', format: 'pct', inverse: false },
        { key: 'stl75', label: 'STL/75', format: 'dec', inverse: false },
        { key: 'blk75', label: 'BLK/75', format: 'dec', inverse: false },
        { key: 'oreb75', label: 'OREB/75', format: 'dec', inverse: false },
        { key: 'dreb75', label: 'DREB/75', format: 'dec', inverse: false }
    ];
    
    const selectedStatInfo = statOptions.find(s => s.key === selectedStat) || statOptions[0];
    
    // Get filtered and sorted players
    const leaderboardData = useMemo(() => {
        if (!allRadarMetrics || allRadarMetrics.length === 0) return [];
        
        // Choose pool based on role filter
        let pool = allRadarMetrics;
        if (useRoleFilter && playerRoleInfo && roleGroupedMetrics) {
            const roleId = playerRoleInfo.role?.id;
            if (roleId && roleGroupedMetrics[roleId] && roleGroupedMetrics[roleId].length >= 5) {
                pool = roleGroupedMetrics[roleId];
            }
        }
        
        // Filter by min poss and valid stat value
        const filtered = pool.filter(p => 
            p.totalPoss >= minPoss && 
            p[selectedStat] !== null && 
            p[selectedStat] !== undefined &&
            !isNaN(p[selectedStat])
        );
        
        // Sort by selected stat (descending, unless inverse)
        const sorted = [...filtered].sort((a, b) => 
            selectedStatInfo.inverse ? a[selectedStat] - b[selectedStat] : b[selectedStat] - a[selectedStat]
        );
        
        // Add precomputed percentile for the selected stat to each entry
        return sorted.slice(0, 20).map(p => {
            const key = `${p.player}|${p.season}`;
            const precomputed = playerLookup?.[key];
            const percentile = precomputed?.percentiles?.leagueWide?.[selectedStat] ?? null;
            return { ...p, precomputedPercentile: percentile };
        });
    }, [allRadarMetrics, roleGroupedMetrics, selectedStat, minPoss, useRoleFilter, playerRoleInfo, selectedStatInfo, playerLookup]);
    
    // Format value
    const formatValue = (value, format) => {
        if (value === null || value === undefined) return '-';
        switch(format) {
            case 'ppp': return value.toFixed(2);
            case 'pct': return value.toFixed(1) + '%';
            case 'dec': return value.toFixed(1);
            case 'int': return Math.round(value).toString();
            default: return value.toFixed(1);
        }
    };
    
    // Get percentile color - works with both rank-based and precomputed percentile
    const getPercentileColor = (pct) => {
        if (pct >= 90) return '#22c55e';
        if (pct >= 75) return '#84cc16';
        if (pct >= 60) return '#a3e635';
        if (pct >= 40) return '#fbbf24';
        if (pct >= 25) return '#fb923c';
        return '#ef4444';
    };
    
    const roleCount = playerRoleInfo && roleGroupedMetrics?.[playerRoleInfo.role?.id]?.length || 0;
    
    return e('div', { className: 'radar-leaderboard-container' },
        // Toggle button
        e('button', {
            className: 'leaderboard-toggle',
            onClick: () => setShowLeaderboard(!showLeaderboard),
            style: {
                background: 'linear-gradient(135deg, var(--accent-indigo), var(--accent-purple))',
                border: 'none',
                borderRadius: '8px',
                padding: '8px 16px',
                color: 'white',
                cursor: 'pointer',
                fontSize: '12px',
                fontWeight: '600',
                display: 'flex',
                alignItems: 'center',
                gap: '6px',
                marginBottom: '10px'
            }
        }, 
            e('span', null, ''),
            showLeaderboard ? 'Hide Leaderboard' : 'Show Leaderboard'
        ),
        
        // Leaderboard panel
        showLeaderboard && e('div', { 
            className: 'leaderboard-panel',
            style: {
                background: 'rgba(0, 0, 0, 0.4)',
                borderRadius: '12px',
                padding: '16px',
                marginBottom: '16px',
                border: '1px solid rgba(255, 255, 255, 0.1)'
            }
        },
            // Controls row
            e('div', { 
                style: { 
                    display: 'flex', 
                    gap: '12px', 
                    marginBottom: '12px',
                    flexWrap: 'wrap',
                    alignItems: 'center'
                }
            },
                // Stat dropdown
                e('div', { style: { display: 'flex', flexDirection: 'column', gap: '4px' } },
                    e('label', { style: { fontSize: '10px', color: 'var(--text-dim)' } }, 'STAT'),
                    e('select', {
                        value: selectedStat,
                        onChange: (ev) => setSelectedStat(ev.target.value),
                        style: {
                            background: 'rgba(0, 0, 0, 0.5)',
                            border: '1px solid rgba(255, 255, 255, 0.2)',
                            borderRadius: '6px',
                            padding: '6px 10px',
                            color: 'white',
                            fontSize: '12px',
                            cursor: 'pointer',
                            minWidth: '140px'
                        }
                    },
                        statOptions.map(opt =>
                            e('option', { key: opt.key, value: opt.key }, opt.label)
                        )
                    )
                ),
                
                // Min poss input
                e('div', { style: { display: 'flex', flexDirection: 'column', gap: '4px' } },
                    e('label', { style: { fontSize: '10px', color: 'var(--text-dim)' } }, 'MIN POSS'),
                    e('input', {
                        type: 'number',
                        value: minPoss,
                        onChange: (ev) => setMinPoss(Math.max(0, parseInt(ev.target.value) || 0)),
                        style: {
                            background: 'rgba(0, 0, 0, 0.5)',
                            border: '1px solid rgba(255, 255, 255, 0.2)',
                            borderRadius: '6px',
                            padding: '6px 10px',
                            color: 'white',
                            fontSize: '12px',
                            width: '70px'
                        }
                    })
                ),
                
                // Role filter toggle
                roleCount >= 5 && e('div', { style: { display: 'flex', flexDirection: 'column', gap: '4px' } },
                    e('label', { style: { fontSize: '10px', color: 'var(--text-dim)' } }, 'FILTER'),
                    e('button', {
                        onClick: () => setUseRoleFilter(!useRoleFilter),
                        style: {
                            background: useRoleFilter ? 'var(--accent-indigo)' : 'rgba(0, 0, 0, 0.5)',
                            border: '1px solid rgba(255, 255, 255, 0.2)',
                            borderRadius: '6px',
                            padding: '6px 10px',
                            color: 'white',
                            fontSize: '11px',
                            cursor: 'pointer'
                        }
                    }, useRoleFilter ? `Role (${roleCount})` : 'All Players')
                )
            ),
            
            // Leaderboard list
            e('div', { 
                style: { 
                    maxHeight: '300px', 
                    overflowY: 'auto',
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '4px'
                }
            },
                leaderboardData.length === 0 
                    ? e('div', { style: { color: 'var(--text-dim)', fontSize: '12px', padding: '10px', textAlign: 'center' } }, 
                        'No players meet criteria')
                    : leaderboardData.map((p, i) => {
                        // Use precomputed percentile if available, fallback to rank-based
                        const pct = p.precomputedPercentile ?? ((leaderboardData.length - i) / leaderboardData.length * 100);
                        return e('div', {
                            key: `${p.player}-${p.season}`,
                            onClick: () => onPlayerSelect && onPlayerSelect(p.player),
                            style: {
                                display: 'flex',
                                alignItems: 'center',
                                gap: '10px',
                                padding: '8px 12px',
                                background: p.player === selectedPlayer 
                                    ? 'rgba(99, 102, 241, 0.3)' 
                                    : 'rgba(255, 255, 255, 0.05)',
                                borderRadius: '6px',
                                cursor: 'pointer',
                                transition: 'background 0.2s',
                                border: p.player === selectedPlayer 
                                    ? '1px solid var(--accent-indigo)' 
                                    : '1px solid transparent'
                            }
                        },
                            // Rank
                            e('div', { 
                                style: { 
                                    width: '24px', 
                                    height: '24px',
                                    borderRadius: '50%',
                                    background: getPercentileColor(pct),
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    fontSize: '11px',
                                    fontWeight: '700',
                                    color: '#000',
                                    flexShrink: 0
                                }
                            }, i + 1),
                            
                            // Player name
                            e('div', { 
                                style: { 
                                    flex: 1, 
                                    fontSize: '12px',
                                    fontWeight: p.player === selectedPlayer ? '600' : '400',
                                    overflow: 'hidden',
                                    textOverflow: 'ellipsis',
                                    whiteSpace: 'nowrap'
                                }
                            }, p.player),
                            
                            // Value
                            e('div', { 
                                style: { 
                                    fontSize: '12px', 
                                    fontWeight: '600',
                                    color: getPercentileColor(pct),
                                    fontFamily: 'JetBrains Mono, monospace'
                                }
                            }, formatValue(p[selectedStat], selectedStatInfo.format)),
                            
                            // Poss
                            e('div', { 
                                style: { 
                                    fontSize: '10px', 
                                    color: 'var(--text-dim)',
                                    fontFamily: 'JetBrains Mono, monospace'
                                }
                            }, `${p.totalPoss} poss`)
                        );
                    })
            )
        )
    );
}

// Spacing Circular Barplot Component
function SpacingRadarChart({ metrics, size = 560, radarPercentiles = null, fallbackSpacing75 = null }) {
    // Debug log incoming props
    console.log('SpacingRadarChart props:', {
        fallbackSpacing75,
        metricsSpacing75: metrics?.spacing75,
        metricsSpacingPct: metrics?.spacingPct,
        radarPercentilesKeys: radarPercentiles ? Object.keys(radarPercentiles).slice(0, 5) : null,
        samplePercentile: radarPercentiles?.spacingPct
    });
    if (!metrics) return e('div', { className: 'radar-container' }, 'Loading...');
    
    const actualSize = 800;
    const centerX = actualSize / 2;
    const centerY = actualSize / 2;
    const innerRadius = actualSize * 0.025;  // Much smaller inner hole
    const maxBarLength = actualSize * 0.26;  // Longer bars to compensate
    const outerRadius = innerRadius + maxBarLength;
    
    // Category definitions with colors
    const categories = [
        { name: 'OVERALL', color: '#06b6d4', metrics: ['spacingPct', 'spacingPPP', 'spacingTOPct', 'spacingFtRate'] },
        { name: 'SPOT-UP C&S', color: '#3b82f6', metrics: ['spotUpCnS75', 'guardedPct', 'guarded3Pct', 'open3Pct', 'adjusted3Pct'] },
        { name: 'MOVING', color: '#a78bfa', metrics: ['moving75', 'moving3Pct'] },
        { name: 'SPOT UP DRIVES', color: '#f472b6', metrics: ['spotUpDrivePct', 'spotUpDrives75', 'spotUpDrivesPPP'] },
        { name: 'SPOT DRV L & R', color: '#f43f5e', metrics: ['spotUpDrivesLeftPct', 'spotUpDrivesLeftPPP', 'spotUpDrivesRightPct', 'spotUpDrivesRightPPP'] },
        { name: 'OFF SCREEN', color: '#f97316', metrics: ['offScreen75', 'offScreenPPP', 'offScreenDrivePct'] },
        { name: 'HANDOFFS', color: '#84cc16', metrics: ['handoffs75', 'handoffsPPP', 'handoffsDrivePct'] }
    ];
    
    // Metric definitions
    const metricDefs = {
        'spacingPct': { label: 'Spacing%', format: 'pct' },
        'spacingPPP': { label: 'PPP', format: 'ppp' },
        'spacingTOPct': { label: 'TO%', format: 'pct', inverse: true },
        'spacingFtRate': { label: 'FT Rate', format: 'pct' },
        'spotUpCnS75': { label: 'C&S/75', format: 'dec' },
        'guardedPct': { label: 'Guard%', format: 'pct' },
        'guarded3Pct': { label: 'Grd 3PT%', format: 'pct' },
        'open3Pct': { label: 'Open 3PT%', format: 'pct' },
        'adjusted3Pct': { label: 'Adj 3PT%', format: 'pct' },
        'moving75': { label: 'Mov/75', format: 'dec' },
        'moving3Pct': { label: 'Mov 3PT%', format: 'pct' },
        'spotUpDrivePct': { label: 'Drive%', format: 'pct' },
        'spotUpDrives75': { label: 'Drv/75', format: 'dec' },
        'spotUpDrivesPPP': { label: 'Drv PPP', format: 'ppp' },
        'spotUpDrivesLeftPct': { label: 'Left%', format: 'pct' },
        'spotUpDrivesLeftPPP': { label: 'L PPP', format: 'ppp' },
        'spotUpDrivesRightPct': { label: 'Right%', format: 'pct' },
        'spotUpDrivesRightPPP': { label: 'R PPP', format: 'ppp' },
        'offScreen75': { label: 'OS/75', format: 'dec' },
        'offScreenPPP': { label: 'OS PPP', format: 'ppp' },
        'offScreenDrivePct': { label: 'OS Drv%', format: 'pct' },
        'handoffs75': { label: 'HO/75', format: 'dec' },
        'handoffsPPP': { label: 'HO PPP', format: 'ppp' },
        'handoffsDrivePct': { label: 'HO Drv%', format: 'pct' }
    };
    
    // Use the proper spacing/75 from radar1Metrics (fallbackSpacing75)
    const spacing75 = fallbackSpacing75 || 0;
    const hasLowSpacingVolume = spacing75 < 1.5;
    
    // Dimming thresholds
    const spotUpDrives75 = metrics.spotUpDrives75 || 0;
    const hasLowSpotUpDrivesVolume = spotUpDrives75 < 1;
    
    // Debug logging
    console.log('SpacingRadar dimming check:', {
        spotUpDrives75,
        hasLowSpotUpDrivesVolume,
        threshold: 1
    });
    
    // Build ordered metrics
    const radarMetricsBase = [];
    const categoryArcs = [];
    let currentIndex = 0;
    
    categories.forEach(cat => {
        const startIdx = currentIndex;
        cat.metrics.forEach(key => {
            // Determine if this metric should be dimmed
            let isDimmed = false;
            // Dim both SPOT UP DRIVES and SPOT DRV L & R when volume is low
            if ((cat.name === 'SPOT DRV L & R' || cat.name === 'SPOT UP DRIVES') && hasLowSpotUpDrivesVolume) {
                isDimmed = true;
            }
            
            radarMetricsBase.push({
                key,
                ...metricDefs[key],
                category: cat.name,
                categoryColor: cat.color,
                isDimmed
            });
            currentIndex++;
        });
        categoryArcs.push({
            name: cat.name,
            color: cat.color,
            startIdx,
            endIdx: currentIndex - 1,
            count: cat.metrics.length
        });
    });
    
    const numPoints = radarMetricsBase.length;
    const angleStep = (Math.PI * 2) / numPoints;
    const barWidth = angleStep * 0.7;
    
    const formatValue = (value, format) => {
        if (value === null || value === undefined) return '-';
        switch(format) {
            case 'ppp': return value.toFixed(2);
            case 'pct': return value.toFixed(0) + '%';
            case 'dec': return value.toFixed(1);
            default: return value.toFixed(1);
        }
    };
    
    const getPercentileColor = (pct) => {
        if (pct === null || pct === undefined) return 'rgba(100, 116, 139, 0.6)';
        if (pct === -1) return 'rgba(148, 163, 184, 0.9)';
        if (pct >= 90) return '#22c55e';
        if (pct >= 75) return '#84cc16';
        if (pct >= 60) return '#a3e635';
        if (pct >= 40) return '#fbbf24';
        if (pct >= 25) return '#fb923c';
        return '#ef4444';
    };
    
    // Calculate bar data
    const barData = radarMetricsBase.map((m, i) => {
        let value = metrics[m.key];
        if (value === null || value === undefined) value = 0;
        
        const pct = radarPercentiles?.[m.key];
        let normalizedValue;
        if (pct !== null && pct !== undefined && !isNaN(pct) && pct >= 0) {
            normalizedValue = Math.max(0.08, pct / 100);
        } else if (pct === -1) {
            normalizedValue = 0.5;
        } else {
            normalizedValue = 0.15;
        }
        
        const clampedValue = Math.max(0.08, Math.min(1, normalizedValue));
        const angle = i * angleStep - Math.PI / 2;
        const barLength = clampedValue * maxBarLength;
        
        return {
            key: m.key,
            label: m.label,
            format: m.format,
            value,
            percentile: pct,
            color: getPercentileColor(pct),
            categoryColor: m.categoryColor,
            angle,
            barLength,
            isDimmed: m.isDimmed
        };
    });
    
    // Create arc path for a bar
    const createBarPath = (startAngle, barLength, barWidthAngle) => {
        const halfWidth = barWidthAngle / 2;
        const innerR = innerRadius;
        const outerR = innerRadius + barLength;
        
        const x1 = centerX + Math.cos(startAngle - halfWidth) * innerR;
        const y1 = centerY + Math.sin(startAngle - halfWidth) * innerR;
        const x2 = centerX + Math.cos(startAngle + halfWidth) * innerR;
        const y2 = centerY + Math.sin(startAngle + halfWidth) * innerR;
        const x3 = centerX + Math.cos(startAngle + halfWidth) * outerR;
        const y3 = centerY + Math.sin(startAngle + halfWidth) * outerR;
        const x4 = centerX + Math.cos(startAngle - halfWidth) * outerR;
        const y4 = centerY + Math.sin(startAngle - halfWidth) * outerR;
        
        return `M ${x1} ${y1} 
                A ${innerR} ${innerR} 0 0 1 ${x2} ${y2}
                L ${x3} ${y3}
                A ${outerR} ${outerR} 0 0 0 ${x4} ${y4}
                Z`;
    };
    
    const createCategoryArc = (cat) => {
        const startAngle = cat.startIdx * angleStep - Math.PI / 2 - angleStep * 0.35;
        const endAngle = (cat.endIdx + 1) * angleStep - Math.PI / 2 - angleStep * 0.65;
        const arcRadius = outerRadius + 12;
        const x1 = centerX + Math.cos(startAngle) * arcRadius;
        const y1 = centerY + Math.sin(startAngle) * arcRadius;
        const x2 = centerX + Math.cos(endAngle) * arcRadius;
        const y2 = centerY + Math.sin(endAngle) * arcRadius;
        const largeArc = (endAngle - startAngle) > Math.PI ? 1 : 0;
        return `M ${x1} ${y1} A ${arcRadius} ${arcRadius} 0 ${largeArc} 1 ${x2} ${y2}`;
    };
    
    // Create translucent category background wedge
    const createCategoryBackground = (cat) => {
        const startAngle = cat.startIdx * angleStep - Math.PI / 2 - angleStep * 0.35;
        const endAngle = (cat.endIdx + 1) * angleStep - Math.PI / 2 - angleStep * 0.65;
        const innerR = innerRadius;
        const outerR = outerRadius + 6;
        
        const x1 = centerX + Math.cos(startAngle) * innerR;
        const y1 = centerY + Math.sin(startAngle) * innerR;
        const x2 = centerX + Math.cos(endAngle) * innerR;
        const y2 = centerY + Math.sin(endAngle) * innerR;
        const x3 = centerX + Math.cos(endAngle) * outerR;
        const y3 = centerY + Math.sin(endAngle) * outerR;
        const x4 = centerX + Math.cos(startAngle) * outerR;
        const y4 = centerY + Math.sin(startAngle) * outerR;
        
        const largeArc = (endAngle - startAngle) > Math.PI ? 1 : 0;
        
        return `M ${x1} ${y1} 
                A ${innerR} ${innerR} 0 ${largeArc} 1 ${x2} ${y2}
                L ${x3} ${y3}
                A ${outerR} ${outerR} 0 ${largeArc} 0 ${x4} ${y4}
                Z`;
    };
    
    // Get spacing % and PPP values for header
    const spacingPctValue = metrics.spacingPct;
    const spacingPPPValue = metrics.spacingPPP;
    const spacing75Display = spacing75;
    
    return e('div', {
        className: 'radar-container',
        style: { 
            position: 'relative',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            width: '100%',
            padding: '12px 0',
            background: 'rgba(0, 0, 0, 0.4)',
            borderRadius: '12px'
        }
    },
        // Header with spacing%, spacing/75, and PPP
        e('div', {
            style: {
                display: 'flex',
                justifyContent: 'space-between',
                width: '100%',
                padding: '0 16px 8px',
                marginBottom: '8px',
                borderBottom: '1px solid rgba(255,255,255,0.1)'
            }
        },
            e('div', {
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                }
            },
                e('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, 'SPACING %'),
                e('span', { 
                    style: { 
                        fontSize: '14px', 
                        fontWeight: '700', 
                        color: '#06b6d4',
                        fontFamily: 'JetBrains Mono, monospace'
                    } 
                }, spacingPctValue ? spacingPctValue.toFixed(1) + '%' : '-')
            ),
            e('div', {
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                }
            },
                e('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, 'SPACING/75'),
                e('span', { 
                    style: { 
                        fontSize: '14px', 
                        fontWeight: '700', 
                        color: '#22d3ee',
                        fontFamily: 'JetBrains Mono, monospace'
                    } 
                }, spacing75Display ? spacing75Display.toFixed(1) : '-')
            ),
            e('div', {
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                }
            },
                e('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, 'PPP'),
                e('span', { 
                    style: { 
                        fontSize: '14px', 
                        fontWeight: '700', 
                        color: '#06b6d4',
                        fontFamily: 'JetBrains Mono, monospace'
                    } 
                }, spacingPPPValue ? spacingPPPValue.toFixed(2) : '-')
            )
        ),
        
        // Low volume warning
        hasLowSpacingVolume && e('div', {
            style: {
                padding: '4px 12px',
                marginBottom: '8px',
                fontSize: '10px',
                color: '#fb923c',
                textAlign: 'center'
            }
        }, ' Low spacing volume (<1.5/75 possessions)'),
        
        // Category legend
        e('div', {
            style: {
                display: 'flex',
                flexWrap: 'wrap',
                gap: '4px',
                justifyContent: 'center',
                marginBottom: '8px',
                padding: '0 12px'
            }
        },
            categories.map(cat => e('div', {
                key: cat.name,
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '3px',
                    padding: '2px 6px',
                    background: `${cat.color}22`,
                    borderRadius: '3px',
                    border: `1px solid ${cat.color}44`
                }
            },
                e('div', {
                    style: { width: '6px', height: '6px', borderRadius: '2px', background: cat.color }
                }),
                e('span', {
                    style: { fontSize: '8px', fontWeight: '600', color: cat.color, letterSpacing: '0.2px' }
                }, cat.name)
            ))
        ),
        
        // Circular Barplot SVG
        e('svg', {
            viewBox: `0 0 ${actualSize} ${actualSize}`,
            width: '100%',
            preserveAspectRatio: 'xMidYMid meet',
            style: { maxWidth: actualSize + 'px', height: 'auto' }
        },
            e('defs', null,
                e('filter', { id: 'spacingGlow', x: '-50%', y: '-50%', width: '200%', height: '200%' },
                    e('feGaussianBlur', { stdDeviation: '3', result: 'coloredBlur' }),
                    e('feMerge', null,
                        e('feMergeNode', { in: 'coloredBlur' }),
                        e('feMergeNode', { in: 'SourceGraphic' })
                    )
                ),
                e('filter', { id: 'spacingStrongGlow', x: '-50%', y: '-50%', width: '200%', height: '200%' },
                    e('feGaussianBlur', { stdDeviation: '5', result: 'coloredBlur' }),
                    e('feMerge', null,
                        e('feMergeNode', { in: 'coloredBlur' }),
                        e('feMergeNode', { in: 'SourceGraphic' })
                    )
                )
            ),
            
            // Background circle
            e('circle', { cx: centerX, cy: centerY, r: outerRadius + 18, fill: 'rgba(0, 0, 0, 0.3)' }),
            
            // Percentile reference rings
            [0.25, 0.5, 0.75, 1].map((pct, i) => {
                const r = innerRadius + (pct * maxBarLength);
                return e('circle', {
                    key: `ring-${i}`,
                    cx: centerX,
                    cy: centerY,
                    r: r,
                    fill: 'none',
                    stroke: i === 3 ? 'rgba(255, 255, 255, 0.25)' : 'rgba(255, 255, 255, 0.1)',
                    strokeWidth: i === 3 ? 1.5 : 1,
                    strokeDasharray: i < 3 ? '4,8' : 'none'
                });
            }),
            
            // Tiny inner circle
            e('circle', {
                cx: centerX,
                cy: centerY,
                r: innerRadius,
                fill: 'rgba(10, 12, 16, 0.95)',
                stroke: 'rgba(6, 182, 212, 0.3)',
                strokeWidth: 1
            }),
            
            // Translucent category background wedges
            categoryArcs.map((cat, i) =>
                e('path', {
                    key: `cat-bg-${i}`,
                    d: createCategoryBackground(cat),
                    fill: cat.color,
                    opacity: 0.08
                })
            ),
            
            // Category arcs
            categoryArcs.map((cat, i) =>
                e('path', {
                    key: `cat-arc-${i}`,
                    d: createCategoryArc(cat),
                    fill: 'none',
                    stroke: cat.color,
                    strokeWidth: 5,
                    strokeLinecap: 'round',
                    opacity: 0.7
                })
            ),
            
            // Bars
            barData.map((bar, i) => {
                const pct = bar.percentile;
                const useStrongGlow = pct !== null && pct >= 75;
                
                return e('path', {
                    key: `bar-${i}`,
                    d: createBarPath(bar.angle, bar.barLength, barWidth),
                    fill: bar.isDimmed ? 'rgba(100, 116, 139, 0.4)' : bar.color,
                    stroke: 'rgba(255, 255, 255, 0.3)',
                    strokeWidth: 0.5,
                    filter: useStrongGlow ? 'url(#spacingStrongGlow)' : 'url(#spacingGlow)',
                    style: { transition: 'all 0.3s ease' }
                });
            }),
            
            // Labels
            barData.map((bar, i) => {
                const angle = bar.angle;
                const angleDeg = (angle * 180 / Math.PI + 360) % 360;
                const value = bar.value;
                const pct = bar.percentile;
                const color = bar.isDimmed ? 'rgba(100, 116, 139, 0.6)' : getPercentileColor(pct);
                
                const labelR = outerRadius + 45;
                const labelX = centerX + Math.cos(angle) * labelR;
                const labelY = centerY + Math.sin(angle) * labelR;
                
                let textAnchor;
                if (angleDeg >= 350 || angleDeg < 10) {
                    textAnchor = 'middle';
                } else if (angleDeg >= 10 && angleDeg < 170) {
                    textAnchor = 'start';
                } else if (angleDeg >= 170 && angleDeg < 190) {
                    textAnchor = 'middle';
                } else {
                    textAnchor = 'end';
                }
                
                return e('g', { key: `label-${i}` },
                    // Connector line
                    e('line', {
                        x1: centerX + Math.cos(angle) * (innerRadius + bar.barLength + 3),
                        y1: centerY + Math.sin(angle) * (innerRadius + bar.barLength + 3),
                        x2: centerX + Math.cos(angle) * (labelR - 15),
                        y2: centerY + Math.sin(angle) * (labelR - 15),
                        stroke: bar.isDimmed ? 'rgba(100, 116, 139, 0.4)' : bar.categoryColor,
                        strokeWidth: 1,
                        opacity: 0.5
                    }),
                    
                    // Label
                    e('text', {
                        x: labelX,
                        y: labelY - 6,
                        textAnchor,
                        dominantBaseline: 'middle',
                        fill: bar.isDimmed ? 'rgba(100, 116, 139, 0.6)' : bar.categoryColor,
                        fontSize: '9px',
                        fontWeight: '600',
                        fontFamily: 'Sora, sans-serif'
                    }, bar.label),
                    
                    // Value
                    e('text', {
                        x: labelX,
                        y: labelY + 5,
                        textAnchor,
                        dominantBaseline: 'middle',
                        fill: color,
                        fontSize: '10px',
                        fontWeight: '700',
                        fontFamily: 'JetBrains Mono, monospace'
                    }, formatValue(value, bar.format)),
                    
                    // Percentile
                    pct !== null && pct !== undefined && pct >= 0 && !bar.isDimmed && e('text', {
                        x: labelX,
                        y: labelY + 17,
                        textAnchor,
                        dominantBaseline: 'middle',
                        fill: color,
                        fontSize: '8px',
                        fontWeight: '600',
                        fontFamily: 'JetBrains Mono, monospace',
                        opacity: 0.85
                    }, Math.round(pct) + '%ile')
                );
            })
        )
    );
}

// Finishing Circular Barplot Component
function FinishingRadarChart({ metrics, size = 560, radarPercentiles = null, fallbackFinishing75 = null }) {
    if (!metrics) return e('div', { className: 'radar-container' }, 'Loading...');
    
    const actualSize = 800;
    const centerX = actualSize / 2;
    const centerY = actualSize / 2;
    const innerRadius = actualSize * 0.025;
    const maxBarLength = actualSize * 0.26;
    const outerRadius = innerRadius + maxBarLength;
    
    // Category definitions with colors
    const categories = [
        { name: 'OVERALL', color: '#facc15', metrics: ['finishingPct', 'finishingPPP', 'finishingTOPct', 'finishingFtRate'] },
        { name: 'P&R ROLLS', color: '#f97316', metrics: ['rolls75', 'rollsPPP', 'rollsFtRate', 'rollsTOPct'] },
        { name: 'P&R POPS', color: '#a78bfa', metrics: ['pops75', 'popsPPP'] },
        { name: 'SELF CUTS', color: '#34d399', metrics: ['selfCut75', 'selfCutPPP', 'selfCutTOPct'] },
        { name: 'PUT BACKS', color: '#f472b6', metrics: ['putbacks75'] }
    ];
    
    // Metric definitions
    const metricDefs = {
        'finishingPct': { label: 'Finish%', format: 'pct' },
        'finishingPPP': { label: 'PPP', format: 'ppp' },
        'finishingTOPct': { label: 'TO%', format: 'pct', inverse: true },
        'finishingFtRate': { label: 'FT Rate', format: 'pct' },
        'rolls75': { label: 'Rolls/75', format: 'dec' },
        'rollsPPP': { label: 'Rolls PPP', format: 'ppp' },
        'rollsFtRate': { label: 'Rolls FT', format: 'pct' },
        'rollsTOPct': { label: 'Rolls TO%', format: 'pct', inverse: true },
        'pops75': { label: 'Pops/75', format: 'dec' },
        'popsPPP': { label: 'Pops PPP', format: 'ppp' },
        'selfCut75': { label: 'Cut/75', format: 'dec' },
        'selfCutPPP': { label: 'Cut PPP', format: 'ppp' },
        'selfCutTOPct': { label: 'Cut TO%', format: 'pct', inverse: true },
        'putbacks75': { label: 'Putback/75', format: 'dec' }
    };
    
    // Use the proper finishing/75 from radar1Metrics (fallbackFinishing75)
    const finishing75 = fallbackFinishing75 || metrics.finishing75 || 0;
    
    // Check if finishing volume is too low to dim everything
    const hasLowFinishingVolume = finishing75 < 1;
    
    // Build ordered metrics
    const radarMetricsBase = [];
    const categoryArcs = [];
    let currentIndex = 0;
    
    categories.forEach(cat => {
        const startIdx = currentIndex;
        cat.metrics.forEach(key => {
            radarMetricsBase.push({
                key,
                ...metricDefs[key],
                category: cat.name,
                categoryColor: cat.color
            });
            currentIndex++;
        });
        categoryArcs.push({
            name: cat.name,
            color: cat.color,
            startIdx,
            endIdx: currentIndex - 1,
            count: cat.metrics.length
        });
    });
    
    const numPoints = radarMetricsBase.length;
    const angleStep = (Math.PI * 2) / numPoints;
    const barWidth = angleStep * 0.7;
    
    const formatValue = (value, format) => {
        if (value === null || value === undefined) return '-';
        switch(format) {
            case 'ppp': return value.toFixed(2);
            case 'pct': return value.toFixed(0) + '%';
            case 'dec': return value.toFixed(1);
            default: return value.toFixed(1);
        }
    };
    
    const getPercentileColor = (pct) => {
        if (pct === null || pct === undefined) return 'rgba(100, 116, 139, 0.6)';
        if (pct === -1) return 'rgba(148, 163, 184, 0.9)';
        if (pct >= 90) return '#22c55e';
        if (pct >= 75) return '#84cc16';
        if (pct >= 60) return '#a3e635';
        if (pct >= 40) return '#fbbf24';
        if (pct >= 25) return '#fb923c';
        return '#ef4444';
    };
    
    // Get finishing percentile values
    const finishingPctValue = metrics?.finishingPct;
    const finishing75Display = finishing75 || metrics?.finishing75;
    const finishingPPPValue = metrics?.finishingPPP;
    
    // Calculate bar data
    const barData = radarMetricsBase.map((m, i) => {
        let value = metrics[m.key];
        if (value === null || value === undefined) value = 0;
        
        const pct = radarPercentiles?.[m.key];
        let normalizedValue;
        
        // Check for low volume dimming
        let isDimmed = hasLowFinishingVolume;
        
        if (pct !== null && pct !== undefined && !isNaN(pct) && pct >= 0 && !isDimmed) {
            normalizedValue = Math.max(0.08, pct / 100);
        } else if (pct === -1) {
            normalizedValue = 0.5;
            isDimmed = true;
        } else {
            normalizedValue = 0.15;
        }
        
        if (isDimmed) normalizedValue = 0.1;
        
        const barLength = normalizedValue * maxBarLength;
        const angle = i * angleStep - Math.PI / 2;
        
        return {
            key: m.key,
            label: m.label,
            format: m.format,
            rawValue: metrics[m.key],
            normalizedValue,
            barLength,
            angle,
            percentile: pct,
            color: isDimmed ? 'rgba(100, 116, 139, 0.5)' : getPercentileColor(pct),
            categoryColor: m.categoryColor,
            category: m.category,
            isDimmed
        };
    });
    
    // Create arc path for a bar
    const createBarPath = (startAngle, barLength, barWidthAngle) => {
        const halfWidth = barWidthAngle / 2;
        const innerR = innerRadius;
        const outerR = innerRadius + barLength;
        
        const x1 = centerX + Math.cos(startAngle - halfWidth) * innerR;
        const y1 = centerY + Math.sin(startAngle - halfWidth) * innerR;
        const x2 = centerX + Math.cos(startAngle + halfWidth) * innerR;
        const y2 = centerY + Math.sin(startAngle + halfWidth) * innerR;
        const x3 = centerX + Math.cos(startAngle + halfWidth) * outerR;
        const y3 = centerY + Math.sin(startAngle + halfWidth) * outerR;
        const x4 = centerX + Math.cos(startAngle - halfWidth) * outerR;
        const y4 = centerY + Math.sin(startAngle - halfWidth) * outerR;
        
        return `M ${x1} ${y1} 
                A ${innerR} ${innerR} 0 0 1 ${x2} ${y2}
                L ${x3} ${y3}
                A ${outerR} ${outerR} 0 0 0 ${x4} ${y4}
                Z`;
    };
    
    const createCategoryArc = (cat) => {
        const startAngle = cat.startIdx * angleStep - Math.PI / 2 - angleStep * 0.35;
        const endAngle = (cat.endIdx + 1) * angleStep - Math.PI / 2 - angleStep * 0.65;
        const arcRadius = outerRadius + 12;
        const x1 = centerX + Math.cos(startAngle) * arcRadius;
        const y1 = centerY + Math.sin(startAngle) * arcRadius;
        const x2 = centerX + Math.cos(endAngle) * arcRadius;
        const y2 = centerY + Math.sin(endAngle) * arcRadius;
        const largeArc = (endAngle - startAngle) > Math.PI ? 1 : 0;
        return `M ${x1} ${y1} A ${arcRadius} ${arcRadius} 0 ${largeArc} 1 ${x2} ${y2}`;
    };
    
    const createCategoryBackground = (cat) => {
        const startAngle = cat.startIdx * angleStep - Math.PI / 2 - angleStep * 0.35;
        const endAngle = (cat.endIdx + 1) * angleStep - Math.PI / 2 - angleStep * 0.65;
        const innerR = innerRadius;
        const outerR = outerRadius + 6;
        
        const x1 = centerX + Math.cos(startAngle) * innerR;
        const y1 = centerY + Math.sin(startAngle) * innerR;
        const x2 = centerX + Math.cos(endAngle) * innerR;
        const y2 = centerY + Math.sin(endAngle) * innerR;
        const x3 = centerX + Math.cos(endAngle) * outerR;
        const y3 = centerY + Math.sin(endAngle) * outerR;
        const x4 = centerX + Math.cos(startAngle) * outerR;
        const y4 = centerY + Math.sin(startAngle) * outerR;
        
        const largeArc = (endAngle - startAngle) > Math.PI ? 1 : 0;
        
        return `M ${x1} ${y1} 
                A ${innerR} ${innerR} 0 ${largeArc} 1 ${x2} ${y2}
                L ${x3} ${y3}
                A ${outerR} ${outerR} 0 ${largeArc} 0 ${x4} ${y4}
                Z`;
    };
    
    return e('div', {
        className: 'radar-container',
        style: { 
            position: 'relative',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            width: '100%',
            padding: '12px 0',
            background: 'rgba(0, 0, 0, 0.4)',
            borderRadius: '12px'
        }
    },
        // Header with Finishing % / Finishing/75 / PPP
        e('div', {
            style: {
                display: 'flex',
                justifyContent: 'space-between',
                width: '100%',
                padding: '0 16px 8px',
                marginBottom: '8px',
                borderBottom: '1px solid rgba(255,255,255,0.1)'
            }
        },
            e('div', {
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                }
            },
                e('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, 'FINISHING %'),
                e('span', { 
                    style: { 
                        fontSize: '14px', 
                        fontWeight: '700', 
                        color: '#facc15',
                        fontFamily: 'JetBrains Mono, monospace'
                    } 
                }, finishingPctValue ? finishingPctValue.toFixed(1) + '%' : '-')
            ),
            e('div', {
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                }
            },
                e('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, 'FINISHING/75'),
                e('span', { 
                    style: { 
                        fontSize: '14px', 
                        fontWeight: '700', 
                        color: '#f97316',
                        fontFamily: 'JetBrains Mono, monospace'
                    } 
                }, finishing75Display ? finishing75Display.toFixed(1) : '-')
            ),
            e('div', {
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                }
            },
                e('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, 'PPP'),
                e('span', { 
                    style: { 
                        fontSize: '14px', 
                        fontWeight: '700', 
                        color: '#facc15',
                        fontFamily: 'JetBrains Mono, monospace'
                    } 
                }, finishingPPPValue ? finishingPPPValue.toFixed(2) : '-')
            )
        ),
        
        // Category legend
        e('div', {
            style: {
                display: 'flex',
                flexWrap: 'wrap',
                gap: '4px',
                justifyContent: 'center',
                marginBottom: '8px',
                padding: '0 12px'
            }
        },
            categories.map(cat => e('div', {
                key: cat.name,
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '3px',
                    padding: '2px 6px',
                    background: `${cat.color}22`,
                    borderRadius: '3px',
                    border: `1px solid ${cat.color}44`
                }
            },
                e('div', {
                    style: { width: '6px', height: '6px', borderRadius: '2px', background: cat.color }
                }),
                e('span', {
                    style: { fontSize: '8px', fontWeight: '600', color: cat.color, letterSpacing: '0.2px' }
                }, cat.name)
            ))
        ),
        
        // Low volume warning
        hasLowFinishingVolume && e('div', {
            style: {
                background: 'rgba(251, 146, 60, 0.15)',
                border: '1px solid rgba(251, 146, 60, 0.3)',
                borderRadius: '6px',
                padding: '6px 12px',
                marginBottom: '8px',
                fontSize: '10px',
                color: '#fb923c',
                textAlign: 'center'
            }
        }, ' Low finishing volume (<1/75 possessions)'),
        
        // SVG Chart
        e('svg', {
            viewBox: `0 0 ${actualSize} ${actualSize}`,
            width: '100%',
            preserveAspectRatio: 'xMidYMid meet',
            style: { maxWidth: actualSize + 'px', height: 'auto' }
        },
            // Defs for glow effects
            e('defs', null,
                e('filter', { id: 'finishingGlow', x: '-50%', y: '-50%', width: '200%', height: '200%' },
                    e('feGaussianBlur', { stdDeviation: '3', result: 'coloredBlur' }),
                    e('feMerge', null,
                        e('feMergeNode', { in: 'coloredBlur' }),
                        e('feMergeNode', { in: 'SourceGraphic' })
                    )
                ),
                e('filter', { id: 'finishingStrongGlow', x: '-50%', y: '-50%', width: '200%', height: '200%' },
                    e('feGaussianBlur', { stdDeviation: '5', result: 'coloredBlur' }),
                    e('feMerge', null,
                        e('feMergeNode', { in: 'coloredBlur' }),
                        e('feMergeNode', { in: 'SourceGraphic' })
                    )
                )
            ),
            
            // Background circle
            e('circle', { cx: centerX, cy: centerY, r: outerRadius + 18, fill: 'rgba(0, 0, 0, 0.3)' }),
            
            // Percentile reference rings
            [0.25, 0.5, 0.75, 1].map((pct, i) => {
                const r = innerRadius + (pct * maxBarLength);
                return e('circle', {
                    key: `ring-${i}`,
                    cx: centerX,
                    cy: centerY,
                    r: r,
                    fill: 'none',
                    stroke: i === 3 ? 'rgba(255, 255, 255, 0.25)' : 'rgba(255, 255, 255, 0.1)',
                    strokeWidth: i === 3 ? 1.5 : 1,
                    strokeDasharray: i < 3 ? '4,8' : 'none'
                });
            }),
            
            // Inner circle
            e('circle', {
                cx: centerX,
                cy: centerY,
                r: innerRadius,
                fill: 'rgba(10, 12, 16, 0.95)',
                stroke: 'rgba(250, 204, 21, 0.3)',
                strokeWidth: 1
            }),
            
            // Category background wedges
            categoryArcs.map((cat, i) =>
                e('path', {
                    key: `cat-bg-${i}`,
                    d: createCategoryBackground(cat),
                    fill: cat.color,
                    opacity: 0.08
                })
            ),
            
            // Category arcs
            categoryArcs.map((cat, i) =>
                e('path', {
                    key: `cat-arc-${i}`,
                    d: createCategoryArc(cat),
                    fill: 'none',
                    stroke: cat.color,
                    strokeWidth: 5,
                    strokeLinecap: 'round',
                    opacity: 0.7
                })
            ),
            
            // Bars
            barData.map((bar, i) => {
                const pct = bar.percentile;
                const useStrongGlow = pct !== null && pct >= 75 && !bar.isDimmed;
                
                return e('path', {
                    key: `bar-${i}`,
                    d: createBarPath(bar.angle, bar.barLength, barWidth),
                    fill: bar.color,
                    stroke: 'rgba(255, 255, 255, 0.3)',
                    strokeWidth: 0.5,
                    filter: useStrongGlow ? 'url(#finishingStrongGlow)' : 'url(#finishingGlow)',
                    style: { transition: 'all 0.3s ease' }
                });
            }),
            
            // Labels
            barData.map((bar, i) => {
                const angle = bar.angle;
                const angleDeg = (angle * 180 / Math.PI + 360) % 360;
                const value = bar.rawValue;
                const pct = bar.percentile;
                const color = bar.isDimmed ? 'rgba(100, 116, 139, 0.6)' : getPercentileColor(pct);
                
                const labelR = outerRadius + 45;
                const labelX = centerX + Math.cos(angle) * labelR;
                const labelY = centerY + Math.sin(angle) * labelR;
                
                let textAnchor;
                if (angleDeg >= 350 || angleDeg < 10) {
                    textAnchor = 'middle';
                } else if (angleDeg >= 10 && angleDeg < 170) {
                    textAnchor = 'start';
                } else if (angleDeg >= 170 && angleDeg < 190) {
                    textAnchor = 'middle';
                } else {
                    textAnchor = 'end';
                }
                
                return e('g', { key: `label-${i}` },
                    // Connector line
                    e('line', {
                        x1: centerX + Math.cos(angle) * (innerRadius + bar.barLength + 3),
                        y1: centerY + Math.sin(angle) * (innerRadius + bar.barLength + 3),
                        x2: centerX + Math.cos(angle) * (labelR - 15),
                        y2: centerY + Math.sin(angle) * (labelR - 15),
                        stroke: bar.isDimmed ? 'rgba(100, 116, 139, 0.4)' : bar.categoryColor,
                        strokeWidth: 1,
                        opacity: 0.5
                    }),
                    
                    // Metric label
                    e('text', {
                        x: labelX,
                        y: labelY - 6,
                        textAnchor,
                        dominantBaseline: 'middle',
                        fill: bar.isDimmed ? 'rgba(100, 116, 139, 0.6)' : bar.categoryColor,
                        fontSize: '9px',
                        fontWeight: '600',
                        fontFamily: 'Sora, sans-serif'
                    }, bar.label),
                    
                    // Value
                    e('text', {
                        x: labelX,
                        y: labelY + 6,
                        textAnchor,
                        dominantBaseline: 'middle',
                        fill: color,
                        fontSize: '9px',
                        fontWeight: '700',
                        fontFamily: 'JetBrains Mono, monospace'
                    }, formatValue(value, bar.format)),
                    
                    // Percentile
                    pct !== null && pct !== undefined && pct >= 0 && !bar.isDimmed && e('text', {
                        x: labelX,
                        y: labelY + 17,
                        textAnchor,
                        dominantBaseline: 'middle',
                        fill: color,
                        fontSize: '8px',
                        fontWeight: '600',
                        fontFamily: 'JetBrains Mono, monospace',
                        opacity: 0.85
                    }, Math.round(pct) + '%ile')
                );
            })
        )
    );
}

// Placeholder Radar Component for sections
// Calculate On-Ball Radar Metrics from raw offense data
function calculateOnBallRadarMetrics(rawRows, matchedPoss) {
    // Helper to calculate per75
    const calcPer75 = (value) => {
        if (!matchedPoss || !matchedPoss.totalPlayerMin || !matchedPoss.totalTeamMin || !matchedPoss.totalTeamPoss) {
            return null;
        }
        return (value * 75 * matchedPoss.totalTeamMin) / (matchedPoss.totalPlayerMin * matchedPoss.totalTeamPoss);
    };
    
    // ===== GET MAIN PLAY TYPE ROWS =====
    const pnrBHRows = rawRows.filter(r => r['Play Type'] === 'P&R Ball Handler' && isMainPlayType(r));
    const isoRows = rawRows.filter(r => r['Play Type'] === 'Isolation' && isMainPlayType(r));
    const postRows = rawRows.filter(r => r['Play Type'] === 'Post-Up' && isMainPlayType(r));
    
    const pnrInclRows = rawRows.filter(r => r['Play Type'] === 'P&R Including Passes' && isMainPlayType(r));
    // FIXED: Use 'ISO Including Passes' not 'Isolation Including Passes'
    const isoInclRows = rawRows.filter(r => r['Play Type'] === 'ISO Including Passes' && isMainPlayType(r));
    const postInclRows = rawRows.filter(r => r['Play Type'] === 'Post-Ups Including Passes' && isMainPlayType(r));
    
    // Direct play type possessions
    const pnrBHPoss = pnrBHRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const pnrBHPts = pnrBHRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const isoPoss = isoRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const isoPts = isoRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const postPoss = postRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const postPts = postRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    
    // Including Passes possessions
    const pnrInclPoss = pnrInclRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const pnrInclPts = pnrInclRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    // FIXED: Accumulate raw TOs from TO% * POSS for each row, then recalculate TO%
    // This handles multi-season aggregation correctly
    const pnrInclTOs = pnrInclRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']); // Already a number like 15.9 (not 0.159)
        return s + (poss * toPct / 100);
    }, 0);
    
    const isoInclPoss = isoInclRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const isoInclPts = isoInclRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    
    const postInclPoss = postInclRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const postInclPts = postInclRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    
    // ===== P&R PRESSURE METRICS =====
    // Defense Commits and Traps
    const pnrDefCommitsRows = rawRows.filter(r => r['Play Type'] === 'P&R BH - Defense Commits' && isMainPlayType(r));
    const pnrTrapsRows = rawRows.filter(r => r['Play Type'] === 'P&R BH - Traps' && isMainPlayType(r));
    
    const pnrPressurePoss = pnrDefCommitsRows.reduce((s, r) => s + parseNum(r['POSS']), 0) + 
                           pnrTrapsRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const pnrPressurePts = pnrDefCommitsRows.reduce((s, r) => s + parseNum(r['PTS']), 0) + 
                          pnrTrapsRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const pnrPressureTOs = pnrDefCommitsRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0) + pnrTrapsRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    const pnrPressureTOPct = pnrPressurePoss > 0 ? (pnrPressureTOs / pnrPressurePoss) * 100 : 0;
    const pnrPressurePPP = pnrPressurePoss > 0 ? pnrPressurePts / pnrPressurePoss : 0;
    
    // ===== POST PRESSURE METRICS =====
    // Defense Commits and Hard Double
    const postDefCommitsRows = rawRows.filter(r => r['Play Type'] === 'Post-Up - Defense Commits' && isMainPlayType(r));
    const postHardDoubleRows = rawRows.filter(r => r['Play Type'] === 'Post-Up - Hard Double' && isMainPlayType(r));
    
    const postPressurePoss = postDefCommitsRows.reduce((s, r) => s + parseNum(r['POSS']), 0) + 
                            postHardDoubleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const postPressurePts = postDefCommitsRows.reduce((s, r) => s + parseNum(r['PTS']), 0) + 
                           postHardDoubleRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const postPressureTOs = postDefCommitsRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0) + postHardDoubleRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    const postPressureTOPct = postPressurePoss > 0 ? (postPressureTOs / postPressurePoss) * 100 : 0;
    const postPressurePPP = postPressurePoss > 0 ? postPressurePts / postPressurePoss : 0;
    
    // Direct on-ball possessions (for % of total)
    const onBallDirectPoss = pnrBHPoss + isoPoss + postPoss;
    const onBallDirectPts = pnrBHPts + isoPts + postPts;
    
    // On-ball "Including Passes" totals (for PPP)
    const onBallInclPoss = pnrInclPoss + isoInclPoss + postInclPoss;
    const onBallInclPts = pnrInclPts + isoInclPts + postInclPts;
    
    // Total possessions from Overall main row
    // NOTE: "Overall" in Synergy is drives data, NOT total possessions
    // Calculate totalPoss from sum of all main play types instead
    const mainPlayTypeRows = rawRows.filter(r => MAIN_PLAY_TYPES.includes(r['Play Type']) && isMainPlayType(r));
    const totalPoss = mainPlayTypeRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    
    // ===== P&R PASSING METRICS =====
    // Pass% = (P&R Including Passes poss - P&R Ball Handler poss) / P&R Including Passes poss
    const pnrPassPoss = Math.max(0, pnrInclPoss - pnrBHPoss);
    const pnrPassPct = pnrInclPoss > 0 ? (pnrPassPoss / pnrInclPoss) * 100 : 0;
    
    // P&R TO% - recalculate from accumulated TOs (handles multi-season correctly)
    const pnrTOPct = pnrInclPoss > 0 ? (pnrInclTOs / pnrInclPoss) * 100 : 0;
    
    // P&R Roll Assist: P&R Including Passes > P&R Roll Man > N/A
    const pnrRollAstRows = rawRows.filter(r => 
        r['Play Type'] === 'P&R Including Passes' &&
        isSubCategorySummary(r, 'P&R Roll Man')
    );
    const pnrRollAstPts = pnrRollAstRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const pnrRollAstPoss = pnrRollAstRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    
    // P&R Spot Up Assist: P&R Including Passes > Spot-Up > N/A
    const pnrSpotUpAstRows = rawRows.filter(r => 
        r['Play Type'] === 'P&R Including Passes' &&
        isSubCategorySummary(r, 'Spot-Up')
    );
    const pnrSpotUpAstPts = pnrSpotUpAstRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const pnrSpotUpAstPoss = pnrSpotUpAstRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    
    // Pass destination percentages (% of passes that go to each target)
    const pnrRollAstPct = pnrPassPoss > 0 ? (pnrRollAstPoss / pnrPassPoss) * 100 : 0;
    const pnrSpotUpAstPct = pnrPassPoss > 0 ? (pnrSpotUpAstPoss / pnrPassPoss) * 100 : 0;
    
    // ===== HANDLING SHOT DISTRIBUTION =====
    // P&R Ball Handler with High/Left/Right P&R and Dribble Jumper SUMMARY rows only
    // Use 2 FG ATT for mid-range, 3FG ATT for 3PT (note: different spacing in column names!)
    
    const hasPnrDirection = (r) => 
        anySubCategory(r, 'Left P&R') || anySubCategory(r, 'Right P&R') || anySubCategory(r, 'High P&R');
    
    // FIXED: Use isSubCategorySummary to avoid double-counting with detail rows
    const hasDribbleJumperSummary = (r) => isSubCategorySummary(r, 'Dribble Jumper');
    
    // P&R BH handling dribble jumpers (SUMMARY rows only - Dribble Jumper > N/A)
    const pnrDribbleJumperRows = rawRows.filter(r =>
        r['Play Type'] === 'P&R Ball Handler' &&
        hasPnrDirection(r) &&
        hasDribbleJumperSummary(r)
    );
    
    // FIXED: Use '2 FG ATT' (with space) for mid-range, '3FG ATT' (no space) for 3PT
    const handlingMidAtt = pnrDribbleJumperRows.reduce((s, r) => s + parseNum(r['2 FG ATT']), 0);
    const handlingMidMade = pnrDribbleJumperRows.reduce((s, r) => s + parseNum(r['2 FG MADE']), 0);
    const handling3Att = pnrDribbleJumperRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0);
    const handling3Made = pnrDribbleJumperRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
    
    // Rim: P&R BH with direction > To Basket
    const handlingRimRows = rawRows.filter(r =>
        r['Play Type'] === 'P&R Ball Handler' &&
        hasPnrDirection(r) &&
        isSubCategorySummary(r, 'To Basket')
    );
    const handlingRimAtt = handlingRimRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const handlingRimMade = handlingRimRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
    
    // ===== POST L VS R =====
    const postLeftRows = rawRows.filter(r =>
        r['Play Type'] === 'Post-Up' &&
        isSubCategorySummary(r, 'Left Shoulder')
    );
    const postLeftPoss = postLeftRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const postLeftPts = postLeftRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const postLeftFgAtt = postLeftRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const postLeftFgMade = postLeftRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
    const postLeft3Made = postLeftRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
    const postLeftTOs = postLeftRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    const postLeftFTAs = postLeftRows.reduce((s, r) => {
        const fgAtt = parseNum(r['FG ATT']);
        const ftaFga = parseNum(r['FTA/FGA']);
        return s + (fgAtt * ftaFga / 100);
    }, 0);
    
    const postRightRows = rawRows.filter(r =>
        r['Play Type'] === 'Post-Up' &&
        isSubCategorySummary(r, 'Right Shoulder')
    );
    const postRightPoss = postRightRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const postRightPts = postRightRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const postRightFgAtt = postRightRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const postRightFgMade = postRightRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
    const postRight3Made = postRightRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
    const postRightTOs = postRightRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    const postRightFTAs = postRightRows.reduce((s, r) => {
        const fgAtt = parseNum(r['FG ATT']);
        const ftaFga = parseNum(r['FTA/FGA']);
        return s + (fgAtt * ftaFga / 100);
    }, 0);
    
    const totalPostShoulderPoss = postLeftPoss + postRightPoss;
    
    // ===== POST LEFT/RIGHT BLOCK =====
    const postLeftBlockRows = rawRows.filter(r =>
        r['Play Type'] === 'Post-Up' &&
        isSubCategorySummary(r, 'Left Block')
    );
    const postLeftBlockPoss = postLeftBlockRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const postLeftBlockPts = postLeftBlockRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const postLeftBlockFgAtt = postLeftBlockRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const postLeftBlockFgMade = postLeftBlockRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
    const postLeftBlockFTAs = postLeftBlockRows.reduce((s, r) => s + parseNum(r['FTA']), 0);
    const postLeftBlockTOs = postLeftBlockRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    
    const postRightBlockRows = rawRows.filter(r =>
        r['Play Type'] === 'Post-Up' &&
        isSubCategorySummary(r, 'Right Block')
    );
    const postRightBlockPoss = postRightBlockRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const postRightBlockPts = postRightBlockRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const postRightBlockFgAtt = postRightBlockRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const postRightBlockFgMade = postRightBlockRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
    const postRightBlockFTAs = postRightBlockRows.reduce((s, r) => s + parseNum(r['FTA']), 0);
    const postRightBlockTOs = postRightBlockRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    
    const totalPostBlockPoss = postLeftBlockPoss + postRightBlockPoss;
    
    // ===== SHOULDERS WITHIN EACH BLOCK =====
    const getBlockShoulderData = (block, shoulder) => {
        const rows = rawRows.filter(r =>
            r['Play Type'] === 'Post-Up' &&
            anySubCategory(r, block) &&
            isSubCategorySummary(r, shoulder)
        );
        const poss = rows.reduce((s, r) => s + parseNum(r['POSS']), 0);
        const pts = rows.reduce((s, r) => s + parseNum(r['PTS']), 0);
        const fgAtt = rows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
        const fgMade = rows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
        return { poss, pts, ppp: poss > 0 ? pts / poss : 0, fgPct: fgAtt > 0 ? (fgMade / fgAtt) * 100 : 0 };
    };
    
    const leftBlockLeftShoulder = getBlockShoulderData('Left Block', 'Left Shoulder');
    const leftBlockRightShoulder = getBlockShoulderData('Left Block', 'Right Shoulder');
    const rightBlockLeftShoulder = getBlockShoulderData('Right Block', 'Left Shoulder');
    const rightBlockRightShoulder = getBlockShoulderData('Right Block', 'Right Shoulder');
    
    // ===== P&R UNPRESSURED (Including Passes minus pressure plays) =====
    const pnrUnpressuredPoss = Math.max(0, pnrInclPoss - pnrPressurePoss);
    const pnrUnpressuredPts = Math.max(0, pnrInclPts - pnrPressurePts);
    const pnrUnpressuredTOs = Math.max(0, pnrInclTOs - pnrPressureTOs);
    const pnrUnpressuredPPP = pnrUnpressuredPoss > 0 ? pnrUnpressuredPts / pnrUnpressuredPoss : 0;
    const pnrUnpressuredTOPct = pnrUnpressuredPoss > 0 ? (pnrUnpressuredTOs / pnrUnpressuredPoss) * 100 : 0;
    
    // ===== POST UNPRESSURED (Including Passes minus pressure plays) =====
    const postUnpressuredPoss = Math.max(0, postInclPoss - postPressurePoss);
    const postUnpressuredPts = Math.max(0, postInclPts - postPressurePts);
    // Get total post-up TOs from post direct rows
    const postDirectTOs = postRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    const postUnpressuredTOs = Math.max(0, postDirectTOs - postPressureTOs);
    const postUnpressuredPPP = postUnpressuredPoss > 0 ? postUnpressuredPts / postUnpressuredPoss : 0;
    const postUnpressuredTOPct = postUnpressuredPoss > 0 ? (postUnpressuredTOs / postUnpressuredPoss) * 100 : 0;
    
    // ===== SHOULDER OUTCOMES =====
    const shotOutcomeTypes = [
        { key: 'toHook', label: 'Hook', search: 'To Hook' },
        { key: 'toBasket', label: 'Basket', search: 'To Basket' },
        { key: 'toJumper', label: 'Jumper', search: 'To Jumper' },
        { key: 'toDropStep', label: 'Drop Step', search: 'To Drop Step' },
        { key: 'toUpAndUnder', label: 'Up & Under', search: 'To Up and Under' }
    ];
    
    // Get shot outcomes for a shoulder (overall)
    const getShoulderOutcomes = (shoulder) => {
        const outcomes = {};
        shotOutcomeTypes.forEach(outcome => {
            const outcomeRows = rawRows.filter(r =>
                r['Play Type'] === 'Post-Up' &&
                anySubCategory(r, shoulder) &&
                anySubCategory(r, outcome.search)
            );
            const poss = outcomeRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
            const pts = outcomeRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
            const fgAtt = outcomeRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
            const fgMade = outcomeRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
            outcomes[outcome.key] = {
                poss,
                ppp: poss > 0 ? pts / poss : 0,
                fgPct: fgAtt > 0 ? (fgMade / fgAtt) * 100 : 0,
                label: outcome.label
            };
        });
        return outcomes;
    };
    
    // Get shot outcomes for block > shoulder > shot type
    const getBlockShoulderOutcomes = (block, shoulder) => {
        const outcomes = {};
        shotOutcomeTypes.forEach(outcome => {
            const outcomeRows = rawRows.filter(r =>
                r['Play Type'] === 'Post-Up' &&
                anySubCategory(r, block) &&
                anySubCategory(r, shoulder) &&
                isSubCategorySummary(r, outcome.search)
            );
            const poss = outcomeRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
            const pts = outcomeRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
            const fgAtt = outcomeRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
            const fgMade = outcomeRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
            if (poss > 0) {
                outcomes[outcome.key] = {
                    poss,
                    ppp: poss > 0 ? pts / poss : 0,
                    fgPct: fgAtt > 0 ? (fgMade / fgAtt) * 100 : 0,
                    label: outcome.label
                };
            }
        });
        return outcomes;
    };
    
    const postLeftOutcomes = getShoulderOutcomes('Left Shoulder');
    const postRightOutcomes = getShoulderOutcomes('Right Shoulder');
    
    // Block > Shoulder > Shot Type outcomes
    const leftBlockLeftShoulderOutcomes = getBlockShoulderOutcomes('Left Block', 'Left Shoulder');
    const leftBlockRightShoulderOutcomes = getBlockShoulderOutcomes('Left Block', 'Right Shoulder');
    const rightBlockLeftShoulderOutcomes = getBlockShoulderOutcomes('Right Block', 'Left Shoulder');
    const rightBlockRightShoulderOutcomes = getBlockShoulderOutcomes('Right Block', 'Right Shoulder');
    
    // Calculate post/75 for threshold check
    const post75 = calcPer75(postInclPoss);
    const hasLowPostVolume = post75 !== null && post75 < 0.5;
    
    // Debug logging
    console.log('On-Ball Radar Debug:', {
        totalPoss,
        onBallDirectPoss,
        onBallInclPoss,
        onBallPct: totalPoss > 0 ? (onBallInclPoss / totalPoss) * 100 : 0,
        pnrBHPoss,
        isoPoss,
        postPoss,
        pnrInclPoss,
        pnrInclTOs,
        pnrTOPct,
        isoInclPoss,
        isoInclRowsCount: isoInclRows.length,
        postInclPoss,
        handlingMidAtt,
        handling3Att,
        pnrDribbleJumperRowsCount: pnrDribbleJumperRows.length
    });
    
    return {
        // Overall - Including Passes (Creation metrics)
        onBallDirectPoss,
        onBallInclPoss,
        onBallInclPts,
        totalPoss,
        onBallPct: totalPoss > 0 ? (onBallInclPoss / totalPoss) * 100 : 0,
        onBall75: calcPer75(onBallDirectPoss),
        onBallPPP: onBallInclPoss > 0 ? onBallInclPts / onBallInclPoss : 0,
        // NEW: Including Passes versions for Creation/75 and PPP
        onBallIncl75: calcPer75(onBallInclPoss),
        onBallInclPPP: onBallInclPoss > 0 ? onBallInclPts / onBallInclPoss : 0,
        
        // Self-Creation Breakdown (direct play types only, no passes)
        pnrBH75: calcPer75(pnrBHPoss),
        pnrBHPPP: pnrBHPoss > 0 ? pnrBHPts / pnrBHPoss : 0,
        _pnrBHPoss: pnrBHPoss,
        isoDirect75: calcPer75(isoPoss),
        isoDirectPPP: isoPoss > 0 ? isoPts / isoPoss : 0,
        _isoDirectPoss: isoPoss,
        postDirect75: calcPer75(postPoss),
        postDirectPPP: postPoss > 0 ? postPts / postPoss : 0,
        _postDirectPoss: postPoss,
        
        // P&R Overall
        pnrIncl75: calcPer75(pnrInclPoss),
        pnrInclPPP: pnrInclPoss > 0 ? pnrInclPts / pnrInclPoss : 0,
        pnrPressurePPP: pnrPressurePPP,
        pnrPressureTOPct: pnrPressureTOPct,
        pnrUnpressuredPPP: pnrUnpressuredPPP,
        pnrUnpressuredTOPct: pnrUnpressuredTOPct,
        _pnrInclPoss: pnrInclPoss,
        _pnrPressurePoss: pnrPressurePoss,
        
        // P&R Passing (FIXED: TO% from CSV directly)
        pnrPassPct: pnrPassPct,
        pnrTOPct: pnrTOPct,
        pnrRollAst75: calcPer75(pnrRollAstPts),
        pnrSpotUpAst75: calcPer75(pnrSpotUpAstPts),
        pnrRollAstPct: pnrRollAstPct,
        pnrSpotUpAstPct: pnrSpotUpAstPct,
        _pnrRollAstPts: pnrRollAstPts,
        _pnrSpotUpAstPts: pnrSpotUpAstPts,
        _pnrPassPoss: pnrPassPoss,
        
        // Handling Shot Distribution (FIXED: correct column names)
        handlingRim75: calcPer75(handlingRimAtt),
        handlingRimPct: handlingRimAtt > 0 ? (handlingRimMade / handlingRimAtt) * 100 : 0,
        handlingMid75: calcPer75(handlingMidAtt),
        handlingMidPct: handlingMidAtt > 0 ? (handlingMidMade / handlingMidAtt) * 100 : 0,
        handling3P75: calcPer75(handling3Att),
        handling3PPct: handling3Att > 0 ? (handling3Made / handling3Att) * 100 : 0,
        _handlingRimAtt: handlingRimAtt,
        _handlingMidAtt: handlingMidAtt,
        _handling3Att: handling3Att,
        
        // ISO (FIXED: correct play type name)
        iso75: calcPer75(isoInclPoss),
        isoPPP: isoInclPoss > 0 ? isoInclPts / isoInclPoss : 0,
        _isoInclPoss: isoInclPoss,
        
        // Post Overall
        post75: post75,
        postPPP: postInclPoss > 0 ? postInclPts / postInclPoss : 0,
        postPassPct: postInclPoss > 0 ? ((postInclPoss - postPoss) / postInclPoss) * 100 : 0,
        postPressurePPP: postPressurePPP,
        postPressureTOPct: postPressureTOPct,
        postUnpressuredPPP: postUnpressuredPPP,
        postUnpressuredTOPct: postUnpressuredTOPct,
        _postInclPoss: postInclPoss,
        _postPressurePoss: postPressurePoss,
        hasLowPostVolume: hasLowPostVolume,
        
        // Post L vs R SHOULDER - Extended
        postLeftPPP: postLeftPoss > 0 ? postLeftPts / postLeftPoss : 0,
        postLeftPct: totalPostShoulderPoss > 0 ? (postLeftPoss / totalPostShoulderPoss) * 100 : 0,
        postLeftEfg: postLeftFgAtt > 0 ? ((postLeftFgMade + 0.5 * postLeft3Made) / postLeftFgAtt) * 100 : 0,
        postLeftFtRate: postLeftFgAtt > 0 ? (postLeftFTAs / postLeftFgAtt) * 100 : 0,
        postLeftTOPct: postLeftPoss > 0 ? (postLeftTOs / postLeftPoss) * 100 : 0,
        postLeftOutcomes: postLeftOutcomes,
        postRightPPP: postRightPoss > 0 ? postRightPts / postRightPoss : 0,
        postRightPct: totalPostShoulderPoss > 0 ? (postRightPoss / totalPostShoulderPoss) * 100 : 0,
        postRightEfg: postRightFgAtt > 0 ? ((postRightFgMade + 0.5 * postRight3Made) / postRightFgAtt) * 100 : 0,
        postRightFtRate: postRightFgAtt > 0 ? (postRightFTAs / postRightFgAtt) * 100 : 0,
        postRightTOPct: postRightPoss > 0 ? (postRightTOs / postRightPoss) * 100 : 0,
        postRightOutcomes: postRightOutcomes,
        _postLeftPoss: postLeftPoss,
        _postRightPoss: postRightPoss,
        
        // Post L vs R BLOCK
        postLeftBlockPPP: postLeftBlockPoss > 0 ? postLeftBlockPts / postLeftBlockPoss : 0,
        postLeftBlockPct: totalPostBlockPoss > 0 ? (postLeftBlockPoss / totalPostBlockPoss) * 100 : 0,
        postLeftBlockFgPct: postLeftBlockFgAtt > 0 ? (postLeftBlockFgMade / postLeftBlockFgAtt) * 100 : 0,
        postLeftBlockTOPct: postLeftBlockPoss > 0 ? (postLeftBlockTOs / postLeftBlockPoss) * 100 : 0,
        postLeftBlockFtRate: postLeftBlockFgAtt > 0 ? (postLeftBlockFTAs / postLeftBlockFgAtt) * 100 : 0,
        postRightBlockPPP: postRightBlockPoss > 0 ? postRightBlockPts / postRightBlockPoss : 0,
        postRightBlockPct: totalPostBlockPoss > 0 ? (postRightBlockPoss / totalPostBlockPoss) * 100 : 0,
        postRightBlockFgPct: postRightBlockFgAtt > 0 ? (postRightBlockFgMade / postRightBlockFgAtt) * 100 : 0,
        postRightBlockTOPct: postRightBlockPoss > 0 ? (postRightBlockTOs / postRightBlockPoss) * 100 : 0,
        postRightBlockFtRate: postRightBlockFgAtt > 0 ? (postRightBlockFTAs / postRightBlockFgAtt) * 100 : 0,
        _postLeftBlockPoss: postLeftBlockPoss,
        _postRightBlockPoss: postRightBlockPoss,
        
        // Shoulders within each block
        leftBlockLeftShoulder: leftBlockLeftShoulder,
        leftBlockRightShoulder: leftBlockRightShoulder,
        rightBlockLeftShoulder: rightBlockLeftShoulder,
        rightBlockRightShoulder: rightBlockRightShoulder,
        
        // Block > Shoulder > Shot Type outcomes
        leftBlockLeftShoulderOutcomes: leftBlockLeftShoulderOutcomes,
        leftBlockRightShoulderOutcomes: leftBlockRightShoulderOutcomes,
        rightBlockLeftShoulderOutcomes: rightBlockLeftShoulderOutcomes,
        rightBlockRightShoulderOutcomes: rightBlockRightShoulderOutcomes
    };
}

// Calculate Spacing Radar Metrics from raw offense data
function calculateSpacingRadarMetrics(rawRows, matchedPoss) {
    // Get total possessions from main play types first (needed for fallback)
    const mainPlayTypeRows = rawRows.filter(r => MAIN_PLAY_TYPES.includes(r['Play Type']) && isMainPlayType(r));
    const totalPoss = mainPlayTypeRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    
    // Check if matchedPoss data is reliable
    const hasReliableMinutes = matchedPoss && 
        matchedPoss.totalPlayerMin > 0 && 
        matchedPoss.totalTeamMin > 0 && 
        matchedPoss.totalTeamPoss > 0;
    
    // Helper to calculate per75 with fallback
    const calcPer75 = (value) => {
        if (hasReliableMinutes) {
            return (value * 75 * matchedPoss.totalTeamMin) / (matchedPoss.totalPlayerMin * matchedPoss.totalTeamPoss);
        }
        // Fallback: simple ratio based on total possessions
        return totalPoss > 0 ? (value / totalPoss) * 75 : 0;
    };
    
    // ===== SPACING PLAY TYPES =====
    const spotUpRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Spot Up');
    const handoffsRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Handoffs');
    const offScreenRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Off Screen');
    
    const spotUpPoss = spotUpRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const spotUpPts = spotUpRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const handoffsPoss = handoffsRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const handoffsPts = handoffsRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const offScreenPoss = offScreenRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const offScreenPts = offScreenRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    
    // Spacing totals
    const spacingPoss = spotUpPoss + handoffsPoss + offScreenPoss;
    const spacingPts = spotUpPts + handoffsPts + offScreenPts;
    
    // Calculate TOs for spacing
    const spacingTOs = spotUpRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0) + handoffsRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0) + offScreenRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    
    // Calculate FT Rate for spacing
    const spacingFgAtt = spotUpRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0) +
                         handoffsRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0) +
                         offScreenRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const spacingFTAs = spotUpRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0) +
                        handoffsRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0) +
                        offScreenRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
    
    // ===== SPOT UP C&S (No Dribble Jumper) =====
    // Get Spot Up > No Dribble Jumper summary rows
    const spotUpNoDribbleRows = rawRows.filter(r =>
        r['Play Type'] === 'Spot Up' &&
        isSubCategorySummary(r, 'No Dribble Jumper')
    );
    const spotUpCnSPoss = spotUpNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const spotUpCnS3Att = spotUpNoDribbleRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0);
    const spotUpCnS3Made = spotUpNoDribbleRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
    
    // ===== GUARDED vs OPEN (No Dribble Jumper in Spot Up) =====
    const spotUpGuardedRows = rawRows.filter(r =>
        r['Play Type'] === 'Spot Up' &&
        anySubCategory(r, 'No Dribble Jumper') &&
        isSubCategorySummary(r, 'Guarded')
    );
    const spotUpOpenRows = rawRows.filter(r =>
        r['Play Type'] === 'Spot Up' &&
        anySubCategory(r, 'No Dribble Jumper') &&
        isSubCategorySummary(r, 'Open')
    );
    
    const guarded3Att = spotUpGuardedRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0);
    const guarded3Made = spotUpGuardedRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
    const open3Att = spotUpOpenRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0);
    const open3Made = spotUpOpenRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
    
    const guarded3Pct = guarded3Att > 0 ? (guarded3Made / guarded3Att) * 100 : 0;
    const open3Pct = open3Att > 0 ? (open3Made / open3Att) * 100 : 0;
    const total3Att = guarded3Att + open3Att;
    const guardedPct = total3Att > 0 ? (guarded3Att / total3Att) * 100 : 0;
    
    // Calculate Adjusted 3PT% (normalized to 50/50 open/guarded mix)
    // This gives equal weight to both shot types regardless of actual mix
    // Adjusted = 0.5 * Open3Pct + 0.5 * Guarded3Pct
    // This represents "what they would shoot if given equal mix of open and guarded"
    const adjusted3Pct = (open3Att > 0 || guarded3Att > 0) 
        ? (0.5 * open3Pct + 0.5 * guarded3Pct) 
        : 0;
    
    // ===== MOVING SHOTS (No Dribble Jumper in Handoffs + Off Screen) =====
    const handoffsNoDribbleRows = rawRows.filter(r =>
        r['Play Type'] === 'Handoffs' &&
        isSubCategorySummary(r, 'No Dribble Jumper')
    );
    const offScreenNoDribbleRows = rawRows.filter(r =>
        r['Play Type'] === 'Off Screen' &&
        isSubCategorySummary(r, 'No Dribble Jumper')
    );
    
    const movingPoss = handoffsNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                       offScreenNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const movingPts = handoffsNoDribbleRows.reduce((s, r) => s + parseNum(r['PTS']), 0) +
                      offScreenNoDribbleRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const moving3Att = handoffsNoDribbleRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0) +
                       offScreenNoDribbleRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0);
    const moving3Made = handoffsNoDribbleRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0) +
                        offScreenNoDribbleRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
    
    // ===== SPOT UP DRIVES =====
    // Spot Up drives = Drives Left, Drives Right, Drives Straight in Spot Up
    const spotUpDrivesRows = rawRows.filter(r =>
        r['Play Type'] === 'Spot Up' &&
        (isSubCategorySummary(r, 'Drives Left') || 
         isSubCategorySummary(r, 'Drives Right') || 
         isSubCategorySummary(r, 'Drives Straight'))
    );
    const spotUpDrivesPoss = spotUpDrivesRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const spotUpDrivesPts = spotUpDrivesRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const spotUpDrivesFgAtt = spotUpDrivesRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const spotUpDrivesFTAs = spotUpDrivesRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
    const spotUpDrivesTOs = spotUpDrivesRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    
    // ===== SPOT UP DRIVES LEFT vs RIGHT =====
    const spotUpDrivesLeftRows = rawRows.filter(r =>
        r['Play Type'] === 'Spot Up' &&
        isSubCategorySummary(r, 'Drives Left')
    );
    const spotUpDrivesRightRows = rawRows.filter(r =>
        r['Play Type'] === 'Spot Up' &&
        isSubCategorySummary(r, 'Drives Right')
    );
    
    const spotUpDrivesLeftPoss = spotUpDrivesLeftRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const spotUpDrivesLeftPts = spotUpDrivesLeftRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const spotUpDrivesRightPoss = spotUpDrivesRightRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const spotUpDrivesRightPts = spotUpDrivesRightRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    
    const totalSpotUpDrivesLR = spotUpDrivesLeftPoss + spotUpDrivesRightPoss;
    
    // ===== SPOT UP DRIVES SHOT TYPE BREAKDOWN =====
    // Helper to get shot breakdown for a drive direction
    const getSpotUpDriveShotBreakdown = (direction) => {
        // To Basket = Rim
        const toBasketRows = rawRows.filter(r =>
            r['Play Type'] === 'Spot Up' &&
            anySubCategory(r, direction) &&
            isSubCategorySummary(r, 'To Basket')
        );
        const rimAtt = toBasketRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
        const rimMade = toBasketRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
        
        // Dribble Jumper > 2 FG ATT = Mid, 3FG ATT = 3PT
        const dribbleJumperRows = rawRows.filter(r =>
            r['Play Type'] === 'Spot Up' &&
            anySubCategory(r, direction) &&
            isSubCategorySummary(r, 'Dribble Jumper')
        );
        const midAtt = dribbleJumperRows.reduce((s, r) => s + parseNum(r['2 FG ATT']), 0);
        const midMade = dribbleJumperRows.reduce((s, r) => s + parseNum(r['2 FG MADE']), 0);
        const threeAtt = dribbleJumperRows.reduce((s, r) => s + parseNum(r['3FG ATT']), 0);
        const threeMade = dribbleJumperRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
        
        const totalAtt = rimAtt + midAtt + threeAtt;
        
        return {
            rim: {
                att: rimAtt,
                made: rimMade,
                pct: totalAtt > 0 ? (rimAtt / totalAtt) * 100 : 0,
                fgPct: rimAtt > 0 ? (rimMade / rimAtt) * 100 : 0
            },
            mid: {
                att: midAtt,
                made: midMade,
                pct: totalAtt > 0 ? (midAtt / totalAtt) * 100 : 0,
                fgPct: midAtt > 0 ? (midMade / midAtt) * 100 : 0
            },
            three: {
                att: threeAtt,
                made: threeMade,
                pct: totalAtt > 0 ? (threeAtt / totalAtt) * 100 : 0,
                fgPct: threeAtt > 0 ? (threeMade / threeAtt) * 100 : 0
            },
            total: totalAtt
        };
    };
    
    const spotUpDrivesLeftShots = getSpotUpDriveShotBreakdown('Drives Left');
    const spotUpDrivesRightShots = getSpotUpDriveShotBreakdown('Drives Right');
    
    // Also get additional stats for LEFT
    const spotUpDrivesLeftFgAtt = spotUpDrivesLeftRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const spotUpDrivesLeftFgMade = spotUpDrivesLeftRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
    const spotUpDrivesLeftFg3Made = spotUpDrivesLeftRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
    const spotUpDrivesLeftFTAs = spotUpDrivesLeftRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
    const spotUpDrivesLeftTOs = spotUpDrivesLeftRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    
    // Also get additional stats for RIGHT
    const spotUpDrivesRightFgAtt = spotUpDrivesRightRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const spotUpDrivesRightFgMade = spotUpDrivesRightRows.reduce((s, r) => s + parseNum(r['FG MADE']), 0);
    const spotUpDrivesRightFg3Made = spotUpDrivesRightRows.reduce((s, r) => s + parseNum(r['3 FG MADE']), 0);
    const spotUpDrivesRightFTAs = spotUpDrivesRightRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
    const spotUpDrivesRightTOs = spotUpDrivesRightRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    
    // Drive% = Spot Up drives / (drives + no dribble jumper)
    const spotUpNoDribblePoss = spotUpNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const spotUpDrivePct = (spotUpDrivesPoss + spotUpNoDribblePoss) > 0 
        ? (spotUpDrivesPoss / (spotUpDrivesPoss + spotUpNoDribblePoss)) * 100 
        : 0;
    
    // ===== OFF SCREEN BREAKDOWN =====
    // Off Screen summary row for totals
    const offScreenSummaryRow = offScreenRows[0]; // Main play type summary row
    const offScreenSummaryPoss = offScreenSummaryRow ? parseNum(offScreenSummaryRow['POSS']) : 0;
    const offScreenSummaryPts = offScreenSummaryRow ? parseNum(offScreenSummaryRow['PTS']) : 0;
    
    // Off Screen drives = To Basket or Dribble Jumper rows
    const offScreenToBasketRows = rawRows.filter(r =>
        r['Play Type'] === 'Off Screen' &&
        isSubCategorySummary(r, 'To Basket')
    );
    const offScreenDribbleJumperRows = rawRows.filter(r =>
        r['Play Type'] === 'Off Screen' &&
        isSubCategorySummary(r, 'Dribble Jumper')
    );
    const offScreenDrivesPoss = offScreenToBasketRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                                offScreenDribbleJumperRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const offScreenNoDribblePoss = offScreenNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const offScreenDrivePct = (offScreenDrivesPoss + offScreenNoDribblePoss) > 0
        ? (offScreenDrivesPoss / (offScreenDrivesPoss + offScreenNoDribblePoss)) * 100
        : 0;
    
    // ===== HANDOFFS BREAKDOWN =====
    const handoffsSummaryRow = handoffsRows[0];
    const handoffsSummaryPoss = handoffsSummaryRow ? parseNum(handoffsSummaryRow['POSS']) : 0;
    const handoffsSummaryPts = handoffsSummaryRow ? parseNum(handoffsSummaryRow['PTS']) : 0;
    
    // Handoffs drives = To Basket or Dribble Jumper rows
    const handoffsToBasketRows = rawRows.filter(r =>
        r['Play Type'] === 'Handoffs' &&
        isSubCategorySummary(r, 'To Basket')
    );
    const handoffsDribbleJumperRows = rawRows.filter(r =>
        r['Play Type'] === 'Handoffs' &&
        isSubCategorySummary(r, 'Dribble Jumper')
    );
    const handoffsDrivesPoss = handoffsToBasketRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                               handoffsDribbleJumperRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const handoffsNoDribblePoss = handoffsNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const handoffsDrivePct = (handoffsDrivesPoss + handoffsNoDribblePoss) > 0
        ? (handoffsDrivesPoss / (handoffsDrivesPoss + handoffsNoDribblePoss)) * 100
        : 0;
    
    return {
        // Overall Spacing
        totalPoss,
        spacingPoss,
        spacingPts,
        spacing75: calcPer75(spacingPoss),
        spacingPct: totalPoss > 0 ? (spacingPoss / totalPoss) * 100 : 0,
        spacingPPP: spacingPoss > 0 ? spacingPts / spacingPoss : 0,
        spacingTOPct: spacingPoss > 0 ? (spacingTOs / spacingPoss) * 100 : 0,
        spacingFtRate: spacingFgAtt > 0 ? (spacingFTAs / spacingFgAtt) * 100 : 0,
        _spacingPoss: spacingPoss,
        
        // Spot-Up C&S (No Dribble Jumper)
        spotUpCnS75: calcPer75(spotUpCnSPoss),
        spotUpCnSPct: spotUpPoss > 0 ? (spotUpCnSPoss / spotUpPoss) * 100 : 0,
        _spotUpCnSPoss: spotUpCnSPoss,
        _spotUpPoss: spotUpPoss,
        
        // Guarded vs Open
        guardedPct: guardedPct,
        guarded3Pct: guarded3Pct,
        open3Pct: open3Pct,
        adjusted3Pct: adjusted3Pct,
        _guarded3Att: guarded3Att,
        _open3Att: open3Att,
        
        // Moving Shots (Handoffs + Off Screen No Dribble Jumper)
        moving75: calcPer75(movingPoss),
        movingPPP: movingPoss > 0 ? movingPts / movingPoss : 0,
        moving3Pct: moving3Att > 0 ? (moving3Made / moving3Att) * 100 : 0,
        _movingPoss: movingPoss,
        _moving3Att: moving3Att,
        
        // Spot Up Drives
        spotUpDrivePct: spotUpDrivePct,
        spotUpDrives75: calcPer75(spotUpDrivesPoss),
        spotUpDrivesPPP: spotUpDrivesPoss > 0 ? spotUpDrivesPts / spotUpDrivesPoss : 0,
        spotUpDrivesFtRate: spotUpDrivesFgAtt > 0 ? (spotUpDrivesFTAs / spotUpDrivesFgAtt) * 100 : 0,
        spotUpDrivesTOPct: spotUpDrivesPoss > 0 ? (spotUpDrivesTOs / spotUpDrivesPoss) * 100 : 0,
        _spotUpDrivesPoss: spotUpDrivesPoss,
        
        // Spot Up Drives Left vs Right
        spotUpDrivesLeftPct: totalSpotUpDrivesLR > 0 ? (spotUpDrivesLeftPoss / totalSpotUpDrivesLR) * 100 : 0,
        spotUpDrivesLeftPPP: spotUpDrivesLeftPoss > 0 ? spotUpDrivesLeftPts / spotUpDrivesLeftPoss : 0,
        spotUpDrivesLeftEfg: spotUpDrivesLeftFgAtt > 0 ? ((spotUpDrivesLeftFgMade + 0.5 * spotUpDrivesLeftFg3Made) / spotUpDrivesLeftFgAtt) * 100 : 0,
        spotUpDrivesLeftFtRate: spotUpDrivesLeftFgAtt > 0 ? (spotUpDrivesLeftFTAs / spotUpDrivesLeftFgAtt) * 100 : 0,
        spotUpDrivesLeftTOPct: spotUpDrivesLeftPoss > 0 ? (spotUpDrivesLeftTOs / spotUpDrivesLeftPoss) * 100 : 0,
        spotUpDrivesLeftShots: spotUpDrivesLeftShots,
        spotUpDrivesRightPct: totalSpotUpDrivesLR > 0 ? (spotUpDrivesRightPoss / totalSpotUpDrivesLR) * 100 : 0,
        spotUpDrivesRightPPP: spotUpDrivesRightPoss > 0 ? spotUpDrivesRightPts / spotUpDrivesRightPoss : 0,
        spotUpDrivesRightEfg: spotUpDrivesRightFgAtt > 0 ? ((spotUpDrivesRightFgMade + 0.5 * spotUpDrivesRightFg3Made) / spotUpDrivesRightFgAtt) * 100 : 0,
        spotUpDrivesRightFtRate: spotUpDrivesRightFgAtt > 0 ? (spotUpDrivesRightFTAs / spotUpDrivesRightFgAtt) * 100 : 0,
        spotUpDrivesRightTOPct: spotUpDrivesRightPoss > 0 ? (spotUpDrivesRightTOs / spotUpDrivesRightPoss) * 100 : 0,
        spotUpDrivesRightShots: spotUpDrivesRightShots,
        _spotUpDrivesLeftPoss: spotUpDrivesLeftPoss,
        _spotUpDrivesRightPoss: spotUpDrivesRightPoss,
        
        // Off Screen
        offScreen75: calcPer75(offScreenPoss),
        offScreenPPP: offScreenPoss > 0 ? offScreenPts / offScreenPoss : 0,
        offScreenDrivePct: offScreenDrivePct,
        _offScreenPoss: offScreenPoss,
        
        // Handoffs
        handoffs75: calcPer75(handoffsPoss),
        handoffsPPP: handoffsPoss > 0 ? handoffsPts / handoffsPoss : 0,
        handoffsDrivePct: handoffsDrivePct,
        _handoffsPoss: handoffsPoss
    };
}

// Calculate Finishing Radar Metrics
function calculateFinishingRadarMetrics(rawRows, matchedPoss) {
    // Get total possessions from main play types first (needed for fallback)
    const mainPlayTypeRows = rawRows.filter(r => MAIN_PLAY_TYPES.includes(r['Play Type']) && isMainPlayType(r));
    const totalPoss = mainPlayTypeRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    
    // Check if matchedPoss data is reliable
    const hasReliableMinutes = matchedPoss && 
        matchedPoss.totalPlayerMin > 0 && 
        matchedPoss.totalTeamMin > 0 && 
        matchedPoss.totalTeamPoss > 0;
    
    // Helper to calculate per75 with fallback
    const calcPer75 = (value) => {
        if (hasReliableMinutes) {
            return (value * 75 * matchedPoss.totalTeamMin) / (matchedPoss.totalPlayerMin * matchedPoss.totalTeamPoss);
        }
        // Fallback: simple ratio based on total possessions
        return totalPoss > 0 ? (value / totalPoss) * 75 : 0;
    };
    
    // ===== FINISHING PLAY TYPES (Cut, P&R Roll Man, Offensive Rebounds) =====
    const cutRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Cut');
    const rollManRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'P&R Roll Man');
    const putbackRows = mainPlayTypeRows.filter(r => r['Play Type'] === 'Offensive Rebounds (Put Backs)');
    
    const cutPoss = cutRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const cutPts = cutRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const rollManPoss = rollManRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const rollManPts = rollManRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const putbackPoss = putbackRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const putbackPts = putbackRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    
    // Finishing totals
    const finishingPoss = cutPoss + rollManPoss + putbackPoss;
    const finishingPts = cutPts + rollManPts + putbackPts;
    
    // Calculate TOs for finishing
    const finishingTOs = cutRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0) + rollManRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0) + putbackRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    
    // Calculate FT Rate for finishing
    const finishingFgAtt = cutRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0) +
                           rollManRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0) +
                           putbackRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const finishingFTAs = cutRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0) +
                          rollManRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0) +
                          putbackRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
    
    // ===== P&R ROLLS TO BASKET =====
    // P&R Roll Man > Rolls to Basket summary rows
    const rollsToBasketRows = rawRows.filter(r =>
        r['Play Type'] === 'P&R Roll Man' &&
        isSubCategorySummary(r, 'Rolls to Basket')
    );
    const rollsPoss = rollsToBasketRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const rollsPts = rollsToBasketRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const rollsFgAtt = rollsToBasketRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const rollsFTAs = rollsToBasketRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
    const rollsTOs = rollsToBasketRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    
    // ===== P&R POPS =====
    // P&R Roll Man > Pick and Pops summary rows + Slips the Pick > No Dribble Jumper
    const pickAndPopsRows = rawRows.filter(r =>
        r['Play Type'] === 'P&R Roll Man' &&
        isSubCategorySummary(r, 'Pick and Pops')
    );
    const slipsNoDribbleRows = rawRows.filter(r =>
        r['Play Type'] === 'P&R Roll Man' &&
        anySubCategory(r, 'Slips the Pick') &&
        isSubCategorySummary(r, 'No Dribble Jumper')
    );
    const popsPoss = pickAndPopsRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                     slipsNoDribbleRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const popsPts = pickAndPopsRows.reduce((s, r) => s + parseNum(r['PTS']), 0) +
                    slipsNoDribbleRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    
    // ===== P&R SLIPS (Slips the Pick summary rows) =====
    const slipsRows = rawRows.filter(r =>
        r['Play Type'] === 'P&R Roll Man' &&
        isSubCategorySummary(r, 'Slips the Pick')
    );
    const slipsPoss = slipsRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const slipsPts = slipsRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    
    // P&R Roll Man breakdown percentages (of main category)
    const rollsOfRollMan = rollManPoss > 0 ? (rollsPoss / rollManPoss) * 100 : 0;
    const popsOfRollMan = rollManPoss > 0 ? (pickAndPopsRows.reduce((s, r) => s + parseNum(r['POSS']), 0) / rollManPoss) * 100 : 0;
    const slipsOfRollMan = rollManPoss > 0 ? (slipsPoss / rollManPoss) * 100 : 0;
    
    // ===== SELF CUTS =====
    // Cut > Basket/Flash summary rows (not from screens)
    const cutBasketRows = rawRows.filter(r =>
        r['Play Type'] === 'Cut' &&
        isSubCategorySummary(r, 'Basket')
    );
    const cutFlashRows = rawRows.filter(r =>
        r['Play Type'] === 'Cut' &&
        isSubCategorySummary(r, 'Flash')
    );
    const selfCutPoss = cutBasketRows.reduce((s, r) => s + parseNum(r['POSS']), 0) +
                        cutFlashRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const selfCutPts = cutBasketRows.reduce((s, r) => s + parseNum(r['PTS']), 0) +
                       cutFlashRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const selfCutTOs = cutBasketRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0) + cutFlashRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    
    return {
        // Overall Finishing
        totalPoss,
        finishingPoss,
        finishingPts,
        finishing75: calcPer75(finishingPoss),
        finishingPct: totalPoss > 0 ? (finishingPoss / totalPoss) * 100 : 0,
        finishingPPP: finishingPoss > 0 ? finishingPts / finishingPoss : 0,
        finishingTOPct: finishingPoss > 0 ? (finishingTOs / finishingPoss) * 100 : 0,
        finishingFtRate: finishingFgAtt > 0 ? (finishingFTAs / finishingFgAtt) * 100 : 0,
        _finishingPoss: finishingPoss,
        
        // P&R Rolls to Basket
        rolls75: calcPer75(rollsPoss),
        rollsPPP: rollsPoss > 0 ? rollsPts / rollsPoss : 0,
        rollsFtRate: rollsFgAtt > 0 ? (rollsFTAs / rollsFgAtt) * 100 : 0,
        rollsTOPct: rollsPoss > 0 ? (rollsTOs / rollsPoss) * 100 : 0,
        _rollsPoss: rollsPoss,
        
        // P&R Pops
        pops75: calcPer75(popsPoss),
        popsPPP: popsPoss > 0 ? popsPts / popsPoss : 0,
        _popsPoss: popsPoss,
        
        // P&R Roll Man main category
        rollMan75: calcPer75(rollManPoss),
        _rollManPoss: rollManPoss,
        rollsOfRollMan: rollsOfRollMan,
        popsOfRollMan: popsOfRollMan,
        slipsOfRollMan: slipsOfRollMan,
        slips75: calcPer75(slipsPoss),
        slipsPPP: slipsPoss > 0 ? slipsPts / slipsPoss : 0,
        _slipsPoss: slipsPoss,
        
        // Self Cuts
        selfCut75: calcPer75(selfCutPoss),
        selfCutPPP: selfCutPoss > 0 ? selfCutPts / selfCutPoss : 0,
        selfCutTOPct: selfCutPoss > 0 ? (selfCutTOs / selfCutPoss) * 100 : 0,
        _selfCutPoss: selfCutPoss,
        
        // Put Backs
        putbacks75: calcPer75(putbackPoss),
        _putbacksPoss: putbackPoss
    };
}

// Calculate Defense Radar Metrics from raw data
function calculateDefenseRadarMetrics(defenseRows, matchedPoss) {
    if (!defenseRows || defenseRows.length === 0) return null;
    
    // Per-75 calculation
    const calcPer75 = (poss) => {
        if (!matchedPoss || !matchedPoss.totalPlayerMin || !matchedPoss.totalTeamMin || !matchedPoss.totalTeamPoss) {
            return null;
        }
        return (poss * 75 * matchedPoss.totalTeamMin) / (matchedPoss.totalPlayerMin * matchedPoss.totalTeamPoss);
    };
    
    const defMainRows = defenseRows.filter(r => isMainPlayType(r));
    const isoDefRows = defMainRows.filter(r => r['Play Type'] === 'Isolation');
    const pnrDefRows = defMainRows.filter(r => r['Play Type'] === 'P&R Ball Handler');
    const postDefRows = defMainRows.filter(r => r['Play Type'] === 'Post-Up');
    
    // Overall drives defense (from Overall play type)
    const drivesLeftDefRows = defenseRows.filter(r => r['Play Type'] === 'Overall' && isSubCategorySummary(r, 'Drives Left'));
    const drivesRightDefRows = defenseRows.filter(r => r['Play Type'] === 'Overall' && isSubCategorySummary(r, 'Drives Right'));
    const drivesStraightDefRows = defenseRows.filter(r => r['Play Type'] === 'Overall' && isSubCategorySummary(r, 'Drives Straight'));
    const allDrivesDefRows = [...drivesLeftDefRows, ...drivesRightDefRows, ...drivesStraightDefRows];
    
    // Spot Up drives defense
    const spotUpDriveDefRows = defenseRows.filter(r =>
        r['Play Type'] === 'Spot Up' &&
        (anySubCategory(r, 'Drives Left') || anySubCategory(r, 'Drives Right') || anySubCategory(r, 'Drives Straight')) &&
        (r['Sub Category 4'] === 'N/A' || !r['Sub Category 4'])
    );
    
    // On-ball defense (P&R BH + ISO + Spot Up Drives)
    const allOnBallDefRows = [...isoDefRows, ...pnrDefRows, ...spotUpDriveDefRows];
    const onBallDefPoss = allOnBallDefRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const onBallDefPts = allOnBallDefRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const onBallDefTOs = allOnBallDefRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    const onBallDefFgAtt = allOnBallDefRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const onBallDefFTAs = allOnBallDefRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
    
    // P&R Defense metrics
    const pnrDefPoss = pnrDefRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const pnrDefPts = pnrDefRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const pnrDefTOs = pnrDefRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    const pnrDefFgAtt = pnrDefRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const pnrDefFTAs = pnrDefRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
    
    // Drives Defense metrics
    const drivesDefPoss = allDrivesDefRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const drivesDefPts = allDrivesDefRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const drivesDefTOs = allDrivesDefRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    const drivesDefFgAtt = allDrivesDefRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const drivesDefFTAs = allDrivesDefRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
    
    // Post Defense metrics
    const postDefPoss = postDefRows.reduce((s, r) => s + parseNum(r['POSS']), 0);
    const postDefPts = postDefRows.reduce((s, r) => s + parseNum(r['PTS']), 0);
    const postDefTOs = postDefRows.reduce((s, r) => {
        const poss = parseNum(r['POSS']);
        const toPct = parseNum(r['TO%']);
        return s + (poss * toPct / 100);
    }, 0);
    const postDefFgAtt = postDefRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    const postDefFTAs = postDefRows.reduce((s, r) => s + parseNum(r['FTA/FGA']) * parseNum(r['FG ATT']), 0);
    
    // Overall defense TO%
    const allDefensiveRows = [...isoDefRows, ...pnrDefRows, ...postDefRows, ...spotUpDriveDefRows];
    const defTO = allDefensiveRows.reduce((s, r) => {
        const toPct = parsePct(r['TO%']);
        const poss = parseNum(r['POSS']);
        return s + (toPct * poss / 100);
    }, 0);
    const defFgAtt = allDefensiveRows.reduce((s, r) => s + parseNum(r['FG ATT']), 0);
    
    // STL and BLK from matchedPoss
    const stl75 = matchedPoss?.stl75;
    const blk75 = matchedPoss?.blk75;
    
    return {
        // OnBall Defense
        onBallDef75: calcPer75(onBallDefPoss),
        onBallDefPPP: onBallDefPoss > 0 ? onBallDefPts / onBallDefPoss : null,
        onBallDefTOPct: onBallDefPoss > 0 ? (onBallDefTOs / onBallDefPoss) * 100 : null,
        onBallDefFtRate: onBallDefFgAtt > 0 ? (onBallDefFTAs / onBallDefFgAtt) * 100 : null,
        _onBallDefPoss: onBallDefPoss,
        
        // P&R Defense
        pnrDef75: calcPer75(pnrDefPoss),
        pnrDefPPP: pnrDefPoss > 0 ? pnrDefPts / pnrDefPoss : null,
        pnrDefTOPct: pnrDefPoss > 0 ? (pnrDefTOs / pnrDefPoss) * 100 : null,
        pnrDefFtRate: pnrDefFgAtt > 0 ? (pnrDefFTAs / pnrDefFgAtt) * 100 : null,
        _pnrDefPoss: pnrDefPoss,
        
        // Drives Defense
        drivesDef75: calcPer75(drivesDefPoss),
        drivesDefPPP: drivesDefPoss > 0 ? drivesDefPts / drivesDefPoss : null,
        drivesDefTOPct: drivesDefPoss > 0 ? (drivesDefTOs / drivesDefPoss) * 100 : null,
        drivesDefFtRate: drivesDefFgAtt > 0 ? (drivesDefFTAs / drivesDefFgAtt) * 100 : null,
        _drivesDefPoss: drivesDefPoss,
        
        // Post Defense
        postDef75: calcPer75(postDefPoss),
        postDefPPP: postDefPoss > 0 ? postDefPts / postDefPoss : null,
        postDefTOPct: postDefPoss > 0 ? (postDefTOs / postDefPoss) * 100 : null,
        postDefFtRate: postDefFgAtt > 0 ? (postDefFTAs / postDefFgAtt) * 100 : null,
        _postDefPoss: postDefPoss,
        
        // Overall defense TO%
        defTOPct: (defTO + defFgAtt) > 0 ? (defTO / (defTO + defFgAtt)) * 100 : null,
        
        // Box Score
        stl75: stl75,
        blk75: blk75
    };
}

// On-Ball Circular Barplot Component
function OnBallRadarChart({ metrics: metricsOriginal, size = 560, radarPercentiles = null, onBallPct, onBallPPP }) {
    if (!metricsOriginal) return e('div', { className: 'radar-container' }, 'Loading...');
    
    // Override metrics.onBallPct with the passed prop
    const metrics = {
        ...metricsOriginal,
        onBallPct: onBallPct !== undefined ? onBallPct : metricsOriginal.onBallPct
    };
    
    const actualSize = 800;
    const centerX = actualSize / 2;
    const centerY = actualSize / 2;
    const innerRadius = actualSize * 0.025;  // Much smaller inner hole
    const maxBarLength = actualSize * 0.26;  // Longer bars to compensate
    const outerRadius = innerRadius + maxBarLength;
    
    // Category definitions with colors
    const categories = [
        { name: 'OVERALL', color: '#818cf8', metrics: ['onBallPct', 'onBallInclPPP'] },
        { name: 'P&R OVERALL', color: '#f472b6', metrics: ['pnrIncl75', 'pnrInclPPP', 'pnrPressurePPP', 'pnrPressureTOPct'] },
        { name: 'P&R PASSING', color: '#a78bfa', metrics: ['pnrPassPct', 'pnrTOPct', 'pnrRollAst75', 'pnrSpotUpAst75'] },
        { name: 'SHOT SELECTION', color: '#22d3ee', metrics: ['handlingRim75', 'handlingRimPct', 'handlingMid75', 'handlingMidPct', 'handling3P75', 'handling3PPct'] },
        { name: 'ISOLATION', color: '#fb923c', metrics: ['iso75', 'isoPPP'] },
        { name: 'POST OVERALL', color: '#facc15', metrics: ['post75', 'postPPP', 'postPassPct', 'postPressurePPP', 'postPressureTOPct'] },
        { name: 'POST L VS R', color: '#34d399', metrics: ['postLeftPPP', 'postLeftPct', 'postRightPPP', 'postRightPct'] }
    ];
    
    // Metric definitions
    const metricDefs = {
        'onBallPct': { label: 'OnBall%', format: 'pct' },
        'onBallInclPPP': { label: 'PPP', format: 'ppp' },
        'pnrIncl75': { label: 'P&R/75', format: 'dec' },
        'pnrInclPPP': { label: 'P&R PPP', format: 'ppp' },
        'pnrPressurePPP': { label: 'Press PPP', format: 'ppp' },
        'pnrPressureTOPct': { label: 'Press TO%', format: 'pct', inverse: true },
        'pnrPassPct': { label: 'Pass%', format: 'pct' },
        'pnrTOPct': { label: 'TO%', format: 'pct', inverse: true },
        'pnrRollAst75': { label: 'Roll AST', format: 'dec' },
        'pnrSpotUpAst75': { label: 'Spot AST', format: 'dec' },
        'handlingRim75': { label: 'Rim/75', format: 'dec' },
        'handlingRimPct': { label: 'Rim%', format: 'pct' },
        'handlingMid75': { label: 'Mid/75', format: 'dec' },
        'handlingMidPct': { label: 'Mid%', format: 'pct' },
        'handling3P75': { label: '3P/75', format: 'dec' },
        'handling3PPct': { label: '3P%', format: 'pct' },
        'iso75': { label: 'ISO/75', format: 'dec' },
        'isoPPP': { label: 'ISO PPP', format: 'ppp' },
        'post75': { label: 'Post/75', format: 'dec' },
        'postPPP': { label: 'Post PPP', format: 'ppp' },
        'postPassPct': { label: 'Pass%', format: 'pct' },
        'postPressurePPP': { label: 'Press PPP', format: 'ppp' },
        'postPressureTOPct': { label: 'Press TO%', format: 'pct', inverse: true },
        'postLeftPPP': { label: 'L PPP', format: 'ppp' },
        'postLeftPct': { label: 'L%', format: 'pct' },
        'postRightPPP': { label: 'R PPP', format: 'ppp' },
        'postRightPct': { label: 'R%', format: 'pct' }
    };
    
    // Volume-based dimming logic (preserved from original)
    const hasLowPostVolume = metrics.hasLowPostVolume;
    const postMetrics = ['post75', 'postPPP', 'postPassPct', 'postPressurePPP', 'postPressureTOPct', 'postLeftPPP', 'postLeftPct', 'postRightPPP', 'postRightPct'];
    const combinedOnBall75 = (metrics.pnrIncl75 || 0) + (metrics.iso75 || 0);
    const hasLowOnBallVolume = combinedOnBall75 < 2;
    const shotSelectionThreshold = 2.5;
    const shotSelectionVolumeLow = combinedOnBall75 < (shotSelectionThreshold * 0.8);
    const pnrVolumeLow = (metrics.pnrIncl75 || 0) < 1.6;
    const isoVolumeLow = (metrics.iso75 || 0) < 0.64;
    const postVolumeLow = (metrics.post75 || 0) < 0.64;
    
    // Build ordered metrics
    const radarMetricsBase = [];
    const categoryArcs = [];
    let currentIndex = 0;
    
    categories.forEach(cat => {
        const startIdx = currentIndex;
        cat.metrics.forEach(key => {
            let isDimmed = hasLowPostVolume && postMetrics.includes(key);
            
            if (key === 'handlingRim75' && shotSelectionVolumeLow) isDimmed = true;
            if (key === 'handlingRimPct' && shotSelectionVolumeLow) isDimmed = true;
            if (key === 'handlingMid75' && shotSelectionVolumeLow) isDimmed = true;
            if (key === 'handlingMidPct' && shotSelectionVolumeLow) isDimmed = true;
            if (key === 'handling3P75' && shotSelectionVolumeLow) isDimmed = true;
            if (key === 'handling3PPct' && shotSelectionVolumeLow) isDimmed = true;
            
            if ((key === 'pnrInclPPP' || key === 'pnrPassPct' || key === 'pnrTOPct' || key === 'pnrPressurePPP' || key === 'pnrPressureTOPct') && pnrVolumeLow) isDimmed = true;
            if (key === 'isoPPP' && isoVolumeLow) isDimmed = true;
            if ((key === 'postPPP' || key === 'postPassPct' || key === 'postPressurePPP' || key === 'postPressureTOPct' || key === 'postLeftPPP' || key === 'postLeftPct' || key === 'postRightPPP' || key === 'postRightPct') && postVolumeLow) isDimmed = true;
            
            radarMetricsBase.push({
                key,
                ...metricDefs[key],
                category: cat.name,
                categoryColor: cat.color,
                isDimmed: isDimmed
            });
            currentIndex++;
        });
        categoryArcs.push({
            name: cat.name,
            color: cat.color,
            startIdx,
            endIdx: currentIndex - 1,
            count: cat.metrics.length
        });
    });
    
    const numPoints = radarMetricsBase.length;
    const angleStep = (Math.PI * 2) / numPoints;
    const barWidth = angleStep * 0.7;
    
    const formatValue = (value, format) => {
        if (value === null || value === undefined) return '-';
        switch(format) {
            case 'ppp': return value.toFixed(2);
            case 'pct': return value.toFixed(0) + '%';
            case 'dec': return value.toFixed(1);
            default: return value.toFixed(1);
        }
    };
    
    const getPercentileColor = (pct) => {
        if (pct === null || pct === undefined) return 'rgba(100, 116, 139, 0.6)';
        if (pct === -1) return 'rgba(148, 163, 184, 0.9)';
        if (pct >= 90) return '#22c55e';
        if (pct >= 75) return '#84cc16';
        if (pct >= 60) return '#a3e635';
        if (pct >= 40) return '#fbbf24';
        if (pct >= 25) return '#fb923c';
        return '#ef4444';
    };
    
    // Calculate bar data
    const barData = radarMetricsBase.map((m, i) => {
        let value = metrics[m.key];
        if (value === null || value === undefined) value = 0;
        
        const pct = radarPercentiles?.[m.key];
        let normalizedValue;
        if (pct !== null && pct !== undefined && !isNaN(pct) && pct >= 0) {
            normalizedValue = Math.max(0.08, pct / 100);
        } else if (pct === -1) {
            normalizedValue = 0.5;
        } else {
            normalizedValue = 0.15;
        }
        
        if (m.isDimmed) normalizedValue = 0.1;
        
        const barLength = normalizedValue * maxBarLength;
        const angle = i * angleStep - Math.PI / 2;
        
        return {
            key: m.key,
            label: m.label,
            format: m.format,
            rawValue: metrics[m.key],
            normalizedValue,
            barLength,
            angle,
            percentile: pct,
            color: m.isDimmed ? 'rgba(100, 116, 139, 0.5)' : getPercentileColor(pct),
            categoryColor: m.categoryColor,
            category: m.category,
            isDimmed: m.isDimmed
        };
    });
    
    // Create arc path for a bar
    const createBarPath = (startAngle, barLength, barWidthAngle) => {
        const halfWidth = barWidthAngle / 2;
        const innerR = innerRadius;
        const outerR = innerRadius + barLength;
        
        const x1 = centerX + Math.cos(startAngle - halfWidth) * innerR;
        const y1 = centerY + Math.sin(startAngle - halfWidth) * innerR;
        const x2 = centerX + Math.cos(startAngle + halfWidth) * innerR;
        const y2 = centerY + Math.sin(startAngle + halfWidth) * innerR;
        const x3 = centerX + Math.cos(startAngle + halfWidth) * outerR;
        const y3 = centerY + Math.sin(startAngle + halfWidth) * outerR;
        const x4 = centerX + Math.cos(startAngle - halfWidth) * outerR;
        const y4 = centerY + Math.sin(startAngle - halfWidth) * outerR;
        
        return `M ${x1} ${y1} 
                A ${innerR} ${innerR} 0 0 1 ${x2} ${y2}
                L ${x3} ${y3}
                A ${outerR} ${outerR} 0 0 0 ${x4} ${y4}
                Z`;
    };
    
    const createCategoryArc = (cat) => {
        const startAngle = cat.startIdx * angleStep - Math.PI / 2 - angleStep * 0.35;
        const endAngle = (cat.endIdx + 1) * angleStep - Math.PI / 2 - angleStep * 0.65;
        const arcRadius = outerRadius + 12;
        const x1 = centerX + Math.cos(startAngle) * arcRadius;
        const y1 = centerY + Math.sin(startAngle) * arcRadius;
        const x2 = centerX + Math.cos(endAngle) * arcRadius;
        const y2 = centerY + Math.sin(endAngle) * arcRadius;
        const largeArc = (endAngle - startAngle) > Math.PI ? 1 : 0;
        return `M ${x1} ${y1} A ${arcRadius} ${arcRadius} 0 ${largeArc} 1 ${x2} ${y2}`;
    };
    
    // Create translucent category background wedge
    const createCategoryBackground = (cat) => {
        const startAngle = cat.startIdx * angleStep - Math.PI / 2 - angleStep * 0.35;
        const endAngle = (cat.endIdx + 1) * angleStep - Math.PI / 2 - angleStep * 0.65;
        const innerR = innerRadius;
        const outerR = outerRadius + 6;
        
        const x1 = centerX + Math.cos(startAngle) * innerR;
        const y1 = centerY + Math.sin(startAngle) * innerR;
        const x2 = centerX + Math.cos(endAngle) * innerR;
        const y2 = centerY + Math.sin(endAngle) * innerR;
        const x3 = centerX + Math.cos(endAngle) * outerR;
        const y3 = centerY + Math.sin(endAngle) * outerR;
        const x4 = centerX + Math.cos(startAngle) * outerR;
        const y4 = centerY + Math.sin(startAngle) * outerR;
        
        const largeArc = (endAngle - startAngle) > Math.PI ? 1 : 0;
        
        return `M ${x1} ${y1} 
                A ${innerR} ${innerR} 0 ${largeArc} 1 ${x2} ${y2}
                L ${x3} ${y3}
                A ${outerR} ${outerR} 0 ${largeArc} 0 ${x4} ${y4}
                Z`;
    };
    
    return e('div', { 
        className: 'radar-container',
        style: { 
            width: '100%', 
            display: 'flex', 
            flexDirection: 'column',
            alignItems: 'center',
            padding: '12px 0',
            background: 'rgba(0, 0, 0, 0.4)',
            borderRadius: '12px'
        }
    },
        // Header with on-ball % and PPP
        e('div', {
            style: {
                display: 'flex',
                justifyContent: 'space-between',
                width: '100%',
                padding: '0 16px 8px',
                marginBottom: '8px',
                borderBottom: '1px solid rgba(255,255,255,0.1)'
            }
        },
            e('div', {
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                }
            },
                e('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, 'ON-BALL %'),
                e('span', { 
                    style: { 
                        fontSize: '14px', 
                        fontWeight: '700', 
                        color: '#818cf8',
                        fontFamily: 'JetBrains Mono, monospace'
                    } 
                }, onBallPct ? onBallPct.toFixed(1) + '%' : '-')
            ),
            e('div', { style: { fontSize: '11px', fontWeight: '600', color: 'var(--text-primary)' } }, 'ON-BALL PROFILE'),
            e('div', {
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                }
            },
                e('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, 'PPP'),
                e('span', { 
                    style: { 
                        fontSize: '14px', 
                        fontWeight: '700', 
                        color: '#818cf8',
                        fontFamily: 'JetBrains Mono, monospace'
                    } 
                }, onBallPPP ? onBallPPP.toFixed(2) : '-')
            )
        ),
        
        // Low volume warning
        hasLowOnBallVolume && e('div', {
            style: {
                padding: '4px 12px',
                marginBottom: '8px',
                fontSize: '10px',
                color: '#fb923c',
                textAlign: 'center'
            }
        }, ' Low on-ball volume (<2/75 possessions)'),
        
        // Category legend
        e('div', {
            style: {
                display: 'flex',
                flexWrap: 'wrap',
                justifyContent: 'center',
                gap: '6px',
                marginBottom: '8px',
                padding: '0 12px'
            }
        },
            categories.map(cat => e('div', {
                key: cat.name,
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '3px',
                    padding: '2px 6px',
                    background: `${cat.color}22`,
                    borderRadius: '3px',
                    border: `1px solid ${cat.color}44`
                }
            },
                e('div', {
                    style: { width: '6px', height: '6px', borderRadius: '2px', background: cat.color }
                }),
                e('span', {
                    style: { fontSize: '8px', fontWeight: '600', color: cat.color, letterSpacing: '0.2px' }
                }, cat.name)
            ))
        ),
        
        // Circular Barplot SVG
        e('svg', { 
            viewBox: `0 0 ${actualSize} ${actualSize}`,
            width: '100%',
            preserveAspectRatio: 'xMidYMid meet',
            style: { maxWidth: actualSize + 'px', height: 'auto' }
        },
            e('defs', null,
                e('filter', { id: 'onballGlow', x: '-50%', y: '-50%', width: '200%', height: '200%' },
                    e('feGaussianBlur', { stdDeviation: '3', result: 'coloredBlur' }),
                    e('feMerge', null,
                        e('feMergeNode', { in: 'coloredBlur' }),
                        e('feMergeNode', { in: 'SourceGraphic' })
                    )
                ),
                e('filter', { id: 'onballStrongGlow', x: '-50%', y: '-50%', width: '200%', height: '200%' },
                    e('feGaussianBlur', { stdDeviation: '5', result: 'coloredBlur' }),
                    e('feMerge', null,
                        e('feMergeNode', { in: 'coloredBlur' }),
                        e('feMergeNode', { in: 'SourceGraphic' })
                    )
                )
            ),
            
            // Background circle
            e('circle', { cx: centerX, cy: centerY, r: outerRadius + 18, fill: 'rgba(0, 0, 0, 0.3)' }),
            
            // Percentile reference rings
            [0.25, 0.5, 0.75, 1].map((pct, i) => {
                const r = innerRadius + (pct * maxBarLength);
                return e('circle', {
                    key: `ring-${i}`,
                    cx: centerX,
                    cy: centerY,
                    r: r,
                    fill: 'none',
                    stroke: i === 3 ? 'rgba(255, 255, 255, 0.25)' : 'rgba(255, 255, 255, 0.1)',
                    strokeWidth: i === 3 ? 1.5 : 1,
                    strokeDasharray: i < 3 ? '4,8' : 'none'
                });
            }),
            
            // Tiny inner circle
            e('circle', {
                cx: centerX,
                cy: centerY,
                r: innerRadius,
                fill: 'rgba(10, 12, 16, 0.95)',
                stroke: 'rgba(129, 140, 248, 0.3)',
                strokeWidth: 1
            }),
            
            // Translucent category background wedges
            categoryArcs.map((cat, i) =>
                e('path', {
                    key: `cat-bg-${i}`,
                    d: createCategoryBackground(cat),
                    fill: cat.color,
                    opacity: 0.08
                })
            ),
            
            // Category arcs
            categoryArcs.map((cat, i) =>
                e('path', {
                    key: `cat-arc-${i}`,
                    d: createCategoryArc(cat),
                    fill: 'none',
                    stroke: cat.color,
                    strokeWidth: 5,
                    strokeLinecap: 'round',
                    opacity: 0.7
                })
            ),
            
            // Bars
            barData.map((bar, i) => {
                const pct = bar.percentile;
                const useStrongGlow = pct !== null && pct >= 75 && !bar.isDimmed;
                
                return e('path', {
                    key: `bar-${i}`,
                    d: createBarPath(bar.angle, bar.barLength, barWidth),
                    fill: bar.color,
                    stroke: 'rgba(255, 255, 255, 0.3)',
                    strokeWidth: 0.5,
                    filter: useStrongGlow ? 'url(#onballStrongGlow)' : 'url(#onballGlow)',
                    style: { transition: 'all 0.3s ease' }
                });
            }),
            
            // Labels
            barData.map((bar, i) => {
                const angle = bar.angle;
                const angleDeg = (angle * 180 / Math.PI + 360) % 360;
                const value = bar.rawValue;
                const pct = bar.percentile;
                const color = bar.isDimmed ? 'rgba(100, 116, 139, 0.6)' : getPercentileColor(pct);
                
                const labelR = outerRadius + 45;
                const labelX = centerX + Math.cos(angle) * labelR;
                const labelY = centerY + Math.sin(angle) * labelR;
                
                let textAnchor;
                if (angleDeg >= 350 || angleDeg < 10) {
                    textAnchor = 'middle';
                } else if (angleDeg >= 10 && angleDeg < 170) {
                    textAnchor = 'start';
                } else if (angleDeg >= 170 && angleDeg < 190) {
                    textAnchor = 'middle';
                } else {
                    textAnchor = 'end';
                }
                
                return e('g', { key: `label-${i}` },
                    // Connector line
                    e('line', {
                        x1: centerX + Math.cos(angle) * (innerRadius + bar.barLength + 3),
                        y1: centerY + Math.sin(angle) * (innerRadius + bar.barLength + 3),
                        x2: centerX + Math.cos(angle) * (labelR - 15),
                        y2: centerY + Math.sin(angle) * (labelR - 15),
                        stroke: bar.isDimmed ? 'rgba(100, 116, 139, 0.4)' : bar.categoryColor,
                        strokeWidth: 1,
                        opacity: 0.5
                    }),
                    
                    // Label
                    e('text', {
                        x: labelX,
                        y: labelY - 6,
                        textAnchor,
                        dominantBaseline: 'middle',
                        fill: bar.isDimmed ? 'rgba(100, 116, 139, 0.6)' : bar.categoryColor,
                        fontSize: '9px',
                        fontWeight: '600',
                        fontFamily: 'Sora, sans-serif'
                    }, bar.label),
                    
                    // Value + Percentile
                    e('text', {
                        x: labelX,
                        y: labelY + 7,
                        textAnchor,
                        dominantBaseline: 'middle',
                        fill: color,
                        fontSize: '9px',
                        fontWeight: '700',
                        fontFamily: 'JetBrains Mono, monospace'
                    }, pct !== null && pct !== undefined && pct >= 0 && !bar.isDimmed ? 
                        `${formatValue(value, bar.format)} (${Math.round(pct)})` : 
                        formatValue(value, bar.format)
                    )
                );
            })
        )
    );
}

// Defense Circular Barplot Component
function DefenseRadarChart({ metrics, size = 560, radarPercentiles = null, fallbackDef75 = null }) {
    if (!metrics) return e('div', { className: 'radar-container' }, 'Loading...');
    
    const actualSize = 800;
    const centerX = actualSize / 2;
    const centerY = actualSize / 2;
    const innerRadius = actualSize * 0.025;
    const maxBarLength = actualSize * 0.26;
    const outerRadius = innerRadius + maxBarLength;
    
    // Category definitions
    const categories = [
        { name: 'ON-BALL DEF', color: '#ef4444', metrics: ['onBallDef75', 'onBallDefPPP', 'onBallDefTOPct', 'onBallDefFtRate'] },
        { name: 'P&R DEF', color: '#f97316', metrics: ['pnrDef75', 'pnrDefPPP', 'pnrDefTOPct', 'pnrDefFtRate'] },
        { name: 'DRIVES DEF', color: '#eab308', metrics: ['drivesDef75', 'drivesDefPPP', 'drivesDefTOPct', 'drivesDefFtRate'] },
        { name: 'POST DEF', color: '#22c55e', metrics: ['postDef75', 'postDefPPP', 'postDefTOPct', 'postDefFtRate'] },
        { name: 'BOX SCORE', color: '#06b6d4', metrics: ['stl75', 'blk75'] }
    ];
    
    const metricDefs = {
        'onBallDef75': { label: 'OnBall/75', format: 'dec' },
        'onBallDefPPP': { label: 'OnBall PPP', format: 'ppp', inverse: true },
        'onBallDefTOPct': { label: 'OnBall TO%', format: 'pct', inverse: true },
        'onBallDefFtRate': { label: 'OnBall FT', format: 'pct', inverse: true },
        'pnrDef75': { label: 'P&R/75', format: 'dec' },
        'pnrDefPPP': { label: 'P&R PPP', format: 'ppp', inverse: true },
        'pnrDefTOPct': { label: 'P&R TO%', format: 'pct', inverse: true },
        'pnrDefFtRate': { label: 'P&R FT', format: 'pct', inverse: true },
        'drivesDef75': { label: 'Drives/75', format: 'dec' },
        'drivesDefPPP': { label: 'Drives PPP', format: 'ppp', inverse: true },
        'drivesDefTOPct': { label: 'Drives TO%', format: 'pct', inverse: true },
        'drivesDefFtRate': { label: 'Drives FT', format: 'pct', inverse: true },
        'postDef75': { label: 'Post/75', format: 'dec' },
        'postDefPPP': { label: 'Post PPP', format: 'ppp', inverse: true },
        'postDefTOPct': { label: 'Post TO%', format: 'pct', inverse: true },
        'postDefFtRate': { label: 'Post FT', format: 'pct', inverse: true },
        'stl75': { label: 'STL/75', format: 'dec' },
        'blk75': { label: 'BLK/75', format: 'dec' }
    };
    
    const def75 = fallbackDef75 || metrics?.onBallDef75 || 0;
    const hasLowDefVolume = def75 < 2;
    
    // Build ordered metrics
    const radarMetricsBase = [];
    const categoryArcs = [];
    let currentIndex = 0;
    
    categories.forEach(cat => {
        const startIdx = currentIndex;
        cat.metrics.forEach(key => {
            radarMetricsBase.push({
                key,
                ...metricDefs[key],
                category: cat.name,
                categoryColor: cat.color
            });
            currentIndex++;
        });
        categoryArcs.push({
            name: cat.name,
            color: cat.color,
            startIdx,
            endIdx: currentIndex - 1,
            count: cat.metrics.length
        });
    });
    
    const numPoints = radarMetricsBase.length;
    const angleStep = (Math.PI * 2) / numPoints;
    const barWidth = angleStep * 0.7;
    
    const formatValue = (value, format) => {
        if (value === null || value === undefined) return '-';
        switch(format) {
            case 'ppp': return value.toFixed(2);
            case 'pct': return value.toFixed(0) + '%';
            case 'dec': return value.toFixed(1);
            default: return value.toFixed(1);
        }
    };
    
    const getPercentileColor = (pct) => {
        if (pct === null || pct === undefined) return 'rgba(100, 116, 139, 0.6)';
        if (pct === -1) return 'rgba(148, 163, 184, 0.9)';
        if (pct >= 90) return '#22c55e';
        if (pct >= 75) return '#84cc16';
        if (pct >= 60) return '#a3e635';
        if (pct >= 40) return '#fbbf24';
        if (pct >= 25) return '#fb923c';
        return '#ef4444';
    };
    
    // Get header values
    const onBallDef75Value = metrics?.onBallDef75;
    const onBallDefPPPValue = metrics?.onBallDefPPP;
    const defTOPctValue = metrics?.defTOPct;
    
    // Calculate bar data
    const barData = radarMetricsBase.map((m, i) => {
        let value = metrics[m.key];
        if (value === null || value === undefined) value = 0;
        
        const pct = radarPercentiles?.[m.key];
        let normalizedValue;
        
        let isDimmed = hasLowDefVolume;
        
        if (pct !== null && pct !== undefined && !isNaN(pct) && pct >= 0 && !isDimmed) {
            normalizedValue = Math.max(0.08, pct / 100);
        } else if (pct === -1) {
            normalizedValue = 0.5;
            isDimmed = true;
        } else {
            normalizedValue = 0.15;
        }
        
        if (isDimmed) normalizedValue = 0.1;
        
        const barLength = normalizedValue * maxBarLength;
        const angle = i * angleStep - Math.PI / 2;
        
        return {
            key: m.key,
            label: m.label,
            format: m.format,
            rawValue: metrics[m.key],
            normalizedValue,
            barLength,
            angle,
            percentile: pct,
            color: isDimmed ? 'rgba(100, 116, 139, 0.5)' : getPercentileColor(pct),
            categoryColor: m.categoryColor,
            category: m.category,
            isDimmed
        };
    });
    
    // Create arc path for a bar
    const createBarPath = (startAngle, barLength, barWidthAngle) => {
        const halfWidth = barWidthAngle / 2;
        const innerR = innerRadius;
        const outerR = innerRadius + barLength;
        
        const x1 = centerX + Math.cos(startAngle - halfWidth) * innerR;
        const y1 = centerY + Math.sin(startAngle - halfWidth) * innerR;
        const x2 = centerX + Math.cos(startAngle + halfWidth) * innerR;
        const y2 = centerY + Math.sin(startAngle + halfWidth) * innerR;
        const x3 = centerX + Math.cos(startAngle + halfWidth) * outerR;
        const y3 = centerY + Math.sin(startAngle + halfWidth) * outerR;
        const x4 = centerX + Math.cos(startAngle - halfWidth) * outerR;
        const y4 = centerY + Math.sin(startAngle - halfWidth) * outerR;
        
        return `M ${x1} ${y1} 
                A ${innerR} ${innerR} 0 0 1 ${x2} ${y2}
                L ${x3} ${y3}
                A ${outerR} ${outerR} 0 0 0 ${x4} ${y4}
                Z`;
    };
    
    // Create category background wedge
    const createCategoryBackground = (cat) => {
        const startAngle = cat.startIdx * angleStep - Math.PI / 2 - angleStep * 0.4;
        const endAngle = (cat.endIdx + 1) * angleStep - Math.PI / 2 - angleStep * 0.6;
        const bgR = outerRadius + 15;
        
        const x1 = centerX + Math.cos(startAngle) * innerRadius;
        const y1 = centerY + Math.sin(startAngle) * innerRadius;
        const x2 = centerX + Math.cos(endAngle) * innerRadius;
        const y2 = centerY + Math.sin(endAngle) * innerRadius;
        const x3 = centerX + Math.cos(endAngle) * bgR;
        const y3 = centerY + Math.sin(endAngle) * bgR;
        const x4 = centerX + Math.cos(startAngle) * bgR;
        const y4 = centerY + Math.sin(startAngle) * bgR;
        
        const largeArcInner = (endAngle - startAngle) > Math.PI ? 1 : 0;
        const largeArcOuter = (endAngle - startAngle) > Math.PI ? 1 : 0;
        
        return `M ${x1} ${y1}
                A ${innerRadius} ${innerRadius} 0 ${largeArcInner} 1 ${x2} ${y2}
                L ${x3} ${y3}
                A ${bgR} ${bgR} 0 ${largeArcOuter} 0 ${x4} ${y4}
                Z`;
    };
    
    return e('div', {
        className: 'radar-container',
        style: { 
            position: 'relative',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            width: '100%',
            padding: '12px 0',
            background: 'rgba(0, 0, 0, 0.4)',
            borderRadius: '12px'
        }
    },
        // Header
        e('div', {
            style: {
                display: 'flex',
                justifyContent: 'space-between',
                width: '100%',
                padding: '0 16px 8px',
                marginBottom: '8px',
                borderBottom: '1px solid rgba(255,255,255,0.1)'
            }
        },
            e('div', {
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                }
            },
                e('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, 'ON-BALL DEF/75'),
                e('span', { 
                    style: { 
                        fontSize: '14px', 
                        fontWeight: '700', 
                        color: '#ef4444',
                        fontFamily: 'JetBrains Mono, monospace'
                    } 
                }, onBallDef75Value ? onBallDef75Value.toFixed(1) : '-')
            ),
            e('div', {
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                }
            },
                e('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, 'DEF PPP'),
                e('span', { 
                    style: { 
                        fontSize: '14px', 
                        fontWeight: '700', 
                        color: '#22d3ee',
                        fontFamily: 'JetBrains Mono, monospace'
                    } 
                }, onBallDefPPPValue ? onBallDefPPPValue.toFixed(2) : '-')
            ),
            e('div', {
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                }
            },
                e('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, 'DEF TO%'),
                e('span', { 
                    style: { 
                        fontSize: '14px', 
                        fontWeight: '700', 
                        color: '#22c55e',
                        fontFamily: 'JetBrains Mono, monospace'
                    } 
                }, defTOPctValue ? defTOPctValue.toFixed(1) + '%' : '-')
            )
        ),
        
        // Category legend
        e('div', {
            style: {
                display: 'flex',
                flexWrap: 'wrap',
                gap: '4px',
                justifyContent: 'center',
                marginBottom: '8px',
                padding: '0 12px'
            }
        },
            categories.map(cat => e('div', {
                key: cat.name,
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '3px',
                    padding: '2px 6px',
                    background: `${cat.color}22`,
                    borderRadius: '3px',
                    border: `1px solid ${cat.color}44`
                }
            },
                e('div', { style: { width: '6px', height: '6px', borderRadius: '50%', background: cat.color } }),
                e('span', { style: { fontSize: '8px', color: cat.color, fontWeight: '600' } }, cat.name)
            ))
        ),
        
        // Low volume warning
        hasLowDefVolume && e('div', {
            style: {
                padding: '4px 12px',
                marginBottom: '8px',
                fontSize: '10px',
                color: '#fb923c',
                textAlign: 'center'
            }
        }, ' Low defense volume (<2/75 on-ball possessions)'),
        
        // SVG Chart
        e('svg', {
            viewBox: `0 0 ${actualSize} ${actualSize}`,
            width: '100%',
            preserveAspectRatio: 'xMidYMid meet',
            style: { maxWidth: actualSize + 'px', height: 'auto' }
        },
            // Defs for glow effects
            e('defs', null,
                e('filter', { id: 'defenseGlow', x: '-50%', y: '-50%', width: '200%', height: '200%' },
                    e('feGaussianBlur', { stdDeviation: '3', result: 'coloredBlur' }),
                    e('feMerge', null,
                        e('feMergeNode', { in: 'coloredBlur' }),
                        e('feMergeNode', { in: 'SourceGraphic' })
                    )
                ),
                e('filter', { id: 'defenseStrongGlow', x: '-50%', y: '-50%', width: '200%', height: '200%' },
                    e('feGaussianBlur', { stdDeviation: '5', result: 'coloredBlur' }),
                    e('feMerge', null,
                        e('feMergeNode', { in: 'coloredBlur' }),
                        e('feMergeNode', { in: 'SourceGraphic' })
                    )
                )
            ),
            
            // Background circle
            e('circle', { cx: centerX, cy: centerY, r: outerRadius + 18, fill: 'rgba(0, 0, 0, 0.3)' }),
            
            // Percentile reference rings
            [0.25, 0.5, 0.75, 1].map((pct, i) => {
                const r = innerRadius + (pct * maxBarLength);
                return e('circle', {
                    key: `ring-${i}`,
                    cx: centerX,
                    cy: centerY,
                    r: r,
                    fill: 'none',
                    stroke: i === 3 ? 'rgba(255, 255, 255, 0.25)' : 'rgba(255, 255, 255, 0.1)',
                    strokeWidth: i === 3 ? 1.5 : 1,
                    strokeDasharray: i < 3 ? '4,8' : 'none'
                });
            }),
            
            // Inner circle
            e('circle', {
                cx: centerX,
                cy: centerY,
                r: innerRadius,
                fill: 'rgba(10, 12, 16, 0.95)',
                stroke: 'rgba(239, 68, 68, 0.3)',
                strokeWidth: 1
            }),
            
            // Translucent category background wedges
            categoryArcs.map((cat, i) =>
                e('path', {
                    key: `cat-bg-${i}`,
                    d: createCategoryBackground(cat),
                    fill: cat.color,
                    opacity: 0.08
                })
            ),
            
            // Category arcs
            categoryArcs.map((cat, i) => {
                const midAngle = ((cat.startIdx + cat.endIdx) / 2) * angleStep - Math.PI / 2;
                const arcR = outerRadius + 12;
                
                return e('path', {
                    key: `cat-arc-${i}`,
                    d: `M ${centerX + Math.cos(cat.startIdx * angleStep - Math.PI/2 - angleStep*0.35) * arcR}
                        ${centerY + Math.sin(cat.startIdx * angleStep - Math.PI/2 - angleStep*0.35) * arcR}
                        A ${arcR} ${arcR} 0 0 1
                        ${centerX + Math.cos((cat.endIdx + 1) * angleStep - Math.PI/2 - angleStep*0.65) * arcR}
                        ${centerY + Math.sin((cat.endIdx + 1) * angleStep - Math.PI/2 - angleStep*0.65) * arcR}`,
                    fill: 'none',
                    stroke: cat.color,
                    strokeWidth: 3,
                    strokeLinecap: 'round',
                    opacity: 0.7
                });
            }),
            
            // Bars
            barData.map((bar, i) => {
                const useStrongGlow = bar.percentile >= 75 && !bar.isDimmed;
                return e('path', {
                    key: `bar-${i}`,
                    d: createBarPath(bar.angle, bar.barLength, barWidth),
                    fill: bar.color,
                    stroke: 'rgba(255, 255, 255, 0.3)',
                    strokeWidth: 0.5,
                    filter: useStrongGlow ? 'url(#defenseStrongGlow)' : 'url(#defenseGlow)',
                    style: { transition: 'all 0.3s ease' }
                });
            }),
            
            // Labels
            barData.map((bar, i) => {
                const angle = bar.angle;
                const angleDeg = (angle * 180 / Math.PI + 360) % 360;
                const value = bar.rawValue;
                const pct = bar.percentile;
                const color = bar.isDimmed ? 'rgba(100, 116, 139, 0.6)' : getPercentileColor(pct);
                
                const labelR = outerRadius + 45;
                const labelX = centerX + Math.cos(angle) * labelR;
                const labelY = centerY + Math.sin(angle) * labelR;
                
                let textAnchor;
                if (angleDeg >= 350 || angleDeg < 10) {
                    textAnchor = 'middle';
                } else if (angleDeg >= 10 && angleDeg < 170) {
                    textAnchor = 'start';
                } else if (angleDeg >= 170 && angleDeg < 190) {
                    textAnchor = 'middle';
                } else {
                    textAnchor = 'end';
                }
                
                return e('g', { key: `label-${i}` },
                    // Connector line
                    e('line', {
                        x1: centerX + Math.cos(angle) * (innerRadius + bar.barLength + 3),
                        y1: centerY + Math.sin(angle) * (innerRadius + bar.barLength + 3),
                        x2: centerX + Math.cos(angle) * (labelR - 15),
                        y2: centerY + Math.sin(angle) * (labelR - 15),
                        stroke: bar.isDimmed ? 'rgba(100, 116, 139, 0.4)' : bar.categoryColor,
                        strokeWidth: 1,
                        opacity: 0.5
                    }),
                    
                    // Metric label
                    e('text', {
                        x: labelX,
                        y: labelY - 6,
                        textAnchor,
                        fill: bar.isDimmed ? 'rgba(100, 116, 139, 0.6)' : bar.categoryColor,
                        fontSize: '11px',
                        fontWeight: '600'
                    }, bar.label),
                    
                    // Value
                    e('text', {
                        x: labelX,
                        y: labelY + 8,
                        textAnchor,
                        fill: color,
                        fontSize: '13px',
                        fontWeight: '700',
                        fontFamily: 'JetBrains Mono, monospace'
                    }, formatValue(value, bar.format)),
                    
                    // Percentile
                    pct !== null && pct !== undefined && pct !== -1 && !bar.isDimmed && e('text', {
                        x: labelX,
                        y: labelY + 21,
                        textAnchor,
                        fill: color,
                        fontSize: '9px',
                        fontWeight: '500',
                        opacity: 0.8
                    }, `${Math.round(pct)}%ile`)
                );
            })
        )
    );
}

function PlaceholderRadar({ title }) {
    return e('div', { 
        className: 'radar-container',
        style: { 
            display: 'flex', 
            flexDirection: 'column', 
            alignItems: 'center',
            justifyContent: 'center',
            minHeight: '180px'
        }
    },
        e('svg', { viewBox: '0 0 100 100', width: 120, height: 120 },
            e('polygon', {
                points: '50,10 90,35 90,75 50,100 10,75 10,35',
                fill: 'none',
                stroke: 'rgba(255,255,255,0.2)',
                strokeWidth: 2
            }),
            e('polygon', {
                points: '50,30 70,42 70,68 50,80 30,68 30,42',
                fill: 'none',
                stroke: 'rgba(255,255,255,0.1)',
                strokeWidth: 1
            })
        ),
        e('div', { 
            style: { 
                fontSize: '0.7rem', 
                color: 'var(--text-muted)',
                marginTop: '8px'
            }
        }, title)
    );
}

// Camera Button Component for screenshot capture
function CameraButton({ onClick, style = {} }) {
    return e('button', {
        className: 'camera-btn',
        onClick: (ev) => { ev.stopPropagation(); onClick(); },
        title: 'Capture for social media (1920x1080)',
        style: style
    }, '');
}

// Helper: Get percentile color
function getScreenshotPctColor(pct) {
    if (pct === null || pct === undefined) return '#94a3b8';
    if (pct >= 90) return '#22c55e';
    if (pct >= 75) return '#4ade80';
    if (pct >= 60) return '#facc15';
    if (pct >= 40) return '#fb923c';
    if (pct >= 25) return '#f87171';
    return '#ef4444';
}

// Helper: Get PPP color
function getScreenshotPppColor(ppp) {
    if (ppp >= 1.15) return '#22c55e';
    if (ppp >= 1.0) return '#4ade80';
    if (ppp >= 0.9) return '#facc15';
    if (ppp >= 0.8) return '#fb923c';
    return '#ef4444';
}

// Screenshot Stat Row Component
function SSStatRow({ label, value, percentile, color, format = 'default' }) {
    const formatValue = (val) => {
        if (format === 'pct') return (val * 100).toFixed(1) + '%';
        if (format === 'ppp') return val.toFixed(2);
        if (format === 'dec') return val.toFixed(1);
        return val;
    };
    
    return e('div', { className: 'ss-stat-row' },
        e('span', { className: 'ss-stat-label' }, label),
        e('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' } },
            e('span', { 
                className: 'ss-stat-value',
                style: { color: color || 'var(--text-primary)' }
            }, formatValue(value)),
            percentile !== undefined && e('span', { 
                className: 'ss-percentile-badge',
                style: { 
                    background: `${getScreenshotPctColor(percentile)}22`,
                    color: getScreenshotPctColor(percentile)
                }
            }, Math.round(percentile) + 'th')
        )
    );
}

// Screenshot Bar Chart Component
function SSBarChart({ data, maxValue = null }) {
    const max = maxValue || Math.max(...data.map(d => d.value), 1);
    
    return e('div', { className: 'ss-bar-chart' },
        data.map((item, i) => 
            e('div', { key: i, className: 'ss-bar-row' },
                e('span', { className: 'ss-bar-label' }, item.label),
                e('div', { className: 'ss-bar-track' },
                    e('div', { 
                        className: 'ss-bar-fill',
                        style: { 
                            width: `${Math.max((item.value / max) * 100, 5)}%`,
                            background: item.color || 'linear-gradient(90deg, #6366f1, #8b5cf6)'
                        }
                    }, item.value > max * 0.15 ? item.displayValue || item.value.toFixed(1) : '')
                ),
                e('span', { 
                    className: 'ss-bar-value',
                    style: { color: item.valueColor || 'var(--text-primary)' }
                }, item.displayValue || item.value.toFixed(1) + (item.suffix || ''))
            )
        )
    );
}

// Screenshot Big Stat Component
function SSBigStat({ value, label, color, subvalue, sublabel }) {
    return e('div', { className: 'ss-big-stat' },
        e('div', { 
            className: 'ss-big-stat-value',
            style: { color: color || 'var(--text-primary)' }
        }, value),
        e('div', { className: 'ss-big-stat-label' }, label),
        subvalue && e('div', { 
            style: { 
                marginTop: '12px',
                fontSize: '1.2rem',
                color: 'var(--text-secondary)'
            }
        }, 
            e('span', { style: { fontWeight: '600' } }, subvalue),
            ' ',
            e('span', { style: { color: 'var(--text-muted)' } }, sublabel)
        )
    );
}

// Overview Section Screenshot Content
function ScreenshotOverview({ playerData, radar1Metrics, radar1Percentiles, playerRoleInfo, onBallRadarMetrics, spacingRadarMetrics, finishingRadarMetrics, defenseRadarMetrics }) {
    if (!playerData || !radar1Metrics) return null;
    
    return e('div', { className: 'ss-grid-2col' },
        // Left column - Key Stats
        e('div', { style: { display: 'flex', flexDirection: 'column', gap: '20px' } },
            // Creation Distribution
            e('div', { className: 'ss-card' },
                e('div', { className: 'ss-card-title', style: { color: '#a78bfa' } }, ' CREATION PROFILE'),
                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                    e(SSBigStat, { 
                        value: (radar1Metrics.onBallPct || 0).toFixed(0) + '%', 
                        label: 'ON-BALL',
                        color: '#f97316'
                    }),
                    e(SSBigStat, { 
                        value: (radar1Metrics.offBallPct || 0).toFixed(0) + '%', 
                        label: 'OFF-BALL',
                        color: '#06b6d4'
                    })
                ),
                e(SSBarChart, {
                    data: [
                        { label: 'ISO', value: playerData.playTypeStats?.['Isolation']?.pctOfPoss || 0, color: '#ef4444', suffix: '%' },
                        { label: 'P&R BH', value: playerData.playTypeStats?.['P&R Ball Handler']?.pctOfPoss || 0, color: '#f59e0b', suffix: '%' },
                        { label: 'SPOT UP', value: playerData.playTypeStats?.['Spot Up']?.pctOfPoss || 0, color: '#06b6d4', suffix: '%' },
                        { label: 'CUT', value: playerData.playTypeStats?.['Cut']?.pctOfPoss || 0, color: '#22c55e', suffix: '%' },
                        { label: 'TRANS', value: playerData.playTypeStats?.['Transition']?.pctOfPoss || 0, color: '#8b5cf6', suffix: '%' }
                    ],
                    maxValue: 40
                })
            ),
            // Role & Style
            e('div', { className: 'ss-card' },
                e('div', { className: 'ss-card-title', style: { color: '#60a5fa' } }, ' ROLE & STYLE'),
                e('div', { style: { fontSize: '2rem', fontFamily: 'Bebas Neue', letterSpacing: '2px', marginBottom: '16px', color: '#a78bfa' } }, 
                    playerRoleInfo?.role?.name || 'Versatile'
                ),
                e('div', { style: { color: 'var(--text-secondary)', lineHeight: '1.6' } }, 
                    playerRoleInfo?.role?.description || 'Balanced offensive player'
                )
            )
        ),
        // Right column - Efficiency
        e('div', { style: { display: 'flex', flexDirection: 'column', gap: '20px' } },
            e('div', { className: 'ss-card', style: { flex: 1 } },
                e('div', { className: 'ss-card-title', style: { color: '#22d3ee' } }, ' EFFICIENCY'),
                e(SSStatRow, { label: 'Overall PPP', value: radar1Metrics.overallPPP || 0, percentile: radar1Percentiles?.overallPPP, format: 'ppp', color: getScreenshotPppColor(radar1Metrics.overallPPP) }),
                e(SSStatRow, { label: 'On-Ball PPP', value: radar1Metrics.onBallPPP || 0, percentile: radar1Percentiles?.onBallPPP, format: 'ppp', color: getScreenshotPppColor(radar1Metrics.onBallPPP) }),
                e(SSStatRow, { label: 'Off-Ball PPP', value: radar1Metrics.offBallPPP || 0, percentile: radar1Percentiles?.offBallPPP, format: 'ppp', color: getScreenshotPppColor(radar1Metrics.offBallPPP) }),
                e(SSStatRow, { label: 'eFG%', value: radar1Metrics.efgPct || 0, percentile: radar1Percentiles?.efgPct, format: 'pct' }),
                e(SSStatRow, { label: 'TS%', value: radar1Metrics.tsPct || 0, percentile: radar1Percentiles?.tsPct, format: 'pct' })
            ),
            e('div', { className: 'ss-card' },
                e('div', { className: 'ss-card-title', style: { color: '#f59e0b' } }, ' VOLUME'),
                e(SSStatRow, { label: 'Total Possessions', value: playerData.totalPoss || 0, format: 'default' }),
                e(SSStatRow, { label: 'Usage/75', value: radar1Metrics.usage75 || 0, percentile: radar1Percentiles?.usage75, format: 'dec' }),
                e(SSStatRow, { label: 'Ast/75', value: radar1Metrics.ast75 || 0, percentile: radar1Percentiles?.ast75, format: 'dec' })
            )
        )
    );
}

// On-Ball Section Screenshot Content
function ScreenshotOnBall({ playerData, onBallRadarMetrics, onBallRadarPercentiles }) {
    if (!playerData || !onBallRadarMetrics) return null;
    
    const isoStats = playerData.playTypeStats?.['Isolation'] || {};
    const pnrStats = playerData.playTypeStats?.['P&R Ball Handler'] || {};
    const postStats = playerData.playTypeStats?.['Post-Up'] || {};
    
    return e('div', { className: 'ss-grid-3col' },
        // ISO Card
        e('div', { className: 'ss-card' },
            e('div', { className: 'ss-card-title', style: { color: '#ef4444' } }, ' ISOLATION'),
            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                e(SSBigStat, { 
                    value: (isoStats.pctOfPoss || 0).toFixed(1) + '%', 
                    label: 'OF POSS',
                    color: '#ef4444'
                }),
                e(SSBigStat, { 
                    value: (isoStats.ppp || 0).toFixed(2), 
                    label: 'PPP',
                    color: getScreenshotPppColor(isoStats.ppp)
                })
            ),
            e(SSStatRow, { label: 'ISO/75', value: onBallRadarMetrics.iso75 || 0, percentile: onBallRadarPercentiles?.iso75, format: 'dec' }),
            e(SSStatRow, { label: 'eFG%', value: isoStats.efgPct || 0, format: 'pct' }),
            e(SSStatRow, { label: 'TO%', value: isoStats.toPct || 0, format: 'pct', color: '#ef4444' }),
            e(SSStatRow, { label: 'FT Rate', value: isoStats.ftRate || 0, format: 'pct' })
        ),
        // P&R Card
        e('div', { className: 'ss-card' },
            e('div', { className: 'ss-card-title', style: { color: '#f59e0b' } }, ' P&R BALL HANDLER'),
            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                e(SSBigStat, { 
                    value: (pnrStats.pctOfPoss || 0).toFixed(1) + '%', 
                    label: 'OF POSS',
                    color: '#f59e0b'
                }),
                e(SSBigStat, { 
                    value: (pnrStats.ppp || 0).toFixed(2), 
                    label: 'PPP',
                    color: getScreenshotPppColor(pnrStats.ppp)
                })
            ),
            e(SSStatRow, { label: 'P&R/75', value: onBallRadarMetrics.pnr75 || 0, percentile: onBallRadarPercentiles?.pnr75, format: 'dec' }),
            e(SSStatRow, { label: 'Score%', value: onBallRadarMetrics.pnrScorePct || 0, format: 'pct' }),
            e(SSStatRow, { label: 'Pass%', value: onBallRadarMetrics.pnrPassPct || 0, format: 'pct', color: '#a78bfa' }),
            e(SSStatRow, { label: 'TO%', value: pnrStats.toPct || 0, format: 'pct', color: '#ef4444' })
        ),
        // Post Card
        e('div', { className: 'ss-card' },
            e('div', { className: 'ss-card-title', style: { color: '#22c55e' } }, ' POST-UP'),
            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                e(SSBigStat, { 
                    value: (postStats.pctOfPoss || 0).toFixed(1) + '%', 
                    label: 'OF POSS',
                    color: '#22c55e'
                }),
                e(SSBigStat, { 
                    value: (postStats.ppp || 0).toFixed(2), 
                    label: 'PPP',
                    color: getScreenshotPppColor(postStats.ppp)
                })
            ),
            e(SSStatRow, { label: 'Post/75', value: onBallRadarMetrics.post75 || 0, percentile: onBallRadarPercentiles?.post75, format: 'dec' }),
            e(SSStatRow, { label: 'eFG%', value: postStats.efgPct || 0, format: 'pct' }),
            e(SSStatRow, { label: 'TO%', value: postStats.toPct || 0, format: 'pct', color: '#ef4444' }),
            e(SSStatRow, { label: 'FT Rate', value: postStats.ftRate || 0, format: 'pct' })
        )
    );
}

// Spacing Section Screenshot Content
function ScreenshotSpacing({ playerData, spacingRadarMetrics, spacingRadarPercentiles }) {
    if (!playerData || !spacingRadarMetrics) return null;
    
    const spotStats = playerData.playTypeStats?.['Spot Up'] || {};
    const handoffStats = playerData.playTypeStats?.['Handoffs'] || {};
    const offScreenStats = playerData.playTypeStats?.['Off Screen'] || {};
    
    return e('div', { className: 'ss-grid-3col' },
        // Spot Up Card
        e('div', { className: 'ss-card' },
            e('div', { className: 'ss-card-title', style: { color: '#06b6d4' } }, ' SPOT UP'),
            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                e(SSBigStat, { 
                    value: (spotStats.pctOfPoss || 0).toFixed(1) + '%', 
                    label: 'OF POSS',
                    color: '#06b6d4'
                }),
                e(SSBigStat, { 
                    value: (spotStats.ppp || 0).toFixed(2), 
                    label: 'PPP',
                    color: getScreenshotPppColor(spotStats.ppp)
                })
            ),
            e(SSStatRow, { label: 'Spot/75', value: spacingRadarMetrics.spotUp75 || 0, percentile: spacingRadarPercentiles?.spotUp75, format: 'dec' }),
            e(SSStatRow, { label: 'Catch & Shoot', value: spacingRadarMetrics.spotUpCnSPct || 0, format: 'pct' }),
            e(SSStatRow, { label: 'Drives', value: spacingRadarMetrics.spotUpDrivesPct || 0, format: 'pct' }),
            e(SSStatRow, { label: '3PT%', value: spacingRadarMetrics.spotUp3Pct || 0, format: 'pct', color: '#22c55e' })
        ),
        // Handoffs Card
        e('div', { className: 'ss-card' },
            e('div', { className: 'ss-card-title', style: { color: '#f59e0b' } }, ' HANDOFFS'),
            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                e(SSBigStat, { 
                    value: (handoffStats.pctOfPoss || 0).toFixed(1) + '%', 
                    label: 'OF POSS',
                    color: '#f59e0b'
                }),
                e(SSBigStat, { 
                    value: (handoffStats.ppp || 0).toFixed(2), 
                    label: 'PPP',
                    color: getScreenshotPppColor(handoffStats.ppp)
                })
            ),
            e(SSStatRow, { label: 'HO/75', value: spacingRadarMetrics.handoffs75 || 0, percentile: spacingRadarPercentiles?.handoffs75, format: 'dec' }),
            e(SSStatRow, { label: 'eFG%', value: handoffStats.efgPct || 0, format: 'pct' }),
            e(SSStatRow, { label: 'TO%', value: handoffStats.toPct || 0, format: 'pct', color: '#ef4444' }),
            e(SSStatRow, { label: 'FT Rate', value: handoffStats.ftRate || 0, format: 'pct' })
        ),
        // Off Screen Card
        e('div', { className: 'ss-card' },
            e('div', { className: 'ss-card-title', style: { color: '#8b5cf6' } }, ' OFF SCREEN'),
            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                e(SSBigStat, { 
                    value: (offScreenStats.pctOfPoss || 0).toFixed(1) + '%', 
                    label: 'OF POSS',
                    color: '#8b5cf6'
                }),
                e(SSBigStat, { 
                    value: (offScreenStats.ppp || 0).toFixed(2), 
                    label: 'PPP',
                    color: getScreenshotPppColor(offScreenStats.ppp)
                })
            ),
            e(SSStatRow, { label: 'OffScr/75', value: spacingRadarMetrics.offScreen75 || 0, percentile: spacingRadarPercentiles?.offScreen75, format: 'dec' }),
            e(SSStatRow, { label: 'eFG%', value: offScreenStats.efgPct || 0, format: 'pct' }),
            e(SSStatRow, { label: 'TO%', value: offScreenStats.toPct || 0, format: 'pct', color: '#ef4444' }),
            e(SSStatRow, { label: 'FT Rate', value: offScreenStats.ftRate || 0, format: 'pct' })
        )
    );
}

// Finishing Section Screenshot Content
function ScreenshotFinishing({ playerData, finishingRadarMetrics, finishingRadarPercentiles }) {
    if (!playerData || !finishingRadarMetrics) return null;
    
    const cutStats = playerData.playTypeStats?.['Cut'] || {};
    const rollStats = playerData.playTypeStats?.['P&R Roll Man'] || {};
    const orebStats = playerData.playTypeStats?.['Offensive Rebounds'] || {};
    
    return e('div', { className: 'ss-grid-3col' },
        // Cut Card
        e('div', { className: 'ss-card' },
            e('div', { className: 'ss-card-title', style: { color: '#22c55e' } }, ' CUTS'),
            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                e(SSBigStat, { 
                    value: (cutStats.pctOfPoss || 0).toFixed(1) + '%', 
                    label: 'OF POSS',
                    color: '#22c55e'
                }),
                e(SSBigStat, { 
                    value: (cutStats.ppp || 0).toFixed(2), 
                    label: 'PPP',
                    color: getScreenshotPppColor(cutStats.ppp)
                })
            ),
            e(SSStatRow, { label: 'Cut/75', value: finishingRadarMetrics.cut75 || 0, percentile: finishingRadarPercentiles?.cut75, format: 'dec' }),
            e(SSStatRow, { label: 'FG%', value: cutStats.fgPct || 0, format: 'pct' }),
            e(SSStatRow, { label: 'FT Rate', value: cutStats.ftRate || 0, format: 'pct' })
        ),
        // Roll Man Card
        e('div', { className: 'ss-card' },
            e('div', { className: 'ss-card-title', style: { color: '#f59e0b' } }, ' ROLL MAN'),
            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                e(SSBigStat, { 
                    value: (rollStats.pctOfPoss || 0).toFixed(1) + '%', 
                    label: 'OF POSS',
                    color: '#f59e0b'
                }),
                e(SSBigStat, { 
                    value: (rollStats.ppp || 0).toFixed(2), 
                    label: 'PPP',
                    color: getScreenshotPppColor(rollStats.ppp)
                })
            ),
            e(SSStatRow, { label: 'Roll/75', value: finishingRadarMetrics.rollMan75 || 0, percentile: finishingRadarPercentiles?.rollMan75, format: 'dec' }),
            e(SSStatRow, { label: 'FG%', value: rollStats.fgPct || 0, format: 'pct' }),
            e(SSStatRow, { label: 'Slip vs Roll', value: finishingRadarMetrics.rollSlipPct || 0, format: 'pct' }),
            e(SSStatRow, { label: 'Pop%', value: finishingRadarMetrics.rollPopPct || 0, format: 'pct' })
        ),
        // OREB Card
        e('div', { className: 'ss-card' },
            e('div', { className: 'ss-card-title', style: { color: '#8b5cf6' } }, ' OFFENSIVE BOARDS'),
            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                e(SSBigStat, { 
                    value: (orebStats.pctOfPoss || 0).toFixed(1) + '%', 
                    label: 'OF POSS',
                    color: '#8b5cf6'
                }),
                e(SSBigStat, { 
                    value: (orebStats.ppp || 0).toFixed(2), 
                    label: 'PPP',
                    color: getScreenshotPppColor(orebStats.ppp)
                })
            ),
            e(SSStatRow, { label: 'OREB/75', value: finishingRadarMetrics.oreb75 || 0, percentile: finishingRadarPercentiles?.oreb75, format: 'dec' }),
            e(SSStatRow, { label: 'Putback%', value: finishingRadarMetrics.orebPutbackPct || 0, format: 'pct' }),
            e(SSStatRow, { label: 'FG%', value: orebStats.fgPct || 0, format: 'pct' })
        )
    );
}

// Defense Section Screenshot Content
function ScreenshotDefense({ defenseRadarMetrics, defenseRadarPercentiles }) {
    if (!defenseRadarMetrics) return null;
    
    return e('div', { className: 'ss-grid-2col' },
        // Left column - On-Ball & P&R Defense
        e('div', { style: { display: 'flex', flexDirection: 'column', gap: '20px' } },
            e('div', { className: 'ss-card' },
                e('div', { className: 'ss-card-title', style: { color: '#ef4444' } }, ' ON-BALL DEFENSE'),
                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                    e(SSBigStat, { 
                        value: (defenseRadarMetrics.onBallDef75 || 0).toFixed(1), 
                        label: 'DEF/75',
                        color: '#ef4444'
                    }),
                    e(SSBigStat, { 
                        value: (defenseRadarMetrics.onBallDefPPP || 0).toFixed(2), 
                        label: 'OPP PPP',
                        color: (defenseRadarMetrics.onBallDefPPP || 1) <= 0.9 ? '#22c55e' : '#ef4444'
                    })
                ),
                e(SSStatRow, { label: 'Def TO%', value: defenseRadarMetrics.onBallDefTOPct || 0, percentile: defenseRadarPercentiles?.onBallDefTOPct, format: 'pct', color: '#22d3ee' }),
                e(SSStatRow, { label: 'Opp FT Rate', value: defenseRadarMetrics.onBallDefFtRate || 0, format: 'pct' })
            ),
            e('div', { className: 'ss-card' },
                e('div', { className: 'ss-card-title', style: { color: '#f59e0b' } }, ' P&R DEFENSE'),
                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '20px' } },
                    e(SSBigStat, { 
                        value: (defenseRadarMetrics.pnrDef75 || 0).toFixed(1), 
                        label: 'DEF/75',
                        color: '#f59e0b'
                    }),
                    e(SSBigStat, { 
                        value: (defenseRadarMetrics.pnrDefPPP || 0).toFixed(2), 
                        label: 'OPP PPP',
                        color: (defenseRadarMetrics.pnrDefPPP || 1) <= 0.9 ? '#22c55e' : '#ef4444'
                    })
                ),
                e(SSStatRow, { label: 'Def TO%', value: defenseRadarMetrics.pnrDefTOPct || 0, percentile: defenseRadarPercentiles?.pnrDefTOPct, format: 'pct', color: '#22d3ee' }),
                e(SSStatRow, { label: 'Opp FT Rate', value: defenseRadarMetrics.pnrDefFtRate || 0, format: 'pct' })
            )
        ),
        // Right column - Drives & Post Defense + Stocks
        e('div', { style: { display: 'flex', flexDirection: 'column', gap: '20px' } },
            e('div', { className: 'ss-card' },
                e('div', { className: 'ss-card-title', style: { color: '#22c55e' } }, ' DRIVES & POST DEF'),
                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px' } },
                    e('div', { style: { background: 'rgba(249,115,22,0.1)', borderRadius: '8px', padding: '12px' } },
                        e('div', { style: { fontSize: '0.9rem', color: 'var(--text-muted)', marginBottom: '8px' } }, 'DRIVES DEF'),
                        e('div', { style: { fontSize: '1.8rem', fontFamily: 'Bebas Neue', color: '#f97316' } }, (defenseRadarMetrics.drivesDef75 || 0).toFixed(1)),
                        e('div', { style: { fontSize: '1rem', color: getScreenshotPppColor(1 / (defenseRadarMetrics.drivesDefPPP || 1)) } }, 
                            (defenseRadarMetrics.drivesDefPPP || 0).toFixed(2) + ' PPP'
                        )
                    ),
                    e('div', { style: { background: 'rgba(34,197,94,0.1)', borderRadius: '8px', padding: '12px' } },
                        e('div', { style: { fontSize: '0.9rem', color: 'var(--text-muted)', marginBottom: '8px' } }, 'POST DEF'),
                        e('div', { style: { fontSize: '1.8rem', fontFamily: 'Bebas Neue', color: '#22c55e' } }, (defenseRadarMetrics.postDef75 || 0).toFixed(1)),
                        e('div', { style: { fontSize: '1rem', color: getScreenshotPppColor(1 / (defenseRadarMetrics.postDefPPP || 1)) } }, 
                            (defenseRadarMetrics.postDefPPP || 0).toFixed(2) + ' PPP'
                        )
                    )
                )
            ),
            e('div', { className: 'ss-card' },
                e('div', { className: 'ss-card-title', style: { color: '#22d3ee' } }, ' STOCKS'),
                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '16px', marginTop: '12px' } },
                    e(SSBigStat, { 
                        value: (defenseRadarMetrics.stl75 || 0).toFixed(1), 
                        label: 'STL/75',
                        color: '#22d3ee'
                    }),
                    e(SSBigStat, { 
                        value: (defenseRadarMetrics.blk75 || 0).toFixed(1), 
                        label: 'BLK/75',
                        color: '#a78bfa'
                    }),
                    e(SSBigStat, { 
                        value: ((defenseRadarMetrics.defTOPct || 0) * 100).toFixed(1) + '%', 
                        label: 'DEF TO%',
                        color: '#22c55e'
                    })
                )
            )
        )
    );
}

// Player Profile Section Screenshot Content
function ScreenshotProfile({ playerData, radar1Metrics, radar1Percentiles, playerRoleInfo, onBallRadarMetrics, spacingRadarMetrics, finishingRadarMetrics, defenseRadarMetrics, defenseRadarPercentiles }) {
    if (!playerData || !radar1Metrics) return null;
    
    return e('div', { className: 'ss-grid-2col' },
        // Left - Offense Summary
        e('div', { className: 'ss-card' },
            e('div', { className: 'ss-card-title', style: { color: '#f97316' } }, ' OFFENSE'),
            e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '12px', marginBottom: '20px' } },
                e(SSBigStat, { 
                    value: (radar1Metrics.overallPPP || 0).toFixed(2), 
                    label: 'PPP',
                    color: getScreenshotPppColor(radar1Metrics.overallPPP)
                }),
                e(SSBigStat, { 
                    value: ((radar1Metrics.efgPct || 0) * 100).toFixed(1) + '%', 
                    label: 'eFG%',
                    color: '#22d3ee'
                }),
                e(SSBigStat, { 
                    value: (radar1Metrics.usage75 || 0).toFixed(1), 
                    label: 'USG/75',
                    color: '#a78bfa'
                })
            ),
            e(SSStatRow, { label: 'On-Ball%', value: radar1Metrics.onBallPct || 0, format: 'pct', color: '#f97316' }),
            e(SSStatRow, { label: 'On-Ball PPP', value: radar1Metrics.onBallPPP || 0, percentile: radar1Percentiles?.onBallPPP, format: 'ppp' }),
            e(SSStatRow, { label: 'Off-Ball%', value: radar1Metrics.offBallPct || 0, format: 'pct', color: '#06b6d4' }),
            e(SSStatRow, { label: 'Off-Ball PPP', value: radar1Metrics.offBallPPP || 0, percentile: radar1Percentiles?.offBallPPP, format: 'ppp' }),
            e(SSStatRow, { label: 'AST/75', value: radar1Metrics.ast75 || 0, percentile: radar1Percentiles?.ast75, format: 'dec' }),
            e(SSStatRow, { label: 'TO%', value: radar1Metrics.toPct || 0, format: 'pct', color: '#ef4444' })
        ),
        // Right - Defense Summary
        e('div', { className: 'ss-card' },
            e('div', { className: 'ss-card-title', style: { color: '#ef4444' } }, ' DEFENSE'),
            defenseRadarMetrics ? e(React.Fragment, null,
                e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '12px', marginBottom: '20px' } },
                    e(SSBigStat, { 
                        value: (defenseRadarMetrics.onBallDef75 || 0).toFixed(1), 
                        label: 'DEF/75',
                        color: '#ef4444'
                    }),
                    e(SSBigStat, { 
                        value: (defenseRadarMetrics.onBallDefPPP || 0).toFixed(2), 
                        label: 'OPP PPP',
                        color: (defenseRadarMetrics.onBallDefPPP || 1) <= 0.9 ? '#22c55e' : '#f59e0b'
                    }),
                    e(SSBigStat, { 
                        value: (defenseRadarMetrics.stl75 || 0).toFixed(1), 
                        label: 'STL/75',
                        color: '#22d3ee'
                    })
                ),
                e(SSStatRow, { label: 'On-Ball Def/75', value: defenseRadarMetrics.onBallDef75 || 0, percentile: defenseRadarPercentiles?.onBallDef75, format: 'dec' }),
                e(SSStatRow, { label: 'P&R Def/75', value: defenseRadarMetrics.pnrDef75 || 0, percentile: defenseRadarPercentiles?.pnrDef75, format: 'dec' }),
                e(SSStatRow, { label: 'BLK/75', value: defenseRadarMetrics.blk75 || 0, percentile: defenseRadarPercentiles?.blk75, format: 'dec' }),
                e(SSStatRow, { label: 'Def TO%', value: defenseRadarMetrics.defTOPct || 0, percentile: defenseRadarPercentiles?.defTOPct, format: 'pct', color: '#22c55e' })
            ) : e('div', { style: { color: 'var(--text-muted)', textAlign: 'center', padding: '40px' } }, 'No defense data available')
        )
    );
}

// Main Screenshot Modal Component - Uses off-screen rendering for perfect 1920x1080 capture
function ScreenshotModal({ 
    isOpen, 
    onClose, 
    onCapture, 
    screenshotRef,
    title,
    section,
    sourceElementId,
    playerName,
    playerTeam,
    playerPhoto,
    playerRole,
    selectedSeasons
}) {
    const [previewScale, setPreviewScale] = useState(0.5);
    const [isCapturing, setIsCapturing] = useState(false);
    const captureContainerRef = React.useRef(null);
    
    // Handle viewport resize for preview scaling
    useEffect(() => {
        const updateScale = () => {
            const vw = window.innerWidth - 80;
            const vh = window.innerHeight - 140;
            const scaleX = vw / 1920;
            const scaleY = vh / 1080;
            setPreviewScale(Math.min(scaleX, scaleY, 0.6));
        };
        updateScale();
        window.addEventListener('resize', updateScale);
        return () => window.removeEventListener('resize', updateScale);
    }, []);
    
    // Build the capture container when modal opens
    useEffect(() => {
        if (!isOpen || !sourceElementId) return;
        
        const sourceElement = document.getElementById(sourceElementId);
        if (!sourceElement) {
            console.warn('Source element not found:', sourceElementId);
            return;
        }
        
        // Get the capture container
        const captureContainer = captureContainerRef.current;
        if (!captureContainer) return;
        
        // Clear previous content from the body area
        const bodyArea = captureContainer.querySelector('.ss-body-area');
        if (bodyArea) bodyArea.innerHTML = '';
        
        // Clone the source element
        const clone = sourceElement.cloneNode(true);
        clone.removeAttribute('id');
        clone.classList.add('screenshot-clone');
        
        // Remove camera buttons
        clone.querySelectorAll('.camera-btn').forEach(btn => btn.remove());
        
        // AGGRESSIVELY remove metrics/stats tables
        // Target by style characteristics - the RadarStatsTable has width 280px or 240px, maxHeight 580px/460px
        clone.querySelectorAll('div').forEach(el => {
            const style = el.style;
            const computedWidth = el.offsetWidth;
            // Remove elements that look like the stats table (narrow width, has scrolling)
            if (computedWidth > 200 && computedWidth < 300 && 
                (style.overflowY === 'auto' || style.maxHeight)) {
                el.remove();
            }
        });
        
        // Remove elements containing METRICS text header
        clone.querySelectorAll('button').forEach(btn => {
            if (btn.textContent && btn.textContent.includes('METRICS')) {
                // Remove the parent container of this button
                btn.closest('div')?.remove();
            }
        });
        
        // Remove any element that has "Expand" and "Collapse" buttons (the stats table controls)
        clone.querySelectorAll('button').forEach(btn => {
            if (btn.textContent === 'Expand' || btn.textContent === 'Collapse') {
                // Go up to find the stats table container and remove it
                let parent = btn.parentElement;
                for (let i = 0; i < 5 && parent; i++) {
                    if (parent.style && (parent.style.maxHeight || parent.style.overflowY === 'auto')) {
                        parent.remove();
                        break;
                    }
                    parent = parent.parentElement;
                }
            }
        });
        
        // Remove select dropdowns (sort controls)
        clone.querySelectorAll('select').forEach(sel => {
            // Go up and remove the containing stats panel
            let parent = sel.parentElement;
            for (let i = 0; i < 6 && parent; i++) {
                if (parent.style && parent.style.borderRadius === '12px' && 
                    (parent.style.maxHeight || parent.style.overflowY)) {
                    parent.remove();
                    break;
                }
                parent = parent.parentElement;
            }
        });
        
        // Expand all collapsed sections
        clone.querySelectorAll('.scout-section-content').forEach(el => {
            el.style.maxHeight = 'none';
            el.style.opacity = '1';
            el.style.overflow = 'visible';
        });
        clone.querySelectorAll('.collapse-icon').forEach(el => el.remove());
        
        // Temporarily append clone to measure its dimensions
        clone.style.position = 'absolute';
        clone.style.visibility = 'hidden';
        clone.style.left = '-9999px';
        clone.style.transform = 'none';
        document.body.appendChild(clone);
        
        // Measure
        const expandedWidth = clone.offsetWidth || 900;
        const expandedHeight = clone.scrollHeight || 700;
        
        document.body.removeChild(clone);
        clone.style.visibility = 'visible';
        clone.style.left = '0';
        
        // Available space - full 1920x1080 now (no header/footer)
        const availableWidth = 1880;
        const availableHeight = 1040;
        
        // Calculate scale - DON'T scale, just center
        // The content should render at native size for best quality
        const scaleX = availableWidth / expandedWidth;
        const scaleY = availableHeight / expandedHeight;
        
        // Only scale if content is too big, otherwise keep at 1.0
        let fitScale = 1.0;
        if (expandedWidth > availableWidth || expandedHeight > availableHeight) {
            fitScale = Math.min(scaleX, scaleY);
        }
        
        // Center
        const scaledWidth = expandedWidth * fitScale;
        const scaledHeight = expandedHeight * fitScale;
        const offsetX = Math.max(0, (availableWidth - scaledWidth) / 2);
        const offsetY = Math.max(0, (availableHeight - scaledHeight) / 2);
        
        // Use zoom instead of transform for better text rendering
        clone.style.zoom = fitScale;
        clone.style.position = 'absolute';
        clone.style.top = offsetY + 'px';
        clone.style.left = offsetX + 'px';
        
        if (bodyArea) {
            bodyArea.style.position = 'relative';
            bodyArea.style.width = availableWidth + 'px';
            bodyArea.style.height = availableHeight + 'px';
            bodyArea.style.margin = '20px auto';
            bodyArea.style.overflow = 'hidden';
            bodyArea.appendChild(clone);
        }
        
        console.log(`Screenshot: ${expandedWidth}x${expandedHeight} @ ${fitScale.toFixed(2)}x`);
    }, [isOpen, sourceElementId]);
    
    // Handle ESC key
    useEffect(() => {
        if (!isOpen) return;
        const handleKeyDown = (e) => { if (e.key === 'Escape') onClose(); };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [isOpen, onClose]);
    
    // Capture function - use html2canvas
    const handleCapture = async () => {
        if (!captureContainerRef.current) return;
        setIsCapturing(true);
        
        try {
            // Wait for fonts to load
            await document.fonts.ready;
            
            // Double RAF to ensure render completion
            await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
            
            // Hide no-capture elements temporarily
            const noCapture = captureContainerRef.current.querySelectorAll('.no-capture');
            noCapture.forEach(el => el.style.display = 'none');
            
            // Capture with html2canvas
            const canvas = await html2canvas(captureContainerRef.current, {
                width: 1920,
                height: 1080,
                scale: 2,  // 2x for sharper output
                backgroundColor: '#0a0c10',
                useCORS: true,
                allowTaint: true,
                logging: false
            });
            
            // Restore no-capture elements
            noCapture.forEach(el => el.style.display = '');
            
            // Download
            const link = document.createElement('a');
            link.download = `${playerName || 'player'}-${title.replace(/\s+/g, '-').toLowerCase()}-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            console.log('Screenshot captured successfully');
            
        } catch (err) {
            console.error('Screenshot capture failed:', err);
            alert('Screenshot failed: ' + err.message);
        } finally {
            setIsCapturing(false);
        }
    };
    
    if (!isOpen) return null;
    
    const sectionConfig = {
        overview: { icon: '', color: '#a78bfa' },
        onball: { icon: '', color: '#f97316' },
        spacing: { icon: '', color: '#06b6d4' },
        finishing: { icon: '', color: '#facc15' },
        defense: { icon: '', color: '#ef4444' },
        profile: { icon: '', color: '#8b5cf6' }
    };
    
    const config = sectionConfig[section] || { icon: '', color: '#a78bfa' };
    const currentDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
    const seasonText = selectedSeasons?.length > 0 ? selectedSeasons.join(', ') : '';
    
    return e('div', { className: 'screenshot-modal-overlay', onClick: onClose },
        // Controls at top
        e('div', { className: 'screenshot-modal-controls', onClick: ev => ev.stopPropagation() },
            e('button', { 
                className: 'screenshot-modal-btn capture',
                onClick: handleCapture,
                disabled: isCapturing
            }, isCapturing ? ' Capturing...' : ' Download PNG (19201080)'),
            e('button', { className: 'screenshot-modal-btn close', onClick: onClose }, ' Close')
        ),
        
        // Preview (scaled down for display)
        e('div', { 
            className: 'screenshot-preview-wrapper',
            onClick: ev => ev.stopPropagation(),
            style: { transform: `scale(${previewScale})`, transformOrigin: 'top center', marginTop: '80px' }
        },
            // The actual 1920x1080 capture container - CLEAN, no header/footer
            e('div', { 
                ref: captureContainerRef,
                className: 'screenshot-capture-container',
                style: {
                    width: '1920px',
                    height: '1080px',
                    background: '#0a0c10',
                    borderRadius: '0',
                    overflow: 'hidden',
                    position: 'relative',
                    fontFamily: 'Sora, sans-serif'
                }
            },
                // Body - full area for content
                e('div', { 
                    className: 'ss-body-area',
                    style: {
                        width: '1880px',
                        height: '1040px',
                        margin: '20px',
                        padding: '0',
                        overflow: 'hidden',
                        position: 'relative'
                    }
                }),
                
                // Small watermark in corner (subtle)
                e('div', {
                    style: {
                        position: 'absolute',
                        bottom: '10px',
                        right: '20px',
                        color: 'rgba(255,255,255,0.15)',
                        fontSize: '10px',
                        fontFamily: 'Sora, sans-serif'
                    }
                }, ' Basketball Player Breakdown Analyzer'),
                
                // Save button overlay (excluded from capture)
                e('div', {
                    className: 'no-capture',
                    style: {
                        position: 'absolute',
                        bottom: '40px',
                        left: '50%',
                        transform: 'translateX(-50%)',
                        zIndex: 100
                    }
                },
                    e('button', {
                        onClick: handleCapture,
                        disabled: isCapturing,
                        style: {
                            padding: '14px 36px',
                            fontSize: '16px',
                            fontWeight: '700',
                            background: 'linear-gradient(135deg, #10b981, #059669)',
                            color: 'white',
                            border: 'none',
                            borderRadius: '10px',
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '8px',
                            boxShadow: '0 6px 24px rgba(16, 185, 129, 0.5)',
                            transition: 'all 0.2s ease'
                        }
                    }, isCapturing ? ' Saving...' : ' Save as PNG')
                )
            )
        )
    );
}

// Scout Report Main Tab Component
function ScoutReportMainTab({ 
    playerData, 
    sectionData, 
    matchedPoss, 
    playerDefenseData, 
    playerEnhancedStats,
    availableSeasons,
    selectedSeasons,
    toggleSeason,
    playerPhoto,
    handlePhotoUpload,
    scoutNotes,
    setScoutNotes,
    pools,
    rolePools,
    offenseData,
    radarScalesData, // This is now precomputedData
    onPlayerSelect,
    selectedPlayer,
    openScreenshotModal
}) {
    // Calculate player's play type distribution and role
    const playerRoleInfo = useMemo(() => {
        if (!playerData || !playerData.rawRows) return null;
        
        const dist = calculatePlayTypeDistribution(playerData.rawRows, playerData.totalPoss);
        const role = classifyPlayerRole(dist);
        
        return { distribution: dist, role };
    }, [playerData]);
    
    // Get precomputed player data from lookup
    const precomputedPlayerData = useMemo(() => {
        if (!radarScalesData?.playerLookup || !selectedPlayer) return null;
        
        // Try to find player in lookup (need to match player|season)
        const seasons = playerData?.seasons || [];
        for (const season of seasons) {
            const key = `${selectedPlayer}|${season}`;
            if (radarScalesData.playerLookup[key]) {
                return radarScalesData.playerLookup[key];
            }
        }
        
        // Try first matching key for this player
        for (const key in radarScalesData.playerLookup) {
            if (key.startsWith(selectedPlayer + '|')) {
                return radarScalesData.playerLookup[key];
            }
        }
        
        return null;
    }, [radarScalesData, selectedPlayer, playerData]);
    
    // Use precomputed scales (role-specific if available, otherwise league-wide)
    const dynamicRadarScales = useMemo(() => {
        if (!radarScalesData?.scales) return null;
        
        const roleId = precomputedPlayerData?.roleId || playerRoleInfo?.role?.id;
        
        // Check for role-specific scales
        if (roleId && radarScalesData.scales.byRole[roleId]) {
            return radarScalesData.scales.byRole[roleId];
        }
        
        // Fall back to league-wide scales
        return radarScalesData.scales.leagueWide;
    }, [radarScalesData, precomputedPlayerData, playerRoleInfo]);
    
    // Calculate Radar 1 metrics (still needed for display, but percentiles come from precomputed)
    const radar1Metrics = useMemo(() => {
        const baseMetrics = calculateRadar1Metrics(
            playerData, 
            sectionData, 
            matchedPoss, 
            playerDefenseData, 
            playerEnhancedStats,
            pools
        );
        
        // Add transition metrics from sectionData.transition
        const transitionData = sectionData?.transition;
        if (transitionData) {
            baseMetrics.transPctOfPoss = transitionData.main?.pctOfPoss || 0;
            baseMetrics.transPPP = transitionData.main?.ppp || 0;
            baseMetrics.hcPctOfPoss = transitionData.halfCourt?.pctOfPoss || 0;
            baseMetrics.hcPPP = transitionData.halfCourt?.ppp || 0;
        }
        
        return baseMetrics;
    }, [playerData, sectionData, matchedPoss, playerDefenseData, playerEnhancedStats, pools]);
    
    // Use precomputed percentiles (or fall back if not found)
    const radarPercentiles = useMemo(() => {
        // Always calculate fresh percentiles using current radar1Metrics against the full pool
        // This ensures aggregated multi-season data is properly percentiled
        if (!radar1Metrics || !radarScalesData?.allRadarMetrics) return {};
        
        const { allRadarMetrics, roleGroupedMetrics } = radarScalesData;
        const MIN_ROLE_SAMPLES = 10;
        
        let roleMetrics = null;
        if (playerRoleInfo?.role?.id && roleGroupedMetrics?.[playerRoleInfo.role.id]?.length >= MIN_ROLE_SAMPLES) {
            roleMetrics = roleGroupedMetrics[playerRoleInfo.role.id];
        }
        
        // Debug: Log radar1Metrics before passing to percentile calculator
        console.log(`radar1Metrics before percentile calc: finishingVol75=${radar1Metrics.finishingVol75?.toFixed(2)}, finishingPPP=${radar1Metrics.finishingPPP?.toFixed(2)}`);
        
        const pctls = calculateAllRadarPercentiles(radar1Metrics, allRadarMetrics, roleMetrics, MIN_ROLE_SAMPLES);
        
        // Diagnostic: Log percentile calculation details
        const poolUsed = roleMetrics?.length >= MIN_ROLE_SAMPLES ? 'role' : 'league';
        console.log(`Radar percentiles calculated: ${poolUsed} pool, size = ${poolUsed === 'role' ? roleMetrics.length : allRadarMetrics.length}`);
        console.log(`After percentile calc: finishingPPP percentile = ${pctls.finishingPPP}`);
        
        return pctls;
    }, [radar1Metrics, radarScalesData, playerRoleInfo]);
    
    // Calculate On-Ball Radar metrics
    const onBallRadarMetrics = useMemo(() => {
        if (!playerData || !playerData.rawRows) return null;
        return calculateOnBallRadarMetrics(playerData.rawRows, matchedPoss);
    }, [playerData, matchedPoss]);
    
    // Calculate On-Ball Radar percentiles from precomputed data
    const onBallRadarPercentiles = useMemo(() => {
        if (!onBallRadarMetrics || !radarScalesData?.allRadarMetrics) return {};
        
        const { allRadarMetrics } = radarScalesData;
        
        // Map from display keys to precomputed keys
        const keyMap = {
            'onBallPct': 'ob_onBallPct',
            'onBallInclPPP': 'ob_onBallInclPPP',
            'pnrIncl75': 'ob_pnrIncl75',
            'pnrInclPPP': 'ob_pnrInclPPP',
            'pnrPressurePPP': 'ob_pnrPressurePPP',
            'pnrPressureTOPct': 'ob_pnrPressureTOPct',
            'pnrPassPct': 'ob_pnrPassPct',
            'pnrTOPct': 'ob_pnrTOPct',
            'pnrRollAst75': 'ob_pnrRollAst75',
            'pnrSpotUpAst75': 'ob_pnrSpotUpAst75',
            'handlingRim75': 'ob_handlingRim75',
            'handlingRimPct': 'ob_handlingRimPct',
            'handlingMid75': 'ob_handlingMid75',
            'handlingMidPct': 'ob_handlingMidPct',
            'handling3P75': 'ob_handling3P75',
            'handling3PPct': 'ob_handling3PPct',
            'iso75': 'ob_iso75',
            'isoPPP': 'ob_isoPPP',
            'post75': 'ob_post75',
            'postPPP': 'ob_postPPP',
            'postPassPct': 'ob_postPassPct',
            'postPressurePPP': 'ob_postPressurePPP',
            'postPressureTOPct': 'ob_postPressureTOPct',
            'postLeftPPP': 'ob_postLeftPPP',
            'postLeftPct': 'ob_postLeftPct',
            'postRightPPP': 'ob_postRightPPP',
            'postRightPct': 'ob_postRightPct',
            // Self-Creation Breakdown (using direct metrics)
            'onBall75': 'ob_onBall75',
            'onBallPPP': 'ob_onBallPPP',
            'pnrBH75': 'ob_pnrBH75',
            'pnrBHPPP': 'ob_pnrBHPPP',
            'isoDirect75': 'ob_isoDirect75',
            'isoDirectPPP': 'ob_isoDirectPPP',
            'postDirect75': 'ob_postDirect75',
            'postDirectPPP': 'ob_postDirectPPP'
        };
        
        // Metric definitions with inverse flags and volume thresholds
        // volumeKey + minVolume: the per-75 metric that must meet minimum for this metric to count
        // If player is at 80%+ of threshold but below threshold, they get 0th percentile
        // If player is below 80% of threshold, they get null (dimmed)
        // volumeDisplayKey: the key to look up in onBallRadarMetrics (strip ob_ prefix from volumeKey)
        const metricDefs = {
            'onBallPct': { inverse: false, weightKey: 'totalPoss', minWeight: 50 },
            'onBallInclPPP': { inverse: false, weightKey: '_onBallInclPoss', minWeight: 20 },
            'pnrIncl75': { inverse: false, weightKey: 'totalPoss', minWeight: 50 },
            'pnrInclPPP': { inverse: false, weightKey: '_pnrInclPoss', minWeight: 15, volumeKey: 'ob_pnrIncl75', volumeDisplayKey: 'pnrIncl75', minVolume: 2 },
            'pnrPressurePPP': { inverse: false, weightKey: '_pnrPressurePoss', minWeight: 10, volumeKey: 'ob_pnrIncl75', volumeDisplayKey: 'pnrIncl75', minVolume: 2 },
            'pnrPressureTOPct': { inverse: true, weightKey: '_pnrPressurePoss', minWeight: 10, volumeKey: 'ob_pnrIncl75', volumeDisplayKey: 'pnrIncl75', minVolume: 2 },
            'pnrPassPct': { inverse: false, weightKey: '_pnrInclPoss', minWeight: 15, volumeKey: 'ob_pnrIncl75', volumeDisplayKey: 'pnrIncl75', minVolume: 2 },
            'pnrTOPct': { inverse: true, weightKey: '_pnrInclPoss', minWeight: 15, volumeKey: 'ob_pnrIncl75', volumeDisplayKey: 'pnrIncl75', minVolume: 2 },
            'pnrRollAst75': { inverse: false, weightKey: '_pnrInclPoss', minWeight: 15 },
            'pnrSpotUpAst75': { inverse: false, weightKey: '_pnrInclPoss', minWeight: 15 },
            // SHOT SELECTION: Uses combined P&R/75 + ISO/75 >= 2.5 threshold
            'handlingRim75': { inverse: false, weightKey: '_onBallDirectPoss', minWeight: 20, useCombinedThreshold: true, combinedMinVolume: 2.5 },
            'handlingRimPct': { inverse: false, weightKey: '_handlingRimAtt', minWeight: 10, useCombinedThreshold: true, combinedMinVolume: 2.5 },
            'handlingMid75': { inverse: false, weightKey: '_onBallDirectPoss', minWeight: 20, useCombinedThreshold: true, combinedMinVolume: 2.5 },
            'handlingMidPct': { inverse: false, weightKey: '_handlingMidAtt', minWeight: 10, useCombinedThreshold: true, combinedMinVolume: 2.5 },
            'handling3P75': { inverse: false, weightKey: '_onBallDirectPoss', minWeight: 20, useCombinedThreshold: true, combinedMinVolume: 2.5 },
            'handling3PPct': { inverse: false, weightKey: '_handling3Att', minWeight: 10, useCombinedThreshold: true, combinedMinVolume: 2.5 },
            'iso75': { inverse: false, weightKey: 'totalPoss', minWeight: 50 },
            'isoPPP': { inverse: false, weightKey: '_isoInclPoss', minWeight: 15, volumeKey: 'ob_iso75', volumeDisplayKey: 'iso75', minVolume: 0.8 },
            'post75': { inverse: false, weightKey: 'totalPoss', minWeight: 50 },
            'postPPP': { inverse: false, weightKey: '_postInclPoss', minWeight: 10, volumeKey: 'ob_post75', volumeDisplayKey: 'post75', minVolume: 0.8 },
            'postPassPct': { inverse: false, weightKey: '_postInclPoss', minWeight: 10, volumeKey: 'ob_post75', volumeDisplayKey: 'post75', minVolume: 0.8 },
            'postPressurePPP': { inverse: false, weightKey: '_postPressurePoss', minWeight: 5, volumeKey: 'ob_post75', volumeDisplayKey: 'post75', minVolume: 0.8 },
            'postPressureTOPct': { inverse: true, weightKey: '_postPressurePoss', minWeight: 5, volumeKey: 'ob_post75', volumeDisplayKey: 'post75', minVolume: 0.8 },
            'postLeftPPP': { inverse: false, weightKey: '_postLeftPoss', minWeight: 5, volumeKey: 'ob_post75', volumeDisplayKey: 'post75', minVolume: 0.8 },
            'postLeftPct': { inverse: false, weightKey: '_postInclPoss', minWeight: 10, volumeKey: 'ob_post75', volumeDisplayKey: 'post75', minVolume: 0.8 },
            'postRightPPP': { inverse: false, weightKey: '_postRightPoss', minWeight: 5, volumeKey: 'ob_post75', volumeDisplayKey: 'post75', minVolume: 0.8 },
            'postRightPct': { inverse: false, weightKey: '_postInclPoss', minWeight: 10, volumeKey: 'ob_post75', volumeDisplayKey: 'post75', minVolume: 0.8 },
            // Self-Creation Breakdown (direct metrics)
            'onBall75': { inverse: false, weightKey: '_onBallDirectPoss', minWeight: 20 },
            'onBallPPP': { inverse: false, weightKey: '_onBallDirectPoss', minWeight: 20 },
            'pnrBH75': { inverse: false, weightKey: '_pnrBHPoss', minWeight: 10 },
            'pnrBHPPP': { inverse: false, weightKey: '_pnrBHPoss', minWeight: 10 },
            'isoDirect75': { inverse: false, weightKey: '_isoDirectPoss', minWeight: 10 },
            'isoDirectPPP': { inverse: false, weightKey: '_isoDirectPoss', minWeight: 10 },
            'postDirect75': { inverse: false, weightKey: '_postDirectPoss', minWeight: 5 },
            'postDirectPPP': { inverse: false, weightKey: '_postDirectPoss', minWeight: 5 }
        };
        
        const pctls = {};
        
        Object.keys(keyMap).forEach(displayKey => {
            const precomputedKey = keyMap[displayKey];
            const def = metricDefs[displayKey];
            if (!def) {
                pctls[displayKey] = null;
                return;
            }
            const playerValue = onBallRadarMetrics[displayKey];
            
            // Handle combined threshold for SHOT SELECTION metrics (P&R/75 + ISO/75)
            let meetsVolumeThreshold, meetsPartialThreshold;
            if (def.useCombinedThreshold) {
                // Combined threshold: P&R/75 + ISO/75 >= combinedMinVolume (2.5)
                const pnr75 = onBallRadarMetrics.pnrIncl75 || 0;
                const iso75 = onBallRadarMetrics.iso75 || 0;
                const combinedVol = pnr75 + iso75;
                meetsVolumeThreshold = combinedVol >= def.combinedMinVolume;
                meetsPartialThreshold = combinedVol >= def.combinedMinVolume * 0.8;
            } else {
                // Standard volume threshold logic
                const playerVolumeValue = def.volumeDisplayKey ? onBallRadarMetrics[def.volumeDisplayKey] : null;
                meetsVolumeThreshold = !def.volumeKey || (playerVolumeValue !== null && playerVolumeValue >= def.minVolume);
                meetsPartialThreshold = !def.volumeKey || (playerVolumeValue !== null && playerVolumeValue >= def.minVolume * 0.8);
            }
            
            // Debug for P&R metrics
            if (displayKey === 'pnrInclPPP' || displayKey === 'postPPP') {
                const playerVolumeValue = def.volumeDisplayKey ? onBallRadarMetrics[def.volumeDisplayKey] : null;
                console.log(`${displayKey} check: playerValue=${playerValue?.toFixed(2)}, volumeDisplayKey=${def.volumeDisplayKey}, volumeValue=${playerVolumeValue?.toFixed(2)}, minVolume=${def.minVolume}, meetsThreshold=${meetsVolumeThreshold}`);
            }
            
            // Build weighted data from all players with volume threshold
            const weightedData = allRadarMetrics
                .filter(m => {
                    const w = m[def.weightKey] || m.totalPoss;
                    const v = m[precomputedKey];
                    // Check appropriate threshold for pool members
                    let poolMeetsVolume;
                    if (def.useCombinedThreshold) {
                        const poolPnr75 = m.ob_pnrIncl75 || 0;
                        const poolIso75 = m.ob_iso75 || 0;
                        poolMeetsVolume = (poolPnr75 + poolIso75) >= def.combinedMinVolume;
                    } else {
                        const poolVolumeValue = def.volumeKey ? m[def.volumeKey] : null;
                        poolMeetsVolume = !def.volumeKey || (poolVolumeValue !== null && poolVolumeValue >= def.minVolume);
                    }
                    return w >= def.minWeight && v !== null && v !== undefined && !isNaN(v) && poolMeetsVolume;
                })
                .map(m => ({
                    value: m[precomputedKey],
                    weight: m[def.weightKey] || m.totalPoss
                }));
            
            if (playerValue === null || playerValue === undefined || weightedData.length < 3) {
                pctls[displayKey] = null;
            } else if (!meetsPartialThreshold) {
                // Below 80% of volume threshold - dim completely
                pctls[displayKey] = null;
            } else if (!meetsVolumeThreshold) {
                // Between 80% and 100% of threshold - gray text, no percentile number
                pctls[displayKey] = -1;
            } else {
                pctls[displayKey] = calculateWeightedPercentile(
                    playerValue, 1, weightedData, def.inverse
                );
            }
        });
        
        return pctls;
    }, [onBallRadarMetrics, radarScalesData]);
    
    // Calculate Spacing Radar metrics
    const spacingRadarMetrics = useMemo(() => {
        if (!playerData || !playerData.rawRows) return null;
        return calculateSpacingRadarMetrics(playerData.rawRows, matchedPoss);
    }, [playerData, matchedPoss]);
    
    // Calculate Spacing Radar percentiles using precomputed metrics
    const spacingRadarPercentiles = useMemo(() => {
        if (!spacingRadarMetrics || !radarScalesData?.allRadarMetrics) return {};
        
        const { allRadarMetrics } = radarScalesData;
        
        // Map display keys to precomputed keys in radarMetrics (sp_* prefix)
        const keyMap = {
            'spacingPct': 'sp_spacingPct',
            'spacingPPP': 'sp_spacingPPP',
            'spacingTOPct': 'sp_spacingTOPct',
            'spacingFtRate': 'sp_spacingFtRate',
            'spotUpCnS75': 'sp_spotUpCnS75',
            'guardedPct': 'sp_guardedPct',
            'guarded3Pct': 'sp_guarded3Pct',
            'open3Pct': 'sp_open3Pct',
            'adjusted3Pct': 'sp_adjusted3Pct',
            'moving75': 'sp_moving75',
            'moving3Pct': 'sp_moving3Pct',
            'spotUpDrivePct': 'sp_spotUpDrivePct',
            'spotUpDrives75': 'sp_spotUpDrives75',
            'spotUpDrivesPPP': 'sp_spotUpDrivesPPP',
            'offScreen75': 'sp_offScreen75',
            'offScreenPPP': 'sp_offScreenPPP',
            'offScreenDrivePct': 'sp_offScreenDrivePct',
            'handoffs75': 'sp_handoffs75',
            'handoffsPPP': 'sp_handoffsPPP',
            'handoffsDrivePct': 'sp_handoffsDrivePct'
        };
        
        // Metric definitions with thresholds matching the display dimming logic
        // Overall: spacing75 >= 1.5 base, >= 2.5 for PPP/TO%/FT Rate
        // Spot-Up C&S: spotUpCnS75 >= 1.5
        // Moving: moving75 >= 0.7
        // Spot Up Drives: spotUpDrives75 >= 1.0
        // Off Screen: offScreen75 >= 0.7
        // Handoffs: handoffs75 >= 0.8
        const metricDefs = {
            // Overall - base threshold: spacing75 >= 1.5
            'spacingPct': { inverse: false, weightKey: 'totalPoss', minWeight: 50, volumeKey: 'sp_spacing75', minVolume: 1.5 },
            'spacingPPP': { inverse: false, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'sp_spacing75', minVolume: 2.5 },
            'spacingTOPct': { inverse: true, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'sp_spacing75', minVolume: 2.5 },
            'spacingFtRate': { inverse: false, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'sp_spacing75', minVolume: 2.5 },
            // Spot-Up C&S - threshold: spotUpCnS75 >= 1.5
            'spotUpCnS75': { inverse: false, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'sp_spacing75', minVolume: 1.5 },
            'guardedPct': { inverse: false, weightKey: '_spotUpCnSPoss', minWeight: 10, volumeKey: 'sp_spotUpCnS75', minVolume: 1.5 },
            'guarded3Pct': { inverse: false, weightKey: '_spGuarded3Att', minWeight: 5, volumeKey: 'sp_spotUpCnS75', minVolume: 1.5 },
            'open3Pct': { inverse: false, weightKey: '_spOpen3Att', minWeight: 5, volumeKey: 'sp_spotUpCnS75', minVolume: 1.5 },
            'adjusted3Pct': { inverse: false, weightKey: '_spotUpCnSPoss', minWeight: 10, volumeKey: 'sp_spotUpCnS75', minVolume: 1.5 },
            // Moving - threshold: moving75 >= 0.7
            'moving75': { inverse: false, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'sp_spacing75', minVolume: 1.5 },
            'moving3Pct': { inverse: false, weightKey: '_moving3Att', minWeight: 5, volumeKey: 'sp_moving75', minVolume: 0.7 },
            // Spot Up Drives - threshold: spotUpDrives75 >= 1.0
            'spotUpDrivePct': { inverse: false, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'sp_spacing75', minVolume: 1.5 },
            'spotUpDrives75': { inverse: false, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'sp_spacing75', minVolume: 1.5 },
            'spotUpDrivesPPP': { inverse: false, weightKey: '_spotUpDrivesPoss', minWeight: 10, volumeKey: 'sp_spotUpDrives75', minVolume: 1.0 },
            // Off Screen - threshold: offScreen75 >= 0.7
            'offScreen75': { inverse: false, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'sp_spacing75', minVolume: 1.5 },
            'offScreenPPP': { inverse: false, weightKey: '_offScreenPoss', minWeight: 10, volumeKey: 'sp_offScreen75', minVolume: 0.7 },
            'offScreenDrivePct': { inverse: false, weightKey: '_offScreenPoss', minWeight: 10, volumeKey: 'sp_offScreen75', minVolume: 0.7 },
            // Handoffs - threshold: handoffs75 >= 0.8
            'handoffs75': { inverse: false, weightKey: '_spacingPoss', minWeight: 20, volumeKey: 'sp_spacing75', minVolume: 1.5 },
            'handoffsPPP': { inverse: false, weightKey: '_handoffsPoss', minWeight: 10, volumeKey: 'sp_handoffs75', minVolume: 0.8 },
            'handoffsDrivePct': { inverse: false, weightKey: '_handoffsPoss', minWeight: 10, volumeKey: 'sp_handoffs75', minVolume: 0.8 }
        };
        
        const pctls = {};
        
        // Find selected player metrics once (outside loop for efficiency)
        const selectedPlayerMetrics = allRadarMetrics.find(m => 
            m.player === playerData?.playerName || m.player === playerData?.name || m.player === playerData?.player
        );
        
        // Debug log for spacing radar percentile calculation
        console.log(`SpacingRadar: Looking for player ${playerData?.playerName || playerData?.name}`, 
            'Found:', !!selectedPlayerMetrics,
            'sp_spacing75:', selectedPlayerMetrics?.sp_spacing75,
            'sp_spotUpCnS75:', selectedPlayerMetrics?.sp_spotUpCnS75
        );
        
        Object.keys(keyMap).forEach(displayKey => {
            const precomputedKey = keyMap[displayKey];
            const def = metricDefs[displayKey];
            if (!def) {
                pctls[displayKey] = null;
                return;
            }
            const playerValue = spacingRadarMetrics[displayKey];
            
            // Check volume threshold for the current player
            // Use the precomputed volume key from allRadarMetrics for the selected player
            const playerVolumeValue = selectedPlayerMetrics ? selectedPlayerMetrics[def.volumeKey] : null;
            const meetsVolumeThreshold = playerVolumeValue !== null && playerVolumeValue >= def.minVolume;
            const meetsPartialThreshold = playerVolumeValue !== null && playerVolumeValue >= def.minVolume * 0.8;
            
            // Build weighted data from all players with volume threshold
            const weightedData = allRadarMetrics
                .filter(m => {
                    const w = m[def.weightKey] || m.totalPoss;
                    const v = m[precomputedKey];
                    // Check appropriate threshold for pool members
                    const poolVolumeValue = m[def.volumeKey];
                    const poolMeetsVolume = poolVolumeValue !== null && poolVolumeValue >= def.minVolume;
                    return w >= def.minWeight && v !== null && v !== undefined && !isNaN(v) && poolMeetsVolume;
                })
                .map(m => ({
                    value: m[precomputedKey],
                    weight: m[def.weightKey] || m.totalPoss
                }));
            
            if (playerValue === null || playerValue === undefined || weightedData.length < 3) {
                pctls[displayKey] = null;
            } else if (!meetsPartialThreshold) {
                // Below 80% of volume threshold - dim completely
                pctls[displayKey] = null;
            } else if (!meetsVolumeThreshold) {
                // Between 80% and 100% of threshold - gray text, no percentile number
                pctls[displayKey] = -1;
            } else {
                pctls[displayKey] = calculateWeightedPercentile(
                    playerValue, 1, weightedData, def.inverse
                );
            }
        });
        
        return pctls;
    }, [spacingRadarMetrics, radarScalesData, playerData]);
    
    // Calculate Finishing Radar metrics
    const finishingRadarMetrics = useMemo(() => {
        if (!playerData || !playerData.rawRows) return null;
        return calculateFinishingRadarMetrics(playerData.rawRows, matchedPoss);
    }, [playerData, matchedPoss]);
    
    // Calculate Finishing Radar percentiles
    const finishingRadarPercentiles = useMemo(() => {
        if (!finishingRadarMetrics || !radarScalesData?.allRadarMetrics) return {};
        
        const { allRadarMetrics } = radarScalesData;
        const pctls = {};
        
        // Map display keys to precomputed keys (fn_* prefix)
        const keyMap = {
            'finishingPct': 'fn_finishingPct',
            'finishingPPP': 'fn_finishingPPP',
            'finishingTOPct': 'fn_finishingTOPct',
            'finishingFtRate': 'fn_finishingFtRate',
            'rolls75': 'fn_rolls75',
            'rollsPPP': 'fn_rollsPPP',
            'rollsFtRate': 'fn_rollsFtRate',
            'rollsTOPct': 'fn_rollsTOPct',
            'pops75': 'fn_pops75',
            'popsPPP': 'fn_popsPPP',
            'selfCut75': 'fn_selfCut75',
            'selfCutPPP': 'fn_selfCutPPP',
            'selfCutTOPct': 'fn_selfCutTOPct',
            'putbacks75': 'fn_putbacks75'
        };
        
        // Metric definitions with thresholds
        // Base threshold: finishing75 >= 1 for the whole barplot
        // P&R Rolls: rolls75 >= 0.5 for PPP/FT/TO%
        // P&R Pops: pops75 >= 0.5 for PPP
        // Self Cuts: selfCut75 >= 0.6 for PPP/TO%
        const metricDefs = {
            // Overall - base threshold: finishing75 >= 1
            'finishingPct': { inverse: false, weightKey: 'totalPoss', minWeight: 50, volumeKey: 'fn_finishing75', minVolume: 1 },
            'finishingPPP': { inverse: false, weightKey: '_finishingPoss', minWeight: 15, volumeKey: 'fn_finishing75', minVolume: 1 },
            'finishingTOPct': { inverse: true, weightKey: '_finishingPoss', minWeight: 15, volumeKey: 'fn_finishing75', minVolume: 1 },
            'finishingFtRate': { inverse: false, weightKey: '_finishingPoss', minWeight: 15, volumeKey: 'fn_finishing75', minVolume: 1 },
            // P&R Rolls - threshold: rolls75 >= 0.5
            'rolls75': { inverse: false, weightKey: '_finishingPoss', minWeight: 15, volumeKey: 'fn_finishing75', minVolume: 1 },
            'rollsPPP': { inverse: false, weightKey: '_rollsPoss', minWeight: 10, volumeKey: 'fn_rolls75', minVolume: 0.5 },
            'rollsFtRate': { inverse: false, weightKey: '_rollsPoss', minWeight: 10, volumeKey: 'fn_rolls75', minVolume: 0.5 },
            'rollsTOPct': { inverse: true, weightKey: '_rollsPoss', minWeight: 10, volumeKey: 'fn_rolls75', minVolume: 0.5 },
            // P&R Pops - threshold: pops75 >= 0.5
            'pops75': { inverse: false, weightKey: '_finishingPoss', minWeight: 15, volumeKey: 'fn_finishing75', minVolume: 1 },
            'popsPPP': { inverse: false, weightKey: '_popsPoss', minWeight: 10, volumeKey: 'fn_pops75', minVolume: 0.5 },
            // Self Cuts - threshold: selfCut75 >= 0.6
            'selfCut75': { inverse: false, weightKey: '_finishingPoss', minWeight: 15, volumeKey: 'fn_finishing75', minVolume: 1 },
            'selfCutPPP': { inverse: false, weightKey: '_selfCutPoss', minWeight: 8, volumeKey: 'fn_selfCut75', minVolume: 0.6 },
            'selfCutTOPct': { inverse: true, weightKey: '_selfCutPoss', minWeight: 8, volumeKey: 'fn_selfCut75', minVolume: 0.6 },
            // Put Backs
            'putbacks75': { inverse: false, weightKey: '_finishingPoss', minWeight: 15, volumeKey: 'fn_finishing75', minVolume: 1 }
        };
        
        // Find selected player in allRadarMetrics for volume checks
        const selectedPlayerMetrics = allRadarMetrics.find(m => 
            m.player === (playerData?.playerName || playerData?.name)
        );
        
        Object.keys(keyMap).forEach(displayKey => {
            const precomputedKey = keyMap[displayKey];
            const def = metricDefs[displayKey];
            if (!def) {
                pctls[displayKey] = null;
                return;
            }
            const playerValue = finishingRadarMetrics[displayKey];
            
            // Check volume threshold for the current player
            const playerVolumeValue = selectedPlayerMetrics ? selectedPlayerMetrics[def.volumeKey] : null;
            const meetsVolumeThreshold = playerVolumeValue !== null && playerVolumeValue >= def.minVolume;
            const meetsPartialThreshold = playerVolumeValue !== null && playerVolumeValue >= def.minVolume * 0.8;
            
            // Build weighted data from all players with volume threshold
            const weightedData = allRadarMetrics
                .filter(m => {
                    const w = m[def.weightKey] || m.totalPoss;
                    const v = m[precomputedKey];
                    // Check appropriate threshold for pool members
                    const poolVolumeValue = m[def.volumeKey];
                    const poolMeetsVolume = poolVolumeValue !== null && poolVolumeValue >= def.minVolume;
                    return w >= def.minWeight && v !== null && v !== undefined && !isNaN(v) && poolMeetsVolume;
                })
                .map(m => ({
                    value: m[precomputedKey],
                    weight: m[def.weightKey] || m.totalPoss
                }));
            
            if (playerValue === null || playerValue === undefined || weightedData.length < 3) {
                pctls[displayKey] = null;
            } else if (!meetsPartialThreshold) {
                // Below 80% of volume threshold - dim completely
                pctls[displayKey] = null;
            } else if (!meetsVolumeThreshold) {
                // Between 80% and 100% of threshold - gray text, no percentile number
                pctls[displayKey] = -1;
            } else {
                pctls[displayKey] = calculateWeightedPercentile(
                    playerValue, 1, weightedData, def.inverse
                );
            }
        });
        
        return pctls;
    }, [finishingRadarMetrics, radarScalesData, playerData]);
    
    // Calculate Defense Radar metrics from player defense data
    const defenseRadarMetrics = useMemo(() => {
        if (!playerDefenseData || playerDefenseData.length === 0) return null;
        return calculateDefenseRadarMetrics(playerDefenseData, matchedPoss);
    }, [playerDefenseData, matchedPoss]);
    
    // Calculate Defense Radar percentiles
    const defenseRadarPercentiles = useMemo(() => {
        if (!defenseRadarMetrics || !radarScalesData?.allRadarMetrics) return {};
        
        const { allRadarMetrics } = radarScalesData;
        const pctls = {};
        
        // Map display keys to precomputed keys (df_* prefix)
        const keyMap = {
            'onBallDef75': 'df_onBallDef75',
            'onBallDefPPP': 'df_onBallDefPPP',
            'onBallDefTOPct': 'df_onBallDefTOPct',
            'onBallDefFtRate': 'df_onBallDefFtRate',
            'pnrDef75': 'df_pnrDef75',
            'pnrDefPPP': 'df_pnrDefPPP',
            'pnrDefTOPct': 'df_pnrDefTOPct',
            'pnrDefFtRate': 'df_pnrDefFtRate',
            'drivesDef75': 'df_drivesDef75',
            'drivesDefPPP': 'df_drivesDefPPP',
            'drivesDefTOPct': 'df_drivesDefTOPct',
            'drivesDefFtRate': 'df_drivesDefFtRate',
            'postDef75': 'df_postDef75',
            'postDefPPP': 'df_postDefPPP',
            'postDefTOPct': 'df_postDefTOPct',
            'postDefFtRate': 'df_postDefFtRate',
            'stl75': 'df_stl75',
            'blk75': 'df_blk75'
        };
        
        // Metric definitions with thresholds
        // OnBallD/75: 2 (OnBallD PPP, OnBallD TO%, OnBall D FT rate)
        // P&R D/75: 1.5 (P&R D PPP, P&R D TO%, P&R D FT Rate)
        // DrivesD/75: 1 (DrivesD PPP, DrivesD TO%, DrivesD FT rate)
        // PostD/75: 1 (PostD PPP, PostD TO%, PostD FT rate)
        // Note: For defense, higher PPP/TO%/FT = bad (opponent doing well), so inverse: true
        const metricDefs = {
            // OnBall Defense - threshold: onBallDef75 >= 2
            'onBallDef75': { inverse: false, weightKey: '_onBallDefPoss', minWeight: 15, volumeKey: 'df_onBallDef75', minVolume: 2 },
            'onBallDefPPP': { inverse: true, weightKey: '_onBallDefPoss', minWeight: 15, volumeKey: 'df_onBallDef75', minVolume: 2 },
            'onBallDefTOPct': { inverse: true, weightKey: '_onBallDefPoss', minWeight: 15, volumeKey: 'df_onBallDef75', minVolume: 2 },
            'onBallDefFtRate': { inverse: true, weightKey: '_onBallDefPoss', minWeight: 15, volumeKey: 'df_onBallDef75', minVolume: 2 },
            // P&R Defense - threshold: pnrDef75 >= 1.5
            'pnrDef75': { inverse: false, weightKey: '_pnrDefPoss', minWeight: 10, volumeKey: 'df_onBallDef75', minVolume: 2 },
            'pnrDefPPP': { inverse: true, weightKey: '_pnrDefPoss', minWeight: 10, volumeKey: 'df_pnrDef75', minVolume: 1.5 },
            'pnrDefTOPct': { inverse: true, weightKey: '_pnrDefPoss', minWeight: 10, volumeKey: 'df_pnrDef75', minVolume: 1.5 },
            'pnrDefFtRate': { inverse: true, weightKey: '_pnrDefPoss', minWeight: 10, volumeKey: 'df_pnrDef75', minVolume: 1.5 },
            // Drives Defense - threshold: drivesDef75 >= 1
            'drivesDef75': { inverse: false, weightKey: '_drivesDefPoss', minWeight: 10, volumeKey: 'df_onBallDef75', minVolume: 2 },
            'drivesDefPPP': { inverse: true, weightKey: '_drivesDefPoss', minWeight: 10, volumeKey: 'df_drivesDef75', minVolume: 1 },
            'drivesDefTOPct': { inverse: true, weightKey: '_drivesDefPoss', minWeight: 10, volumeKey: 'df_drivesDef75', minVolume: 1 },
            'drivesDefFtRate': { inverse: true, weightKey: '_drivesDefPoss', minWeight: 10, volumeKey: 'df_drivesDef75', minVolume: 1 },
            // Post Defense - threshold: postDef75 >= 1
            'postDef75': { inverse: false, weightKey: '_postDefPoss', minWeight: 10, volumeKey: 'df_onBallDef75', minVolume: 2 },
            'postDefPPP': { inverse: true, weightKey: '_postDefPoss', minWeight: 10, volumeKey: 'df_postDef75', minVolume: 1 },
            'postDefTOPct': { inverse: true, weightKey: '_postDefPoss', minWeight: 10, volumeKey: 'df_postDef75', minVolume: 1 },
            'postDefFtRate': { inverse: true, weightKey: '_postDefPoss', minWeight: 10, volumeKey: 'df_postDef75', minVolume: 1 },
            // Box Score - no volume threshold
            'stl75': { inverse: false, weightKey: 'totalPoss', minWeight: 50, volumeKey: 'df_onBallDef75', minVolume: 0 },
            'blk75': { inverse: false, weightKey: 'totalPoss', minWeight: 50, volumeKey: 'df_onBallDef75', minVolume: 0 }
        };
        
        // Find selected player in allRadarMetrics for volume checks
        const selectedPlayerMetrics = allRadarMetrics.find(m => 
            m.player === (playerData?.playerName || playerData?.name)
        );
        
        Object.keys(keyMap).forEach(displayKey => {
            const precomputedKey = keyMap[displayKey];
            const def = metricDefs[displayKey];
            if (!def) {
                pctls[displayKey] = null;
                return;
            }
            const playerValue = defenseRadarMetrics[displayKey];
            
            // Check volume threshold for the current player
            const playerVolumeValue = selectedPlayerMetrics ? selectedPlayerMetrics[def.volumeKey] : null;
            const meetsVolumeThreshold = def.minVolume === 0 || (playerVolumeValue !== null && playerVolumeValue >= def.minVolume);
            const meetsPartialThreshold = def.minVolume === 0 || (playerVolumeValue !== null && playerVolumeValue >= def.minVolume * 0.8);
            
            // Build weighted data from all players with volume threshold
            const weightedData = allRadarMetrics
                .filter(m => {
                    const w = m[def.weightKey] || m.totalPoss;
                    const v = m[precomputedKey];
                    // Check appropriate threshold for pool members
                    const poolVolumeValue = m[def.volumeKey];
                    const poolMeetsVolume = def.minVolume === 0 || (poolVolumeValue !== null && poolVolumeValue >= def.minVolume);
                    return w >= def.minWeight && v !== null && v !== undefined && !isNaN(v) && poolMeetsVolume;
                })
                .map(m => ({
                    value: m[precomputedKey],
                    weight: m[def.weightKey] || m.totalPoss
                }));
            
            if (playerValue === null || playerValue === undefined || weightedData.length < 3) {
                pctls[displayKey] = null;
            } else if (!meetsPartialThreshold) {
                // Below 80% of volume threshold - dim completely
                pctls[displayKey] = null;
            } else if (!meetsVolumeThreshold) {
                // Between 80% and 100% of threshold - gray text, no percentile number
                pctls[displayKey] = -1;
            } else {
                pctls[displayKey] = calculateWeightedPercentile(
                    playerValue, 1, weightedData, def.inverse
                );
            }
        });
        
        return pctls;
    }, [defenseRadarMetrics, radarScalesData, playerData]);
    
    // Get slashing data for left/right hand visualization
    const slashingData = sectionData?.slashing;
    const offScreenData = sectionData?.offScreen;
    
    // Helper function for per-75 calculations
    const calcPer75 = (poss) => {
        if (!matchedPoss || !matchedPoss.totalPlayerMin || !matchedPoss.totalTeamMin || !matchedPoss.totalTeamPoss) {
            return null;
        }
        return (poss * 75 * matchedPoss.totalTeamMin) / (matchedPoss.totalPlayerMin * matchedPoss.totalTeamPoss);
    };
    
    // Get transition data
    const transData = sectionData?.transition;
    
    // Section collapse states (start collapsed)
    const [onBallCollapsed, setOnBallCollapsed] = React.useState(true);
    const [spacingCollapsed, setSpacingCollapsed] = React.useState(true);
    const [finishingCollapsed, setFinishingCollapsed] = React.useState(true);
    const [defenseCollapsed, setDefenseCollapsed] = React.useState(true);
    
    if (!playerData) {
        return e('div', { className: 'scout-report-container' },
            e(EmptyState, { text: 'Select a player to view scout report' })
        );
    }
    
    return e('div', { className: 'scout-report-container' },
        // ========== LEADERBOARD ==========
        radarScalesData?.allRadarMetrics?.length > 0 && e(RadarLeaderboard, {
            allRadarMetrics: radarScalesData.allRadarMetrics,
            roleGroupedMetrics: radarScalesData.roleGroupedMetrics,
            playerLookup: radarScalesData.playerLookup,
            selectedPlayer: selectedPlayer,
            onPlayerSelect: onPlayerSelect,
            playerRoleInfo: playerRoleInfo
        }),
        
        // ========== HEADER ROW (Photo + Info + Radar) ==========
        e('div', { id: 'section-overview', className: 'scout-header-row-expanded', style: { position: 'relative' } },
            // Camera button for this section
            e(CameraButton, { 
                onClick: () => openScreenshotModal('overview', 'PLAYER OVERVIEW', 'section-overview', {
                    playerName: playerData.playerName,
                    playerTeam: playerData.team,
                    playerRole: playerRoleInfo?.role?.name
                }),
                style: { top: '15px', right: '15px' }
            }),
            // Left side - Photo + Info
            e('div', { className: 'scout-header-left' },
                // Player Photo Box
                e('label', null,
                    e('input', {
                        type: 'file',
                        accept: 'image/*',
                        onChange: handlePhotoUpload,
                        style: { display: 'none' }
                    }),
                    e('div', { className: 'player-photo-box' },
                        playerPhoto 
                            ? e('img', { src: playerPhoto, alt: 'Player' })
                            : e('div', null, '', e('br'), 'Click to add photo')
                    )
                ),
                
                // Player Info
                e('div', { className: 'player-info-compact' },
                    e('div', { className: 'player-name-display' }, playerData.playerName),
                    // Role Badge
                    playerRoleInfo && e('div', { 
                        className: 'player-role-badge',
                        title: playerRoleInfo.role.description
                    }, playerRoleInfo.role.name),
                    e('div', { className: 'player-team-display' }, playerData.team),
                    // Season Dropdown
                    e('div', { className: 'season-dropdown-container' },
                        e('label', { style: { fontSize: '0.7rem', color: 'var(--text-muted)', marginRight: '8px' } }, 'SEASONS:'),
                        e('div', { className: 'season-dropdown-wrapper' },
                            availableSeasons.map(season =>
                                e('label', { 
                                    key: season,
                                    className: `season-chip ${selectedSeasons.includes(season) ? 'selected' : ''}`,
                                    title: season
                                },
                                    e('input', {
                                        type: 'checkbox',
                                        checked: selectedSeasons.includes(season),
                                        onChange: () => toggleSeason(season),
                                        style: { display: 'none' }
                                    }),
                                    e('span', null, season.split(' ')[0] || season.substring(0, 9))
                                )
                            )
                        )
                    ),
                    
                    // OnBall% / OffBall% Bar Chart
                    radar1Metrics && e('div', {
                        style: {
                            marginTop: '12px',
                            padding: '10px',
                            background: 'rgba(0, 0, 0, 0.2)',
                            borderRadius: '8px'
                        }
                    },
                        e('div', { 
                            style: { 
                                fontSize: '0.65rem', 
                                color: 'var(--text-muted)', 
                                marginBottom: '6px',
                                textTransform: 'uppercase',
                                letterSpacing: '0.5px'
                            } 
                        }, 'Creation Distribution'),
                        e(HorizBarChart, {
                            data: [
                                { label: 'OnBall%', value: radar1Metrics.onBallPct || 0, color: 'pink' },
                                { label: 'OffBall%', value: radar1Metrics.offBallPct || 0, color: 'cyan' }
                            ],
                            height: 24,
                            showLabels: true,
                            showValues: true
                        })
                    ),
                    
                    // Play Type % of Possessions Bar Chart
                    e('div', {
                        style: {
                            marginTop: '10px',
                            padding: '10px',
                            background: 'rgba(0, 0, 0, 0.2)',
                            borderRadius: '8px'
                        }
                    },
                        e('div', { 
                            style: { 
                                fontSize: '0.65rem', 
                                color: 'var(--text-muted)', 
                                marginBottom: '8px',
                                textTransform: 'uppercase',
                                letterSpacing: '0.5px'
                            } 
                        }, 'Play Type Distribution'),
                        e(PlayTypeRowBars, {
                            data: [
                                { label: 'P&R BH', value: playerData.playTypeStats['P&R Ball Handler']?.pctOfPoss || 0, color: 'amber' },
                                { label: 'ISO', value: playerData.playTypeStats['Isolation']?.pctOfPoss || 0, color: 'rose' },
                                { label: 'Post', value: playerData.playTypeStats['Post-Up']?.pctOfPoss || 0, color: 'emerald' },
                                { label: 'Spot Up', value: playerData.playTypeStats['Spot Up']?.pctOfPoss || 0, color: 'cyan' },
                                { label: 'Cut', value: playerData.playTypeStats['Cut']?.pctOfPoss || 0, color: 'orange' },
                                { label: 'Roll Man', value: playerData.playTypeStats['P&R Roll Man']?.pctOfPoss || 0, color: 'violet' },
                                { label: 'Handoffs', value: playerData.playTypeStats['Handoffs']?.pctOfPoss || 0, color: 'lime' },
                                { label: 'Screens', value: playerData.playTypeStats['Off Screen']?.pctOfPoss || 0, color: 'blue' },
                                { label: 'OREB', value: playerData.playTypeStats['Offensive Rebounds (Put Backs)']?.pctOfPoss || 0, color: 'slate' }
                            ]
                        }),
                        
                        // Play Type PPP bar chart - only show play types with 30+ poss
                        e('div', { 
                            style: { 
                                fontSize: '0.65rem', 
                                color: 'var(--text-muted)', 
                                marginBottom: '8px',
                                marginTop: '12px',
                                textTransform: 'uppercase',
                                letterSpacing: '0.5px'
                            } 
                        }, 'Scoring Play Type PPP (30+ poss)'),
                        e(PlayTypeRowBars, {
                            data: [
                                { label: 'P&R BH', value: (playerData.playTypeStats['P&R Ball Handler']?.poss || 0) >= 30 ? playerData.playTypeStats['P&R Ball Handler']?.ppp || 0 : null, color: 'amber', maxValue: 1.4 },
                                { label: 'ISO', value: (playerData.playTypeStats['Isolation']?.poss || 0) >= 30 ? playerData.playTypeStats['Isolation']?.ppp || 0 : null, color: 'rose', maxValue: 1.4 },
                                { label: 'Post', value: (playerData.playTypeStats['Post-Up']?.poss || 0) >= 30 ? playerData.playTypeStats['Post-Up']?.ppp || 0 : null, color: 'emerald', maxValue: 1.4 },
                                { label: 'Spot Up', value: (playerData.playTypeStats['Spot Up']?.poss || 0) >= 30 ? playerData.playTypeStats['Spot Up']?.ppp || 0 : null, color: 'cyan', maxValue: 1.4 },
                                { label: 'Cut', value: (playerData.playTypeStats['Cut']?.poss || 0) >= 30 ? playerData.playTypeStats['Cut']?.ppp || 0 : null, color: 'orange', maxValue: 1.4 },
                                { label: 'Roll Man', value: (playerData.playTypeStats['P&R Roll Man']?.poss || 0) >= 30 ? playerData.playTypeStats['P&R Roll Man']?.ppp || 0 : null, color: 'violet', maxValue: 1.4 },
                                { label: 'Handoffs', value: (playerData.playTypeStats['Handoffs']?.poss || 0) >= 30 ? playerData.playTypeStats['Handoffs']?.ppp || 0 : null, color: 'lime', maxValue: 1.4 },
                                { label: 'Screens', value: (playerData.playTypeStats['Off Screen']?.poss || 0) >= 30 ? playerData.playTypeStats['Off Screen']?.ppp || 0 : null, color: 'blue', maxValue: 1.4 },
                                { label: 'OREB', value: (playerData.playTypeStats['Offensive Rebounds (Put Backs)']?.poss || 0) >= 30 ? playerData.playTypeStats['Offensive Rebounds (Put Backs)']?.ppp || 0 : null, color: 'slate', maxValue: 1.4 }
                            ].filter(d => d.value !== null),
                            valueFormat: 'ppp'
                        }),
                        
                        // Play Type TO% bar chart - use Including Passes for on-ball play types
                        e('div', { 
                            style: { 
                                fontSize: '0.65rem', 
                                color: 'var(--text-muted)', 
                                marginBottom: '8px',
                                marginTop: '12px',
                                textTransform: 'uppercase',
                                letterSpacing: '0.5px'
                            } 
                        }, 'Play Type TO% (30+ poss)'),
                        e(PlayTypeRowBars, {
                            data: [
                                // On-ball: use Including Passes data from sectionData for TO%
                                { label: 'P&R BH', value: (sectionData?.pnr?.including?.poss || 0) >= 30 ? sectionData?.pnr?.including?.toPct || 0 : null, color: 'amber', maxValue: 25 },
                                { label: 'ISO', value: (sectionData?.isolation?.including?.poss || 0) >= 30 ? sectionData?.isolation?.including?.toPct || 0 : null, color: 'rose', maxValue: 25 },
                                { label: 'Post', value: (sectionData?.postUp?.including?.poss || 0) >= 30 ? sectionData?.postUp?.including?.toPct || 0 : null, color: 'emerald', maxValue: 25 },
                                // Off-ball: use regular play type data
                                { label: 'Spot Up', value: (playerData.playTypeStats['Spot Up']?.poss || 0) >= 30 ? playerData.playTypeStats['Spot Up']?.toPct || 0 : null, color: 'cyan', maxValue: 25 },
                                { label: 'Cut', value: (playerData.playTypeStats['Cut']?.poss || 0) >= 30 ? playerData.playTypeStats['Cut']?.toPct || 0 : null, color: 'orange', maxValue: 25 },
                                { label: 'Roll Man', value: (playerData.playTypeStats['P&R Roll Man']?.poss || 0) >= 30 ? playerData.playTypeStats['P&R Roll Man']?.toPct || 0 : null, color: 'violet', maxValue: 25 },
                                { label: 'Handoffs', value: (playerData.playTypeStats['Handoffs']?.poss || 0) >= 30 ? playerData.playTypeStats['Handoffs']?.toPct || 0 : null, color: 'lime', maxValue: 25 },
                                { label: 'Screens', value: (playerData.playTypeStats['Off Screen']?.poss || 0) >= 30 ? playerData.playTypeStats['Off Screen']?.toPct || 0 : null, color: 'blue', maxValue: 25 },
                                { label: 'OREB', value: (playerData.playTypeStats['Offensive Rebounds (Put Backs)']?.poss || 0) >= 30 ? playerData.playTypeStats['Offensive Rebounds (Put Backs)']?.toPct || 0 : null, color: 'slate', maxValue: 25 }
                            ].filter(d => d.value !== null),
                            valueFormat: 'pct'
                        })
                    )
                )
            ),
            
            // Right side - Radar Chart with Stats Table
            e('div', { className: 'scout-header-radar' },
                e('div', { className: 'radar-title-inline' }, 'COMPREHENSIVE PLAYER PROFILE'),
                e('div', { className: 'radar-subtitle-inline' }, 
                    (() => {
                        const roleId = playerRoleInfo?.role?.id;
                        const rolePoolSize = rolePools?.[roleId]?.players?.length || 0;
                        const roleName = playerRoleInfo?.role?.name || '';
                        const roleScaleSize = radarScalesData?.roleGroupedMetrics?.[roleId]?.length || 0;
                        const usingRoleScale = roleScaleSize >= 10;
                        
                        if (roleName && rolePoolSize > 0) {
                            return `${roleName} (${rolePoolSize} comps)  Scale: ${usingRoleScale ? 'Role-specific' : 'League-wide'}`;
                        }
                        return '28 Key Metrics  League-wide Scale';
                    })()
                ),
                // Flex container for table + chart
                e('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '16px', marginTop: '8px' } },
                    // Stats Table
                    e(RadarStatsTable, {
                        metrics: radar1Metrics,
                        percentiles: radarPercentiles,
                        title: ' METRICS',
                        categories: [
                            { name: 'OVERALL', color: '#818cf8', metricDefs: [
                                { key: 'totalPPP', label: 'PPP', format: 'ppp' },
                                { key: 'tsPct', label: 'TS%', format: 'pct' },
                                { key: 'ftRate', label: 'FT Rate', format: 'pct' },
                                { key: 'usagePct', label: 'Usage', format: 'pct' }
                            ]},
                            { name: 'CREATION', color: '#f472b6', metricDefs: [
                                { key: 'onBallVol75', label: 'Creation/75', format: 'dec' },
                                { key: 'onBallPPP', label: 'Creation PPP', format: 'ppp' },
                                { key: 'rimPressure', label: 'Rim Press', format: 'int' },
                                { key: 'rimToMidRatio', label: 'Rim:Mid', format: 'dec' },
                                { key: 'onBallPassPct', label: 'Pass%', format: 'pct' }
                            ]},
                            { name: 'TRANS vs HC', color: '#f59e0b', metricDefs: [
                                { key: 'transPctOfPoss', label: 'Trans%', format: 'pct' },
                                { key: 'transPPP', label: 'Trans PPP', format: 'ppp' },
                                { key: 'hcPctOfPoss', label: 'HC%', format: 'pct' },
                                { key: 'hcPPP', label: 'HC PPP', format: 'ppp' }
                            ]},
                            { name: 'PLAYMAKING', color: '#a78bfa', metricDefs: [
                                { key: 'astUsgRatio', label: 'AST/USG', format: 'dec' },
                                { key: 'toPct', label: 'TO%', format: 'pct' }
                            ]},
                            { name: 'SPACING', color: '#22d3ee', metricDefs: [
                                { key: 'shootingValue', label: 'Shot Val', format: 'int' },
                                { key: 'fg3Att75', label: '3PA/75', format: 'dec' },
                                { key: 'spacingVol75', label: 'Space/75', format: 'dec' },
                                { key: 'spacingPPP', label: 'Space PPP', format: 'ppp' }
                            ]},
                            { name: 'SLASHING', color: '#fb923c', metricDefs: [
                                { key: 'drives75', label: 'Drives/75', format: 'dec' },
                                { key: 'drivesPPP', label: 'Drives PPP', format: 'ppp' }
                            ]},
                            { name: 'FINISHING', color: '#facc15', metricDefs: [
                                { key: 'finishingVol75', label: 'Finish/75', format: 'dec' },
                                { key: 'finishingPPP', label: 'Finish PPP', format: 'ppp' }
                            ]},
                            { name: 'PERIMETER D', color: '#34d399', metricDefs: [
                                { key: 'onBallDef75', label: 'OnBallD/75', format: 'dec' },
                                { key: 'onBallDefPPP', label: 'OnBallD PPP', format: 'ppp' }
                            ]},
                            { name: 'POST D', color: '#4ade80', metricDefs: [
                                { key: 'postDef75', label: 'PostD/75', format: 'dec' },
                                { key: 'postDefPPP', label: 'PostD PPP', format: 'ppp' }
                            ]},
                            { name: 'DISRUPTION', color: '#f87171', metricDefs: [
                                { key: 'defTOPct', label: 'Def TO%', format: 'pct' },
                                { key: 'stl75', label: 'STL/75', format: 'dec' },
                                { key: 'blk75', label: 'BLK/75', format: 'dec' }
                            ]},
                            { name: 'REBOUNDING', color: '#94a3b8', metricDefs: [
                                { key: 'oreb75', label: 'OREB/75', format: 'dec' },
                                { key: 'dreb75', label: 'DREB/75', format: 'dec' }
                            ]}
                        ]
                    }),
                    // Chart
                    e(HexRadarChart, { 
                        metrics: radar1Metrics, 
                        size: 580,
                        roleInfo: playerRoleInfo,
                        rolePools: rolePools,
                        dynamicScales: dynamicRadarScales,
                        radarPercentiles: radarPercentiles
                    })
                )
            )
        ),
        
        // ========== SCOUTING KEYS SECTION ==========
        e('div', { className: 'scouting-keys-section' },
            e('div', { className: 'scouting-keys-title' },
                e('span', null, ''),
                e('span', null, 'SCOUTING KEYS')
            ),
            e('div', { className: 'scouting-keys-grid' },
                // Pressure vs Unpressured - only show if P&R/75 >= 2
                onBallRadarMetrics && (onBallRadarMetrics.pnrIncl75 || 0) >= 2 && e('div', { className: 'scout-key-card' },
                    e('div', { className: 'scout-key-header', style: { color: '#f472b6' } },
                        e('span', null, ''),
                        'Pressure Handle',
                        e('span', { style: { marginLeft: 'auto', fontFamily: 'JetBrains Mono', fontSize: '0.55rem', color: 'var(--text-muted)' } }, 
                            fmt(onBallRadarMetrics.pnrIncl75 || 0, 1) + ' P&R/75')
                    ),
                    e('div', { className: 'scout-key-content' },
                        e('div', { className: 'scout-key-duo' },
                            e('div', { className: 'scout-key-duo-item', style: { borderLeft: '3px solid #ef4444', padding: '10px' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1.1rem', fontWeight: '700', color: '#ef4444' } }, 
                                    fmtPpp(onBallRadarMetrics.pnrPressurePPP || 0)),
                                e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)', marginTop: '2px', textTransform: 'uppercase' } }, 'PRESSURED'),
                                e('div', { style: { fontSize: '0.7rem', color: 'var(--text-muted)', marginTop: '4px', fontFamily: 'JetBrains Mono' } }, 
                                    'TO: ' + fmtPct(onBallRadarMetrics.pnrPressureTOPct || 0))
                            ),
                            e('div', { className: 'scout-key-duo-item', style: { borderLeft: '3px solid #22c55e', padding: '10px' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1.1rem', fontWeight: '700', color: '#22c55e' } }, 
                                    fmtPpp(onBallRadarMetrics.pnrUnpressuredPPP || 0)),
                                e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)', marginTop: '2px', textTransform: 'uppercase' } }, 'OPEN'),
                                e('div', { style: { fontSize: '0.7rem', color: 'var(--text-muted)', marginTop: '4px', fontFamily: 'JetBrains Mono' } }, 
                                    'TO: ' + fmtPct(onBallRadarMetrics.pnrUnpressuredTOPct || 0))
                            )
                        )
                    )
                ),
                
                // Post Moves - show only if Post/75 >= 0.8
                onBallRadarMetrics && (onBallRadarMetrics.post75 || 0) >= 0.8 && (onBallRadarMetrics._postLeftPoss > 0 || onBallRadarMetrics._postRightPoss > 0) && e('div', { 
                    className: 'scout-key-card-expanded',
                    style: { position: 'relative' }
                },
                    e('div', { className: 'scout-key-header', style: { color: '#facc15' } },
                        e('span', null, ''),
                        'Post Moves'
                    ),
                    e('div', { className: 'scout-key-content' },
                        // ===== TOP: OVERALL LEFT vs RIGHT SHOULDER =====
                        e('div', { style: { marginBottom: '10px' } },
                            e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)', marginBottom: '4px', textAlign: 'center', fontWeight: '600' } }, 'SHOULDER PREFERENCE'),
                            e('div', { className: 'scout-key-duo' },
                                e('div', { className: 'scout-key-duo-item', style: { borderLeft: '3px solid #f43f5e', padding: '8px' } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1.1rem', fontWeight: '700' } }, 
                                        fmtPct(onBallRadarMetrics.postLeftPct || 0)),
                                    e('div', { style: { fontSize: '0.5rem', color: 'var(--text-muted)' } }, ' LEFT SHOULDER'),
                                    e('div', { style: { display: 'flex', gap: '8px', marginTop: '4px', justifyContent: 'center' } },
                                        e('span', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.7rem', fontWeight: '600' } }, 
                                            fmtPpp(onBallRadarMetrics.postLeftPPP || 0) + ' PPP'),
                                        e('span', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.7rem', color: 'var(--text-muted)' } }, 
                                            fmtPct(onBallRadarMetrics.postLeftEfg || 0) + ' FG')
                                    )
                                ),
                                e('div', { className: 'scout-key-duo-item', style: { borderLeft: '3px solid #3b82f6', padding: '8px' } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1.1rem', fontWeight: '700' } }, 
                                        fmtPct(onBallRadarMetrics.postRightPct || 0)),
                                    e('div', { style: { fontSize: '0.5rem', color: 'var(--text-muted)' } }, 'RIGHT SHOULDER '),
                                    e('div', { style: { display: 'flex', gap: '8px', marginTop: '4px', justifyContent: 'center' } },
                                        e('span', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.7rem', fontWeight: '600' } }, 
                                            fmtPpp(onBallRadarMetrics.postRightPPP || 0) + ' PPP'),
                                        e('span', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.7rem', color: 'var(--text-muted)' } }, 
                                            fmtPct(onBallRadarMetrics.postRightEfg || 0) + ' FG')
                                    )
                                )
                            )
                        ),
                        
                        // ===== BLOCK POSITION BAR =====
                        e('div', { style: { marginBottom: '8px' } },
                            e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)', marginBottom: '4px', textAlign: 'center', fontWeight: '600' } }, 'BLOCK POSITION'),
                            (() => {
                                const leftBlockPct = onBallRadarMetrics.postLeftBlockPct || 0;
                                const rightBlockPct = onBallRadarMetrics.postRightBlockPct || 0;
                                return e('div', null,
                                    e('div', { className: 'scout-key-bar-container', style: { height: '20px' } },
                                        leftBlockPct > 0 && e('div', { 
                                            className: 'scout-key-bar', 
                                            style: { width: `${leftBlockPct}%`, background: 'linear-gradient(90deg, #be185d, #f43f5e)', fontSize: '0.55rem' }
                                        }, leftBlockPct >= 20 ? Math.round(leftBlockPct) + '%' : ''),
                                        rightBlockPct > 0 && e('div', { 
                                            className: 'scout-key-bar', 
                                            style: { width: `${rightBlockPct}%`, background: 'linear-gradient(90deg, #3b82f6, #1d4ed8)', fontSize: '0.55rem' }
                                        }, rightBlockPct >= 20 ? Math.round(rightBlockPct) + '%' : '')
                                    ),
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '0.5rem', marginTop: '2px' } },
                                        e('span', { style: { color: '#f43f5e' } }, 'LEFT BLOCK'),
                                        e('span', { style: { color: '#3b82f6' } }, 'RIGHT BLOCK')
                                    )
                                );
                            })()
                        ),
                        
                        // ===== BLOCK BREAKDOWN WITH NESTED SHOULDERS & SHOT TYPES =====
                        e('div', { className: 'scout-key-duo', style: { gap: '8px' } },
                            // LEFT BLOCK breakdown
                            onBallRadarMetrics._postLeftBlockPoss > 0 && e('div', { style: { background: 'rgba(244,63,94,0.1)', borderRadius: '6px', padding: '6px', flex: 1 } },
                                e('div', { style: { fontSize: '0.5rem', fontWeight: '600', color: '#f43f5e', marginBottom: '4px', textAlign: 'center' } }, 
                                    ' LEFT BLOCK'),
                                e('div', { style: { display: 'flex', justifyContent: 'space-around', marginBottom: '6px', fontSize: '0.45rem' } },
                                    e('div', { style: { textAlign: 'center' } },
                                        e('div', { style: { fontFamily: 'JetBrains Mono', fontWeight: '700' } }, fmtPpp(onBallRadarMetrics.postLeftBlockPPP || 0)),
                                        e('div', { style: { color: 'var(--text-muted)', fontSize: '0.4rem' } }, 'PPP')
                                    ),
                                    e('div', { style: { textAlign: 'center' } },
                                        e('div', { style: { fontFamily: 'JetBrains Mono', fontWeight: '700' } }, fmtPct(onBallRadarMetrics.postLeftBlockFgPct || 0)),
                                        e('div', { style: { color: 'var(--text-muted)', fontSize: '0.4rem' } }, 'FG%')
                                    ),
                                    e('div', { style: { textAlign: 'center' } },
                                        e('div', { style: { fontFamily: 'JetBrains Mono', fontWeight: '700', color: '#ef4444' } }, fmtPct(onBallRadarMetrics.postLeftBlockTOPct || 0)),
                                        e('div', { style: { color: 'var(--text-muted)', fontSize: '0.4rem' } }, 'TO%')
                                    ),
                                    e('div', { style: { textAlign: 'center' } },
                                        e('div', { style: { fontFamily: 'JetBrains Mono', fontWeight: '700', color: '#22d3ee' } }, fmtPct(onBallRadarMetrics.postLeftBlockFtRate || 0)),
                                        e('div', { style: { color: 'var(--text-muted)', fontSize: '0.4rem' } }, 'FT')
                                    )
                                ),
                                // Left shoulder on left block with shot types
                                e('div', { style: { borderTop: '1px solid rgba(244,63,94,0.3)', paddingTop: '4px', marginBottom: '4px' } },
                                    e('div', { style: { fontSize: '0.45rem', color: '#f43f5e', fontWeight: '600', marginBottom: '2px' } }, 
                                        ' L SHLD: ' + fmtPpp(onBallRadarMetrics.leftBlockLeftShoulder?.ppp || 0) + ' PPP'),
                                    // Shot types for left shoulder on left block
                                    (() => {
                                        const outcomes = onBallRadarMetrics.leftBlockLeftShoulderOutcomes || {};
                                        const types = ['toBasket', 'toHook', 'toJumper', 'toDropStep', 'toUpAndUnder'];
                                        const labels = { toBasket: 'RIM', toHook: 'HK', toJumper: 'JMP', toDropStep: 'DRP', toUpAndUnder: 'U&U' };
                                        const hasPoss = types.some(t => (outcomes[t]?.poss || 0) > 0);
                                        if (!hasPoss) return null;
                                        return e('div', { style: { display: 'flex', gap: '2px', flexWrap: 'wrap', fontSize: '0.4rem' } },
                                            types.map(t => {
                                                const d = outcomes[t] || {};
                                                if (!d.poss || d.poss === 0) return null;
                                                return e('span', { key: t, style: { padding: '1px 3px', background: 'rgba(0,0,0,0.3)', borderRadius: '2px' } },
                                                    labels[t] + ':' + fmtPct(d.fgPct || 0)
                                                );
                                            })
                                        );
                                    })()
                                ),
                                // Right shoulder on left block with shot types
                                e('div', { style: { paddingTop: '4px' } },
                                    e('div', { style: { fontSize: '0.45rem', color: '#3b82f6', fontWeight: '600', marginBottom: '2px' } }, 
                                        ' R SHLD: ' + fmtPpp(onBallRadarMetrics.leftBlockRightShoulder?.ppp || 0) + ' PPP'),
                                    // Shot types for right shoulder on left block
                                    (() => {
                                        const outcomes = onBallRadarMetrics.leftBlockRightShoulderOutcomes || {};
                                        const types = ['toBasket', 'toHook', 'toJumper', 'toDropStep', 'toUpAndUnder'];
                                        const labels = { toBasket: 'RIM', toHook: 'HK', toJumper: 'JMP', toDropStep: 'DRP', toUpAndUnder: 'U&U' };
                                        const hasPoss = types.some(t => (outcomes[t]?.poss || 0) > 0);
                                        if (!hasPoss) return null;
                                        return e('div', { style: { display: 'flex', gap: '2px', flexWrap: 'wrap', fontSize: '0.4rem' } },
                                            types.map(t => {
                                                const d = outcomes[t] || {};
                                                if (!d.poss || d.poss === 0) return null;
                                                return e('span', { key: t, style: { padding: '1px 3px', background: 'rgba(0,0,0,0.3)', borderRadius: '2px' } },
                                                    labels[t] + ':' + fmtPct(d.fgPct || 0)
                                                );
                                            })
                                        );
                                    })()
                                )
                            ),
                            // RIGHT BLOCK breakdown
                            onBallRadarMetrics._postRightBlockPoss > 0 && e('div', { style: { background: 'rgba(59,130,246,0.1)', borderRadius: '6px', padding: '6px', flex: 1 } },
                                e('div', { style: { fontSize: '0.5rem', fontWeight: '600', color: '#3b82f6', marginBottom: '4px', textAlign: 'center' } }, 
                                    'RIGHT BLOCK '),
                                e('div', { style: { display: 'flex', justifyContent: 'space-around', marginBottom: '6px', fontSize: '0.45rem' } },
                                    e('div', { style: { textAlign: 'center' } },
                                        e('div', { style: { fontFamily: 'JetBrains Mono', fontWeight: '700' } }, fmtPpp(onBallRadarMetrics.postRightBlockPPP || 0)),
                                        e('div', { style: { color: 'var(--text-muted)', fontSize: '0.4rem' } }, 'PPP')
                                    ),
                                    e('div', { style: { textAlign: 'center' } },
                                        e('div', { style: { fontFamily: 'JetBrains Mono', fontWeight: '700' } }, fmtPct(onBallRadarMetrics.postRightBlockFgPct || 0)),
                                        e('div', { style: { color: 'var(--text-muted)', fontSize: '0.4rem' } }, 'FG%')
                                    ),
                                    e('div', { style: { textAlign: 'center' } },
                                        e('div', { style: { fontFamily: 'JetBrains Mono', fontWeight: '700', color: '#ef4444' } }, fmtPct(onBallRadarMetrics.postRightBlockTOPct || 0)),
                                        e('div', { style: { color: 'var(--text-muted)', fontSize: '0.4rem' } }, 'TO%')
                                    ),
                                    e('div', { style: { textAlign: 'center' } },
                                        e('div', { style: { fontFamily: 'JetBrains Mono', fontWeight: '700', color: '#22d3ee' } }, fmtPct(onBallRadarMetrics.postRightBlockFtRate || 0)),
                                        e('div', { style: { color: 'var(--text-muted)', fontSize: '0.4rem' } }, 'FT')
                                    )
                                ),
                                // Left shoulder on right block with shot types
                                e('div', { style: { borderTop: '1px solid rgba(59,130,246,0.3)', paddingTop: '4px', marginBottom: '4px' } },
                                    e('div', { style: { fontSize: '0.45rem', color: '#f43f5e', fontWeight: '600', marginBottom: '2px' } }, 
                                        ' L SHLD: ' + fmtPpp(onBallRadarMetrics.rightBlockLeftShoulder?.ppp || 0) + ' PPP'),
                                    // Shot types for left shoulder on right block
                                    (() => {
                                        const outcomes = onBallRadarMetrics.rightBlockLeftShoulderOutcomes || {};
                                        const types = ['toBasket', 'toHook', 'toJumper', 'toDropStep', 'toUpAndUnder'];
                                        const labels = { toBasket: 'RIM', toHook: 'HK', toJumper: 'JMP', toDropStep: 'DRP', toUpAndUnder: 'U&U' };
                                        const hasPoss = types.some(t => (outcomes[t]?.poss || 0) > 0);
                                        if (!hasPoss) return null;
                                        return e('div', { style: { display: 'flex', gap: '2px', flexWrap: 'wrap', fontSize: '0.4rem' } },
                                            types.map(t => {
                                                const d = outcomes[t] || {};
                                                if (!d.poss || d.poss === 0) return null;
                                                return e('span', { key: t, style: { padding: '1px 3px', background: 'rgba(0,0,0,0.3)', borderRadius: '2px' } },
                                                    labels[t] + ':' + fmtPct(d.fgPct || 0)
                                                );
                                            })
                                        );
                                    })()
                                ),
                                // Right shoulder on right block with shot types
                                e('div', { style: { paddingTop: '4px' } },
                                    e('div', { style: { fontSize: '0.45rem', color: '#3b82f6', fontWeight: '600', marginBottom: '2px' } }, 
                                        ' R SHLD: ' + fmtPpp(onBallRadarMetrics.rightBlockRightShoulder?.ppp || 0) + ' PPP'),
                                    // Shot types for right shoulder on right block
                                    (() => {
                                        const outcomes = onBallRadarMetrics.rightBlockRightShoulderOutcomes || {};
                                        const types = ['toBasket', 'toHook', 'toJumper', 'toDropStep', 'toUpAndUnder'];
                                        const labels = { toBasket: 'RIM', toHook: 'HK', toJumper: 'JMP', toDropStep: 'DRP', toUpAndUnder: 'U&U' };
                                        const hasPoss = types.some(t => (outcomes[t]?.poss || 0) > 0);
                                        if (!hasPoss) return null;
                                        return e('div', { style: { display: 'flex', gap: '2px', flexWrap: 'wrap', fontSize: '0.4rem' } },
                                            types.map(t => {
                                                const d = outcomes[t] || {};
                                                if (!d.poss || d.poss === 0) return null;
                                                return e('span', { key: t, style: { padding: '1px 3px', background: 'rgba(0,0,0,0.3)', borderRadius: '2px' } },
                                                    labels[t] + ':' + fmtPct(d.fgPct || 0)
                                                );
                                            })
                                        );
                                    })()
                                )
                            )
                        ),
                        
                        // ===== OVERALL SHOT TYPE SUMMARY =====
                        e('div', { style: { marginTop: '8px', padding: '6px', background: 'rgba(250,204,21,0.1)', borderRadius: '6px' } },
                            e('div', { style: { fontSize: '0.5rem', fontWeight: '600', color: '#facc15', marginBottom: '4px', textAlign: 'center' } }, 'OVERALL SHOT TYPES'),
                            (() => {
                                const leftOutcomes = onBallRadarMetrics.postLeftOutcomes || {};
                                const rightOutcomes = onBallRadarMetrics.postRightOutcomes || {};
                                const shotTypes = ['toBasket', 'toHook', 'toJumper', 'toDropStep', 'toUpAndUnder'];
                                const shotLabels = { toBasket: 'Basket', toHook: 'Hook', toJumper: 'Jumper', toDropStep: 'Drop', toUpAndUnder: 'Up&Under' };
                                
                                return e('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '4px', justifyContent: 'center' } },
                                    shotTypes.map(type => {
                                        const leftData = leftOutcomes[type] || { poss: 0, fgPct: 0 };
                                        const rightData = rightOutcomes[type] || { poss: 0, fgPct: 0 };
                                        const totalPoss = leftData.poss + rightData.poss;
                                        const avgFgPct = totalPoss > 0 ? 
                                            ((leftData.poss * (leftData.fgPct || 0)) + (rightData.poss * (rightData.fgPct || 0))) / totalPoss : 0;
                                        
                                        if (totalPoss === 0) return null;
                                        
                                        return e('div', { 
                                            key: type,
                                            style: { 
                                                background: 'rgba(0,0,0,0.2)', 
                                                borderRadius: '4px', 
                                                padding: '3px 6px',
                                                fontSize: '0.45rem',
                                                textAlign: 'center'
                                            }
                                        },
                                            e('div', { style: { fontWeight: '600' } }, shotLabels[type]),
                                            e('div', { style: { fontFamily: 'JetBrains Mono', color: avgFgPct >= 50 ? '#22c55e' : avgFgPct >= 40 ? '#fbbf24' : '#ef4444' } }, 
                                                fmtPct(avgFgPct))
                                        );
                                    })
                                );
                            })()
                        ),
                        // ===== LEGEND =====
                        e('div', { style: { marginTop: '6px', paddingTop: '6px', borderTop: '1px solid rgba(255,255,255,0.1)', fontSize: '0.4rem', color: 'var(--text-muted)', textAlign: 'center' } },
                            e('span', null, 'RIM=To Basket  HK=Hook  JMP=Jumper  DRP=Drop Step  U&U=Up&Under')
                        )
                    )
                ),
                
                // P&R Pass Breakdown - only show if P&R/75 >= 2
                onBallRadarMetrics && (onBallRadarMetrics.pnrIncl75 || 0) >= 2 && e('div', { className: 'scout-key-card' },
                    e('div', { className: 'scout-key-header', style: { color: '#a78bfa' } },
                        e('span', null, ''),
                        'P&R Passing',
                        e('span', { style: { marginLeft: 'auto', fontFamily: 'JetBrains Mono', fontSize: '0.55rem', color: 'var(--text-muted)' } }, 
                            fmt(onBallRadarMetrics.pnrIncl75 || 0, 1) + ' P&R/75')
                    ),
                    e('div', { className: 'scout-key-content' },
                        e('div', { style: { textAlign: 'center', marginBottom: '8px', padding: '8px', background: 'rgba(167,139,250,0.15)', borderRadius: '6px' } },
                            e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1.3rem', fontWeight: '700', color: '#a78bfa' } }, 
                                fmtPct(onBallRadarMetrics.pnrPassPct || 0)),
                            e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)', marginTop: '2px' } }, 'PASS RATE')
                        ),
                        e('div', { className: 'scout-key-duo' },
                            e('div', { className: 'scout-key-duo-item', style: { padding: '8px' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.95rem', fontWeight: '700' } }, 
                                    fmtPct(onBallRadarMetrics.pnrRollAstPct || 0)),
                                e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, ' TO ROLL')
                            ),
                            e('div', { className: 'scout-key-duo-item', style: { padding: '8px' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.95rem', fontWeight: '700' } }, 
                                    fmtPct(onBallRadarMetrics.pnrSpotUpAstPct || 0)),
                                e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, ' TO SPOT')
                            )
                        )
                    )
                ),
                
                // Merged: Spot-Up Drives + Spot Up Drive L/R with Shot Distribution
                spacingRadarMetrics && e('div', { className: 'scout-key-card' },
                    e('div', { className: 'scout-key-header', style: { color: '#f97316' } },
                        e('span', null, ''),
                        'Spot-Up Drives'
                    ),
                    e('div', { className: 'scout-key-content' },
                        // Spot-Up Drive stats at top
                        e('div', { style: { display: 'flex', justifyContent: 'space-around', marginBottom: '8px', padding: '6px', background: 'rgba(249,115,22,0.1)', borderRadius: '6px' } },
                            e('div', { style: { textAlign: 'center' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.9rem', fontWeight: '700', color: '#f97316' } }, fmtPct(spacingRadarMetrics.spotUpDrivePct || 0)),
                                e('div', { style: { color: 'var(--text-muted)', fontSize: '0.5rem' } }, 'SPOT DRV%')
                            ),
                            e('div', { style: { textAlign: 'center' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.9rem', fontWeight: '700' } }, fmtPpp(spacingRadarMetrics.spotUpDrivesPPP || 0)),
                                e('div', { style: { color: 'var(--text-muted)', fontSize: '0.5rem' } }, 'PPP')
                            ),
                            e('div', { style: { textAlign: 'center' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.9rem', fontWeight: '700', color: '#22d3ee' } }, fmtPct(spacingRadarMetrics.spotUpDrivesFtRate || 0)),
                                e('div', { style: { color: 'var(--text-muted)', fontSize: '0.5rem' } }, 'FT RATE')
                            ),
                            e('div', { style: { textAlign: 'center' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.9rem', fontWeight: '700', color: '#ef4444' } }, fmtPct(spacingRadarMetrics.spotUpDrivesTOPct || 0)),
                                e('div', { style: { color: 'var(--text-muted)', fontSize: '0.5rem' } }, 'TO%')
                            )
                        ),
                        // Spot Up Drives L/R distribution bar
                        (spacingRadarMetrics._spotUpDrivesLeftPoss > 0 || spacingRadarMetrics._spotUpDrivesRightPoss > 0) && e('div', null,
                            (() => {
                                const leftPct = spacingRadarMetrics.spotUpDrivesLeftPct || 0;
                                const rightPct = spacingRadarMetrics.spotUpDrivesRightPct || 0;
                                const leftShots = spacingRadarMetrics.spotUpDrivesLeftShots || { rim: {}, mid: {}, three: {} };
                                const rightShots = spacingRadarMetrics.spotUpDrivesRightShots || { rim: {}, mid: {}, three: {} };
                                
                                return e('div', null,
                                    // Main L/R bar
                                    e('div', { className: 'scout-key-bar-container', style: { height: '24px' } },
                                        leftPct > 0 && e('div', { 
                                            className: 'scout-key-bar', 
                                            style: { width: `${leftPct}%`, background: '#f43f5e', fontSize: '0.65rem' }
                                        }, leftPct >= 20 ? Math.round(leftPct) + '%' : ''),
                                        rightPct > 0 && e('div', { 
                                            className: 'scout-key-bar', 
                                            style: { width: `${rightPct}%`, background: '#3b82f6', fontSize: '0.65rem' }
                                        }, rightPct >= 20 ? Math.round(rightPct) + '%' : '')
                                    ),
                                    // L/R PPP and stats
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '0.6rem', marginTop: '4px', fontWeight: '600' } },
                                        e('span', { style: { color: '#f43f5e' } }, ' LEFT: ' + fmtPpp(spacingRadarMetrics.spotUpDrivesLeftPPP || 0) + ' PPP'),
                                        e('span', { style: { color: '#3b82f6' } }, 'RIGHT: ' + fmtPpp(spacingRadarMetrics.spotUpDrivesRightPPP || 0) + ' PPP ')
                                    ),
                                    // Two-column layout for L and R breakdown
                                    e('div', { className: 'scout-key-duo', style: { marginTop: '6px' } },
                                        // LEFT DRIVE column
                                        e('div', { style: { background: 'rgba(244,63,94,0.1)', borderRadius: '6px', padding: '6px' } },
                                            // eFG, FT, TO row
                                            e('div', { style: { display: 'flex', justifyContent: 'space-around', marginBottom: '6px', fontSize: '0.55rem' } },
                                                e('div', { style: { textAlign: 'center' } },
                                                    e('div', { style: { fontWeight: '700', fontFamily: 'JetBrains Mono' } }, fmtPct(spacingRadarMetrics.spotUpDrivesLeftEfg || 0)),
                                                    e('div', { style: { color: 'var(--text-muted)', fontSize: '0.45rem' } }, 'eFG')
                                                ),
                                                e('div', { style: { textAlign: 'center' } },
                                                    e('div', { style: { fontWeight: '700', fontFamily: 'JetBrains Mono' } }, fmtPct(spacingRadarMetrics.spotUpDrivesLeftFtRate || 0)),
                                                    e('div', { style: { color: 'var(--text-muted)', fontSize: '0.45rem' } }, 'FT')
                                                ),
                                                e('div', { style: { textAlign: 'center' } },
                                                    e('div', { style: { fontWeight: '700', fontFamily: 'JetBrains Mono', color: '#ef4444' } }, fmtPct(spacingRadarMetrics.spotUpDrivesLeftTOPct || 0)),
                                                    e('div', { style: { color: 'var(--text-muted)', fontSize: '0.45rem' } }, 'TO')
                                                )
                                            ),
                                            // Shot distribution bar for LEFT
                                            leftShots.total > 0 && e('div', null,
                                                e('div', { style: { display: 'flex', height: '14px', borderRadius: '3px', overflow: 'hidden', background: 'rgba(0,0,0,0.3)' } },
                                                    leftShots.rim.pct > 0 && e('div', { style: { width: `${leftShots.rim.pct}%`, background: '#ef4444', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.45rem', fontWeight: '600', color: 'white' } }, 
                                                        leftShots.rim.pct >= 20 ? Math.round(leftShots.rim.pct) : ''),
                                                    leftShots.mid.pct > 0 && e('div', { style: { width: `${leftShots.mid.pct}%`, background: '#f59e0b', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.45rem', fontWeight: '600', color: 'white' } }, 
                                                        leftShots.mid.pct >= 20 ? Math.round(leftShots.mid.pct) : ''),
                                                    leftShots.three.pct > 0 && e('div', { style: { width: `${leftShots.three.pct}%`, background: '#22c55e', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.45rem', fontWeight: '600', color: 'white' } }, 
                                                        leftShots.three.pct >= 20 ? Math.round(leftShots.three.pct) : '')
                                                ),
                                                e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '0.45rem', marginTop: '2px' } },
                                                    e('span', { style: { color: '#ef4444' } }, 'R:' + fmtPct(leftShots.rim.fgPct || 0)),
                                                    e('span', { style: { color: '#f59e0b' } }, 'M:' + fmtPct(leftShots.mid.fgPct || 0)),
                                                    e('span', { style: { color: '#22c55e' } }, '3:' + fmtPct(leftShots.three.fgPct || 0))
                                                )
                                            )
                                        ),
                                        // RIGHT DRIVE column
                                        e('div', { style: { background: 'rgba(59,130,246,0.1)', borderRadius: '6px', padding: '6px' } },
                                            // eFG, FT, TO row
                                            e('div', { style: { display: 'flex', justifyContent: 'space-around', marginBottom: '6px', fontSize: '0.55rem' } },
                                                e('div', { style: { textAlign: 'center' } },
                                                    e('div', { style: { fontWeight: '700', fontFamily: 'JetBrains Mono' } }, fmtPct(spacingRadarMetrics.spotUpDrivesRightEfg || 0)),
                                                    e('div', { style: { color: 'var(--text-muted)', fontSize: '0.45rem' } }, 'eFG')
                                                ),
                                                e('div', { style: { textAlign: 'center' } },
                                                    e('div', { style: { fontWeight: '700', fontFamily: 'JetBrains Mono' } }, fmtPct(spacingRadarMetrics.spotUpDrivesRightFtRate || 0)),
                                                    e('div', { style: { color: 'var(--text-muted)', fontSize: '0.45rem' } }, 'FT')
                                                ),
                                                e('div', { style: { textAlign: 'center' } },
                                                    e('div', { style: { fontWeight: '700', fontFamily: 'JetBrains Mono', color: '#ef4444' } }, fmtPct(spacingRadarMetrics.spotUpDrivesRightTOPct || 0)),
                                                    e('div', { style: { color: 'var(--text-muted)', fontSize: '0.45rem' } }, 'TO')
                                                )
                                            ),
                                            // Shot distribution bar for RIGHT
                                            rightShots.total > 0 && e('div', null,
                                                e('div', { style: { display: 'flex', height: '14px', borderRadius: '3px', overflow: 'hidden', background: 'rgba(0,0,0,0.3)' } },
                                                    rightShots.rim.pct > 0 && e('div', { style: { width: `${rightShots.rim.pct}%`, background: '#ef4444', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.45rem', fontWeight: '600', color: 'white' } }, 
                                                        rightShots.rim.pct >= 20 ? Math.round(rightShots.rim.pct) : ''),
                                                    rightShots.mid.pct > 0 && e('div', { style: { width: `${rightShots.mid.pct}%`, background: '#f59e0b', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.45rem', fontWeight: '600', color: 'white' } }, 
                                                        rightShots.mid.pct >= 20 ? Math.round(rightShots.mid.pct) : ''),
                                                    rightShots.three.pct > 0 && e('div', { style: { width: `${rightShots.three.pct}%`, background: '#22c55e', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.45rem', fontWeight: '600', color: 'white' } }, 
                                                        rightShots.three.pct >= 20 ? Math.round(rightShots.three.pct) : '')
                                                ),
                                                e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '0.45rem', marginTop: '2px' } },
                                                    e('span', { style: { color: '#ef4444' } }, 'R:' + fmtPct(rightShots.rim.fgPct || 0)),
                                                    e('span', { style: { color: '#f59e0b' } }, 'M:' + fmtPct(rightShots.mid.fgPct || 0)),
                                                    e('span', { style: { color: '#22c55e' } }, '3:' + fmtPct(rightShots.three.fgPct || 0))
                                                )
                                            )
                                        )
                                    )
                                );
                            })()
                        )
                    )
                ),
                
                // Handling Shot Distribution (from on-ball section)
                // Data sources: RIM = P&R BH with direction > To Basket (FG ATT)
                //              MID = P&R BH with direction > Dribble Jumper (2 FG ATT) 
                //              3PT = P&R BH with direction > Dribble Jumper (3FG ATT)
                onBallRadarMetrics && (onBallRadarMetrics._handlingRimAtt > 0 || onBallRadarMetrics._handlingMidAtt > 0 || onBallRadarMetrics._handling3Att > 0) && e('div', { className: 'scout-key-card' },
                    e('div', { className: 'scout-key-header', style: { color: '#818cf8' } },
                        e('span', null, ''),
                        'Handling Shots',
                        e('span', { style: { marginLeft: 'auto', fontSize: '0.45rem', color: 'var(--text-muted)', fontWeight: '400' } }, 'P&R BH')
                    ),
                    (() => {
                        const rimAtt = onBallRadarMetrics._handlingRimAtt || 0;
                        const midAtt = onBallRadarMetrics._handlingMidAtt || 0;
                        const threeAtt = onBallRadarMetrics._handling3Att || 0;
                        const totalAtt = rimAtt + midAtt + threeAtt;
                        const rimPct = totalAtt > 0 ? (rimAtt / totalAtt) * 100 : 0;
                        const midPct = totalAtt > 0 ? (midAtt / totalAtt) * 100 : 0;
                        const threePct = totalAtt > 0 ? (threeAtt / totalAtt) * 100 : 0;
                        
                        // Volume thresholds for color coding (per 75 possessions)
                        const rim75 = onBallRadarMetrics.handlingRim75 || 0;
                        const mid75 = onBallRadarMetrics.handlingMid75 || 0;
                        const three75 = onBallRadarMetrics.handling3P75 || 0;
                        
                        // Color based on volume - higher volume = more emphasis
                        const getVolumeColor = (val, thresholds) => {
                            if (val >= thresholds.high) return '#22c55e';
                            if (val >= thresholds.mid) return '#fbbf24';
                            return 'var(--text-muted)';
                        };
                        
                        return e('div', { className: 'scout-key-content' },
                            // Shot distribution bar
                            e('div', { className: 'scout-key-bar-container', style: { height: '24px' } },
                                rimPct > 0 && e('div', { 
                                    className: 'scout-key-bar', 
                                    style: { width: `${rimPct}%`, background: '#ef4444', fontSize: '0.6rem' }
                                }, rimPct >= 15 ? Math.round(rimPct) + '%' : ''),
                                midPct > 0 && e('div', { 
                                    className: 'scout-key-bar', 
                                    style: { width: `${midPct}%`, background: '#f59e0b', fontSize: '0.6rem' }
                                }, midPct >= 15 ? Math.round(midPct) + '%' : ''),
                                threePct > 0 && e('div', { 
                                    className: 'scout-key-bar', 
                                    style: { width: `${threePct}%`, background: '#22c55e', fontSize: '0.6rem' }
                                }, threePct >= 15 ? Math.round(threePct) + '%' : '')
                            ),
                            // Per-75 volume - LARGE with PERCENTILE-based coloring
                            (() => {
                                // Get percentiles from onBallRadarPercentiles
                                const rimPctl = onBallRadarPercentiles?.handlingRim75;
                                const midPctl = onBallRadarPercentiles?.handlingMid75;
                                const threePctl = onBallRadarPercentiles?.handling3P75;
                                
                                // Color based on percentile
                                const getPctlColor = (pctl) => {
                                    if (pctl === null || pctl === undefined) return { bg: 'rgba(100,100,100,0.2)', border: 'rgba(100,100,100,0.4)', text: '#888' };
                                    if (pctl >= 75) return { bg: 'rgba(34,197,94,0.25)', border: 'rgba(34,197,94,0.6)', text: '#22c55e' };
                                    if (pctl >= 50) return { bg: 'rgba(34,211,238,0.25)', border: 'rgba(34,211,238,0.6)', text: '#22d3ee' };
                                    if (pctl >= 25) return { bg: 'rgba(251,191,36,0.25)', border: 'rgba(251,191,36,0.6)', text: '#fbbf24' };
                                    return { bg: 'rgba(239,68,68,0.25)', border: 'rgba(239,68,68,0.6)', text: '#ef4444' };
                                };
                                
                                const rimColors = getPctlColor(rimPctl);
                                const midColors = getPctlColor(midPctl);
                                const threeColors = getPctlColor(threePctl);
                                
                                return e('div', { style: { display: 'flex', gap: '6px', marginTop: '8px' } },
                                    e('div', { style: { textAlign: 'center', flex: 1, padding: '10px 6px', background: rimColors.bg, borderRadius: '8px', border: `2px solid ${rimColors.border}` } },
                                        e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1.3rem', fontWeight: '700', color: rimColors.text } }, 
                                            fmt(rim75, 1)),
                                        e('div', { style: { fontSize: '0.6rem', color: rimColors.text, fontWeight: '700', marginTop: '2px' } }, 'RIM/75')
                                    ),
                                    e('div', { style: { textAlign: 'center', flex: 1, padding: '10px 6px', background: midColors.bg, borderRadius: '8px', border: `2px solid ${midColors.border}` } },
                                        e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1.3rem', fontWeight: '700', color: midColors.text } }, 
                                            fmt(mid75, 1)),
                                        e('div', { style: { fontSize: '0.6rem', color: midColors.text, fontWeight: '700', marginTop: '2px' } }, 'MID/75')
                                    ),
                                    e('div', { style: { textAlign: 'center', flex: 1, padding: '10px 6px', background: threeColors.bg, borderRadius: '8px', border: `2px solid ${threeColors.border}` } },
                                        e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1.3rem', fontWeight: '700', color: threeColors.text } }, 
                                            fmt(three75, 1)),
                                        e('div', { style: { fontSize: '0.6rem', color: threeColors.text, fontWeight: '700', marginTop: '2px' } }, '3PT/75')
                                    )
                                );
                            })(),
                            // FG% for each zone
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', marginTop: '6px', padding: '6px', background: 'rgba(0,0,0,0.2)', borderRadius: '6px' } },
                                e('div', { style: { textAlign: 'center', flex: 1 } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.85rem', fontWeight: '700', color: (onBallRadarMetrics.handlingRimPct || 0) >= 55 ? '#22c55e' : (onBallRadarMetrics.handlingRimPct || 0) >= 45 ? '#fbbf24' : '#ef4444' } }, 
                                        fmtPct(onBallRadarMetrics.handlingRimPct || 0)),
                                    e('div', { style: { fontSize: '0.5rem', color: 'var(--text-muted)' } }, 'RIM FG%')
                                ),
                                e('div', { style: { textAlign: 'center', flex: 1 } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.85rem', fontWeight: '700', color: (onBallRadarMetrics.handlingMidPct || 0) >= 42 ? '#22c55e' : (onBallRadarMetrics.handlingMidPct || 0) >= 36 ? '#fbbf24' : '#ef4444' } }, 
                                        fmtPct(onBallRadarMetrics.handlingMidPct || 0)),
                                    e('div', { style: { fontSize: '0.5rem', color: 'var(--text-muted)' } }, 'MID FG%')
                                ),
                                e('div', { style: { textAlign: 'center', flex: 1 } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.85rem', fontWeight: '700', color: (onBallRadarMetrics.handling3PPct || 0) >= 36 ? '#22c55e' : (onBallRadarMetrics.handling3PPct || 0) >= 32 ? '#fbbf24' : '#ef4444' } }, 
                                        fmtPct(onBallRadarMetrics.handling3PPct || 0)),
                                    e('div', { style: { fontSize: '0.5rem', color: 'var(--text-muted)' } }, '3PT FG%')
                                )
                            )
                        );
                    })()
                ),
                
                // Catch & Shoot
                spacingRadarMetrics && e('div', { className: 'scout-key-card' },
                    e('div', { className: 'scout-key-header', style: { color: '#3b82f6' } },
                        e('span', null, ''),
                        'Catch & Shoot'
                    ),
                    e('div', { className: 'scout-key-content' },
                        // Per 75 and % of Spot-Ups side by side
                        e('div', { style: { display: 'flex', gap: '6px', marginBottom: '8px' } },
                            e('div', { style: { flex: 1, textAlign: 'center', padding: '8px', background: 'rgba(59,130,246,0.1)', borderRadius: '6px' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1.2rem', fontWeight: '700' } }, 
                                    fmt(spacingRadarMetrics.spotUpCnS75 || 0, 1)),
                                e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, 'PER 75')
                            ),
                            e('div', { style: { flex: 1, textAlign: 'center', padding: '8px', background: 'rgba(139,92,246,0.1)', borderRadius: '6px' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1.2rem', fontWeight: '700', color: '#a78bfa' } }, 
                                    fmtPct(spacingRadarMetrics.spotUpCnSPct || 0)),
                                e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, '% SPOT-UP')
                            )
                        ),
                        e('div', { className: 'scout-key-duo' },
                            e('div', { className: 'scout-key-duo-item', style: { background: 'rgba(239,68,68,0.15)', padding: '8px' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1rem', fontWeight: '700', color: (spacingRadarMetrics.guarded3Pct || 0) >= 37 ? '#22c55e' : (spacingRadarMetrics.guarded3Pct || 0) >= 33 ? '#fbbf24' : '#ef4444' } }, 
                                    fmtPct(spacingRadarMetrics.guarded3Pct || 0)),
                                e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, ' GUARDED')
                            ),
                            e('div', { className: 'scout-key-duo-item', style: { background: 'rgba(34,197,94,0.15)', padding: '8px' } },
                                e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1rem', fontWeight: '700', color: (spacingRadarMetrics.open3Pct || 0) >= 40 ? '#22c55e' : (spacingRadarMetrics.open3Pct || 0) >= 36 ? '#fbbf24' : '#ef4444' } }, 
                                    fmtPct(spacingRadarMetrics.open3Pct || 0)),
                                e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, ' OPEN')
                            )
                        ),
                        e('div', { style: { textAlign: 'center', marginTop: '8px', padding: '6px', background: 'rgba(139,92,246,0.15)', borderRadius: '6px' } },
                            e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, 'ADJUSTED 3PT%'),
                            e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '1rem', fontWeight: '700', color: (spacingRadarMetrics.adjusted3Pct || 0) >= 38 ? '#22c55e' : (spacingRadarMetrics.adjusted3Pct || 0) >= 34 ? '#fbbf24' : '#ef4444' } }, 
                                fmtPct(spacingRadarMetrics.adjusted3Pct || 0))
                        )
                    )
                ),
                
                // P&R Roll Man Tendency (including slips) - only show if Roll Man/75 >= 0.7
                finishingRadarMetrics && (finishingRadarMetrics.rollMan75 || 0) >= 0.7 && (finishingRadarMetrics.rolls75 > 0 || finishingRadarMetrics.pops75 > 0 || finishingRadarMetrics.slips75 > 0) && e('div', { className: 'scout-key-card' },
                    e('div', { className: 'scout-key-header', style: { color: '#f97316' } },
                        e('span', null, ''),
                        'Roll Man'
                    ),
                    (() => {
                        const rollsPct = finishingRadarMetrics.rollsOfRollMan || 0;
                        const slipsPct = finishingRadarMetrics.slipsOfRollMan || 0;
                        const popsPct = finishingRadarMetrics.popsOfRollMan || 0;
                        const rolls75 = finishingRadarMetrics.rolls75 || 0;
                        const slips75 = finishingRadarMetrics.slips75 || 0;
                        const pops75 = finishingRadarMetrics.pops75 || 0;
                        
                        return e('div', { className: 'scout-key-content' },
                            // Three-way distribution bar: Rolls / Slips / Pops
                            e('div', { className: 'scout-key-bar-container', style: { height: '24px' } },
                                rollsPct > 0 && e('div', { 
                                    className: 'scout-key-bar', 
                                    style: { width: `${rollsPct}%`, background: '#f97316', fontSize: '0.6rem' }
                                }, rollsPct >= 20 ? Math.round(rollsPct) + '%' : ''),
                                slipsPct > 0 && e('div', { 
                                    className: 'scout-key-bar', 
                                    style: { width: `${slipsPct}%`, background: '#22d3ee', fontSize: '0.6rem' }
                                }, slipsPct >= 20 ? Math.round(slipsPct) + '%' : ''),
                                popsPct > 0 && e('div', { 
                                    className: 'scout-key-bar', 
                                    style: { width: `${popsPct}%`, background: '#a78bfa', fontSize: '0.6rem' }
                                }, popsPct >= 20 ? Math.round(popsPct) + '%' : '')
                            ),
                            // Per-75 labels
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '0.6rem', marginTop: '6px', fontWeight: '600' } },
                                e('span', { style: { color: '#f97316' } }, ' Roll: ' + fmt(rolls75, 1)),
                                slips75 > 0 && e('span', { style: { color: '#22d3ee' } }, 'Slip: ' + fmt(slips75, 1)),
                                e('span', { style: { color: '#a78bfa' } }, 'Pop: ' + fmt(pops75, 1) + ' ')
                            ),
                            // PPP row - larger fonts
                            e('div', { style: { display: 'flex', justifyContent: 'space-around', marginTop: '8px', padding: '6px', background: 'rgba(0,0,0,0.2)', borderRadius: '6px' } },
                                e('div', { style: { textAlign: 'center' } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.9rem', fontWeight: '700', color: '#f97316' } }, fmtPpp(finishingRadarMetrics.rollsPPP || 0)),
                                    e('div', { style: { color: 'var(--text-muted)', fontSize: '0.5rem' } }, 'ROLL PPP')
                                ),
                                slips75 > 0 && e('div', { style: { textAlign: 'center' } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.9rem', fontWeight: '700', color: '#22d3ee' } }, fmtPpp(finishingRadarMetrics.slipsPPP || 0)),
                                    e('div', { style: { color: 'var(--text-muted)', fontSize: '0.5rem' } }, 'SLIP PPP')
                                ),
                                e('div', { style: { textAlign: 'center' } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.9rem', fontWeight: '700', color: '#a78bfa' } }, fmtPpp(finishingRadarMetrics.popsPPP || 0)),
                                    e('div', { style: { color: 'var(--text-muted)', fontSize: '0.5rem' } }, 'POP PPP')
                                )
                            )
                        );
                    })()
                ),
                
                // OnBall D + Post D stacked vertically
                defenseRadarMetrics && e('div', { 
                    style: { 
                        display: 'flex', 
                        flexDirection: 'column', 
                        gap: '8px'
                    } 
                },
                    // OnBall Defense with P&R and Drives breakdown
                    e('div', { className: 'scout-key-card', style: { marginBottom: '0' } },
                        e('div', { className: 'scout-key-header', style: { color: '#34d399' } },
                            e('span', null, ''),
                            'OnBall D'
                        ),
                        e('div', { className: 'scout-key-content' },
                            // Overall OnBall D stats
                            e('div', { style: { display: 'flex', justifyContent: 'space-around', padding: '6px', background: 'rgba(52,211,153,0.1)', borderRadius: '6px', marginBottom: '8px' } },
                                e('div', { style: { textAlign: 'center' } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.9rem', fontWeight: '700' } }, fmt(defenseRadarMetrics.onBallDef75 || 0, 1)),
                                    e('div', { style: { fontSize: '0.5rem', color: 'var(--text-muted)' } }, '/75')
                                ),
                                e('div', { style: { textAlign: 'center' } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.9rem', fontWeight: '700', color: (defenseRadarMetrics.onBallDefPPP || 1) <= 0.85 ? '#22c55e' : (defenseRadarMetrics.onBallDefPPP || 1) <= 1.0 ? '#fbbf24' : '#ef4444' } }, 
                                        fmtPpp(defenseRadarMetrics.onBallDefPPP || 0)),
                                    e('div', { style: { fontSize: '0.5rem', color: 'var(--text-muted)' } }, 'PPP')
                                ),
                                e('div', { style: { textAlign: 'center' } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.9rem', fontWeight: '700', color: '#22d3ee' } }, 
                                        fmtPct(defenseRadarMetrics.onBallDefTOPct || 0)),
                                    e('div', { style: { fontSize: '0.5rem', color: 'var(--text-muted)' } }, 'TO%')
                                ),
                                e('div', { style: { textAlign: 'center' } },
                                    e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.9rem', fontWeight: '700' } }, fmtPct(defenseRadarMetrics.onBallDefFtRate || 0)),
                                    e('div', { style: { fontSize: '0.5rem', color: 'var(--text-muted)' } }, 'FT RATE')
                                )
                            ),
                            // P&R and Drives breakdown
                            e('div', { className: 'scout-key-duo' },
                                // P&R Defense
                                e('div', { style: { background: 'rgba(244,114,182,0.1)', borderRadius: '6px', padding: '6px' } },
                                    e('div', { style: { fontSize: '0.55rem', fontWeight: '600', color: '#f472b6', marginBottom: '4px', textAlign: 'center' } }, ' P&R DEF'),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px' } },
                                        e('div', { style: { textAlign: 'center' } },
                                            e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.75rem', fontWeight: '700' } }, fmt(defenseRadarMetrics.pnrDef75 || 0, 1)),
                                            e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, '/75')
                                        ),
                                        e('div', { style: { textAlign: 'center' } },
                                            e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.75rem', fontWeight: '700', color: (defenseRadarMetrics.pnrDefPPP || 1) <= 0.85 ? '#22c55e' : (defenseRadarMetrics.pnrDefPPP || 1) <= 1.0 ? '#fbbf24' : '#ef4444' } }, 
                                                fmtPpp(defenseRadarMetrics.pnrDefPPP || 0)),
                                            e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, 'PPP')
                                        ),
                                        e('div', { style: { textAlign: 'center' } },
                                            e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.75rem', fontWeight: '700', color: '#22d3ee' } }, 
                                                fmtPct(defenseRadarMetrics.pnrDefTOPct || 0)),
                                            e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, 'TO%')
                                        ),
                                        e('div', { style: { textAlign: 'center' } },
                                            e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.75rem', fontWeight: '700' } }, fmtPct(defenseRadarMetrics.pnrDefFtRate || 0)),
                                            e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, 'FT')
                                        )
                                    )
                                ),
                                // Drives Defense
                                e('div', { style: { background: 'rgba(249,115,22,0.1)', borderRadius: '6px', padding: '6px' } },
                                    e('div', { style: { fontSize: '0.55rem', fontWeight: '600', color: '#f97316', marginBottom: '4px', textAlign: 'center' } }, ' DRIVES DEF'),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px' } },
                                        e('div', { style: { textAlign: 'center' } },
                                            e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.75rem', fontWeight: '700' } }, fmt(defenseRadarMetrics.drivesDef75 || 0, 1)),
                                            e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, '/75')
                                        ),
                                        e('div', { style: { textAlign: 'center' } },
                                            e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.75rem', fontWeight: '700', color: (defenseRadarMetrics.drivesDefPPP || 1) <= 0.85 ? '#22c55e' : (defenseRadarMetrics.drivesDefPPP || 1) <= 1.0 ? '#fbbf24' : '#ef4444' } }, 
                                                fmtPpp(defenseRadarMetrics.drivesDefPPP || 0)),
                                            e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, 'PPP')
                                        ),
                                        e('div', { style: { textAlign: 'center' } },
                                            e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.75rem', fontWeight: '700', color: '#22d3ee' } }, 
                                                fmtPct(defenseRadarMetrics.drivesDefTOPct || 0)),
                                            e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, 'TO%')
                                        ),
                                        e('div', { style: { textAlign: 'center' } },
                                            e('div', { style: { fontFamily: 'JetBrains Mono', fontSize: '0.75rem', fontWeight: '700' } }, fmtPct(defenseRadarMetrics.drivesDefFtRate || 0)),
                                            e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, 'FT')
                                        )
                                    )
                                )
                            )
                        )
                    ),
                    
                    // Post Defense (within same container)
                    defenseRadarMetrics.postDef75 > 0 && e('div', { className: 'scout-key-card', style: { marginBottom: '0' } },
                        e('div', { className: 'scout-key-header', style: { color: '#22c55e' } },
                            e('span', null, ''),
                            'Post D'
                        ),
                        e('div', { className: 'scout-key-stats' },
                            e('div', { className: 'scout-key-stat' },
                                e('div', { className: 'scout-key-stat-value' }, fmt(defenseRadarMetrics.postDef75 || 0, 1)),
                                e('div', { className: 'scout-key-stat-label' }, '/75')
                            ),
                            e('div', { className: 'scout-key-stat' },
                                e('div', { className: 'scout-key-stat-value', style: { color: (defenseRadarMetrics.postDefPPP || 1) <= 0.85 ? '#22c55e' : (defenseRadarMetrics.postDefPPP || 1) <= 1.0 ? '#fbbf24' : '#ef4444' } }, 
                                    fmtPpp(defenseRadarMetrics.postDefPPP || 0)),
                                e('div', { className: 'scout-key-stat-label' }, 'PPP')
                            ),
                            e('div', { className: 'scout-key-stat' },
                                e('div', { className: 'scout-key-stat-value', style: { color: '#22d3ee' } }, 
                                    fmtPct(defenseRadarMetrics.postDefTOPct || 0)),
                                e('div', { className: 'scout-key-stat-label' }, 'TO%')
                            ),
                            e('div', { className: 'scout-key-stat' },
                                e('div', { className: 'scout-key-stat-value' }, fmtPct(defenseRadarMetrics.postDefFtRate || 0)),
                                e('div', { className: 'scout-key-stat-label' }, 'FT')
                            )
                        )
                    )
                )
            )
        ),
        
        // ========== ON-BALL SECTION (COLLAPSIBLE) ==========
        e('div', { id: 'section-onball', className: 'scout-collapsible-section', style: { position: 'relative' } },
            // Camera button
            e(CameraButton, { 
                onClick: () => openScreenshotModal('onball', 'ON-BALL BREAKDOWN', 'section-onball', {
                    playerName: playerData.playerName,
                    playerTeam: playerData.team,
                    playerRole: playerRoleInfo?.role?.name
                }),
                style: { top: '8px', right: '8px' }
            }),
            // Collapsible Header
            e('div', { 
                className: 'scout-section-header',
                onClick: () => setOnBallCollapsed(!onBallCollapsed)
            },
                e('div', { className: 'scout-section-header-title on-ball' },
                    e('span', null, ''),
                    e('span', null, 'ON-BALL')
                ),
                e('div', { className: 'scout-section-header-stats' },
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'ON-BALL%'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#f97316' } }, 
                            fmtPct((playerData.playTypeStats['Isolation']?.pctOfPoss || 0) + 
                                   (playerData.playTypeStats['P&R Ball Handler']?.pctOfPoss || 0) + 
                                   (playerData.playTypeStats['Post-Up']?.pctOfPoss || 0)))
                    ),
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'PPP'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#22d3ee' } }, 
                            fmtPpp(onBallRadarMetrics?.onBallPPP || radar1Metrics?.onBallPPP || 0))
                    ),
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'CREATION/75'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#a78bfa' } }, 
                            fmt(onBallRadarMetrics?.onBallIncl75 || radar1Metrics?.onBallIncl75 || 0, 1))
                    )
                ),
                e('div', { className: 'scout-section-toggle' },
                    e('span', null, onBallCollapsed ? 'Expand' : 'Collapse'),
                    e('span', { className: `scout-section-toggle-icon ${onBallCollapsed ? '' : 'expanded'}` }, '')
                )
            ),
            // Collapsible Content
            e('div', { className: `scout-section-content ${onBallCollapsed ? '' : 'expanded'}` },
                e('div', { className: 'scout-section-row' },
                    // Left column - Bar Chart + Pressure/Unpressured
                    e('div', { className: 'scout-section-box' },
                        e('div', { className: 'scout-section-title' }, 'ON-BALL'),
                        e('div', { className: 'scout-section-subtitle' }, '% OF TOTAL POSS.'),
                        e(ScoutBarChart, {
                    data: [
                        { label: 'ISO', value: playerData.playTypeStats['Isolation']?.pctOfPoss || 0, color: 'red' },
                        { label: 'P&R', value: playerData.playTypeStats['P&R Ball Handler']?.pctOfPoss || 0, color: 'yellow' },
                        { label: 'POST', value: playerData.playTypeStats['Post-Up']?.pctOfPoss || 0, color: 'green' }
                    ]
                }),
                
                // Pressure vs Unpressured section
                onBallRadarMetrics && e('div', { style: { marginTop: '16px', paddingTop: '12px', borderTop: '1px solid rgba(255,255,255,0.1)' } },
                    e('div', { className: 'scout-section-subtitle', style: { marginBottom: '8px' } }, 'PRESSURE VS UNPRESSURED'),
                    
                    // P&R Pressure
                    e('div', { style: { marginBottom: '10px' } },
                        e('div', { style: { fontSize: '0.65rem', color: 'var(--text-muted)', marginBottom: '4px' } }, 'P&R BALL HANDLER'),
                        e('div', { style: { display: 'flex', gap: '8px' } },
                            e('div', { style: { flex: 1, background: 'rgba(239,68,68,0.15)', borderRadius: '6px', padding: '6px', textAlign: 'center' } },
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--accent-rose)', marginBottom: '2px' } }, ' PRESSURE'),
                                e('div', { style: { fontSize: '0.9rem', fontWeight: '700' } }, fmtPpp(onBallRadarMetrics.pnrPressurePPP || 0)),
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, 'TO: ' + fmtPct(onBallRadarMetrics.pnrPressureTOPct || 0))
                            ),
                            e('div', { style: { flex: 1, background: 'rgba(34,197,94,0.15)', borderRadius: '6px', padding: '6px', textAlign: 'center' } },
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--accent-emerald)', marginBottom: '2px' } }, ' OPEN'),
                                e('div', { style: { fontSize: '0.9rem', fontWeight: '700' } }, fmtPpp(onBallRadarMetrics.pnrUnpressuredPPP || 0)),
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, 'TO: ' + fmtPct(onBallRadarMetrics.pnrUnpressuredTOPct || 0))
                            )
                        )
                    ),
                    
                    // Post Pressure
                    e('div', null,
                        e('div', { style: { fontSize: '0.65rem', color: 'var(--text-muted)', marginBottom: '4px' } }, 'POST-UP'),
                        e('div', { style: { display: 'flex', gap: '8px' } },
                            e('div', { style: { flex: 1, background: 'rgba(239,68,68,0.15)', borderRadius: '6px', padding: '6px', textAlign: 'center' } },
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--accent-rose)', marginBottom: '2px' } }, ' PRESSURE'),
                                e('div', { style: { fontSize: '0.9rem', fontWeight: '700' } }, fmtPpp(onBallRadarMetrics.postPressurePPP || 0)),
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, 'TO: ' + fmtPct(onBallRadarMetrics.postPressureTOPct || 0))
                            ),
                            e('div', { style: { flex: 1, background: 'rgba(34,197,94,0.15)', borderRadius: '6px', padding: '6px', textAlign: 'center' } },
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--accent-emerald)', marginBottom: '2px' } }, ' OPEN'),
                                e('div', { style: { fontSize: '0.9rem', fontWeight: '700' } }, fmtPpp(onBallRadarMetrics.postUnpressuredPPP || 0)),
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, 'TO: ' + fmtPct(onBallRadarMetrics.postUnpressuredTOPct || 0))
                            )
                        )
                    ),
                    
                    // P&R Pass Breakdown section
                    e('div', { style: { marginTop: '12px', paddingTop: '12px', borderTop: '1px solid rgba(255,255,255,0.1)' } },
                        e('div', { style: { fontSize: '0.65rem', color: 'var(--text-muted)', marginBottom: '6px' } }, 'P&R PASS BREAKDOWN'),
                        e('div', { style: { background: 'rgba(168,85,247,0.15)', borderRadius: '6px', padding: '8px' } },
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' } },
                                e('span', { style: { fontSize: '0.7rem', color: 'var(--text-secondary)' } }, 'Pass %'),
                                e('span', { style: { fontSize: '0.9rem', fontWeight: '700', color: 'var(--accent-violet)' } }, fmtPct(onBallRadarMetrics.pnrPassPct || 0))
                            ),
                            e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)', marginBottom: '4px' } }, 'PASS DESTINATIONS'),
                            e('div', { style: { display: 'flex', gap: '6px' } },
                                e('div', { style: { flex: 1, background: 'rgba(0,0,0,0.2)', borderRadius: '4px', padding: '6px', textAlign: 'center' } },
                                    e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, ' ROLL'),
                                    e('div', { style: { fontSize: '0.8rem', fontWeight: '600' } }, fmtPct(onBallRadarMetrics.pnrRollAstPct || 0)),
                                    e('div', { 
                                        style: { 
                                            fontSize: '0.7rem', 
                                            fontWeight: '600',
                                            marginTop: '2px',
                                            color: getPercentileColor(onBallRadarPercentiles?.pnrRollAst75)
                                        } 
                                    }, fmt(onBallRadarMetrics.pnrRollAst75 || 0, 1) + '/75')
                                ),
                                e('div', { style: { flex: 1, background: 'rgba(0,0,0,0.2)', borderRadius: '4px', padding: '6px', textAlign: 'center' } },
                                    e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, ' SPOT'),
                                    e('div', { style: { fontSize: '0.8rem', fontWeight: '600' } }, fmtPct(onBallRadarMetrics.pnrSpotUpAstPct || 0)),
                                    e('div', { 
                                        style: { 
                                            fontSize: '0.7rem', 
                                            fontWeight: '600',
                                            marginTop: '2px',
                                            color: getPercentileColor(onBallRadarPercentiles?.pnrSpotUpAst75)
                                        } 
                                    }, fmt(onBallRadarMetrics.pnrSpotUpAst75 || 0, 1) + '/75')
                                )
                            )
                        )
                    ),
                    
                    // Self-Creation Breakdown section
                    e('div', { style: { marginTop: '12px', paddingTop: '12px', borderTop: '1px solid rgba(255,255,255,0.1)' } },
                        e('div', { style: { fontSize: '0.65rem', color: 'var(--text-muted)', marginBottom: '6px' } }, 'SELF-CREATION BREAKDOWN'),
                        e('div', { style: { background: 'rgba(129,140,248,0.15)', borderRadius: '6px', padding: '8px' } },
                            // Creation/75 and PPP header (using direct metrics)
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px', paddingBottom: '6px', borderBottom: '1px solid rgba(255,255,255,0.1)' } },
                                e('div', { style: { textAlign: 'center', flex: 1 } },
                                    e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, 'Creation/75'),
                                    e('div', { 
                                        style: { 
                                            fontSize: '1rem', 
                                            fontWeight: '700',
                                            color: getPercentileColor(onBallRadarPercentiles?.onBall75)
                                        } 
                                    }, fmt(onBallRadarMetrics.onBall75 || 0, 1))
                                ),
                                e('div', { style: { textAlign: 'center', flex: 1 } },
                                    e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, 'Creation PPP'),
                                    e('div', { 
                                        style: { 
                                            fontSize: '1rem', 
                                            fontWeight: '700',
                                            color: getPercentileColor(onBallRadarPercentiles?.onBallPPP)
                                        } 
                                    }, fmtPpp(onBallRadarMetrics.onBallPPP || 0))
                                )
                            ),
                            // Individual play types
                            e('div', { style: { display: 'flex', flexDirection: 'column', gap: '6px' } },
                                // P&R BH
                                e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: 'rgba(0,0,0,0.2)', borderRadius: '4px', padding: '6px' } },
                                    e('div', { style: { fontSize: '0.65rem', color: 'var(--accent-rose)', fontWeight: '600' } }, 'P&R BH'),
                                    e('div', { style: { display: 'flex', gap: '12px' } },
                                        e('div', { style: { textAlign: 'right' } },
                                            e('span', { 
                                                style: { 
                                                    fontSize: '0.75rem', 
                                                    fontWeight: '600',
                                                    color: getPercentileColor(onBallRadarPercentiles?.pnrBH75)
                                                } 
                                            }, fmt(onBallRadarMetrics.pnrBH75 || 0, 1) + '/75')
                                        ),
                                        e('div', { style: { textAlign: 'right', minWidth: '40px' } },
                                            e('span', { 
                                                style: { 
                                                    fontSize: '0.75rem', 
                                                    fontWeight: '600',
                                                    color: getPercentileColor(onBallRadarPercentiles?.pnrBHPPP)
                                                } 
                                            }, fmtPpp(onBallRadarMetrics.pnrBHPPP || 0) + ' PPP')
                                        )
                                    )
                                ),
                                // Isolation
                                e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: 'rgba(0,0,0,0.2)', borderRadius: '4px', padding: '6px' } },
                                    e('div', { style: { fontSize: '0.65rem', color: 'var(--accent-amber)', fontWeight: '600' } }, 'ISO'),
                                    e('div', { style: { display: 'flex', gap: '12px' } },
                                        e('div', { style: { textAlign: 'right' } },
                                            e('span', { 
                                                style: { 
                                                    fontSize: '0.75rem', 
                                                    fontWeight: '600',
                                                    color: getPercentileColor(onBallRadarPercentiles?.isoDirect75)
                                                } 
                                            }, fmt(onBallRadarMetrics.isoDirect75 || 0, 1) + '/75')
                                        ),
                                        e('div', { style: { textAlign: 'right', minWidth: '40px' } },
                                            e('span', { 
                                                style: { 
                                                    fontSize: '0.75rem', 
                                                    fontWeight: '600',
                                                    color: getPercentileColor(onBallRadarPercentiles?.isoDirectPPP)
                                                } 
                                            }, fmtPpp(onBallRadarMetrics.isoDirectPPP || 0) + ' PPP')
                                        )
                                    )
                                ),
                                // Post-Up
                                e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: 'rgba(0,0,0,0.2)', borderRadius: '4px', padding: '6px' } },
                                    e('div', { style: { fontSize: '0.65rem', color: 'var(--accent-yellow)', fontWeight: '600' } }, 'POST'),
                                    e('div', { style: { display: 'flex', gap: '12px' } },
                                        e('div', { style: { textAlign: 'right' } },
                                            e('span', { 
                                                style: { 
                                                    fontSize: '0.75rem', 
                                                    fontWeight: '600',
                                                    color: getPercentileColor(onBallRadarPercentiles?.postDirect75)
                                                } 
                                            }, fmt(onBallRadarMetrics.postDirect75 || 0, 1) + '/75')
                                        ),
                                        e('div', { style: { textAlign: 'right', minWidth: '40px' } },
                                            e('span', { 
                                                style: { 
                                                    fontSize: '0.75rem', 
                                                    fontWeight: '600',
                                                    color: getPercentileColor(onBallRadarPercentiles?.postDirectPPP)
                                                } 
                                            }, fmtPpp(onBallRadarMetrics.postDirectPPP || 0) + ' PPP')
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ),
            
            // Center - On-Ball Radar with Stats Table
            e('div', { className: 'scout-section-box', style: { display: 'flex', alignItems: 'flex-start', gap: '12px' } },
                // Stats Table (left)
                onBallRadarMetrics && e(RadarStatsTable, {
                    metrics: onBallRadarMetrics,
                    percentiles: onBallRadarPercentiles,
                    title: ' ON-BALL',
                    compact: true,
                    categories: [
                        { name: 'OVERALL', color: '#818cf8', metricDefs: [
                            { key: 'onBallPct', label: 'OnBall%', format: 'pct' },
                            { key: 'onBallInclPPP', label: 'PPP', format: 'ppp' }
                        ]},
                        { name: 'P&R OVERALL', color: '#f472b6', metricDefs: [
                            { key: 'pnrIncl75', label: 'P&R/75', format: 'dec' },
                            { key: 'pnrInclPPP', label: 'P&R PPP', format: 'ppp' },
                            { key: 'pnrPressurePPP', label: 'Press PPP', format: 'ppp' },
                            { key: 'pnrPressureTOPct', label: 'Press TO%', format: 'pct' }
                        ]},
                        { name: 'P&R PASSING', color: '#a78bfa', metricDefs: [
                            { key: 'pnrPassPct', label: 'Pass%', format: 'pct' },
                            { key: 'pnrTOPct', label: 'TO%', format: 'pct' },
                            { key: 'pnrRollAst75', label: 'Roll AST', format: 'dec' },
                            { key: 'pnrSpotUpAst75', label: 'Spot AST', format: 'dec' }
                        ]},
                        { name: 'SHOT SELECTION', color: '#22d3ee', metricDefs: [
                            { key: 'handlingRim75', label: 'Rim/75', format: 'dec' },
                            { key: 'handlingRimPct', label: 'Rim%', format: 'pct' },
                            { key: 'handlingMid75', label: 'Mid/75', format: 'dec' },
                            { key: 'handlingMidPct', label: 'Mid%', format: 'pct' },
                            { key: 'handling3P75', label: '3P/75', format: 'dec' },
                            { key: 'handling3PPct', label: '3P%', format: 'pct' }
                        ]},
                        { name: 'ISOLATION', color: '#fb923c', metricDefs: [
                            { key: 'iso75', label: 'ISO/75', format: 'dec' },
                            { key: 'isoPPP', label: 'ISO PPP', format: 'ppp' }
                        ]},
                        { name: 'POST OVERALL', color: '#facc15', metricDefs: [
                            { key: 'post75', label: 'Post/75', format: 'dec' },
                            { key: 'postPPP', label: 'Post PPP', format: 'ppp' },
                            { key: 'postPassPct', label: 'Pass%', format: 'pct' },
                            { key: 'postPressurePPP', label: 'Press PPP', format: 'ppp' }
                        ]},
                        { name: 'POST L VS R', color: '#34d399', metricDefs: [
                            { key: 'postLeftPPP', label: 'L PPP', format: 'ppp' },
                            { key: 'postLeftPct', label: 'L%', format: 'pct' },
                            { key: 'postRightPPP', label: 'R PPP', format: 'ppp' },
                            { key: 'postRightPct', label: 'R%', format: 'pct' }
                        ]}
                    ]
                }),
                // Chart (right)
                onBallRadarMetrics ? e(OnBallRadarChart, { 
                    metrics: onBallRadarMetrics,
                    size: 480,
                    radarPercentiles: onBallRadarPercentiles,
                    onBallPct: radar1Metrics?.onBallPct || onBallRadarMetrics.onBallPct,
                    onBallPPP: onBallRadarMetrics.onBallPPP
                }) : e(PlaceholderRadar, { title: 'On-Ball Radar' })
            ),
            
            // Right column - Handling Shot Distribution
            e('div', { className: 'scout-section-box' },
                e('div', { className: 'scout-section-title' }, 'HANDLING SHOT DISTRIBUTION'),
                e('div', { className: 'scout-section-subtitle' }, 'P&R Ball Handler Dribble Jumpers'),
                onBallRadarMetrics ? e('div', { className: 'shot-dist-chart' },
                    // Get total attempts for percentages
                    (() => {
                        const rimAtt = onBallRadarMetrics._handlingRimAtt || 0;
                        const midAtt = onBallRadarMetrics._handlingMidAtt || 0;
                        const threeAtt = onBallRadarMetrics._handling3Att || 0;
                        const totalAtt = rimAtt + midAtt + threeAtt;
                        
                        const rimPct = totalAtt > 0 ? (rimAtt / totalAtt) * 100 : 0;
                        const midPct = totalAtt > 0 ? (midAtt / totalAtt) * 100 : 0;
                        const threePct = totalAtt > 0 ? (threeAtt / totalAtt) * 100 : 0;
                        
                        // Calculate per 75 for each zone
                        const rim75 = onBallRadarMetrics.handlingRim75 || 0;
                        const mid75 = onBallRadarMetrics.handlingMid75 || 0;
                        const three75 = onBallRadarMetrics.handling3P75 || 0;
                        
                        return e('div', { className: 'shot-dist-bars' },
                            // Rim
                            e('div', { className: 'shot-dist-row' },
                                e('div', { className: 'shot-dist-label' }, ' RIM'),
                                e('div', { className: 'shot-dist-bar-container' },
                                    e('div', { 
                                        className: 'shot-dist-bar',
                                        style: { 
                                            width: `${rimPct}%`,
                                            background: 'var(--accent-emerald)'
                                        }
                                    })
                                ),
                                e('div', { className: 'shot-dist-value' }, fmtPct(rimPct)),
                                e('div', { className: 'shot-dist-fg' }, fmtPct(onBallRadarMetrics.handlingRimPct || 0) + ' FG%'),
                                e('div', { 
                                    className: 'shot-dist-per75', 
                                    style: { 
                                        fontSize: '0.7rem', 
                                        fontWeight: '600',
                                        marginLeft: '4px',
                                        color: getPercentileColor(onBallRadarPercentiles?.handlingRim75)
                                    } 
                                }, fmt(rim75, 1) + '/75')
                            ),
                            // Mid
                            e('div', { className: 'shot-dist-row' },
                                e('div', { className: 'shot-dist-label' }, ' MID'),
                                e('div', { className: 'shot-dist-bar-container' },
                                    e('div', { 
                                        className: 'shot-dist-bar',
                                        style: { 
                                            width: `${midPct}%`,
                                            background: 'var(--accent-amber)'
                                        }
                                    })
                                ),
                                e('div', { className: 'shot-dist-value' }, fmtPct(midPct)),
                                e('div', { className: 'shot-dist-fg' }, fmtPct(onBallRadarMetrics.handlingMidPct || 0) + ' FG%'),
                                e('div', { 
                                    className: 'shot-dist-per75', 
                                    style: { 
                                        fontSize: '0.7rem', 
                                        fontWeight: '600',
                                        marginLeft: '4px',
                                        color: getPercentileColor(onBallRadarPercentiles?.handlingMid75)
                                    } 
                                }, fmt(mid75, 1) + '/75')
                            ),
                            // 3PT
                            e('div', { className: 'shot-dist-row' },
                                e('div', { className: 'shot-dist-label' }, ' 3PT'),
                                e('div', { className: 'shot-dist-bar-container' },
                                    e('div', { 
                                        className: 'shot-dist-bar',
                                        style: { 
                                            width: `${threePct}%`,
                                            background: 'var(--accent-blue)'
                                        }
                                    })
                                ),
                                e('div', { className: 'shot-dist-value' }, fmtPct(threePct)),
                                e('div', { className: 'shot-dist-fg' }, fmtPct(onBallRadarMetrics.handling3PPct || 0) + ' FG%'),
                                e('div', { 
                                    className: 'shot-dist-per75', 
                                    style: { 
                                        fontSize: '0.7rem', 
                                        fontWeight: '600',
                                        marginLeft: '4px',
                                        color: getPercentileColor(onBallRadarPercentiles?.handling3P75)
                                    } 
                                }, fmt(three75, 1) + '/75')
                            ),
                            // Volume indicator
                            e('div', { className: 'shot-dist-volume' },
                                `Total: ${totalAtt} ATT`
                            )
                        );
                    })()
                ) : e('div', { style: { color: 'var(--text-muted)', textAlign: 'center' } }, 'No handling data'),
                
                // Post-Ups Left vs Right Shoulder section
                e('div', { style: { marginTop: '16px', paddingTop: '16px', borderTop: '1px solid rgba(255,255,255,0.1)' } },
                    e('div', { className: 'scout-section-title', style: { marginBottom: '4px' } }, 'POST-UPS'),
                    e('div', { className: 'scout-section-subtitle' }, 'Left vs Right Shoulder'),
                    onBallRadarMetrics ? e('div', null,
                        e('div', { className: 'hands-compact', style: { marginTop: '8px' } },
                            e('div', { className: 'hand-compact' },
                                e('div', { 
                                    className: 'hand-compact-icon',
                                    style: { fontSize: '1.5rem' }
                                }, ''),
                                e('div', { className: 'hand-compact-label' }, 'LEFT'),
                                e('div', { 
                                    className: `hand-compact-pct ${getPctClass(onBallRadarPercentiles?.postLeftPPP)}`
                                }, fmtPct(onBallRadarMetrics.postLeftPct || 0)),
                                e('div', { className: 'hand-compact-per75' }, (calcPer75(onBallRadarMetrics._postLeftPoss) !== null ? fmt(calcPer75(onBallRadarMetrics._postLeftPoss), 1) : '-') + '/75'),
                                e('div', { className: 'hand-shot-types' },
                                    e('div', { className: 'shot-type-row' },
                                        e('span', { className: 'shot-type-label' }, 'eFG%'),
                                        e('span', { className: 'shot-type-value' }, fmtPct(onBallRadarMetrics.postLeftEfg || 0))
                                    ),
                                    e('div', { className: 'shot-type-row' },
                                        e('span', { className: 'shot-type-label' }, 'FT Rate'),
                                        e('span', { className: 'shot-type-value' }, fmtPct(onBallRadarMetrics.postLeftFtRate || 0))
                                    ),
                                    e('div', { className: 'shot-type-row' },
                                        e('span', { className: 'shot-type-label' }, 'TO%'),
                                        e('span', { className: 'shot-type-value' }, fmtPct(onBallRadarMetrics.postLeftTOPct || 0))
                                    )
                                )
                            ),
                            e('div', { className: 'hand-compact' },
                                e('div', { 
                                    className: 'hand-compact-icon',
                                    style: { fontSize: '1.5rem' }
                                }, ''),
                                e('div', { className: 'hand-compact-label' }, 'RIGHT'),
                                e('div', { 
                                    className: `hand-compact-pct ${getPctClass(onBallRadarPercentiles?.postRightPPP)}`
                                }, fmtPct(onBallRadarMetrics.postRightPct || 0)),
                                e('div', { className: 'hand-compact-per75' }, (calcPer75(onBallRadarMetrics._postRightPoss) !== null ? fmt(calcPer75(onBallRadarMetrics._postRightPoss), 1) : '-') + '/75'),
                                e('div', { className: 'hand-shot-types' },
                                    e('div', { className: 'shot-type-row' },
                                        e('span', { className: 'shot-type-label' }, 'eFG%'),
                                        e('span', { className: 'shot-type-value' }, fmtPct(onBallRadarMetrics.postRightEfg || 0))
                                    ),
                                    e('div', { className: 'shot-type-row' },
                                        e('span', { className: 'shot-type-label' }, 'FT Rate'),
                                        e('span', { className: 'shot-type-value' }, fmtPct(onBallRadarMetrics.postRightFtRate || 0))
                                    ),
                                    e('div', { className: 'shot-type-row' },
                                        e('span', { className: 'shot-type-label' }, 'TO%'),
                                        e('span', { className: 'shot-type-value' }, fmtPct(onBallRadarMetrics.postRightTOPct || 0))
                                    )
                                )
                            )
                        ),
                        // Shoulder outcomes section
                        e('div', { style: { marginTop: '12px', display: 'flex', gap: '8px' } },
                            // Left shoulder outcomes
                            e('div', { style: { flex: 1, background: 'rgba(0,0,0,0.2)', borderRadius: '6px', padding: '8px' } },
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)', marginBottom: '4px', textAlign: 'center' } }, 'LEFT OUTCOMES'),
                                onBallRadarMetrics.postLeftOutcomes && Object.entries(onBallRadarMetrics.postLeftOutcomes)
                                    .filter(([_, data]) => data.poss > 0)
                                    .sort((a, b) => b[1].poss - a[1].poss)
                                    .slice(0, 3)
                                    .map(([key, data]) => 
                                        e('div', { key, className: 'shot-type-row', style: { fontSize: '0.6rem' } },
                                            e('span', { className: 'shot-type-label' }, data.label),
                                            e('span', { className: 'shot-type-value' }, fmtPpp(data.ppp))
                                        )
                                    )
                            ),
                            // Right shoulder outcomes
                            e('div', { style: { flex: 1, background: 'rgba(0,0,0,0.2)', borderRadius: '6px', padding: '8px' } },
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)', marginBottom: '4px', textAlign: 'center' } }, 'RIGHT OUTCOMES'),
                                onBallRadarMetrics.postRightOutcomes && Object.entries(onBallRadarMetrics.postRightOutcomes)
                                    .filter(([_, data]) => data.poss > 0)
                                    .sort((a, b) => b[1].poss - a[1].poss)
                                    .slice(0, 3)
                                    .map(([key, data]) => 
                                        e('div', { key, className: 'shot-type-row', style: { fontSize: '0.6rem' } },
                                            e('span', { className: 'shot-type-label' }, data.label),
                                            e('span', { className: 'shot-type-value' }, fmtPpp(data.ppp))
                                        )
                                    )
                            )
                        )
                    ) : e('div', { style: { color: 'var(--text-muted)', textAlign: 'center' } }, 'No post-up data')
                )
            )
        ))), // Close scout-section-row, scout-section-content, scout-collapsible-section
        
        // ========== SPACING SECTION (COLLAPSIBLE) ==========
        e('div', { id: 'section-spacing', className: 'scout-collapsible-section', style: { position: 'relative' } },
            // Camera button
            e(CameraButton, { 
                onClick: () => openScreenshotModal('spacing', 'SPACING BREAKDOWN', 'section-spacing', {
                    playerName: playerData.playerName,
                    playerTeam: playerData.team,
                    playerRole: playerRoleInfo?.role?.name
                }),
                style: { top: '8px', right: '8px' }
            }),
            // Collapsible Header
            e('div', { 
                className: 'scout-section-header',
                onClick: () => setSpacingCollapsed(!spacingCollapsed)
            },
                e('div', { className: 'scout-section-header-title spacing' },
                    e('span', null, ''),
                    e('span', null, 'SPACING')
                ),
                e('div', { className: 'scout-section-header-stats' },
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'SPACING%'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#06b6d4' } }, 
                            fmtPct(spacingRadarMetrics?.spacingPct || radar1Metrics?.spacingPct || 0))
                    ),
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'PPP'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#22d3ee' } }, 
                            fmtPpp(spacingRadarMetrics?.spacingPPP || radar1Metrics?.spacingPPP || 0))
                    ),
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'SPACING/75'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#a78bfa' } }, 
                            fmt(radar1Metrics?.spacingVol75 || 0, 1))
                    )
                ),
                e('div', { className: 'scout-section-toggle' },
                    e('span', null, spacingCollapsed ? 'Expand' : 'Collapse'),
                    e('span', { className: `scout-section-toggle-icon ${spacingCollapsed ? '' : 'expanded'}` }, '')
                )
            ),
            // Collapsible Content
            e('div', { className: `scout-section-content ${spacingCollapsed ? '' : 'expanded'}` },
                e('div', { className: 'scout-section-row' },
                    // Left column - Bar Chart + Off Screen Direction
                    e('div', { className: 'scout-section-box' },
                        e('div', { className: 'scout-section-title' }, 'SPACING'),
                        e('div', { className: 'scout-section-subtitle' }, '% OF TOTAL POSS.'),
                        e(ScoutBarChart, {
                    data: [
                        { label: 'SPOT', value: playerData.playTypeStats['Spot Up']?.pctOfPoss || 0, color: 'red' },
                        { label: 'HO', value: playerData.playTypeStats['Handoffs']?.pctOfPoss || 0, color: 'yellow' },
                        { label: 'SCRN', value: playerData.playTypeStats['Off Screen']?.pctOfPoss || 0, color: 'green' }
                    ]
                }),
                
                // Off Screen Direction section
                offScreenData && (offScreenData.left?.poss > 0 || offScreenData.right?.poss > 0) && e('div', { 
                    style: { marginTop: '16px', paddingTop: '12px', borderTop: '1px solid rgba(255,255,255,0.1)' } 
                },
                    e('div', { className: 'scout-section-subtitle', style: { marginBottom: '8px' } }, 'OFF SCREEN DIRECTION'),
                    e(HorizBarChart, { 
                        data: [
                            { label: 'Left', value: offScreenData.left?.poss || 0, color: 'rose', subValue: fmtPpp(offScreenData.left?.ppp || 0) + ' PPP' },
                            { label: 'Right', value: offScreenData.right?.poss || 0, color: 'blue', subValue: fmtPpp(offScreenData.right?.ppp || 0) + ' PPP' }
                        ],
                        height: 20
                    }),
                    e('div', { style: { display: 'flex', flexDirection: 'column', gap: '8px', marginTop: '10px' } },
                        // Shooter's Left compact card
                        e('div', { 
                            style: { 
                                background: 'rgba(244,63,94,0.1)', 
                                borderRadius: '6px', 
                                padding: '8px',
                                border: '1px solid rgba(244,63,94,0.3)'
                            }
                        },
                            e('div', { style: { fontSize: '0.6rem', color: '#f43f5e', fontWeight: '600', marginBottom: '4px' } }, " SHOOTER'S LEFT"),
                            e('div', { style: { fontSize: '0.65rem', color: 'var(--text-secondary)' } }, fmtPct(offScreenData.left?.pct || 0)),
                            e('div', { style: { display: 'flex', gap: '6px', marginTop: '4px', flexWrap: 'wrap' } },
                                e('span', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, 'PPP: ' + fmtPpp(offScreenData.left?.ppp || 0)),
                                e('span', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, 'eFG: ' + fmtPct(offScreenData.left?.efg || 0)),
                                e('span', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, 'TO: ' + fmtPct(offScreenData.left?.toPct || 0))
                            ),
                            // Cut types
                            offScreenData.left?.cuts && e('div', { style: { marginTop: '6px', paddingTop: '6px', borderTop: '1px solid rgba(255,255,255,0.1)' } },
                                e('div', { style: { fontSize: '0.5rem', color: 'var(--text-muted)', marginBottom: '2px' } }, 'CUT TYPE'),
                                e('div', { style: { display: 'flex', gap: '6px', fontSize: '0.5rem' } },
                                    e('span', { style: { color: 'var(--text-muted)' } }, 'Str: ' + fmtPct(offScreenData.left.cuts?.straight?.pct || 0)),
                                    e('span', { style: { color: 'var(--text-muted)' } }, 'Flr: ' + fmtPct(offScreenData.left.cuts?.flare?.pct || 0)),
                                    e('span', { style: { color: 'var(--text-muted)' } }, 'Crl: ' + fmtPct(offScreenData.left.cuts?.curl?.pct || 0))
                                )
                            )
                        ),
                        // Shooter's Right compact card
                        e('div', { 
                            style: { 
                                background: 'rgba(59,130,246,0.1)', 
                                borderRadius: '6px', 
                                padding: '8px',
                                border: '1px solid rgba(59,130,246,0.3)'
                            }
                        },
                            e('div', { style: { fontSize: '0.6rem', color: '#3b82f6', fontWeight: '600', marginBottom: '4px' } }, " SHOOTER'S RIGHT"),
                            e('div', { style: { fontSize: '0.65rem', color: 'var(--text-secondary)' } }, fmtPct(offScreenData.right?.pct || 0)),
                            e('div', { style: { display: 'flex', gap: '6px', marginTop: '4px', flexWrap: 'wrap' } },
                                e('span', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, 'PPP: ' + fmtPpp(offScreenData.right?.ppp || 0)),
                                e('span', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, 'eFG: ' + fmtPct(offScreenData.right?.efg || 0)),
                                e('span', { style: { fontSize: '0.55rem', color: 'var(--text-muted)' } }, 'TO: ' + fmtPct(offScreenData.right?.toPct || 0))
                            ),
                            // Cut types
                            offScreenData.right?.cuts && e('div', { style: { marginTop: '6px', paddingTop: '6px', borderTop: '1px solid rgba(255,255,255,0.1)' } },
                                e('div', { style: { fontSize: '0.5rem', color: 'var(--text-muted)', marginBottom: '2px' } }, 'CUT TYPE'),
                                e('div', { style: { display: 'flex', gap: '6px', fontSize: '0.5rem' } },
                                    e('span', { style: { color: 'var(--text-muted)' } }, 'Str: ' + fmtPct(offScreenData.right.cuts?.straight?.pct || 0)),
                                    e('span', { style: { color: 'var(--text-muted)' } }, 'Flr: ' + fmtPct(offScreenData.right.cuts?.flare?.pct || 0)),
                                    e('span', { style: { color: 'var(--text-muted)' } }, 'Crl: ' + fmtPct(offScreenData.right.cuts?.curl?.pct || 0))
                                )
                            )
                        )
                    )
                ),
                
                // DRIVES section - larger format
                spacingRadarMetrics && e('div', { 
                    style: { marginTop: '16px', paddingTop: '12px', borderTop: '1px solid rgba(255,255,255,0.1)' } 
                },
                    // SPOT UP DRIVES section
                    e('div', { 
                        style: { 
                            background: 'linear-gradient(135deg, rgba(249,115,22,0.15), rgba(249,115,22,0.05))', 
                            borderRadius: '10px', 
                            padding: '14px',
                            border: '1px solid rgba(249,115,22,0.4)',
                            marginBottom: '12px'
                        }
                    },
                        e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' } },
                            e('span', { style: { fontSize: '0.75rem', color: '#f97316', fontWeight: '700', letterSpacing: '0.5px' } }, ' SPOT UP DRIVES'),
                            e('span', { style: { fontSize: '1.4rem', fontWeight: '800', color: 'var(--text-primary)' } }, 
                                fmtPct(spacingRadarMetrics.spotUpDrivePct || 0))
                        ),
                        e('div', { style: { display: 'flex', gap: '16px', justifyContent: 'center' } },
                            e('div', { style: { textAlign: 'center' } },
                                e('div', { style: { fontSize: '1rem', fontWeight: '700', color: '#f97316' } }, 
                                    fmt(spacingRadarMetrics.spotUpDrives75 || 0, 1)),
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, 'DRIVE/75')
                            ),
                            e('div', { style: { textAlign: 'center' } },
                                e('div', { style: { fontSize: '1rem', fontWeight: '700', color: '#22d3ee' } }, 
                                    fmtPpp(spacingRadarMetrics.spotUpDrivesPPP || 0)),
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, 'DRIVE PPP')
                            )
                        )
                    )
                )
            ),
            
            // Center - Spacing Radar with Stats Table
            e('div', { className: 'scout-section-box', style: { display: 'flex', alignItems: 'flex-start', gap: '12px' } },
                // Stats Table (left)
                spacingRadarMetrics && e(RadarStatsTable, {
                    metrics: spacingRadarMetrics,
                    percentiles: spacingRadarPercentiles,
                    title: ' SPACING',
                    compact: true,
                    categories: [
                        { name: 'OVERALL', color: '#06b6d4', metricDefs: [
                            { key: 'spacingPct', label: 'Spacing%', format: 'pct' },
                            { key: 'spacingPPP', label: 'PPP', format: 'ppp' },
                            { key: 'spacingTOPct', label: 'TO%', format: 'pct' },
                            { key: 'spacingFtRate', label: 'FT Rate', format: 'pct' }
                        ]},
                        { name: 'SPOT-UP C&S', color: '#3b82f6', metricDefs: [
                            { key: 'spotUpCnS75', label: 'C&S/75', format: 'dec' },
                            { key: 'guardedPct', label: 'Guard%', format: 'pct' },
                            { key: 'guarded3Pct', label: 'Grd 3PT%', format: 'pct' },
                            { key: 'open3Pct', label: 'Open 3PT%', format: 'pct' },
                            { key: 'adjusted3Pct', label: 'Adj 3PT%', format: 'pct' }
                        ]},
                        { name: 'MOVING', color: '#a78bfa', metricDefs: [
                            { key: 'moving75', label: 'Mov/75', format: 'dec' },
                            { key: 'moving3Pct', label: 'Mov 3PT%', format: 'pct' }
                        ]},
                        { name: 'SPOT UP DRIVES', color: '#f472b6', metricDefs: [
                            { key: 'spotUpDrivePct', label: 'Drive%', format: 'pct' },
                            { key: 'spotUpDrives75', label: 'Drv/75', format: 'dec' },
                            { key: 'spotUpDrivesPPP', label: 'Drv PPP', format: 'ppp' }
                        ]},
                        { name: 'L vs R DRIVES', color: '#a78bfa', metricDefs: [
                            { key: 'spotUpDrivesLeftPct', label: 'Left%', format: 'pct' },
                            { key: 'spotUpDrivesLeftPPP', label: 'L PPP', format: 'ppp' },
                            { key: 'spotUpDrivesRightPct', label: 'Right%', format: 'pct' },
                            { key: 'spotUpDrivesRightPPP', label: 'R PPP', format: 'ppp' }
                        ]},
                        { name: 'OFF SCREEN', color: '#f97316', metricDefs: [
                            { key: 'offScreen75', label: 'OS/75', format: 'dec' },
                            { key: 'offScreenPPP', label: 'OS PPP', format: 'ppp' },
                            { key: 'offScreenDrivePct', label: 'OS Drv%', format: 'pct' }
                        ]},
                        { name: 'HANDOFFS', color: '#84cc16', metricDefs: [
                            { key: 'handoffs75', label: 'HO/75', format: 'dec' },
                            { key: 'handoffsPPP', label: 'HO PPP', format: 'ppp' },
                            { key: 'handoffsDrivePct', label: 'HO Drv%', format: 'pct' }
                        ]}
                    ]
                }),
                // Chart (right)
                spacingRadarMetrics ? e(SpacingRadarChart, { 
                    metrics: spacingRadarMetrics,
                    size: 480,
                    radarPercentiles: spacingRadarPercentiles,
                    fallbackSpacing75: radar1Metrics?.spacingVol75
                }) : e(PlaceholderRadar, { title: 'Spacing Radar' })
            ),
            
            // Right column - Left vs Right Hand
            e('div', { className: 'scout-section-box' },
                e('div', { className: 'scout-section-title' }, 'LEFT HAND VS RIGHT'),
                slashingData ? e('div', { className: 'hands-compact' },
                    e('div', { className: 'hand-compact' },
                        e('div', { 
                            className: 'hand-compact-icon',
                            style: { transform: 'scaleX(-1)' }
                        }, ''),
                        e('div', { className: 'hand-compact-label' }, 'LEFT'),
                        e('div', { 
                            className: `hand-compact-pct ${getPctClass(calcPercentile(slashingData.left?.ppp, pools?.ppp || [], true))}`
                        }, fmtPct(slashingData.left?.pct || 0)),
                        e('div', { 
                            className: 'hand-compact-per75',
                            style: {
                                fontSize: '0.75rem',
                                fontWeight: '600',
                                color: getPctClass(calcPercentile(slashingData.left?.ppp, pools?.ppp || [], true)) === 'pct-elite' ? '#22c55e' :
                                       getPctClass(calcPercentile(slashingData.left?.ppp, pools?.ppp || [], true)) === 'pct-good' ? '#4ade80' :
                                       getPctClass(calcPercentile(slashingData.left?.ppp, pools?.ppp || [], true)) === 'pct-above-avg' ? '#a3e635' :
                                       getPctClass(calcPercentile(slashingData.left?.ppp, pools?.ppp || [], true)) === 'pct-below-avg' ? '#fbbf24' :
                                       getPctClass(calcPercentile(slashingData.left?.ppp, pools?.ppp || [], true)) === 'pct-poor' ? '#ef4444' : 'var(--text-secondary)'
                            }
                        }, (calcPer75(slashingData.left?.poss) !== null ? fmt(calcPer75(slashingData.left?.poss), 1) : '-') + '/75'),
                        e('div', { className: 'hand-shot-types' },
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, 'eFG%'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.left?.efg || 0))
                            ),
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, 'FT Rate'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.left?.ftRate || 0))
                            ),
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, 'TO%'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.left?.toPct || 0))
                            )
                        ),
                        // Shot distribution for left hand
                        slashingData.left?.shotTypes && e('div', { 
                            className: 'hand-shot-dist',
                            style: { marginTop: '8px', paddingTop: '8px', borderTop: '1px solid rgba(255,255,255,0.1)' }
                        },
                            e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)', marginBottom: '4px' } }, 'SHOT DIST'),
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, 'Rim'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.left.shotTypes.rim?.pct || 0)),
                                e('span', { className: 'shot-type-ts', style: { fontSize: '0.6rem', fontWeight: '500', color: 'var(--text-secondary)', marginLeft: '4px' } }, fmtPct(slashingData.left.shotTypes.rim?.ts || 0) + ' TS')
                            ),
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, 'Mid'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.left.shotTypes.mid?.pct || 0)),
                                e('span', { className: 'shot-type-ts', style: { fontSize: '0.6rem', fontWeight: '500', color: 'var(--text-secondary)', marginLeft: '4px' } }, fmtPct(slashingData.left.shotTypes.mid?.ts || 0) + ' TS')
                            ),
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, '3PT'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.left.shotTypes.three?.pct || 0)),
                                e('span', { className: 'shot-type-ts', style: { fontSize: '0.6rem', fontWeight: '500', color: 'var(--text-secondary)', marginLeft: '4px' } }, fmtPct(slashingData.left.shotTypes.three?.ts || 0) + ' TS')
                            )
                        )
                    ),
                    e('div', { className: 'hand-compact' },
                        e('div', { className: 'hand-compact-icon' }, ''),
                        e('div', { className: 'hand-compact-label' }, 'RIGHT'),
                        e('div', { 
                            className: `hand-compact-pct ${getPctClass(calcPercentile(slashingData.right?.ppp, pools?.ppp || [], true))}`
                        }, fmtPct(slashingData.right?.pct || 0)),
                        e('div', { 
                            className: 'hand-compact-per75',
                            style: {
                                fontSize: '0.75rem',
                                fontWeight: '600',
                                color: getPctClass(calcPercentile(slashingData.right?.ppp, pools?.ppp || [], true)) === 'pct-elite' ? '#22c55e' :
                                       getPctClass(calcPercentile(slashingData.right?.ppp, pools?.ppp || [], true)) === 'pct-good' ? '#4ade80' :
                                       getPctClass(calcPercentile(slashingData.right?.ppp, pools?.ppp || [], true)) === 'pct-above-avg' ? '#a3e635' :
                                       getPctClass(calcPercentile(slashingData.right?.ppp, pools?.ppp || [], true)) === 'pct-below-avg' ? '#fbbf24' :
                                       getPctClass(calcPercentile(slashingData.right?.ppp, pools?.ppp || [], true)) === 'pct-poor' ? '#ef4444' : 'var(--text-secondary)'
                            }
                        }, (calcPer75(slashingData.right?.poss) !== null ? fmt(calcPer75(slashingData.right?.poss), 1) : '-') + '/75'),
                        e('div', { className: 'hand-shot-types' },
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, 'eFG%'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.right?.efg || 0))
                            ),
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, 'FT Rate'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.right?.ftRate || 0))
                            ),
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, 'TO%'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.right?.toPct || 0))
                            )
                        ),
                        // Shot distribution for right hand
                        slashingData.right?.shotTypes && e('div', { 
                            className: 'hand-shot-dist',
                            style: { marginTop: '8px', paddingTop: '8px', borderTop: '1px solid rgba(255,255,255,0.1)' }
                        },
                            e('div', { style: { fontSize: '0.55rem', color: 'var(--text-muted)', marginBottom: '4px' } }, 'SHOT DIST'),
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, 'Rim'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.right.shotTypes.rim?.pct || 0)),
                                e('span', { className: 'shot-type-ts', style: { fontSize: '0.6rem', fontWeight: '500', color: 'var(--text-secondary)', marginLeft: '4px' } }, fmtPct(slashingData.right.shotTypes.rim?.ts || 0) + ' TS')
                            ),
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, 'Mid'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.right.shotTypes.mid?.pct || 0)),
                                e('span', { className: 'shot-type-ts', style: { fontSize: '0.6rem', fontWeight: '500', color: 'var(--text-secondary)', marginLeft: '4px' } }, fmtPct(slashingData.right.shotTypes.mid?.ts || 0) + ' TS')
                            ),
                            e('div', { className: 'shot-type-row' },
                                e('span', { className: 'shot-type-label' }, '3PT'),
                                e('span', { className: 'shot-type-value' }, fmtPct(slashingData.right.shotTypes.three?.pct || 0)),
                                e('span', { className: 'shot-type-ts', style: { fontSize: '0.6rem', fontWeight: '500', color: 'var(--text-secondary)', marginLeft: '4px' } }, fmtPct(slashingData.right.shotTypes.three?.ts || 0) + ' TS')
                            )
                        )
                    )
                ) : e('div', { style: { color: 'var(--text-muted)', textAlign: 'center' } }, 'No drive data'),
                
                // L vs R DRIVES - stacked vertically, with dimming threshold based on drv/75 < 1
                spacingRadarMetrics && e('div', { 
                    style: { 
                        marginTop: '16px',
                        paddingTop: '12px',
                        borderTop: '1px solid rgba(255,255,255,0.1)'
                    }
                },
                    (() => {
                        // Use spotUpDrives75 from spacing radar metrics
                        const drv75 = spacingRadarMetrics.spotUpDrives75 || 0;
                        const leftPoss = spacingRadarMetrics._spotUpDrivesLeftPoss || 0;
                        const rightPoss = spacingRadarMetrics._spotUpDrivesRightPoss || 0;
                        const totalLRPoss = leftPoss + rightPoss;
                        const isDimmed = drv75 < 1;
                        const dimStyle = isDimmed ? { opacity: 0.4 } : {};
                        
                        // Don't show if no L/R drive data
                        if (totalLRPoss === 0) return null;
                        
                        return e('div', { 
                            style: { 
                                background: 'linear-gradient(135deg, rgba(244,63,94,0.15), rgba(59,130,246,0.15))', 
                                borderRadius: '10px', 
                                padding: '12px',
                                border: '1px solid rgba(167,139,250,0.4)',
                                ...dimStyle
                            }
                        },
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' } },
                                e('span', { style: { fontSize: '0.7rem', color: '#a78bfa', fontWeight: '700', letterSpacing: '0.5px' } }, ' L vs R SPOT-UP DRIVES'),
                                e('span', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, 
                                    fmt(drv75, 1) + ' DRV/75')
                            ),
                            // Stacked LEFT and RIGHT
                            e('div', { style: { display: 'flex', flexDirection: 'column', gap: '8px' } },
                                // LEFT drives
                                e('div', { 
                                    style: { 
                                        background: 'rgba(244,63,94,0.15)', 
                                        borderRadius: '8px', 
                                        padding: '10px', 
                                        borderLeft: '3px solid #f43f5e'
                                    }
                                },
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' } },
                                        e('div', { style: { fontSize: '0.65rem', color: '#f43f5e', fontWeight: '600' } }, ' LEFT'),
                                        e('div', { style: { display: 'flex', gap: '12px' } },
                                            e('div', { style: { textAlign: 'center' } },
                                                e('div', { style: { fontSize: '1rem', fontWeight: '700', fontFamily: 'JetBrains Mono' } }, 
                                                    fmtPct(spacingRadarMetrics.spotUpDrivesLeftPct || 0)),
                                                e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, '%')
                                            ),
                                            e('div', { style: { textAlign: 'center' } },
                                                e('div', { style: { fontSize: '1rem', fontWeight: '700', fontFamily: 'JetBrains Mono', color: '#22d3ee' } }, 
                                                    fmtPpp(spacingRadarMetrics.spotUpDrivesLeftPPP || 0)),
                                                e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, 'PPP')
                                            )
                                        )
                                    )
                                ),
                                // RIGHT drives
                                e('div', { 
                                    style: { 
                                        background: 'rgba(59,130,246,0.15)', 
                                        borderRadius: '8px', 
                                        padding: '10px', 
                                        borderLeft: '3px solid #3b82f6'
                                    }
                                },
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' } },
                                        e('div', { style: { fontSize: '0.65rem', color: '#3b82f6', fontWeight: '600' } }, 'RIGHT '),
                                        e('div', { style: { display: 'flex', gap: '12px' } },
                                            e('div', { style: { textAlign: 'center' } },
                                                e('div', { style: { fontSize: '1rem', fontWeight: '700', fontFamily: 'JetBrains Mono' } }, 
                                                    fmtPct(spacingRadarMetrics.spotUpDrivesRightPct || 0)),
                                                e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, '%')
                                            ),
                                            e('div', { style: { textAlign: 'center' } },
                                                e('div', { style: { fontSize: '1rem', fontWeight: '700', fontFamily: 'JetBrains Mono', color: '#22d3ee' } }, 
                                                    fmtPpp(spacingRadarMetrics.spotUpDrivesRightPPP || 0)),
                                                e('div', { style: { fontSize: '0.45rem', color: 'var(--text-muted)' } }, 'PPP')
                                            )
                                        )
                                    )
                                )
                            )
                        );
                    })()
                ),
                
                // CATCH & SHOOT section - stacked layout
                spacingRadarMetrics && e('div', { 
                    style: { 
                        marginTop: '16px',
                        paddingTop: '12px',
                        borderTop: '1px solid rgba(255,255,255,0.1)'
                    }
                },
                    e('div', { 
                        style: { 
                            background: 'linear-gradient(135deg, rgba(59,130,246,0.15), rgba(59,130,246,0.05))', 
                            borderRadius: '10px', 
                            padding: '12px',
                            border: '1px solid rgba(59,130,246,0.4)',
                            marginBottom: '10px'
                        }
                    },
                        e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' } },
                            e('span', { style: { fontSize: '0.7rem', color: '#3b82f6', fontWeight: '700', letterSpacing: '0.5px' } }, ' CATCH & SHOOT'),
                            e('span', { style: { fontSize: '1.1rem', fontWeight: '700', color: 'var(--text-primary)' } }, 
                                fmt(spacingRadarMetrics.spotUpCnS75 || 0, 1) + '/75')
                        ),
                        // Stacked guarded/open 3PT%
                        e('div', { style: { display: 'flex', flexDirection: 'column', gap: '8px' } },
                            e('div', { 
                                style: { 
                                    textAlign: 'center', 
                                    padding: '10px',
                                    background: 'rgba(239,68,68,0.1)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(239,68,68,0.3)'
                                }
                            },
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)', marginBottom: '4px' } }, 'GUARDED 3PT%'),
                                e('div', { 
                                    style: { 
                                        fontSize: '1.3rem', 
                                        fontWeight: '800',
                                        color: (spacingRadarMetrics.guarded3Pct || 0) >= 40 ? '#22c55e' :
                                               (spacingRadarMetrics.guarded3Pct || 0) >= 37 ? '#84cc16' :
                                               (spacingRadarMetrics.guarded3Pct || 0) >= 34 ? '#fbbf24' :
                                               (spacingRadarMetrics.guarded3Pct || 0) >= 30 ? '#fb923c' : '#ef4444'
                                    }
                                }, fmtPct(spacingRadarMetrics.guarded3Pct || 0))
                            ),
                            e('div', { 
                                style: { 
                                    textAlign: 'center', 
                                    padding: '10px',
                                    background: 'rgba(34,197,94,0.1)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(34,197,94,0.3)'
                                }
                            },
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)', marginBottom: '4px' } }, 'OPEN 3PT%'),
                                e('div', { 
                                    style: { 
                                        fontSize: '1.3rem', 
                                        fontWeight: '800',
                                        color: (spacingRadarMetrics.open3Pct || 0) >= 40 ? '#22c55e' :
                                               (spacingRadarMetrics.open3Pct || 0) >= 37 ? '#84cc16' :
                                               (spacingRadarMetrics.open3Pct || 0) >= 34 ? '#fbbf24' :
                                               (spacingRadarMetrics.open3Pct || 0) >= 30 ? '#fb923c' : '#ef4444'
                                    }
                                }, fmtPct(spacingRadarMetrics.open3Pct || 0))
                            )
                        )
                    ),
                    
                    // DRIVE TENDENCY section
                    e('div', { 
                        style: { 
                            background: 'linear-gradient(135deg, rgba(168,85,247,0.15), rgba(168,85,247,0.05))', 
                            borderRadius: '10px', 
                            padding: '12px',
                            border: '1px solid rgba(168,85,247,0.4)'
                        }
                    },
                        e('div', { style: { fontSize: '0.7rem', color: '#a855f7', fontWeight: '700', marginBottom: '10px', letterSpacing: '0.5px' } }, ' DRIVE TENDENCY'),
                        e('div', { style: { display: 'flex', gap: '12px', justifyContent: 'space-around' } },
                            e('div', { style: { textAlign: 'center', flex: 1 } },
                                e('div', { style: { fontSize: '1.2rem', fontWeight: '800', color: '#06b6d4' } }, 
                                    fmtPct(spacingRadarMetrics.offScreenDrivePct || 0)),
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, 'OFF SCREEN')
                            ),
                            e('div', { style: { textAlign: 'center', flex: 1 } },
                                e('div', { style: { fontSize: '1.2rem', fontWeight: '800', color: '#facc15' } }, 
                                    fmtPct(spacingRadarMetrics.handoffsDrivePct || 0)),
                                e('div', { style: { fontSize: '0.6rem', color: 'var(--text-muted)' } }, 'HANDOFFS')
                            )
                        )
                    )
                )
            )
        ))), // Close scout-section-row, scout-section-content, scout-collapsible-section
        
        // ========== FINISHING SECTION (COLLAPSIBLE) ==========
        e('div', { id: 'section-finishing', className: 'scout-collapsible-section', style: { position: 'relative' } },
            // Camera button
            e(CameraButton, { 
                onClick: () => openScreenshotModal('finishing', 'FINISHING BREAKDOWN', 'section-finishing', {
                    playerName: playerData.playerName,
                    playerTeam: playerData.team,
                    playerRole: playerRoleInfo?.role?.name
                }),
                style: { top: '8px', right: '8px' }
            }),
            // Collapsible Header
            e('div', { 
                className: 'scout-section-header',
                onClick: () => setFinishingCollapsed(!finishingCollapsed)
            },
                e('div', { className: 'scout-section-header-title finishing' },
                    e('span', null, ''),
                    e('span', null, 'FINISHING')
                ),
                e('div', { className: 'scout-section-header-stats' },
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'FINISHING%'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#facc15' } }, 
                            fmtPct(finishingRadarMetrics?.finishingPct || radar1Metrics?.finishingPct || 0))
                    ),
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'PPP'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#22d3ee' } }, 
                            fmtPpp(finishingRadarMetrics?.finishingPPP || radar1Metrics?.finishingPPP || 0))
                    ),
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'FINISHING/75'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#a78bfa' } }, 
                            fmt(radar1Metrics?.finishingVol75 || 0, 1))
                    )
                ),
                e('div', { className: 'scout-section-toggle' },
                    e('span', null, finishingCollapsed ? 'Expand' : 'Collapse'),
                    e('span', { className: `scout-section-toggle-icon ${finishingCollapsed ? '' : 'expanded'}` }, '')
                )
            ),
            // Collapsible Content
            e('div', { className: `scout-section-content ${finishingCollapsed ? '' : 'expanded'}` },
                e('div', { className: 'scout-section-row' },
                    // Left column - Bar Chart
                    e('div', { className: 'scout-section-box' },
                        e('div', { className: 'scout-section-title' }, 'FINISHING'),
                        e('div', { className: 'scout-section-subtitle' }, '% OF TOTAL POSS.'),
                        e(ScoutBarChart, {
                    data: [
                        { label: 'CUT', value: playerData.playTypeStats['Cut']?.pctOfPoss || 0, color: 'red' },
                        { label: 'ROLL', value: playerData.playTypeStats['P&R Roll Man']?.pctOfPoss || 0, color: 'yellow' },
                        { label: 'OREB', value: playerData.playTypeStats['Offensive Rebounds (Put Backs)']?.pctOfPoss || 0, color: 'green' }
                    ]
                }),
                
                // Finishing play type breakdown
                finishingRadarMetrics && e('div', { 
                    style: { marginTop: '16px', paddingTop: '12px', borderTop: '1px solid rgba(255,255,255,0.1)' } 
                },
                    e('div', { className: 'scout-section-subtitle', style: { marginBottom: '8px' } }, 'PLAY TYPE DETAILS'),
                    e('div', { style: { display: 'flex', flexDirection: 'column', gap: '6px' } },
                        // Cut breakdown
                        e('div', { 
                            style: { 
                                background: 'rgba(34,197,94,0.1)', 
                                borderRadius: '6px', 
                                padding: '8px',
                                border: '1px solid rgba(34,197,94,0.3)'
                            }
                        },
                            e('div', { style: { fontSize: '0.6rem', color: '#34d399', fontWeight: '600', marginBottom: '4px' } }, ' CUTS'),
                            e('div', { style: { display: 'flex', gap: '8px', fontSize: '0.55rem', flexWrap: 'wrap' } },
                                e('span', { style: { color: 'var(--text-muted)' } }, 'PPP: ' + fmtPpp(finishingRadarMetrics.selfCutPPP || 0)),
                                e('span', { style: { color: 'var(--text-muted)' } }, 'Per75: ' + fmt(finishingRadarMetrics.selfCut75, 1)),
                                e('span', { style: { color: 'var(--text-muted)' } }, 'TO: ' + fmtPct(finishingRadarMetrics.selfCutTOPct || 0))
                            )
                        ),
                        // P&R Roll Man breakdown
                        e('div', { 
                            style: { 
                                background: 'rgba(249,115,22,0.1)', 
                                borderRadius: '6px', 
                                padding: '8px',
                                border: '1px solid rgba(249,115,22,0.3)'
                            }
                        },
                            e('div', { style: { fontSize: '0.6rem', color: '#f97316', fontWeight: '600', marginBottom: '4px' } }, ' P&R ROLL MAN'),
                            e('div', { style: { display: 'flex', gap: '8px', fontSize: '0.55rem', flexWrap: 'wrap' } },
                                e('span', { style: { color: 'var(--text-muted)' } }, 'Rolls: ' + fmt(finishingRadarMetrics.rolls75, 1) + '/75'),
                                e('span', { style: { color: 'var(--text-muted)' } }, 'Pops: ' + fmt(finishingRadarMetrics.pops75, 1) + '/75')
                            ),
                            e('div', { style: { display: 'flex', gap: '8px', fontSize: '0.55rem', flexWrap: 'wrap', marginTop: '2px' } },
                                e('span', { style: { color: 'var(--text-muted)' } }, 'Roll PPP: ' + fmtPpp(finishingRadarMetrics.rollsPPP || 0)),
                                e('span', { style: { color: 'var(--text-muted)' } }, 'Pop PPP: ' + fmtPpp(finishingRadarMetrics.popsPPP || 0))
                            )
                        ),
                        // Putbacks breakdown
                        e('div', { 
                            style: { 
                                background: 'rgba(244,114,182,0.1)', 
                                borderRadius: '6px', 
                                padding: '8px',
                                border: '1px solid rgba(244,114,182,0.3)'
                            }
                        },
                            e('div', { style: { fontSize: '0.6rem', color: '#f472b6', fontWeight: '600', marginBottom: '4px' } }, ' PUT BACKS'),
                            e('div', { style: { display: 'flex', gap: '8px', fontSize: '0.55rem', flexWrap: 'wrap' } },
                                e('span', { style: { color: 'var(--text-muted)' } }, 'Per75: ' + fmt(finishingRadarMetrics.putbacks75, 1)),
                                e('span', { style: { color: 'var(--text-muted)' } }, 'Poss: ' + (finishingRadarMetrics._putbacksPoss || 0))
                            )
                        )
                    )
                ),
                
                // P&R Roll Man Overall Breakdown - LARGER FORMAT
                finishingRadarMetrics && e('div', { 
                    style: { marginTop: '16px', paddingTop: '12px', borderTop: '1px solid rgba(255,255,255,0.1)' } 
                },
                    e('div', { 
                        style: { 
                            background: 'linear-gradient(135deg, rgba(250,204,21,0.15), rgba(250,204,21,0.05))', 
                            borderRadius: '12px', 
                            padding: '16px',
                            border: '1px solid rgba(250,204,21,0.4)'
                        }
                    },
                        e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' } },
                            e('span', { style: { fontSize: '0.8rem', color: '#facc15', fontWeight: '700', letterSpacing: '0.5px' } }, ' P&R ROLL MAN'),
                            e('span', { style: { fontSize: '1.5rem', fontWeight: '800', color: 'var(--text-primary)' } }, 
                                fmt(finishingRadarMetrics.rollMan75 || 0, 1) + '/75')
                        ),
                        e('div', { style: { fontSize: '0.7rem', color: 'var(--text-muted)', marginBottom: '10px', textAlign: 'center' } }, 'TENDENCY BREAKDOWN'),
                        e('div', { style: { display: 'flex', flexDirection: 'column', gap: '8px' } },
                            e('div', { 
                                style: { 
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    padding: '10px 14px',
                                    background: 'rgba(249,115,22,0.15)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(249,115,22,0.3)'
                                }
                            },
                                e('div', { style: { fontSize: '0.7rem', color: 'var(--text-muted)' } }, 'ROLLS'),
                                e('div', { style: { fontSize: '1.3rem', fontWeight: '800', color: '#f97316' } }, 
                                    fmtPct(finishingRadarMetrics.rollsOfRollMan || 0))
                            ),
                            e('div', { 
                                style: { 
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    padding: '10px 14px',
                                    background: 'rgba(168,85,247,0.15)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(168,85,247,0.3)'
                                }
                            },
                                e('div', { style: { fontSize: '0.7rem', color: 'var(--text-muted)' } }, 'POPS'),
                                e('div', { style: { fontSize: '1.3rem', fontWeight: '800', color: '#a855f7' } }, 
                                    fmtPct(finishingRadarMetrics.popsOfRollMan || 0))
                            ),
                            e('div', { 
                                style: { 
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    padding: '10px 14px',
                                    background: 'rgba(34,197,94,0.15)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(34,197,94,0.3)'
                                }
                            },
                                e('div', { style: { fontSize: '0.7rem', color: 'var(--text-muted)' } }, 'SLIPS'),
                                e('div', { style: { fontSize: '1.3rem', fontWeight: '800', color: '#22c55e' } }, 
                                    fmtPct(finishingRadarMetrics.slipsOfRollMan || 0))
                            )
                        )
                    )
                )
            ),
            
            // Center - Finishing Radar with Stats Table
            e('div', { className: 'scout-section-box', style: { display: 'flex', alignItems: 'flex-start', gap: '12px' } },
                // Stats Table (left)
                finishingRadarMetrics && e(RadarStatsTable, {
                    metrics: finishingRadarMetrics,
                    percentiles: finishingRadarPercentiles,
                    title: ' FINISHING',
                    compact: true,
                    categories: [
                        { name: 'OVERALL', color: '#facc15', metricDefs: [
                            { key: 'finishingPct', label: 'Finish%', format: 'pct' },
                            { key: 'finishingPPP', label: 'PPP', format: 'ppp' },
                            { key: 'finishingTOPct', label: 'TO%', format: 'pct' },
                            { key: 'finishingFtRate', label: 'FT Rate', format: 'pct' }
                        ]},
                        { name: 'P&R ROLLS', color: '#f97316', metricDefs: [
                            { key: 'rolls75', label: 'Rolls/75', format: 'dec' },
                            { key: 'rollsPPP', label: 'Rolls PPP', format: 'ppp' },
                            { key: 'rollsFtRate', label: 'Rolls FT', format: 'pct' },
                            { key: 'rollsTOPct', label: 'Rolls TO%', format: 'pct' }
                        ]},
                        { name: 'P&R POPS', color: '#a78bfa', metricDefs: [
                            { key: 'pops75', label: 'Pops/75', format: 'dec' },
                            { key: 'popsPPP', label: 'Pops PPP', format: 'ppp' }
                        ]},
                        { name: 'SELF CUTS', color: '#34d399', metricDefs: [
                            { key: 'selfCut75', label: 'Cut/75', format: 'dec' },
                            { key: 'selfCutPPP', label: 'Cut PPP', format: 'ppp' },
                            { key: 'selfCutTOPct', label: 'Cut TO%', format: 'pct' }
                        ]},
                        { name: 'PUT BACKS', color: '#f472b6', metricDefs: [
                            { key: 'putbacks75', label: 'Putback/75', format: 'dec' }
                        ]}
                    ]
                }),
                // Chart (right)
                finishingRadarMetrics ? e(FinishingRadarChart, { 
                    metrics: finishingRadarMetrics,
                    size: 480,
                    radarPercentiles: finishingRadarPercentiles,
                    fallbackFinishing75: radar1Metrics?.finishingVol75
                }) : e(PlaceholderRadar, { title: 'Finishing Radar' })
            ),
            
            // Right column - Poss Based Stats
            e('div', { className: 'scout-section-box' },
                e('div', { className: 'scout-section-title' }, 'POSS. BASED STATS'),
                e('div', { className: 'scout-section-subtitle' }, '& % OF TEAM STATS'),
                e('div', { style: { fontSize: '0.75rem' } },
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px' } },
                        e('span', { style: { color: 'var(--text-muted)' } }, 'Usage%'),
                        e('span', { style: { fontFamily: 'JetBrains Mono' } }, fmtPct(matchedPoss?.usagePct || 0))
                    ),
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px' } },
                        e('span', { style: { color: 'var(--text-muted)' } }, 'Team Poss'),
                        e('span', { style: { fontFamily: 'JetBrains Mono' } }, matchedPoss?.totalTeamPoss || 0)
                    ),
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px' } },
                        e('span', { style: { color: 'var(--text-muted)' } }, 'Player Poss'),
                        e('span', { style: { fontFamily: 'JetBrains Mono' } }, matchedPoss?.totalPlayerPoss || 0)
                    ),
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px' } },
                        e('span', { style: { color: 'var(--text-muted)' } }, 'Player Min'),
                        e('span', { style: { fontFamily: 'JetBrains Mono' } }, 
                            matchedPoss?.totalPlayerMin != null ? matchedPoss.totalPlayerMin.toFixed(2) : '-')
                    ),
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '8px', paddingBottom: '8px', borderBottom: '1px solid var(--border-subtle)' } },
                        e('span', { style: { color: 'var(--text-muted)' } }, 'Games'),
                        e('span', { style: { fontFamily: 'JetBrains Mono' } }, matchedPoss?.games || playerData.totalGames || 0)
                    ),
                    // Per-75 Stats
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px' } },
                        e('span', { style: { color: 'var(--text-muted)' } }, 'AST%'),
                        e('span', { style: { fontFamily: 'JetBrains Mono', color: 'var(--accent-indigo)' } }, 
                            matchedPoss?.astPct != null ? matchedPoss.astPct.toFixed(1) + '%' : '-')
                    ),
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px' } },
                        e('span', { style: { color: 'var(--text-muted)' } }, 'TO%'),
                        e('span', { style: { fontFamily: 'JetBrains Mono', color: 'var(--accent-rose)' } }, 
                            matchedPoss?.toPct != null ? matchedPoss.toPct.toFixed(1) + '%' : '-')
                    ),
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px' } },
                        e('span', { style: { color: 'var(--text-muted)' } }, 'STL/75'),
                        e('span', { style: { fontFamily: 'JetBrains Mono', color: 'var(--accent-emerald)' } }, 
                            matchedPoss?.stl75 != null ? matchedPoss.stl75.toFixed(1) : '-')
                    ),
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px' } },
                        e('span', { style: { color: 'var(--text-muted)' } }, 'BLK/75'),
                        e('span', { style: { fontFamily: 'JetBrains Mono', color: 'var(--accent-emerald)' } }, 
                            matchedPoss?.blk75 != null ? matchedPoss.blk75.toFixed(1) : '-')
                    ),
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '4px' } },
                        e('span', { style: { color: 'var(--text-muted)' } }, 'OREB/75'),
                        e('span', { style: { fontFamily: 'JetBrains Mono', color: 'var(--accent-amber)' } }, 
                            matchedPoss?.oreb75 != null ? matchedPoss.oreb75.toFixed(1) : '-')
                    ),
                    e('div', { style: { display: 'flex', justifyContent: 'space-between' } },
                        e('span', { style: { color: 'var(--text-muted)' } }, 'DREB/75'),
                        e('span', { style: { fontFamily: 'JetBrains Mono', color: 'var(--accent-blue)' } }, 
                            matchedPoss?.dreb75 != null ? matchedPoss.dreb75.toFixed(1) : '-')
                    )
                )
            )
        ))), // Close scout-section-row, scout-section-content, scout-collapsible-section
        
        // ========== DEFENSE SECTION (COLLAPSIBLE) ==========
        e('div', { id: 'section-defense', className: 'scout-collapsible-section', style: { position: 'relative' } },
            // Camera button
            e(CameraButton, { 
                onClick: () => openScreenshotModal('defense', 'DEFENSE BREAKDOWN', 'section-defense', {
                    playerName: playerData.playerName,
                    playerTeam: playerData.team,
                    playerRole: playerRoleInfo?.role?.name
                }),
                style: { top: '8px', right: '8px' }
            }),
            // Collapsible Header
            e('div', { 
                className: 'scout-section-header',
                onClick: () => setDefenseCollapsed(!defenseCollapsed)
            },
                e('div', { className: 'scout-section-header-title defense' },
                    e('span', null, ''),
                    e('span', null, 'DEFENSE')
                ),
                e('div', { className: 'scout-section-header-stats' },
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'ON-BALL DEF/75'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#ef4444' } }, 
                            fmt(defenseRadarMetrics?.onBallDef75 || radar1Metrics?.onBallDef75 || 0, 1))
                    ),
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'DEF PPP'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#22d3ee' } }, 
                            fmtPpp(defenseRadarMetrics?.onBallDefPPP || radar1Metrics?.onBallDefPPP || 0))
                    ),
                    e('div', { className: 'scout-section-header-stat' },
                        e('span', { className: 'scout-section-header-stat-label' }, 'DEF TO%'),
                        e('span', { className: 'scout-section-header-stat-value', style: { color: '#22c55e' } }, 
                            fmtPct(defenseRadarMetrics?.defTOPct || radar1Metrics?.defTOPct || 0))
                    )
                ),
                e('div', { className: 'scout-section-toggle' },
                    e('span', null, defenseCollapsed ? 'Expand' : 'Collapse'),
                    e('span', { className: `scout-section-toggle-icon ${defenseCollapsed ? '' : 'expanded'}` }, '')
                )
            ),
            // Collapsible Content
            e('div', { className: `scout-section-content ${defenseCollapsed ? '' : 'expanded'}` },
                e('div', { className: 'scout-section-row', style: { gridTemplateColumns: '1fr 300px' } },
                    // Center - Defense Radar with Stats Table
                    e('div', { className: 'scout-section-box', style: { display: 'flex', alignItems: 'flex-start', gap: '12px' } },
                        // Stats Table (left)
                        defenseRadarMetrics && e(RadarStatsTable, {
                            metrics: defenseRadarMetrics,
                            percentiles: defenseRadarPercentiles,
                            title: ' DEFENSE',
                            compact: true,
                            categories: [
                                { name: 'ON-BALL DEF', color: '#ef4444', metricDefs: [
                                    { key: 'onBallDef75', label: 'OnBall/75', format: 'dec' },
                                    { key: 'onBallDefPPP', label: 'OnBall PPP', format: 'ppp' },
                                    { key: 'onBallDefTOPct', label: 'OnBall TO%', format: 'pct' },
                                    { key: 'onBallDefFtRate', label: 'OnBall FT', format: 'pct' }
                                ]},
                                { name: 'P&R DEF', color: '#f97316', metricDefs: [
                                    { key: 'pnrDef75', label: 'P&R/75', format: 'dec' },
                                    { key: 'pnrDefPPP', label: 'P&R PPP', format: 'ppp' },
                                    { key: 'pnrDefTOPct', label: 'P&R TO%', format: 'pct' },
                                    { key: 'pnrDefFtRate', label: 'P&R FT', format: 'pct' }
                                ]},
                                { name: 'DRIVES DEF', color: '#eab308', metricDefs: [
                                    { key: 'drivesDef75', label: 'Drives/75', format: 'dec' },
                                    { key: 'drivesDefPPP', label: 'Drives PPP', format: 'ppp' },
                                    { key: 'drivesDefTOPct', label: 'Drives TO%', format: 'pct' },
                                    { key: 'drivesDefFtRate', label: 'Drives FT', format: 'pct' }
                                ]},
                                { name: 'POST DEF', color: '#22c55e', metricDefs: [
                                    { key: 'postDef75', label: 'Post/75', format: 'dec' },
                                    { key: 'postDefPPP', label: 'Post PPP', format: 'ppp' },
                                    { key: 'postDefTOPct', label: 'Post TO%', format: 'pct' },
                                    { key: 'postDefFtRate', label: 'Post FT', format: 'pct' }
                                ]},
                                { name: 'BOX SCORE', color: '#06b6d4', metricDefs: [
                                    { key: 'stl75', label: 'STL/75', format: 'dec' },
                                    { key: 'blk75', label: 'BLK/75', format: 'dec' }
                                ]}
                            ]
                        }),
                        // Chart (right)
                        defenseRadarMetrics ? e(DefenseRadarChart, { 
                            metrics: defenseRadarMetrics,
                            size: 480,
                            radarPercentiles: defenseRadarPercentiles,
                            fallbackDef75: radar1Metrics?.onBallDef75
                        }) : e(PlaceholderRadar, { title: 'Defense Radar' })
                    ),
                    
                    // Right column - Box Score Defense
                    e('div', { className: 'scout-section-box' },
                        e('div', { className: 'scout-section-title' }, 'BOX SCORE DEFENSE'),
                        e('div', { style: { fontSize: '0.75rem' } },
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '8px', paddingBottom: '8px', borderBottom: '1px solid var(--border-subtle)' } },
                                e('span', { style: { color: 'var(--text-muted)' } }, 'STL/75'),
                                e('span', { style: { fontFamily: 'JetBrains Mono', color: 'var(--accent-emerald)', fontSize: '1rem', fontWeight: '700' } }, 
                                    defenseRadarMetrics?.stl75 != null ? defenseRadarMetrics.stl75.toFixed(1) : 
                                    matchedPoss?.stl75 != null ? matchedPoss.stl75.toFixed(1) : '-')
                            ),
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '8px', paddingBottom: '8px', borderBottom: '1px solid var(--border-subtle)' } },
                                e('span', { style: { color: 'var(--text-muted)' } }, 'BLK/75'),
                                e('span', { style: { fontFamily: 'JetBrains Mono', color: 'var(--accent-blue)', fontSize: '1rem', fontWeight: '700' } }, 
                                    defenseRadarMetrics?.blk75 != null ? defenseRadarMetrics.blk75.toFixed(1) : 
                                    matchedPoss?.blk75 != null ? matchedPoss.blk75.toFixed(1) : '-')
                            ),
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '8px', paddingBottom: '8px', borderBottom: '1px solid var(--border-subtle)' } },
                                e('span', { style: { color: 'var(--text-muted)' } }, 'DREB/75'),
                                e('span', { style: { fontFamily: 'JetBrains Mono', color: 'var(--accent-amber)', fontSize: '1rem', fontWeight: '700' } }, 
                                    matchedPoss?.dreb75 != null ? matchedPoss.dreb75.toFixed(1) : '-')
                            ),
                            
                            // Defense Detail Cards
                            e('div', { className: 'scout-section-subtitle', style: { marginTop: '12px', marginBottom: '8px' } }, 'DEFENSE BREAKDOWN'),
                            defenseRadarMetrics && e('div', { style: { display: 'flex', flexDirection: 'column', gap: '6px' } },
                                // P&R Defense
                                e('div', { 
                                    style: { 
                                        background: 'rgba(249,115,22,0.1)', 
                                        borderRadius: '6px', 
                                        padding: '8px',
                                        border: '1px solid rgba(249,115,22,0.3)'
                                    }
                                },
                                    e('div', { style: { fontSize: '0.6rem', color: '#f97316', fontWeight: '600', marginBottom: '4px' } }, ' P&R DEFENSE'),
                                    e('div', { style: { display: 'flex', gap: '8px', fontSize: '0.55rem', flexWrap: 'wrap' } },
                                        e('span', { style: { color: 'var(--text-muted)' } }, 'Per75: ' + fmt(defenseRadarMetrics.pnrDef75, 1)),
                                        e('span', { style: { color: 'var(--text-muted)' } }, 'PPP: ' + fmtPpp(defenseRadarMetrics.pnrDefPPP || 0)),
                                        e('span', { style: { color: 'var(--text-muted)' } }, 'TO: ' + fmtPct(defenseRadarMetrics.pnrDefTOPct || 0))
                                    )
                                ),
                                // Post Defense
                                e('div', { 
                                    style: { 
                                        background: 'rgba(34,197,94,0.1)', 
                                        borderRadius: '6px', 
                                        padding: '8px',
                                        border: '1px solid rgba(34,197,94,0.3)'
                                    }
                                },
                                    e('div', { style: { fontSize: '0.6rem', color: '#22c55e', fontWeight: '600', marginBottom: '4px' } }, ' POST DEFENSE'),
                                    e('div', { style: { display: 'flex', gap: '8px', fontSize: '0.55rem', flexWrap: 'wrap' } },
                                        e('span', { style: { color: 'var(--text-muted)' } }, 'Per75: ' + fmt(defenseRadarMetrics.postDef75, 1)),
                                        e('span', { style: { color: 'var(--text-muted)' } }, 'PPP: ' + fmtPpp(defenseRadarMetrics.postDefPPP || 0)),
                                        e('span', { style: { color: 'var(--text-muted)' } }, 'TO: ' + fmtPct(defenseRadarMetrics.postDefTOPct || 0))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        // ========== SCOUT NOTES SECTION ==========
        e('div', { className: 'scout-notes-section' },
            e('div', { className: 'scout-notes-title' }, 'SCOUT REPORT NOTES'),
            e('textarea', {
                className: 'scout-notes-textarea',
                placeholder: 'Enter scout notes here...',
                value: scoutNotes,
                onChange: (ev) => setScoutNotes(ev.target.value)
            })
        )
    );
}

// ============================================
// PROFILES TAB COMPONENT
// ============================================

function ProfilesTab({ radarScalesData, offenseData, defenseData, onPlayerSelect, selectedPlayer, selectedSeasons, teamUtilitiesData, playerUtilitiesData, useDuplicateData }) {
    const [filtersExpanded, setFiltersExpanded] = useState(false);
    const [selectedSection, setSelectedSection] = useState('main');
    const [minPoss, setMinPoss] = useState(50);
    const [sortConfig, setSortConfig] = useState({ key: 'totalPPP', direction: 'desc' });
    const [collapsedCategories, setCollapsedCategories] = useState(new Set());
    const [statFilters, setStatFilters] = useState({});
    
    // Independent season filter for ProfilesTab (not affected by main player selection)
    const [profilesSeasonFilter, setProfilesSeasonFilter] = useState('all'); // 'all' or specific season
    
    // Get all available seasons from the precomputed data
    const allAvailableSeasons = useMemo(() => {
        if (!radarScalesData?.allRadarMetrics) return [];
        const seasons = [...new Set(radarScalesData.allRadarMetrics.map(p => p.season))].filter(s => s);
        return seasons.sort();
    }, [radarScalesData]);
    
    // Determine which seasons to filter by for ProfilesTab
    const effectiveSeasonFilter = useMemo(() => {
        if (profilesSeasonFilter === 'all') {
            return null; // No filter - show all
        }
        return [profilesSeasonFilter]; // Single season selected
    }, [profilesSeasonFilter]);
    
    // Define all metric categories by section
    const sectionDefinitions = {
        main: {
            name: 'Main',
            icon: '',
            categories: [
                { name: 'OVERALL', color: '#818cf8', metrics: [
                    { key: 'totalPPP', label: 'PPP', format: 'ppp' },
                    { key: 'tsPct', label: 'TS%', format: 'pct' },
                    { key: 'ftRate', label: 'FT Rate', format: 'pct' },
                    { key: 'usagePct', label: 'Usage%', format: 'pct' }
                ]},
                { name: 'CREATION', color: '#f472b6', metrics: [
                    { key: 'onBallVol75', label: 'Creat/75', format: 'dec' },
                    { key: 'onBallPPP', label: 'Creat PPP', format: 'ppp' },
                    { key: 'onBallPct', label: 'OnBall%', format: 'pct' },
                    { key: 'rimPressure', label: 'RimPress', format: 'int' },
                    { key: 'onBallPassPct', label: 'Pass%', format: 'pct' }
                ]},
                { name: 'PLAYMAKING', color: '#a78bfa', metrics: [
                    { key: 'astUsgRatio', label: 'AST/USG', format: 'dec' },
                    { key: 'toPct', label: 'TO%', format: 'pct', inverse: true }
                ]},
                { name: 'SPACING', color: '#22d3ee', metrics: [
                    { key: 'shootingValue', label: 'Shot Val', format: 'int' },
                    { key: 'fg3Att75', label: '3PA/75', format: 'dec' },
                    { key: 'spacingVol75', label: 'Space/75', format: 'dec' },
                    { key: 'spacingPPP', label: 'Space PPP', format: 'ppp' }
                ]},
                { name: 'SLASHING', color: '#fb923c', metrics: [
                    { key: 'drives75', label: 'Drv/75', format: 'dec' },
                    { key: 'drivesPPP', label: 'Drv PPP', format: 'ppp' }
                ]},
                { name: 'FINISHING', color: '#facc15', metrics: [
                    { key: 'finishingVol75', label: 'Fin/75', format: 'dec' },
                    { key: 'finishingPPP', label: 'Fin PPP', format: 'ppp' }
                ]},
                { name: 'PERIMETER D', color: '#34d399', metrics: [
                    { key: 'onBallDef75', label: 'OnBD/75', format: 'dec' },
                    { key: 'onBallDefPPP', label: 'OnBD PPP', format: 'ppp', inverse: true }
                ]},
                { name: 'POST D', color: '#4ade80', metrics: [
                    { key: 'postDef75', label: 'PostD/75', format: 'dec' },
                    { key: 'postDefPPP', label: 'PostD PPP', format: 'ppp', inverse: true }
                ]},
                { name: 'DISRUPTION', color: '#f87171', metrics: [
                    { key: 'defTOPct', label: 'DefTO%', format: 'pct' },
                    { key: 'stl75', label: 'STL/75', format: 'dec' },
                    { key: 'blk75', label: 'BLK/75', format: 'dec' }
                ]},
                { name: 'REBOUNDING', color: '#94a3b8', metrics: [
                    { key: 'oreb75', label: 'OREB/75', format: 'dec' },
                    { key: 'dreb75', label: 'DREB/75', format: 'dec' }
                ]}
            ]
        },
        onball: {
            name: 'On-Ball',
            icon: '',
            categories: [
                { name: 'ON-BALL OVERALL', color: '#818cf8', metrics: [
                    { key: 'ob_onBallPct', label: 'OnBall%', format: 'pct' },
                    { key: 'ob_onBallInclPPP', label: 'PPP', format: 'ppp' }
                ]},
                { name: 'P&R OVERALL', color: '#f472b6', metrics: [
                    { key: 'ob_pnrIncl75', label: 'P&R/75', format: 'dec' },
                    { key: 'ob_pnrInclPPP', label: 'P&R PPP', format: 'ppp' },
                    { key: 'ob_pnrPressurePPP', label: 'Press PPP', format: 'ppp' },
                    { key: 'ob_pnrPressureTOPct', label: 'Press TO%', format: 'pct', inverse: true }
                ]},
                { name: 'P&R PASSING', color: '#a78bfa', metrics: [
                    { key: 'ob_pnrPassPct', label: 'Pass%', format: 'pct' },
                    { key: 'ob_pnrTOPct', label: 'TO%', format: 'pct', inverse: true },
                    { key: 'ob_pnrRollAst75', label: 'Roll AST', format: 'dec' },
                    { key: 'ob_pnrSpotUpAst75', label: 'SpotAST', format: 'dec' }
                ]},
                { name: 'SHOT SELECTION', color: '#22d3ee', metrics: [
                    { key: 'ob_handlingRim75', label: 'Rim/75', format: 'dec' },
                    { key: 'ob_handlingRimPct', label: 'Rim%', format: 'pct' },
                    { key: 'ob_handlingMid75', label: 'Mid/75', format: 'dec' },
                    { key: 'ob_handlingMidPct', label: 'Mid%', format: 'pct' },
                    { key: 'ob_handling3P75', label: '3P/75', format: 'dec' },
                    { key: 'ob_handling3PPct', label: '3P%', format: 'pct' }
                ]},
                { name: 'ISOLATION', color: '#fb923c', metrics: [
                    { key: 'ob_iso75', label: 'ISO/75', format: 'dec' },
                    { key: 'ob_isoPPP', label: 'ISO PPP', format: 'ppp' }
                ]},
                { name: 'POST OVERALL', color: '#facc15', metrics: [
                    { key: 'ob_post75', label: 'Post/75', format: 'dec' },
                    { key: 'ob_postPPP', label: 'Post PPP', format: 'ppp' },
                    { key: 'ob_postPassPct', label: 'Pass%', format: 'pct' }
                ]},
                { name: 'POST L VS R', color: '#34d399', metrics: [
                    { key: 'ob_postLeftPPP', label: 'L PPP', format: 'ppp' },
                    { key: 'ob_postLeftPct', label: 'L%', format: 'pct' },
                    { key: 'ob_postRightPPP', label: 'R PPP', format: 'ppp' },
                    { key: 'ob_postRightPct', label: 'R%', format: 'pct' }
                ]}
            ]
        },
        spacing: {
            name: 'Spacing',
            icon: '',
            categories: [
                { name: 'OVERALL', color: '#06b6d4', metrics: [
                    { key: 'sp_spacingPct', label: 'Space%', format: 'pct' },
                    { key: 'sp_spacingPPP', label: 'PPP', format: 'ppp' },
                    { key: 'sp_spacingTOPct', label: 'TO%', format: 'pct', inverse: true },
                    { key: 'sp_spacingFtRate', label: 'FT Rate', format: 'pct' }
                ]},
                { name: 'SPOT-UP C&S', color: '#3b82f6', metrics: [
                    { key: 'sp_spotUpCnS75', label: 'C&S/75', format: 'dec' },
                    { key: 'sp_guardedPct', label: 'Guard%', format: 'pct' },
                    { key: 'sp_guarded3Pct', label: 'Grd3%', format: 'pct' },
                    { key: 'sp_open3Pct', label: 'Open3%', format: 'pct' },
                    { key: 'sp_adjusted3Pct', label: 'Adj3%', format: 'pct' }
                ]},
                { name: 'MOVING', color: '#a78bfa', metrics: [
                    { key: 'sp_moving75', label: 'Mov/75', format: 'dec' },
                    { key: 'sp_moving3Pct', label: 'Mov3%', format: 'pct' }
                ]},
                { name: 'SPOT UP DRIVES', color: '#f472b6', metrics: [
                    { key: 'sp_spotUpDrivePct', label: 'Drv%', format: 'pct' },
                    { key: 'sp_spotUpDrives75', label: 'Drv/75', format: 'dec' },
                    { key: 'sp_spotUpDrivesPPP', label: 'Drv PPP', format: 'ppp' }
                ]},
                { name: 'OFF SCREEN', color: '#f97316', metrics: [
                    { key: 'sp_offScreen75', label: 'OS/75', format: 'dec' },
                    { key: 'sp_offScreenPPP', label: 'OS PPP', format: 'ppp' },
                    { key: 'sp_offScreenDrivePct', label: 'OS Drv%', format: 'pct' }
                ]},
                { name: 'HANDOFFS', color: '#84cc16', metrics: [
                    { key: 'sp_handoffs75', label: 'HO/75', format: 'dec' },
                    { key: 'sp_handoffsPPP', label: 'HO PPP', format: 'ppp' },
                    { key: 'sp_handoffsDrivePct', label: 'HO Drv%', format: 'pct' }
                ]}
            ]
        },
        finishing: {
            name: 'Finishing',
            icon: '',
            categories: [
                { name: 'OVERALL', color: '#facc15', metrics: [
                    { key: 'fn_finishingPct', label: 'Fin%', format: 'pct' },
                    { key: 'fn_finishingPPP', label: 'PPP', format: 'ppp' },
                    { key: 'fn_finishingTOPct', label: 'TO%', format: 'pct', inverse: true },
                    { key: 'fn_finishingFtRate', label: 'FT Rate', format: 'pct' }
                ]},
                { name: 'P&R ROLLS', color: '#f472b6', metrics: [
                    { key: 'fn_rolls75', label: 'Roll/75', format: 'dec' },
                    { key: 'fn_rollsPPP', label: 'Roll PPP', format: 'ppp' },
                    { key: 'fn_rollsFtRate', label: 'Roll FT%', format: 'pct' },
                    { key: 'fn_rollsTOPct', label: 'Roll TO%', format: 'pct', inverse: true }
                ]},
                { name: 'P&R POPS', color: '#a78bfa', metrics: [
                    { key: 'fn_pops75', label: 'Pop/75', format: 'dec' },
                    { key: 'fn_popsPPP', label: 'Pop PPP', format: 'ppp' }
                ]},
                { name: 'CUTS', color: '#22d3ee', metrics: [
                    { key: 'fn_selfCut75', label: 'Cut/75', format: 'dec' },
                    { key: 'fn_selfCutPPP', label: 'Cut PPP', format: 'ppp' },
                    { key: 'fn_selfCutTOPct', label: 'Cut TO%', format: 'pct', inverse: true }
                ]},
                { name: 'PUTBACKS', color: '#fb923c', metrics: [
                    { key: 'fn_putbacks75', label: 'PB/75', format: 'dec' }
                ]}
            ]
        },
        defense: {
            name: 'Defense',
            icon: '',
            categories: [
                { name: 'ON-BALL D', color: '#34d399', metrics: [
                    { key: 'df_onBallDef75', label: 'OnBD/75', format: 'dec' },
                    { key: 'df_onBallDefPPP', label: 'OnBD PPP', format: 'ppp', inverse: true },
                    { key: 'df_onBallDefTOPct', label: 'OnBD TO%', format: 'pct' },
                    { key: 'df_onBallDefFtRate', label: 'OnBD FT%', format: 'pct', inverse: true }
                ]},
                { name: 'P&R D', color: '#4ade80', metrics: [
                    { key: 'df_pnrDef75', label: 'P&RD/75', format: 'dec' },
                    { key: 'df_pnrDefPPP', label: 'P&RD PPP', format: 'ppp', inverse: true },
                    { key: 'df_pnrDefTOPct', label: 'P&RD TO%', format: 'pct' }
                ]},
                { name: 'DRIVES D', color: '#22d3ee', metrics: [
                    { key: 'df_drivesDef75', label: 'DrvD/75', format: 'dec' },
                    { key: 'df_drivesDefPPP', label: 'DrvD PPP', format: 'ppp', inverse: true },
                    { key: 'df_drivesDefTOPct', label: 'DrvD TO%', format: 'pct' }
                ]},
                { name: 'POST D', color: '#f472b6', metrics: [
                    { key: 'df_postDef75', label: 'PostD/75', format: 'dec' },
                    { key: 'df_postDefPPP', label: 'PostD PPP', format: 'ppp', inverse: true },
                    { key: 'df_postDefTOPct', label: 'PostD TO%', format: 'pct' }
                ]},
                { name: 'DISRUPTION', color: '#f87171', metrics: [
                    { key: 'stl75', label: 'STL/75', format: 'dec' },
                    { key: 'blk75', label: 'BLK/75', format: 'dec' }
                ]}
            ]
        }
    };
    
    // Get current categories based on selected section
    const currentCategories = useMemo(() => {
        if (selectedSection === 'all') {
            return Object.values(sectionDefinitions).flatMap(s => 
                s.categories.map(c => ({ ...c, sectionName: s.name }))
            );
        }
        return sectionDefinitions[selectedSection]?.categories || [];
    }, [selectedSection]);
    
    // Get all metrics for current section
    const currentMetrics = useMemo(() => {
        return currentCategories.flatMap(cat => cat.metrics);
    }, [currentCategories]);
    
    // Process player data from radarScalesData
    const playersData = useMemo(() => {
        if (!radarScalesData?.allRadarMetrics) {
            console.log('ProfilesTab: No allRadarMetrics data');
            return [];
        }
        
        const allData = radarScalesData.allRadarMetrics;
        console.log('ProfilesTab: allRadarMetrics length =', allData.length);
        
        // Debug: Show what seasons exist in the data
        const seasonsInData = [...new Set(allData.map(p => p.season))].sort();
        console.log('ProfilesTab: Seasons in data:', seasonsInData);
        console.log('ProfilesTab: Season filter:', effectiveSeasonFilter || 'ALL');
        console.log('ProfilesTab: useDuplicateData =', useDuplicateData);
        
        // Filter by ProfilesTab's own season filter (not affected by player selection)
        let data = allData;
        
        // Filter out duplicates unless useDuplicateData is true
        if (!useDuplicateData) {
            const beforeDupeFilter = data.length;
            data = data.filter(p => !p._isDuplicate);
            const afterDupeFilter = data.length;
            if (beforeDupeFilter !== afterDupeFilter) {
                console.log(`ProfilesTab: Excluded ${beforeDupeFilter - afterDupeFilter} duplicate seasons`);
            }
        }
        
        if (effectiveSeasonFilter && effectiveSeasonFilter.length > 0) {
            data = data.filter(p => {
                if (p.season) {
                    return effectiveSeasonFilter.includes(p.season);
                }
                return true;
            });
            console.log('ProfilesTab: After season filter =', data.length);
        } else {
            console.log('ProfilesTab: No season filter - showing all', data.length);
        }
        
        // Filter by minimum possessions
        const filtered = data.filter(p => (p.totalPoss || 0) >= minPoss);
        console.log('ProfilesTab: After minPoss filter =', filtered.length, '(minPoss =', minPoss, ')');
        
        // Calculate percentiles for each metric
        // Build percentile pools for all metrics
        const allMetricKeys = Object.values(sectionDefinitions).flatMap(s => 
            s.categories.flatMap(c => c.metrics.map(m => m.key))
        );
        
        const percentilePools = {};
        allMetricKeys.forEach(key => {
            const values = filtered
                .map(p => p[key])
                .filter(v => v !== null && v !== undefined && !isNaN(v))
                .sort((a, b) => a - b);
            percentilePools[key] = values;
        });
        
        // Calculate percentile for each player's metrics
        const withPercentiles = filtered.map(player => {
            const playerWithPcts = { ...player };
            allMetricKeys.forEach(key => {
                const value = player[key];
                const pool = percentilePools[key];
                if (value !== null && value !== undefined && !isNaN(value) && pool.length > 0) {
                    // Find rank in pool
                    const rank = pool.filter(v => v < value).length;
                    const pct = (rank / pool.length) * 100;
                    playerWithPcts[`${key}_pct`] = pct;
                }
            });
            return playerWithPcts;
        });
        
        return withPercentiles;
    }, [radarScalesData, effectiveSeasonFilter, minPoss, useDuplicateData]);
    
    // Apply stat filters and sorting
    const filteredAndSortedData = useMemo(() => {
        let filtered = [...playersData];
        
        // Apply stat filters
        Object.entries(statFilters).forEach(([key, filter]) => {
            if (filter.min !== '' && filter.min !== undefined) {
                filtered = filtered.filter(p => {
                    const val = p[key];
                    return val !== null && val !== undefined && val >= parseFloat(filter.min);
                });
            }
            if (filter.max !== '' && filter.max !== undefined) {
                filtered = filtered.filter(p => {
                    const val = p[key];
                    return val !== null && val !== undefined && val <= parseFloat(filter.max);
                });
            }
        });
        
        // Sort
        if (sortConfig.key) {
            filtered.sort((a, b) => {
                const aVal = a[sortConfig.key];
                const bVal = b[sortConfig.key];
                
                if (aVal === null || aVal === undefined) return 1;
                if (bVal === null || bVal === undefined) return -1;
                
                const multiplier = sortConfig.direction === 'asc' ? 1 : -1;
                return (aVal - bVal) * multiplier;
            });
        }
        
        return filtered;
    }, [playersData, statFilters, sortConfig]);
    
    // Handle sort click
    const handleSort = (key) => {
        setSortConfig(prev => ({
            key,
            direction: prev.key === key && prev.direction === 'desc' ? 'asc' : 'desc'
        }));
    };
    
    // Toggle category collapse
    const toggleCategory = (catName) => {
        setCollapsedCategories(prev => {
            const next = new Set(prev);
            if (next.has(catName)) {
                next.delete(catName);
            } else {
                next.add(catName);
            }
            return next;
        });
    };
    
    // Update stat filter
    const updateStatFilter = (key, type, value) => {
        setStatFilters(prev => ({
            ...prev,
            [key]: {
                ...prev[key],
                [type]: value
            }
        }));
    };
    
    // Reset all filters
    const resetFilters = () => {
        setStatFilters({});
        setMinPoss(50);
        setSortConfig({ key: 'totalPPP', direction: 'desc' });
        setProfilesSeasonFilter('all');
    };
    
    // Format value
    const formatValue = (value, format) => {
        if (value === null || value === undefined) return '-';
        switch(format) {
            case 'ppp': return value.toFixed(2);
            case 'pct': return value.toFixed(1) + '%';
            case 'dec': return value.toFixed(1);
            case 'int': return Math.round(value).toString();
            default: return value.toFixed(1);
        }
    };
    
    // Get percentile color class
    const getPercentileClass = (pct) => {
        if (pct === null || pct === undefined) return '';
        if (pct >= 90) return 'pct-elite';
        if (pct >= 75) return 'pct-good';
        if (pct >= 40) return 'pct-avg';
        if (pct >= 25) return 'pct-below';
        return 'pct-poor';
    };
    
    // Get rank class
    const getRankClass = (rank) => {
        if (rank === 1) return 'rank-1';
        if (rank === 2) return 'rank-2';
        if (rank === 3) return 'rank-3';
        return 'rank-default';
    };
    
    return e('div', { className: 'profiles-container' },
        // Controls Section
        e('div', { className: 'profiles-controls' },
            e('div', { 
                className: 'profiles-controls-header',
                onClick: () => setFiltersExpanded(!filtersExpanded)
            },
                e('div', { className: 'profiles-controls-title' },
                    '',
                    'STATS FILTERS & SETTINGS'
                ),
                e('div', { className: 'profiles-controls-toggle' },
                    e('span', null, filtersExpanded ? 'Collapse' : 'Expand'),
                    e('span', { 
                        className: `profiles-controls-toggle-icon ${filtersExpanded ? 'expanded' : ''}`
                    }, '')
                )
            ),
            
            // Filter Content (collapsible)
            e('div', { className: `profiles-filters-content ${filtersExpanded ? 'expanded' : ''}` },
                // Main filter row
                e('div', { className: 'profiles-filter-row' },
                    // Season selector (independent from main player selection)
                    e('div', { className: 'profiles-filter-group' },
                        e('label', { className: 'profiles-filter-label' }, 'Season'),
                        e('select', {
                            className: 'profiles-filter-select',
                            value: profilesSeasonFilter,
                            onChange: (ev) => setProfilesSeasonFilter(ev.target.value)
                        },
                            e('option', { value: 'all' }, ` All Seasons (${allAvailableSeasons.length})`),
                            allAvailableSeasons.map(season => 
                                e('option', { key: season, value: season }, season)
                            )
                        )
                    ),
                    
                    // Section selector
                    e('div', { className: 'profiles-filter-group' },
                        e('label', { className: 'profiles-filter-label' }, 'Stats Section'),
                        e('select', {
                            className: 'profiles-filter-select',
                            value: selectedSection,
                            onChange: (ev) => setSelectedSection(ev.target.value)
                        },
                            e('option', { value: 'main' }, ' Main'),
                            e('option', { value: 'onball' }, ' On-Ball'),
                            e('option', { value: 'spacing' }, ' Spacing'),
                            e('option', { value: 'finishing' }, ' Finishing'),
                            e('option', { value: 'defense' }, ' Defense'),
                            e('option', { value: 'all' }, ' All Sections')
                        )
                    ),
                    
                    // Min possessions
                    e('div', { className: 'profiles-filter-group' },
                        e('label', { className: 'profiles-filter-label' }, 'Min Possessions'),
                        e('input', {
                            type: 'number',
                            className: 'profiles-filter-input',
                            value: minPoss,
                            onChange: (ev) => setMinPoss(Math.max(0, parseInt(ev.target.value) || 0))
                        })
                    ),
                    
                    // Reset button
                    e('button', {
                        className: 'profiles-reset-btn',
                        onClick: resetFilters
                    }, ' Reset Filters')
                ),
                
                // Stat-specific filters
                currentMetrics.length > 0 && e('div', { className: 'profiles-stat-filters' },
                    currentMetrics.slice(0, 12).map(metric => 
                        e('div', { key: metric.key, className: 'profiles-stat-filter-item' },
                            e('span', { className: 'profiles-stat-filter-name' }, metric.label),
                            e('div', { className: 'profiles-stat-filter-inputs' },
                                e('input', {
                                    type: 'number',
                                    placeholder: 'Min',
                                    value: statFilters[metric.key]?.min || '',
                                    onChange: (ev) => updateStatFilter(metric.key, 'min', ev.target.value),
                                    step: metric.format === 'ppp' ? '0.01' : '1'
                                }),
                                e('span', null, '-'),
                                e('input', {
                                    type: 'number',
                                    placeholder: 'Max',
                                    value: statFilters[metric.key]?.max || '',
                                    onChange: (ev) => updateStatFilter(metric.key, 'max', ev.target.value),
                                    step: metric.format === 'ppp' ? '0.01' : '1'
                                })
                            )
                        )
                    )
                )
            )
        ),
        
        // Table Section
        e('div', { className: 'profiles-table-container' },
            e('div', { className: 'profiles-table-header' },
                e('div', { className: 'profiles-table-title' }, 
                    `${sectionDefinitions[selectedSection]?.icon || ''} ${sectionDefinitions[selectedSection]?.name || 'All'} LEADERBOARD`
                ),
                e('div', { className: 'profiles-table-info' },
                    e('span', { className: 'profiles-table-count' }, 
                        `${filteredAndSortedData.length} player${filteredAndSortedData.length !== 1 ? 's' : ''}`
                    ),
                    profilesSeasonFilter !== 'all' && e('span', { 
                        style: { 
                            marginLeft: '8px', 
                            opacity: 0.7, 
                            fontSize: '12px' 
                        } 
                    }, ` ${profilesSeasonFilter}`),
                    // Show duplicate info when duplicates toggle is on
                    useDuplicateData && filteredAndSortedData.some(p => p._isDuplicate) && e('span', {
                        style: {
                            marginLeft: '8px',
                            fontSize: '11px',
                            color: '#fb923c',
                            background: 'rgba(251, 146, 60, 0.15)',
                            padding: '2px 6px',
                            borderRadius: '4px'
                        }
                    }, ` ${filteredAndSortedData.filter(p => p._isDuplicate).length} dupes shown`)
                )
            ),
            
            e('div', { className: 'profiles-table-scroll' },
                e('table', { className: 'profiles-table' },
                    e('thead', null,
                        // Category header row
                        e('tr', { className: 'profiles-category-header' },
                            e('th', { 
                                className: 'sticky-col',
                                colSpan: 2, 
                                style: { 
                                    background: 'rgba(99, 102, 241, 0.2)', 
                                    color: '#818cf8',
                                    left: 0,
                                    zIndex: 12
                                } 
                            }, 'PLAYER'),
                            e('th', { style: { background: 'rgba(99, 102, 241, 0.2)', color: '#818cf8' } }, 'POSS'),
                            currentCategories.map((cat, catIdx) => {
                                const isCollapsed = collapsedCategories.has(cat.name);
                                return e('th', {
                                    key: `cat-${catIdx}`,
                                    colSpan: isCollapsed ? 1 : cat.metrics.length,
                                    style: { 
                                        background: `${cat.color}22`,
                                        color: cat.color,
                                        borderLeft: `3px solid ${cat.color}`
                                    }
                                },
                                    e('button', {
                                        className: 'profiles-category-collapse-btn',
                                        onClick: () => toggleCategory(cat.name)
                                    },
                                        e('span', { 
                                            className: `profiles-category-collapse-icon ${isCollapsed ? 'collapsed' : ''}`
                                        }, ''),
                                        cat.name,
                                        cat.sectionName && e('span', { 
                                            style: { fontSize: '0.6rem', marginLeft: '6px', opacity: 0.7 }
                                        }, `(${cat.sectionName})`)
                                    )
                                );
                            })
                        ),
                        
                        // Column headers
                        e('tr', null,
                            e('th', { className: 'sticky-col' }, '#'),
                            e('th', { className: 'sticky-col' }, 'Player'),
                            e('th', { 
                                className: sortConfig.key === 'totalPoss' ? `sorted ${sortConfig.direction}` : '',
                                onClick: () => handleSort('totalPoss')
                            }, 'Poss'),
                            currentCategories.flatMap((cat, catIdx) => {
                                const isCollapsed = collapsedCategories.has(cat.name);
                                if (isCollapsed) {
                                    return [e('th', { 
                                        key: `collapsed-${catIdx}`,
                                        style: { color: cat.color, opacity: 0.5 }
                                    }, '...')];
                                }
                                return cat.metrics.map((metric, metricIdx) =>
                                    e('th', {
                                        key: `${catIdx}-${metricIdx}`,
                                        className: sortConfig.key === metric.key ? `sorted ${sortConfig.direction}` : '',
                                        onClick: () => handleSort(metric.key),
                                        style: { 
                                            borderLeft: metricIdx === 0 ? `2px solid ${cat.color}40` : 'none'
                                        }
                                    }, metric.label)
                                );
                            })
                        )
                    ),
                    
                    e('tbody', null,
                        filteredAndSortedData.map((player, idx) => {
                            const isSelected = player.player === selectedPlayer;
                            // Show season badge when viewing all seasons
                            const showSeasonBadge = profilesSeasonFilter === 'all' && player.season;
                            // Check for duplicate flags
                            const isPlayTypeDupe = player._isDuplicate;
                            const isUtilitiesDupe = player._utilitiesDuplicate && !player._isDuplicate;
                            
                            return e('tr', { 
                                key: `${player.player}-${player.season}`,
                                className: `${isSelected ? 'selected' : ''} ${isPlayTypeDupe ? 'dupe-row' : ''}`,
                                onClick: () => onPlayerSelect && onPlayerSelect(player.player),
                                style: isPlayTypeDupe ? { opacity: 0.6, background: 'rgba(251, 146, 60, 0.1)' } : {}
                            },
                                // Rank
                                e('td', { className: 'sticky-col' },
                                    e('span', { className: `rank-cell ${getRankClass(idx + 1)}` }, idx + 1)
                                ),
                                // Player name
                                e('td', { className: 'sticky-col' },
                                    e('div', { className: 'player-name-cell' },
                                        player.player,
                                        player.team && e('span', { className: 'player-team-badge' }, player.team),
                                        showSeasonBadge && e('span', { 
                                            className: 'player-season-badge',
                                            style: { 
                                                fontSize: '9px', 
                                                opacity: 0.6, 
                                                marginLeft: '4px',
                                                background: 'var(--surface-lighter)',
                                                padding: '1px 4px',
                                                borderRadius: '3px'
                                            }
                                        }, player.season.split(' ')[0]),
                                        // Duplicate indicators
                                        isPlayTypeDupe && e('span', {
                                            title: `Play type duplicate of ${player._duplicateOf} (${player._duplicateSimilarity?.toFixed(0)}% similar)`,
                                            style: {
                                                fontSize: '9px',
                                                marginLeft: '4px',
                                                background: 'rgba(251, 146, 60, 0.3)',
                                                color: '#fb923c',
                                                padding: '1px 4px',
                                                borderRadius: '3px',
                                                cursor: 'help'
                                            }
                                        }, ' DUPE'),
                                        isUtilitiesDupe && e('span', {
                                            title: `Utilities data similar to ${player._utilitiesDuplicateOf} (play type data is unique)`,
                                            style: {
                                                fontSize: '9px',
                                                marginLeft: '4px',
                                                background: 'rgba(34, 211, 238, 0.2)',
                                                color: '#22d3ee',
                                                padding: '1px 4px',
                                                borderRadius: '3px',
                                                cursor: 'help'
                                            }
                                        }, ' Utils')
                                    )
                                ),
                                // Possessions
                                e('td', null, player.totalPoss || '-'),
                                // Metric values
                                currentCategories.flatMap((cat, catIdx) => {
                                    const isCollapsed = collapsedCategories.has(cat.name);
                                    if (isCollapsed) {
                                        return [e('td', { 
                                            key: `collapsed-${catIdx}`,
                                            style: { color: cat.color, opacity: 0.3 }
                                        }, '')];
                                    }
                                    return cat.metrics.map((metric, metricIdx) => {
                                        const value = player[metric.key];
                                        const pctKey = `${metric.key}_pct`;
                                        const pct = player[pctKey];
                                        const pctClass = getPercentileClass(pct);
                                        
                                        return e('td', {
                                            key: `${catIdx}-${metricIdx}`,
                                            className: pctClass ? `pct-cell ${pctClass}` : '',
                                            style: { 
                                                borderLeft: metricIdx === 0 ? `2px solid ${cat.color}20` : 'none'
                                            }
                                        }, formatValue(value, metric.format));
                                    });
                                })
                            );
                        })
                    )
                )
            )
        )
    );
}

// ============================================
// PLAYER PROFILE TAB COMPONENT
// ============================================
function PlayerProfileTab({ 
    playerData, 
    sectionData, 
    matchedPoss, 
    playerDefenseData, 
    playerEnhancedStats,
    radarScalesData,
    pools,
    rolePools,
    selectedPlayer,
    availableSeasons,
    selectedSeasons,
    toggleSeason,
    players,
    setSelectedPlayer,
    playerPhoto,
    handlePhotoUpload,
    openScreenshotModal
}) {
    // Collapse state for each section
    const [collapsedSections, setCollapsedSections] = useState(new Set());
    
    const toggleSection = (section) => {
        setCollapsedSections(prev => {
            const next = new Set(prev);
            if (next.has(section)) {
                next.delete(section);
            } else {
                next.add(section);
            }
            return next;
        });
    };
    
    // Early return if no player data
    if (!playerData) {
        return e('div', { 
            className: 'player-profile-empty',
            style: {
                padding: '60px',
                textAlign: 'center',
                color: 'var(--text-muted)'
            }
        },
            e('div', { style: { fontSize: '64px', marginBottom: '20px' } }, ''),
            e('h2', { style: { color: 'var(--text-primary)', marginBottom: '12px' } }, 'No Player Selected'),
            e('p', null, 'Select a player from the Profiles tab or use the dropdown above.')
        );
    }
    
    // Format value helper
    const fmtVal = (val, format) => {
        if (val === null || val === undefined || isNaN(val)) return '-';
        switch(format) {
            case 'ppp': return val.toFixed(2);
            case 'pct': return val.toFixed(0) + '%';
            case 'dec': return val.toFixed(1);
            default: return val.toFixed(1);
        }
    };
    
    // Get percentile color
    const getPctColor = (pct) => {
        if (pct === null || pct === undefined || pct < 0) return 'var(--text-muted)';
        if (pct >= 90) return '#22c55e';
        if (pct >= 75) return '#84cc16';
        if (pct >= 60) return '#a3e635';
        if (pct >= 40) return '#fbbf24';
        if (pct >= 25) return '#fb923c';
        return '#ef4444';
    };
    
    // Calculate all radar metrics
    const radar1Metrics = useMemo(() => {
        const baseMetrics = calculateRadar1Metrics(playerData, sectionData, matchedPoss, playerDefenseData, playerEnhancedStats, pools);
        const transitionData = sectionData?.transition;
        if (transitionData) {
            baseMetrics.transPctOfPoss = transitionData.main?.pctOfPoss || 0;
            baseMetrics.transPPP = transitionData.main?.ppp || 0;
            baseMetrics.hcPctOfPoss = transitionData.halfCourt?.pctOfPoss || 0;
            baseMetrics.hcPPP = transitionData.halfCourt?.ppp || 0;
        }
        return baseMetrics;
    }, [playerData, sectionData, matchedPoss, playerDefenseData, playerEnhancedStats, pools]);
    
    const onBallRadarMetrics = useMemo(() => {
        if (!playerData?.rawRows) return null;
        return calculateOnBallRadarMetrics(playerData.rawRows, matchedPoss);
    }, [playerData, matchedPoss]);
    
    const spacingRadarMetrics = useMemo(() => {
        if (!playerData?.rawRows) return null;
        return calculateSpacingRadarMetrics(playerData.rawRows, matchedPoss);
    }, [playerData, matchedPoss]);
    
    const finishingRadarMetrics = useMemo(() => {
        if (!playerData?.rawRows) return null;
        return calculateFinishingRadarMetrics(playerData.rawRows, matchedPoss);
    }, [playerData, matchedPoss]);
    
    const defenseRadarMetrics = useMemo(() => {
        if (!playerDefenseData || playerDefenseData.length === 0) return null;
        return calculateDefenseRadarMetrics(playerDefenseData, matchedPoss);
    }, [playerDefenseData, matchedPoss]);
    
    // Get player role info
    const playerRoleInfo = useMemo(() => {
        if (!radarScalesData?.playerRoles || !playerData) return null;
        return radarScalesData.playerRoles[playerData.player];
    }, [radarScalesData, playerData]);
    
    // Combined all metrics from all sources for easy access
    const allMetricsObj = useMemo(() => {
        return {
            ...(radar1Metrics || {}),
            ...(onBallRadarMetrics || {}),
            ...(spacingRadarMetrics || {}),
            ...(finishingRadarMetrics || {}),
            ...(defenseRadarMetrics || {})
        };
    }, [radar1Metrics, onBallRadarMetrics, spacingRadarMetrics, finishingRadarMetrics, defenseRadarMetrics]);
    
    // Key mapping from display keys to pool keys (pool uses prefixes)
    const keyToPoolKey = (key) => {
        // On-Ball metrics use ob_ prefix
        const onBallKeys = ['onBallIncl75', 'onBallInclPPP', 'onBallPPP', 'onBall75', 'onBallPct',
            'pnrIncl75', 'pnrInclPPP', 'pnrPassPct', 'pnrTOPct', 'pnrPressurePPP', 'pnrPressureTOPct',
            'iso75', 'isoPPP', 'post75', 'postPPP', 'postPassPct', 'postPressurePPP', 'postPressureTOPct',
            'handlingRim75', 'handlingRimPct', 'handlingMid75', 'handlingMidPct', 'handling3P75', 'handling3PPct'];
        if (onBallKeys.includes(key)) return `ob_${key}`;
        
        // Spacing metrics use sp_ prefix
        const spacingKeys = ['spacing75', 'spacingPPP', 'spacingPct', 'spacingTOPct', 'spacingFtRate',
            'spotUpCnS75', 'guardedPct', 'guarded3Pct', 'open3Pct', 'adjusted3Pct',
            'spotUpDrivePct', 'spotUpDrives75', 'spotUpDrivesPPP', 'spotUpDrivesFtRate', 'spotUpDrivesTOPct',
            'moving75', 'movingPPP', 'moving3Pct', 'offScreen75', 'handoffs75'];
        if (spacingKeys.includes(key)) return `sp_${key}`;
        
        // Finishing metrics use fn_ prefix
        const finishingKeys = ['finishing75', 'finishingPPP', 'finishingPct', 'finishingTOPct', 'finishingFtRate',
            'rolls75', 'rollsPPP', 'rollsFtRate', 'rollsTOPct', 'pops75', 'popsPPP',
            'rollMan75', 'slips75', 'slipsPPP', 'selfCut75', 'selfCutPPP', 'selfCutTOPct', 'putbacks75'];
        if (finishingKeys.includes(key)) return `fn_${key}`;
        
        // Defense metrics use df_ prefix
        const defenseKeys = ['onBallDef75', 'onBallDefPPP', 'onBallDefTOPct', 'onBallDefFtRate',
            'pnrDef75', 'pnrDefPPP', 'pnrDefTOPct', 'pnrDefFtRate',
            'postDef75', 'postDefPPP', 'postDefTOPct', 'postDefFtRate',
            'drivesDef75', 'drivesDefPPP', 'drivesDefTOPct', 'drivesDefFtRate',
            'stl75', 'blk75'];
        if (defenseKeys.includes(key)) return `df_${key}`;
        
        // Default - no prefix (radar1 metrics like totalPPP, usagePct, etc.)
        return key;
    };
    
    // Calculate percentiles for all metrics
    const allPercentiles = useMemo(() => {
        if (!radarScalesData?.allRadarMetrics) return {};
        const pool = radarScalesData.allRadarMetrics;
        const pcts = {};
        
        Object.keys(allMetricsObj).forEach(key => {
            if (key.startsWith('_')) return; // Skip internal keys
            const playerVal = allMetricsObj[key];
            if (playerVal === null || playerVal === undefined || isNaN(playerVal)) return;
            
            // Try both the direct key and the prefixed pool key
            const poolKey = keyToPoolKey(key);
            const poolValues = pool
                .map(p => p[poolKey] ?? p[key]) // Try prefixed key first, then direct
                .filter(v => v !== null && v !== undefined && !isNaN(v))
                .sort((a, b) => a - b);
            
            if (poolValues.length > 0) {
                const rank = poolValues.filter(v => v < playerVal).length;
                pcts[key] = (rank / poolValues.length) * 100;
            }
        });
        
        return pcts;
    }, [allMetricsObj, radarScalesData]);
    
    // Stat row component
    const StatRow = ({ label, value, format, metricKey }) => {
        const pct = allPercentiles[metricKey];
        const color = getPctColor(pct);
        return e('div', { 
            style: { 
                display: 'flex', 
                justifyContent: 'space-between', 
                padding: '4px 0',
                borderBottom: '1px solid rgba(255,255,255,0.05)'
            }
        },
            e('span', { style: { color: 'var(--text-secondary)', fontSize: '0.75rem' } }, label),
            e('span', { 
                style: { 
                    fontFamily: 'JetBrains Mono, monospace',
                    fontWeight: '600',
                    color: color,
                    fontSize: '0.8rem'
                }
            }, fmtVal(value, format))
        );
    };
    
    // Category header component
    const CategoryHeader = ({ title, color }) => {
        return e('div', {
            style: {
                fontFamily: 'Bebas Neue, sans-serif',
                fontSize: '0.85rem',
                letterSpacing: '1px',
                color: color,
                padding: '8px 0 4px 0',
                borderBottom: `2px solid ${color}`,
                marginBottom: '4px',
                marginTop: '8px'
            }
        }, title);
    };
    
    // Section definitions with all stats - using allMetricsObj for values
    const sections = [
        {
            id: 'onball',
            name: 'ON-BALL',
            icon: '',
            color: '#f97316',
            hasData: !!onBallRadarMetrics || !!radar1Metrics,
            columns: [
                {
                    title: 'Creation',
                    color: '#f97316',
                    stats: [
                        { label: 'OnBall/75', key: 'onBallIncl75', format: 'dec' },
                        { label: 'OnBall PPP', key: 'onBallInclPPP', format: 'ppp' },
                        { label: 'Pass%', key: 'onBallPassPct', format: 'pct' },
                        { label: 'TO%', key: 'toPct', format: 'pct' }
                    ]
                },
                {
                    title: 'P&R Ball Handler',
                    color: '#eab308',
                    stats: [
                        { label: 'P&R/75', key: 'pnrIncl75', format: 'dec' },
                        { label: 'P&R PPP', key: 'pnrInclPPP', format: 'ppp' },
                        { label: 'Pass%', key: 'pnrPassPct', format: 'pct' },
                        { label: 'TO%', key: 'pnrTOPct', format: 'pct' },
                        { label: 'Pressure PPP', key: 'pnrPressurePPP', format: 'ppp' },
                        { label: 'Pressure TO%', key: 'pnrPressureTOPct', format: 'pct' }
                    ]
                },
                {
                    title: 'Isolation',
                    color: '#22c55e',
                    stats: [
                        { label: 'ISO/75', key: 'iso75', format: 'dec' },
                        { label: 'ISO PPP', key: 'isoPPP', format: 'ppp' }
                    ]
                },
                {
                    title: 'Post-Up',
                    color: '#3b82f6',
                    stats: [
                        { label: 'Post/75', key: 'post75', format: 'dec' },
                        { label: 'Post PPP', key: 'postPPP', format: 'ppp' },
                        { label: 'Pass%', key: 'postPassPct', format: 'pct' },
                        { label: 'Pressure PPP', key: 'postPressurePPP', format: 'ppp' },
                        { label: 'Pressure TO%', key: 'postPressureTOPct', format: 'pct' }
                    ]
                }
            ]
        },
        {
            id: 'spacing',
            name: 'SPACING',
            icon: '',
            color: '#22d3ee',
            hasData: !!spacingRadarMetrics,
            columns: [
                {
                    title: 'Overall',
                    color: '#06b6d4',
                    stats: [
                        { label: 'Spacing/75', key: 'spacing75', format: 'dec' },
                        { label: 'Spacing PPP', key: 'spacingPPP', format: 'ppp' },
                        { label: 'Spacing%', key: 'spacingPct', format: 'pct' },
                        { label: 'TO%', key: 'spacingTOPct', format: 'pct' },
                        { label: 'FT Rate', key: 'spacingFtRate', format: 'pct' }
                    ]
                },
                {
                    title: 'Spot-Up C&S',
                    color: '#3b82f6',
                    stats: [
                        { label: 'C&S/75', key: 'spotUpCnS75', format: 'dec' },
                        { label: 'Guarded%', key: 'guardedPct', format: 'pct' },
                        { label: 'Guarded 3PT%', key: 'guarded3Pct', format: 'pct' },
                        { label: 'Open 3PT%', key: 'open3Pct', format: 'pct' },
                        { label: 'Adjusted 3PT%', key: 'adjusted3Pct', format: 'pct' }
                    ]
                },
                {
                    title: 'Spot-Up Drives',
                    color: '#f472b6',
                    stats: [
                        { label: 'Drive%', key: 'spotUpDrivePct', format: 'pct' },
                        { label: 'Drives/75', key: 'spotUpDrives75', format: 'dec' },
                        { label: 'Drive PPP', key: 'spotUpDrivesPPP', format: 'ppp' },
                        { label: 'FT Rate', key: 'spotUpDrivesFtRate', format: 'pct' },
                        { label: 'TO%', key: 'spotUpDrivesTOPct', format: 'pct' }
                    ]
                },
                {
                    title: 'Moving Shots',
                    color: '#a78bfa',
                    stats: [
                        { label: 'Moving/75', key: 'moving75', format: 'dec' },
                        { label: 'Moving PPP', key: 'movingPPP', format: 'ppp' },
                        { label: 'Moving 3PT%', key: 'moving3Pct', format: 'pct' }
                    ]
                }
            ]
        },
        {
            id: 'finishing',
            name: 'FINISHING',
            icon: '',
            color: '#facc15',
            hasData: !!finishingRadarMetrics || !!radar1Metrics,
            columns: [
                {
                    title: 'Overall',
                    color: '#ef4444',
                    stats: [
                        { label: 'Finishing/75', key: 'finishing75', format: 'dec' },
                        { label: 'Finishing PPP', key: 'finishingPPP', format: 'ppp' },
                        { label: 'Finishing%', key: 'finishingPct', format: 'pct' },
                        { label: 'TO%', key: 'finishingTOPct', format: 'pct' },
                        { label: 'FT Rate', key: 'finishingFtRate', format: 'pct' }
                    ]
                },
                {
                    title: 'Drives',
                    color: '#fb923c',
                    stats: [
                        { label: 'Drives/75', key: 'drives75', format: 'dec' },
                        { label: 'Drive PPP', key: 'drivesPPP', format: 'ppp' }
                    ]
                },
                {
                    title: 'Roll Man',
                    color: '#a78bfa',
                    stats: [
                        { label: 'Rolls/75', key: 'rolls75', format: 'dec' },
                        { label: 'Roll PPP', key: 'rollsPPP', format: 'ppp' },
                        { label: 'Pops/75', key: 'pops75', format: 'dec' },
                        { label: 'Pops PPP', key: 'popsPPP', format: 'ppp' },
                        { label: 'Slips/75', key: 'slips75', format: 'dec' }
                    ]
                },
                {
                    title: 'Cuts & Putbacks',
                    color: '#22c55e',
                    stats: [
                        { label: 'Cuts/75', key: 'selfCut75', format: 'dec' },
                        { label: 'Cut PPP', key: 'selfCutPPP', format: 'ppp' },
                        { label: 'Putbacks/75', key: 'putbacks75', format: 'dec' }
                    ]
                }
            ]
        },
        {
            id: 'defense',
            name: 'DEFENSE',
            icon: '',
            color: '#ef4444',
            hasData: !!defenseRadarMetrics || !!radar1Metrics,
            columns: [
                {
                    title: 'On-Ball Defense',
                    color: '#ef4444',
                    stats: [
                        { label: 'OnBall D/75', key: 'onBallDef75', format: 'dec' },
                        { label: 'OnBall D PPP', key: 'onBallDefPPP', format: 'ppp' },
                        { label: 'OnBall D TO%', key: 'onBallDefTOPct', format: 'pct' },
                        { label: 'OnBall D FT Rate', key: 'onBallDefFtRate', format: 'pct' }
                    ]
                },
                {
                    title: 'P&R Defense',
                    color: '#f97316',
                    stats: [
                        { label: 'P&R D/75', key: 'pnrDef75', format: 'dec' },
                        { label: 'P&R D PPP', key: 'pnrDefPPP', format: 'ppp' },
                        { label: 'P&R D TO%', key: 'pnrDefTOPct', format: 'pct' },
                        { label: 'P&R D FT Rate', key: 'pnrDefFtRate', format: 'pct' }
                    ]
                },
                {
                    title: 'Drives Defense',
                    color: '#22d3ee',
                    stats: [
                        { label: 'Drives D/75', key: 'drivesDef75', format: 'dec' },
                        { label: 'Drives D PPP', key: 'drivesDefPPP', format: 'ppp' },
                        { label: 'Drives D TO%', key: 'drivesDefTOPct', format: 'pct' },
                        { label: 'Drives D FT Rate', key: 'drivesDefFtRate', format: 'pct' }
                    ]
                },
                {
                    title: 'Post Defense',
                    color: '#22c55e',
                    stats: [
                        { label: 'Post D/75', key: 'postDef75', format: 'dec' },
                        { label: 'Post D PPP', key: 'postDefPPP', format: 'ppp' },
                        { label: 'Post D TO%', key: 'postDefTOPct', format: 'pct' },
                        { label: 'Post D FT Rate', key: 'postDefFtRate', format: 'pct' }
                    ]
                },
                {
                    title: 'Disruption',
                    color: '#3b82f6',
                    stats: [
                        { label: 'STL/75', key: 'stl75', format: 'dec' },
                        { label: 'BLK/75', key: 'blk75', format: 'dec' },
                        { label: 'Def TO%', key: 'defTOPct', format: 'pct' }
                    ]
                }
            ]
        },
        {
            id: 'overall',
            name: 'OVERALL',
            icon: '',
            color: '#818cf8',
            hasData: !!radar1Metrics,
            columns: [
                {
                    title: 'Efficiency',
                    color: '#22c55e',
                    stats: [
                        { label: 'Total PPP', key: 'totalPPP', format: 'ppp' },
                        { label: 'TS%', key: 'tsPct', format: 'pct' },
                        { label: 'FT Rate', key: 'ftRate', format: 'pct' }
                    ]
                },
                {
                    title: 'Usage',
                    color: '#f97316',
                    stats: [
                        { label: 'Usage%', key: 'usagePct', format: 'pct' },
                        { label: 'On-Ball%', key: 'onBallPct', format: 'pct' },
                        { label: 'Off-Ball%', key: 'offBallPct', format: 'pct' },
                        { label: 'TO%', key: 'toPct', format: 'pct' }
                    ]
                },
                {
                    title: 'Shooting',
                    color: '#3b82f6',
                    stats: [
                        { label: '3PA/75', key: 'fg3Att75', format: 'dec' },
                        { label: 'Shooting Value', key: 'shootingValue', format: 'dec' },
                        { label: 'Rim Pressure', key: 'rimPressure', format: 'dec' },
                        { label: 'HC Rim/75', key: 'hcRim75', format: 'dec' },
                        { label: 'HC Rim FG%', key: 'hcRimFgPct', format: 'pct' }
                    ]
                },
                {
                    title: 'Playmaking',
                    color: '#a78bfa',
                    stats: [
                        { label: 'AST/USG', key: 'astUsgRatio', format: 'dec' },
                        { label: 'Pass%', key: 'onBallPassPct', format: 'pct' }
                    ]
                },
                {
                    title: 'Rebounding',
                    color: '#94a3b8',
                    stats: [
                        { label: 'OREB/75', key: 'oreb75', format: 'dec' },
                        { label: 'DREB/75', key: 'dreb75', format: 'dec' }
                    ]
                }
            ]
        }
    ];
    
    return e('div', { className: 'player-profile-container', style: { padding: '20px', maxWidth: '1200px', margin: '0 auto' } },
        // Header with player photo and selection
        e('div', { 
            style: {
                background: 'linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.15), rgba(236, 72, 153, 0.1))',
                borderRadius: '16px',
                padding: '24px',
                marginBottom: '24px',
                border: '1px solid rgba(99, 102, 241, 0.4)',
                display: 'grid',
                gridTemplateColumns: '140px 1fr auto',
                gap: '24px',
                alignItems: 'center',
                boxShadow: '0 8px 32px rgba(99, 102, 241, 0.15)',
                position: 'relative'
            },
            id: 'section-profile'
        },
            // Camera button for full profile
            openScreenshotModal && e(CameraButton, { 
                onClick: () => openScreenshotModal('profile', 'PLAYER PROFILE', 'section-profile', {
                    playerName: playerData?.playerName,
                    playerTeam: playerData?.team,
                    playerRole: playerRoleInfo?.role?.name
                }),
                style: { top: '15px', right: '15px' }
            }),
            // Player Photo
            e('label', {
                style: {
                    width: '140px',
                    height: '160px',
                    borderRadius: '12px',
                    overflow: 'hidden',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    background: playerPhoto ? 'transparent' : 'linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(15, 23, 42, 0.9))',
                    border: playerPhoto ? 'none' : '2px dashed rgba(99, 102, 241, 0.5)',
                    transition: 'all 0.2s ease',
                    position: 'relative',
                    flexShrink: 0
                }
            },
                e('input', {
                    type: 'file',
                    accept: 'image/*',
                    onChange: handlePhotoUpload,
                    style: { display: 'none' }
                }),
                playerPhoto 
                    ? e('img', { 
                        src: playerPhoto, 
                        alt: playerData.player,
                        style: { 
                            width: '100%', 
                            height: '100%', 
                            objectFit: 'cover',
                            borderRadius: '12px'
                        }
                    })
                    : e('div', { 
                        style: { 
                            textAlign: 'center', 
                            color: 'var(--text-muted)',
                            fontSize: '0.75rem'
                        }
                    },
                        e('div', { style: { fontSize: '2rem', marginBottom: '8px', opacity: 0.5 } }, ''),
                        e('span', null, 'Add Photo')
                    )
            ),
            // Player Info Center
            e('div', { style: { display: 'flex', flexDirection: 'column', gap: '12px' } },
                // Player Name - Large and Eye-catching
                e('h1', { 
                    style: { 
                        fontSize: '2.8rem', 
                        fontFamily: 'Bebas Neue, sans-serif',
                        letterSpacing: '4px',
                        marginBottom: '0',
                        background: 'linear-gradient(135deg, #ffffff 0%, #a5b4fc 50%, #c4b5fd 100%)',
                        WebkitBackgroundClip: 'text',
                        WebkitTextFillColor: 'transparent',
                        backgroundClip: 'text',
                        textShadow: '0 0 40px rgba(129, 140, 248, 0.4)',
                        lineHeight: 1
                    }
                }, playerData.player),
                // Badges row
                e('div', { style: { display: 'flex', gap: '10px', alignItems: 'center', flexWrap: 'wrap' } },
                    playerData.team && e('span', { 
                        style: { 
                            background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(37, 99, 235, 0.2))', 
                            padding: '6px 14px', 
                            borderRadius: '20px',
                            fontSize: '0.85rem',
                            fontWeight: '600',
                            color: '#60a5fa',
                            border: '1px solid rgba(59, 130, 246, 0.3)'
                        }
                    }, playerData.team),
                    playerRoleInfo?.role?.name && e('span', { 
                        style: { 
                            background: 'linear-gradient(135deg, rgba(167, 139, 250, 0.3), rgba(139, 92, 246, 0.2))', 
                            padding: '6px 14px', 
                            borderRadius: '20px',
                            fontSize: '0.85rem',
                            fontWeight: '600',
                            color: '#a78bfa',
                            border: '1px solid rgba(167, 139, 250, 0.3)'
                        }
                    }, playerRoleInfo.role.name),
                    e('span', { 
                        style: { 
                            background: 'rgba(34, 197, 94, 0.15)',
                            padding: '6px 14px', 
                            borderRadius: '20px',
                            color: '#4ade80',
                            fontSize: '0.85rem',
                            fontWeight: '600',
                            fontFamily: 'JetBrains Mono, monospace',
                            border: '1px solid rgba(34, 197, 94, 0.3)'
                        }
                    }, `${playerData.totalPoss || 0} POSS`)
                ),
                // Season chips
                availableSeasons.length > 0 && e('div', { style: { display: 'flex', gap: '8px', marginTop: '4px' } },
                    availableSeasons.map(season => 
                        e('button', {
                            key: season,
                            onClick: () => toggleSeason(season),
                            style: {
                                padding: '5px 12px',
                                borderRadius: '6px',
                                border: selectedSeasons.includes(season) 
                                    ? '2px solid #818cf8' 
                                    : '1px solid rgba(255,255,255,0.2)',
                                background: selectedSeasons.includes(season)
                                    ? 'rgba(129, 140, 248, 0.25)'
                                    : 'rgba(0,0,0,0.2)',
                                color: selectedSeasons.includes(season) ? '#a5b4fc' : 'var(--text-muted)',
                                cursor: 'pointer',
                                fontSize: '0.75rem',
                                fontWeight: '600',
                                transition: 'all 0.2s ease'
                            }
                        }, season.split(' ')[0])
                    )
                )
            ),
            // Player dropdown (right side)
            e('div', { style: { display: 'flex', flexDirection: 'column', alignItems: 'flex-end', gap: '8px' } },
                e('span', { style: { fontSize: '0.7rem', color: 'var(--text-muted)', textTransform: 'uppercase', letterSpacing: '1px' } }, 'Switch Player'),
                players && players.length > 0 && e('select', {
                    className: 'control-select',
                    value: selectedPlayer,
                    onChange: (ev) => setSelectedPlayer(ev.target.value),
                    style: {
                        padding: '10px 14px',
                        borderRadius: '10px',
                        background: 'rgba(15, 23, 42, 0.8)',
                        border: '1px solid rgba(99, 102, 241, 0.4)',
                        color: 'var(--text-primary)',
                        fontSize: '0.9rem',
                        minWidth: '220px',
                        cursor: 'pointer',
                        fontWeight: '500'
                    }
                }, players.map(p => e('option', { key: p, value: p }, p)))
            )
        ),
        
        // Sections with PES-style stat columns
        e('div', { style: { display: 'flex', flexDirection: 'column', gap: '12px' } },
            sections.filter(s => s.hasData).map(section => {
                const isCollapsed = collapsedSections.has(section.id);
                
                return e('div', { 
                    key: section.id,
                    style: {
                        background: 'var(--bg-card)',
                        borderRadius: '10px',
                        border: `1px solid ${section.color}33`,
                        overflow: 'hidden'
                    }
                },
                    // Section Header (clickable)
                    e('div', {
                        onClick: () => toggleSection(section.id),
                        style: {
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'space-between',
                            padding: '10px 14px',
                            background: `${section.color}15`,
                            cursor: 'pointer',
                            borderBottom: isCollapsed ? 'none' : `1px solid ${section.color}22`
                        }
                    },
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
                            e('span', { style: { fontSize: '1rem' } }, section.icon),
                            e('span', { 
                                style: { 
                                    fontFamily: 'Bebas Neue, sans-serif',
                                    fontSize: '1rem',
                                    letterSpacing: '1.5px',
                                    color: section.color
                                }
                            }, section.name)
                        ),
                        e('span', { 
                            style: { 
                                color: 'var(--text-muted)',
                                fontSize: '0.8rem',
                                transform: isCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)',
                                transition: 'transform 0.2s ease'
                            }
                        }, '')
                    ),
                    
                    // Section Content - Multi-column stats layout (PES style)
                    !isCollapsed && e('div', {
                        style: {
                            display: 'grid',
                            gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))',
                            gap: '16px',
                            padding: '16px'
                        }
                    },
                        section.columns.map((col, colIdx) => 
                            e('div', { key: colIdx },
                                // Column header
                                e('div', {
                                    style: {
                                        fontFamily: 'Bebas Neue, sans-serif',
                                        fontSize: '0.8rem',
                                        letterSpacing: '1px',
                                        color: col.color,
                                        paddingBottom: '4px',
                                        borderBottom: `2px solid ${col.color}`,
                                        marginBottom: '6px'
                                    }
                                }, col.title),
                                // Stats
                                col.stats.map((stat, statIdx) => {
                                    const value = allMetricsObj[stat.key];
                                    const pct = allPercentiles[stat.key];
                                    const color = getPctColor(pct);
                                    
                                    return e('div', { 
                                        key: statIdx,
                                        style: { 
                                            display: 'flex', 
                                            justifyContent: 'space-between', 
                                            padding: '3px 0',
                                            borderBottom: '1px solid rgba(255,255,255,0.04)'
                                        }
                                    },
                                        e('span', { 
                                            style: { 
                                                color: 'var(--text-secondary)', 
                                                fontSize: '0.7rem' 
                                            }
                                        }, stat.label),
                                        e('span', { 
                                            style: { 
                                                fontFamily: 'JetBrains Mono, monospace',
                                                fontWeight: '600',
                                                color: color,
                                                fontSize: '0.75rem'
                                            }
                                        }, fmtVal(value, stat.format))
                                    );
                                })
                            )
                        )
                    )
                );
            })
        )
    );
}

// ============================================
// PART 5: MAIN APP COMPONENT
// ============================================

function App() {
    const [offenseData, setOffenseData] = useState([]);
    const [utilitiesData, setUtilitiesData] = useState([]);
    const [defenseData, setDefenseData] = useState([]);
    const [teamUtilitiesData, setTeamUtilitiesData] = useState([]);
    const [playerUtilitiesData, setPlayerUtilitiesData] = useState([]);
    const [enhancedStatsData, setEnhancedStatsData] = useState([]);
    const [offenseFile, setOffenseFile] = useState('');
    const [utilitiesFile, setUtilitiesFile] = useState('');
    const [defenseFile, setDefenseFile] = useState('');
    const [teamUtilFile, setTeamUtilFile] = useState('');
    const [playerUtilFile, setPlayerUtilFile] = useState('');
    const [enhancedStatsFile, setEnhancedStatsFile] = useState('');
    const [selectedPlayer, setSelectedPlayer] = useState('');
    const [selectedTeam, setSelectedTeam] = useState('All Teams');
    const [selectedSeasons, setSelectedSeasons] = useState([]);
    const [playerPhoto, setPlayerPhoto] = useState(null);
    const [scoutNotes, setScoutNotes] = useState('');
    const [activeTab, setActiveTab] = useState('main');
    const [isLoading, setIsLoading] = useState(false);
    
    // Screenshot modal state
    const [screenshotModal, setScreenshotModal] = useState({ open: false, section: null, title: '', sourceElementId: null });
    const screenshotRef = React.useRef(null);
    
    // Duplicate data control - default OFF (excludes duplicates)
    const [useDuplicateData, setUseDuplicateData] = useState(false);
    
    // File upload handlers
    const handleOffenseUpload = useCallback((ev) => {
        const file = ev.target.files[0];
        if (file) {
            setOffenseFile(file.name);
            setIsLoading(true);
            const reader = new FileReader();
            reader.onload = (e) => {
                setOffenseData(parseCSV(e.target.result));
                setIsLoading(false);
            };
            reader.readAsText(file);
        }
    }, []);
    
    const handleUtilitiesUpload = useCallback((ev) => {
        const file = ev.target.files[0];
        if (file) {
            setUtilitiesFile(file.name);
            const reader = new FileReader();
            reader.onload = (e) => {
                setUtilitiesData(parseCSV(e.target.result));
            };
            reader.readAsText(file);
        }
    }, []);
    
    const handleDefenseUpload = useCallback((ev) => {
        const file = ev.target.files[0];
        if (file) {
            setDefenseFile(file.name);
            const reader = new FileReader();
            reader.onload = (e) => {
                setDefenseData(parseCSV(e.target.result));
            };
            reader.readAsText(file);
        }
    }, []);
    
    const handleTeamUtilitiesUpload = useCallback((ev) => {
        const file = ev.target.files[0];
        if (file) {
            setTeamUtilFile(file.name);
            const reader = new FileReader();
            reader.onload = (e) => {
                setTeamUtilitiesData(parseCSV(e.target.result));
            };
            reader.readAsText(file);
        }
    }, []);
    
    const handlePlayerUtilitiesUpload = useCallback((ev) => {
        const file = ev.target.files[0];
        if (file) {
            setPlayerUtilFile(file.name);
            const reader = new FileReader();
            reader.onload = (e) => {
                setPlayerUtilitiesData(parseCSV(e.target.result));
            };
            reader.readAsText(file);
        }
    }, []);
    
    const handleEnhancedStatsUpload = useCallback((ev) => {
        const file = ev.target.files[0];
        if (file) {
            setEnhancedStatsFile(file.name);
            const reader = new FileReader();
            reader.onload = (e) => {
                setEnhancedStatsData(parseCSV(e.target.result));
            };
            reader.readAsText(file);
        }
    }, []);
    
    const handlePhotoUpload = useCallback((ev) => {
        const file = ev.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                setPlayerPhoto(e.target.result);
            };
            reader.readAsDataURL(file);
        }
    }, []);
    
    // Screenshot capture handler
    const captureScreenshot = useCallback(async () => {
        if (!screenshotRef.current) return;
        
        try {
            // Get the screenshot-content element (the 1920x1080 container)
            const contentEl = screenshotRef.current;
            
            // Temporarily reset any transforms for accurate capture
            const originalTransform = contentEl.style.transform;
            contentEl.style.transform = 'none';
            
            const canvas = await html2canvas(contentEl, {
                scale: 1, // 1:1 since content is already 1920x1080
                backgroundColor: '#0a0c10',
                useCORS: true,
                allowTaint: true,
                width: 1920,
                height: 1080,
                windowWidth: 1920,
                windowHeight: 1080
            });
            
            // Restore transform
            contentEl.style.transform = originalTransform;
            
            const link = document.createElement('a');
            link.download = `${selectedPlayer || 'player'}-${screenshotModal.title.replace(/\s+/g, '-').toLowerCase()}-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        } catch (err) {
            console.error('Screenshot failed:', err);
            alert('Screenshot capture failed. Please try again.');
        }
    }, [selectedPlayer, screenshotModal.title]);
    
    // Open screenshot modal for a section - just needs sourceElementId and basic info
    const openScreenshotModal = useCallback((section, title, sourceElementId, info = {}) => {
        setScreenshotModal({ open: true, section, title, sourceElementId, ...info });
    }, []);
    
    // Close screenshot modal
    const closeScreenshotModal = useCallback(() => {
        setScreenshotModal({ open: false, section: null, title: '', sourceElementId: null });
    }, []);
    
    // Toggle season selection
    const toggleSeason = useCallback((season) => {
        setSelectedSeasons(prev => {
            if (prev.includes(season)) {
                return prev.filter(s => s !== season);
            } else {
                return [...prev, season];
            }
        });
    }, []);

    // ========================================
    // PARENT APP INTEGRATION (SLB Tauri App)
    // ========================================
    // Listen for data files from parent app (launcher.js)
    useEffect(() => {
        const handleParentMessage = async (event) => {
            // Validate message source
            if (!event.data || event.data.source !== 'slb-parent-app') {
                return;
            }

            console.log('[AdvancedPlayerView] Received message from parent:', event.data.type);

            if (event.data.type === 'DATA_FILES_INFO') {
                const { dataFiles, dataDate, appType } = event.data;

                if (!dataFiles || !Array.isArray(dataFiles)) {
                    console.error('[AdvancedPlayerView] Invalid data files received');
                    return;
                }

                console.log(`[AdvancedPlayerView] Loading data from parent app (${dataDate || 'unknown date'})...`);
                setIsLoading(true);

                // Map file names to their corresponding setters
                const fileHandlers = {
                    'PLAYER_OFFENSE.csv': async (url) => {
                        console.log('[AdvancedPlayerView] Loading PLAYER_OFFENSE.csv...');
                        const response = await fetch(url);
                        const text = await response.text();
                        const data = parseCSV(text);
                        setOffenseData(data);
                        setOffenseFile('PLAYER_OFFENSE.csv (auto-loaded)');
                        console.log(`[AdvancedPlayerView] Loaded ${data.length} offense records`);
                        return true;
                    },
                    'PLAYER_DEFENSE.csv': async (url) => {
                        console.log('[AdvancedPlayerView] Loading PLAYER_DEFENSE.csv...');
                        const response = await fetch(url);
                        const text = await response.text();
                        const data = parseCSV(text);
                        setDefenseData(data);
                        setDefenseFile('PLAYER_DEFENSE.csv (auto-loaded)');
                        console.log(`[AdvancedPlayerView] Loaded ${data.length} defense records`);
                        return true;
                    },
                    'TEAM_OFFENSE.csv': async (url) => {
                        console.log('[AdvancedPlayerView] Loading TEAM_OFFENSE.csv...');
                        const response = await fetch(url);
                        const text = await response.text();
                        const data = parseCSV(text);
                        // Team offense is used for team utilities
                        setTeamUtilitiesData(data);
                        setTeamUtilFile('TEAM_OFFENSE.csv (auto-loaded)');
                        console.log(`[AdvancedPlayerView] Loaded ${data.length} team offense records`);
                        return true;
                    },
                    'TEAM_DEFENSE.csv': async (url) => {
                        console.log('[AdvancedPlayerView] Loading TEAM_DEFENSE.csv...');
                        const response = await fetch(url);
                        const text = await response.text();
                        // Team defense data - stored for potential future use
                        console.log(`[AdvancedPlayerView] Loaded TEAM_DEFENSE.csv`);
                        return true;
                    },
                    'utilities.csv': async (url) => {
                        console.log('[AdvancedPlayerView] Loading utilities.csv...');
                        const response = await fetch(url);
                        const text = await response.text();
                        const data = parseCSV(text);
                        setUtilitiesData(data);
                        setUtilitiesFile('utilities.csv (auto-loaded)');
                        console.log(`[AdvancedPlayerView] Loaded ${data.length} utility records`);
                        return true;
                    },
                    'utilities_player.csv': async (url) => {
                        console.log('[AdvancedPlayerView] Loading utilities_player.csv...');
                        const response = await fetch(url);
                        const text = await response.text();
                        const data = parseCSV(text);
                        setPlayerUtilitiesData(data);
                        setPlayerUtilFile('utilities_player.csv (auto-loaded)');
                        console.log(`[AdvancedPlayerView] Loaded ${data.length} player utility records`);
                        return true;
                    },
                    'team_utilities.csv': async (url) => {
                        console.log('[AdvancedPlayerView] Loading team_utilities.csv...');
                        const response = await fetch(url);
                        const text = await response.text();
                        const data = parseCSV(text);
                        setTeamUtilitiesData(data);
                        setTeamUtilFile('team_utilities.csv (auto-loaded)');
                        console.log(`[AdvancedPlayerView] Loaded ${data.length} team utility records`);
                        return true;
                    }
                };

                try {
                    // Load files in parallel
                    const loadPromises = [];

                    for (const fileInfo of dataFiles) {
                        const handler = fileHandlers[fileInfo.name];
                        if (handler) {
                            loadPromises.push(handler(fileInfo.url).catch(err => {
                                console.error(`[AdvancedPlayerView] Error loading ${fileInfo.name}:`, err);
                                return false;
                            }));
                        } else {
                            console.log(`[AdvancedPlayerView] No handler for file: ${fileInfo.name}`);
                        }
                    }

                    // Wait for all files to load
                    await Promise.all(loadPromises);

                    console.log('[AdvancedPlayerView] Data loading complete!');
                    setIsLoading(false);

                    // Send acknowledgment back to parent
                    if (window.parent !== window) {
                        window.parent.postMessage({
                            source: 'slb-child-app',
                            type: 'DATA_LOADED',
                            appType: appType
                        }, '*');
                    }

                } catch (error) {
                    console.error('[AdvancedPlayerView] Error loading data files:', error);
                    setIsLoading(false);
                }
            }
        };

        window.addEventListener('message', handleParentMessage);

        // Notify parent that this app is ready to receive data
        if (window.parent !== window) {
            window.parent.postMessage({
                source: 'slb-child-app',
                type: 'APP_READY',
                appType: 'advanced-player-view'
            }, '*');
            console.log('[AdvancedPlayerView] Sent APP_READY to parent');
        }

        return () => {
            window.removeEventListener('message', handleParentMessage);
        };
    }, []); // Empty deps - only run once on mount

    // Precompute all player data (metrics, scales, percentiles) once on data load
    // IMPORTANT: Pool is built from ALL seasons to ensure stable percentile comparisons
    // The player's displayed stats are filtered by selectedSeasons separately
    // NOTE: This must be defined early so duplicate info is available for filtering
    const precomputedData = useMemo(() => {
        if (!offenseData.length) {
            return {
                allRadarMetrics: [],
                roleGroupedMetrics: {},
                scales: { leagueWide: null, byRole: {} },
                playerLookup: {},
                duplicateInfo: {},
                ready: false
            };
        }
        // Use ALL seasons for the percentile pool (not filtered by selectedSeasons)
        const allSeasons = [...new Set(offenseData.map(r => r['Season']))];
        return precomputeAllPlayerData(
            offenseData, 
            defenseData, 
            teamUtilitiesData, 
            playerUtilitiesData, 
            allSeasons
        );
    }, [offenseData, defenseData, teamUtilitiesData, playerUtilitiesData]);
    
    // Alias for backward compatibility
    const radarScalesData = precomputedData;
    
    // Calculate duplicate counts for UI display
    const duplicateCount = useMemo(() => {
        if (!radarScalesData?.allRadarMetrics) return 0;
        return radarScalesData.allRadarMetrics.filter(m => m._isDuplicate).length;
    }, [radarScalesData]);
    
    // Diagnostic: Log excluded duplicate data
    useEffect(() => {
        if (!radarScalesData?.allRadarMetrics || radarScalesData.allRadarMetrics.length === 0) return;
        
        const duplicates = radarScalesData.allRadarMetrics.filter(m => m._isDuplicate);
        const utilitiesOnlyDupes = radarScalesData.allRadarMetrics.filter(m => m._utilitiesDuplicate && !m._isDuplicate);
        
        if (duplicates.length > 0 || utilitiesOnlyDupes.length > 0) {
            console.log('\n');
            console.log('           DUPLICATE DATA DETECTION SUMMARY                 ');
            console.log('');
            
            if (duplicates.length > 0) {
                console.log(`  EXCLUDED PLAY TYPE DUPLICATES: ${duplicates.length} season(s)`);
                console.log('');
                duplicates.forEach(d => {
                    console.log(`    ${d.player} - ${d.season}`);
                    console.log(`      ${d._duplicateSimilarity?.toFixed(1)}% similar to: ${d._duplicateOf}`);
                });
            }
            
            if (utilitiesOnlyDupes.length > 0) {
                console.log('');
                console.log(`   UTILITIES DUPLICATES (not excluded): ${utilitiesOnlyDupes.length} season(s)`);
                utilitiesOnlyDupes.forEach(d => {
                    console.log(`    ${d.player} - ${d.season} (similar utils to ${d._utilitiesDuplicateOf})`);
                });
            }
            
            console.log('');
            if (useDuplicateData) {
                console.log('  STATUS: Duplicates INCLUDED (toggle is ON)             ');
            } else {
                console.log('  STATUS: Duplicates EXCLUDED (toggle is OFF - default)  ');
            }
            console.log('\n');
        }
    }, [radarScalesData, useDuplicateData]);
    
    // Get unique teams
    const teams = useMemo(() => {
        if (!offenseData.length) return [];
        return [...new Set(offenseData.map(d => d['Team']))].filter(t => t).sort();
    }, [offenseData]);
    
    // Get unique players (filtered by team)
    const players = useMemo(() => {
        if (!offenseData.length) return [];
        let filteredData = offenseData;
        if (selectedTeam && selectedTeam !== 'All Teams') {
            filteredData = offenseData.filter(d => d['Team'] === selectedTeam);
        }
        return [...new Set(filteredData.map(d => d['Player Name']))].filter(p => p).sort();
    }, [offenseData, selectedTeam]);
    
    // Get available seasons for selected player (excludes duplicates unless useDuplicateData is true)
    const availableSeasons = useMemo(() => {
        if (!selectedPlayer || !offenseData.length) return [];
        const playerRows = offenseData.filter(row => row['Player Name'] === selectedPlayer);
        let seasons = [...new Set(playerRows.map(r => r['Season']))].filter(s => s).sort();
        
        // Exclude duplicate seasons unless useDuplicateData is enabled
        if (!useDuplicateData && radarScalesData?.allRadarMetrics) {
            const duplicateSeasons = radarScalesData.allRadarMetrics
                .filter(m => m.player === selectedPlayer && m._isDuplicate)
                .map(m => m.season);
            seasons = seasons.filter(s => !duplicateSeasons.includes(s));
        }
        
        return seasons;
    }, [offenseData, selectedPlayer, useDuplicateData, radarScalesData]);
    
    // Auto-select first player when team changes or on initial load
    useEffect(() => {
        if (players.length > 0 && (!selectedPlayer || !players.includes(selectedPlayer))) {
            setSelectedPlayer(players[0]);
        }
    }, [players, selectedPlayer]);
    
    // Auto-select all seasons when player changes
    useEffect(() => {
        if (availableSeasons.length > 0) {
            setSelectedSeasons(availableSeasons);
        }
    }, [availableSeasons]);
    
    // Filter offense data by selected seasons
    // When no seasons selected, return empty but keep UI functional
    // Excludes duplicate seasons unless useDuplicateData is enabled
    const filteredOffenseData = useMemo(() => {
        if (!offenseData.length) return offenseData;
        if (!selectedSeasons.length) return []; // No seasons selected = no data to display
        
        let filtered = offenseData.filter(row => selectedSeasons.includes(row['Season']));
        
        // Exclude duplicate seasons unless useDuplicateData is enabled
        if (!useDuplicateData && radarScalesData?.allRadarMetrics) {
            const duplicatePlayerSeasons = new Set(
                radarScalesData.allRadarMetrics
                    .filter(m => m._isDuplicate)
                    .map(m => `${m.player}|${m.season}`)
            );
            filtered = filtered.filter(row => {
                const key = `${row['Player Name']}|${row['Season']}`;
                return !duplicatePlayerSeasons.has(key);
            });
        }
        
        return filtered;
    }, [offenseData, selectedSeasons, useDuplicateData, radarScalesData]);
    
    // Filter defense data by selected seasons
    // Excludes duplicate seasons unless useDuplicateData is enabled
    const filteredDefenseData = useMemo(() => {
        if (!defenseData.length) return defenseData;
        if (!selectedSeasons.length) return []; // No seasons selected = no data
        
        let filtered = defenseData.filter(row => selectedSeasons.includes(row['Season']));
        
        // Exclude duplicate seasons unless useDuplicateData is enabled
        if (!useDuplicateData && radarScalesData?.allRadarMetrics) {
            const duplicatePlayerSeasons = new Set(
                radarScalesData.allRadarMetrics
                    .filter(m => m._isDuplicate)
                    .map(m => `${m.player}|${m.season}`)
            );
            filtered = filtered.filter(row => {
                const key = `${row['Player Name']}|${row['Season']}`;
                return !duplicatePlayerSeasons.has(key);
            });
        }
        
        return filtered;
    }, [defenseData, selectedSeasons, useDuplicateData, radarScalesData]);
    
    // Track if we have data loaded (even if no seasons selected)
    const hasDataLoaded = offenseData.length > 0;
    
    // Aggregate player data (using filtered data)
    const playerData = useMemo(() => {
        if (!selectedPlayer || !filteredOffenseData.length) return null;
        return aggregatePlayerData(filteredOffenseData, utilitiesData, selectedPlayer);
    }, [selectedPlayer, filteredOffenseData, utilitiesData]);
    
    // Calculate all players data for percentiles
    const allPlayersData = useMemo(() => {
        if (!filteredOffenseData.length) return [];
        return players.map(p => aggregatePlayerData(filteredOffenseData, utilitiesData, p)).filter(d => d);
    }, [filteredOffenseData, utilitiesData, players]);
    
    // Get matching possessions from team/player utilities for per-75 calculations
    const matchedPossessions = useMemo(() => {
        if (!selectedPlayer || !teamUtilitiesData.length || !playerUtilitiesData.length) return null;
        
        // Get player's rows from offense data
        const playerRows = filteredOffenseData.filter(row => row['Player Name'] === selectedPlayer);
        if (playerRows.length === 0) return null;
        
        // Helper to parse minutes - handles "'MM:SS", "MM:SS" format or plain decimal
        const parseMinutes = (minStr) => {
            if (!minStr) return 0;
            // Remove leading quote if present (Excel artifact)
            let str = String(minStr).trim().replace(/^['"]/, '');
            if (str.includes(':')) {
                const parts = str.split(':');
                return parseFloat(parts[0]) + (parseFloat(parts[1] || 0) / 60);
            }
            return parseFloat(str) || 0;
        };
        
        // Helper to normalize date formats for comparison
        // Handles: "12/7/25 12:13" and "12/05/25 2:30 PM" -> "12/7/25"
        const normalizeDate = (dateStr) => {
            if (!dateStr) return '';
            const str = String(dateStr).trim();
            // Extract date part (before time)
            const datePart = str.split(' ')[0];
            // Split into M/D/YY
            const parts = datePart.split('/');
            if (parts.length !== 3) return str;
            // Remove leading zeros and return normalized
            const month = parseInt(parts[0], 10);
            const day = parseInt(parts[1], 10);
            const year = parts[2];
            return `${month}/${day}/${year}`;
        };
        
        // Helper to extract season year from full season string
        // "2025-2026 Cheshire - International" -> "2025-2026"
        const getSeasonYear = (season) => {
            if (!season) return '';
            return season.split(' ')[0]; // Gets "2025-2026"
        };
        
        // Helper to check if a team_utilities row is an empty indicator row
        // (has Team Name + Player Name + Season but no game data)
        const isEmptyIndicatorRow = (row) => {
            const gameNum = row['GAME #'];
            const poss = row['POSS'] || row['Poss'];
            return (!gameNum || gameNum === '') && (!poss || poss === '' || parseNum(poss) === 0);
        };
        
        // Get selected season years for matching
        const selectedSeasonYears = selectedSeasons.map(s => getSeasonYear(s));
        
        // Get duplicate seasons for this player (to exclude from utilities matching)
        const duplicateSeasons = (!useDuplicateData && radarScalesData?.allRadarMetrics)
            ? new Set(radarScalesData.allRadarMetrics
                .filter(m => m.player === selectedPlayer && m._isDuplicate)
                .map(m => m.season))
            : new Set();
        
        // PLAYER UTILITIES: Match by Player Name + Season Year (excluding duplicate seasons)
        const playerUtils = playerUtilitiesData.filter(row => {
            const rowSeason = row['Season'];
            const rowSeasonYear = getSeasonYear(rowSeason);
            
            // Skip if this is a duplicate season
            if (duplicateSeasons.has(rowSeason)) return false;
            
            return row['Player Name'] === selectedPlayer &&
                   selectedSeasonYears.includes(rowSeasonYear);
        });
        
        // Create a map of player's normalized dates to their data
        // Also track team name and season for matching
        const playerDataMap = {};
        playerUtils.forEach(row => {
            const rawDate = row['DATE'] || row['Date'];
            const date = normalizeDate(rawDate);
            const season = row['Season'];
            const teamName = row['Team Name'] || row['Team'];
            
            if (date) {
                playerDataMap[date] = {
                    season,
                    teamName,
                    poss: parseNum(row['POSS'] || row['Poss']),
                    min: parseMinutes(row['MIN']),
                    fgAtt: parseNum(row['FG ATT']),
                    fgMade: parseNum(row['FG MADE']),
                    ftAtt: parseNum(row['FT ATT']),
                    stl: parseNum(row['STL']),
                    blk: parseNum(row['BLK']),
                    oreb: parseNum(row['OFF REB']),
                    dreb: parseNum(row['DEF REB']),
                    ast: parseNum(row['AST']),
                    to: parseNum(row['TO']),
                    pts: parseNum(row['PTS'])
                };
            }
        });
        
        // Get the normalized dates the player actually played
        const playerDates = Object.keys(playerDataMap);
        
        // TEAM UTILITIES: Build two lookups for matching flexibility
        // 1. Primary: Team Name + Season Year + Date (matches precomputation)
        // 2. Fallback: Full Season + Date (handles team name mismatches like "Cheshire Phoenix" vs "Surrey Scorchers")
        const teamUtilsLookup = {};
        const seasonDateLookup = {};  // Fallback: season -> date -> data
        
        teamUtilitiesData.forEach(row => {
            if (isEmptyIndicatorRow(row)) return; // Skip empty indicator rows
            
            const teamName = row['Team Name'] || row['Team'];
            const season = row['Season'];
            const rowSeasonYear = getSeasonYear(season);
            const rawDate = row['DATE'] || row['Date'];
            const date = normalizeDate(rawDate);
            const poss = parseNum(row['POSS'] || row['Poss']);
            const gameNum = row['GAME #'];
            
            // Skip rows without valid data
            if (!teamName || !date || (!gameNum && !poss)) return;
            if (!selectedSeasonYears.includes(rowSeasonYear)) return;
            
            const teamData = {
                poss: poss,
                fgAtt: parseNum(row['FG ATT']),
                fgMade: parseNum(row['FG MADE']),
                ftAtt: parseNum(row['FT ATT']),
                to: parseNum(row['TO'])
            };
            
            // Primary lookup: team -> seasonYear -> date
            if (!teamUtilsLookup[teamName]) teamUtilsLookup[teamName] = {};
            if (!teamUtilsLookup[teamName][rowSeasonYear]) teamUtilsLookup[teamName][rowSeasonYear] = {};
            if (!teamUtilsLookup[teamName][rowSeasonYear][date]) {
                teamUtilsLookup[teamName][rowSeasonYear][date] = teamData;
            }
            
            // Fallback lookup: full season string -> date (for team name mismatches)
            if (!seasonDateLookup[season]) seasonDateLookup[season] = {};
            if (!seasonDateLookup[season][date]) {
                seasonDateLookup[season][date] = teamData;
            }
        });
        
        // Match team data for each player game date
        // Primary: Team Name + Season Year + Date
        // Fallback: Full Season + Date (handles cases like Surrey/Cheshire name mismatch)
        const teamDataMap = {};
        playerDates.forEach(date => {
            const pData = playerDataMap[date];
            if (!pData) return;
            
            const teamName = pData.teamName;
            const season = pData.season;
            const seasonYear = getSeasonYear(season);
            
            // Try primary lookup: Team Name + Season Year + Date
            let tData = teamUtilsLookup[teamName]?.[seasonYear]?.[date];
            
            // Fallback: Full Season + Date (for team name mismatches)
            if (!tData) {
                tData = seasonDateLookup[season]?.[date];
            }
            
            if (tData) {
                teamDataMap[date] = tData;
            }
        });
        
        // FALLBACK: If player utilities is empty but we have offense data,
        // try matching team utilities by Team Name from offense data
        if (playerUtils.length === 0) {
            const offenseTeams = [...new Set(playerRows.map(r => r['Team']))];
            
            // Try to find team data for any matching team/season
            offenseTeams.forEach(teamName => {
                selectedSeasonYears.forEach(seasonYear => {
                    const seasonData = teamUtilsLookup[teamName]?.[seasonYear];
                    if (seasonData) {
                        Object.entries(seasonData).forEach(([date, tData]) => {
                            if (!teamDataMap[date]) {
                                teamDataMap[date] = tData;
                            }
                        });
                    }
                });
            });
        }
        
        // Calculate totals - only for dates where BOTH team and player data exist
        let totalTeamPoss = 0;
        let totalPlayerPoss = 0;
        let totalPlayerMin = 0;
        let totalTeamMin = 0; // Assumed 40 min per game
        let totalPlayerFgAtt = 0, totalPlayerFgMade = 0, totalPlayerFtAtt = 0, totalPlayerTo = 0;
        let totalTeamFgAtt = 0, totalTeamFgMade = 0, totalTeamFtAtt = 0, totalTeamTo = 0;
        let totalStl = 0, totalBlk = 0, totalOreb = 0, totalDreb = 0;
        let totalAst = 0, totalPts = 0;
        let matchedGames = 0;
        
        playerDates.forEach(date => {
            if (teamDataMap[date] !== undefined) {
                const pData = playerDataMap[date];
                const tData = teamDataMap[date];
                
                totalTeamPoss += tData.poss;
                totalPlayerPoss += pData.poss;
                totalPlayerMin += pData.min;
                totalTeamMin += 40; // Assumed 40 min per game (no OT parsing)
                
                // For usage% calculation
                totalPlayerFgAtt += pData.fgAtt;
                totalPlayerFgMade += pData.fgMade || 0;
                totalPlayerFtAtt += pData.ftAtt;
                totalPlayerTo += pData.to;
                totalTeamFgAtt += tData.fgAtt;
                totalTeamFgMade += tData.fgMade || 0;
                totalTeamFtAtt += tData.ftAtt;
                totalTeamTo += tData.to;
                
                // Box score stats
                totalStl += pData.stl;
                totalBlk += pData.blk;
                totalOreb += pData.oreb;
                totalDreb += pData.dreb;
                totalAst += pData.ast;
                totalPts += pData.pts;
                matchedGames++;
            }
        });
        
        // Calculate Usage% using proper formula:
        // Usage% = 100 * ((FGA + 0.44*FTA + TO) * (Team_Total_Minutes / 5)) / ((Team_FGA + 0.44*Team_FTA + Team_TO) * Player_Minutes)
        // Where Team_Total_Minutes = 5 players  game length = 200 for 40-min game
        // Since we use totalTeamMin = 40 per game (just game length), we don't divide by 5
        // This is equivalent to: 100 * playerPoss * 40 / (teamPoss * playerMin) per game
        const playerPossEstimate = totalPlayerFgAtt + (0.44 * totalPlayerFtAtt) + totalPlayerTo;
        const teamPossEstimate = totalTeamFgAtt + (0.44 * totalTeamFtAtt) + totalTeamTo;
        const usagePct = (teamPossEstimate > 0 && totalPlayerMin > 0) 
            ? 100 * (playerPossEstimate * totalTeamMin) / (teamPossEstimate * totalPlayerMin)
            : 0;
        
        // Calculate AST% = 100 * PlayerAST / (TeamFGM - PlayerFGM)
        // This measures what % of teammate field goals the player assisted on
        const teammatesFgMade = totalTeamFgMade - totalPlayerFgMade;
        const astPct = teammatesFgMade > 0 ? (totalAst / teammatesFgMade) * 100 : 0;
        
        // Calculate TO% = 100 * TO / (FGA + 0.44*FTA + TO)
        // This measures turnovers as a % of possessions used
        const toPct = playerPossEstimate > 0 ? (totalPlayerTo / playerPossEstimate) * 100 : 0;
        
        // Calculate per-75 possessions helper
        // Formula: stat * (gameMin / playerMin) * (75 / teamPace)
        // = stat * 75 * totalTeamMin / (totalPlayerMin * totalTeamPoss)
        // This normalizes for playing time, then adjusts for pace
        const per75 = (value) => (totalTeamPoss > 0 && totalPlayerMin > 0) 
            ? (value * 75 * totalTeamMin) / (totalPlayerMin * totalTeamPoss)
            : 0;
        
        // Debug log for matching
        console.log(`Utilities matching for ${selectedPlayer}: ${matchedGames} games matched, ${playerDates.length} player dates, teamPoss=${totalTeamPoss}, playerMin=${totalPlayerMin.toFixed(1)}, AST%=${astPct.toFixed(1)}, TO%=${toPct.toFixed(1)}`);
        
        return {
            totalTeamPoss,
            totalPlayerPoss,
            totalPlayerMin: Math.round(totalPlayerMin * 100) / 100, // Round to 2 decimal places
            totalTeamMin,
            games: matchedGames,
            usagePct,
            astPct,
            toPct,
            // Box score totals
            totalStl,
            totalBlk,
            totalOreb,
            totalDreb,
            totalAst,
            totalTo: totalPlayerTo,
            totalPts,
            // Per-75 stats
            stl75: per75(totalStl),
            blk75: per75(totalBlk),
            oreb75: per75(totalOreb),
            dreb75: per75(totalDreb),
            ast75: per75(totalAst),
            to75: per75(totalPlayerTo)
        };
    }, [selectedPlayer, teamUtilitiesData, playerUtilitiesData, filteredOffenseData, selectedSeasons, useDuplicateData, radarScalesData]);
    
    // Get defense data for selected player
    const playerDefenseData = useMemo(() => {
        if (!selectedPlayer || !filteredDefenseData.length) return null;
        return filteredDefenseData.filter(row => row['Player Name'] === selectedPlayer);
    }, [selectedPlayer, filteredDefenseData]);
    
    // Get enhanced stats for selected player
    const playerEnhancedStats = useMemo(() => {
        if (!selectedPlayer || !enhancedStatsData.length) return null;
        const playerStats = enhancedStatsData.filter(row => 
            row['Player Name'] === selectedPlayer &&
            selectedSeasons.includes(row['Season'])
        );
        if (playerStats.length === 0) return null;
        
        // Aggregate enhanced stats
        let totalGames = 0;
        let totalAst = 0, totalStl = 0, totalBlk = 0, totalOreb = 0, totalDreb = 0;
        let totalUsage = 0, totalAstPct = 0;
        
        playerStats.forEach(row => {
            const games = parseNum(row['Games'] || row['GP'] || row['Games Played'] || 1);
            totalGames += games;
            totalAst += parseNum(row['AST'] || row['Assists'] || 0) * games;
            totalStl += parseNum(row['STL'] || row['Steals'] || 0) * games;
            totalBlk += parseNum(row['BLK'] || row['Blocks'] || 0) * games;
            totalOreb += parseNum(row['OREB'] || row['Offensive Rebounds'] || 0) * games;
            totalDreb += parseNum(row['DREB'] || row['Defensive Rebounds'] || 0) * games;
            if (row['USG%'] || row['Usage']) {
                totalUsage += parseNum(row['USG%'] || row['Usage'] || 0) * games;
            }
            if (row['AST%'] || row['Assist Percentage']) {
                totalAstPct += parseNum(row['AST%'] || row['Assist Percentage'] || 0) * games;
            }
        });
        
        return totalGames > 0 ? {
            astPerGame: totalAst / totalGames,
            stlPerGame: totalStl / totalGames,
            blkPerGame: totalBlk / totalGames,
            orebPerGame: totalOreb / totalGames,
            drebPerGame: totalDreb / totalGames,
            usagePct: totalUsage / totalGames,
            astPct: totalAstPct / totalGames,
            games: totalGames
        } : null;
    }, [selectedPlayer, enhancedStatsData, selectedSeasons]);
    
    // Calculate league percentiles
    const leaguePercentiles = useMemo(() => {
        if (!allPlayersData.length) return null;
        return calculateLeaguePercentiles(allPlayersData);
    }, [allPlayersData]);
    
    const pools = leaguePercentiles?.pools || {};
    
    // Build role-based pools for role-specific percentiles
    const rolePools = useMemo(() => {
        if (!offenseData.length) return {};
        return buildRoleBasedPools(offenseData);
    }, [offenseData]);
    
    // Calculate section-specific data
    const sectionData = useMemo(() => {
        if (!playerData) return null;
        
        return {
            cns: getShootingCnSData(playerData.rawRows, playerData.totalGames, playerData.totalPoss),
            pnr: getPnRBHData(playerData.rawRows, playerData.totalGames, playerData.totalPoss),
            transition: getTransitionData(playerData.rawRows, playerData.totalGames, playerData.totalPoss, playerData),
            spotUp: getSpotUpData(playerData.rawRows, playerData.totalGames),
            rollMan: getPnRRollManData(playerData.rawRows, playerData.totalGames),
            offScreen: getOffScreenData(playerData.rawRows, playerData.totalGames),
            postUp: getPostUpData(playerData.rawRows, playerData.totalGames),
            slashing: getSlashingData(playerData.rawRows, playerData.totalGames, playerData.totalPoss),
            isolation: getIsolationData(playerData.rawRows, playerData.totalGames, playerData.totalPoss)
        };
    }, [playerData]);
    
    // Upload screen
    if (!offenseData.length) {
        return e('div', { className: 'container' },
            e('div', { className: 'header' },
                e('h1', null, 'PLAYER BREAKDOWN ANALYZER'),
                e('p', { className: 'header-subtitle' }, 'Comprehensive individual player play-type analysis & scout reports')
            ),
            e('div', { className: 'upload-screen' },
                e('div', { className: 'upload-box' },
                    e('div', { className: 'upload-icon' }, ''),
                    e('div', { className: 'upload-title' }, 'Upload Data Files'),
                    e('p', { className: 'upload-desc' }, 
                        'Upload your data files to begin analysis. Required: Offense CSV. Optional: Defense, Utilities for enhanced metrics.'
                    ),
                    e('div', { className: 'upload-buttons', style: { flexWrap: 'wrap', gap: '8px' } },
                        e('label', null,
                            e('input', { 
                                type: 'file', 
                                accept: '.csv', 
                                onChange: handleOffenseUpload, 
                                style: { display: 'none' } 
                            }),
                            e('div', { className: 'upload-btn primary' }, ' Offense CSV')
                        ),
                        e('label', null,
                            e('input', { 
                                type: 'file', 
                                accept: '.csv', 
                                onChange: handleDefenseUpload, 
                                style: { display: 'none' } 
                            }),
                            e('div', { className: 'upload-btn secondary' }, ' Defense CSV')
                        ),
                        e('label', null,
                            e('input', { 
                                type: 'file', 
                                accept: '.csv', 
                                onChange: handleUtilitiesUpload, 
                                style: { display: 'none' } 
                            }),
                            e('div', { className: 'upload-btn secondary' }, ' Utilities CSV')
                        ),
                        e('label', null,
                            e('input', { 
                                type: 'file', 
                                accept: '.csv', 
                                onChange: handleTeamUtilitiesUpload, 
                                style: { display: 'none' } 
                            }),
                            e('div', { className: 'upload-btn secondary' }, ' Team Utils CSV')
                        ),
                        e('label', null,
                            e('input', { 
                                type: 'file', 
                                accept: '.csv', 
                                onChange: handlePlayerUtilitiesUpload, 
                                style: { display: 'none' } 
                            }),
                            e('div', { className: 'upload-btn secondary' }, ' Player Utils CSV')
                        )
                    ),
                    e('div', { style: { marginTop: '12px', fontSize: '0.75rem' } },
                        offenseFile && e('div', { className: 'file-indicator' }, ' ', offenseFile),
                        defenseFile && e('div', { className: 'file-indicator' }, ' ', defenseFile),
                        utilitiesFile && e('div', { className: 'file-indicator' }, ' ', utilitiesFile),
                        teamUtilFile && e('div', { className: 'file-indicator' }, ' ', teamUtilFile),
                        playerUtilFile && e('div', { className: 'file-indicator' }, ' ', playerUtilFile)
                    ),
                    isLoading && e('div', { style: { marginTop: '16px', color: 'var(--text-muted)' } }, 'Loading...')
                )
            )
        );
    }
    
    // Main dashboard
    return e('div', { className: 'container' },
        // Header
        e('div', { className: 'header' },
            e('h1', null, 'PLAYER BREAKDOWN ANALYZER'),
            playerData && e('div', { className: 'header-meta' },
                e('div', { className: 'header-meta-item' },
                    e('span', null, ''),
                    e('span', { className: 'value' }, playerData.playerName)
                ),
                e('div', { className: 'header-meta-item' },
                    e('span', null, ''),
                    e('span', { className: 'value' }, playerData.team)
                ),
                e('div', { className: 'header-meta-item' },
                    e('span', null, ''),
                    e('span', { className: 'value' }, playerData.totalGames + ' games')
                ),
                e('div', { className: 'header-meta-item' },
                    e('span', null, ''),
                    e('span', { className: 'value' }, players.length + ' players loaded')
                )
            )
        ),
        
        // Controls
        e('div', { className: 'controls' },
            e('div', { className: 'control-group' },
                e('label', { className: 'control-label' }, 'Select Team'),
                e('select', { 
                    className: 'control-select',
                    value: selectedTeam, 
                    onChange: (ev) => setSelectedTeam(ev.target.value)
                }, 
                    e('option', { value: 'All Teams' }, 'All Teams'),
                    teams.map(t => e('option', { key: t, value: t }, t))
                )
            ),
            e('div', { className: 'control-group' },
                e('label', { className: 'control-label' }, 'Select Player'),
                e('select', { 
                    className: 'control-select',
                    value: selectedPlayer, 
                    onChange: (ev) => setSelectedPlayer(ev.target.value)
                }, players.map(p => e('option', { key: p, value: p }, p)))
            ),
            e('div', { className: 'control-buttons', style: { flexWrap: 'wrap' } },
                e('label', null,
                    e('input', { 
                        type: 'file', 
                        accept: '.csv', 
                        onChange: handleOffenseUpload, 
                        style: { display: 'none' } 
                    }),
                    e('button', { className: 'control-btn' }, ' Off')
                ),
                e('label', null,
                    e('input', { 
                        type: 'file', 
                        accept: '.csv', 
                        onChange: handleDefenseUpload, 
                        style: { display: 'none' } 
                    }),
                    e('button', { className: 'control-btn' }, ' Def')
                ),
                e('label', null,
                    e('input', { 
                        type: 'file', 
                        accept: '.csv', 
                        onChange: handleTeamUtilitiesUpload, 
                        style: { display: 'none' } 
                    }),
                    e('button', { className: 'control-btn' }, ' TmU')
                ),
                e('label', null,
                    e('input', { 
                        type: 'file', 
                        accept: '.csv', 
                        onChange: handlePlayerUtilitiesUpload, 
                        style: { display: 'none' } 
                    }),
                    e('button', { className: 'control-btn' }, ' PlU')
                ),
                // Duplicate data toggle
                duplicateCount > 0 && e('button', { 
                    className: `control-btn ${useDuplicateData ? 'active' : ''}`,
                    onClick: () => setUseDuplicateData(!useDuplicateData),
                    title: useDuplicateData 
                        ? `Click to exclude ${duplicateCount} duplicate season(s)` 
                        : `Click to include ${duplicateCount} duplicate season(s)`,
                    style: {
                        marginLeft: '8px',
                        background: useDuplicateData ? 'rgba(251, 146, 60, 0.3)' : 'var(--surface-lighter)',
                        borderColor: useDuplicateData ? '#fb923c' : 'var(--border-color)'
                    }
                }, useDuplicateData ? ` ${duplicateCount} Dupes` : ` ${duplicateCount} Excluded`)
            )
        ),
        
        // Tabs Navigation
        e('div', { className: 'tabs-container' },
            e('div', { className: 'tabs-nav' },
                e('button', { 
                    className: `tab-btn ${activeTab === 'main' ? 'active' : ''}`,
                    onClick: () => setActiveTab('main')
                }, '', ' Main'),
                e('button', { 
                    className: `tab-btn ${activeTab === 'profiles' ? 'active' : ''}`,
                    onClick: () => setActiveTab('profiles')
                }, '', ' Profiles'),
                e('button', { 
                    className: `tab-btn ${activeTab === 'playerProfile' ? 'active' : ''}`,
                    onClick: () => setActiveTab('playerProfile')
                }, '', ' Player Profile'),
                e('button', { 
                    className: `tab-btn ${activeTab === 'possession' ? 'active' : ''}`,
                    onClick: () => setActiveTab('possession')
                }, '', ' Possession')
            )
        ),
        
        // Tabbed Content
        hasDataLoaded ? (
            e('div', null,
                // Main Tab - Requires player selection
                activeTab === 'main' && e('div', { className: 'tab-transition-wrapper', key: 'main-tab' },
                    playerData && sectionData ? e(ScoutReportMainTab, {
                        playerData,
                        sectionData,
                        matchedPoss: matchedPossessions,
                        playerDefenseData,
                        playerEnhancedStats,
                        availableSeasons,
                        selectedSeasons,
                        toggleSeason,
                        playerPhoto,
                        handlePhotoUpload,
                        scoutNotes,
                        setScoutNotes,
                        pools,
                        rolePools,
                        offenseData,
                        radarScalesData,
                        onPlayerSelect: setSelectedPlayer,
                        selectedPlayer,
                        openScreenshotModal
                    }) : e('div', { className: 'no-seasons-container', style: { 
                            padding: '40px', 
                            textAlign: 'center',
                            color: 'var(--text-muted)'
                        } },
                        e('div', { style: { fontSize: '48px', marginBottom: '16px' } }, ''),
                        e('h2', { style: { color: 'var(--text-primary)', marginBottom: '12px' } }, 
                            selectedSeasons.length === 0 ? 'No Seasons Selected' : 'Select a Player'
                        ),
                        e('p', { style: { marginBottom: '24px' } }, 
                            selectedSeasons.length === 0 
                                ? 'Please select at least one season to view player data.'
                                : 'Use the dropdown above to select a player.'
                        ),
                        selectedSeasons.length === 0 && availableSeasons.length > 0 && e('div', { 
                            className: 'season-chips',
                            style: { justifyContent: 'center', marginTop: '20px' }
                        },
                            availableSeasons.map(season => 
                                e('label', { 
                                    key: season, 
                                    className: `season-chip ${selectedSeasons.includes(season) ? 'selected' : ''}`,
                                    style: { cursor: 'pointer' }
                                },
                                    e('input', {
                                        type: 'checkbox',
                                        checked: selectedSeasons.includes(season),
                                        onChange: () => toggleSeason(season),
                                        style: { display: 'none' }
                                    }),
                                    season
                                )
                            )
                        )
                    )
                ),
                
                // Profiles Tab - Works independently with radarScalesData
                activeTab === 'profiles' && e('div', { className: 'tab-transition-wrapper', key: 'profiles-tab' },
                    radarScalesData?.ready ? e(ProfilesTab, {
                        radarScalesData,
                        offenseData,
                        defenseData,
                        onPlayerSelect: (player) => {
                            setSelectedPlayer(player);
                            setActiveTab('playerProfile');
                        },
                        selectedPlayer,
                        selectedSeasons,
                        teamUtilitiesData,
                        playerUtilitiesData,
                        useDuplicateData
                    }) : e('div', { className: 'no-seasons-container', style: { 
                            padding: '40px', 
                            textAlign: 'center',
                            color: 'var(--text-muted)'
                        } },
                        e('div', { style: { fontSize: '48px', marginBottom: '16px' } }, ''),
                        e('h2', { style: { color: 'var(--text-primary)', marginBottom: '12px' } }, 
                            'Loading Player Data...'
                        ),
                        e('p', null, 'Please wait while player metrics are being calculated.')
                    )
                ),
                
                // Player Profile Tab - Detailed individual player view
                activeTab === 'playerProfile' && e('div', { className: 'tab-transition-wrapper', key: 'profile-tab' },
                    playerData && sectionData ? e(PlayerProfileTab, {
                        playerData,
                        sectionData,
                        matchedPoss: matchedPossessions,
                        playerDefenseData,
                        playerEnhancedStats,
                        radarScalesData,
                        pools,
                        rolePools,
                        selectedPlayer,
                        availableSeasons,
                        selectedSeasons,
                        toggleSeason,
                        players,
                        setSelectedPlayer,
                        playerPhoto,
                        handlePhotoUpload,
                        openScreenshotModal
                    }) : e('div', { className: 'no-seasons-container', style: { 
                            padding: '40px', 
                            textAlign: 'center',
                            color: 'var(--text-muted)'
                        } },
                        e('div', { style: { fontSize: '64px', marginBottom: '20px' } }, ''),
                        e('h2', { style: { color: 'var(--text-primary)', marginBottom: '12px' } }, 
                            'No Player Selected'
                        ),
                        e('p', { style: { marginBottom: '24px' } }, 
                            'Select a player from the Profiles tab or use the dropdown above to view their detailed profile.'
                        )
                    )
                ),
                
                // Possession Breakdown Tab
                activeTab === 'possession' && e('div', { className: 'tab-transition-wrapper', key: 'possession-tab' },
                    e(PossessionSunburst, { 
                        offenseData, 
                        selectedPlayer,
                        availableSeasons
                    })
                ),
                
                // Screenshot Modal - clones actual DOM content from sourceElementId
                screenshotModal.open && e(ScreenshotModal, {
                    isOpen: screenshotModal.open,
                    onClose: closeScreenshotModal,
                    onCapture: captureScreenshot,
                    screenshotRef: screenshotRef,
                    title: screenshotModal.title,
                    section: screenshotModal.section,
                    sourceElementId: screenshotModal.sourceElementId,
                    playerName: screenshotModal.playerName || playerData?.playerName || selectedPlayer,
                    playerTeam: screenshotModal.playerTeam || playerData?.team,
                    playerPhoto: playerPhoto,
                    playerRole: screenshotModal.playerRole,
                    selectedSeasons: selectedSeasons
                })
            )
        ) : e(LoadingState)
    );
}

// Render the app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(e(App));

console.log('Part 5 loaded successfully - Main App ready');

    </script>
</body>
</html>
