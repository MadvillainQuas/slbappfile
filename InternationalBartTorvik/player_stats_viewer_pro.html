<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player Stats Viewer - Interactive (with Free Agents)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; padding: 0; background: linear-gradient(135deg, #0d1117 0%, #161b22 50%, #0d1117 100%); min-height: 100vh; color: #e6edf3; }
        .container { max-width: 100%; margin: 0 auto; background: transparent; padding: 0; }
        
        /* App Header */
        .app-header { background: linear-gradient(90deg, #0d1117 0%, #1a1f2e 50%, #0d1117 100%); padding: 15px 30px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #30363d; }
        h1 { text-align: left; color: #e6edf3; margin: 0; font-size: 20px; background: linear-gradient(90deg, #00d4ff, #00ff88); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        
        /* Collapsible Upload Section */
        .upload-toggle { background: linear-gradient(90deg, #21262d, #30363d); padding: 10px 30px; cursor: pointer; display: flex; align-items: center; gap: 10px; border-bottom: 1px solid #30363d; }
        .upload-toggle:hover { background: linear-gradient(90deg, #30363d, #3d444d); }
        .upload-toggle-icon { transition: transform 0.3s ease; color: #00d4ff; }
        .upload-toggle.collapsed .upload-toggle-icon { transform: rotate(-90deg); }
        .upload-section { display: flex; gap: 15px; padding: 20px 30px; background: #161b22; border-bottom: 1px solid #30363d; flex-wrap: wrap; transition: all 0.3s ease; max-height: 500px; overflow: hidden; }
        .upload-section.collapsed { max-height: 0; padding: 0 30px; border-bottom: none; }
        .upload-box { flex: 1; min-width: 140px; padding: 15px; border: 2px dashed #30363d; border-radius: 8px; text-align: center; cursor: pointer; transition: all 0.3s; background: #21262d; color: #8b949e; }
        .upload-box:hover { border-color: #00d4ff; background: rgba(0, 212, 255, 0.05); box-shadow: 0 0 15px rgba(0, 212, 255, 0.2); }
        .upload-box.loaded { border-color: #00ff88 !important; border-style: solid; background: rgba(0, 255, 136, 0.1) !important; color: #00ff88; }
        
        /* Instructions - hidden by default when data loaded */
        .instructions { background: rgba(255, 193, 7, 0.1); padding: 15px 30px; border-bottom: 1px solid #30363d; border-left: 4px solid #ffc107; }
        .instructions h3 { margin-bottom: 10px; color: #ffc107; font-size: 14px; }
        .instructions ul { margin-left: 20px; color: #8b949e; font-size: 12px; }
        .instructions.hidden { display: none; }
        
        /* Filter Section - Sleek Contemporary Design */
        .filter-section { margin: 0; padding: 20px 30px; background: #161b22; border-bottom: 1px solid #30363d; max-height: none; overflow: visible; }
        .filter-header { display: flex; align-items: center; gap: 15px; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #30363d; }
        .filter-title { font-size: 12px; font-weight: 600; color: #00d4ff; text-transform: uppercase; letter-spacing: 1px; display: flex; align-items: center; gap: 8px; }
        .filter-row { display: flex; gap: 12px; margin-bottom: 12px; flex-wrap: wrap; align-items: center; }
        .filter-item { display: flex; align-items: center; gap: 6px; background: #21262d; padding: 8px 12px; border-radius: 8px; border: 1px solid #30363d; transition: all 0.2s ease; }
        .filter-item:hover { border-color: #484f58; }
        .filter-item label { font-size: 10px; font-weight: 600; white-space: nowrap; color: #8b949e; text-transform: uppercase; letter-spacing: 0.5px; }
        .filter-item select, .filter-item input { padding: 6px 10px; border: 1px solid #484f58; border-radius: 6px; font-size: 11px; background: #30363d; color: #e6edf3; transition: all 0.2s ease; }
        .filter-item select:focus, .filter-item input:focus { outline: none; border-color: #00d4ff; box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2); }
        .filter-item input[type="number"] { width: 65px; }
        .filter-item input[type="text"] { width: 180px; }
        .filter-item input::placeholder { color: #6e7681; }
        
        /* Height filter dropdowns */
        .height-filter-group { display: flex; gap: 4px; align-items: center; }
        .height-filter-group select { width: 52px; }
        .height-filter-group span { color: #6e7681; font-size: 10px; font-weight: 500; }
        
        /* Name search box */
        .name-search-box { position: relative; flex: 1; max-width: 220px; }
        .name-search-box input { padding: 8px 12px 8px 36px !important; width: 100% !important; background: #21262d; border: 1px solid #30363d; border-radius: 8px; }
        .name-search-box::before { content: 'üîç'; position: absolute; left: 12px; top: 50%; transform: translateY(-50%); font-size: 12px; opacity: 0.7; }
        
        /* League Filter - Sleek Dropdown */
        .league-filter-container { position: relative; width: 100%; margin-bottom: 15px; }
        .league-filter-toggle { display: flex; align-items: center; justify-content: space-between; padding: 10px 15px; background: #21262d; border: 1px solid #30363d; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; }
        .league-filter-toggle:hover { border-color: #484f58; background: #262c36; }
        .league-filter-toggle .toggle-text { font-size: 11px; font-weight: 600; color: #e6edf3; }
        .league-filter-toggle .toggle-count { font-size: 10px; color: #8b949e; margin-left: 10px; }
        .league-filter-toggle .toggle-icon { color: #00d4ff; font-size: 10px; transition: transform 0.2s ease; }
        .league-filter-toggle.open .toggle-icon { transform: rotate(180deg); }
        .league-checkboxes { display: none; position: absolute; top: calc(100% + 5px); left: 0; right: 0; background: #21262d; border: 1px solid #30363d; border-radius: 8px; padding: 12px; max-height: 250px; overflow-y: auto; z-index: 100; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4); }
        .league-checkboxes.show { display: block; }
        .league-checkboxes-header { display: flex; gap: 8px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #30363d; }
        .league-checkboxes-header button { padding: 4px 12px; font-size: 10px; background: #30363d; border: 1px solid #484f58; border-radius: 4px; color: #e6edf3; cursor: pointer; transition: all 0.2s ease; }
        .league-checkboxes-header button:hover { background: #3d444d; border-color: #00d4ff; }
        .league-checkbox-item { display: flex; align-items: center; padding: 6px 8px; margin: 2px 0; border-radius: 4px; cursor: pointer; transition: background 0.2s ease; }
        .league-checkbox-item:hover { background: #30363d; }
        .league-checkbox-item input[type="checkbox"] { margin-right: 10px; accent-color: #00d4ff; width: 14px; height: 14px; }
        .league-checkbox-item span { font-size: 11px; color: #e6edf3; }
        
        /* Filter Grid Layout */
        .filter-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px; }
        .filter-grid-row { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px; margin-bottom: 10px; }
        
        /* Stat Filters Grid */
        .stat-filters-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 8px; padding-top: 15px; border-top: 1px solid #30363d; margin-top: 15px; }
        .stat-filter-item { display: flex; align-items: center; gap: 5px; background: rgba(33, 38, 45, 0.6); padding: 6px 10px; border-radius: 6px; border: 1px solid transparent; }
        .stat-filter-item:hover { border-color: #30363d; }
        .stat-filter-item label { font-size: 9px; font-weight: 600; color: #8b949e; min-width: 45px; }
        .stat-filter-item input { width: 50px; padding: 4px 6px; font-size: 10px; background: #30363d; border: 1px solid #484f58; border-radius: 4px; color: #e6edf3; }
        
        button { padding: 8px 18px; background: rgba(0, 212, 255, 0.15); color: #00d4ff; border: 1px solid #00d4ff; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: 600; transition: all 0.2s ease; }
        button:hover { background: rgba(0, 212, 255, 0.25); box-shadow: 0 0 15px rgba(0, 212, 255, 0.3); }
        button.reset { background: rgba(248, 81, 73, 0.15); color: #f85149; border-color: #f85149; }
        button.reset:hover { background: rgba(248, 81, 73, 0.25); box-shadow: 0 0 15px rgba(248, 81, 73, 0.3); }
        
        .table-container { overflow-x: auto; max-height: 70vh; overflow-y: auto; padding: 0 30px 30px 30px; background: #0d1117; position: relative; }
        table { width: 100%; border-collapse: separate; border-spacing: 0; font-size: 11px; background: #161b22; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3); }
        thead { position: sticky; top: 0; z-index: 10; }
        thead tr { background: #1c2128; }
        th { padding: 12px 8px; text-align: center; cursor: pointer; user-select: none; font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 2px solid #30363d; transition: color 0.2s, background 0.2s; color: #8b949e; background: #1c2128; font-weight: 600; }
        th:hover { color: #00d4ff; background: #21262d !important; }
        .group-basic { background: #1c2128 !important; }
        .group-shooting { background: #162516 !important; color: #00ff88 !important; }
        .group-advanced { background: #161625 !important; color: #00d4ff !important; }
        .group-impact { background: #251625 !important; color: #ff6b9d !important; }
        .group-free-agent { background: #251a10 !important; color: #ff6b00 !important; }
        td { padding: 10px 8px; text-align: center; border-bottom: 1px solid rgba(48, 54, 61, 0.5); }
        tbody tr { background: #161b22; transition: background 0.15s ease; }
        tbody tr:nth-child(even) { background: #1a1f26; }
        tr:hover td { background: rgba(0, 212, 255, 0.08) !important; }
        tr.dragging { opacity: 0.5; background: rgba(255, 235, 59, 0.3) !important; }
        tr.drop-target { background: rgba(0, 255, 136, 0.2) !important; border: 2px dashed #00ff88; }
        .player-name { text-align: left; cursor: pointer; color: #58a6ff; font-weight: 600; transition: all 0.2s; }
        .player-name:hover { color: #79c0ff; text-decoration: underline; }
        .row-link { color: #6e7681; font-size: 10px; text-decoration: none; font-weight: 600; transition: all 0.2s; }
        .row-link:hover { color: #00d4ff; }
        .row-link:visited { color: #a371f7; }
        .player-link { color: #58a6ff; text-decoration: none; font-weight: 600; }
        .player-link:hover { color: #79c0ff; text-decoration: underline; }
        .team-cell { font-weight: 600; color: #e6edf3; }
        .editable-cell { cursor: pointer; padding: 2px 4px; border-radius: 4px; transition: background 0.15s ease; }
        .editable-cell:hover { background: rgba(0, 212, 255, 0.15); }
        .editable-cell.editing { background: #30363d; }
        .editable-cell.edited { background: rgba(255, 235, 59, 0.15); font-weight: bold; }
        .edit-input { width: 50px; padding: 2px 4px; font-size: 11px; border: 1px solid #00d4ff; border-radius: 4px; text-align: center; background: #30363d; color: #e6edf3; }
        .edit-input.nat-input { width: 40px; text-transform: uppercase; }
        .edit-input.ht-input { width: 50px; }
        td:nth-child(8), th:nth-child(8) { border-right: 2px solid #30363d; }
        td:nth-child(16), th:nth-child(16) { border-right: 2px solid #30363d; }
        td:nth-child(23), th:nth-child(23) { border-right: 2px solid #30363d; }
        td:nth-child(30), th:nth-child(30) { border-right: 2px solid #30363d; }
        th:nth-child(8), th:nth-child(16), th:nth-child(23), th:nth-child(30) { border-right: 2px solid #484f58; }
        
        /* Percentile Colors - Vibrant */
        .pct-90 { background: rgba(0, 255, 136, 0.3) !important; color: #00ff88 !important; font-weight: 600; }
        .pct-80 { background: rgba(0, 255, 136, 0.2) !important; color: #4ade80 !important; }
        .pct-70 { background: rgba(0, 200, 100, 0.15) !important; color: #86efac !important; }
        .pct-60 { background: rgba(0, 180, 80, 0.08) !important; color: #a7f3d0 !important; }
        .pct-50 { background: transparent !important; color: #e6edf3 !important; }
        .pct-40 { background: rgba(251, 146, 60, 0.08) !important; color: #fed7aa !important; }
        .pct-30 { background: rgba(251, 146, 60, 0.15) !important; color: #fb923c !important; }
        .pct-20 { background: rgba(248, 81, 73, 0.2) !important; color: #f87171 !important; }
        .pct-10 { background: rgba(248, 81, 73, 0.3) !important; color: #f85149 !important; font-weight: 600; }
        
        /* Modal */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85); backdrop-filter: blur(8px); }
        .modal-content { background: linear-gradient(135deg, #161b22, #21262d); margin: 3% auto; padding: 30px; border-radius: 16px; width: 90%; max-width: 900px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5); border: 1px solid #30363d; }
        .close { color: #8b949e; float: right; font-size: 28px; font-weight: bold; cursor: pointer; transition: all 0.2s; }
        .close:hover { color: #f85149; }
        #modalPlayerName { text-align: center; margin-bottom: 20px; color: #58a6ff; font-size: 24px; font-weight: 600; }
        #radarChart { width: 100% !important; max-width: 800px !important; height: 600px !important; margin: 15px auto; }
        .chart-container { background: #0d1117; padding: 20px; border-radius: 12px; border: 1px solid #30363d; }
        
        /* View Mode Toggle Styles - Contemporary */
        .view-mode-section { display: flex; gap: 15px; align-items: center; padding: 15px 30px; background: #0d1117; border-bottom: 1px solid #30363d; flex-wrap: wrap; }
        .view-mode-label { font-size: 11px; font-weight: 600; color: #6e7681; text-transform: uppercase; letter-spacing: 1px; }
        .view-mode-btn { padding: 10px 22px; font-size: 11px; font-weight: 600; border: 1px solid #30363d; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; background: #161b22; color: #8b949e; }
        .view-mode-btn.all-players:hover, .view-mode-btn.all-players.active { background: linear-gradient(135deg, #00d4ff 0%, #00a0cc 100%); border-color: transparent; color: #fff; box-shadow: 0 4px 20px rgba(0, 212, 255, 0.4); transform: translateY(-1px); }
        .view-mode-btn.free-agents:hover, .view-mode-btn.free-agents.active { background: linear-gradient(135deg, #ff6b00 0%, #cc5500 100%); border-color: transparent; color: #fff; box-shadow: 0 4px 20px rgba(255, 107, 0, 0.4); transform: translateY(-1px); }
        .view-mode-btn.export-view { background: #161b22; border: 1px solid #8b5cf6; color: #8b5cf6; }
        .view-mode-btn.export-view:hover, .view-mode-btn.export-view.active { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); border-color: transparent; color: #fff; box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4); transform: translateY(-1px); }
        .view-mode-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none !important; }
        .view-mode-info { font-size: 11px; color: #6e7681; }
        
        /* Stats Summary - Modern Cards */
        .stats-summary { display: flex; gap: 15px; margin: 0; padding: 20px 30px; flex-wrap: wrap; background: #0d1117; border-bottom: 1px solid #30363d; }
        .stat-box { flex: 1; min-width: 140px; padding: 18px 20px; background: linear-gradient(135deg, #161b22 0%, #1c2128 100%); border: 1px solid #30363d; color: #e6edf3; border-radius: 12px; text-align: center; transition: all 0.2s ease; position: relative; overflow: hidden; }
        .stat-box::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px; background: linear-gradient(90deg, #00d4ff, #00ff88); opacity: 0; transition: opacity 0.2s ease; }
        .stat-box:hover { border-color: #484f58; transform: translateY(-2px); }
        .stat-box:hover::before { opacity: 1; }
        .stat-box h4 { font-size: 10px; margin-bottom: 8px; color: #6e7681; text-transform: uppercase; letter-spacing: 1.5px; font-weight: 500; }
        .stat-box .value { font-size: 28px; font-weight: 700; color: #00d4ff; }
        .stat-box#freeAgentStatBox { border-color: rgba(255, 107, 0, 0.3); }
        .stat-box#freeAgentStatBox::before { background: linear-gradient(90deg, #ff6b00, #ff9500); }
        .stat-box#freeAgentStatBox .value { color: #ff6b00; }
        
        /* Free Agent specific styles */
        .fa-status-active { color: #ff6b00; font-weight: bold; }
        .fa-last-game { font-size: 9px; color: #ff6b00; }
        .fa-missed-games { background: rgba(248, 81, 73, 0.2); color: #f85149; padding: 2px 8px; border-radius: 12px; font-size: 9px; font-weight: 600; }
        
        /* Job Market specific styles */
        .view-mode-btn.job-market:hover, .view-mode-btn.job-market.active { 
            background: linear-gradient(135deg, #10b981 0%, #059669 100%); 
            border-color: transparent; 
            color: #fff; 
            box-shadow: 0 4px 20px rgba(16, 185, 129, 0.4); 
            transform: translateY(-1px); 
        }
        .jm-season-badge { 
            background: rgba(16, 185, 129, 0.2); 
            color: #10b981; 
            padding: 2px 6px; 
            border-radius: 4px; 
            font-size: 9px; 
            font-weight: 600; 
        }
        .jm-league-badge { 
            font-size: 9px; 
            color: #8b949e; 
        }
        .stat-box#jobMarketStatBox { border-color: rgba(16, 185, 129, 0.3); }
        .stat-box#jobMarketStatBox::before { background: linear-gradient(90deg, #10b981, #34d399); }
        .stat-box#jobMarketStatBox .value { color: #10b981; }
        
        /* Collapsible row styles for Job Market */
        .jm-expandable { cursor: pointer; }
        .jm-expandable:hover { background: rgba(16, 185, 129, 0.08) !important; }
        .jm-expandable td:first-child { position: relative; padding-left: 25px; }
        .jm-expand-icon { 
            position: absolute; 
            left: 8px; 
            top: 50%; 
            transform: translateY(-50%); 
            color: #10b981; 
            font-size: 10px; 
            transition: transform 0.2s ease;
            font-weight: bold;
        }
        .jm-expandable.expanded .jm-expand-icon { transform: translateY(-50%) rotate(90deg); }
        .jm-child-row { 
            display: none; 
            background: rgba(16, 185, 129, 0.03) !important; 
        }
        .jm-child-row.visible { display: table-row; }
        .jm-child-row td { 
            padding: 6px 8px !important; 
            font-size: 10px !important; 
            color: #8b949e !important;
            border-bottom: 1px dashed rgba(48, 54, 61, 0.3) !important;
        }
        .jm-child-row td:first-child { padding-left: 35px !important; }
        .jm-child-row .player-name { color: #6b8b9e !important; font-weight: normal !important; }
        .jm-primary-season { font-weight: 600; color: #10b981; }
        .jm-seasons-indicator { 
            font-size: 9px; 
            color: #6b7280; 
            margin-left: 5px;
            background: rgba(107, 114, 128, 0.2);
            padding: 1px 5px;
            border-radius: 3px;
        }
        .jm-last-team { font-size: 9px; color: #10b981; }
        .jm-last-year { font-size: 9px; color: #6b7280; }
        .group-job-market { background: #0f2318 !important; color: #10b981 !important; }
        
        /* Status Bar */
        #statusBar { padding: 8px 30px; background: #161b22; border-bottom: 1px solid #30363d; font-size: 11px; display: flex; justify-content: space-between; align-items: center; }
        #statusBar span { color: #8b949e; }
        #statusBar #statusLeft { color: #00d4ff; font-weight: 600; display: flex; align-items: center; gap: 8px; }
        #statusBar #statusLeft::before { content: ''; width: 6px; height: 6px; background: #00d4ff; border-radius: 50%; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        /* Debug Console */
        #debugConsole { margin: 0; padding: 10px 30px; background: rgba(13, 17, 23, 0.95); border-top: 1px solid #30363d; font-family: 'Consolas', monospace; font-size: 10px; max-height: 120px; overflow-y: auto; color: #8b949e; }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #21262d; }
        ::-webkit-scrollbar-thumb { background: #484f58; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6e7681; }
        
        /* Export View Styles - Social Media Ready */
        .export-view-container { display: none; padding: 20px; background: #0a0e13; min-height: 100vh; }
        .export-view-container.active { display: block; }
        .export-controls { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; padding: 15px; background: #161b22; border-radius: 10px; border: 1px solid #30363d; flex-wrap: wrap; }
        .export-controls label { font-size: 12px; color: #8b949e; font-weight: 600; }
        .export-controls input[type="number"] { width: 80px; padding: 8px 12px; background: #21262d; border: 1px solid #30363d; border-radius: 6px; color: #e6edf3; font-size: 14px; }
        .export-controls input[type="number"]:focus, .export-controls input[type="text"]:focus { outline: none; border-color: #00d4ff; }
        .export-controls button { padding: 10px 20px; }
        .export-info { font-size: 11px; color: #6e7681; margin-left: auto; }
        
        /* Instagram Frame - Premium Social Media Design */
        .instagram-frame { 
            width: 100%; 
            max-width: 1080px; 
            margin: 0 auto; 
            background: linear-gradient(165deg, #0f1419 0%, #1a1f2e 30%, #0d1117 70%, #0a0e13 100%);
            border-radius: 16px; 
            padding: 30px; 
            min-height: 1350px; 
            position: relative;
            box-shadow: 0 0 80px rgba(0, 212, 255, 0.15), 0 0 40px rgba(139, 92, 246, 0.1);
            overflow: hidden;
        }
        .instagram-frame::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #00d4ff 0%, #8b5cf6 50%, #ff6b00 100%);
        }
        .instagram-frame::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(ellipse at 20% 0%, rgba(0, 212, 255, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(139, 92, 246, 0.08) 0%, transparent 50%);
            pointer-events: none;
        }
        
        /* Header Styling */
        .instagram-header { 
            text-align: center; 
            margin-bottom: 25px; 
            padding-bottom: 20px; 
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
            position: relative;
            z-index: 1;
        }
        .instagram-header h2 { 
            font-size: 32px; 
            color: #ffffff; 
            margin: 0; 
            font-weight: 800; 
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.5), 0 0 60px rgba(0, 212, 255, 0.3);
            background: linear-gradient(135deg, #ffffff 0%, #00d4ff 50%, #ffffff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .instagram-header .subtitle { 
            font-size: 12px; 
            color: #8b949e; 
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: 600;
        }
        
        /* Player Cards Grid - 5 per row */
        .player-cards-grid { 
            display: grid; 
            grid-template-columns: repeat(5, 1fr); 
            gap: 14px;
            position: relative;
            z-index: 1;
        }
        
        /* Premium Player Card */
        .player-card { 
            background: linear-gradient(145deg, rgba(30, 37, 46, 0.9) 0%, rgba(22, 27, 34, 0.95) 100%);
            border: 1px solid rgba(48, 54, 61, 0.8);
            border-radius: 12px; 
            padding: 14px; 
            transition: all 0.3s ease;
            display: flex; 
            flex-direction: column;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        .player-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #00d4ff, #8b5cf6);
            opacity: 0.8;
        }
        .player-card:hover { 
            border-color: #00d4ff; 
            transform: translateY(-3px) scale(1.02); 
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4), 0 0 20px rgba(0, 212, 255, 0.2);
        }
        
        /* Card Header - Player Info */
        .card-header { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            margin-bottom: 12px; 
            padding-bottom: 10px; 
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
            position: relative;
        }
        .card-remove-btn { position: absolute; top: -6px; right: -6px; width: 20px; height: 20px; border-radius: 50%; background: #30363d; border: 1px solid #484f58; color: #8b949e; font-size: 14px; line-height: 1; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; opacity: 0; z-index: 10; }
        .player-card:hover .card-remove-btn { opacity: 1; }
        .card-remove-btn:hover { background: #f85149; border-color: #f85149; color: #fff; transform: scale(1.1); }
        .player-photo-placeholder { 
            width: 44px; 
            height: 44px; 
            border-radius: 50%; 
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 2px solid #484f58; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            overflow: hidden; 
            flex-shrink: 0; 
            cursor: pointer; 
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .player-photo-placeholder img { width: 100%; height: 100%; object-fit: cover; position: relative; z-index: 1; }
        .player-photo-placeholder:not(:has(img))::before { content: 'üì∑'; font-size: 16px; }
        .player-photo-placeholder:hover { border-color: #00d4ff; box-shadow: 0 0 15px rgba(0, 212, 255, 0.4); }
        .card-player-info { flex: 1; min-width: 0; }
        .card-player-name { 
            font-size: 13px; 
            font-weight: 700; 
            color: #ffffff; 
            margin-bottom: 2px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1.2;
            white-space: nowrap;
        }
        .card-player-team { 
            font-size: 10px; 
            color: #00d4ff; 
            white-space: nowrap;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .card-player-meta { font-size: 9px; color: #6e7681; }
        
        /* Card Stats - Categorized Layout */
        .card-stats { display: flex; flex-direction: column; gap: 5px; margin-bottom: 12px; }
        .card-stat-category { 
            display: flex; 
            gap: 4px; 
            padding: 6px 8px; 
            background: rgba(13, 17, 23, 0.6);
            border-radius: 6px; 
            border-left: 3px solid #30363d;
        }
        .card-stat-category.efficiency { border-left-color: #00d4ff; background: rgba(0, 212, 255, 0.05); }
        .card-stat-category.shooting { border-left-color: #8b5cf6; background: rgba(139, 92, 246, 0.05); }
        .card-stat-category.freethrows { border-left-color: #f59e0b; background: rgba(245, 158, 11, 0.05); }
        .card-stat-category.rebounding { border-left-color: #10b981; background: rgba(16, 185, 129, 0.05); }
        .card-stat-category.playmaking { border-left-color: #ec4899; background: rgba(236, 72, 153, 0.05); }
        .card-stat-category.defense { border-left-color: #ef4444; background: rgba(239, 68, 68, 0.05); }
        .card-stat { display: flex; flex-direction: column; align-items: center; flex: 1; min-width: 0; }
        .card-stat-label { font-size: 7px; color: #6e7681; font-weight: 600; text-transform: uppercase; margin-bottom: 1px; }
        .card-stat-value { font-size: 11px; font-weight: 700; color: #e6edf3; }
        /* Override pct-* background for card stat values - text color only */
        .card-stat-value[class*="pct-"], .card-bpm-value[class*="pct-"] { background: transparent !important; }
        
        /* BPM Section - Prominent */
        .card-bpm-section { 
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            border-radius: 8px; 
            padding: 10px; 
            margin-top: auto; 
            border: 1px solid rgba(0, 212, 255, 0.2);
        }
        .card-bpm-title { 
            font-size: 7px; 
            color: #00d4ff; 
            text-transform: uppercase; 
            letter-spacing: 1.5px; 
            margin-bottom: 6px; 
            text-align: center;
            font-weight: 700;
        }
        .card-bpm-values { display: flex; justify-content: center; gap: 10px; }
        .card-bpm-item { text-align: center; flex: 1; }
        .card-bpm-label { font-size: 7px; color: #8b949e; text-transform: uppercase; margin-bottom: 2px; font-weight: 600; }
        .card-bpm-value { font-size: 16px; font-weight: 800; color: #e6edf3; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
        .card-bpm-single { font-size: 24px; }
        
        /* Watermark / Branding */
        .instagram-footer {
            text-align: center;
            margin-top: 25px;
            padding-top: 15px;
            border-top: 1px solid rgba(48, 54, 61, 0.5);
            position: relative;
            z-index: 1;
        }
        .instagram-footer .branding {
            font-size: 10px;
            color: #484f58;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 600;
        }
        
        /* Responsive adjustments */
        @media (max-width: 1200px) { .player-cards-grid { grid-template-columns: repeat(4, 1fr); } }
        @media (max-width: 900px) { .player-cards-grid { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 600px) { .player-cards-grid { grid-template-columns: repeat(2, 1fr); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="app-header">
            <h1>üèÄ Player Stats Viewer Pro</h1>
        </div>
        <div class="instructions" id="instructionsSection">
            <h3>üìñ Instructions</h3>
            <ul>
                <li>Upload <strong>player_stats.csv</strong> and <strong>team_totals.csv</strong> for all players view</li>
                <li><strong style="color: #ff6b00;">Upload definitely_out.csv</strong> to enable Free Agent view mode</li>
                <li><strong style="color: #10b981;">Upload Job Market CSV</strong> to enable Job Market view (collapsible rows, per-game stats)</li>
                <li>Use filters to narrow down players ‚Ä¢ Click headers to sort ‚Ä¢ Click names for radar chart</li>
                <li><strong>Drag and drop</strong> one player onto another to merge stats</li>
            </ul>
            <div id="debugConsole" style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid #30363d; border-radius: 4px; font-family: monospace; font-size: 10px; max-height: 100px; overflow-y: auto; display: none;">
                <strong style="color: #00d4ff;">Debug Log:</strong><br>
                <div id="debugLog"></div>
            </div>
        </div>
        
        <!-- Collapsible Upload Toggle -->
        <div class="upload-toggle" id="uploadToggle" onclick="toggleUploadSection()">
            <span class="upload-toggle-icon" id="uploadToggleIcon">‚ñº</span>
            <span style="font-size: 12px; color: #8b949e;">üìÅ Data Files</span>
        </div>
        
        <div class="upload-section" id="uploadSection">
            <div class="upload-box" id="playerUploadBox">
                <input type="file" id="playerStatsFile" accept=".csv" style="display: none;">
                <div>üìä player_stats.csv</div>
                <div id="playerFileName" style="margin-top: 8px; font-size: 11px;"></div>
            </div>
            <div class="upload-box" id="teamUploadBox">
                <input type="file" id="teamTotalsFile" accept=".csv" style="display: none;">
                <div>üèÜ team_totals.csv</div>
                <div id="teamFileName" style="margin-top: 8px; font-size: 11px;"></div>
            </div>
            <div class="upload-box" id="freeAgentUploadBox" style="border-color: #ff6b00;">
                <input type="file" id="freeAgentFile" accept=".csv" style="display: none;">
                <div style="color: #ff6b00;">üîÑ definitely_out.csv</div>
                <div style="font-size: 9px; color: #8b949e;">Free Agent view</div>
                <div id="freeAgentFileName" style="margin-top: 5px; font-size: 10px;"></div>
            </div>
            <div class="upload-box" id="rawTeamUploadBox">
                <input type="file" id="rawTeamStatsFile" accept=".csv" style="display: none;">
                <div>üìà raw_team_stats.csv</div>
                <div style="font-size: 9px; color: #8b949e;">Optional</div>
                <div id="rawTeamFileName" style="margin-top: 5px; font-size: 10px;"></div>
            </div>
            <div class="upload-box" id="rawOppUploadBox">
                <input type="file" id="rawOppStatsFile" accept=".csv" style="display: none;">
                <div>üõ°Ô∏è raw_opponent_stats.csv</div>
                <div style="font-size: 9px; color: #8b949e;">Optional</div>
                <div id="rawOppFileName" style="margin-top: 5px; font-size: 10px;"></div>
            </div>
            <div class="upload-box" id="rawPlayerUploadBox">
                <input type="file" id="rawPlayerStatsFile" accept=".csv" style="display: none;">
                <div>üåç raw_player_stats.csv</div>
                <div style="font-size: 9px; color: #8b949e;">Optional</div>
                <div id="rawPlayerFileName" style="margin-top: 5px; font-size: 10px;"></div>
            </div>
            <div class="upload-box" id="jobMarketUploadBox" style="border-color: #10b981;">
                <input type="file" id="jobMarketFile" accept=".csv" style="display: none;">
                <div style="color: #10b981;">üìã Job Market CSV</div>
                <div style="font-size: 9px; color: #8b949e;">Free Players</div>
                <div id="jobMarketFileName" style="margin-top: 5px; font-size: 10px;"></div>
            </div>
        </div>
        
        <!-- View Mode Toggle Section -->
        <div class="view-mode-section" id="viewModeSection" style="display: none;">
            <span class="view-mode-label">View:</span>
            <button class="view-mode-btn all-players active" id="btnAllPlayers" onclick="setViewMode('all')">
                üìä All Players
            </button>
            <button class="view-mode-btn free-agents" id="btnFreeAgents" onclick="setViewMode('freeagents')" disabled>
                üîÑ Free Agents
            </button>
            <button class="view-mode-btn job-market" id="btnJobMarket" onclick="setViewMode('jobmarket')" disabled>
                üìã Job Market
            </button>
            <button class="view-mode-btn export-view" id="btnExportView" onclick="setViewMode('export')">
                üì∏ Export View
            </button>
            <span class="view-mode-info" id="viewModeInfo">Upload definitely_out.csv to enable Free Agent view</span>
            
            <div style="margin-left: auto; display: flex; align-items: center; gap: 10px;">
                <label style="font-size: 10px; color: #6e7681; text-transform: uppercase; letter-spacing: 1px;">BPM:</label>
                <select id="bpmTypeSelector" onchange="setBPMType(this.value)" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #30363d; font-size: 11px; cursor: pointer; background: #161b22; color: #e6edf3;">
                    <option value="standard">Standard</option>
                    <option value="linear">Linear</option>
                </select>
            </div>
        </div>
        
        <div class="stats-summary" id="statsSummary" style="display: none;">
            <div class="stat-box"><h4>Total Players</h4><div class="value" id="totalPlayers">0</div></div>
            <div class="stat-box"><h4>Filtered</h4><div class="value" id="filteredPlayers">0</div></div>
            <div class="stat-box"><h4>Displayed</h4><div class="value" id="displayedPlayers">0</div></div>
            <div class="stat-box"><h4>Teams</h4><div class="value" id="totalTeams">0</div></div>
            <div class="stat-box" id="freeAgentStatBox" style="display: none;"><h4>Free Agents</h4><div class="value" id="totalFreeAgents">0</div></div>
            <div class="stat-box" id="jobMarketStatBox" style="display: none;"><h4>Job Market</h4><div class="value" id="totalJobMarket">0</div></div>
        </div>
        <div class="filter-section" id="filterSection" style="display: none;">
            <div class="filter-header">
                <span class="filter-title">‚öôÔ∏è Filters</span>
                <div class="name-search-box">
                    <input type="text" id="nameSearch" placeholder="Search player name..." oninput="applyFiltersDebounced()">
                </div>
                <div style="margin-left: auto; display: flex; gap: 10px;">
                    <button onclick="applyFilters()">Apply Filters</button>
                    <button class="reset" onclick="resetFilters()">Reset</button>
                </div>
            </div>
            <div id="filterContainer"></div>
        </div>
        <div id="statusBar" style="display: none;">
            <span id="statusLeft">Ready</span>
            <span style="float: right;" id="statusRight"></span>
        </div>
        <div class="table-container" id="tableContainer">
            <table id="statsTable">
                <thead id="tableHeader"></thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>
        
        <!-- Export View Container -->
        <div class="export-view-container" id="exportViewContainer">
            <div class="export-controls">
                <label>Title</label>
                <input type="text" id="exportTitleInput" value="Top Players" oninput="updateExportTitle()" style="width: 200px; padding: 8px 12px; background: #21262d; border: 1px solid #30363d; border-radius: 6px; color: #e6edf3; font-size: 14px;">
                <label>Subtitle</label>
                <input type="text" id="exportSubtitleInput" value="Advanced Stats" oninput="updateExportSubtitle()" style="width: 180px; padding: 8px 12px; background: #21262d; border: 1px solid #30363d; border-radius: 6px; color: #e6edf3; font-size: 14px;">
                <label style="margin-left: 15px;">Top</label>
                <input type="number" id="exportPlayerCount" value="20" min="1" max="100">
                <button onclick="generateExportCards()">Generate</button>
                <button class="reset" onclick="setViewMode(previousViewMode || 'all')">Back</button>
                <span class="export-info">üì± Screenshot-ready for Instagram!</span>
            </div>
            <div class="instagram-frame" id="instagramFrame">
                <div class="instagram-header">
                    <h2 id="exportTitle">Top Players</h2>
                    <div class="subtitle" id="exportSubtitle">Stats Overview</div>
                </div>
                <div class="player-cards-grid" id="playerCardsGrid"></div>
                <div class="instagram-footer">
                    <div class="branding">Basketball Analytics ‚Ä¢ Advanced Stats</div>
                </div>
            </div>
        </div>
    </div>
    <div id="radarModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 id="modalPlayerName"></h2>
            <div class="chart-container">
                <canvas id="radarChart"></canvas>
            </div>
        </div>
    </div>
    <script>
        let playerData = [];
        let teamData = [];
        let rawTeamData = [];
        let rawOppData = [];
        let rawPlayerData = [];
        let freeAgentData = [];  // Data from definitely_out.csv
        let jobMarketRawData = [];  // Raw data from Job Market CSV
        let jobMarketData = [];  // Processed Job Market data (grouped by player, per-game stats)
        let filteredData = [];
        let sortColumn = null;
        let sortAscending = true;
        let draggedRow = null;
        let displayLimit = 100;
        const PAGE_SIZE = 100;
        
        // View mode: 'all', 'freeagents', or 'jobmarket'
        let currentViewMode = 'all';
        
        // BPM type: 'standard' or 'linear'
        let currentBPMType = 'standard';
        
        const RENDER_CHUNK_SIZE = 50;
        let isRendering = false;
        let renderQueue = [];
        let cachedTableBody = null;
        let filterDebounceTimer = null;
        const FILTER_DEBOUNCE_MS = 300;
        let sortKeyCache = new Map();
        let percentileCache = {};
        
        // Upload section collapsed state
        let uploadSectionCollapsed = false;

        // Headers for all players mode
        const headersAllPlayers = ['üîó', 'League', 'Season', 'Team', 'Player', 'Age', 'Nat', 'Ht', 'Pos', 'Role', 'Games', 'MPG', 'PPG', 'FG%', '3P%', 'FT%', 'eFG%', 'TS%', 'USG%', 'AST/USG', 'FTr', 'PTS/100', '3PA/100', 'ORB%', 'DRB%', 'TRB%', 'AST%', 'TOV%', 'STL%', 'BLK%', 'BPM', 'OBPM', 'DBPM'];
        
        // Headers for free agents mode (includes Last Game, Missed Games)
        const headersFreeAgents = ['üîó', 'League', 'Country', 'Team', 'Player', 'Age', 'Ht', 'Pos', 'Last Game', 'Missed', 'Games', 'MPG', 'PPG', 'FG%', '3P%', 'FT%', 'eFG%', 'TS%', 'USG%', 'AST/USG', 'FTr', 'PTS/100', '3PA/100', 'ORB%', 'DRB%', 'TRB%', 'AST%', 'TOV%', 'STL%', 'BLK%', 'BPM', 'OBPM', 'DBPM'];
        
        // Headers for job market mode (per-game stats and per-40 stats from CSV)
        const headersJobMarket = ['üîó', 'Player', 'Pos', 'Nat', 'Ht', 'Age', 'Last Team', 'Last Year', 'Season', 'Team', 'League', 'GP', 'MPG', 'PPG', 'RPG', 'APG', 'SPG', 'BPG', 'TPG', 'FG%', '3P%', 'FT%', 'P/40', 'R/40', 'A/40', 'S/40', 'B/40', 'TO/40'];
        
        let headers = headersAllPlayers;
        
        const coloredStatsSet = new Set(['eFG%', 'TS%', 'USG%', 'AST/USG', 'FTr', 'PTS/100', '3PA/100', 'ORB%', 'DRB%', 'TRB%', 'AST%', 'STL%', 'BLK%', 'TOV%', 'BPM', 'OBPM', 'DBPM']);
        const coloredStats = [...coloredStatsSet];
        const inverseStatsSet = new Set(['TOV%']);
        const inverseStats = [...inverseStatsSet];
        
        const headerKeyMap = {
            '#': null, 'League': 'league', 'Season': 'season', 'Team': 'team', 'Country': 'country',
            'Player': 'player_name', 'Age': 'Age', 'Nat': 'Nationality', 'Ht': 'Height_Inches',
            'Pos': '_estimatedPosition', 'Role': '_offensiveRole', 'Last Game': 'last_known_game', 'Missed': 'missed_games',
            'Games': 'Games', 'GP': 'GP', 'MPG': 'MPG', 'PPG': 'PPG',
            'FG%': 'FG%', '3P%': '3P%', 'FT%': 'FT%', 'eFG%': 'eFG%', 'TS%': 'TS%',
            'USG%': 'USG%', 'AST/USG': 'AST/USG', 'FTr': 'FTr', 'PTS/100': 'PTS/100', '3PA/100': '3PA/100',
            'ORB%': 'ORB%', 'DRB%': 'DRB%', 'TRB%': 'TRB%', 'AST%': 'AST%', 'TOV%': 'TOV%',
            'STL%': 'STL%', 'BLK%': 'BLK%', 'BPM': 'BPM', 'OBPM': 'OBPM', 'DBPM': 'DBPM',
            // Job Market specific - per game
            'Last Team': 'last_team', 'Last Year': 'last_year_played',
            'RPG': 'RPG', 'APG': 'APG', 'SPG': 'SPG', 'BPG': 'BPG', 'TPG': 'TPG',
            // Job Market specific - per 40 minutes
            'P/40': 'PTS40', 'R/40': 'REB40', 'A/40': 'AST40', 'S/40': 'STL40', 'B/40': 'BLK40', 'TO/40': 'TOV40'
        };

        function debugLog(message) {
            console.log(message);
            const debugConsole = document.getElementById('debugConsole');
            const debugLog = document.getElementById('debugLog');
            debugConsole.style.display = 'block';
            debugLog.innerHTML += `${message}<br>`;
            debugLog.scrollTop = debugLog.scrollHeight;
        }
        
        // Toggle upload section visibility
        function toggleUploadSection() {
            uploadSectionCollapsed = !uploadSectionCollapsed;
            const section = document.getElementById('uploadSection');
            const toggle = document.getElementById('uploadToggle');
            const icon = document.getElementById('uploadToggleIcon');
            
            if (uploadSectionCollapsed) {
                section.classList.add('collapsed');
                toggle.classList.add('collapsed');
                icon.textContent = '‚ñ∂';
            } else {
                section.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                icon.textContent = '‚ñº';
            }
        }
        
        // Auto-collapse upload section after data loaded
        function autoCollapseUploadSection() {
            if (!uploadSectionCollapsed && playerData.length > 0 && teamData.length > 0) {
                toggleUploadSection();
                document.getElementById('instructionsSection').classList.add('hidden');
            }
        }
        
        // Debounced filter application for name search
        function applyFiltersDebounced() {
            clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(applyFilters, FILTER_DEBOUNCE_MS);
        }

        // Event listeners for uploads
        document.getElementById('playerUploadBox').addEventListener('click', () => { document.getElementById('playerStatsFile').click(); });
        document.getElementById('teamUploadBox').addEventListener('click', () => { document.getElementById('teamTotalsFile').click(); });
        document.getElementById('rawTeamUploadBox').addEventListener('click', () => { document.getElementById('rawTeamStatsFile').click(); });
        document.getElementById('rawOppUploadBox').addEventListener('click', () => { document.getElementById('rawOppStatsFile').click(); });
        document.getElementById('rawPlayerUploadBox').addEventListener('click', () => { document.getElementById('rawPlayerStatsFile').click(); });
        document.getElementById('freeAgentUploadBox').addEventListener('click', () => { document.getElementById('freeAgentFile').click(); });

        // Handle Free Agent CSV upload
        document.getElementById('freeAgentFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                debugLog(`üîÑ Loading free agent data (${(file.size/1024/1024).toFixed(2)} MB)...`);
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        // Store free agent identifiers and FA-specific data for matching
                        freeAgentData = results.data
                            .filter(row => row.player_name && row.player_name.trim())
                            .map(row => ({
                                player_name: row.player_name.trim(),
                                player_url: row.player_url || '',
                                team: row.team || '',
                                country: row.country || '',
                                league: row.league || '',
                                last_known_game: row.last_known_game || '',
                                missed_games: parseInt(row.missed_games) || 0,
                                flagged_at: row.flagged_at || '',
                                // Store position from definitely_out if available
                                position: row.position || '',
                                height: row.height || '',
                                age: row.age || ''
                            }));
                        
                        debugLog(`‚úì Loaded ${freeAgentData.length} free agent identifiers`);
                        document.getElementById('freeAgentFileName').textContent = `‚úì ${file.name} (${freeAgentData.length} players)`;
                        document.getElementById('freeAgentUploadBox').classList.add('loaded');
                        document.getElementById('freeAgentUploadBox').style.borderColor = '#4CAF50';
                        document.getElementById('freeAgentUploadBox').style.background = '#e8f5e9';
                        
                        // Enable Free Agents button
                        document.getElementById('btnFreeAgents').disabled = false;
                        document.getElementById('viewModeInfo').textContent = `${freeAgentData.length} free agents loaded`;
                        document.getElementById('viewModeSection').style.display = 'flex';
                        
                        // Update free agent count
                        document.getElementById('freeAgentStatBox').style.display = 'block';
                        document.getElementById('totalFreeAgents').textContent = freeAgentData.length;
                        
                        // If player data is already loaded, do the matching
                        if (playerData.length > 0) {
                            matchFreeAgentsToPlayerStats();
                        }
                        
                        // If we're in free agent mode, refresh the view
                        if (currentViewMode === 'freeagents') {
                            applyFilters();
                        }
                    },
                    error: function(error) {
                        debugLog(`‚úó ERROR loading free agent data: ${error.message}`);
                        alert('Error loading free agent file: ' + error.message);
                    }
                });
            }
        });
        
        // Match free agents to player stats using URL or name
        let matchedFreeAgents = [];  // Players from playerData that are confirmed free agents
        
        function matchFreeAgentsToPlayerStats() {
            debugLog('Matching free agents to player stats...');
            const startTime = performance.now();
            
            // Build lookup maps for fast matching
            const faByUrl = new Map();
            const faByNameTeam = new Map();
            const faByNameLeague = new Map();
            const faByName = new Map();
            
            for (const fa of freeAgentData) {
                // Primary: URL matching (most reliable)
                if (fa.player_url) {
                    faByUrl.set(fa.player_url, fa);
                }
                // Secondary: Name + Team
                const nameTeamKey = `${fa.player_name.toLowerCase()}|${fa.team.toLowerCase()}`;
                faByNameTeam.set(nameTeamKey, fa);
                // Tertiary: Name + League
                const nameLeagueKey = `${fa.player_name.toLowerCase()}|${fa.league.toLowerCase()}`;
                if (!faByNameLeague.has(nameLeagueKey)) {
                    faByNameLeague.set(nameLeagueKey, fa);
                }
                // Fallback: Just name (may have duplicates, keep first)
                const nameKey = fa.player_name.toLowerCase();
                if (!faByName.has(nameKey)) {
                    faByName.set(nameKey, fa);
                }
            }
            
            matchedFreeAgents = [];
            let matchedByUrl = 0;
            let matchedByNameTeam = 0;
            let matchedByNameLeague = 0;
            let matchedByName = 0;
            
            for (const player of playerData) {
                let faMatch = null;
                let matchType = '';
                
                // Try URL match first
                if (player.player_url && faByUrl.has(player.player_url)) {
                    faMatch = faByUrl.get(player.player_url);
                    matchType = 'url';
                    matchedByUrl++;
                }
                // Try Name + Team
                else {
                    const nameTeamKey = `${(player.player_name || '').toLowerCase()}|${(player.team || '').toLowerCase()}`;
                    if (faByNameTeam.has(nameTeamKey)) {
                        faMatch = faByNameTeam.get(nameTeamKey);
                        matchType = 'name+team';
                        matchedByNameTeam++;
                    }
                    // Try Name + League
                    else {
                        const nameLeagueKey = `${(player.player_name || '').toLowerCase()}|${(player.league || '').toLowerCase()}`;
                        if (faByNameLeague.has(nameLeagueKey)) {
                            faMatch = faByNameLeague.get(nameLeagueKey);
                            matchType = 'name+league';
                            matchedByNameLeague++;
                        }
                        // Try just Name (last resort)
                        else {
                            const nameKey = (player.player_name || '').toLowerCase();
                            if (faByName.has(nameKey)) {
                                faMatch = faByName.get(nameKey);
                                matchType = 'name';
                                matchedByName++;
                            }
                        }
                    }
                }
                
                if (faMatch) {
                    // Create a copy of the player with free agent info added
                    const faPlayer = { ...player };
                    faPlayer.isFreeAgent = true;
                    faPlayer.last_known_game = faMatch.last_known_game;
                    faPlayer.missed_games = faMatch.missed_games;
                    faPlayer.country = faMatch.country || player.Nationality || '';
                    faPlayer.flagged_at = faMatch.flagged_at;
                    faPlayer._matchType = matchType;
                    
                    // Use FA's position/height/age if player data is missing
                    if (!faPlayer._estimatedPosition && faMatch.position) {
                        faPlayer._estimatedPosition = parsePosition(faMatch.position);
                    }
                    if (!faPlayer.Height_Inches && faMatch.height) {
                        faPlayer.Height_Inches = parseHeight(faMatch.height);
                    }
                    if (!faPlayer.Age && faMatch.age) {
                        faPlayer.Age = parseInt(faMatch.age) || 0;
                    }
                    
                    matchedFreeAgents.push(faPlayer);
                }
            }
            
            const elapsed = (performance.now() - startTime).toFixed(0);
            const totalMatched = matchedByUrl + matchedByNameTeam + matchedByNameLeague + matchedByName;
            debugLog(`‚úì Matched ${totalMatched}/${freeAgentData.length} free agents in ${elapsed}ms`);
            debugLog(`  By URL: ${matchedByUrl}, Name+Team: ${matchedByNameTeam}, Name+League: ${matchedByNameLeague}, Name only: ${matchedByName}`);
            
            const unmatched = freeAgentData.length - totalMatched;
            if (unmatched > 0) {
                debugLog(`  ‚ö†Ô∏è ${unmatched} free agents not found in player_stats.csv`);
            }
            
            // Update the displayed count
            document.getElementById('totalFreeAgents').textContent = totalMatched;
            document.getElementById('viewModeInfo').textContent = `${totalMatched}/${freeAgentData.length} free agents matched`;
        }
        
        function parseHeight(heightStr) {
            if (!heightStr || heightStr === '') return 0;
            const numHeight = parseFloat(heightStr);
            if (!isNaN(numHeight)) {
                // Assume cm if > 100
                if (numHeight > 100) {
                    return numHeight / 2.54;
                }
                return numHeight > 12 ? numHeight : numHeight * 12;
            }
            return 0;
        }
        
        function parsePosition(posStr) {
            if (!posStr || posStr === '') return 3;
            const posMap = { 'PG': 1, 'SG': 2, 'G': 1.5, 'SF': 3, 'F': 3.5, 'PF': 4, 'C': 5, 'F/C': 4.5 };
            return posMap[posStr.toUpperCase()] || 3;
        }
        
        function calculateFreeAgentStats(player) {
            const games = player.Games || player.GP || 1;
            const min = player.MIN || 0;
            
            // Calculate MPG and PPG if not provided
            if (!player.MPG && min > 0) player.MPG = min / games;
            if (!player.PPG && player.PTS > 0) player.PPG = player.PTS / games;
            
            // Calculate FTr
            const fga = player.FGA || 0;
            const fta = player.FTA || 0;
            player.FTr = fga > 0 ? (fta / fga) : 0;
            
            // Estimate per-100 stats (rough estimate without team PACE)
            const estPoss = fga + 0.44 * fta + (player.TOV || 0);
            if (estPoss > 0) {
                player['PTS/100'] = player['PTS/100'] || ((player.PTS || 0) / estPoss) * 100;
                player['3PA/100'] = player['3PA/100'] || ((player.ThreePA || 0) / estPoss) * 100;
            }
            
            // Store Standard BPM
            let bpm = player.BPM;
            if (!bpm || isNaN(bpm)) bpm = estimateBPM(player);
            let obpm = player.OBPM;
            if (!obpm || isNaN(obpm)) obpm = bpm * 0.6;
            let dbpm = player.DBPM;
            if (!dbpm || isNaN(dbpm)) dbpm = bpm - obpm;
            
            player.BPM_Standard = bpm;
            player.OBPM_Standard = obpm;
            player.DBPM_Standard = dbpm;
            
            // Store Linear BPM (from CSV if available, otherwise use standard)
            player.BPM_Linear = player.BPM_Linear || bpm;
            player.OBPM_Linear = player.OBPM_Linear || obpm;
            player.DBPM_Linear = player.DBPM_Linear || dbpm;
            
            // Set active BPM based on current selection
            if (currentBPMType === 'linear') {
                player.BPM = player.BPM_Linear;
                player.OBPM = player.OBPM_Linear;
                player.DBPM = player.DBPM_Linear;
            } else {
                player.BPM = player.BPM_Standard;
                player.OBPM = player.OBPM_Standard;
                player.DBPM = player.DBPM_Standard;
            }
        }
        
        let previousViewMode = 'all';
        
        function setViewMode(mode) {
            // Store previous view mode (but not if switching from export back)
            if (currentViewMode !== 'export' && mode === 'export') {
                previousViewMode = currentViewMode;
            }
            
            if (mode === currentViewMode) return;
            
            currentViewMode = mode;
            displayLimit = PAGE_SIZE;
            
            // Update button states
            document.getElementById('btnAllPlayers').classList.toggle('active', mode === 'all');
            document.getElementById('btnFreeAgents').classList.toggle('active', mode === 'freeagents');
            document.getElementById('btnJobMarket').classList.toggle('active', mode === 'jobmarket');
            document.getElementById('btnExportView').classList.toggle('active', mode === 'export');
            
            // Show/hide containers based on mode
            const tableContainer = document.getElementById('tableContainer');
            const exportContainer = document.getElementById('exportViewContainer');
            const filterSection = document.getElementById('filterSection');
            const statsSummary = document.getElementById('statsSummary');
            const loadMoreContainer = document.getElementById('loadMoreContainer');
            
            if (mode === 'export') {
                tableContainer.style.display = 'none';
                exportContainer.classList.add('active');
                if (filterSection) filterSection.style.display = 'none';
                if (statsSummary) statsSummary.style.display = 'none';
                if (loadMoreContainer) loadMoreContainer.style.display = 'none';
                // Initialize title and subtitle inputs with defaults
                const count = parseInt(document.getElementById('exportPlayerCount').value) || 20;
                const modeText = previousViewMode === 'freeagents' ? 'Free Agents' : previousViewMode === 'jobmarket' ? 'Job Market' : 'Players';
                document.getElementById('exportTitleInput').value = `Top ${count} ${modeText}`;
                document.getElementById('exportSubtitleInput').value = `${currentBPMType === 'linear' ? 'Linear' : 'Standard'} BPM ‚Ä¢ Advanced Stats`;
                generateExportCards();
                return;
            } else {
                tableContainer.style.display = 'block';
                exportContainer.classList.remove('active');
                if (filterSection) filterSection.style.display = 'block';
                if (statsSummary) statsSummary.style.display = 'flex';
            }
            
            // Update headers based on mode
            if (mode === 'jobmarket') {
                headers = headersJobMarket;
            } else if (mode === 'freeagents') {
                headers = headersFreeAgents;
            } else {
                headers = headersAllPlayers;
            }
            
            // Update status bar background
            const statusBar = document.getElementById('statusBar');
            statusBar.style.background = '#161b22';
            if (mode === 'freeagents') {
                statusBar.style.color = '#ff6b00';
            } else if (mode === 'jobmarket') {
                statusBar.style.color = '#10b981';
            } else {
                statusBar.style.color = '#00d4ff';
            }
            
            const viewLabels = {
                'all': 'All Players',
                'freeagents': 'Free Agents',
                'jobmarket': 'Job Market'
            };
            debugLog(`Switched to ${viewLabels[mode] || mode} view`);
            
            if (mode === 'freeagents') {
                // Ensure matching is done
                if (matchedFreeAgents.length === 0 && freeAgentData.length > 0 && playerData.length > 0) {
                    matchFreeAgentsToPlayerStats();
                }
                document.getElementById('totalPlayers').textContent = matchedFreeAgents.length.toLocaleString();
            } else if (mode === 'jobmarket') {
                document.getElementById('totalPlayers').textContent = jobMarketData.length.toLocaleString();
            } else {
                // Restore all players data
                document.getElementById('totalPlayers').textContent = playerData.length.toLocaleString();
            }
            
            createFilters();
            applyFilters();
        }
        
        function setBPMType(type) {
            if (type === currentBPMType) return;
            
            currentBPMType = type;
            debugLog(`Switched to ${type === 'linear' ? 'Linear' : 'Standard'} BPM`);
            
            // Update BPM values for all players
            const updateBPMForPlayer = (player) => {
                if (type === 'linear') {
                    player.BPM = player.BPM_Linear || player.BPM_Standard;
                    player.OBPM = player.OBPM_Linear || player.OBPM_Standard;
                    player.DBPM = player.DBPM_Linear || player.DBPM_Standard;
                } else {
                    player.BPM = player.BPM_Standard;
                    player.OBPM = player.OBPM_Standard;
                    player.DBPM = player.DBPM_Standard;
                }
            };
            
            // Update player data
            for (const player of playerData) {
                updateBPMForPlayer(player);
            }
            
            // Update matched free agents (they reference playerData, but let's make sure)
            for (const player of matchedFreeAgents) {
                updateBPMForPlayer(player);
            }
            
            // Recalculate percentiles for BPM stats
            recalculateBPMPercentiles();
            
            // Re-render table
            renderTable();
        }
        
        function recalculateBPMPercentiles() {
            const bpmStats = ['BPM', 'OBPM', 'DBPM'];
            const dataSource = (currentViewMode === 'freeagents') ? matchedFreeAgents : playerData;
            
            const qualifiedPlayers = dataSource.filter(p => {
                const games = p.Games || p.GP || 0;
                const mpg = p.MPG || 0;
                return games >= 3 && mpg >= 5;
            });
            
            for (const stat of bpmStats) {
                const values = [];
                for (const p of qualifiedPlayers) {
                    const val = p[stat];
                    if (val !== null && val !== undefined && !isNaN(val)) {
                        const mpg = p.MPG || 1;
                        const weight = Math.min(mpg, 30) / 30;
                        values.push({ value: +val, weight: weight });
                    }
                }
                
                if (values.length === 0) { percentileCache[stat] = []; continue; }
                
                values.sort((a, b) => a.value - b.value);
                
                let totalWeight = 0;
                for (const v of values) totalWeight += v.weight;
                
                const boundaries = [];
                let cumulativeWeight = 0;
                for (let i = 0; i < values.length; i++) {
                    boundaries[i] = { value: values[i].value, percentile: (cumulativeWeight / totalWeight) * 100 };
                    cumulativeWeight += values[i].weight;
                }
                
                percentileCache[stat] = boundaries;
            }
            
            debugLog(`Recalculated BPM percentiles for ${currentBPMType} mode`);
        }
        
        function processFreeAgentData() {
            if (freeAgentData.length === 0) {
                debugLog('No free agent data loaded');
                return;
            }
            
            debugLog(`Processing ${freeAgentData.length} free agents...`);
            
            // Assign IDs and ensure all stats are calculated
            for (let i = 0; i < freeAgentData.length; i++) {
                freeAgentData[i]._id = i;
            }
            
            // Pre-calculate percentiles for free agents
            preCalculatePercentilesFreeAgents();
            
            document.getElementById('totalPlayers').textContent = freeAgentData.length.toLocaleString();
            
            const teams = [...new Set(freeAgentData.map(p => p.team))];
            document.getElementById('totalTeams').textContent = teams.length;
        }
        
        function preCalculatePercentilesFreeAgents() {
            const dataSource = freeAgentData;
            const statsToCache = [...coloredStats];
            const startTime = performance.now();
            
            // Filter to players with meaningful games
            const qualifiedPlayers = dataSource.filter(p => {
                const games = p.Games || p.GP || 0;
                const mpg = p.MPG || 0;
                return games >= 1 && mpg >= 3;
            });
            
            debugLog(`Free Agent percentiles: ${qualifiedPlayers.length} qualified players`);
            
            for (let s = 0; s < statsToCache.length; s++) {
                const stat = statsToCache[s];
                const values = [];
                
                for (let i = 0; i < qualifiedPlayers.length; i++) {
                    const p = qualifiedPlayers[i];
                    const val = p[stat];
                    if (val !== null && val !== undefined && !isNaN(val)) {
                        const mpg = p.MPG || 1;
                        const weight = Math.min(mpg, 30) / 30;
                        values.push({ value: +val, weight: weight });
                    }
                }
                
                if (values.length === 0) {
                    percentileCache[stat] = [];
                    continue;
                }
                
                values.sort((a, b) => a.value - b.value);
                
                let totalWeight = 0;
                for (let i = 0; i < values.length; i++) {
                    totalWeight += values[i].weight;
                }
                
                const boundaries = [];
                let cumulativeWeight = 0;
                for (let i = 0; i < values.length; i++) {
                    boundaries[i] = { 
                        value: values[i].value, 
                        percentile: (cumulativeWeight / totalWeight) * 100 
                    };
                    cumulativeWeight += values[i].weight;
                }
                
                percentileCache[stat] = boundaries;
            }
            
            const elapsed = (performance.now() - startTime).toFixed(0);
            debugLog(`‚úì Free agent percentiles calculated in ${elapsed}ms`);
        }

        // Handle raw_team_stats.csv upload (optional, for accurate TOV/PACE)
        document.getElementById('rawTeamStatsFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                debugLog(`üìà Loading raw team stats (${(file.size/1024/1024).toFixed(2)} MB)...`);
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rawTeamData = results.data
                            .filter(row => row.totals_type === 'Team_Totals')
                            .map(row => ({
                                league: row.league,
                                season: row.season,
                                team: row.team_full,
                                team_url: row.team_url,
                                GP: row.col_2,
                                MIN: row.col_3,
                                PTS: row.col_4,
                                FGM: row.col_5,
                                FGA: row.col_6,
                                FG_pct: row.col_7,
                                ThreePM: row.col_8,
                                ThreePA: row.col_9,
                                ThreeP_pct: row.col_10,
                                FTM: row.col_11,
                                FTA: row.col_12,
                                FT_pct: row.col_13,
                                OREB: row.col_14,
                                DREB: row.col_15,
                                REB: row.col_16,
                                AST: row.col_17,
                                STL: row.col_18,
                                BLK: row.col_19,
                                TOV: row.col_20,
                                PF: row.col_21
                            }));
                        debugLog(`‚úì Loaded ${rawTeamData.length} teams with TOV data`);
                        document.getElementById('rawTeamFileName').textContent = `‚úì ${file.name} (${rawTeamData.length} teams)`;
                        document.getElementById('rawTeamUploadBox').classList.add('loaded');
                        if (playerData.length > 0 && teamData.length > 0) {
                            debugLog('Reprocessing with raw team data...');
                            processDataOptimized();
                            applyFilters();
                        }
                    }
                });
            }
        });
        
        // Handle raw_opponent_stats.csv upload
        document.getElementById('rawOppStatsFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                debugLog(`üõ°Ô∏è Loading raw opponent stats...`);
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rawOppData = results.data
                            .filter(row => row.totals_type === 'Opp_Totals')
                            .map(row => ({
                                league: row.league,
                                season: row.season,
                                team: row.team_full,
                                team_url: row.team_url,
                                GP: row.col_2,
                                MIN: row.col_3,
                                PTS: row.col_4,
                                FGA: row.col_6,
                                FTA: row.col_12,
                                OREB: row.col_14,
                                TOV: row.col_20
                            }));
                        debugLog(`‚úì Loaded ${rawOppData.length} opponent records`);
                        document.getElementById('rawOppFileName').textContent = `‚úì ${file.name} (${rawOppData.length} records)`;
                        document.getElementById('rawOppUploadBox').classList.add('loaded');
                        if (playerData.length > 0 && teamData.length > 0) {
                            debugLog('Reprocessing with opponent data...');
                            processDataOptimized();
                            applyFilters();
                        }
                    }
                });
            }
        });
        
        // Handle raw_player_stats.csv upload
        document.getElementById('rawPlayerStatsFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                debugLog(`üåç Loading raw player stats for nationality...`);
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rawPlayerData = results.data
                            .filter(row => row.player_name && row.player_name.trim())
                            .map(row => ({
                                player_name: row.player_name,
                                player_url: row.player_url,
                                Nationality: row.Nationality || '',
                                team: row.team,
                                league: row.league,
                                season: row.season
                            }));
                        debugLog(`‚úì Loaded ${rawPlayerData.length} players with nationality data`);
                        document.getElementById('rawPlayerFileName').textContent = `‚úì ${file.name} (${rawPlayerData.length} players)`;
                        document.getElementById('rawPlayerUploadBox').style.background = '#e8f5e9';
                        if (playerData.length > 0 && teamData.length > 0) {
                            debugLog('Reprocessing with nationality data...');
                            processDataOptimized();
                            applyFilters();
                        }
                    }
                });
            }
        });

        // Handle Job Market CSV upload
        document.getElementById('jobMarketFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                debugLog(`üìã Loading Job Market CSV...`);
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        jobMarketRawData = results.data.filter(row => row.player_name && row.player_name.trim());
                        debugLog(`‚úì Loaded ${jobMarketRawData.length} raw Job Market records`);
                        
                        // Process the Job Market data
                        processJobMarketData();
                        
                        document.getElementById('jobMarketFileName').textContent = `‚úì ${file.name} (${jobMarketData.length} players)`;
                        document.getElementById('jobMarketUploadBox').classList.add('loaded');
                        document.getElementById('btnJobMarket').disabled = false;
                        document.getElementById('totalJobMarket').textContent = jobMarketData.length;
                        document.getElementById('jobMarketStatBox').style.display = 'block';
                        document.getElementById('viewModeSection').style.display = 'flex';
                        
                        debugLog(`‚úì Processed ${jobMarketData.length} unique players for Job Market view`);
                    }
                });
            }
        });
        
        // Click handler for Job Market upload box
        document.getElementById('jobMarketUploadBox').addEventListener('click', function() {
            document.getElementById('jobMarketFile').click();
        });
        
        // Process Job Market CSV data - group by player, convert to per-game, sort by GP
        function processJobMarketData() {
            const playerMap = new Map();
            
            for (const row of jobMarketRawData) {
                const playerKey = row.player_url || row.player_name;
                
                if (!playerMap.has(playerKey)) {
                    playerMap.set(playerKey, {
                        player_name: row.player_name,
                        player_url: row.player_url,
                        position: row.position || '',
                        nationality: row.nationality || '',
                        height: row.height || '',
                        birth_year: row.birth_year || '',
                        last_team: row.last_team || '',
                        last_team_country: row.last_team_country || '',
                        last_year_played: row.last_year_played || '',
                        last_game_date: row.last_game_date || '',
                        seasons: []
                    });
                }
                
                // Parse stats from the row
                const gp = parseInt(row.gp) || 0;
                const min = parseInt(row.min) || 0;
                const pts = parseInt(row.pts) || 0;
                
                // Parse shooting stats (format: "made-attempted")
                const fg = parseShootingStat(row.fg);
                const threePt = parseShootingStat(row.three_pt);
                const ft = parseShootingStat(row.ft);
                
                const reb = parseInt(row.reb) || 0;
                const oreb = parseInt(row.oreb) || 0;
                const dreb = parseInt(row.dreb) || 0;
                const ast = parseInt(row.ast) || 0;
                const stl = parseInt(row.stl) || 0;
                const blk = parseInt(row.blk) || 0;
                const tov = parseInt(row.tov) || 0;
                
                // Calculate per-game stats
                const seasonData = {
                    season: row.season || '',
                    team: row.team || '',
                    league: row.league || '',
                    GP: gp,
                    MIN: min,
                    MPG: gp > 0 ? (min / gp) : 0,
                    PPG: gp > 0 ? (pts / gp) : 0,
                    'FG%': fg.attempted > 0 ? (fg.made / fg.attempted * 100) : 0,
                    '3P%': threePt.attempted > 0 ? (threePt.made / threePt.attempted * 100) : 0,
                    'FT%': ft.attempted > 0 ? (ft.made / ft.attempted * 100) : 0,
                    RPG: gp > 0 ? (reb / gp) : 0,
                    OREBPG: gp > 0 ? (oreb / gp) : 0,
                    DREBPG: gp > 0 ? (dreb / gp) : 0,
                    APG: gp > 0 ? (ast / gp) : 0,
                    SPG: gp > 0 ? (stl / gp) : 0,
                    BPG: gp > 0 ? (blk / gp) : 0,
                    TPG: gp > 0 ? (tov / gp) : 0,
                    // Per-40 minute stats
                    PTS40: min > 0 ? (pts / min * 40) : 0,
                    REB40: min > 0 ? (reb / min * 40) : 0,
                    AST40: min > 0 ? (ast / min * 40) : 0,
                    STL40: min > 0 ? (stl / min * 40) : 0,
                    BLK40: min > 0 ? (blk / min * 40) : 0,
                    TOV40: min > 0 ? (tov / min * 40) : 0,
                    // Raw totals for reference
                    PTS: pts,
                    REB: reb,
                    AST: ast,
                    STL: stl,
                    BLK: blk,
                    TOV: tov,
                    FGM: fg.made,
                    FGA: fg.attempted,
                    TPM: threePt.made,
                    TPA: threePt.attempted,
                    FTM: ft.made,
                    FTA: ft.attempted
                };
                
                playerMap.get(playerKey).seasons.push(seasonData);
            }
            
            // Convert to array and sort seasons by GP descending
            jobMarketData = [];
            for (const [key, player] of playerMap) {
                // Sort seasons by GP descending
                player.seasons.sort((a, b) => b.GP - a.GP);
                
                // Calculate age from birth year
                const currentYear = new Date().getFullYear();
                player.Age = player.birth_year ? (currentYear - parseInt(player.birth_year)) : '';
                
                // Convert height from cm to display
                player.Height_Inches = player.height ? parseFloat(player.height) / 2.54 : 0;
                
                // Use the best season (highest GP) as the primary display
                if (player.seasons.length > 0) {
                    const primarySeason = player.seasons[0];
                    Object.assign(player, {
                        season: primarySeason.season,
                        team: primarySeason.team,
                        league: primarySeason.league,
                        GP: primarySeason.GP,
                        MPG: primarySeason.MPG,
                        PPG: primarySeason.PPG,
                        'FG%': primarySeason['FG%'],
                        '3P%': primarySeason['3P%'],
                        'FT%': primarySeason['FT%'],
                        RPG: primarySeason.RPG,
                        APG: primarySeason.APG,
                        SPG: primarySeason.SPG,
                        BPG: primarySeason.BPG,
                        TPG: primarySeason.TPG,
                        // Per-40 minute stats
                        PTS40: primarySeason.PTS40,
                        REB40: primarySeason.REB40,
                        AST40: primarySeason.AST40,
                        STL40: primarySeason.STL40,
                        BLK40: primarySeason.BLK40,
                        TOV40: primarySeason.TOV40
                    });
                }
                
                // Keep track of how many seasons this player has
                player.totalSeasons = player.seasons.length;
                
                jobMarketData.push(player);
            }
            
            // Sort by total GP across all seasons (or primary season GP)
            jobMarketData.sort((a, b) => b.GP - a.GP);
        }
        
        // Helper function to parse shooting stats like "109-206"
        function parseShootingStat(stat) {
            if (!stat || typeof stat !== 'string') return { made: 0, attempted: 0 };
            const parts = stat.split('-');
            return {
                made: parseInt(parts[0]) || 0,
                attempted: parseInt(parts[1]) || 0
            };
        }

        document.getElementById('playerStatsFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                debugLog(`üìä Loading player stats file (${(file.size/1024/1024).toFixed(2)} MB)...`);
                const startTime = performance.now();
                const useWorker = file.size > 5 * 1024 * 1024;
                
                Papa.parse(file, {
                    header: true, 
                    dynamicTyping: true, 
                    skipEmptyLines: true,
                    worker: useWorker,
                    fastMode: false,
                    complete: function(results) {
                        const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
                        debugLog(`‚úì CSV parsed in ${elapsed}s: ${results.data.length} rows`);
                        
                        const validPlayers = [];
                        for (let i = 0; i < results.data.length; i++) {
                            const row = results.data[i];
                            if (row.player_name && row.player_name.trim()) {
                                validPlayers.push(row);
                            }
                        }
                        playerData = validPlayers;
                        
                        debugLog(`‚úì Filtered to ${playerData.length} valid players`);
                        document.getElementById('playerFileName').textContent = `${file.name} (${playerData.length.toLocaleString()} players)`;
                        document.getElementById('playerUploadBox').classList.add('loaded');
                        checkDataLoaded();
                    },
                    error: function(error) { debugLog(`‚úó ERROR loading player stats: ${error.message}`); alert('Error loading player stats file: ' + error.message); }
                });
            }
        });

        document.getElementById('teamTotalsFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                debugLog('üèÜ Loading team totals file...');
                Papa.parse(file, {
                    header: true, 
                    dynamicTyping: true, 
                    skipEmptyLines: true,
                    complete: function(results) {
                        debugLog(`‚úì Team data loaded: ${results.data.length} rows`);
                        const validTeams = [];
                        for (let i = 0; i < results.data.length; i++) {
                            const row = results.data[i];
                            if (row.team && row.team.trim() && row.type === 'Team') {
                                validTeams.push(row);
                            }
                        }
                        teamData = validTeams;
                        debugLog(`‚úì Filtered to ${teamData.length} team records`);
                        document.getElementById('teamFileName').textContent = `${file.name} (${teamData.length} teams)`;
                        document.getElementById('teamUploadBox').classList.add('loaded');
                        checkDataLoaded();
                    },
                    error: function(error) { debugLog(`‚úó ERROR loading team totals: ${error.message}`); alert('Error loading team totals file: ' + error.message); }
                });
            }
        });

        function checkDataLoaded() {
            debugLog(`Checking data: ${playerData.length} players, ${teamData.length} team records`);
            if (playerData.length > 0 && teamData.length > 0) {
                const loadingMsg = playerData.length > 10000 ? 
                    `Processing ${playerData.length.toLocaleString()} players... This may take a moment.` : 
                    'Processing data...';
                showLoadingIndicator(loadingMsg);
                
                setTimeout(() => {
                    try {
                        debugLog('Processing data...');
                        processDataOptimized();
                    } catch (error) { 
                        hideLoadingIndicator();
                        debugLog(`‚úó ERROR processing data: ${error.message}`); 
                        console.error('Full error:', error); 
                        alert('Error processing data: ' + error.message); 
                    }
                }, 50);
            } else { debugLog('‚è≥ Waiting for both files to be uploaded...'); }
        }
        
        function showLoadingIndicator(message) {
            let indicator = document.getElementById('loadingIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'loadingIndicator';
                indicator.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 30px 50px; border-radius: 10px; z-index: 9999; font-size: 16px; text-align: center;';
                document.body.appendChild(indicator);
            }
            indicator.innerHTML = `<div style="margin-bottom: 10px;">‚è≥ ${message}</div><div id="loadingProgress" style="font-size: 12px; color: #aaa;">Starting...</div>`;
            indicator.style.display = 'block';
        }
        
        function updateLoadingProgress(message) {
            const progress = document.getElementById('loadingProgress');
            if (progress) progress.textContent = message;
        }
        
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loadingIndicator');
            if (indicator) indicator.style.display = 'none';
        }

        function processDataOptimized() {
            const startTime = performance.now();
            debugLog('Processing player statistics (optimized)...');
            const total = playerData.length;
            
            function normalizeTeamName(name) {
                if (!name) return '';
                return name.toLowerCase()
                    .replace(/[''`]/g, '')
                    .replace(/[^a-z0-9\s]/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
            }
            
            function getTeamWords(name) {
                const normalized = normalizeTeamName(name);
                const stopWords = new Set(['fc', 'bc', 'kk', 'bk', 'cb', 'de', 'la', 'le', 'el', 'du', 'di', 'da', 'basketball', 'basket', 'club']);
                return normalized.split(' ')
                    .filter(w => w.length >= 2 && !stopWords.has(w));
            }
            
            function calculateTeamMatchScore(playerTeam, teamTotalsTeam) {
                const playerWords = getTeamWords(playerTeam);
                const teamWords = getTeamWords(teamTotalsTeam);
                if (playerWords.length === 0 || teamWords.length === 0) return 0;
                let matchedWords = 0;
                let partialMatches = 0;
                for (const pw of playerWords) {
                    if (teamWords.includes(pw)) { matchedWords++; continue; }
                    for (const tw of teamWords) {
                        if (tw.startsWith(pw) || pw.startsWith(tw)) { partialMatches += 0.7; break; }
                        if (tw.includes(pw) || pw.includes(tw)) { partialMatches += 0.4; break; }
                    }
                }
                return (matchedWords + partialMatches) / playerWords.length;
            }
            
            const rawTeamLookup = new Map();
            for (let i = 0; i < rawTeamData.length; i++) {
                const rt = rawTeamData[i];
                const key = `${rt.league}|${rt.season}|${normalizeTeamName(rt.team)}`;
                rawTeamLookup.set(key, rt);
            }
            
            const rawPlayerLookup = new Map();
            for (let i = 0; i < rawPlayerData.length; i++) {
                const rp = rawPlayerData[i];
                if (rp.player_url) rawPlayerLookup.set(rp.player_url, rp);
                const nameKey = `${rp.player_name}|${rp.team}`;
                if (!rawPlayerLookup.has(nameKey)) rawPlayerLookup.set(nameKey, rp);
            }
            
            function calculatePaceFromStats(t, parseNum, rawTeam = null) {
                const mins = parseNum(t.MIN);
                const fga = parseNum(t.FGA);
                const fta = parseNum(t.FTA);
                const oreb = parseNum(t.OREB);
                let tov = 0;
                if (rawTeam) tov = parseNum(rawTeam.TOV);
                if (mins > 0 && fga > 0) {
                    const basePoss = fga + 0.44 * fta - oreb;
                    if (tov === 0) tov = basePoss * 0.12;
                    const poss = basePoss + tov;
                    const pace = (poss / mins) * 40;
                    return pace;
                }
                return 0;
            }
            
            const teamsByLeagueSeason = new Map();
            const parseNum = (v) => +String(v || 0).replace(/,/g, '');
            
            for (let i = 0; i < teamData.length; i++) {
                const t = teamData[i];
                const key = `${t.league}|${t.season}`;
                if (!teamsByLeagueSeason.has(key)) teamsByLeagueSeason.set(key, []);
                let pace = parseNum(t.PACE);
                if (pace < 50) {
                    const rawKey = `${t.league}|${t.season}|${normalizeTeamName(t.team)}`;
                    const rawTeam = rawTeamLookup.get(rawKey);
                    const calcPace = calculatePaceFromStats(t, parseNum, rawTeam);
                    if (calcPace >= 50 && calcPace <= 90) pace = calcPace;
                }
                teamsByLeagueSeason.get(key).push({ team: t.team, MIN: parseNum(t.MIN), POSS: parseNum(t.POSS), PACE: pace });
            }
            
            function findBestTeam(playerTeam, league, season) {
                const key = `${league}|${season}`;
                const teams = teamsByLeagueSeason.get(key);
                if (!teams || teams.length === 0) return null;
                const normalizedPlayer = normalizeTeamName(playerTeam);
                for (const t of teams) {
                    if (normalizeTeamName(t.team) === normalizedPlayer) return t;
                }
                let bestMatch = null;
                let bestScore = 0.5;
                for (const t of teams) {
                    const score = calculateTeamMatchScore(playerTeam, t.team);
                    if (score > bestScore) { bestScore = score; bestMatch = t; }
                }
                return bestMatch;
            }
            
            let matchedCount = 0;
            let recalculatedCount = 0;
            const unmatchedTeams = new Set();
            
            for (let idx = 0; idx < total; idx++) {
                const player = playerData[idx];
                
                // ==================== MAP CSV COLUMNS TO DISPLAY NAMES ====================
                // Basic shooting percentages
                player['FG%'] = +player.FG_pct || 0;
                player['3P%'] = +player.ThreeP_pct || 0;
                player['FT%'] = +player.FT_pct || 0;
                
                // eFG% - check calculated value first, then decimal form
                const efgCalc = +player.eFG_pct_calc;
                const efgDec = +player.eFG_pct;
                player['eFG%'] = efgCalc > 1 ? efgCalc : (efgDec ? (efgDec < 1 ? efgDec * 100 : efgDec) : 0);
                
                // TS% - check calculated value first, then decimal form
                const tsCalc = +player.TS_pct_calc;
                const tsDec = +player.TS_pct;
                player['TS%'] = tsCalc > 1 ? tsCalc : (tsDec ? (tsDec < 1 ? tsDec * 100 : tsDec) : 0);
                
                // Advanced percentages
                player['USG%'] = +player.USG_pct || 0;
                player['ORB%'] = +player.ORB_pct || 0;
                player['DRB%'] = +player.DRB_pct || 0;
                player['TRB%'] = +player.TRB_pct || 0;
                player['AST%'] = +player.AST_pct || 0;
                
                // Calculate AST/USG ratio (AST% divided by USG%)
                const astPct = player['AST%'];
                const usgPct = player['USG%'];
                player['AST/USG'] = (usgPct > 0) ? (astPct / usgPct) : 0;
                
                // TOV% - check calculated value first
                const tovCalc = +player.TOV_pct_calc;
                player['TOV%'] = tovCalc > 0 ? tovCalc : (+player.TOV_pct || 0);
                
                player['STL%'] = +player.STL_pct || 0;
                player['BLK%'] = +player.BLK_pct || 0;
                
                // FTr (Free Throw rate)
                player.FTr = +player.FT_rate || (+player.FGA > 0 ? +player.FTA / +player.FGA : 0);
                
                // Basic stats
                player.Games = +player.GP || 0;
                player.MPG = +player.MPG || 0;
                player.PPG = +player.PPG || 0;
                
                // Process Age
                player.Age = +player.age || +player.Age || 0;
                
                // Process height
                let heightInches = 0;
                const htRaw = player.Height || player.height || player.Ht;
                if (htRaw) {
                    const htStr = String(htRaw);
                    const ftInMatch = htStr.match(/(\d+)['\-](\d+)/);
                    if (ftInMatch) {
                        heightInches = parseInt(ftInMatch[1]) * 12 + parseInt(ftInMatch[2]);
                    } else {
                        const numHeight = parseFloat(htStr);
                        if (!isNaN(numHeight)) {
                            if (numHeight > 100) heightInches = numHeight / 2.54;
                            else if (numHeight > 0) heightInches = numHeight > 12 ? numHeight : numHeight * 12;
                        }
                    }
                }
                player.Height_Inches = heightInches;
                
                // Process Nationality
                let nationality = '';
                if (rawPlayerData.length > 0) {
                    let rawPlayer = rawPlayerLookup.get(player.player_url);
                    if (!rawPlayer) rawPlayer = rawPlayerLookup.get(`${player.player_name}|${player.team}`);
                    if (rawPlayer && rawPlayer.Nationality) nationality = rawPlayer.Nationality;
                }
                player.Nationality = nationality;
                
                const playerMin = +player.MIN || 0;
                const playerPts = +player.PTS || 0;
                const playerThreePA = +player.ThreePA || 0;
                const team = findBestTeam(player.team, player.league, player.season);
                if (team) matchedCount++;
                
                if (team && team.PACE >= 50 && playerMin > 0) {
                    const playerPoss = playerMin * (team.PACE / 40);
                    const pts100 = (playerPts / playerPoss) * 100;
                    const threepa100 = (playerThreePA / playerPoss) * 100;
                    if (pts100 >= 0 && pts100 <= 150) {
                        player['PTS/100'] = pts100;
                        player['3PA/100'] = threepa100;
                        recalculatedCount++;
                    } else {
                        player['PTS/100'] = +player.PTS_per100 || 0;
                        player['3PA/100'] = +player.ThreePA_per100 || 0;
                    }
                } else {
                    player['PTS/100'] = +player.PTS_per100 || 0;
                    player['3PA/100'] = +player.ThreePA_per100 || 0;
                    if (!team && unmatchedTeams.size < 20) unmatchedTeams.add(`${player.team} (${player.league} ${player.season})`);
                }
                
                player._id = idx;
            }
            
            // BPM Assignment - read from CSV first, store both standard and linear
            for (let idx = 0; idx < total; idx++) {
                const player = playerData[idx];
                
                // Read Standard BPM from CSV
                let bpm = +player.BPM;
                if (isNaN(bpm) || bpm === 0) bpm = estimateBPM(player);
                
                let obpm = +player.OBPM;
                if (isNaN(obpm)) obpm = bpm * 0.6;
                
                let dbpm = +player.DBPM;
                if (isNaN(dbpm)) dbpm = bpm - obpm;
                
                // Store standard BPM values
                player.BPM_Standard = bpm;
                player.OBPM_Standard = obpm;
                player.DBPM_Standard = dbpm;
                
                // Read Linear BPM from CSV (column is named 'Linear_BPM')
                let linearBpm = +player.Linear_BPM;
                
                // If Linear_BPM not available, fall back to standard
                if (isNaN(linearBpm)) linearBpm = bpm;
                
                // Estimate Linear OBPM/DBPM proportionally from standard split
                // If standard BPM exists and is non-zero, use the same O/D ratio
                let linearObpm, linearDbpm;
                if (bpm !== 0 && !isNaN(obpm) && !isNaN(dbpm)) {
                    const obpmRatio = obpm / bpm;
                    const dbpmRatio = dbpm / bpm;
                    linearObpm = linearBpm * obpmRatio;
                    linearDbpm = linearBpm * dbpmRatio;
                } else {
                    linearObpm = linearBpm * 0.6;
                    linearDbpm = linearBpm * 0.4;
                }
                
                // Store linear BPM values
                player.BPM_Linear = linearBpm;
                player.OBPM_Linear = linearObpm;
                player.DBPM_Linear = linearDbpm;
                
                // Set active BPM based on current selection (default to standard)
                player.BPM = player.BPM_Standard;
                player.OBPM = player.OBPM_Standard;
                player.DBPM = player.DBPM_Standard;
                
                // Position estimate from CSV
                const csvPosition = +player.Position_Est;
                if (!isNaN(csvPosition) && csvPosition >= 1 && csvPosition <= 5) {
                    player._estimatedPosition = csvPosition;
                }
                
                // Offensive role from CSV
                const csvRole = +player.Off_Role_Est;
                if (!isNaN(csvRole) && csvRole >= 1 && csvRole <= 5) {
                    player._offensiveRole = csvRole;
                }
            }
            
            updateLoadingProgress('Calculating percentiles...');
            
            // Count how many players have Linear_BPM data
            let linearBpmCount = 0;
            for (const p of playerData) {
                if (p.BPM_Linear !== p.BPM_Standard) linearBpmCount++;
            }
            debugLog(`  Linear BPM data found for ${linearBpmCount}/${total} players`);
            
            preCalculatePercentiles();
            
            updateLoadingProgress('Building filters...');
            const teams = [...new Set(playerData.map(p => p.team))].sort();
            const leagues = [...new Set(playerData.map(p => p.league))].sort();
            const seasons = [...new Set(playerData.map(p => p.season))].sort().reverse();
            
            document.getElementById('totalPlayers').textContent = playerData.length.toLocaleString();
            document.getElementById('totalTeams').textContent = teams.length;
            
            const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
            debugLog(`‚úì Data processing complete in ${elapsed}s`);
            
            updateLoadingProgress('Building UI...');
            createFilters();
            displayData();
            
            // If free agent data is already loaded, do the matching
            if (freeAgentData.length > 0) {
                matchFreeAgentsToPlayerStats();
            }
            
            document.getElementById('statsSummary').style.display = 'flex';
            document.getElementById('filterSection').style.display = 'block';
            document.getElementById('viewModeSection').style.display = 'flex';
            hideLoadingIndicator();
            
            // Auto-collapse upload section after data is loaded
            autoCollapseUploadSection();
        }
        
        function preCalculatePercentiles() {
            const statsToCache = [...coloredStats];
            const startTime = performance.now();
            
            const qualifiedPlayers = playerData.filter(p => {
                const games = p.Games || p.GP || 0;
                const mpg = p.MPG || 0;
                return games >= 3 && mpg >= 5;
            });
            
            debugLog(`Percentile base: ${qualifiedPlayers.length} qualified players (3+ games, 5+ MPG)`);
            
            for (let s = 0; s < statsToCache.length; s++) {
                const stat = statsToCache[s];
                const values = [];
                
                for (let i = 0; i < qualifiedPlayers.length; i++) {
                    const p = qualifiedPlayers[i];
                    const val = p[stat];
                    if (val !== null && val !== undefined && !isNaN(val)) {
                        const mpg = p.MPG || 1;
                        const weight = Math.min(mpg, 30) / 30;
                        values.push({ value: +val, weight: weight });
                    }
                }
                
                if (values.length === 0) { percentileCache[stat] = []; continue; }
                
                values.sort((a, b) => a.value - b.value);
                
                let totalWeight = 0;
                for (let i = 0; i < values.length; i++) totalWeight += values[i].weight;
                
                const boundaries = [];
                let cumulativeWeight = 0;
                for (let i = 0; i < values.length; i++) {
                    boundaries[i] = { value: values[i].value, percentile: (cumulativeWeight / totalWeight) * 100 };
                    cumulativeWeight += values[i].weight;
                }
                
                percentileCache[stat] = boundaries;
            }
            
            const elapsed = (performance.now() - startTime).toFixed(0);
            debugLog(`‚úì Percentiles calculated for ${statsToCache.length} stats in ${elapsed}ms`);
        }
        
        function getPercentileFast(value, stat) {
            const numVal = +value;
            if (isNaN(numVal)) return null;
            const boundaries = percentileCache[stat];
            if (!boundaries || boundaries.length === 0) return null;
            if (isNaN(boundaries[0].value)) return null;
            
            let low = 0, high = boundaries.length - 1;
            if (numVal < boundaries[0].value) return 0;
            if (numVal >= boundaries[high].value) return 100;
            
            while (low < high) {
                const mid = Math.floor((low + high + 1) / 2);
                if (boundaries[mid].value <= numVal) low = mid;
                else high = mid - 1;
            }
            
            return boundaries[low].percentile;
        }

        function createFilters() {
            const filterContainer = document.getElementById('filterContainer');
            filterContainer.innerHTML = '';
            
            // Use appropriate data source based on mode
            let dataSource;
            if (currentViewMode === 'freeagents') {
                dataSource = matchedFreeAgents;
            } else if (currentViewMode === 'jobmarket') {
                dataSource = jobMarketData;
            } else {
                dataSource = playerData;
            }
            
            // === LEAGUE FILTER - Sleek Dropdown ===
            const leagues = [...new Set(dataSource.map(p => p.league))].sort();
            const leagueContainer = document.createElement('div');
            leagueContainer.className = 'league-filter-container';
            leagueContainer.innerHTML = `
                <div class="league-filter-toggle" onclick="toggleLeagueDropdown()">
                    <span>
                        <span class="toggle-text">‚ñº Leagues</span>
                        <span class="toggle-count" id="selectedLeaguesCount">(${leagues.length}/${leagues.length} selected)</span>
                    </span>
                    <span class="toggle-icon">‚ñæ</span>
                </div>
                <div class="league-checkboxes" id="leagueCheckboxes">
                    <div class="league-checkboxes-header">
                        <button type="button" onclick="selectAllLeagues(); event.stopPropagation();">Select All</button>
                        <button type="button" onclick="deselectAllLeagues(); event.stopPropagation();">Deselect All</button>
                    </div>
                    ${leagues.map(l => `
                        <label class="league-checkbox-item">
                            <input type="checkbox" class="league-checkbox" value="${l}" checked onchange="applyFiltersDebounced()">
                            <span>${l}</span>
                        </label>
                    `).join('')}
                </div>
            `;
            filterContainer.appendChild(leagueContainer);
            
            // === PRIMARY FILTERS ROW ===
            const primaryRow = document.createElement('div');
            primaryRow.className = 'filter-row';
            
            // Season filter (for all players mode)
            if (currentViewMode === 'all') {
                const seasons = [...new Set(dataSource.map(p => p.season))].sort().reverse();
                const seasonItem = document.createElement('div');
                seasonItem.className = 'filter-item';
                seasonItem.innerHTML = `<label>Season</label><select id="filter_Season" onchange="applyFilters()"><option value="">All</option>${seasons.map(s => `<option value="${s}">${s}</option>`).join('')}</select>`;
                primaryRow.appendChild(seasonItem);
            }
            
            // Country filter (for free agents)
            if (currentViewMode === 'freeagents') {
                const countries = [...new Set(dataSource.map(p => p.country).filter(c => c && c.trim()))].sort();
                const countryItem = document.createElement('div');
                countryItem.className = 'filter-item';
                countryItem.innerHTML = `<label>Country</label><select id="filter_Country" onchange="applyFilters()"><option value="">All (${countries.length})</option>${countries.map(c => `<option value="${c}">${c}</option>`).join('')}</select>`;
                primaryRow.appendChild(countryItem);
            }
            
            // Nationality filter (for job market mode)
            if (currentViewMode === 'jobmarket') {
                const nationalities = [...new Set(dataSource.map(p => p.nationality).filter(n => n && n.trim()))].sort();
                const natItem = document.createElement('div');
                natItem.className = 'filter-item';
                natItem.innerHTML = `<label>Nationality</label><select id="filter_Nationality" onchange="applyFilters()"><option value="">All (${nationalities.length})</option>${nationalities.map(n => `<option value="${n}">${n}</option>`).join('')}</select>`;
                primaryRow.appendChild(natItem);
                
                // Position filter for job market
                const positions = [...new Set(dataSource.map(p => p.position).filter(p => p && p.trim()))].sort();
                const posItem = document.createElement('div');
                posItem.className = 'filter-item';
                posItem.innerHTML = `<label>Position</label><select id="filter_Position" onchange="applyFilters()"><option value="">All (${positions.length})</option>${positions.map(p => `<option value="${p}">${p}</option>`).join('')}</select>`;
                primaryRow.appendChild(posItem);
            }
            
            // Team filter (not for job market - they have multiple teams per player)
            if (currentViewMode !== 'jobmarket') {
                const teamItem = document.createElement('div');
                teamItem.className = 'filter-item';
                teamItem.innerHTML = `<label>Team</label><select id="filter_Team" onchange="applyFilters()"><option value="">All Teams</option>${[...new Set(dataSource.map(p => p.team))].sort().map(t => `<option value="${t}">${t}</option>`).join('')}</select>`;
                primaryRow.appendChild(teamItem);
            }
            
            // Nationality filter (for all players mode)
            if (currentViewMode === 'all') {
                const nationalities = [...new Set(dataSource.map(p => p.Nationality).filter(n => n && n.trim()))].sort();
                const natItem = document.createElement('div');
                natItem.className = 'filter-item';
                natItem.innerHTML = `<label>Nat</label><select id="filter_Nationality" onchange="applyFilters()"><option value="">All (${nationalities.length})</option>${nationalities.map(n => `<option value="${n}">${n}</option>`).join('')}</select>`;
                primaryRow.appendChild(natItem);
            }
            
            // Height filter with feet/inches dropdowns
            const heightItem = document.createElement('div');
            heightItem.className = 'filter-item';
            heightItem.innerHTML = `
                <label>Height</label>
                <div class="height-filter-group">
                    <select id="filter_min_Ht_ft" onchange="applyFiltersDebounced()"><option value="">-</option><option value="5">5'</option><option value="6">6'</option><option value="7">7'</option></select>
                    <select id="filter_min_Ht_in" onchange="applyFiltersDebounced()"><option value="">-</option>${[...Array(12).keys()].map(i => `<option value="${i}">${i}"</option>`).join('')}</select>
                    <span>to</span>
                    <select id="filter_max_Ht_ft" onchange="applyFiltersDebounced()"><option value="">-</option><option value="5">5'</option><option value="6">6'</option><option value="7">7'</option></select>
                    <select id="filter_max_Ht_in" onchange="applyFiltersDebounced()"><option value="">-</option>${[...Array(12).keys()].map(i => `<option value="${i}">${i}"</option>`).join('')}</select>
                </div>
            `;
            primaryRow.appendChild(heightItem);
            
            filterContainer.appendChild(primaryRow);
            
            // === STAT FILTERS GRID ===
            // Determine which headers to use for stat filters based on mode
            let statFilterHeaders;
            if (currentViewMode === 'jobmarket') {
                statFilterHeaders = ['GP', 'MPG', 'PPG', 'RPG', 'APG', 'SPG', 'BPG', 'TPG', 'FG%', '3P%', 'FT%', 'P/40', 'R/40', 'A/40', 'S/40', 'B/40', 'TO/40'];
            } else {
                statFilterHeaders = headers.slice(5).filter(h => !['Nat', 'Last Game', 'Missed', 'Country', 'Ht'].includes(h));
            }
            
            const statGrid = document.createElement('div');
            statGrid.className = 'stat-filters-grid';
            
            for (const header of statFilterHeaders) {
                const filterKey = getStatKey(header);
                const item = document.createElement('div');
                item.className = 'stat-filter-item';
                item.innerHTML = `<label>${header}</label><input type="number" id="filter_min_${filterKey}" placeholder="Min" step="0.1" oninput="applyFiltersDebounced()"><input type="number" id="filter_max_${filterKey}" placeholder="Max" step="0.1" oninput="applyFiltersDebounced()">`;
                statGrid.appendChild(item);
            }
            filterContainer.appendChild(statGrid);
        }
        
        function toggleLeagueDropdown() {
            const checkboxes = document.getElementById('leagueCheckboxes');
            const toggle = checkboxes.previousElementSibling;
            checkboxes.classList.toggle('show');
            toggle.classList.toggle('open');
        }
        
        // Close league dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const container = document.querySelector('.league-filter-container');
            if (container && !container.contains(e.target)) {
                const checkboxes = document.getElementById('leagueCheckboxes');
                const toggle = checkboxes?.previousElementSibling;
                if (checkboxes) checkboxes.classList.remove('show');
                if (toggle) toggle.classList.remove('open');
            }
        });

        function getStatKey(header) {
            const mapping = { 
                'Age': 'Age', 'Nat': 'Nationality', 'Ht': 'Height_Inches',
                'FG%': 'FG%', '3P%': '3P%', 'FT%': 'FT%', 'eFG%': 'eFG%', 'TS%': 'TS%', 'USG%': 'USG%', 
                'ORB%': 'ORB%', 'DRB%': 'DRB%', 'TRB%': 'TRB%', 'AST%': 'AST%', 'TOV%': 'TOV%', 
                'STL%': 'STL%', 'BLK%': 'BLK%', 'PTS/100': 'PTS/100', '3PA/100': '3PA/100',
                'Pos': '_estimatedPosition', 'Role': '_offensiveRole',
                // Per-40 minute stats
                'P/40': 'PTS40', 'R/40': 'REB40', 'A/40': 'AST40', 'S/40': 'STL40', 'B/40': 'BLK40', 'TO/40': 'TOV40'
            };
            return mapping[header] || header;
        }
        
        function toggleLeagueFilter() {
            // Legacy function - now handled by toggleLeagueDropdown
            toggleLeagueDropdown();
        }
        
        function selectAllLeagues() {
            document.querySelectorAll('.league-checkbox').forEach(cb => cb.checked = true);
            updateLeagueCount();
        }
        
        function deselectAllLeagues() {
            document.querySelectorAll('.league-checkbox').forEach(cb => cb.checked = false);
            updateLeagueCount();
        }
        
        function updateLeagueCount() {
            const checked = document.querySelectorAll('.league-checkbox:checked').length;
            const total = document.querySelectorAll('.league-checkbox').length;
            const countSpan = document.getElementById('selectedLeaguesCount');
            if (countSpan) {
                countSpan.textContent = `(${checked}/${total} selected)`;
            }
        }

        function displayData() {
            debugLog('Preparing display...');
            filteredData = [...playerData];
            debugLog(`Initial data: ${filteredData.length} players`);
            applyFilters();
        }

        function applyFilters() {
            const startTime = performance.now();
            displayLimit = PAGE_SIZE;
            
            // Use appropriate data source based on mode
            let dataSource;
            if (currentViewMode === 'freeagents') {
                dataSource = matchedFreeAgents;
            } else if (currentViewMode === 'jobmarket') {
                dataSource = jobMarketData;
            } else {
                dataSource = playerData;
            }
            const beforeCount = dataSource.length;
            
            // Name search
            const nameSearchEl = document.getElementById('nameSearch');
            const nameSearch = nameSearchEl ? nameSearchEl.value.toLowerCase().trim() : '';
            
            const selectedLeagues = new Set([...document.querySelectorAll('.league-checkbox:checked')].map(cb => cb.value));
            updateLeagueCount();
            
            const seasonFilter = document.getElementById('filter_Season')?.value || '';
            const teamFilter = document.getElementById('filter_Team')?.value || '';
            const nationalityFilter = document.getElementById('filter_Nationality')?.value || '';
            const countryFilter = document.getElementById('filter_Country')?.value || '';
            const positionFilter = document.getElementById('filter_Position')?.value || '';
            
            // Height filter with feet/inches dropdowns
            let minHeightInches = null;
            let maxHeightInches = null;
            const minHtFt = document.getElementById('filter_min_Ht_ft')?.value;
            const minHtIn = document.getElementById('filter_min_Ht_in')?.value;
            const maxHtFt = document.getElementById('filter_max_Ht_ft')?.value;
            const maxHtIn = document.getElementById('filter_max_Ht_in')?.value;
            if (minHtFt !== '' && minHtFt !== undefined) {
                minHeightInches = (parseInt(minHtFt) || 0) * 12 + (parseInt(minHtIn) || 0);
            }
            if (maxHtFt !== '' && maxHtFt !== undefined) {
                maxHeightInches = (parseInt(maxHtFt) || 0) * 12 + (parseInt(maxHtIn) || 0);
            }
            
            // Build numeric filters
            const numericFilters = [];
            let filterHeaders;
            if (currentViewMode === 'jobmarket') {
                filterHeaders = ['GP', 'MPG', 'PPG', 'RPG', 'APG', 'SPG', 'BPG', 'TPG', 'FG%', '3P%', 'FT%', 'P/40', 'R/40', 'A/40', 'S/40', 'B/40', 'TO/40'];
            } else if (currentViewMode === 'freeagents') {
                filterHeaders = headersFreeAgents;
            } else {
                filterHeaders = headersAllPlayers;
            }
            
            const skipHeaders = ['Nat', 'Last Game', 'Missed', 'Country', 'Ht', 'Pos', 'Role', 'üîó', 'Player', 'Team', 'League', 'Season', 'Last Team', 'Last Year', 'Age'];
            for (const header of filterHeaders) {
                if (skipHeaders.includes(header)) continue;
                const statKey = getStatKey(header);
                const minInput = document.getElementById(`filter_min_${statKey}`);
                const maxInput = document.getElementById(`filter_max_${statKey}`);
                // Debug: log if input not found for job market
                if (currentViewMode === 'jobmarket' && !minInput) {
                    debugLog(`Warning: filter_min_${statKey} not found for header ${header}`);
                }
                const minVal = minInput && minInput.value !== '' ? parseFloat(minInput.value) : null;
                const maxVal = maxInput && maxInput.value !== '' ? parseFloat(maxInput.value) : null;
                if (minVal !== null || maxVal !== null) {
                    numericFilters.push({ key: statKey, min: minVal, max: maxVal });
                }
            }
            
            const result = [];
            const total = dataSource.length;
            
            for (let i = 0; i < total; i++) {
                const player = dataSource[i];
                
                // For job market mode, team can be empty for primary row
                if (currentViewMode !== 'jobmarket') {
                    if (!player.team || player.team.trim() === '') continue;
                }
                
                // Name search filter
                if (nameSearch && !(player.player_name || '').toLowerCase().includes(nameSearch)) continue;
                
                if (selectedLeagues.size > 0 && !selectedLeagues.has(player.league)) continue;
                if (seasonFilter && player.season !== seasonFilter) continue;
                if (teamFilter && player.team !== teamFilter) continue;
                
                // Nationality filter - handle both formats
                if (nationalityFilter) {
                    const playerNat = player.Nationality || player.nationality || '';
                    if (playerNat !== nationalityFilter) continue;
                }
                
                if (countryFilter && player.country !== countryFilter) continue;
                if (positionFilter && player.position !== positionFilter) continue;
                
                // Height filter
                if (minHeightInches !== null && (player.Height_Inches || 0) < minHeightInches) continue;
                if (maxHeightInches !== null && (player.Height_Inches || 0) > maxHeightInches) continue;
                
                let pass = true;
                for (let j = 0; j < numericFilters.length; j++) {
                    const f = numericFilters[j];
                    const val = player[f.key];
                    // Debug: log first player's filter check in job market mode
                    if (currentViewMode === 'jobmarket' && i === 0 && j === 0) {
                        debugLog(`Filter check: key=${f.key}, player value=${val}, min=${f.min}, max=${f.max}`);
                    }
                    if (val === null || val === undefined) { pass = false; break; }
                    if (f.min !== null && val < f.min) { pass = false; break; }
                    if (f.max !== null && val > f.max) { pass = false; break; }
                }
                if (!pass) continue;
                
                result.push(player);
            }
            
            // Debug: Log filter count for job market
            if (currentViewMode === 'jobmarket') {
                debugLog(`Job Market filters: ${numericFilters.length} numeric filters active`);
                if (numericFilters.length > 0) {
                    debugLog(`Active filters: ${numericFilters.map(f => `${f.key}(${f.min}-${f.max})`).join(', ')}`);
                }
            }
            
            filteredData = result;
            
            const elapsed = (performance.now() - startTime).toFixed(0);
            const modeLabels = { 'all': 'players', 'freeagents': 'free agents', 'jobmarket': 'job market players' };
            debugLog(`Filters applied in ${elapsed}ms: ${beforeCount.toLocaleString()} ‚Üí ${filteredData.length.toLocaleString()} ${modeLabels[currentViewMode] || 'players'}`);
            document.getElementById('filteredPlayers').textContent = filteredData.length.toLocaleString();
            document.getElementById('statusBar').style.display = 'block';
            document.getElementById('statusRight').textContent = `Filter time: ${elapsed}ms`;
            
            const statusLabels = { 'all': 'üìä All Players View', 'freeagents': 'üîÑ Free Agents View', 'jobmarket': 'üìã Job Market View' };
            document.getElementById('statusLeft').textContent = statusLabels[currentViewMode] || 'üìä All Players View';
            
            renderTable();
        }

        function resetFilters() {
            // Clear name search
            const nameSearchEl = document.getElementById('nameSearch');
            if (nameSearchEl) nameSearchEl.value = '';
            
            document.querySelectorAll('.league-checkbox').forEach(cb => cb.checked = true);
            updateLeagueCount();
            
            const seasonFilter = document.getElementById('filter_Season');
            if (seasonFilter) seasonFilter.value = '';
            const teamFilter = document.getElementById('filter_Team');
            if (teamFilter) teamFilter.value = '';
            const nationalityFilter = document.getElementById('filter_Nationality');
            if (nationalityFilter) nationalityFilter.value = '';
            const countryFilter = document.getElementById('filter_Country');
            if (countryFilter) countryFilter.value = '';
            const positionFilter = document.getElementById('filter_Position');
            if (positionFilter) positionFilter.value = '';
            
            // Clear height filters
            const minHtFt = document.getElementById('filter_min_Ht_ft');
            if (minHtFt) minHtFt.value = '';
            const minHtIn = document.getElementById('filter_min_Ht_in');
            if (minHtIn) minHtIn.value = '';
            const maxHtFt = document.getElementById('filter_max_Ht_ft');
            if (maxHtFt) maxHtFt.value = '';
            const maxHtIn = document.getElementById('filter_max_Ht_in');
            if (maxHtIn) maxHtIn.value = '';
            
            // Determine which headers to use for clearing stat filters
            let filterHeaders;
            if (currentViewMode === 'jobmarket') {
                filterHeaders = ['GP', 'MPG', 'PPG', 'RPG', 'APG', 'SPG', 'BPG', 'TPG', 'FG%', '3P%', 'FT%', 'P/40', 'R/40', 'A/40', 'S/40', 'B/40', 'TO/40'];
            } else if (currentViewMode === 'freeagents') {
                filterHeaders = headersFreeAgents;
            } else {
                filterHeaders = headersAllPlayers;
            }
            
            const skipHeaders = ['Nat', 'Last Game', 'Missed', 'Country', 'Ht', 'Pos', 'Role', 'üîó', 'Player', 'Team', 'League', 'Season', 'Last Team', 'Last Year', 'Age'];
            for (const header of filterHeaders) {
                if (skipHeaders.includes(header)) continue;
                const statKey = getStatKey(header);
                const minInput = document.getElementById(`filter_min_${statKey}`);
                const maxInput = document.getElementById(`filter_max_${statKey}`);
                if (minInput) minInput.value = '';
                if (maxInput) maxInput.value = '';
            }
            applyFilters();
        }

        function renderTable() {
            const startTime = performance.now();
            const total = filteredData.length;
            const toShow = Math.min(displayLimit, total);
            
            debugLog(`Rendering ${toShow.toLocaleString()} of ${total.toLocaleString()} ${currentViewMode === 'freeagents' ? 'free agents' : currentViewMode === 'jobmarket' ? 'job market players' : 'players'}...`);
            
            // Build header
            const headerRow = document.getElementById('tableHeader');
            let headerHTML = '<tr>';
            const bpmSuffix = currentBPMType === 'linear' ? ' (L)' : '';
            for (let i = 0; i < headers.length; i++) {
                let h = headers[i];
                // Add suffix to BPM columns when using Linear BPM
                if (['BPM', 'OBPM', 'DBPM'].includes(h)) {
                    h = h + bpmSuffix;
                }
                let groupClass = 'group-basic';
                if (currentViewMode === 'jobmarket') {
                    // Job Market header groups
                    if (['Last Team', 'Last Year'].includes(headers[i])) groupClass = 'group-job-market';
                    else if (i >= 11 && i <= 14) groupClass = 'group-shooting';
                    else if (i >= 15) groupClass = 'group-advanced';
                } else if (currentViewMode === 'freeagents') {
                    if (['Last Game', 'Missed'].includes(headers[i])) groupClass = 'group-free-agent';
                    else if (i >= 10 && i <= 13) groupClass = 'group-shooting';
                    else if (i >= 14 && i <= 20) groupClass = 'group-advanced';
                    else if (i >= 21) groupClass = 'group-impact';
                } else {
                    if (i >= 8 && i <= 11) groupClass = 'group-shooting';
                    else if (i >= 12 && i <= 17) groupClass = 'group-advanced';
                    else if (i >= 18) groupClass = 'group-impact';
                }
                // Add tooltip to # column
                const titleAttr = (i === 0) ? ' title="Click row # to open Eurobasket page"' : '';
                headerHTML += `<th class="${groupClass}"${titleAttr} onclick="sortTable(${i}, '${headers[i]}')">${h}</th>`;
            }
            headerHTML += '</tr>';
            headerRow.innerHTML = headerHTML;
            
            // Build rows
            const rowsHTML = [];
            const playersToShow = filteredData.slice(0, toShow);
            
            for (let idx = 0; idx < playersToShow.length; idx++) {
                const player = playersToShow[idx];
                if (currentViewMode === 'jobmarket') {
                    rowsHTML.push(buildJobMarketRowHTML(player, idx));
                } else if (currentViewMode === 'freeagents') {
                    rowsHTML.push(buildFreeAgentRowHTML(player, idx));
                } else {
                    rowsHTML.push(buildRowHTML(player, idx));
                }
            }
            
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = rowsHTML.join('');
            
            // Add event listeners for Job Market expandable rows
            if (currentViewMode === 'jobmarket') {
                tbody.querySelectorAll('.jm-expandable').forEach(row => {
                    row.addEventListener('click', function(e) {
                        // Don't toggle if clicking on a link
                        if (e.target.tagName === 'A') return;
                        toggleJobMarketRow(this);
                    });
                });
            }
            
            // Add event listeners
            tbody.querySelectorAll('.player-name').forEach(el => {
                el.addEventListener('click', function(e) {
                    // If it's a link (in job market mode), let the default behavior happen
                    if (this.tagName === 'A') {
                        e.stopPropagation(); // Still prevent row toggle
                        return; // Let the link work
                    }
                    e.stopPropagation(); // Prevent row toggle
                    const idx = parseInt(this.dataset.idx);
                    const player = playersToShow[idx];
                    if (player && currentViewMode !== 'jobmarket') showRadarChart(player);
                });
            });
            
            // Drag and drop (not for job market)
            if (currentViewMode !== 'jobmarket') {
                tbody.querySelectorAll('tr').forEach(row => {
                    row.draggable = true;
                    row.addEventListener('dragstart', handleDragStart);
                    row.addEventListener('dragover', handleDragOver);
                    row.addEventListener('dragleave', handleDragLeave);
                    row.addEventListener('drop', handleDrop);
                    row.addEventListener('dragend', handleDragEnd);
                });
            }
            
            const elapsed = (performance.now() - startTime).toFixed(0);
            debugLog(`‚úì Table rendered in ${elapsed}ms`);
            document.getElementById('statusRight').textContent = `Render time: ${elapsed}ms`;
            
            updateLoadMoreButton();
        }
        
        function buildRowHTML(player, idx) {
            const posDisplay = player._estimatedPosition ? player._estimatedPosition.toFixed(1) : '-';
            const roleDisplay = player._offensiveRole ? player._offensiveRole.toFixed(1) : '-';
            
            // Row number with link to Eurobasket page
            const playerUrl = player.player_url || '';
            const numCell = playerUrl 
                ? `<a href="${playerUrl}" target="_blank" class="row-link" title="Open Eurobasket page">${idx + 1}</a>`
                : `<span style="color: #999; font-size: 10px;">${idx + 1}</span>`;
            
            const ageCell = `<span class="editable-cell" data-player-id="${player._id}" data-field="Age" onclick="startEditingCell(this)">${player.Age || '-'}</span>`;
            const natCell = `<span class="editable-cell" data-player-id="${player._id}" data-field="Nationality" onclick="startEditingCell(this)" style="font-size:10px">${player.Nationality || '-'}</span>`;
            const htCell = `<span class="editable-cell" data-player-id="${player._id}" data-field="Height_Inches" onclick="startEditingCell(this)">${formatHeight(player.Height_Inches)}</span>`;
            
            const cells = [
                numCell,
                `<span style="font-size:10px">${player.league || ''}</span>`,
                `<span style="font-size:10px">${player.season || ''}</span>`,
                `<span class="team-cell">${player.team_abbrev || player.team || ''}</span>`,
                `<span class="player-name" data-idx="${idx}">${player.player_name || ''}</span>`,
                ageCell,
                natCell,
                htCell,
                `<span style="font-size:11px" title="1=PG, 5=C">${posDisplay}</span>`,
                `<span style="font-size:11px" title="1=Primary, 5=Role">${roleDisplay}</span>`,
                player.Games || player.GP || '-',
                formatNumber(player.MPG, 1),
                formatNumber(player.PPG, 1),
                formatNumber(player['FG%'], 1),
                formatNumber(player['3P%'], 1),
                formatNumber(player['FT%'], 1),
                formatNumber(player['eFG%'], 1),
                formatNumber(player['TS%'], 1),
                formatNumber(player['USG%'], 1),
                formatNumber(player['AST/USG'], 2),
                formatNumber(player.FTr, 2),
                formatNumber(player['PTS/100'], 1),
                formatNumber(player['3PA/100'], 1),
                formatNumber(player['ORB%'], 1),
                formatNumber(player['DRB%'], 1),
                formatNumber(player['TRB%'], 1),
                formatNumber(player['AST%'], 1),
                formatNumber(player['TOV%'], 1),
                formatNumber(player['STL%'], 1),
                formatNumber(player['BLK%'], 1),
                formatNumber(player.BPM, 2),
                formatNumber(player.OBPM, 2),
                formatNumber(player.DBPM, 2)
            ];
            
            let html = `<tr data-player-index="${idx}">`;
            for (let i = 0; i < cells.length; i++) {
                let cls = '';
                if (i >= 11 && i < cells.length) {
                    const header = headers[i];
                    if (coloredStatsSet.has(header)) {
                        const value = player[header];
                        const isInverse = inverseStatsSet.has(header);
                        cls = getPercentileClass(value, header, isInverse);
                    }
                }
                html += cls ? `<td class="${cls}">${cells[i]}</td>` : `<td>${cells[i]}</td>`;
            }
            html += '</tr>';
            return html;
        }
        
        function buildFreeAgentRowHTML(player, idx) {
            const posDisplay = player._estimatedPosition ? player._estimatedPosition.toFixed(1) : '-';
            
            // Row number with link to Eurobasket page
            const playerUrl = player.player_url || '';
            const numCell = playerUrl 
                ? `<a href="${playerUrl}" target="_blank" class="row-link" title="Open Eurobasket page">${idx + 1}</a>`
                : `<span style="color: #999; font-size: 10px;">${idx + 1}</span>`;
            
            // Format last known game date
            let lastGameDisplay = '-';
            if (player.last_known_game) {
                const date = new Date(player.last_known_game);
                if (!isNaN(date.getTime())) {
                    lastGameDisplay = `<span class="fa-last-game">${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</span>`;
                } else {
                    lastGameDisplay = `<span class="fa-last-game">${player.last_known_game}</span>`;
                }
            }
            
            // Missed games badge
            const missedGames = player.missed_games || 0;
            const missedDisplay = missedGames > 0 ? `<span class="fa-missed-games">${missedGames}</span>` : '-';
            
            const cells = [
                numCell,
                `<span style="font-size:10px">${player.league || ''}</span>`,
                `<span style="font-size:10px">${player.country || ''}</span>`,
                `<span class="team-cell">${player.team || ''}</span>`,
                `<span class="player-name" data-idx="${idx}">${player.player_name || ''}</span>`,
                player.Age || '-',
                formatHeight(player.Height_Inches),
                `<span style="font-size:11px">${posDisplay}</span>`,
                lastGameDisplay,
                missedDisplay,
                player.Games || player.GP || '-',
                formatNumber(player.MPG, 1),
                formatNumber(player.PPG, 1),
                formatNumber(player['FG%'], 1),
                formatNumber(player['3P%'], 1),
                formatNumber(player['FT%'], 1),
                formatNumber(player['eFG%'], 1),
                formatNumber(player['TS%'], 1),
                formatNumber(player['USG%'], 1),
                formatNumber(player['AST/USG'], 2),
                formatNumber(player.FTr, 2),
                formatNumber(player['PTS/100'], 1),
                formatNumber(player['3PA/100'], 1),
                formatNumber(player['ORB%'], 1),
                formatNumber(player['DRB%'], 1),
                formatNumber(player['TRB%'], 1),
                formatNumber(player['AST%'], 1),
                formatNumber(player['TOV%'], 1),
                formatNumber(player['STL%'], 1),
                formatNumber(player['BLK%'], 1),
                formatNumber(player.BPM, 2),
                formatNumber(player.OBPM, 2),
                formatNumber(player.DBPM, 2)
            ];
            
            let html = `<tr data-player-index="${idx}">`;
            for (let i = 0; i < cells.length; i++) {
                let cls = '';
                // Apply percentile coloring for stat columns (adjusted for free agent headers)
                if (i >= 12 && i < cells.length) {
                    const header = headersFreeAgents[i];
                    if (coloredStatsSet.has(header)) {
                        const value = player[header];
                        const isInverse = inverseStatsSet.has(header);
                        cls = getPercentileClass(value, header, isInverse);
                    }
                }
                html += cls ? `<td class="${cls}">${cells[i]}</td>` : `<td>${cells[i]}</td>`;
            }
            html += '</tr>';
            return html;
        }
        
        // Build Job Market row with collapsible child rows
        function buildJobMarketRowHTML(player, idx) {
            const hasMultipleSeasons = player.seasons && player.seasons.length > 1;
            const expandIcon = hasMultipleSeasons ? `<span class="jm-expand-icon">‚ñ∂</span>` : '';
            const seasonsIndicator = hasMultipleSeasons ? `<span class="jm-seasons-indicator">${player.seasons.length} seasons</span>` : '';
            
            // Row number with link to page
            const playerUrl = player.player_url || '';
            const numCell = playerUrl 
                ? `${expandIcon}<a href="${playerUrl}" target="_blank" class="row-link" title="Open player page">${idx + 1}</a>`
                : `${expandIcon}<span style="color: #999; font-size: 10px;">${idx + 1}</span>`;
            
            // Primary season (highest GP)
            const primarySeason = player.seasons && player.seasons[0] ? player.seasons[0] : player;
            
            // Player name with link to eurobasket page
            const playerNameCell = playerUrl 
                ? `<a href="${playerUrl}" target="_blank" class="player-name player-link" data-idx="${idx}" title="View on Eurobasket">${player.player_name || ''}</a>${seasonsIndicator}`
                : `<span class="player-name" data-idx="${idx}">${player.player_name || ''}</span>${seasonsIndicator}`;
            
            const cells = [
                numCell,
                playerNameCell,
                `<span style="font-size:10px">${player.position || ''}</span>`,
                `<span style="font-size:10px">${player.nationality || ''}</span>`,
                formatHeight(player.Height_Inches),
                player.Age || '-',
                `<span class="jm-last-team">${player.last_team || ''}</span>`,
                `<span class="jm-last-year">${player.last_year_played || ''}</span>`,
                `<span class="jm-season-badge">${primarySeason.season || ''}</span>`,
                `<span style="font-size:10px">${primarySeason.team || ''}</span>`,
                `<span style="font-size:9px">${primarySeason.league || ''}</span>`,
                primarySeason.GP || '-',
                formatNumber(primarySeason.MPG, 1),
                formatNumber(primarySeason.PPG, 1),
                formatNumber(primarySeason.RPG, 1),
                formatNumber(primarySeason.APG, 1),
                formatNumber(primarySeason.SPG, 1),
                formatNumber(primarySeason.BPG, 1),
                formatNumber(primarySeason.TPG, 1),
                formatNumber(primarySeason['FG%'], 1),
                formatNumber(primarySeason['3P%'], 1),
                formatNumber(primarySeason['FT%'], 1),
                // Per-40 minute stats
                formatNumber(primarySeason.PTS40, 1),
                formatNumber(primarySeason.REB40, 1),
                formatNumber(primarySeason.AST40, 1),
                formatNumber(primarySeason.STL40, 1),
                formatNumber(primarySeason.BLK40, 1),
                formatNumber(primarySeason.TOV40, 1)
            ];
            
            const expandableClass = hasMultipleSeasons ? 'jm-expandable' : '';
            let html = `<tr class="${expandableClass}" data-player-index="${idx}" data-player-id="${player.player_url || player.player_name}">`;
            for (let i = 0; i < cells.length; i++) {
                html += `<td>${cells[i]}</td>`;
            }
            html += '</tr>';
            
            // Add child rows for additional seasons (hidden by default)
            if (hasMultipleSeasons) {
                for (let s = 1; s < Math.min(player.seasons.length, 3); s++) {
                    const season = player.seasons[s];
                    html += buildJobMarketChildRowHTML(player, season, idx, s);
                }
            }
            
            return html;
        }
        
        // Build a child row for additional seasons
        function buildJobMarketChildRowHTML(player, season, parentIdx, seasonIdx) {
            const cells = [
                `<span style="color: #6b7280; font-size: 9px;">‚Ü≥</span>`,
                `<span class="player-name" style="opacity: 0.7;">${player.player_name || ''}</span>`,
                '',
                '',
                '',
                '',
                '',
                '',
                `<span class="jm-season-badge" style="opacity: 0.8;">${season.season || ''}</span>`,
                `<span style="font-size:10px">${season.team || ''}</span>`,
                `<span style="font-size:9px">${season.league || ''}</span>`,
                season.GP || '-',
                formatNumber(season.MPG, 1),
                formatNumber(season.PPG, 1),
                formatNumber(season.RPG, 1),
                formatNumber(season.APG, 1),
                formatNumber(season.SPG, 1),
                formatNumber(season.BPG, 1),
                formatNumber(season.TPG, 1),
                formatNumber(season['FG%'], 1),
                formatNumber(season['3P%'], 1),
                formatNumber(season['FT%'], 1),
                // Per-40 minute stats
                formatNumber(season.PTS40, 1),
                formatNumber(season.REB40, 1),
                formatNumber(season.AST40, 1),
                formatNumber(season.STL40, 1),
                formatNumber(season.BLK40, 1),
                formatNumber(season.TOV40, 1)
            ];
            
            let html = `<tr class="jm-child-row" data-parent-idx="${parentIdx}" data-season-idx="${seasonIdx}">`;
            for (let i = 0; i < cells.length; i++) {
                html += `<td>${cells[i]}</td>`;
            }
            html += '</tr>';
            return html;
        }
        
        // Toggle visibility of child rows
        function toggleJobMarketRow(row) {
            const idx = row.dataset.playerIndex;
            const isExpanded = row.classList.contains('expanded');
            
            // Find all child rows for this parent
            const childRows = document.querySelectorAll(`tr.jm-child-row[data-parent-idx="${idx}"]`);
            
            if (isExpanded) {
                row.classList.remove('expanded');
                childRows.forEach(child => child.classList.remove('visible'));
            } else {
                row.classList.add('expanded');
                childRows.forEach(child => child.classList.add('visible'));
            }
        }
        
        function startEditingCell(cell) {
            const playerId = parseInt(cell.dataset.playerId);
            const field = cell.dataset.field;
            const dataSource = (currentViewMode === 'freeagents') ? freeAgentData : playerData;
            const player = dataSource.find(p => p._id === playerId);
            if (!player) return;
            
            cell.classList.add('editing');
            const originalValue = cell.textContent;
            
            let inputClass = 'edit-input';
            let inputValue = '';
            let placeholder = '';
            
            if (field === 'Age') { inputValue = player.Age || ''; placeholder = 'Age'; }
            else if (field === 'Nationality') { inputClass += ' nat-input'; inputValue = player.Nationality || ''; placeholder = 'NAT'; }
            else if (field === 'Height_Inches') {
                inputClass += ' ht-input';
                const inches = player.Height_Inches;
                if (inches && inches > 0) {
                    const feet = Math.floor(inches / 12);
                    const remainingInches = Math.round(inches % 12);
                    inputValue = `${feet}'${remainingInches}`;
                }
                placeholder = "6'5";
            }
            
            cell.innerHTML = `<input type="text" class="${inputClass}" value="${inputValue}" placeholder="${placeholder}">`;
            const input = cell.querySelector('input');
            input.focus();
            input.select();
            
            input.onblur = function() { finishEditingCell(cell, player, field, input.value, originalValue); };
            input.onkeydown = function(e) {
                if (e.key === 'Enter') input.blur();
                else if (e.key === 'Escape') { cell.classList.remove('editing'); cell.innerHTML = originalValue; }
            };
        }
        
        function finishEditingCell(cell, player, field, newValue, originalValue) {
            cell.classList.remove('editing');
            let displayValue = '-';
            let dataValue = null;
            
            if (field === 'Age') {
                const parsed = parseInt(newValue);
                if (!isNaN(parsed) && parsed > 0 && parsed < 100) { player.Age = parsed; dataValue = parsed; displayValue = parsed; }
                else if (newValue.trim() === '') { player.Age = 0; displayValue = '-'; }
                else { displayValue = originalValue; }
            } else if (field === 'Nationality') {
                const trimmed = newValue.trim().toUpperCase();
                if (trimmed.length > 0 && trimmed.length <= 5) { player.Nationality = trimmed; dataValue = trimmed; displayValue = trimmed; }
                else if (trimmed === '') { player.Nationality = ''; displayValue = '-'; }
                else { displayValue = originalValue; }
            } else if (field === 'Height_Inches') {
                let heightInches = 0;
                const trimmed = newValue.trim();
                const ftInMatch = trimmed.match(/(\d+)['\-](\d+)/);
                if (ftInMatch) heightInches = parseInt(ftInMatch[1]) * 12 + parseInt(ftInMatch[2]);
                else {
                    const numHeight = parseFloat(trimmed);
                    if (!isNaN(numHeight)) {
                        if (numHeight > 100) heightInches = numHeight / 2.54;
                        else if (numHeight > 0) heightInches = numHeight > 12 ? numHeight : numHeight * 12;
                    }
                }
                if (heightInches > 0) { player.Height_Inches = heightInches; dataValue = heightInches; displayValue = formatHeight(heightInches); }
                else if (trimmed === '') { player.Height_Inches = 0; displayValue = '-'; }
                else { displayValue = originalValue; }
            }
            
            if (field === 'Nationality') cell.innerHTML = `<span style="font-size:10px">${displayValue}</span>`;
            else cell.textContent = displayValue;
            
            if (dataValue !== null) cell.classList.add('edited');
        }
        
        function updateLoadMoreButton() {
            let loadMoreContainer = document.getElementById('loadMoreContainer');
            if (!loadMoreContainer) {
                loadMoreContainer = document.createElement('div');
                loadMoreContainer.id = 'loadMoreContainer';
                loadMoreContainer.style.cssText = 'text-align: center; padding: 15px; background: #161b22; border: 1px solid #30363d; border-radius: 8px; margin: 15px 30px;';
                document.querySelector('.table-container').after(loadMoreContainer);
            }
            
            const showing = Math.min(displayLimit, filteredData.length);
            const total = filteredData.length;
            const remaining = total - showing;
            
            document.getElementById('displayedPlayers').textContent = showing.toLocaleString();
            
            const modeLabels = { 'all': 'players', 'freeagents': 'free agents', 'jobmarket': 'job market players' };
            const modeLabel = modeLabels[currentViewMode] || 'players';
            
            if (remaining > 0) {
                loadMoreContainer.innerHTML = `
                    <span style="margin-right: 15px; color: #8b949e;">Showing ${showing.toLocaleString()} of ${total.toLocaleString()} ${modeLabel}</span>
                    <button onclick="loadMorePlayers()">Load ${Math.min(PAGE_SIZE, remaining).toLocaleString()} More</button>
                    <button onclick="loadAllPlayers()" style="margin-left: 10px; background: rgba(88, 166, 255, 0.15); border-color: #58a6ff; color: #58a6ff;">Load All (${remaining.toLocaleString()})</button>
                `;
                loadMoreContainer.style.display = 'block';
            } else {
                loadMoreContainer.innerHTML = `<span style="color: #8b949e;">Showing all ${total.toLocaleString()} ${modeLabel}</span>`;
                loadMoreContainer.style.display = total > PAGE_SIZE ? 'block' : 'none';
            }
        }
        
        function loadMorePlayers() { displayLimit += PAGE_SIZE; renderTable(); }
        function loadAllPlayers() {
            const remaining = filteredData.length - displayLimit;
            if (remaining > 10000 && !confirm(`Loading ${remaining.toLocaleString()} more rows may slow your browser. Continue?`)) return;
            displayLimit = filteredData.length;
            renderTable();
        }

        // Export View - Generate Player Cards
        function generateExportCards() {
            const count = parseInt(document.getElementById('exportPlayerCount').value) || 20;
            const dataSource = (previousViewMode === 'freeagents') ? matchedFreeAgents : playerData;
            
            // Use current filtered data if available, otherwise use full data
            const sourceData = filteredData.length > 0 ? filteredData : dataSource;
            const topPlayers = sourceData.slice(0, count);
            
            // Use custom title if set, otherwise generate default
            const titleInput = document.getElementById('exportTitleInput');
            const customTitle = titleInput.value.trim();
            if (!customTitle) {
                const modeText = previousViewMode === 'freeagents' ? 'Free Agents' : 'Players';
                titleInput.value = `Top ${topPlayers.length} ${modeText}`;
            }
            document.getElementById('exportTitle').textContent = titleInput.value;
            
            // Use subtitle input value
            const subtitleInput = document.getElementById('exportSubtitleInput');
            document.getElementById('exportSubtitle').textContent = subtitleInput.value || `${currentBPMType === 'linear' ? 'Linear' : 'Standard'} BPM ‚Ä¢ Advanced Stats`;
            
            const grid = document.getElementById('playerCardsGrid');
            grid.innerHTML = '';
            
            topPlayers.forEach((player, idx) => {
                const card = createPlayerCard(player, idx);
                grid.appendChild(card);
            });
            
            // Apply dynamic name scaling after cards are rendered
            requestAnimationFrame(() => {
                scalePlayerNames();
            });
            
            debugLog(`Generated ${topPlayers.length} export cards`);
        }
        
        // Dynamic name scaling to fit container
        function scalePlayerNames() {
            const cards = document.querySelectorAll('.player-card');
            
            cards.forEach(card => {
                const nameEl = card.querySelector('.card-player-name');
                const teamEl = card.querySelector('.card-player-team');
                const container = card.querySelector('.card-player-info');
                
                if (!container) return;
                const maxWidth = container.offsetWidth - 2;
                
                // Scale player name
                if (nameEl) {
                    scaleTextToFit(nameEl, maxWidth, 13, 8);
                }
                
                // Scale team name
                if (teamEl) {
                    scaleTextToFit(teamEl, maxWidth, 10, 7);
                }
            });
        }
        
        function scaleTextToFit(element, maxWidth, baseFontSize, minFontSize) {
            // Reset to base size first
            element.style.fontSize = baseFontSize + 'px';
            
            // Create a temporary span to measure text width
            const measureSpan = document.createElement('span');
            measureSpan.style.cssText = `
                position: absolute;
                visibility: hidden;
                white-space: nowrap;
                font-family: inherit;
                font-weight: ${getComputedStyle(element).fontWeight};
                letter-spacing: ${getComputedStyle(element).letterSpacing};
                text-transform: ${getComputedStyle(element).textTransform};
            `;
            measureSpan.textContent = element.textContent;
            document.body.appendChild(measureSpan);
            
            let fontSize = baseFontSize;
            measureSpan.style.fontSize = fontSize + 'px';
            
            // Reduce font size until text fits or we hit minimum
            while (measureSpan.offsetWidth > maxWidth && fontSize > minFontSize) {
                fontSize -= 0.5;
                measureSpan.style.fontSize = fontSize + 'px';
            }
            
            // Apply the calculated font size
            element.style.fontSize = fontSize + 'px';
            
            // Clean up
            document.body.removeChild(measureSpan);
        }
        
        // Rescale names on window resize
        window.addEventListener('resize', () => {
            if (currentViewMode === 'export') {
                scalePlayerNames();
            }
        });
        
        function updateExportTitle() {
            const titleInput = document.getElementById('exportTitleInput');
            document.getElementById('exportTitle').textContent = titleInput.value || 'Top Players';
        }
        
        function updateExportSubtitle() {
            const subtitleInput = document.getElementById('exportSubtitleInput');
            document.getElementById('exportSubtitle').textContent = subtitleInput.value || 'Advanced Stats';
        }
        
        function createPlayerCard(player, idx) {
            const card = document.createElement('div');
            card.className = 'player-card';
            card.dataset.playerIdx = idx;
            
            // Get stat values - use the same field names as main table (player['TS%'] etc.)
            const ts = player['TS%'] ?? 0;
            const usg = player['USG%'] ?? 0;
            const threeP = player['3P%'] ?? 0;
            const threePAper100 = player['3PA/100'] ?? 0;
            const ftr = player.FTr ?? 0;
            const orb = player['ORB%'] ?? 0;
            const drb = player['DRB%'] ?? 0;
            const trb = player['TRB%'] ?? 0;
            const ast = player['AST%'] ?? 0;
            const tov = player['TOV%'] ?? 0;
            const stl = player['STL%'] ?? 0;
            const blk = player['BLK%'] ?? 0;
            const bpm = player.BPM ?? 0;
            const obpm = player.OBPM ?? 0;
            const dbpm = player.DBPM ?? 0;
            
            // Get color classes for stats - use same keys as percentileCache (e.g. 'TS%', 'USG%')
            const getStatColorClass = (value, stat, inverse = false) => {
                return getPercentileClass(value, stat, inverse);
            };
            
            // BPM color class - use percentile classes
            const getBPMColorClass = (value, stat = 'BPM') => {
                return getPercentileClass(value, stat, false);
            };
            
            // Build card HTML
            card.innerHTML = `
                <div class="card-header">
                    <div class="player-photo-placeholder" onclick="uploadPlayerPhoto(${idx})" title="Click to add photo">
                        <input type="file" accept="image/*" style="display:none" onchange="handlePhotoUpload(event, ${idx})">
                    </div>
                    <div class="card-player-info">
                        <div class="card-player-name" title="${player.player_name || ''}">${player.player_name || 'Unknown'}</div>
                        <div class="card-player-team">${player.team_abbrev || player.team || ''}</div>
                        <div class="card-player-meta">${player.Age || '-'} yrs ‚Ä¢ ${formatHeight(player.Height_Inches) || '-'}</div>
                    </div>
                    <button class="card-remove-btn" onclick="removePlayerCard(this)" title="Remove card">√ó</button>
                </div>
                <div class="card-stats">
                    <div class="card-stat-category efficiency">
                        <div class="card-stat">
                            <span class="card-stat-label">TS%</span>
                            <span class="card-stat-value ${getStatColorClass(ts, 'TS%')}">${ts.toFixed(1)}</span>
                        </div>
                        <div class="card-stat">
                            <span class="card-stat-label">USG%</span>
                            <span class="card-stat-value ${getStatColorClass(usg, 'USG%')}">${usg.toFixed(1)}</span>
                        </div>
                    </div>
                    <div class="card-stat-category shooting">
                        <div class="card-stat">
                            <span class="card-stat-label">3P%</span>
                            <span class="card-stat-value ${getStatColorClass(threeP, '3P%')}">${threeP.toFixed(1)}</span>
                        </div>
                        <div class="card-stat">
                            <span class="card-stat-label">3PA/100</span>
                            <span class="card-stat-value ${getStatColorClass(threePAper100, '3PA/100')}">${threePAper100.toFixed(1)}</span>
                        </div>
                    </div>
                    <div class="card-stat-category freethrows">
                        <div class="card-stat">
                            <span class="card-stat-label">FTr</span>
                            <span class="card-stat-value ${getStatColorClass(ftr, 'FTr')}">${ftr.toFixed(2)}</span>
                        </div>
                    </div>
                    <div class="card-stat-category rebounding">
                        <div class="card-stat">
                            <span class="card-stat-label">ORB%</span>
                            <span class="card-stat-value ${getStatColorClass(orb, 'ORB%')}">${orb.toFixed(1)}</span>
                        </div>
                        <div class="card-stat">
                            <span class="card-stat-label">DRB%</span>
                            <span class="card-stat-value ${getStatColorClass(drb, 'DRB%')}">${drb.toFixed(1)}</span>
                        </div>
                        <div class="card-stat">
                            <span class="card-stat-label">TRB%</span>
                            <span class="card-stat-value ${getStatColorClass(trb, 'TRB%')}">${trb.toFixed(1)}</span>
                        </div>
                    </div>
                    <div class="card-stat-category playmaking">
                        <div class="card-stat">
                            <span class="card-stat-label">AST%</span>
                            <span class="card-stat-value ${getStatColorClass(ast, 'AST%')}">${ast.toFixed(1)}</span>
                        </div>
                        <div class="card-stat">
                            <span class="card-stat-label">TOV%</span>
                            <span class="card-stat-value ${getStatColorClass(tov, 'TOV%', true)}">${tov.toFixed(1)}</span>
                        </div>
                    </div>
                    <div class="card-stat-category defense">
                        <div class="card-stat">
                            <span class="card-stat-label">STL%</span>
                            <span class="card-stat-value ${getStatColorClass(stl, 'STL%')}">${stl.toFixed(1)}</span>
                        </div>
                        <div class="card-stat">
                            <span class="card-stat-label">BLK%</span>
                            <span class="card-stat-value ${getStatColorClass(blk, 'BLK%')}">${blk.toFixed(1)}</span>
                        </div>
                    </div>
                </div>
                <div class="card-bpm-section">
                    <div class="card-bpm-title">Box Plus/Minus${currentBPMType === 'linear' ? ' (Linear)' : ''}</div>
                    ${currentBPMType === 'linear' ? `
                        <div class="card-bpm-values">
                            <div class="card-bpm-item">
                                <div class="card-bpm-value card-bpm-single ${getBPMColorClass(bpm, 'BPM')}">${bpm >= 0 ? '+' : ''}${bpm.toFixed(1)}</div>
                            </div>
                        </div>
                    ` : `
                        <div class="card-bpm-values">
                            <div class="card-bpm-item">
                                <div class="card-bpm-label">OBPM</div>
                                <div class="card-bpm-value ${getBPMColorClass(obpm, 'OBPM')}">${obpm >= 0 ? '+' : ''}${obpm.toFixed(1)}</div>
                            </div>
                            <div class="card-bpm-item">
                                <div class="card-bpm-label">DBPM</div>
                                <div class="card-bpm-value ${getBPMColorClass(dbpm, 'DBPM')}">${dbpm >= 0 ? '+' : ''}${dbpm.toFixed(1)}</div>
                            </div>
                            <div class="card-bpm-item">
                                <div class="card-bpm-label">BPM</div>
                                <div class="card-bpm-value ${getBPMColorClass(bpm, 'BPM')}">${bpm >= 0 ? '+' : ''}${bpm.toFixed(1)}</div>
                            </div>
                        </div>
                    `}
                </div>
            `;
            
            return card;
        }
        
        function uploadPlayerPhoto(idx) {
            const card = document.querySelector(`.player-card[data-player-idx="${idx}"]`);
            const input = card.querySelector('input[type="file"]');
            input.click();
        }
        
        function removePlayerCard(btn) {
            const card = btn.closest('.player-card');
            if (card) {
                card.style.transition = 'all 0.3s ease';
                card.style.transform = 'scale(0.8)';
                card.style.opacity = '0';
                setTimeout(() => {
                    card.remove();
                }, 300);
            }
        }
        
        function handlePhotoUpload(event, idx) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const card = document.querySelector(`.player-card[data-player-idx="${idx}"]`);
                const placeholder = card.querySelector('.player-photo-placeholder');
                
                // Remove the ::before pseudo-element by adding an image
                let img = placeholder.querySelector('img');
                if (!img) {
                    img = document.createElement('img');
                    placeholder.appendChild(img);
                }
                img.src = e.target.result;
                placeholder.style.setProperty('--show-icon', 'none');
            };
            reader.readAsDataURL(file);
        }

        function getPercentileClass(value, stat, inverse = false) {
            if (value === null || value === undefined || isNaN(value)) return '';
            const percentile = getPercentileFast(value, stat);
            if (percentile === null) return '';
            
            // Apply inverse logic for stats where lower is better (like TOV%)
            const effectivePercentile = inverse ? 100 - percentile : percentile;
            
            // Map to new pct-* classes
            if (effectivePercentile >= 90) return 'pct-90';
            if (effectivePercentile >= 80) return 'pct-80';
            if (effectivePercentile >= 70) return 'pct-70';
            if (effectivePercentile >= 60) return 'pct-60';
            if (effectivePercentile >= 40) return 'pct-50';
            if (effectivePercentile >= 30) return 'pct-40';
            if (effectivePercentile >= 20) return 'pct-30';
            if (effectivePercentile >= 10) return 'pct-20';
            return 'pct-10';
        }

        function formatNumber(num, decimals = 1) {
            if (num === null || num === undefined || isNaN(num)) return '-';
            return Number(num).toFixed(decimals);
        }
        
        function formatHeight(inches) {
            if (!inches || isNaN(inches) || inches <= 0) return '-';
            const feet = Math.floor(inches / 12);
            const remainingInches = Math.round(inches % 12);
            return `${feet}'${remainingInches}"`;
        }

        function sortTable(columnIndex, header) {
            const startTime = performance.now();
            
            if (sortColumn === columnIndex) sortAscending = !sortAscending;
            else { sortColumn = columnIndex; sortAscending = false; }
            
            const key = headerKeyMap[header] || header;
            if (key === null) return;
            
            const asc = sortAscending;
            const isNumeric = !['player_name', 'team', 'league', 'season', 'country', 'last_known_game'].includes(key);
            
            if (isNumeric) {
                filteredData.sort((a, b) => {
                    const aVal = a[key] || 0;
                    const bVal = b[key] || 0;
                    return asc ? aVal - bVal : bVal - aVal;
                });
            } else {
                filteredData.sort((a, b) => {
                    const aVal = a[key] || '';
                    const bVal = b[key] || '';
                    return asc ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                });
            }
            
            const elapsed = (performance.now() - startTime).toFixed(0);
            debugLog(`Sort by ${header} (${asc ? 'asc' : 'desc'}): ${elapsed}ms`);
            renderTable();
        }

        function handleDragStart(e) { draggedRow = this; this.classList.add('dragging'); e.dataTransfer.effectAllowed = 'move'; }
        function handleDragOver(e) { if (e.preventDefault) e.preventDefault(); e.dataTransfer.dropEffect = 'move'; this.classList.add('drop-target'); return false; }
        function handleDragLeave(e) { this.classList.remove('drop-target'); }
        function handleDrop(e) {
            if (e.stopPropagation) e.stopPropagation();
            this.classList.remove('drop-target');
            if (draggedRow !== this) {
                const draggedIndex = parseInt(draggedRow.dataset.playerIndex);
                const targetIndex = parseInt(this.dataset.playerIndex);
                mergePlayers(draggedIndex, targetIndex);
            }
            return false;
        }
        function handleDragEnd(e) { this.classList.remove('dragging'); document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target')); }

        function mergePlayers(index1, index2) {
            const player1 = filteredData[index1];
            const player2 = filteredData[index2];
            if (player1.team !== player2.team || player1.league !== player2.league) { alert('Cannot merge players from different teams or leagues!'); return; }
            if (!confirm(`Merge ${player1.player_name} and ${player2.player_name}?`)) return;
            
            const merged = {
                league: player1.league,
                season: player1.season || player2.season,
                country: player1.country || player2.country,
                team: player1.team,
                team_abbrev: player1.team_abbrev,
                player_name: `${player1.player_name} + ${player2.player_name}`,
                GP: (player1.GP || 0) + (player2.GP || 0),
                Games: (player1.Games || player1.GP || 0) + (player2.Games || player2.GP || 0),
                MIN: (player1.MIN || 0) + (player2.MIN || 0),
                PTS: (player1.PTS || 0) + (player2.PTS || 0),
                FGM: (player1.FGM || 0) + (player2.FGM || 0),
                FGA: (player1.FGA || 0) + (player2.FGA || 0),
                ThreePM: (player1.ThreePM || 0) + (player2.ThreePM || 0),
                ThreePA: (player1.ThreePA || 0) + (player2.ThreePA || 0),
                FTM: (player1.FTM || 0) + (player2.FTM || 0),
                FTA: (player1.FTA || 0) + (player2.FTA || 0),
                OREB: (player1.OREB || 0) + (player2.OREB || 0),
                DREB: (player1.DREB || 0) + (player2.DREB || 0),
                REB: (player1.REB || 0) + (player2.REB || 0),
                AST: (player1.AST || 0) + (player2.AST || 0),
                STL: (player1.STL || 0) + (player2.STL || 0),
                BLK: (player1.BLK || 0) + (player2.BLK || 0),
                TOV: (player1.TOV || 0) + (player2.TOV || 0),
                PF: (player1.PF || 0) + (player2.PF || 0),
                isFreeAgent: player1.isFreeAgent || player2.isFreeAgent
            };
            recalculateAdvancedStats(merged);
            filteredData[index1] = merged;
            filteredData.splice(index2, 1);
            
            const dataSource = (currentViewMode === 'freeagents') ? freeAgentData : playerData;
            const mainIndex1 = dataSource.findIndex(p => p.player_name === player1.player_name && p.team === player1.team && p.league === player1.league);
            const mainIndex2 = dataSource.findIndex(p => p.player_name === player2.player_name && p.team === player2.team && p.league === player2.league);
            if (mainIndex1 !== -1 && mainIndex2 !== -1) {
                dataSource[mainIndex1] = merged;
                dataSource.splice(mainIndex2, 1);
            }
            renderTable();
        }

        function recalculateAdvancedStats(player) {
            calculateBasicStats(player);
            player.BPM = estimateBPM(player);
            player.OBPM = player.BPM * 0.6;
            player.DBPM = player.BPM * 0.4;
        }

        function calculateBasicStats(player) {
            const games = player.Games || player.GP || 1;
            player.Games = games;
            player.MPG = games > 0 ? (player.MIN || 0) / games : 0;
            player.PPG = games > 0 ? (player.PTS || 0) / games : 0;
            const fga = player.FGA || 0;
            const fgm = player.FGM || 0;
            const threePM = player.ThreePM || 0;
            const threePA = player.ThreePA || 0;
            const ftm = player.FTM || 0;
            const fta = player.FTA || 0;
            player['FG%'] = fga > 0 ? (fgm / fga * 100) : 0;
            player['3P%'] = threePA > 0 ? (threePM / threePA * 100) : 0;
            player['FT%'] = fta > 0 ? (ftm / fta * 100) : 0;
            player['eFG%'] = fga > 0 ? ((fgm + 0.5 * threePM) / fga * 100) : 0;
            const tsa = fga + 0.44 * fta;
            const pts = player.PTS || 0;
            player['TS%'] = tsa > 0 ? (pts / (2 * tsa) * 100) : 0;
            const tov = player.TOV || 0;
            const tovDenom = fga + 0.44 * fta + tov;
            player['TOV%'] = tovDenom > 0 ? (tov / tovDenom * 100) : 0;
            player.FTr = fga > 0 ? (fta / fga) : 0;
            const poss = fga + 0.44 * fta + tov;
            player['PTS/100'] = poss > 0 ? (pts / poss) * 100 : 0;
            player['3PA/100'] = poss > 0 ? (threePA / poss) * 100 : 0;
            const min = player.MIN || 0;
            if (min > 0) {
                const possUsed = fga + 0.44 * fta + tov;
                const estTeamPoss = (min / 40) * 100;
                player['USG%'] = estTeamPoss > 0 ? (possUsed / estTeamPoss) * 100 : 0;
            } else { player['USG%'] = 0; }
        }

        function estimateBPM(player) {
            const per100 = player['PTS/100'] || 0;
            const tsPercent = player['TS%'] || 50;
            const astPercent = player['AST%'] || 0;
            const trbPercent = player['TRB%'] || 0;
            const stlPercent = player['STL%'] || 0;
            const blkPercent = player['BLK%'] || 0;
            const tovPercent = player['TOV%'] || 0;
            let bpm = (per100 - 15) * 0.2;
            bpm += (tsPercent - 50) * 0.15;
            bpm += (astPercent - 15) * 0.1;
            bpm += (trbPercent - 10) * 0.05;
            bpm += (stlPercent - 2) * 0.3;
            bpm += (blkPercent - 2) * 0.2;
            bpm -= (tovPercent - 15) * 0.1;
            return bpm;
        }

        let radarChartInstance = null;
        const segmentBackgroundPlugin = {
            id: 'segmentBackground',
            beforeDraw: (chart) => {
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const centerX = (chartArea.left + chartArea.right) / 2;
                const centerY = (chartArea.top + chartArea.bottom) / 2;
                const segments = [
                    { start: 0, end: 1, color: 'rgba(255, 87, 34, 0.25)', label: 'Efficiency' },
                    { start: 2, end: 3, color: 'rgba(76, 175, 80, 0.25)', label: 'Rebounding' },
                    { start: 4, end: 5, color: 'rgba(33, 150, 243, 0.25)', label: 'Playmaking' },
                    { start: 6, end: 7, color: 'rgba(156, 39, 176, 0.25)', label: 'Defense' },
                    { start: 8, end: 8, color: 'rgba(233, 30, 99, 0.25)', label: 'Shooting' },
                    { start: 9, end: 9, color: 'rgba(96, 125, 139, 0.25)', label: 'Impact' }
                ];
                segments.forEach(segment => {
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    const startAngle = chart.scales.r.getIndexAngle(segment.start) - Math.PI / 2;
                    const endAngle = chart.scales.r.getIndexAngle(segment.end + 1) - Math.PI / 2;
                    const radius = chart.scales.r.drawingArea;
                    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    ctx.lineTo(centerX, centerY);
                    ctx.closePath();
                    ctx.fillStyle = segment.color;
                    ctx.fill();
                    ctx.restore();
                    const labelAngle = (startAngle + endAngle) / 2;
                    const labelRadius = radius * 0.35;
                    const labelX = centerX + labelRadius * Math.cos(labelAngle);
                    const labelY = centerY + labelRadius * Math.sin(labelAngle);
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.font = 'bold 11px "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(segment.label, labelX, labelY);
                    ctx.restore();
                });
            }
        };

        function showRadarChart(player) {
            const modal = document.getElementById('radarModal');
            const playerName = document.getElementById('modalPlayerName');
            const teamDisplay = player.team || '';
            const statusDisplay = player.isFreeAgent ? ' üîÑ Free Agent' : '';
            const bpmTypeDisplay = currentBPMType === 'linear' ? ' [Linear BPM]' : '';
            playerName.textContent = `${player.player_name} (${teamDisplay})${statusDisplay}${bpmTypeDisplay}`;
            
            const stats = ['TS%', 'USG%', 'ORB%', 'DRB%', 'AST%', 'TOV%', 'STL%', 'BLK%', '3P%', 'BPM'];
            const radarData = stats.map(stat => {
                const value = player[stat];
                return getPercentileValue(value, stat);
            });
            
            const data = {
                labels: stats.map(s => s === 'TOV%' ? 'TOV% (inv)' : s),
                datasets: [{
                    label: player.player_name,
                    data: radarData,
                    fill: true,
                    backgroundColor: player.isFreeAgent ? 'rgba(230, 81, 0, 0.4)' : 'rgba(255, 87, 34, 0.4)',
                    borderColor: player.isFreeAgent ? 'rgba(230, 81, 0, 1)' : 'rgba(255, 87, 34, 1)',
                    pointBackgroundColor: player.isFreeAgent ? 'rgba(230, 81, 0, 1)' : 'rgba(255, 87, 34, 1)',
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: player.isFreeAgent ? 'rgba(230, 81, 0, 1)' : 'rgba(255, 87, 34, 1)',
                    borderWidth: 3,
                    pointRadius: 6,
                    pointHoverRadius: 9,
                    pointBorderWidth: 2
                }]
            };
            
            const config = {
                type: 'radar',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top', labels: { font: { size: 16, weight: 'bold' }, color: '#fff', padding: 20 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: { size: 14, weight: 'bold' },
                            bodyFont: { size: 13 },
                            padding: 12,
                            callbacks: {
                                label: function(context) {
                                    const label = stats[context.dataIndex];
                                    const value = context.parsed.r;
                                    return `${label}: ${value.toFixed(1)}th percentile`;
                                }
                            }
                        }
                    },
                    elements: { line: { borderWidth: 3, tension: 0.1 } },
                    scales: {
                        r: {
                            min: 0, max: 100, beginAtZero: true,
                            ticks: { stepSize: 20, callback: function(value) { return value + '%'; }, font: { size: 13, weight: 'bold' }, color: '#fff', backdropColor: 'rgba(0, 0, 0, 0.5)', backdropPadding: 4 },
                            pointLabels: { font: { size: 15, weight: 'bold' }, color: '#000', padding: 12 },
                            grid: { color: 'rgba(255, 255, 255, 0.3)', lineWidth: 2 },
                            angleLines: { color: 'rgba(255, 255, 255, 0.3)', lineWidth: 2 }
                        }
                    }
                },
                plugins: [segmentBackgroundPlugin]
            };
            
            if (radarChartInstance) radarChartInstance.destroy();
            const canvas = document.getElementById('radarChart');
            const ctx = canvas.getContext('2d');
            radarChartInstance = new Chart(ctx, config);
            modal.style.display = 'block';
        }

        function getPercentileValue(value, stat) {
            if (value === null || value === undefined || isNaN(value)) return 0;
            const inverse = inverseStats.includes(stat);
            const percentile = getPercentileFast(value, stat);
            if (percentile === null) return 0;
            return inverse ? (100 - percentile) : percentile;
        }

        const closeBtn = document.querySelector('.close');
        if (closeBtn) closeBtn.onclick = function() { document.getElementById('radarModal').style.display = 'none'; }
        window.onclick = function(event) {
            const modal = document.getElementById('radarModal');
            if (event.target === modal) modal.style.display = 'none';
        }

        // ========================================
        // PARENT APP INTEGRATION (SLB Tauri App)
        // ========================================
        // Listen for data files from parent app (launcher.js)
        window.addEventListener('message', async function(event) {
            // Validate message source
            if (!event.data || event.data.source !== 'slb-parent-app') {
                return;
            }

            console.log('[InternationalBartTorvik] Received message from parent:', event.data.type);

            if (event.data.type === 'DATA_FILES_INFO') {
                const { dataFiles, dataDate, appType } = event.data;

                if (!dataFiles || !Array.isArray(dataFiles)) {
                    console.error('[InternationalBartTorvik] Invalid data files received');
                    return;
                }

                debugLog(`üì° Receiving data from parent app (${dataDate || 'unknown date'})...`);

                // Map file names to their corresponding handlers
                const fileHandlers = {
                    'player_stats.csv': async (url) => {
                        debugLog('üîÑ Loading player_stats.csv from GitHub...');
                        const response = await fetch(url);
                        const text = await response.text();
                        return new Promise((resolve) => {
                            Papa.parse(text, {
                                header: true,
                                skipEmptyLines: true,
                                complete: function(results) {
                                    playerData = results.data.filter(row => row.player_name && row.player_name.trim());
                                    debugLog(`‚úì Loaded ${playerData.length} players from player_stats.csv`);
                                    document.getElementById('playerFileName').textContent = `‚úì player_stats.csv (${playerData.length} players)`;
                                    document.getElementById('playerUploadBox').classList.add('loaded');
                                    resolve(true);
                                },
                                error: function(err) {
                                    debugLog(`‚ùå Error parsing player_stats.csv: ${err.message}`);
                                    resolve(false);
                                }
                            });
                        });
                    },
                    'team_totals.csv': async (url) => {
                        debugLog('üîÑ Loading team_totals.csv from GitHub...');
                        const response = await fetch(url);
                        const text = await response.text();
                        return new Promise((resolve) => {
                            Papa.parse(text, {
                                header: true,
                                skipEmptyLines: true,
                                complete: function(results) {
                                    teamData = results.data.filter(row => row.team && row.team.trim());
                                    debugLog(`‚úì Loaded ${teamData.length} teams from team_totals.csv`);
                                    document.getElementById('teamFileName').textContent = `‚úì team_totals.csv (${teamData.length} teams)`;
                                    document.getElementById('teamUploadBox').classList.add('loaded');
                                    resolve(true);
                                },
                                error: function(err) {
                                    debugLog(`‚ùå Error parsing team_totals.csv: ${err.message}`);
                                    resolve(false);
                                }
                            });
                        });
                    },
                    'raw_team_stats.csv': async (url) => {
                        debugLog('üîÑ Loading raw_team_stats.csv from GitHub...');
                        const response = await fetch(url);
                        const text = await response.text();
                        return new Promise((resolve) => {
                            Papa.parse(text, {
                                header: true,
                                skipEmptyLines: true,
                                complete: function(results) {
                                    rawTeamData = results.data.filter(row => row.team && row.team.trim());
                                    debugLog(`‚úì Loaded ${rawTeamData.length} raw team records`);
                                    document.getElementById('rawTeamFileName').textContent = `‚úì raw_team_stats.csv (${rawTeamData.length} games)`;
                                    document.getElementById('rawTeamUploadBox').classList.add('loaded');
                                    resolve(true);
                                },
                                error: function(err) {
                                    debugLog(`‚ùå Error parsing raw_team_stats.csv: ${err.message}`);
                                    resolve(false);
                                }
                            });
                        });
                    },
                    'raw_player_stats.csv': async (url) => {
                        debugLog('üîÑ Loading raw_player_stats.csv from GitHub...');
                        const response = await fetch(url);
                        const text = await response.text();
                        return new Promise((resolve) => {
                            Papa.parse(text, {
                                header: true,
                                skipEmptyLines: true,
                                complete: function(results) {
                                    rawPlayerData = results.data.filter(row => row.player_name && row.player_name.trim());
                                    debugLog(`‚úì Loaded ${rawPlayerData.length} raw player records`);
                                    document.getElementById('rawPlayerFileName').textContent = `‚úì raw_player_stats.csv (${rawPlayerData.length} records)`;
                                    document.getElementById('rawPlayerUploadBox').classList.add('loaded');
                                    resolve(true);
                                },
                                error: function(err) {
                                    debugLog(`‚ùå Error parsing raw_player_stats.csv: ${err.message}`);
                                    resolve(false);
                                }
                            });
                        });
                    }
                };

                try {
                    // Load files in parallel
                    const loadPromises = [];

                    for (const fileInfo of dataFiles) {
                        const handler = fileHandlers[fileInfo.name];
                        if (handler) {
                            loadPromises.push(handler(fileInfo.url));
                        } else {
                            console.log(`[InternationalBartTorvik] No handler for file: ${fileInfo.name}`);
                        }
                    }

                    // Wait for all files to load
                    await Promise.all(loadPromises);

                    // Process data if we have the minimum required files
                    if (playerData.length > 0 && teamData.length > 0) {
                        debugLog('üìä Processing loaded data...');
                        processDataOptimized();

                        // Auto-collapse upload section since data loaded automatically
                        autoCollapseUploadSection();

                        debugLog(`‚úÖ Data loading complete! ${playerData.length} players ready.`);

                        // Send acknowledgment back to parent
                        if (window.parent !== window) {
                            window.parent.postMessage({
                                source: 'slb-child-app',
                                type: 'DATA_LOADED',
                                appType: appType,
                                playerCount: playerData.length,
                                teamCount: teamData.length
                            }, '*');
                        }
                    } else {
                        debugLog('‚ö†Ô∏è Missing required data files (player_stats.csv and team_totals.csv)');
                    }

                } catch (error) {
                    console.error('[InternationalBartTorvik] Error loading data files:', error);
                    debugLog(`‚ùå Error loading data: ${error.message}`);
                }
            }
        });

        // Notify parent that this app is ready to receive data
        if (window.parent !== window) {
            window.parent.postMessage({
                source: 'slb-child-app',
                type: 'APP_READY',
                appType: 'international-bart-torvik'
            }, '*');
            console.log('[InternationalBartTorvik] Sent APP_READY to parent');
        }
    </script>
</body>
</html>
